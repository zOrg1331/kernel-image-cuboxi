From: Amerigo Wang <amwang@redhat.com>
Date: Thu, 13 Jan 2011 11:45:06 -0500
Subject: [misc] add bootmem_debug kernel parameter
Message-id: <4D2EE5C2.3000506@redhat.com>
Patchwork-id: 31822
O-Subject: [v2 RHEL5 Patch 1/2] Add "bootmem_debug" kernel parameter
Bugzilla: 662102
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

BZ:
https://bugzilla.redhat.com/show_bug.cgi?id=662102
(This patch is not to fix this bug, but to debug it.)

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=3030217

Description:

This patch add "bootmem_debug" to RHEL5, so that we can debug
crashkernel reservation failures.

Upstream status:

        commit 80a914dc05683ecfc98f9e1887fd6564846ffbec
        Author: Harvey Harrison <harvey.harrison@gmail.com>
        Date:   Wed Oct 15 22:01:25 2008 -0700

            misc: replace __FUNCTION__ with __func__

        commit 2e5237daf0cc3c8d87762f53f704dc54fa91dcf6
        Author: Johannes Weiner <hannes@saeurebad.de>
        Date:   Wed Jul 23 21:28:02 2008 -0700

            bootmem: add debugging framework

Plus the parse_cmdline_early() piece for RHEL5 only.

Test status:
I can get the desired debugging messages after this patch.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 2814c1d..5c2c271 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -341,6 +341,8 @@ running once the system is up.
 	blkmtd_bs=
 	blkmtd_count=
 
+	bootmem_debug   [KNL] Enable bootmem allocator debug messages.
+
 	bttv.card=	[HW,V4L] bttv (bt848 + bt878 based grabber cards)
 	bttv.radio=	Most important insmod options are available as
 			kernel args too.
diff --git a/arch/i386/kernel/setup.c b/arch/i386/kernel/setup.c
index d5e4fa6..9414905 100644
--- a/arch/i386/kernel/setup.c
+++ b/arch/i386/kernel/setup.c
@@ -158,6 +158,7 @@ extern void early_cpu_init(void);
 extern void generic_apic_probe(char *);
 extern int root_mountflags;
 extern int avoid_smi;
+extern int bootmem_debug;
 
 unsigned long saved_videomode;
 
@@ -829,6 +830,9 @@ static void __init parse_cmdline_early (char ** cmdline_p)
 			}
 		}
 
+		else if (!memcmp(from, "bootmem_debug", 13))
+			bootmem_debug = 1;
+
 		else if (!memcmp(from, "noexec=", 7))
 			noexec_setup(from + 7);
 
diff --git a/arch/x86_64/kernel/setup.c b/arch/x86_64/kernel/setup.c
index 5860db9..b7232bf 100644
--- a/arch/x86_64/kernel/setup.c
+++ b/arch/x86_64/kernel/setup.c
@@ -127,6 +127,7 @@ struct e820map e820;
 
 extern int root_mountflags;
 extern int avoid_smi;
+extern int bootmem_debug;
 
 char command_line[COMMAND_LINE_SIZE];
 
@@ -392,6 +393,9 @@ static __init void parse_cmdline_early (char ** cmdline_p)
 			parse_memmapopt(from+7, &from);
 		}
 
+		if (!memcmp(from, "bootmem_debug", 13))
+			bootmem_debug = 1;
+
 #ifdef CONFIG_NUMA
 		if (!memcmp(from, "numa=", 5))
 			numa_setup(from+5); 
diff --git a/arch/x86_64/mm/numa.c b/arch/x86_64/mm/numa.c
index 9555dc8..c7992da 100644
--- a/arch/x86_64/mm/numa.c
+++ b/arch/x86_64/mm/numa.c
@@ -18,10 +18,6 @@
 #include <asm/numa.h>
 #include <asm/acpi.h>
 
-#ifndef Dprintk
-#define Dprintk(x...)
-#endif
-
 struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;
 bootmem_data_t plat_node_bdata[MAX_NUMNODES];
 
@@ -134,8 +130,10 @@ void __init setup_node_bootmem(int nodeid, unsigned long start, unsigned long en
 	end_pfn = end >> PAGE_SHIFT;
 
 	node_data[nodeid] = early_node_mem(nodeid, start, end, pgdat_size);
-	if (node_data[nodeid] == NULL)
+	if (node_data[nodeid] == NULL) {
+		printk(KERN_DEBUG "setup_node_bootmem: fails to allocate memory for node_data\n");
 		return;
+	}
 	nodedata_phys = __pa(node_data[nodeid]);
 
 	memset(NODE_DATA(nodeid), 0, sizeof(pg_data_t));
@@ -152,10 +150,11 @@ void __init setup_node_bootmem(int nodeid, unsigned long start, unsigned long en
 		if (nodedata_phys < start || nodedata_phys >= end)
 			free_bootmem((unsigned long)node_data[nodeid],pgdat_size);
 		node_data[nodeid] = NULL;
+		printk(KERN_DEBUG "setup_node_bootmem: fails to allocate memory for bootmap\n");
 		return;
 	}
 	bootmap_start = __pa(bootmap);
-	Dprintk("bootmap start %lu pages %lu\n", bootmap_start, bootmap_pages); 
+	printk(KERN_DEBUG "bootmap start %lx pages %lu\n", bootmap_start, bootmap_pages);
 	
 	bootmap_size = init_bootmem_node(NODE_DATA(nodeid),
 					 bootmap_start >> PAGE_SHIFT, 
@@ -181,8 +180,8 @@ void __init setup_node_zones(int nodeid)
  	start_pfn = node_start_pfn(nodeid);
  	end_pfn = node_end_pfn(nodeid);
 
-	Dprintk(KERN_INFO "Setting up node %d %lx-%lx\n",
-		nodeid, start_pfn, end_pfn);
+	printk(KERN_DEBUG "Setting up node %d %lx-%lx\n",
+	       nodeid, start_pfn, end_pfn);
 
 	/* Try to allocate mem_map at end to not fill up precious <4GB
 	   memory. */
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 72ea5e2..fff1fb9 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -41,6 +41,22 @@ static LIST_HEAD(bdata_list);
 unsigned long saved_max_pfn;
 #endif
 
+int bootmem_debug = 0;
+
+static int __init bootmem_debug_setup(char *buf)
+{
+	bootmem_debug = 1;
+	return 0;
+}
+early_param("bootmem_debug", bootmem_debug_setup);
+
+#define bdebug(fmt, args...) ({				\
+	if (unlikely(bootmem_debug))			\
+		printk(KERN_INFO			\
+			"bootmem::%s " fmt,		\
+			__func__, ## args);		\
+})
+
 /* return the number of _pages_ that will be allocated for the boot bitmap */
 unsigned long __init bootmem_bootmap_pages (unsigned long pages)
 {
@@ -95,6 +111,9 @@ static unsigned long __init init_bootmem_core (pg_data_t *pgdat,
 	 */
 	memset(bdata->node_bootmem_map, 0xff, mapsize);
 
+	bdebug("nid=%d start=%lx map=%lx end=%lx mapsize=%lx\n",
+		pgdat->node_id, start, mapstart, end, mapsize);
+
 	return mapsize;
 }
 
@@ -113,8 +132,10 @@ static int __init can_reserve_bootmem_core(bootmem_data_t *bdata,
 
 	/* out of range, don't hold other */
 	if (addr + size < bdata->node_boot_start ||
-		PFN_DOWN(addr) > bdata->node_low_pfn)
+		PFN_DOWN(addr) > bdata->node_low_pfn) {
+		bdebug("out of range: addr=%lx size=%lx flags=%x\n", addr, size, flags);
 		return 0;
+	}
 
 	/*
 	 * Round up to index to the range.
@@ -132,6 +153,8 @@ static int __init can_reserve_bootmem_core(bootmem_data_t *bdata,
 		if (test_bit(i, bdata->node_bootmem_map)) {
 			if (flags & BOOTMEM_EXCLUSIVE)
 				return -EBUSY;
+			bdebug("silent double reserve of PFN %lx\n",
+				i + bdata->node_boot_start);
 		}
 	}
 
@@ -165,9 +188,7 @@ static int __init reserve_bootmem_core(bootmem_data_t *bdata,
 
 	for (i = sidx; i < eidx; i++) {
 		if (test_and_set_bit(i, bdata->node_bootmem_map)) {
-#ifdef CONFIG_DEBUG_BOOTMEM
-			printk("hm, page %08lx reserved twice.\n", i*PAGE_SIZE);
-#endif
+			bdebug("hm, page %08lx reserved twice.\n", i*PAGE_SIZE);
 		}
 	}
 	return 0;
@@ -224,6 +245,9 @@ __alloc_bootmem_core(struct bootmem_data *bdata, unsigned long size,
 	unsigned long i, start = 0, incr, eidx, end_pfn = bdata->node_low_pfn;
 	void *ret;
 
+	bdebug("size=%lx [%lu pages] align=%lx goal=%lx limit=%lx\n",
+		size, PAGE_ALIGN(size) >> PAGE_SHIFT, align, goal, limit);
+
 	if(!size) {
 		printk("__alloc_bootmem_core(): zero-sized request\n");
 		BUG();
@@ -352,6 +376,10 @@ static unsigned long __init free_all_bootmem_core(pg_data_t *pgdat)
 	pfn = bdata->node_boot_start >> PAGE_SHIFT;
 	idx = bdata->node_low_pfn - (bdata->node_boot_start >> PAGE_SHIFT);
 	map = bdata->node_bootmem_map;
+
+	bdebug("nid=%d start_pfn=%lx map=%lx low_fn=%lx\n",
+		pgdat->node_id, pfn, virt_to_phys(map), bdata->node_low_pfn);
+
 	/* Check physaddr is O(LOG2(BITS_PER_LONG)) page aligned */
 	if (bdata->node_boot_start == 0 ||
 	    ffs(bdata->node_boot_start) - PAGE_SHIFT > ffs(BITS_PER_LONG))
@@ -398,6 +426,8 @@ static unsigned long __init free_all_bootmem_core(pg_data_t *pgdat)
 	total += count;
 	bdata->node_bootmem_map = NULL;
 
+	bdebug("nid=%d released=%lx\n", pgdat->node_id, total);
+
 	return total;
 }
 
@@ -411,6 +441,7 @@ int __init reserve_bootmem_node (pg_data_t *pgdat, unsigned long physaddr,
 {
 	int ret;
 
+	bdebug("nid=%d\n addr=%lx size=%lx flags=%lx\n", pgdat->node_id, physaddr, size, flags);
 	ret = can_reserve_bootmem_core(pgdat->bdata, physaddr, size, flags);
 	if (ret < 0)
 		return ret;
@@ -442,6 +473,7 @@ int __init reserve_bootmem (unsigned long addr, unsigned long size,
 	bootmem_data_t *bdata;
 	int ret;
 
+	bdebug("addr=%lx size=%lx flags=%lx\n", addr, size, flags);
 	list_for_each_entry(bdata, &bdata_list, list) {
 		ret = can_reserve_bootmem_core(bdata, addr, size, flags);
 		if (ret < 0)
@@ -493,6 +525,7 @@ void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size, unsigne
 {
 	void *ptr;
 
+	bdebug("nid=%d\n", pgdat->node_id);
 	ptr = __alloc_bootmem_core(pgdat->bdata, size, align, goal, 0);
 	if (ptr)
 		return (ptr);
