From: Hendrik Brueckner <brueckner@redhat.com>
Date: Fri, 29 Oct 2010 15:49:09 -0400
Subject: [s390] cio: prevent panic in I/O cancel function
Message-id: <20101029154908.GA16929@redhat.com>
Patchwork-id: 28988
O-Subject: [RHEL5.6 PATCH 1/1] [s390x] cio: prevent kernel panic in I/O
	cancel function
Bugzilla: 647807
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Description
-----------
A kernel panic occurs with the following text:
"Can't stop I/O on subchannel" when a ccw device is set offline or removed.

Linux function ccw_device_cancel_halt_clear is used to cancel an
outstanding I/O function when a ccw device is set offline or
removed. Depending on the state of the subchannel, the function
performs different I/O commands multiple times. If all attempts
to cancel the I/O failed, a kernel panic is triggered. When
a CLEAR SUBCHANNEL function is active a the subchannel while the
function is called the first time, a kernel panic is immediately
triggered because of a missing initialization of the retry
counter.

Add initialization of the retry counter. Also remove the kernel
panic when I/O could not be cancelled because this is a non-fatal
malfunction.

Bugzilla
--------
BZ 647807
https://bugzilla.redhat.com/show_bug.cgi?id=647807

Upstream status of the patch
----------------------------
The patch is upstream as of kernel version 2.6.37
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=376ae4752e3a387d41a2ba9c9ea45c2df625e6e4

Test status
-----------
The patch has been tested and fixes the problem.
The fix has been verified by the IBM test department.


diff --git a/drivers/s390/cio/device.c b/drivers/s390/cio/device.c
index 1366749..928efe8 100644
--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@ -1031,6 +1031,7 @@ io_subchannel_shutdown(struct subchannel *sch)
 	if (cdev->handler)
 		cdev->handler(cdev, cdev->private->intparm,
 			      ERR_PTR(-EIO));
+	cdev->private->iretry = 255;
 	ret = ccw_device_cancel_halt_clear(cdev);
 	if (ret == -EBUSY) {
 		ccw_device_set_timeout(cdev, HZ/10);
diff --git a/drivers/s390/cio/device_fsm.c b/drivers/s390/cio/device_fsm.c
index c38ca2f..5234ca9 100644
--- a/drivers/s390/cio/device_fsm.c
+++ b/drivers/s390/cio/device_fsm.c
@@ -254,7 +254,10 @@ ccw_device_cancel_halt_clear(struct ccw_device *cdev)
 		ret = cio_clear (sch);
 		return (ret == 0) ? -EBUSY : ret;
 	}
-	panic("Can't stop i/o on subchannel.\n");
+	/* Function was unsuccessful */
+	CIO_MSG_EVENT(0, "0.%x.%04x: could not stop I/O\n",
+		      cdev->private->ssid, cdev->private->devno);
+	return -EIO;
 }
 
 static int
@@ -616,6 +619,7 @@ ccw_device_recog_timeout(struct ccw_device *cdev, enum dev_event dev_event)
 		ccw_device_recog_done(cdev, DEV_STATE_BOXED);
 		break;
 	case -ENODEV:
+	case -EIO:
 		ccw_device_recog_done(cdev, DEV_STATE_NOT_OPER);
 		break;
 	default:
@@ -778,6 +782,7 @@ ccw_device_onoff_timeout(struct ccw_device *cdev, enum dev_event dev_event)
 		ccw_device_done(cdev, DEV_STATE_BOXED);
 		break;
 	case -ENODEV:
+	case -EIO:
 		ccw_device_done(cdev, DEV_STATE_NOT_OPER);
 		break;
 	default:
@@ -898,13 +903,14 @@ ccw_device_online_timeout(struct ccw_device *cdev, enum dev_event dev_event)
 	int ret;
 
 	ccw_device_set_timeout(cdev, 0);
+	cdev->private->iretry = 255;
 	ret = ccw_device_cancel_halt_clear(cdev);
 	if (ret == -EBUSY) {
 		ccw_device_set_timeout(cdev, 3*HZ);
 		cdev->private->state = DEV_STATE_TIMEOUT_KILL;
 		return;
 	}
-	if (ret == -ENODEV)
+	if (ret)
 		dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
 	else if (cdev->handler)
 		cdev->handler(cdev, cdev->private->intparm,
@@ -1020,6 +1026,7 @@ void device_kill_io(struct subchannel *sch)
 	int ret;
 	struct ccw_device *cdev = sch->dev.driver_data;
 
+	cdev->private->iretry = 255;
 	ret = ccw_device_cancel_halt_clear(cdev);
 	if (ret == -EBUSY) {
 		ccw_device_set_timeout(cdev, 3*HZ);
@@ -1065,6 +1072,7 @@ ccw_device_wait4io_timeout(struct ccw_device *cdev, enum dev_event dev_event)
 
 	sch = to_subchannel(cdev->dev.parent);
 	ccw_device_set_timeout(cdev, 0);
+	cdev->private->iretry = 255;
 	ret = ccw_device_cancel_halt_clear(cdev);
 	if (ret == -EBUSY) {
 		ccw_device_set_timeout(cdev, 3*HZ);
@@ -1216,6 +1224,7 @@ ccw_device_quiesce_timeout(struct ccw_device *cdev, enum dev_event dev_event)
 		wake_up(&cdev->private->wait_q);
 		break;
 	case -ENODEV:
+	case -EIO:
 		cdev->private->state = DEV_STATE_NOT_OPER;
 		wake_up(&cdev->private->wait_q);
 		break;
