From: Matthew Garrett <mjg@redhat.com>
Date: Tue, 19 Aug 2008 13:20:31 +0100
Subject: [acpi] increase deep idle state residency on platforms
Message-id: 20080819122031.GA20478@srcf.ucam.org
O-Subject: [RHEL5 patch] BZ#455447 - FEAT: RHEL 5.3: (1/2) Increase deep idle state residency on idle platforms using Nehalem class processors
Bugzilla: 455447

2.6.18 is poor at aggressively moving into deeper C states. If C1 is
entered on a system that supports mwait, then it will remain in C1 until
a reschedule occurs. This patch avoids that case - the CPU will remain
in C1 for one tick and then the situation will be reevaluated, allowing
more time to be spent in the deeper C states. There's no significant
transition cost between C1 and C0, so this should prove entirely
harmless.

diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index a80065f..ce47f96 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -247,10 +247,7 @@ static void acpi_processor_idle(void)
 
 	cx = pr->power.state;
 	if (!cx) {
-		if (pm_idle_save)
-			pm_idle_save();
-		else
-			acpi_safe_halt();
+		acpi_safe_halt();
 		return;
 	}
 
@@ -340,13 +337,8 @@ static void acpi_processor_idle(void)
 	case ACPI_STATE_C1:
 		/*
 		 * Invoke C1.
-		 * Use the appropriate idle routine, the one that would
-		 * be used without acpi C-states.
 		 */
-		if (pm_idle_save)
-			pm_idle_save();
-		else
-			acpi_safe_halt();
+		acpi_safe_halt();
 
 		/*
 		 * TBD: Can't get time duration while in C1, as resumes
