From: Doug Ledford <dledford@redhat.com>
Date: Fri, 12 Mar 2010 20:10:55 -0500
Subject: [net] mlx4: pass attributes down to vlan interfaces
Message-id: <4B9A9FCF.1080706@redhat.com>
Patchwork-id: 23563
O-Subject: [Patch RHEL5.5] update to vlan attributes patch
Bugzilla: 573098
RH-Acked-by: Andy Gospodarek <gospo@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>

This was taken into the -191 kernel, however it turns out that the patch
I submitted was missing an element that is needed for full effect.
Specifically, the patch didn't catch all the places at which the vlan
setting can be enabled and did not, therefore, pass the settings down to
child interfaces all the time.  Secondly, on the child vlan interfaces
in particular, we need to make sure we are running with lockless tx
enabled or the extra locking overhead is problematic.  This patch adds
these two bits and completes this original patch.  The #ifdef
HAVE_NETDEV_VLAN_FEATURES is because upstream solved this issue in a
slightly different way and Mellanox is maintaining the driver in a way
that is compatible with both this backported vlan features setting stuff
we have and the upstream way of doing things.

https://bugzilla.redhat.com/show_bug.cgi?id=573098

Same patch as before.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/net/mlx4/en_ethtool.c b/drivers/net/mlx4/en_ethtool.c
index e0ff25f..0c05e5f 100644
--- a/drivers/net/mlx4/en_ethtool.c
+++ b/drivers/net/mlx4/en_ethtool.c
@@ -34,6 +34,7 @@
 #include <linux/kernel.h>
 #include <linux/ethtool.h>
 #include <linux/netdevice.h>
+#include <linux/if_vlan.h>
 
 #include "mlx4_en.h"
 #include "en_port.h"
@@ -70,8 +71,35 @@ static int mlx4_en_set_tso(struct net_device *dev, u32 data)
 		if (!priv->mdev->LSO_support)
 			return -EPERM;
 		dev->features |= (NETIF_F_TSO | NETIF_F_TSO6);
-	} else
+#ifdef HAVE_NETDEV_VLAN_FEATURES
+		dev->vlan_features |= (NETIF_F_TSO | NETIF_F_TSO6);
+#else
+		if (priv->vlgrp) {
+			int i;
+			struct net_device *vdev;
+			for (i = 0; i < VLAN_GROUP_ARRAY_LEN; i++) {
+				vdev = vlan_group_get_device(priv->vlgrp, i);
+				vdev->features |= (NETIF_F_TSO | NETIF_F_TSO6);
+				vlan_group_set_device(priv->vlgrp, i, vdev);
+			}
+		}
+#endif
+	} else {
 		dev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+#ifdef HAVE_NETDEV_VLAN_FEATURES
+		dev->vlan_features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+#else
+		if (priv->vlgrp) {
+			int i;
+			struct net_device *vdev;
+			for (i = 0; i < VLAN_GROUP_ARRAY_LEN; i++) {
+				vdev = vlan_group_get_device(priv->vlgrp, i);
+				vdev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+				vlan_group_set_device(priv->vlgrp, i, vdev);
+			}
+		}
+#endif
+	}
 	return 0;
 }
 
diff --git a/drivers/net/mlx4/en_netdev.c b/drivers/net/mlx4/en_netdev.c
index 96db9bf..8bd08df 100644
--- a/drivers/net/mlx4/en_netdev.c
+++ b/drivers/net/mlx4/en_netdev.c
@@ -68,6 +68,9 @@ static void mlx4_en_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	struct mlx4_en_dev *mdev = priv->mdev;
 	int err;
+#ifndef HAVE_NETDEV_VLAN_FEATURES
+	struct net_device *vdev;
+#endif
 
 	if (!priv->vlgrp)
 		return;
@@ -83,6 +86,13 @@ static void mlx4_en_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
 			en_err(priv, "Failed configuring VLAN filter\n");
 	}
 	mutex_unlock(&mdev->state_lock);
+
+#ifndef HAVE_NETDEV_VLAN_FEATURES
+	vdev = vlan_group_get_device(priv->vlgrp, vid);
+	vdev->features |= dev->features;
+	vdev->features |= NETIF_F_LLTX;
+	vlan_group_set_device(priv->vlgrp, vid, vdev);
+#endif
 }
 
 static void mlx4_en_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
@@ -1097,7 +1107,12 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	 */
 	dev->features |= NETIF_F_SG;
 	dev->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+#ifdef HAVE_NETDEV_VLAN_FEATURES
+	dev->vlan_features |= NETIF_F_SG;
+	dev->vlan_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+#else
 	dev->features |= NETIF_F_VLAN_CSUM;
+#endif
 	dev->features |= NETIF_F_HIGHDMA;
 	dev->features |= NETIF_F_HW_VLAN_TX |
 			 NETIF_F_HW_VLAN_RX |
@@ -1107,7 +1122,12 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	if (mdev->LSO_support) {
 		dev->features |= NETIF_F_TSO;
 		dev->features |= NETIF_F_TSO6;
+#ifdef HAVE_NETDEV_VLAN_FEATURES
+		dev->vlan_features |= NETIF_F_TSO;
+		dev->vlan_features |= NETIF_F_TSO6;
+#else
 		dev->features |= NETIF_F_VLAN_TSO;
+#endif
 	}
 
 
