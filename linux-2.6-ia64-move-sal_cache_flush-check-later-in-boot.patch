From: Luming Yu <luyu@redhat.com>
Date: Fri, 20 Jun 2008 16:22:21 +0800
Subject: [ia64] move SAL_CACHE_FLUSH check later in boot
Message-id: 485B68BD.5000609@redhat.com
O-Subject: [RHEL 5.3 PATCH 2/2] bz 451745: move SAL_CACHE_FLUSH check later in boot
Bugzilla: 451745
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

BZ 451745

Description of problem:
1.
    [IA64] move SAL_CACHE_FLUSH check later in boot

    The check to see if the firmware drops interrupts during a
    SAL_CACHE_FLUSH is done to early in the boot. SAL_CACHE_FLUSH expects
    to be able to make PAL calls in virtual mode, on some cell based
    machines a fault occurs causing a MCA. This patch moves the check
    after mmu_context_init so the TLB and VHPT are properly setup.
    Signed-off-by Troy Heber <troy.heber@hp.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

2. Without this patch applied, the kernel with just 1st patch applied
boot hang on tiger4.
RHEL5 call the check_sal_flush() function earlier than mainline(
specifically has machvec been set up before the call)

Upstream status:
fa1d19e5d9a94120f31e5783ab44758f46892d94

Testing status:
Boot fine on tiger4 and Cold fusion, and nothing unusual found.

Please review,  test and ACK.

Thanks,
Luming

 arch/ia64/kernel/sal.c   |   11 +++++++----
 arch/ia64/kernel/setup.c |    2 ++
 include/asm-ia64/sal.h   |    1 +
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/arch/ia64/kernel/sal.c b/arch/ia64/kernel/sal.c
index 6c3eb0b..82b0d51 100644
--- a/arch/ia64/kernel/sal.c
+++ b/arch/ia64/kernel/sal.c
@@ -223,12 +223,13 @@ static void __init sal_desc_ap_wakeup(void *p) { }
  */
 static int sal_cache_flush_drops_interrupts;
 
-static void __init
+void __init
 check_sal_cache_flush (void)
 {
 	unsigned long flags;
 	int cpu;
-	u64 vector;
+	u64 vector, cache_type = 3;
+	struct ia64_sal_retval isrv;
 
 	cpu = get_cpu();
 	local_irq_save(flags);
@@ -242,7 +243,10 @@ check_sal_cache_flush (void)
 	while (!ia64_get_irr(IA64_TIMER_VECTOR))
 		cpu_relax();
 
-	ia64_sal_cache_flush(3);
+	SAL_CALL(isrv, SAL_CACHE_FLUSH, cache_type, 0, 0, 0, 0, 0, 0);
+
+	if (isrv.status)
+		printk(KERN_ERR "SAL_CAL_FLUSH failed with %ld\n", isrv.status);
 
 	if (ia64_get_irr(IA64_TIMER_VECTOR)) {
 		vector = ia64_get_ivr();
@@ -330,7 +334,6 @@ ia64_sal_init (struct ia64_sal_systab *systab)
 		p += SAL_DESC_SIZE(*p);
 	}
 
-	check_sal_cache_flush();
 }
 
 int
diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c
index 9144e81..223ca9d 100644
--- a/arch/ia64/kernel/setup.c
+++ b/arch/ia64/kernel/setup.c
@@ -616,6 +616,8 @@ setup_arch (char **cmdline_p)
 	cpu_init();	/* initialize the bootstrap CPU */
 	mmu_context_init();	/* initialize context_id bitmap */
 
+	check_sal_cache_flush();
+
 #ifdef CONFIG_ACPI
 	acpi_boot_init();
 #endif
diff --git a/include/asm-ia64/sal.h b/include/asm-ia64/sal.h
index 0c47c75..5ced6ea 100644
--- a/include/asm-ia64/sal.h
+++ b/include/asm-ia64/sal.h
@@ -665,6 +665,7 @@ ia64_sal_freq_base (unsigned long which, unsigned long *ticks_per_second,
 }
 
 extern s64 ia64_sal_cache_flush (u64 cache_type);
+extern void __init check_sal_cache_flush (void);
 
 /* Initialize all the processor and platform level instruction and data caches */
 static inline s64
