From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Fri, 30 Apr 2010 08:07:32 -0400
Subject: [net] cnic: Fix crash during bnx2x MTU change
Message-id: <20100430080732.GC2664@dhcp-lab-161.englab.brq.redhat.com>
Patchwork-id: 24702
O-Subject: [RHEL5.6 PATCH 6/5] cnic: Fix crash during bnx2x MTU change (bz
	586352)
Bugzilla: 582367
RH-Acked-by: Andy Gospodarek <gospo@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>

This is backport of upstream commit
94824f3dbe0d3f62470603bbb18efb5510aaf07c
needed to avoid ops when disabling lro in bnx2x with running cnic

>From upstream changelog:
cnic_service_bnx2x() irq handler can be called during chip reset from
MTU change.  Need to check that the cnic's device state is up before
handling the irq.

diff --git a/drivers/net/cnic.c b/drivers/net/cnic.c
index 0f81fc9..2dd904d 100644
--- a/drivers/net/cnic.c
+++ b/drivers/net/cnic.c
@@ -2334,13 +2334,14 @@ static int cnic_service_bnx2x(void *data, void *status_blk)
 	struct cnic_local *cp = dev->cnic_priv;
 	u16 prod = cp->kcq_prod_idx & MAX_KCQ_IDX;
 
-	prefetch(cp->status_blk);
-	prefetch(&cp->kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);
 
-	if (likely(test_bit(CNIC_F_CNIC_UP, &dev->flags)))
-		tasklet_schedule(&cp->cnic_irq_task);
+	if (likely(test_bit(CNIC_F_CNIC_UP, &dev->flags))) {
+		prefetch(cp->status_blk);
+		prefetch(&cp->kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);
 
-	cnic_chk_pkt_rings(cp);
+		tasklet_schedule(&cp->cnic_irq_task);
+		cnic_chk_pkt_rings(cp);
+	}
 
 	return 0;
 }
