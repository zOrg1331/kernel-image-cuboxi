From: ddugger@redhat.com <ddugger@redhat.com>
Date: Tue, 21 Apr 2009 13:01:32 -0600
Subject: [xen] vt-d: workaround for Mobile Series 4 Chipset
Message-id: 200904211901.n3LJ1WuG028401@sobek.n0ano.com
O-Subject: [RHEL5.4 PATCH 4/6 V2] BZ496873: vt-d: workaround for Mobile Series 4 Chipset
Bugzilla: 496873
RH-Acked-by: Gerd Hoffmann <kraxel@redhat.com>
RH-Acked-by: Chris Lalancette <clalance@redhat.com>
RH-Acked-by: Rik van Riel <riel@redhat.com>
RH-Acked-by: Gerd Hoffmann <kraxel@redhat.com>
RH-Acked-by: Justin M. Forbes <jforbes@redhat.com>

Incorporated VT-d workaround for a sighting on Intel Mobile Series 4
chipset found in Linux iommu. The sighting is the chipset is not
reporting write buffer flush capability correctly.

Upstream Status: Accepted (CS 19230)

Signed-off-by: Allen Kay <allen.m.kay@intel.com>
Signed-off-by: Weidong Han <weidong.han@intel.com>
Signed-off-by: Gerd Hoffman <kraxel@redhat.com>
Signed-off-by: Don Dugger <donald.d.dugger@intel.com>

Yet Another Resend - resolve the conflicting BZs between the Subject line
(correct) and the message body (incorrect).

diff --git a/drivers/passthrough/vtd/iommu.c b/drivers/passthrough/vtd/iommu.c
index 1705e2f..04d0291 100644
--- a/drivers/passthrough/vtd/iommu.c
+++ b/drivers/passthrough/vtd/iommu.c
@@ -40,6 +40,7 @@
 static spinlock_t domid_bitmap_lock;    /* protect domain id bitmap */
 static int domid_bitmap_size;           /* domain id bitmap size in bits */
 static unsigned long *domid_bitmap;     /* iommu domain id bitmap */
+static int rwbf_quirk = 0;
 
 static void setup_dom0_devices(struct domain *d);
 static void setup_dom0_rmrr(struct domain *d);
@@ -230,7 +231,7 @@ static void iommu_flush_write_buffer(struct iommu *iommu)
     unsigned long flag;
     s_time_t start_time;
 
-    if ( !cap_rwbf(iommu->cap) )
+    if ( !rwbf_quirk && !cap_rwbf(iommu->cap) )
         return;
     val = iommu->gcmd | DMA_GCMD_WBF;
 
@@ -1720,6 +1721,19 @@ static void setup_dom0_rmrr(struct domain *d)
     spin_unlock(&pcidevs_lock);
 }
 
+static void platform_quirks(void)
+{
+    u32 id;
+
+    /* Mobile 4 Series Chipset neglects to set RWBF capability,
+     * but needs it
+     */
+    gdprintk(XENLOG_INFO VTDPREFIX, "DMAR: Forcing write-buffer flush\n");
+    id = pci_conf_read32(0, 0, 0, 0);
+    if ( id == 0x2a408086 )
+        rwbf_quirk = 1;
+}
+
 int intel_vtd_setup(void)
 {
     struct acpi_drhd_unit *drhd;
@@ -1728,6 +1742,8 @@ int intel_vtd_setup(void)
     if ( !vtd_enabled )
         return -ENODEV;
 
+    platform_quirks();
+
     spin_lock_init(&domid_bitmap_lock);
     clflush_size = get_cache_line_size();
 
