diff -Nurap old/drivers/net/Kconfig new/drivers/net/Kconfig
--- old/drivers/net/Kconfig	2007-04-02 12:46:15.000000000 +0400
+++ new/drivers/net/Kconfig	2007-04-02 14:59:53.000000000 +0400
@@ -1899,6 +1899,21 @@ config ACENIC_OMIT_TIGON_I
 
 	  The safe and default value for this is N.
 
+config ATL1
+	tristate "Attansic L1 Gigabit Ethernet support"
+	depends on PCI
+	help
+	  This driver supports Attansic L1 gigabit ethernet cards.
+
+	  For general information and support, go to the driver project
+	  website at:
+
+	  <http://atl1.sourceforge.net/>
+	  <http://sourceforge.net/projects/atl1/>
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called atl1.
+
 config DL2K
 	tristate "D-Link DL2000-based Gigabit Ethernet support"
 	depends on PCI
diff -Nurap old/drivers/net/Makefile new/drivers/net/Makefile
--- old/drivers/net/Makefile	2007-04-02 12:46:16.000000000 +0400
+++ new/drivers/net/Makefile	2007-04-02 14:59:53.000000000 +0400
@@ -6,6 +6,7 @@ ifeq ($(CONFIG_ISDN_PPP),y)
   obj-$(CONFIG_ISDN) += slhc.o
 endif
 
+obj-$(CONFIG_ATL1) += atl1/
 obj-$(CONFIG_E1000) += e1000/
 obj-$(CONFIG_IBM_EMAC) += ibm_emac/
 obj-$(CONFIG_IXGB) += ixgb/
diff -Nurap old/drivers/net/atl1/Makefile new/drivers/net/atl1/Makefile
--- old/drivers/net/atl1/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/Makefile	2007-04-02 15:26:43.000000000 +0400
@@ -0,0 +1,3 @@
+atl1-objs := at_hw.o at_main.o at_hw.o at_param.o at_ethtool.o at_test.o
+obj-$(CONFIG_ATL1) := atl1.o
+
diff -Nurap old/drivers/net/atl1/at.h new/drivers/net/atl1/at.h
--- old/drivers/net/atl1/at.h	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at.h	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,284 @@
+/*
+Linux Attansic 1 Gigabit Ethernet Driver main header file
+*/
+
+#ifndef _ATTANSIC_H__
+#define _ATTANSIC_H__
+
+
+#include <linux/stddef.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/pagemap.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/capability.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <net/pkt_sched.h>
+#include <linux/list.h>
+#include <linux/reboot.h>
+#ifdef NETIF_F_TSO
+#include <net/checksum.h>
+#endif
+#ifdef SIOCGMIIPHY
+#include <linux/mii.h>
+#endif
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#endif
+#ifdef NETIF_F_HW_VLAN_TX
+#include <linux/if_vlan.h>
+#endif
+
+#define BAR_0	0
+#define BAR_1	1
+#define BAR_5	5
+#define PCI_DMA_64BIT	0xffffffffffffffffULL
+#define PCI_DMA_32BIT	0x00000000ffffffffULL
+
+#define	LBYTESWAP( a )  ( ( ( (a) & 0x00ff00ff ) << 8 ) | ( ( (a) & 0xff00ff00 ) >> 8 ) )
+#define	LONGSWAP( a )	( ( LBYTESWAP( a ) << 16 ) | ( LBYTESWAP( a ) >> 16 ) )
+#define	SHORTSWAP( a )	( ( (a) << 8 ) | ( (a) >> 8 ) )
+
+#include "kcompat.h"
+
+
+#define ATTANSIC_ETHERNET_DEVICE(device_id) {\
+	PCI_DEVICE(0x1969, device_id)}
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#define tso_size gso_size
+#endif
+struct at_adapter;
+
+#include "at_hw.h"
+
+#if DBG
+#define AT_DBG(args...)	printk(KERN_DEBUG "attansic: " args)
+#else
+#define AT_DBG(args...)
+#endif
+
+#define AT_ERR(args...)	printk(KERN_ERR "attansic: " args)
+
+#define AT_MAX_INTR         3
+
+#define AT_DEFAULT_TPD		    256
+#define AT_MAX_TPD		    1023
+#define AT_MIN_TPD		    64
+#define AT_DEFAULT_RFD		    512
+#define AT_MIN_RFD		    128
+#define AT_MAX_RFD		    2047
+
+
+
+
+
+#define AT_DESC_UNUSED(R) \
+	((((R)->next_to_clean > (R)->next_to_use) ? 0 : (R)->count) + \
+	(R)->next_to_clean - (R)->next_to_use - 1)
+
+#define AT_DESC_USED(R) \
+	(((R)->next_to_clean > (R)->next_to_use) ? 	\
+			((R)->count+(R)->next_to_use-(R)->next_to_clean+1) : \
+			((R)->next_to_use-(R)->next_to_clean+1))
+
+
+#define AT_GET_DESC(R, i, type)		(&(((type *)((R)->desc))[i]))
+#define AT_RFD_DESC(R, i)		AT_GET_DESC(R, i, rx_free_desc_t)
+#define AT_TPD_DESC(R, i)		AT_GET_DESC(R, i, tx_packet_desc_t)
+#define AT_RRD_DESC(R, i)		AT_GET_DESC(R, i, rx_return_desc_t)
+
+/* wrapper around a pointer to a socket buffer,
+ * so a DMA handle can be stored along with the buffer */
+struct at_buffer {
+	struct sk_buff *skb;
+	uint16_t length;
+	uint16_t alloced;
+	dma_addr_t dma;
+};
+
+#define MAX_TX_BUF_LEN		0x3000 /* 12KB */
+
+struct at_tpd_ring {
+    void *desc;         /* pointer to the descriptor ring memory */
+    dma_addr_t dma;     /* physical adress of the descriptor ring */
+    uint16_t size;      /* length of descriptor ring in bytes */
+    uint16_t count;     /* number of descriptors in the ring */
+
+    uint16_t hw_idx;    /* hardware index */
+    atomic_t next_to_clean;
+    atomic_t next_to_use;
+    struct at_buffer *buffer_info;
+};
+
+struct at_rfd_ring {
+    void *desc;
+    dma_addr_t dma;
+    uint16_t size;
+    uint16_t count;
+    atomic_t next_to_use;
+    uint16_t next_to_clean;
+    struct at_buffer *buffer_info;
+};
+
+struct at_rrd_ring {
+	void *desc;
+	dma_addr_t dma;
+	unsigned int size;
+	uint16_t count;
+	uint16_t next_to_use;
+	atomic_t next_to_clean;
+};
+
+struct at_ring_header {
+	/* pointer to the descriptor ring memory */
+	void *desc;
+	/* physical adress of the descriptor ring */
+	dma_addr_t dma;
+	/* length of descriptor ring in bytes */
+	unsigned int size;
+};
+
+struct at_cmb {
+	coals_msg_block_t* cmb;
+	dma_addr_t dma;
+};
+struct at_smb {
+	stats_msg_block_t* smb;
+	dma_addr_t dma;
+};
+
+/* Statistics counters */
+struct at_sft_stats {
+	uint64_t rx_packets;
+	uint64_t tx_packets;
+	uint64_t rx_bytes;
+	uint64_t tx_bytes;
+	uint64_t multicast;
+	uint64_t collisions;
+	uint64_t rx_errors;
+	uint64_t rx_length_errors;
+	uint64_t rx_crc_errors;
+	uint64_t rx_frame_errors;
+	uint64_t rx_fifo_errors;
+	uint64_t rx_missed_errors;
+	uint64_t tx_errors;
+    uint64_t tx_fifo_errors;
+    uint64_t tx_aborted_errors;
+    uint64_t tx_window_errors;
+    uint64_t tx_carrier_errors;
+
+    uint64_t tx_pause;      // The number of Pause packet transmitted.
+    uint64_t excecol;       // The number of transmit packets aborted due to excessive collisions.
+    uint64_t deffer;        // The number of packets transmitted that is deferred.
+    uint64_t scc;           // The number of packets subsequently transmitted successfully with a single prior collision.
+    uint64_t mcc;           // The number of packets subsequently transmitted successfully with multiple prior collisions.
+    uint64_t latecol;       // The number of packets transmitted with late collisions.
+    uint64_t tx_underun;    // The number of transmit packets aborted due to transmit FIFO underrun, or TRD FIFO underrun
+    uint64_t tx_trunc;      // The number of transmit packets truncated due to size exceeding MTU, regardless if it is truncated by Selene or not. 
+                            // (The name is not really reflects the meaning in this case here.)
+
+    uint64_t rx_pause;      // The number of Pause packet received.
+    uint64_t rx_rrd_ov;
+    uint64_t rx_trunc;
+};
+
+
+/* board specific private data structure */
+
+#define AT_REGS_LEN	8
+struct at_adapter {
+	/* OS defined structs */
+	struct net_device *netdev;
+	struct pci_dev *pdev;
+	struct net_device_stats net_stats;
+	struct at_sft_stats soft_stats;
+
+#ifdef NETIF_F_HW_VLAN_TX
+	struct vlan_group *vlgrp;//
+#endif
+	uint32_t rx_buffer_len;
+	uint32_t wol;
+	uint16_t link_speed;
+	uint16_t link_duplex;
+	spinlock_t stats_lock;
+	spinlock_t tx_lock;
+	atomic_t irq_sem;//
+	struct work_struct tx_timeout_task;//
+	struct work_struct link_chg_task;//
+    struct work_struct pcie_dma_to_rst_task;
+    struct timer_list watchdog_timer;
+    struct timer_list phy_config_timer;
+    boolean_t phy_timer_pending;
+
+    boolean_t mac_disabled;
+
+
+	// All descriptor rings' memory
+	struct at_ring_header ring_header;
+
+	/* TX */
+
+	struct at_tpd_ring tpd_ring;
+	spinlock_t mb_lock;
+
+
+	/* RX */
+	struct at_rfd_ring rfd_ring;
+	struct at_rrd_ring rrd_ring;
+	uint64_t hw_csum_err;
+	uint64_t hw_csum_good;
+
+	uint32_t gorcl;
+	uint64_t gorcl_old;
+
+	/* Interrupt Moderator timer ( 2us resolution) */
+	uint16_t imt;
+	/* Interrupt Clear timer (2us resolution) */
+	uint16_t ict;
+
+
+	/* structs defined in at_hw.h */
+	uint32_t bd_number;     // board number;
+	boolean_t pci_using_64;
+	struct at_hw hw;
+	struct at_smb smb;
+	struct at_cmb cmb;
+
+#ifdef ETHTOOL_TEST
+	uint32_t test_icr;
+	struct at_ring_header   test_ring_header;
+	struct at_tpd_ring     test_tpd_ring;
+	struct at_rfd_ring     test_rfd_ring;
+	struct at_rrd_ring test_rrd_ring;
+#endif
+	uint32_t pci_state[16];
+};
+
+
+
+
+#endif//_ATTANSIC_H__
diff -Nurap old/drivers/net/atl1/at_ethtool.c new/drivers/net/atl1/at_ethtool.c
--- old/drivers/net/atl1/at_ethtool.c	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_ethtool.c	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,696 @@
+#include "at.h"
+#include "at_hw.h"
+
+#ifdef SIOCETHTOOL
+#include <asm/uaccess.h>
+
+extern char at_driver_name[];
+extern char at_driver_version[];
+#ifdef SIOCGMIIPHY
+extern int at_set_spd_dplx(struct at_adapter* adapter,uint16_t spddplx);
+#endif
+extern int32_t at_up(struct at_adapter* adapter);
+extern void at_down(struct at_adapter* adapter);
+extern void at_reset(struct at_adapter* adapter);
+extern int32_t at_setup_ring_resources(struct at_adapter* adapter);
+extern void at_free_ring_resources(struct at_adapter* adapter);
+
+#ifdef	ETHTOOL_GSTATS
+struct at_stats {
+	char stat_string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int stat_offset;
+};
+
+#define AT_STAT(m) sizeof(((struct at_adapter *)0)->m), \
+		      offsetof(struct at_adapter, m)
+static struct at_stats at_gstrings_stats[] = {
+	{ "rx_packets",             AT_STAT(soft_stats.rx_packets)          },
+	{ "tx_packets",             AT_STAT(soft_stats.tx_packets)          },
+	{ "rx_bytes",               AT_STAT(soft_stats.rx_bytes)            },
+	{ "tx_bytes",               AT_STAT(soft_stats.tx_bytes)            },
+	{ "rx_errors",              AT_STAT(soft_stats.rx_errors)           },
+	{ "tx_errors",              AT_STAT(soft_stats.tx_errors)           },
+	{ "rx_dropped",             AT_STAT(net_stats.rx_dropped)           },
+	{ "tx_dropped",             AT_STAT(net_stats.tx_dropped)           },
+	{ "multicast",              AT_STAT(soft_stats.multicast)           },
+	{ "collisions",             AT_STAT(soft_stats.collisions)          },
+	{ "rx_length_errors",       AT_STAT(soft_stats.rx_length_errors)    },
+	{ "rx_over_errors",         AT_STAT(soft_stats.rx_missed_errors)    },
+	{ "rx_crc_errors",          AT_STAT(soft_stats.rx_crc_errors)       },
+	{ "rx_frame_errors",        AT_STAT(soft_stats.rx_frame_errors)     },
+	{ "rx_fifo_errors",         AT_STAT(soft_stats.rx_fifo_errors)      },
+	{ "rx_missed_errors",       AT_STAT(soft_stats.rx_missed_errors)    },
+	{ "tx_aborted_errors",      AT_STAT(soft_stats.tx_aborted_errors)   },
+	{ "tx_carrier_errors",      AT_STAT(soft_stats.tx_carrier_errors)   },
+	{ "tx_fifo_errors",         AT_STAT(soft_stats.tx_fifo_errors)      },
+	{ "tx_window_errors",       AT_STAT(soft_stats.tx_window_errors)    },
+	{ "tx_abort_exce_coll",     AT_STAT(soft_stats.excecol)             },
+	{ "tx_abort_late_coll",     AT_STAT(soft_stats.latecol)             },
+	{ "tx_deferred_ok",         AT_STAT(soft_stats.deffer)              },
+	{ "tx_single_coll_ok",      AT_STAT(soft_stats.scc)                 },
+	{ "tx_multi_coll_ok",       AT_STAT(soft_stats.mcc)                 },
+	{ "tx_underun",             AT_STAT(soft_stats.tx_underun)          },
+	{ "tx_trunc",               AT_STAT(soft_stats.tx_trunc)            },
+	{ "tx_pause",               AT_STAT(soft_stats.tx_pause)            },
+	{ "rx_pause",               AT_STAT(soft_stats.rx_pause)            },
+	{ "rx_rrd_ov",              AT_STAT(soft_stats.rx_rrd_ov)           },
+	{ "rx_trunc",               AT_STAT(soft_stats.rx_trunc)            }
+};
+#define AT_STATS_LEN	\
+	sizeof(at_gstrings_stats) / sizeof(struct at_stats)
+#endif	/* ETHTOOL_GSTATS */
+
+#ifdef	ETHTOOL_GWOL
+static void
+at_ethtool_gwol(struct at_adapter *adapter, struct ethtool_wolinfo *wol)
+{
+	wol->supported =
+	        WAKE_UCAST | WAKE_MCAST |
+			 WAKE_BCAST | WAKE_MAGIC;
+
+	wol->wolopts = 0;
+	if(adapter->wol & AT_WUFC_EX)
+		wol->wolopts |= WAKE_UCAST;
+	if(adapter->wol & AT_WUFC_MC)
+		wol->wolopts |= WAKE_MCAST;
+	if(adapter->wol & AT_WUFC_BC)
+		wol->wolopts |= WAKE_BCAST;
+	if(adapter->wol & AT_WUFC_MAG)
+		wol->wolopts |= WAKE_MAGIC;
+	return;
+
+}
+#endif	/* ETHTOOL_GWOL */
+
+#ifdef	ETHTOOL_SWOL
+static int
+at_ethtool_swol(struct at_adapter *adapter, struct ethtool_wolinfo *wol)
+{
+	if(wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
+		return -EOPNOTSUPP;
+
+	adapter->wol = 0;
+
+	if(wol->wolopts & WAKE_UCAST)
+		adapter->wol |= AT_WUFC_EX;
+	if(wol->wolopts & WAKE_MCAST)
+		adapter->wol |= AT_WUFC_MC;
+	if(wol->wolopts & WAKE_BCAST)
+		adapter->wol |= AT_WUFC_BC;
+	if(wol->wolopts & WAKE_MAGIC)
+		adapter->wol |= AT_WUFC_MAG;
+
+
+	return 0;
+}
+#endif	/* ETHTOOL_SWOL */
+
+static int
+at_ethtool_sset(struct at_adapter *adapter, struct ethtool_cmd *ecmd)
+{
+	struct at_hw *hw = &adapter->hw;
+	uint16_t phy_data;
+	int ret_val = 0;
+        uint16_t old_media_type = hw->MediaType;
+
+	if(netif_running(adapter->netdev)) {
+	    at_down(adapter);
+	}
+	//michael add 2005-11-17
+	DEBUGOUT("enter at_ethtool_sset---michael debug\n");
+	if(ecmd->autoneg == AUTONEG_ENABLE) {
+	    hw->MediaType = MEDIA_TYPE_AUTO_SENSOR;
+	} else {
+	    if (ecmd->speed == SPEED_1000) {
+		if (ecmd->duplex != DUPLEX_FULL) {
+	            printk(KERN_WARNING"can't force to 1000MHalf !\n");
+		    ret_val = -EINVAL;
+		    goto exit_sset;
+		}
+		hw->MediaType = MEDIA_TYPE_1000M_FULL;
+	    } else if (ecmd->speed == SPEED_100) {
+		if (ecmd->duplex == DUPLEX_FULL) {
+		    hw->MediaType = MEDIA_TYPE_100M_FULL;
+		} else {
+		    hw->MediaType = MEDIA_TYPE_100M_HALF;
+		}
+	    } else {
+		if (ecmd->duplex == DUPLEX_FULL) {
+	            hw->MediaType = MEDIA_TYPE_10M_FULL;
+		} else {
+		    hw->MediaType = MEDIA_TYPE_10M_HALF;
+		}
+	    }
+	}
+	switch (hw->MediaType)
+	{
+	case MEDIA_TYPE_AUTO_SENSOR:
+		ecmd->advertising =
+					  ADVERTISED_10baseT_Half |
+					  ADVERTISED_10baseT_Full |
+					  ADVERTISED_100baseT_Half |
+					  ADVERTISED_100baseT_Full |
+					  ADVERTISED_1000baseT_Full|
+					  ADVERTISED_Autoneg |
+					  ADVERTISED_TP;
+		break;
+	case MEDIA_TYPE_1000M_FULL:
+		ecmd->advertising =
+						  ADVERTISED_1000baseT_Full|
+						  ADVERTISED_Autoneg |
+						  ADVERTISED_TP;
+		break;
+	default:
+		ecmd->advertising = 0;
+		break;
+	}
+
+	if(at_phy_setup_autoneg_adv(hw)) {
+		ret_val = -EINVAL;
+		goto exit_sset;
+	}
+
+    if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+    	hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+    	phy_data = MII_CR_RESET | MII_CR_AUTO_NEG_EN;
+    } else {
+        switch (hw->MediaType)
+    	{
+    	case MEDIA_TYPE_100M_FULL:
+    		phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_100|MII_CR_RESET;
+    		break;
+    	case MEDIA_TYPE_100M_HALF:
+    		phy_data = MII_CR_SPEED_100|MII_CR_RESET;
+    		break;
+    	case MEDIA_TYPE_10M_FULL:
+    		phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_10|MII_CR_RESET;
+    		break;
+    	default: // MEDIA_TYPE_10M_HALF:
+    		phy_data = MII_CR_SPEED_10|MII_CR_RESET;
+    		break;
+    	}
+    }
+
+    at_write_phy_reg(hw, MII_BMCR, phy_data);
+
+exit_sset:
+    if (ret_val) {
+        hw->MediaType = old_media_type;
+    }
+
+    if(netif_running(adapter->netdev)) {
+	at_up(adapter);
+    } else if (!ret_val) {
+	at_reset(adapter);
+    }
+
+    return ret_val;
+}
+
+static void
+at_ethtool_gset(struct at_adapter *adapter, struct ethtool_cmd *ecmd)
+{
+	struct at_hw *hw = &adapter->hw;
+
+
+	ecmd->supported = (SUPPORTED_10baseT_Half |
+	                   SUPPORTED_10baseT_Full |
+	                   SUPPORTED_100baseT_Half |
+	                   SUPPORTED_100baseT_Full |
+	                   SUPPORTED_1000baseT_Full|
+	                   SUPPORTED_Autoneg |
+	                   SUPPORTED_TP);
+
+	ecmd->advertising = ADVERTISED_TP;
+
+	if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+	    hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+		ecmd->advertising |= ADVERTISED_Autoneg;
+		if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR) {
+			ecmd->advertising |= ADVERTISED_Autoneg;
+
+			ecmd->advertising |=
+						(ADVERTISED_10baseT_Half 	|
+						 ADVERTISED_10baseT_Full 	|
+						 ADVERTISED_100baseT_Half	|
+						 ADVERTISED_100baseT_Full	|
+						 ADVERTISED_1000baseT_Full  );
+		} else {
+			ecmd->advertising |=
+						(ADVERTISED_1000baseT_Full);
+		}
+	}
+	ecmd->port = PORT_TP;
+	ecmd->phy_address = 0;
+	ecmd->transceiver = XCVR_INTERNAL;
+
+	if(netif_carrier_ok(adapter->netdev))
+	{
+        uint16_t link_speed, link_duplex;
+
+		at_get_speed_and_duplex(hw, &link_speed, &link_duplex);
+		ecmd->speed = link_speed;
+		if(link_duplex == FULL_DUPLEX)
+			ecmd->duplex = DUPLEX_FULL;
+		else
+			ecmd->duplex = DUPLEX_HALF;
+	} else {
+		ecmd->speed = -1;
+		ecmd->duplex = -1;
+	}
+
+	if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+	    hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+		ecmd->autoneg = AUTONEG_ENABLE;
+	} else {
+		ecmd->autoneg = AUTONEG_DISABLE;
+	}
+}
+
+
+#ifdef	ETHTOOL_GDRVINFO
+static void
+at_ethtool_gdrvinfo(struct at_adapter *adapter,
+                       struct ethtool_drvinfo *drvinfo)
+{
+	strncpy(drvinfo->driver,  at_driver_name, 32);
+	strncpy(drvinfo->version, at_driver_version, 32);
+	strncpy(drvinfo->fw_version, "N/A", 32);
+	strncpy(drvinfo->bus_info, pci_name(adapter->pdev), 32);
+#ifdef  ETHTOOL_GEEPROM
+	drvinfo->eedump_len = 48;
+#endif//ETHTOOL_GEEPROM
+}
+#endif	/* ETHTOOL_GDRVINFO */
+
+#ifdef	ETHTOOL_GRINGPARAM
+static int
+at_ethtool_gring(struct at_adapter *adapter,
+                    struct ethtool_ringparam *ring)
+{
+	struct at_tpd_ring *txdr = &adapter->tpd_ring;
+	struct at_rfd_ring *rxdr = &adapter->rfd_ring;
+
+	ring->rx_max_pending = 2048;
+	ring->tx_max_pending = 1024;
+	ring->rx_mini_max_pending = 0;
+	ring->rx_jumbo_max_pending = 0;
+	ring->rx_pending = rxdr->count;
+	ring->tx_pending = txdr->count;
+	ring->rx_mini_pending = 0;
+	ring->rx_jumbo_pending = 0;
+
+	return 0;
+}
+#endif /* ETHTOOL_GRINGPARAM */
+#ifdef	ETHTOOL_SRINGPARAM
+static int
+at_ethtool_sring(struct at_adapter *adapter,
+                 struct ethtool_ringparam *ring)
+{
+	int err;
+	struct at_tpd_ring *tpdr = &adapter->tpd_ring;
+	struct at_rrd_ring *rrdr = &adapter->rrd_ring;
+	struct at_rfd_ring *rfdr = &adapter->rfd_ring;
+
+	struct at_tpd_ring tpd_old, tpd_new;
+	struct at_rfd_ring rfd_old, rfd_new;
+	struct at_rrd_ring rrd_old , rrd_new;
+
+
+	tpd_old = adapter->tpd_ring;
+	rfd_old = adapter->rfd_ring;
+	rrd_old = adapter->rrd_ring;
+
+	if(netif_running(adapter->netdev))
+		at_down(adapter);
+
+	rfdr->count = (uint16_t)max(ring->rx_pending, (uint32_t)32);
+	rfdr->count = rfdr->count>2048 ? 2048 : rfdr->count;
+	rfdr->count = (rfdr->count+3)&~3;
+	rrdr->count = rfdr->count;
+
+	tpdr->count = (uint16_t)max(ring->tx_pending, (uint32_t)16);
+	tpdr->count = tpdr->count>1024 ? 1024 : tpdr->count;
+	tpdr->count = (tpdr->count+3)&~3;
+
+	if(netif_running(adapter->netdev)) {
+		/* try to get new resources before deleting old */
+	    if ((err = at_setup_ring_resources(adapter)))
+	        goto err_setup_ring;
+
+
+		/* save the new, restore the old in order to free it,
+		 * then restore the new back again */
+
+		rfd_new = adapter->rfd_ring;
+		rrd_new = adapter->rrd_ring;
+		tpd_new = adapter->tpd_ring;
+		adapter->rfd_ring = rfd_old;
+		adapter->rrd_ring = rrd_old;
+		adapter->tpd_ring = tpd_old;
+		at_free_ring_resources(adapter);
+        adapter->rfd_ring = rfd_new;
+		adapter->rrd_ring = rrd_new;
+		adapter->tpd_ring = tpd_new;
+
+		if((err = at_up(adapter)))
+			return err;
+	}
+	return 0;
+
+err_setup_ring:
+	adapter->rfd_ring = rfd_old;
+	adapter->rrd_ring = rrd_old;
+	adapter->tpd_ring = tpd_old;
+	at_up(adapter);
+	return err;
+}
+#endif /* ETHTOOL_SRINGPARAM */
+#ifdef	ETHTOOL_GPAUSEPARAM
+static int
+at_ethtool_gpause(struct at_adapter *adapter,
+                     struct ethtool_pauseparam *epause)
+{
+	struct at_hw *hw = &adapter->hw;
+
+	if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+	    hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+		epause->autoneg = AUTONEG_ENABLE;
+	} else {
+		epause->autoneg = AUTONEG_DISABLE;
+	}
+
+	epause->rx_pause = 1;
+	epause->tx_pause = 1;
+
+	return 0;
+}
+#endif /* ETHTOOL_GPAUSEPARAM */
+#ifdef	ETHTOOL_SPAUSEPARAM
+static int
+at_ethtool_spause(struct at_adapter *adapter,
+                     struct ethtool_pauseparam *epause)
+{
+	struct at_hw *hw = &adapter->hw;
+
+	if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+	    hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+		epause->autoneg = AUTONEG_ENABLE;
+	} else {
+		epause->autoneg = AUTONEG_DISABLE;
+	}
+
+	epause->rx_pause = 1;
+	epause->tx_pause = 1;
+	return 0;
+
+}
+#endif /* ETHTOOL_SPAUSEPARAM */
+
+
+int
+at_ethtool_ioctl(struct net_device *netdev, struct ifreq *ifr)
+{
+	struct at_adapter *adapter = netdev->priv;
+	void *addr = ifr->ifr_data;
+	uint32_t cmd;
+
+	if(get_user(cmd, (uint32_t *) addr))
+		return -EFAULT;
+
+	//michael add 2005-11-17/
+	DEBUGOUT("enter at_ethtool_ioctl\n");
+	switch(cmd) {
+	case ETHTOOL_GSET: {
+		struct ethtool_cmd ecmd = {ETHTOOL_GSET};
+		at_ethtool_gset(adapter, &ecmd);
+		if(copy_to_user(addr, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+	}
+	case ETHTOOL_SSET: {
+		struct ethtool_cmd ecmd;
+		if(copy_from_user(&ecmd, addr, sizeof(ecmd)))
+			return -EFAULT;
+		return at_ethtool_sset(adapter, &ecmd);
+	}
+#ifdef	ETHTOOL_GDRVINFO
+	case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo drvinfo = {ETHTOOL_GDRVINFO};
+		at_ethtool_gdrvinfo(adapter, &drvinfo);
+		if(copy_to_user(addr, &drvinfo, sizeof(drvinfo)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GDRVINFO */
+#ifdef	ETHTOOL_GSTRINGS
+	case ETHTOOL_GSTRINGS: {
+		struct ethtool_gstrings gstrings = { ETHTOOL_GSTRINGS };
+		char *strings = NULL;
+		int err = 0;
+
+		if(copy_from_user(&gstrings, addr, sizeof(gstrings)))
+			return -EFAULT;
+		switch(gstrings.string_set)
+		{
+#ifdef	ETHTOOL_GSTATS
+		case ETH_SS_STATS:
+		{
+            int i;
+            gstrings.len = AT_STATS_LEN;
+            strings = kmalloc(AT_STATS_LEN * ETH_GSTRING_LEN,
+            		  GFP_KERNEL);
+            if(!strings)
+            	return -ENOMEM;
+            for(i=0; i < AT_STATS_LEN; i++) {
+            	memcpy(&strings[i * ETH_GSTRING_LEN],
+            	       at_gstrings_stats[i].stat_string,
+            	       ETH_GSTRING_LEN);
+            }
+		break;
+        }
+#endif	/* ETHTOOL_GSTATS */
+		default:
+			return -EOPNOTSUPP;
+		}
+		if(copy_to_user(addr, &gstrings, sizeof(gstrings)))
+			err = -EFAULT;
+		addr += offsetof(struct ethtool_gstrings, data);
+		if(!err && copy_to_user(addr, strings, gstrings.len * ETH_GSTRING_LEN))
+			err = -EFAULT;
+
+		kfree(strings);
+		return err;
+	}
+#endif	/* ETHTOOL_GSTRINGS */
+#ifdef	ETHTOOL_NWAY_RST
+	case ETHTOOL_NWAY_RST: {
+		struct at_hw* hw = &adapter->hw;
+		if(netif_running(netdev)) {
+			uint16_t phy_data;
+			at_down(adapter);
+
+			if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+    			hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+    			phy_data = MII_CR_RESET | MII_CR_AUTO_NEG_EN;
+    		} else {
+	        	switch (hw->MediaType)
+	    		{
+	    		case MEDIA_TYPE_100M_FULL:
+	    			phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_100|MII_CR_RESET;
+	    			break;
+	    		case MEDIA_TYPE_100M_HALF:
+	    			phy_data = MII_CR_SPEED_100|MII_CR_RESET;
+	    			break;
+	    		case MEDIA_TYPE_10M_FULL:
+	    			phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_10|MII_CR_RESET;
+	    			break;
+	    		default: // MEDIA_TYPE_10M_HALF:
+	    			phy_data = MII_CR_SPEED_10|MII_CR_RESET;
+	    			break;
+	    		}
+    		}
+    		at_write_phy_reg(hw, MII_BMCR, phy_data);
+			at_up(adapter);
+		}
+		return 0;
+	}
+#endif	/* ETHTOOL_NWAY_RST */
+#ifdef	ETHTOOL_GLINK
+	case ETHTOOL_GLINK: {
+		struct ethtool_value link = {ETHTOOL_GLINK};
+		link.data = netif_carrier_ok(netdev);
+		if(copy_to_user(addr, &link, sizeof(link)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GLINK */
+#ifdef	ETHTOOL_GWOL
+	case ETHTOOL_GWOL: {
+		struct ethtool_wolinfo wol = {ETHTOOL_GWOL};
+		at_ethtool_gwol(adapter, &wol);
+		if(copy_to_user(addr, &wol, sizeof(wol)) != 0)
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GWOL */
+#ifdef	ETHTOOL_SWOL
+	case ETHTOOL_SWOL: {
+		struct ethtool_wolinfo wol;
+		if(copy_from_user(&wol, addr, sizeof(wol)) != 0)
+			return -EFAULT;
+		return at_ethtool_swol(adapter, &wol);
+	}
+#endif	/* ETHTOOL_SWOL */
+
+#ifdef	ETHTOOL_GRINGPARAM
+	case ETHTOOL_GRINGPARAM: {
+		struct ethtool_ringparam ering = {ETHTOOL_GRINGPARAM};
+		at_ethtool_gring(adapter, &ering);
+		if(copy_to_user(addr, &ering, sizeof(ering)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GRINGPARAM */
+#ifdef	ETHTOOL_SRINGPARAM
+	case ETHTOOL_SRINGPARAM: {
+		struct ethtool_ringparam ering;
+		if(copy_from_user(&ering, addr, sizeof(ering)))
+			return -EFAULT;
+		return at_ethtool_sring(adapter, &ering);
+	}
+#endif	/* ETHTOOL_SRINGPARAM */
+#ifdef	ETHTOOL_GPAUSEPARAM
+	case ETHTOOL_GPAUSEPARAM: {
+		struct ethtool_pauseparam epause = {ETHTOOL_GPAUSEPARAM};
+		at_ethtool_gpause(adapter, &epause);
+		if(copy_to_user(addr, &epause, sizeof(epause)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GPAUSEPARAM */
+#ifdef	ETHTOOL_SPAUSEPARAM
+	case ETHTOOL_SPAUSEPARAM: {
+		struct ethtool_pauseparam epause;
+		if(copy_from_user(&epause, addr, sizeof(epause)))
+			return -EFAULT;
+		return at_ethtool_spause(adapter, &epause);
+	}
+#endif	/* ETHTOOL_SPAUSEPARAM */
+#ifdef	ETHTOOL_GSTATS
+	case ETHTOOL_GSTATS: {
+		struct {
+			struct ethtool_stats eth_stats;
+			uint64_t data[AT_STATS_LEN];
+		} stats = { {ETHTOOL_GSTATS, AT_STATS_LEN} };
+		int i;
+
+		for(i = 0; i < AT_STATS_LEN; i++)
+			stats.data[i] = (at_gstrings_stats[i].sizeof_stat ==
+					sizeof(uint64_t)) ?
+				*(uint64_t *)((char *)adapter +
+					at_gstrings_stats[i].stat_offset) :
+				*(uint32_t *)((char *)adapter +
+					at_gstrings_stats[i].stat_offset);
+		if(copy_to_user(addr, &stats, sizeof(stats)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GSTATS */
+#ifdef	ETHTOOL_GRXCSUM
+	case ETHTOOL_GRXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+		edata.data = 1;
+		if (copy_to_user(addr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GRXCSUM */
+#ifdef	ETHTOOL_GTXCSUM
+	case ETHTOOL_GTXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+		edata.data =
+			(netdev->features & NETIF_F_HW_CSUM) != 0;
+		if (copy_to_user(addr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GTXCSUM */
+#ifdef	ETHTOOL_STXCSUM
+	case ETHTOOL_STXCSUM: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, addr, sizeof(edata)))
+			return -EFAULT;
+
+		if (edata.data)
+			netdev->features |= NETIF_F_HW_CSUM;
+		else
+			netdev->features &= ~NETIF_F_HW_CSUM;
+
+		return 0;
+	}
+#endif	/* ETHTOOL_STXCSUM */
+#ifdef	ETHTOOL_GSG
+	case ETHTOOL_GSG: {
+		struct ethtool_value edata = { ETHTOOL_GSG };
+
+		edata.data =
+			(netdev->features & NETIF_F_SG) != 0;
+		if (copy_to_user(addr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+#endif	/* ETHTOOL_GSG */
+#ifdef	ETHTOOL_SSG
+	case ETHTOOL_SSG: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, addr, sizeof(edata)))
+			return -EFAULT;
+
+		if (edata.data)
+			netdev->features |= NETIF_F_SG;
+		else
+			netdev->features &= ~NETIF_F_SG;
+
+		return 0;
+	}
+#endif	/* ETHTOOL_SSG */
+#ifdef NETIF_F_TSO
+#ifdef ETHTOOL_GTSO
+	case ETHTOOL_GTSO: {
+		struct ethtool_value edata = { ETHTOOL_GTSO };
+
+		edata.data = (netdev->features & NETIF_F_TSO) != 0;
+		if (copy_to_user(addr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+#endif /* ETHTOOL_GTSO */
+#ifdef ETHTOOL_STSO
+	case ETHTOOL_STSO: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, addr, sizeof(edata)))
+			return -EFAULT;
+
+		if (edata.data)
+			netdev->features |= NETIF_F_TSO;
+		else
+			netdev->features &= ~NETIF_F_TSO;
+
+		return 0;
+	}
+#endif /* ETHTOOL_STSO */
+#endif
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+#endif//SIOCETHTOOL
diff -Nurap old/drivers/net/atl1/at_hw.c new/drivers/net/atl1/at_hw.c
--- old/drivers/net/atl1/at_hw.c	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_hw.c	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,932 @@
+#include "at.h"
+#ifdef SIOCGMIIPHY
+#include <linux/mii.h>
+#endif
+
+/*
+ * The little-endian AUTODIN II ethernet CRC calculations.
+ * A big-endian version is also available.
+ * This is slow but compact code.  Do not use this routine
+ * for bulk data, use a table-based routine instead.
+ * This is common code and should be moved to net/core/crc.c.
+ * Chips may use the upper or lower CRC bits, and may reverse
+ * and/or invert them.  Select the endian-ness that results
+ * in minimal calculations.
+ */
+uint32_t
+ether_crc_le(int length, unsigned char *data)
+{
+    uint32_t crc = ~0;  /* Initial value. */
+    while(--length >= 0) {
+        unsigned char current_octet = *data++;
+        int bit;
+        for (bit = 8; --bit >= 0; current_octet >>= 1) {
+            if ((crc ^ current_octet) & 1) {
+                crc >>= 1;
+                crc ^= 0xedb88320;
+            }
+            else
+                crc >>= 1;
+        }
+    }
+    return ~crc;
+}
+
+/********************************************************************
+* Reset the transmit and receive units; mask and clear all interrupts.
+*
+* hw - Struct containing variables accessed by shared code
+* return : AT_SUCCESS  or  idle status (if error)
+********************************************************************/
+int32_t
+at_reset_hw(struct at_hw *hw)
+{
+    uint32_t icr;
+    uint16_t pci_cfg_cmd_word;
+    int i;
+
+    DEBUGFUNC("at_reset_hw");
+
+    /* Workaround for PCI problem when BIOS sets MMRBC incorrectly. */
+    at_read_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);
+    if ((pci_cfg_cmd_word&
+           (CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER))
+        != (CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) {
+        pci_cfg_cmd_word |=
+           (CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER);
+        at_write_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);
+    }
+
+
+    /* Clear Interrupt mask to stop board from generating
+     * interrupts & Clear any pending interrupt events
+     */
+//    AT_WRITE_REG(hw, REG_IMR, 0);
+//    AT_WRITE_REG(hw, REG_ISR, 0xffffffff);
+
+    /* Issue Soft Reset to the MAC.  This will reset the chip's
+     * transmit, receive, DMA.  It will not effect
+     * the current PCI configuration.  The global reset bit is self-
+     * clearing, and should clear within a microsecond.
+     */
+    AT_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_SOFT_RST);
+    wmb();
+
+    AT_WRITE_REGW(hw, REG_GPHY_ENABLE, 1);
+
+    msec_delay(1); // delay about 1ms
+
+    /* Wait at least 10ms for All module to be Idle
+     */
+    for (i=0; i < 10; i++)
+    {
+        icr = AT_READ_REG(hw, REG_IDLE_STATUS);
+        if (!icr)
+            break;
+        msec_delay(1); // delay 1 ms
+        cpu_relax();
+    }
+
+    if (icr)
+    {
+        DEBUGOUT("MAC state machine cann't be idle since disabled for 10ms second\n");
+        return icr;
+    }
+
+    return AT_SUCCESS;
+}
+
+
+/*********************************************************************
+* Reads the adapter's MAC address from the EEPROM
+*
+* hw - Struct containing variables accessed by shared code
+*********************************************************************/
+int32_t
+at_read_mac_addr(struct at_hw * hw)
+{
+    uint16_t  i;
+
+    DEBUGFUNC("at_read_mac_addr");
+
+    if (get_permanent_address(hw)) {
+        // for test
+        hw->perm_mac_addr[0] = 0x00;
+        hw->perm_mac_addr[1] = 0x13;
+        hw->perm_mac_addr[2] = 0x74;
+        hw->perm_mac_addr[3] = 0x00;
+        hw->perm_mac_addr[4] = 0x5c;
+        hw->perm_mac_addr[5] = 0x38;
+    }
+
+    for(i = 0; i < NODE_ADDRESS_SIZE; i++)
+        hw->mac_addr[i] = hw->perm_mac_addr[i];
+    return AT_SUCCESS;
+}
+
+/*********************************************************************
+* Hashes an address to determine its location in the multicast table
+*
+* hw - Struct containing variables accessed by shared code
+* mc_addr - the multicast address to hash
+*********************************************************************/
+/*
+ * at_hash_mc_addr
+ *  purpose
+ *      set hash value for a multicast address
+ *      hash calcu processing :
+ *          1. calcu 32bit CRC for multicast address
+ *          2. reverse crc with MSB to LSB
+ */
+uint32_t
+at_hash_mc_addr(
+        struct at_hw *hw,
+        uint8_t *mc_addr)
+{
+    uint32_t crc32, value=0;
+    int i;
+
+    crc32 = ether_crc_le(6, mc_addr);
+    crc32 = ~crc32;
+    for (i=0; i<32; i++)
+    {
+        value |= (((crc32>>i)&1)<<(31-i));
+    }
+
+    return value;
+}
+
+
+/********************************************************************
+* Sets the bit in the multicast table corresponding to the hash value.
+*
+* hw - Struct containing variables accessed by shared code
+* hash_value - Multicast address hash value
+********************************************************************/
+void
+at_hash_set(
+            struct at_hw *hw,
+            uint32_t hash_value)
+{
+    uint32_t hash_bit, hash_reg;
+    uint32_t mta;
+
+    /* The HASH Table  is a register array of 2 32-bit registers.
+    * It is treated like an array of 64 bits.  We want to set
+    * bit BitArray[hash_value]. So we figure out what register
+    * the bit is in, read it, OR in the new bit, then write
+    * back the new value.  The register is determined by the
+    * upper 7 bits of the hash value and the bit within that
+    * register are determined by the lower 5 bits of the value.
+    */
+    hash_reg = (hash_value >> 31) & 0x1;
+    hash_bit = (hash_value >> 26) & 0x1F;
+
+    mta = AT_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);
+
+    mta |= (1 << hash_bit);
+
+    AT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);
+}
+
+/********************************************************************
+* Make L001's PHY out of Power Saving State (bug)
+*
+* hw - Struct containing variables accessed by shared code
+* when power on, L001's PHY always on Power saving State
+* (Gigabit Link forbidden)
+********************************************************************/
+
+int32_t
+at_phy_leave_power_saving(struct at_hw* hw)
+{
+
+    int32_t ret;
+
+//        DEBUGFUNC("at_phy_leave_power_saving!");
+
+
+    if ((ret = at_write_phy_reg(hw, 29, 0x0029)))
+        return ret;
+
+        return at_write_phy_reg(hw, 30, 0);
+}
+
+int32_t
+at_phy_enter_power_saving(struct at_hw* hw)
+{
+//    int32_t ret_val;
+//    uint16_t phy_data;
+
+    DEBUGFUNC("at_phy_enter_power_saving");
+/*
+    ret_val = at_write_phy_reg(hw, ...);
+    ret_val = at_write_phy_reg(hw, ...);
+    ....
+*/
+    return AT_SUCCESS;
+}
+
+/********************************************************************
+* Performs basic configuration of the adapter.
+*
+* hw - Struct containing variables accessed by shared code
+* Assumes that the controller has previously been reset and is in a
+* post-reset uninitialized state. Initializes multicast table,
+* and  Calls routines to setup link
+* Leaves the transmit and receive units disabled and uninitialized.
+********************************************************************/
+int32_t
+at_init_hw(struct at_hw *hw)
+{
+    uint32_t ret_val = 0;
+
+    DEBUGFUNC("at_init_hw");
+
+    /* Zero out the Multicast HASH table */
+//    DEBUGOUT("Zeroing the MTA");
+    /* clear the old settings from the multicast hash table */
+    AT_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);
+    AT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);
+
+    init_flash_opcode(hw);
+
+
+    if (!hw->phy_configured) {
+        DEBUGOUT("configure phy now !");
+
+          /* enable GPHY LinkChange Interrrupt */
+          ret_val = at_write_phy_reg(hw, 18, 0xC00);
+      if (ret_val)
+              return ret_val;
+
+          /* make PHY out of power-saving state */
+
+          ret_val = at_phy_leave_power_saving(hw);
+          if (ret_val)
+              return ret_val;
+
+        /* Call a subroutine to configure the link */
+        ret_val = at_setup_link(hw);
+    }
+    DEBUGOUT1("at_init_hw: ret: %d", ret_val);
+
+    return ret_val;
+}
+
+
+/********************************************************************
+* Configures link settings.
+*
+* hw - Struct containing variables accessed by shared code
+* Assumes the hardware has previously been reset and the
+* transmitter and receiver are not enabled.
+********************************************************************/
+int32_t
+at_setup_link(struct at_hw *hw)
+{
+    int32_t ret_val;
+
+    DEBUGFUNC("at_setup_link");
+
+    /* Options:
+     *  PHY will advertise value(s) parsed from
+     *  autoneg_advertised and fc
+     *  no matter what autoneg is , We will not wait link result.
+     */
+
+    ret_val = at_phy_setup_autoneg_adv(hw);
+    if(ret_val) {
+        DEBUGOUT("Error Setting up Auto-Negotiation");
+        return ret_val;
+    }
+
+    /* SW.Reset , En-Auto-Neg if needed */
+    DEBUGOUT("Restarting Auto-Neg");
+    ret_val = at_phy_reset(hw);
+    if (ret_val) {
+        DEBUGOUT("Error Resetting the phy");
+        return ret_val;
+    }
+
+    hw->phy_configured = TRUE;
+
+    return ret_val;
+}
+
+
+/******************************************************************************
+* Detects the current speed and duplex settings of the hardware.
+*
+* hw - Struct containing variables accessed by shared code
+* speed - Speed of the connection
+* duplex - Duplex setting of the connection
+*****************************************************************************/
+int32_t
+at_get_speed_and_duplex(
+        struct at_hw *hw,
+        uint16_t *speed,
+        uint16_t *duplex)
+{
+    int32_t ret_val;
+    uint16_t phy_data;
+
+//    DEBUGFUNC("at_get_speed_and_duplex");
+
+    // ; --- Read   PHY Specific Status Register (17)
+    ret_val = at_read_phy_reg(hw, MII_AT001_PSSR, &phy_data);
+    if (ret_val)
+        return ret_val;
+
+    if (!(phy_data & MII_AT001_PSSR_SPD_DPLX_RESOLVED))
+        return AT_ERR_PHY_RES;
+
+    switch(phy_data&MII_AT001_PSSR_SPEED) {
+    case MII_AT001_PSSR_1000MBS :
+        *speed = SPEED_1000;
+//        DEBUGOUT("1000 Mbs, ");
+        break;
+    case MII_AT001_PSSR_100MBS:
+        *speed = SPEED_100;
+//        DEBUGOUT("100 Mbs, ");
+        break;
+    case MII_AT001_PSSR_10MBS:
+        *speed = SPEED_10;
+//        DEBUGOUT("10 Mbs, ");
+        break;
+    default:
+        DEBUGOUT("Error Speed !\n");
+        return AT_ERR_PHY_SPEED;
+        break;
+    }
+
+    if (phy_data & MII_AT001_PSSR_DPLX) {
+        *duplex = FULL_DUPLEX;
+//        DEBUGOUT("Full Duplex");
+    } else {
+        *duplex = HALF_DUPLEX;
+//        DEBUGOUT(" Half Duplex");
+    }
+
+    return AT_SUCCESS;
+}
+
+/*********************************************************************
+* Reads the value from a PHY register
+* hw - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to read
+*********************************************************************/
+int32_t
+at_read_phy_reg(
+            struct at_hw *hw,
+            uint16_t reg_addr,
+            uint16_t *phy_data)
+{
+    uint32_t val;
+    int i;
+
+//    DEBUGFUNC("at_read_phy_reg");
+
+    val = ((uint32_t)(reg_addr&MDIO_REG_ADDR_MASK))
+                << MDIO_REG_ADDR_SHIFT |
+            MDIO_START |
+            MDIO_SUP_PREAMBLE |
+            MDIO_RW |
+            MDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;
+    AT_WRITE_REG(hw, REG_MDIO_CTRL, val);
+
+    wmb();
+
+    for (i=0; i<MDIO_WAIT_TIMES; i++) {
+        usec_delay(2);
+        val = AT_READ_REG(hw, REG_MDIO_CTRL);
+        if (!(val&(MDIO_START|MDIO_BUSY))) {
+            break;
+        }
+        wmb();
+    }
+    if (!(val&(MDIO_START|MDIO_BUSY))) {
+        *phy_data = (uint16_t)val;
+        return AT_SUCCESS;
+    }
+
+    return AT_ERR_PHY;
+}
+
+/********************************************************************
+* Writes a value to a PHY register
+* hw - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to write
+* data - data to write to the PHY
+********************************************************************/
+int32_t
+at_write_phy_reg(
+        struct at_hw *hw,
+        uint32_t reg_addr,
+        uint16_t phy_data)
+{
+    int i;
+    uint32_t val;
+
+    val =   ((uint32_t)(phy_data & MDIO_DATA_MASK)) << MDIO_DATA_SHIFT |
+            (reg_addr&MDIO_REG_ADDR_MASK) << MDIO_REG_ADDR_SHIFT |
+            MDIO_SUP_PREAMBLE |
+            MDIO_START |
+            MDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;
+    AT_WRITE_REG(hw, REG_MDIO_CTRL, val);
+//    printk(KERN_INFO "phy write 0x%x <- 0x%x\n", reg_addr, phy_data);
+//    DEBUGOUT1("phy write 0x%x <- 0x%x, value = 0x%x", i
+//              reg_addr,
+//              phy_data,
+//              val);
+
+    wmb();
+
+    for (i=0; i<MDIO_WAIT_TIMES; i++) {
+        usec_delay(2);
+        val = AT_READ_REG(hw, REG_MDIO_CTRL);
+        if (!(val&(MDIO_START|MDIO_BUSY))) {
+            break;
+        }
+        wmb();
+    }
+
+    if (!(val&(MDIO_START|MDIO_BUSY)))
+        return AT_SUCCESS;
+
+    return AT_ERR_PHY;
+}
+
+/********************************************************************
+* Configures PHY autoneg and flow control advertisement settings
+*
+* hw - Struct containing variables accessed by shared code
+********************************************************************/
+int32_t
+at_phy_setup_autoneg_adv(struct at_hw *hw)
+{
+    int32_t ret_val;
+    int16_t mii_autoneg_adv_reg;
+    int16_t mii_1000t_ctrl_reg;
+
+    DEBUGFUNC("at_phy_setup_autoneg_adv");
+
+    /* Read the MII Auto-Neg Advertisement Register (Address 4). */
+    mii_autoneg_adv_reg = MII_AR_DEFAULT_CAP_MASK;
+
+    /* Read the MII 1000Base-T Control Register (Address 9). */
+    mii_1000t_ctrl_reg = MII_AT001_CR_1000T_DEFAULT_CAP_MASK;
+
+   /* First we clear all the 10/100 mb speed bits in the Auto-Neg
+    * Advertisement Register (Address 4) and the 1000 mb speed bits in
+    * the  1000Base-T Control Register (Address 9).
+    */
+    mii_autoneg_adv_reg &= ~MII_AR_SPEED_MASK;
+    mii_1000t_ctrl_reg &= ~MII_AT001_CR_1000T_SPEED_MASK;
+
+    /* Need to parse MediaType  and set up
+     * the appropriate PHY registers.
+     */
+    switch (hw->MediaType)
+    {
+    case MEDIA_TYPE_AUTO_SENSOR:
+        mii_autoneg_adv_reg |= (MII_AR_10T_HD_CAPS|
+                                MII_AR_10T_FD_CAPS|
+                                MII_AR_100TX_HD_CAPS|
+                                MII_AR_100TX_FD_CAPS);
+        mii_1000t_ctrl_reg |= MII_AT001_CR_1000T_FD_CAPS;
+        break;
+
+    case MEDIA_TYPE_1000M_FULL:
+        mii_1000t_ctrl_reg |= MII_AT001_CR_1000T_FD_CAPS;
+        break;
+
+    case MEDIA_TYPE_100M_FULL:
+        mii_autoneg_adv_reg |= MII_AR_100TX_FD_CAPS;
+        break;
+
+    case MEDIA_TYPE_100M_HALF:
+        mii_autoneg_adv_reg |= MII_AR_100TX_HD_CAPS;
+        break;
+
+    case MEDIA_TYPE_10M_FULL:
+        mii_autoneg_adv_reg |= MII_AR_10T_FD_CAPS;
+        break;
+
+    default:
+        mii_autoneg_adv_reg |= MII_AR_10T_HD_CAPS;
+        break;
+    }
+
+    /* flow control fixed to enable all */
+    mii_autoneg_adv_reg |= (MII_AR_ASM_DIR | MII_AR_PAUSE);
+
+    hw->mii_autoneg_adv_reg = mii_autoneg_adv_reg;
+    hw->mii_1000t_ctrl_reg = mii_1000t_ctrl_reg;
+
+    ret_val = at_write_phy_reg(hw,
+                               MII_ADVERTISE,
+                               mii_autoneg_adv_reg);
+    if(ret_val)
+        return ret_val;
+
+    ret_val = at_write_phy_reg(hw, MII_AT001_CR, mii_1000t_ctrl_reg);
+    if(ret_val)
+        return ret_val;
+
+    return AT_SUCCESS;
+}
+
+/*******************************************************************
+* Resets the PHY and make all config validate
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Sets bit 15 and 12 of the MII Control regiser (for F001 bug)
+*******************************************************************/
+int32_t
+at_phy_reset(struct at_hw *hw)
+{
+    int32_t ret_val;
+    uint16_t phy_data;
+
+//    DEBUGFUNC("at_phy_reset");
+
+    if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+    	hw->MediaType == MEDIA_TYPE_1000M_FULL) {
+    	phy_data = MII_CR_RESET | MII_CR_AUTO_NEG_EN;
+    } else {
+        switch (hw->MediaType)
+    	{
+    	case MEDIA_TYPE_100M_FULL:
+    		phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_100|MII_CR_RESET;
+    		break;
+    	case MEDIA_TYPE_100M_HALF:
+    		phy_data = MII_CR_SPEED_100|MII_CR_RESET;
+    		break;
+    	case MEDIA_TYPE_10M_FULL:
+    		phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_10|MII_CR_RESET;
+    		break;
+    	default: // MEDIA_TYPE_10M_HALF:
+    		phy_data = MII_CR_SPEED_10|MII_CR_RESET;
+    		break;
+    	}
+    }
+
+    ret_val = at_write_phy_reg(hw, MII_BMCR, phy_data);
+    if (ret_val) { // bug fixed
+        uint32_t val;
+        int i;
+        /**************************************
+        * pcie serdes link may be down !
+        **************************************/
+        DEBUGOUT("Auto-Neg make pcie phy link down !");
+
+        for (i=0; i < 25; i++) {
+            msec_delay(1);
+            val = AT_READ_REG(hw, REG_MDIO_CTRL);
+            if (!(val&(MDIO_START|MDIO_BUSY))) {
+                break;
+            }
+        }
+
+        if (0 != (val&(MDIO_START|MDIO_BUSY))) {
+            AT_ERR("pcie linkdown at least for 25ms !\n");
+            return ret_val;
+
+        DEBUGOUT1("pcie linkup after %dms", i);
+        }
+    }
+    return AT_SUCCESS;
+}
+
+void
+set_mac_addr(struct at_hw* hw)
+{
+    uint32_t value;
+    // 00-0B-6A-F6-00-DC
+    // 0:  6AF600DC   1: 000B
+    //  low dword
+    value = (((uint32_t)hw->mac_addr[2]) << 24) |
+            (((uint32_t)hw->mac_addr[3]) << 16) |
+            (((uint32_t)hw->mac_addr[4]) << 8 ) |
+            (((uint32_t)hw->mac_addr[5])      ) ;
+    AT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);
+    // hight dword
+    value = (((uint32_t)hw->mac_addr[0]) << 8 ) |
+            (((uint32_t)hw->mac_addr[1])      ) ;
+    AT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);
+}
+
+
+/*************************************** function about EEPROM **********************************/
+/*
+ * check_eeprom_exist
+ * return 0 if eeprom exist
+ */
+int
+check_eeprom_exist(struct at_hw* hw)
+{
+    uint32_t value;
+
+    value = AT_READ_REG(hw, REG_SPI_FLASH_CTRL);
+    if (value & SPI_FLASH_CTRL_EN_VPD)
+    {
+        value &= ~SPI_FLASH_CTRL_EN_VPD;
+        AT_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);
+    }
+    value = AT_READ_REGW(hw, REG_PCIE_CAP_LIST);
+    return ((value & 0xFF00) == 0x6C00) ? 0 : 1;
+}
+
+inline
+boolean_t
+EthAddressValid(uint8_t* pAddr)
+{
+    // Invalid PermanentAddress ?
+    if (    (
+            (pAddr[0]==0) &&
+            (pAddr[1]==0) &&
+            (pAddr[2]==0) &&
+            (pAddr[3]==0) &&
+            (pAddr[4]==0) &&
+            (pAddr[5]==0)
+            ) ||
+            (pAddr[0] & 1) ) // Multicast address or Broadcast Address
+    {
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/*
+ * get_permanent_address
+ * return 0 if get valid mac address,
+ */
+int
+get_permanent_address(struct at_hw* hw)
+{
+    uint32_t Addr[2];
+    uint32_t i, Control;
+    uint16_t Register;
+    uint8_t  EthAddr[NODE_ADDRESS_SIZE];
+    boolean_t KeyValid;
+
+    if(EthAddressValid(hw->perm_mac_addr))
+        return 0;
+
+    // init
+    Addr[0] = Addr[1] = 0;
+
+    if (!check_eeprom_exist(hw)) { // eeprom exist
+    Register = 0;
+    KeyValid = FALSE;
+    //
+    // Read out all EEPROM content
+    //
+    i = 0;
+    while (1) {
+        if (read_eeprom(hw, i+0x100, &Control)) {
+            if (KeyValid) {
+            if (Register == REG_MAC_STA_ADDR)
+                    Addr[0] = Control;
+            else if (Register == (REG_MAC_STA_ADDR+4)) {
+                Addr[1] = Control;
+            }
+            KeyValid = FALSE;
+        } else if ((Control&0xff) == 0x5A) {
+            KeyValid = TRUE;
+            Register = (uint16_t) (Control >> 16);
+        } else {
+            break; // assume data end while encount an invalid KEYWORD
+            }
+        } else {
+            break; // read error
+        }
+        i += 4;
+    }
+
+    *(uint32_t*) &EthAddr[2] = LONGSWAP(Addr[0]);
+    *(uint16_t*) &EthAddr[0] = SHORTSWAP(*(uint16_t*)&Addr[1]);
+
+        if (EthAddressValid(EthAddr)) {
+            memcpy(hw->perm_mac_addr, EthAddr, NODE_ADDRESS_SIZE);
+            return 0;
+        }
+        return 1;
+    }
+
+    // see if SPI FLAHS exist ?
+    Addr[0] = Addr[1] = 0 ;
+    Register = 0;
+    KeyValid = FALSE;
+    i = 0;
+    while (1) {
+        if (spi_read(hw, i+0x1f000, &Control)) {
+            if (KeyValid) {
+                if (Register == REG_MAC_STA_ADDR)
+                    Addr[0] = Control;
+                else if (Register == (REG_MAC_STA_ADDR+4)) {
+                    Addr[1] = Control;
+                }
+                KeyValid = FALSE;
+            } else if ((Control&0xff) == 0x5A) {
+                KeyValid = TRUE;
+                Register = (uint16_t) (Control >> 16);
+            } else {
+                break; // data end
+            }
+        } else {
+            break; // read error
+        }
+        i += 4;
+    }
+
+    *(uint32_t*) &EthAddr[2] = LONGSWAP(Addr[0]);
+    *(uint16_t*) &EthAddr[0] = SHORTSWAP(*(uint16_t*)&Addr[1]);
+    if (EthAddressValid(EthAddr)) {
+        memcpy(hw->perm_mac_addr, EthAddr, NODE_ADDRESS_SIZE);
+        return 0;
+    }
+    return 1;
+}
+
+boolean_t
+read_eeprom(struct at_hw* hw, uint32_t Offset, uint32_t* pValue)
+{
+    int i;
+    uint32_t    Control;
+
+    if (Offset&3)   return FALSE; //address do not align
+
+    AT_WRITE_REG(hw, REG_VPD_DATA, 0);
+    Control = (Offset&VPD_CAP_VPD_ADDR_MASK)<<VPD_CAP_VPD_ADDR_SHIFT;
+    AT_WRITE_REG(hw, REG_VPD_CAP, Control);
+
+    for (i=0; i < 10; i++)
+    {
+        msec_delay(2);
+        Control = AT_READ_REG(hw, REG_VPD_CAP);
+        if (Control & VPD_CAP_VPD_FLAG)
+            break;
+    }
+    if (Control & VPD_CAP_VPD_FLAG)
+    {
+        *pValue = AT_READ_REG(hw, REG_VPD_DATA);
+        return TRUE;
+    }
+    return FALSE; // timeout
+}
+
+spi_flash_dev flash_table[] =
+{
+//  manu_name   WRSR    READ    PROGRAM WREN    WRDI    RDSR    RDID    SECTOR_ERASE CHIP_ERASE
+    {"Atmel",   0x0,    0x03,   0x02,   0x06,   0x04,   0x05,   0x15,   0x52,   0x62 },
+    {"SST",     0x01,   0x03,   0x02,   0x06,   0x04,   0x05,   0x90,   0x20,   0x60 },
+    {"ST",      0x01,   0x03,   0x02,   0x06,   0x04,   0x05,   0xAB,   0xD8,   0xC7 },
+};
+
+
+#define CUSTOM_SPI_CS_SETUP        2
+#define CUSTOM_SPI_CLK_HI          2
+#define CUSTOM_SPI_CLK_LO          2
+#define CUSTOM_SPI_CS_HOLD         2
+#define CUSTOM_SPI_CS_HI           3
+
+
+
+void
+init_flash_opcode(struct at_hw* hw)
+{
+    if (hw->flash_vendor >= sizeof(flash_table)/sizeof(flash_table[0])) {
+        hw->flash_vendor = 0; // ATMEL
+    }
+    // Init OP table
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_PROGRAM,     flash_table[hw->flash_vendor].cmdPROGRAM);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_SC_ERASE,    flash_table[hw->flash_vendor].cmdSECTOR_ERASE);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_CHIP_ERASE,  flash_table[hw->flash_vendor].cmdCHIP_ERASE);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_RDID,        flash_table[hw->flash_vendor].cmdRDID);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_WREN,        flash_table[hw->flash_vendor].cmdWREN);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_RDSR,        flash_table[hw->flash_vendor].cmdRDSR);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_WRSR,        flash_table[hw->flash_vendor].cmdWRSR);
+    AT_WRITE_REGB(hw, REG_SPI_FLASH_OP_READ,        flash_table[hw->flash_vendor].cmdREAD);
+}
+
+boolean_t
+spi_read(struct at_hw* hw, uint32_t addr, uint32_t* buf)
+{
+    int i;
+    uint32_t value;
+
+    AT_WRITE_REG(hw, REG_SPI_DATA, 0);
+    AT_WRITE_REG(hw, REG_SPI_ADDR, addr);
+
+    value =
+        SPI_FLASH_CTRL_WAIT_READY|
+        (CUSTOM_SPI_CS_SETUP&SPI_FLASH_CTRL_CS_SETUP_MASK)<<SPI_FLASH_CTRL_CS_SETUP_SHIFT |
+        (CUSTOM_SPI_CLK_HI&SPI_FLASH_CTRL_CLK_HI_MASK)<<SPI_FLASH_CTRL_CLK_HI_SHIFT |
+        (CUSTOM_SPI_CLK_LO&SPI_FLASH_CTRL_CLK_LO_MASK)<<SPI_FLASH_CTRL_CLK_LO_SHIFT |
+        (CUSTOM_SPI_CS_HOLD&SPI_FLASH_CTRL_CS_HOLD_MASK)<<SPI_FLASH_CTRL_CS_HOLD_SHIFT |
+        (CUSTOM_SPI_CS_HI&SPI_FLASH_CTRL_CS_HI_MASK)<<SPI_FLASH_CTRL_CS_HI_SHIFT |
+        (1&SPI_FLASH_CTRL_INS_MASK)<<SPI_FLASH_CTRL_INS_SHIFT;
+
+    AT_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);
+
+    value |= SPI_FLASH_CTRL_START;
+
+    AT_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);
+
+    for (i = 0; i < 10; i++)
+    {
+        msec_delay(1); // 1ms
+        value = AT_READ_REG(hw, REG_SPI_FLASH_CTRL);
+        if (!(value & SPI_FLASH_CTRL_START))
+            break;
+    }
+
+    if (value & SPI_FLASH_CTRL_START)
+        return FALSE;
+
+    *buf = AT_READ_REG(hw, REG_SPI_DATA);
+
+    return TRUE;
+}
+
+//michael add 2005-11-17
+int32_t
+at_set_speed_and_duplex(
+        struct at_hw *hw,
+        uint16_t speed,
+        uint16_t duplex)
+{
+    int32_t ret_val;
+    uint16_t phy_data;
+
+//    DEBUGFUNC("at_get_speed_and_duplex");
+
+    if(speed==SPEED_1000)
+    {
+		hw->MediaType=MEDIA_TYPE_1000M_FULL;
+		phy_data=MII_CR_SPEED_1000;
+    }
+   else if((speed==SPEED_100)&&(duplex==FULL_DUPLEX))
+   {
+   	      hw->MediaType=MEDIA_TYPE_100M_FULL;
+	      phy_data=MII_CR_SPEED_100 | MII_CR_FULL_DUPLEX;
+   }
+   else if((speed==SPEED_100)&&(duplex==HALF_DUPLEX))
+   {
+   	     hw->MediaType=MEDIA_TYPE_100M_HALF;
+	     phy_data=MII_CR_SPEED_100;
+   }
+   else if((speed==SPEED_10)&&(duplex==FULL_DUPLEX))
+   {
+   	    hw->MediaType=MEDIA_TYPE_10M_FULL;
+	    phy_data=MII_CR_SPEED_10 | MII_CR_FULL_DUPLEX;
+   }
+   else if((speed==SPEED_10)&&(duplex==HALF_DUPLEX))
+   {
+   	    hw->MediaType=MEDIA_TYPE_10M_HALF;
+	   phy_data=MII_CR_SPEED_10;
+   }
+   else
+   {
+   	printk(KERN_WARNING "speed=%d, duplex=%d  not supported\n",speed,duplex);
+	return AT_ERR_CONFIG;
+   }
+
+   //add reset signal
+    phy_data |= MII_CR_RESET;
+
+    if (hw->MediaType == MEDIA_TYPE_AUTO_SENSOR ||
+    	hw->MediaType == MEDIA_TYPE_1000M_FULL)
+    	phy_data |= MII_CR_AUTO_NEG_EN;
+
+    ret_val = at_write_phy_reg(hw, MII_BMCR, phy_data);
+    if (ret_val) { // bug fixed
+        uint32_t val;
+        int i;
+        /**************************************
+        * pcie serdes link may be down !
+        **************************************/
+        DEBUGOUT("Auto-Neg make pcie phy link down !");
+
+        for (i=0; i < 25; i++) {
+            msec_delay(1);
+            val = AT_READ_REG(hw, REG_MDIO_CTRL);
+            if (!(val&(MDIO_START|MDIO_BUSY))) {
+                break;
+            }
+        }
+
+        if (0 != (val&(MDIO_START|MDIO_BUSY))) {
+            AT_ERR("pcie linkdown at least for 25ms !\n");
+            return ret_val;
+
+        DEBUGOUT1("pcie linkup after %dms", i);
+        }
+    }
+    return AT_SUCCESS;
+
+}
+
diff -Nurap old/drivers/net/atl1/at_hw.h new/drivers/net/atl1/at_hw.h
--- old/drivers/net/atl1/at_hw.h	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_hw.h	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,1043 @@
+/*
+ * Module Name:
+ *   at_hw.h
+ *
+ * Abstract:
+ *   structures , enums,  and macros for the MAC
+ *
+ * Revision History:
+ *   Who             When        What
+ * ------------------------------------------------
+ *   Huangx      06-08-2004      created
+ *
+ * Notes:
+*/
+
+#ifndef _ATTANSIC_HW_H__
+#define _ATTANSIC_HW_H__
+
+#include "at_osdep.h"
+
+#define _AT_ATTRIB_PACK_    __attribute__ ((packed))
+
+struct at_adapter;
+struct at_hw;
+
+/* function prototype */
+
+int32_t at_reset_hw(struct at_hw* hw);
+int32_t at_read_mac_addr(struct at_hw* hw);
+int32_t at_init_hw(struct at_hw* hw);
+int32_t at_phy_setup_autoneg_adv(struct at_hw *hw);
+int32_t at_phy_reset(struct at_hw *hw);
+int32_t at_get_speed_and_duplex(struct at_hw *hw, uint16_t *speed, uint16_t *duplex);
+//michael add 2005-11-17
+int32_t at_set_speed_and_duplex(struct at_hw *hw, uint16_t speed, uint16_t duplex);
+uint32_t at_auto_get_fc(struct at_adapter* adapter, uint16_t duplex);
+uint32_t at_hash_mc_addr(struct at_hw *hw, uint8_t *mc_addr);
+void at_hash_set(struct at_hw *hw, uint32_t hash_value);
+int32_t at_read_phy_reg(struct at_hw *hw, uint16_t reg_addr, uint16_t *phy_data);
+int32_t at_write_phy_reg(struct at_hw *hw, uint32_t reg_addr, uint16_t phy_data);
+void at_read_pci_cfg(struct at_hw*  hw, uint32_t reg, uint16_t *value);
+void at_write_pci_cfg(struct at_hw* hw, uint32_t reg, uint16_t *value);
+int32_t at_validate_mdi_setting(struct at_hw* hw);
+int32_t at_setup_link(struct at_hw* hw);
+void set_mac_addr(struct at_hw* hw);
+int get_permanent_address(struct at_hw* hw);
+boolean_t read_eeprom(struct at_hw* hw, uint32_t Offset, uint32_t* pValue);
+void init_flash_opcode(struct at_hw* hw);
+boolean_t spi_read(struct at_hw* hw, uint32_t addr, uint32_t* buf);
+int32_t at_phy_enter_power_saving(struct at_hw* hw);
+int32_t at_phy_leave_power_saving(struct at_hw* hw);
+
+/* register definition */
+#define REG_PCIE_CAP_LIST           0x58
+
+#define REG_VPD_CAP                 0x6C
+#define     VPD_CAP_ID_MASK                 0xff
+#define     VPD_CAP_ID_SHIFT                0
+#define     VPD_CAP_NEXT_PTR_MASK           0xFF
+#define     VPD_CAP_NEXT_PTR_SHIFT          8
+#define     VPD_CAP_VPD_ADDR_MASK           0x7FFF
+#define     VPD_CAP_VPD_ADDR_SHIFT          16
+#define     VPD_CAP_VPD_FLAG                0x80000000
+
+#define REG_VPD_DATA                0x70
+
+#define REG_SPI_FLASH_CTRL          0x200
+#define     SPI_FLASH_CTRL_STS_NON_RDY      0x1
+#define     SPI_FLASH_CTRL_STS_WEN          0x2
+#define     SPI_FLASH_CTRL_STS_WPEN         0x80
+#define     SPI_FLASH_CTRL_DEV_STS_MASK     0xFF
+#define     SPI_FLASH_CTRL_DEV_STS_SHIFT    0
+#define     SPI_FLASH_CTRL_INS_MASK         0x7
+#define     SPI_FLASH_CTRL_INS_SHIFT        8
+#define     SPI_FLASH_CTRL_START            0x800
+#define     SPI_FLASH_CTRL_EN_VPD           0x2000
+#define     SPI_FLASH_CTRL_LDSTART          0x8000
+#define     SPI_FLASH_CTRL_CS_HI_MASK       0x3
+#define     SPI_FLASH_CTRL_CS_HI_SHIFT      16
+#define     SPI_FLASH_CTRL_CS_HOLD_MASK     0x3
+#define     SPI_FLASH_CTRL_CS_HOLD_SHIFT    18
+#define     SPI_FLASH_CTRL_CLK_LO_MASK      0x3
+#define     SPI_FLASH_CTRL_CLK_LO_SHIFT     20
+#define     SPI_FLASH_CTRL_CLK_HI_MASK      0x3
+#define     SPI_FLASH_CTRL_CLK_HI_SHIFT     22
+#define     SPI_FLASH_CTRL_CS_SETUP_MASK    0x3
+#define     SPI_FLASH_CTRL_CS_SETUP_SHIFT   24
+#define     SPI_FLASH_CTRL_EROM_PGSZ_MASK   0x3
+#define     SPI_FLASH_CTRL_EROM_PGSZ_SHIFT  26
+#define     SPI_FLASH_CTRL_WAIT_READY       0x10000000
+
+#define REG_SPI_ADDR                0x204
+
+#define REG_SPI_DATA                0x208
+
+#define REG_SPI_FLASH_CONFIG        0x20C
+#define     SPI_FLASH_CONFIG_LD_ADDR_MASK   0xFFFFFF
+#define     SPI_FLASH_CONFIG_LD_ADDR_SHIFT  0
+#define     SPI_FLASH_CONFIG_VPD_ADDR_MASK  0x3
+#define     SPI_FLASH_CONFIG_VPD_ADDR_SHIFT 24
+#define     SPI_FLASH_CONFIG_LD_EXIST       0x4000000
+
+
+#define REG_SPI_FLASH_OP_PROGRAM    0x210
+#define REG_SPI_FLASH_OP_SC_ERASE   0x211
+#define REG_SPI_FLASH_OP_CHIP_ERASE 0x212
+#define REG_SPI_FLASH_OP_RDID       0x213
+#define REG_SPI_FLASH_OP_WREN       0x214
+#define REG_SPI_FLASH_OP_RDSR       0x215
+#define REG_SPI_FLASH_OP_WRSR       0x216
+#define REG_SPI_FLASH_OP_READ       0x217
+
+#define REG_TWSI_CTRL               0x218
+#define     TWSI_CTRL_LD_OFFSET_MASK        0xFF
+#define     TWSI_CTRL_LD_OFFSET_SHIFT       0
+#define     TWSI_CTRL_LD_SLV_ADDR_MASK      0x7
+#define     TWSI_CTRL_LD_SLV_ADDR_SHIFT     8
+#define     TWSI_CTRL_SW_LDSTART            0x800
+#define     TWSI_CTRL_HW_LDSTART            0x1000
+#define     TWSI_CTRL_SMB_SLV_ADDR_MASK     0x0x7F
+#define     TWSI_CTRL_SMB_SLV_ADDR_SHIFT    15
+#define     TWSI_CTRL_LD_EXIST              0x400000
+#define     TWSI_CTRL_READ_FREQ_SEL_MASK    0x3
+#define     TWSI_CTRL_READ_FREQ_SEL_SHIFT   23
+#define     TWSI_CTRL_FREQ_SEL_100K         0
+#define     TWSI_CTRL_FREQ_SEL_200K         1
+#define     TWSI_CTRL_FREQ_SEL_300K         2
+#define     TWSI_CTRL_FREQ_SEL_400K         3
+#define     TWSI_CTRL_SMB_SLV_ADDR
+#define     TWSI_CTRL_WRITE_FREQ_SEL_MASK   0x3
+#define     TWSI_CTRL_WRITE_FREQ_SEL_SHIFT  24
+
+
+#define REG_PCIE_DEV_MISC_CTRL      0x21C
+#define     PCIE_DEV_MISC_CTRL_EXT_PIPE     0x2
+#define     PCIE_DEV_MISC_CTRL_RETRY_BUFDIS 0x1
+#define     PCIE_DEV_MISC_CTRL_SPIROM_EXIST 0x4
+#define     PCIE_DEV_MISC_CTRL_SERDES_ENDIAN    0x8
+#define     PCIE_DEV_MISC_CTRL_SERDES_SEL_DIN   0x10
+
+// Selene Master Control Register
+#define REG_MASTER_CTRL             0x1400
+#define     MASTER_CTRL_SOFT_RST            0x1
+#define     MASTER_CTRL_MTIMER_EN           0x2
+#define     MASTER_CTRL_ITIMER_EN           0x4
+#define     MASTER_CTRL_MANUAL_INT          0x8
+#define     MASTER_CTRL_REV_NUM_SHIFT       16
+#define     MASTER_CTRL_REV_NUM_MASK        0xff
+#define     MASTER_CTRL_DEV_ID_SHIFT        24
+#define     MASTER_CTRL_DEV_ID_MASK         0xff
+
+// Timer Initial Value Register
+#define REG_MANUAL_TIMER_INIT       0x1404
+
+// IRQ ModeratorTimer Initial Value Register
+#define REG_IRQ_MODU_TIMER_INIT     0x1408
+
+#define REG_GPHY_ENABLE		    0x140C //w
+// IRQ Anti-Lost Timer Initial Value Register
+#define REG_CMBDISDMA_TIMER         0x140E
+// Block IDLE Status Register
+#define REG_IDLE_STATUS             0x1410
+#define     IDLE_STATUS_RXMAC               1
+#define     IDLE_STATUS_TXMAC               2
+#define     IDLE_STATUS_RXQ                 4
+#define     IDLE_STATUS_TXQ                 8
+#define     IDLE_STATUS_DMAR                0x10
+#define     IDLE_STATUS_DMAW                0x20
+#define     IDLE_STATUS_SMB                 0x40
+#define     IDLE_STATUS_CMB                 0x80
+
+// MDIO Control Register
+#define REG_MDIO_CTRL               0x1414
+#define     MDIO_DATA_MASK                  0xffff
+#define     MDIO_DATA_SHIFT                 0
+#define     MDIO_REG_ADDR_MASK              0x1f
+#define     MDIO_REG_ADDR_SHIFT             16
+#define     MDIO_RW                         0x200000
+#define     MDIO_SUP_PREAMBLE               0x400000
+#define     MDIO_START                      0x800000
+#define     MDIO_CLK_SEL_SHIFT              24
+#define     MDIO_CLK_25_4                   0
+#define     MDIO_CLK_25_6                   2
+#define     MDIO_CLK_25_8                   3
+#define     MDIO_CLK_25_10                  4
+#define     MDIO_CLK_25_14                  5
+#define     MDIO_CLK_25_20                  6
+#define     MDIO_CLK_25_28                  7
+#define     MDIO_BUSY                       0x8000000
+#define     MDIO_WAIT_TIMES                 30
+
+// MII PHY Status Register
+#define REG_PHY_STATUS              0x1418
+
+// BIST Control and Status Register0 (for the Packet Memory)
+#define REG_BIST0_CTRL              0x141c
+#define     BIST0_NOW                       0x1
+#define     BIST0_SRAM_FAIL                 0x2
+#define     BIST0_FUSE_FLAG                 0x4
+#define REG_BIST1_CTRL              0x1420
+#define     BIST1_NOW                       0x1
+#define     BIST1_SRAM_FAIL                 0x2
+#define     BIST1_FUSE_FLAG                 0x4
+
+// MAC Control Register
+#define REG_MAC_CTRL                0x1480
+#define     MAC_CTRL_TX_EN                  1
+#define     MAC_CTRL_RX_EN                  2
+#define     MAC_CTRL_TX_FLOW                4
+#define     MAC_CTRL_RX_FLOW                8
+#define     MAC_CTRL_LOOPBACK               0x10
+#define     MAC_CTRL_DUPLX                  0x20
+#define     MAC_CTRL_ADD_CRC                0x40
+#define     MAC_CTRL_PAD                    0x80
+#define     MAC_CTRL_LENCHK                 0x100
+#define     MAC_CTRL_HUGE_EN                0x200
+#define     MAC_CTRL_PRMLEN_SHIFT           10
+#define     MAC_CTRL_PRMLEN_MASK            0xf
+#define     MAC_CTRL_RMV_VLAN               0x4000
+#define     MAC_CTRL_PROMIS_EN              0x8000
+#define     MAC_CTRL_TX_PAUSE               0x10000
+#define     MAC_CTRL_SCNT                   0x20000
+#define     MAC_CTRL_SRST_TX                0x40000
+#define     MAC_CTRL_TX_SIMURST             0x80000
+#define     MAC_CTRL_SPEED_SHIFT            20
+#define     MAC_CTRL_SPEED_MASK             0x300000
+#define     MAC_CTRL_SPEED_1000             2
+#define     MAC_CTRL_SPEED_10_100           1
+#define     MAC_CTRL_DBG_TX_BKPRESURE       0x400000
+#define     MAC_CTRL_TX_HUGE                0x800000
+#define     MAC_CTRL_RX_CHKSUM_EN           0x1000000
+#define     MAC_CTRL_MC_ALL_EN              0x2000000
+#define     MAC_CTRL_BC_EN                  0x4000000
+#define     MAC_CTRL_DBG                    0x8000000
+
+// MAC IPG/IFG Control Register
+#define REG_MAC_IPG_IFG             0x1484
+#define     MAC_IPG_IFG_IPGT_SHIFT          0
+#define     MAC_IPG_IFG_IPGT_MASK           0x7f
+#define     MAC_IPG_IFG_MIFG_SHIFT          8
+#define     MAC_IPG_IFG_MIFG_MASK           0xff
+#define     MAC_IPG_IFG_IPGR1_SHIFT         16
+#define     MAC_IPG_IFG_IPGR1_MASK          0x7f
+#define     MAC_IPG_IFG_IPGR2_SHIFT         24
+#define     MAC_IPG_IFG_IPGR2_MASK          0x7f
+
+// MAC STATION ADDRESS
+#define REG_MAC_STA_ADDR            0x1488
+
+// Hash table for multicast address
+#define REG_RX_HASH_TABLE           0x1490
+
+// MAC Half-Duplex Control Register
+#define REG_MAC_HALF_DUPLX_CTRL     0x1498
+#define     MAC_HALF_DUPLX_CTRL_LCOL_SHIFT   0
+#define     MAC_HALF_DUPLX_CTRL_LCOL_MASK    0x3ff
+#define     MAC_HALF_DUPLX_CTRL_RETRY_SHIFT  12
+#define     MAC_HALF_DUPLX_CTRL_RETRY_MASK   0xf
+#define     MAC_HALF_DUPLX_CTRL_EXC_DEF_EN   0x10000
+#define     MAC_HALF_DUPLX_CTRL_NO_BACK_C    0x20000
+#define     MAC_HALF_DUPLX_CTRL_NO_BACK_P    0x40000
+#define     MAC_HALF_DUPLX_CTRL_ABEBE        0x80000
+#define     MAC_HALF_DUPLX_CTRL_ABEBT_SHIFT  20
+#define     MAC_HALF_DUPLX_CTRL_ABEBT_MASK   0xf
+#define     MAC_HALF_DUPLX_CTRL_JAMIPG_SHIFT 24
+#define     MAC_HALF_DUPLX_CTRL_JAMIPG_MASK  0xf
+
+// Maximum Frame Length Control Register
+#define REG_MTU                     0x149c
+
+// Wake-On-Lan control register
+#define REG_WOL_CTRL                0x14a0
+#define     WOL_PATTERN_EN                  0x00000001
+#define     WOL_PATTERN_PME_EN              0x00000002
+#define     WOL_MAGIC_EN                    0x00000004
+#define     WOL_MAGIC_PME_EN                0x00000008
+#define     WOL_LINK_CHG_EN                 0x00000010
+#define     WOL_LINK_CHG_PME_EN             0x00000020
+#define     WOL_PATTERN_ST                  0x00000100
+#define     WOL_MAGIC_ST                    0x00000200
+#define     WOL_LINKCHG_ST                  0x00000400
+#define     WOL_CLK_SWITCH_EN               0x00008000
+#define     WOL_PT0_EN                      0x00010000
+#define     WOL_PT1_EN                      0x00020000
+#define     WOL_PT2_EN                      0x00040000
+#define     WOL_PT3_EN                      0x00080000
+#define     WOL_PT4_EN                      0x00100000
+#define     WOL_PT5_EN                      0x00200000
+#define     WOL_PT6_EN                      0x00400000
+
+// WOL Length ( 2 DWORD )
+#define REG_WOL_PATTERN_LEN         0x14a4
+#define     WOL_PT_LEN_MASK                 0x7f
+#define     WOL_PT0_LEN_SHIFT               0
+#define     WOL_PT1_LEN_SHIFT               8
+#define     WOL_PT2_LEN_SHIFT               16
+#define     WOL_PT3_LEN_SHIFT               24
+#define     WOL_PT4_LEN_SHIFT               0
+#define     WOL_PT5_LEN_SHIFT               8
+#define     WOL_PT6_LEN_SHIFT               16
+
+// Internal SRAM Partition Register
+#define REG_SRAM_RFD_ADDR           0x1500
+#define REG_SRAM_RFD_LEN            (REG_SRAM_RFD_ADDR+ 4)
+#define REG_SRAM_RRD_ADDR           (REG_SRAM_RFD_ADDR+ 8)
+#define REG_SRAM_RRD_LEN            (REG_SRAM_RFD_ADDR+12)
+#define REG_SRAM_TPD_ADDR           (REG_SRAM_RFD_ADDR+16)
+#define REG_SRAM_TPD_LEN            (REG_SRAM_RFD_ADDR+20)
+#define REG_SRAM_TRD_ADDR           (REG_SRAM_RFD_ADDR+24)
+#define REG_SRAM_TRD_LEN            (REG_SRAM_RFD_ADDR+28)
+#define REG_SRAM_RXF_ADDR           (REG_SRAM_RFD_ADDR+32)
+#define REG_SRAM_RXF_LEN            (REG_SRAM_RFD_ADDR+36)
+#define REG_SRAM_TXF_ADDR           (REG_SRAM_RFD_ADDR+40)
+#define REG_SRAM_TXF_LEN            (REG_SRAM_RFD_ADDR+44)
+#define REG_SRAM_TCPH_PATH_ADDR     (REG_SRAM_RFD_ADDR+48)
+#define     SRAM_TCPH_ADDR_MASK             0x0fff
+#define     SRAM_TCPH_ADDR_SHIFT            0
+#define     SRAM_PATH_ADDR_MASK             0x0fff
+#define     SRAM_PATH_ADDR_SHIFT            16
+
+// Load Ptr Register
+#define REG_LOAD_PTR                (REG_SRAM_RFD_ADDR+52)
+
+//  Descriptor Control register
+#define REG_DESC_BASE_ADDR_HI       0x1540
+#define REG_DESC_RFD_ADDR_LO        (REG_DESC_BASE_ADDR_HI+4)
+#define REG_DESC_RRD_ADDR_LO        (REG_DESC_BASE_ADDR_HI+8)
+#define REG_DESC_TPD_ADDR_LO        (REG_DESC_BASE_ADDR_HI+12)
+#define REG_DESC_CMB_ADDR_LO        (REG_DESC_BASE_ADDR_HI+16)
+#define REG_DESC_SMB_ADDR_LO        (REG_DESC_BASE_ADDR_HI+20)
+#define REG_DESC_RFD_RRD_RING_SIZE  (REG_DESC_BASE_ADDR_HI+24)
+#define     DESC_RFD_RING_SIZE_MASK         0x7ff
+#define     DESC_RFD_RING_SIZE_SHIFT        0
+#define     DESC_RRD_RING_SIZE_MASK         0x7ff
+#define     DESC_RRD_RING_SIZE_SHIFT        16
+#define REG_DESC_TPD_RING_SIZE      (REG_DESC_BASE_ADDR_HI+28)
+#define     DESC_TPD_RING_SIZE_MASK         0x3ff
+#define     DESC_TPD_RING_SIZE_SHIFT        0
+
+// TXQ Control Register
+#define REG_TXQ_CTRL                0x1580
+#define     TXQ_CTRL_TPD_BURST_NUM_SHIFT    0
+#define     TXQ_CTRL_TPD_BURST_NUM_MASK     0x1f
+#define     TXQ_CTRL_EN                     0x20
+#define     TXQ_CTRL_ENH_MODE               0x40
+#define     TXQ_CTRL_TPD_FETCH_TH_SHIFT     8
+#define     TXQ_CTRL_TPD_FETCH_TH_MASK      0x3f
+#define     TXQ_CTRL_TXF_BURST_NUM_SHIFT    16
+#define     TXQ_CTRL_TXF_BURST_NUM_MASK     0xffff
+
+// Jumbo packet Threshold for task offload
+#define REG_TX_JUMBO_TASK_TH_TPD_IPG        0x1584
+#define     TX_JUMBO_TASK_TH_MASK           0x7ff
+#define     TX_JUMBO_TASK_TH_SHIFT          0
+#define     TX_TPD_MIN_IPG_MASK             0x1f
+#define     TX_TPD_MIN_IPG_SHIFT            16
+
+
+// RXQ Control Register
+#define REG_RXQ_CTRL                0x15a0
+#define     RXQ_CTRL_RFD_BURST_NUM_SHIFT    0
+#define     RXQ_CTRL_RFD_BURST_NUM_MASK     0xff
+#define     RXQ_CTRL_RRD_BURST_THRESH_SHIFT 8
+#define     RXQ_CTRL_RRD_BURST_THRESH_MASK  0xff
+#define     RXQ_CTRL_RFD_PREF_MIN_IPG_SHIFT 16
+#define     RXQ_CTRL_RFD_PREF_MIN_IPG_MASK  0x1f
+#define     RXQ_CTRL_CUT_THRU_EN            0x40000000
+#define     RXQ_CTRL_EN                     0x80000000
+
+// Rx jumbo packet threshold and rrd  retirement timer
+#define REG_RXQ_JMBOSZ_RRDTIM       (REG_RXQ_CTRL+ 4)
+#define     RXQ_JMBOSZ_TH_MASK              0x7ff
+#define     RXQ_JMBOSZ_TH_SHIFT             0
+#define     RXQ_JMBO_LKAH_MASK              0xf
+#define     RXQ_JMBO_LKAH_SHIFT             11
+#define     RXQ_RRD_TIMER_MASK              0xffff
+#define     RXQ_RRD_TIMER_SHIFT             16
+
+// RFD flow control register
+#define REG_RXQ_RXF_PAUSE_THRESH    (REG_RXQ_CTRL+ 8)
+#define     RXQ_RXF_PAUSE_TH_HI_SHIFT       16
+#define     RXQ_RXF_PAUSE_TH_HI_MASK        0xfff
+#define     RXQ_RXF_PAUSE_TH_LO_SHIFT       0
+#define     RXQ_RXF_PAUSE_TH_LO_MASK        0xfff
+
+// RRD flow control register
+#define REG_RXQ_RRD_PAUSE_THRESH    (REG_RXQ_CTRL+12)
+#define     RXQ_RRD_PAUSE_TH_HI_SHIFT       0
+#define     RXQ_RRD_PAUSE_TH_HI_MASK        0xfff
+#define     RXQ_RRD_PAUSE_TH_LO_SHIFT       16
+#define     RXQ_RRD_PAUSE_TH_LO_MASK        0xfff
+
+// DMA Engine Control Register
+#define REG_DMA_CTRL                0x15c0
+#define     DMA_CTRL_DMAR_IN_ORDER          0x1
+#define     DMA_CTRL_DMAR_ENH_ORDER         0x2
+#define     DMA_CTRL_DMAR_OUT_ORDER         0x4
+#define     DMA_CTRL_RCB_VALUE              0x8
+#define     DMA_CTRL_DMAR_BURST_LEN_SHIFT   4
+#define     DMA_CTRL_DMAR_BURST_LEN_MASK    7
+#define     DMA_CTRL_DMAW_BURST_LEN_SHIFT   7
+#define     DMA_CTRL_DMAW_BURST_LEN_MASK    7
+#define     DMA_CTRL_DMAR_EN                0x400
+#define     DMA_CTRL_DMAW_EN                0x800
+
+// CMB/SMB Control Register
+#define REG_CSMB_CTRL               0x15d0
+#define     CSMB_CTRL_CMB_NOW               1
+#define     CSMB_CTRL_SMB_NOW               2
+#define     CSMB_CTRL_CMB_EN                4
+#define     CSMB_CTRL_SMB_EN                8
+
+// CMB DMA Write Threshold Register
+#define REG_CMB_WRITE_TH            (REG_CSMB_CTRL+ 4)
+#define     CMB_RRD_TH_SHIFT                0
+#define     CMB_RRD_TH_MASK                 0x7ff
+#define     CMB_TPD_TH_SHIFT                16
+#define     CMB_TPD_TH_MASK                 0x7ff
+
+// RX/TX count-down timer to trigger CMB-write. 2us resolution.
+#define REG_CMB_WRITE_TIMER         (REG_CSMB_CTRL+ 8)
+#define     CMB_RX_TM_SHIFT                 0
+#define     CMB_RX_TM_MASK                  0xffff
+#define     CMB_TX_TM_SHIFT                 16
+#define     CMB_TX_TM_MASK                  0xffff
+
+// Number of packet received since last CMB write
+#define REG_CMB_RX_PKT_CNT          (REG_CSMB_CTRL+12)
+
+// Number of packet transmitted since last CMB write
+#define REG_CMB_TX_PKT_CNT          (REG_CSMB_CTRL+16)
+
+// SMB auto DMA timer register
+#define REG_SMB_TIMER               (REG_CSMB_CTRL+20)
+
+// Mailbox Register
+#define REG_MAILBOX                 0x15f0
+#define     MB_RFD_PROD_INDX_SHIFT          0
+#define     MB_RFD_PROD_INDX_MASK           0x7ff
+#define     MB_RRD_CONS_INDX_SHIFT          11
+#define     MB_RRD_CONS_INDX_MASK           0x7ff
+#define     MB_TPD_PROD_INDX_SHIFT          22
+#define     MB_TPD_PROD_INDX_MASK           0x3ff
+
+// Interrupt Status Register
+#define REG_ISR                     0x1600
+#define     ISR_SMB                         1
+#define     ISR_TIMER                       2
+#define     ISR_MANUAL                      4
+#define     ISR_RXF_OV                      8
+#define     ISR_RFD_UNRUN                   0x10
+#define     ISR_RRD_OV                      0x20
+#define     ISR_TXF_UNRUN                   0x40
+#define     ISR_LINK                        0x80
+#define     ISR_HOST_RFD_UNRUN              0x100
+#define     ISR_HOST_RRD_OV                 0x200
+#define     ISR_DMAR_TO_RST                 0x400
+#define     ISR_DMAW_TO_RST                 0x800
+#define     ISR_GPHY                        0x1000
+#define     ISR_RX_PKT                      0x10000
+#define     ISR_TX_PKT                      0x20000
+#define     ISR_TX_DMA                      0x40000
+#define     ISR_RX_DMA                      0x80000
+#define     ISR_CMB_RX                      0x100000
+#define     ISR_CMB_TX                      0x200000
+#define     ISR_MAC_RX                      0x400000
+#define     ISR_MAC_TX                      0x800000
+#define     ISR_UR_DETECTED                 0x1000000
+#define     ISR_FERR_DETECTED               0x2000000
+#define     ISR_NFERR_DETECTED              0x4000000
+#define     ISR_CERR_DETECTED               0x8000000
+#define     ISR_PHY_LINKDOWN                0x10000000
+#define     ISR_DIS_SMB                     0x20000000
+#define     ISR_DIS_DMA                     0x40000000
+#define     ISR_DIS_INT                     0x80000000
+
+// Interrupt Mask Register
+#define REG_IMR                     0x1604
+
+
+
+/* Normal Interrupt mask  */
+#define IMR_NORMAL_MASK     (\
+    ISR_SMB         |        \
+    ISR_GPHY        |        \
+    ISR_PHY_LINKDOWN|        \
+    ISR_DMAR_TO_RST |        \
+    ISR_DMAW_TO_RST |        \
+    ISR_CMB_TX      |        \
+    ISR_CMB_RX      )
+
+
+/* Debug Interrupt Mask  (enable all interrupt) */
+#define IMR_DEBUG_MASK     (\
+    ISR_SMB         |       \
+    ISR_TIMER       |       \
+    ISR_MANUAL      |       \
+    ISR_RXF_OV      |       \
+    ISR_RFD_UNRUN   |       \
+    ISR_RRD_OV      |       \
+    ISR_TXF_UNRUN   |       \
+    ISR_LINK        |       \
+    ISR_CMB_TX      |       \
+    ISR_CMB_RX      |       \
+    ISR_RX_PKT      |       \
+    ISR_TX_PKT      |       \
+    ISR_MAC_RX      |       \
+    ISR_MAC_TX              )
+
+// Interrupt Status Register
+#define REG_RFD_RRD_IDX             0x1800
+#define REG_TPD_IDX                 0x1804
+
+/***************************** MII definition ***************************************/
+/* PHY Common Register */
+#define MII_BMCR                        0x00
+#define MII_BMSR                        0x01
+#define MII_PHYSID1                     0x02
+#define MII_PHYSID2                     0x03
+#define MII_ADVERTISE                   0x04
+#define MII_LPA                         0x05
+#define MII_EXPANSION                   0x06
+#define MII_AT001_CR                    0x09
+#define MII_AT001_SR                    0x0A
+#define MII_AT001_ESR                   0x0F
+#define MII_AT001_PSCR                  0x10
+#define MII_AT001_PSSR                  0x11
+#define MII_DCOUNTER                    0x12
+#define MII_FCSCOUNTER                  0x13
+#define MII_NWAYTEST                    0x14
+#define MII_RERRCOUNTER                 0x15
+#define MII_SREVISION                   0x16
+#define MII_RESV1                       0x17
+#define MII_LBRERROR                    0x18
+#define MII_PHYADDR                     0x19
+#define MII_RESV2                       0x1a
+#define MII_TPISTATUS                   0x1b
+#define MII_NCONFIG                     0x1c
+
+
+/* PHY Control Register */
+#define MII_CR_SPEED_SELECT_MSB                  0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_COLL_TEST_ENABLE                  0x0080  /* Collision test enable */
+#define MII_CR_FULL_DUPLEX                       0x0100  /* FDX =1, half duplex =0 */
+#define MII_CR_RESTART_AUTO_NEG                  0x0200  /* Restart auto negotiation */
+#define MII_CR_ISOLATE                           0x0400  /* Isolate PHY from MII */
+#define MII_CR_POWER_DOWN                        0x0800  /* Power down */
+#define MII_CR_AUTO_NEG_EN                       0x1000  /* Auto Neg Enable */
+#define MII_CR_SPEED_SELECT_LSB                  0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_LOOPBACK                          0x4000  /* 0 = normal, 1 = loopback */
+#define MII_CR_RESET                             0x8000  /* 0 = normal, 1 = PHY reset */
+#define MII_CR_SPEED_MASK                        0x2040
+#define MII_CR_SPEED_1000                        0x0040
+#define MII_CR_SPEED_100                         0x2000
+#define MII_CR_SPEED_10                          0x0000
+
+
+/* PHY Status Register */
+#define MII_SR_EXTENDED_CAPS                     0x0001  /* Extended register capabilities */
+#define MII_SR_JABBER_DETECT                     0x0002  /* Jabber Detected */
+#define MII_SR_LINK_STATUS                       0x0004  /* Link Status 1 = link */
+#define MII_SR_AUTONEG_CAPS                      0x0008  /* Auto Neg Capable */
+#define MII_SR_REMOTE_FAULT                      0x0010  /* Remote Fault Detect */
+#define MII_SR_AUTONEG_COMPLETE                  0x0020  /* Auto Neg Complete */
+#define MII_SR_PREAMBLE_SUPPRESS                 0x0040  /* Preamble may be suppressed */
+#define MII_SR_EXTENDED_STATUS                   0x0100  /* Ext. status info in Reg 0x0F */
+#define MII_SR_100T2_HD_CAPS                     0x0200  /* 100T2 Half Duplex Capable */
+#define MII_SR_100T2_FD_CAPS                     0x0400  /* 100T2 Full Duplex Capable */
+#define MII_SR_10T_HD_CAPS                       0x0800  /* 10T   Half Duplex Capable */
+#define MII_SR_10T_FD_CAPS                       0x1000  /* 10T   Full Duplex Capable */
+#define MII_SR_100X_HD_CAPS                      0x2000  /* 100X  Half Duplex Capable */
+#define MII_SR_100X_FD_CAPS                      0x4000  /* 100X  Full Duplex Capable */
+#define MII_SR_100T4_CAPS                        0x8000  /* 100T4 Capable */
+
+/* Link partner ability register. */
+#define MII_LPA_SLCT                             0x001f  /* Same as advertise selector  */
+#define MII_LPA_10HALF                           0x0020  /* Can do 10mbps half-duplex   */
+#define MII_LPA_10FULL                           0x0040  /* Can do 10mbps full-duplex   */
+#define MII_LPA_100HALF                          0x0080  /* Can do 100mbps half-duplex  */
+#define MII_LPA_100FULL                          0x0100  /* Can do 100mbps full-duplex  */
+#define MII_LPA_100BASE4                         0x0200  /* 100BASE-T4  */
+#define MII_LPA_PAUSE                            0x0400  /* PAUSE */
+#define MII_LPA_ASYPAUSE                         0x0800  /* Asymmetrical PAUSE */
+#define MII_LPA_RFAULT                           0x2000  /* Link partner faulted        */
+#define MII_LPA_LPACK                            0x4000  /* Link partner acked us       */
+#define MII_LPA_NPAGE                            0x8000  /* Next page bit               */
+
+/* Autoneg Advertisement Register */
+#define MII_AR_SELECTOR_FIELD                   0x0001  /* indicates IEEE 802.3 CSMA/CD */
+#define MII_AR_10T_HD_CAPS                      0x0020  /* 10T   Half Duplex Capable */
+#define MII_AR_10T_FD_CAPS                      0x0040  /* 10T   Full Duplex Capable */
+#define MII_AR_100TX_HD_CAPS                    0x0080  /* 100TX Half Duplex Capable */
+#define MII_AR_100TX_FD_CAPS                    0x0100  /* 100TX Full Duplex Capable */
+#define MII_AR_100T4_CAPS                       0x0200  /* 100T4 Capable */
+#define MII_AR_PAUSE                            0x0400  /* Pause operation desired */
+#define MII_AR_ASM_DIR                          0x0800  /* Asymmetric Pause Direction bit */
+#define MII_AR_REMOTE_FAULT                     0x2000  /* Remote Fault detected */
+#define MII_AR_NEXT_PAGE                        0x8000  /* Next Page ability supported */
+#define MII_AR_SPEED_MASK                       0x01E0
+#define MII_AR_DEFAULT_CAP_MASK                 0x0DE0
+
+/* 1000BASE-T Control Register */
+#define MII_AT001_CR_1000T_HD_CAPS              0x0100  /* Advertise 1000T HD capability */
+#define MII_AT001_CR_1000T_FD_CAPS              0x0200  /* Advertise 1000T FD capability  */
+#define MII_AT001_CR_1000T_REPEATER_DTE         0x0400  /* 1=Repeater/switch device port */
+                                                        /* 0=DTE device */
+#define MII_AT001_CR_1000T_MS_VALUE             0x0800  /* 1=Configure PHY as Master */
+                                                        /* 0=Configure PHY as Slave */
+#define MII_AT001_CR_1000T_MS_ENABLE            0x1000  /* 1=Master/Slave manual config value */
+                                                        /* 0=Automatic Master/Slave config */
+#define MII_AT001_CR_1000T_TEST_MODE_NORMAL     0x0000  /* Normal Operation */
+#define MII_AT001_CR_1000T_TEST_MODE_1          0x2000  /* Transmit Waveform test */
+#define MII_AT001_CR_1000T_TEST_MODE_2          0x4000  /* Master Transmit Jitter test */
+#define MII_AT001_CR_1000T_TEST_MODE_3          0x6000  /* Slave Transmit Jitter test */
+#define MII_AT001_CR_1000T_TEST_MODE_4          0x8000  /* Transmitter Distortion test */
+#define MII_AT001_CR_1000T_SPEED_MASK           0x0300
+#define MII_AT001_CR_1000T_DEFAULT_CAP_MASK     0x0300
+
+/* 1000BASE-T Status Register */
+#define MII_AT001_SR_1000T_LP_HD_CAPS           0x0400  /* LP is 1000T HD capable */
+#define MII_AT001_SR_1000T_LP_FD_CAPS           0x0800  /* LP is 1000T FD capable */
+#define MII_AT001_SR_1000T_REMOTE_RX_STATUS     0x1000  /* Remote receiver OK */
+#define MII_AT001_SR_1000T_LOCAL_RX_STATUS      0x2000  /* Local receiver OK */
+#define MII_AT001_SR_1000T_MS_CONFIG_RES        0x4000  /* 1=Local TX is Master, 0=Slave */
+#define MII_AT001_SR_1000T_MS_CONFIG_FAULT      0x8000  /* Master/Slave config fault */
+#define MII_AT001_SR_1000T_REMOTE_RX_STATUS_SHIFT   12
+#define MII_AT001_SR_1000T_LOCAL_RX_STATUS_SHIFT    13
+
+/* Extended Status Register */
+#define MII_AT001_ESR_1000T_HD_CAPS             0x1000  /* 1000T HD capable */
+#define MII_AT001_ESR_1000T_FD_CAPS             0x2000  /* 1000T FD capable */
+#define MII_AT001_ESR_1000X_HD_CAPS             0x4000  /* 1000X HD capable */
+#define MII_AT001_ESR_1000X_FD_CAPS             0x8000  /* 1000X FD capable */
+
+/* AT001 PHY Specific Control Register */
+#define MII_AT001_PSCR_JABBER_DISABLE           0x0001  /* 1=Jabber Function disabled */
+#define MII_AT001_PSCR_POLARITY_REVERSAL        0x0002  /* 1=Polarity Reversal enabled */
+#define MII_AT001_PSCR_SQE_TEST                 0x0004  /* 1=SQE Test enabled *//
+#define MII_AT001_PSCR_MAC_POWERDOWN            0x0008
+#define MII_AT001_PSCR_CLK125_DISABLE           0x0010  /* 1=CLK125 low,
+                                                         * 0=CLK125 toggling
+                                                         */
+#define MII_AT001_PSCR_MDI_MANUAL_MODE          0x0000  /* MDI Crossover Mode bits 6:5 */
+                                                        /* Manual MDI configuration */
+#define MII_AT001_PSCR_MDIX_MANUAL_MODE         0x0020  /* Manual MDIX configuration */
+#define MII_AT001_PSCR_AUTO_X_1000T             0x0040  /* 1000BASE-T: Auto crossover,
+                                                         *  100BASE-TX/10BASE-T:
+                                                         *  MDI Mode
+                                                         */
+#define MII_AT001_PSCR_AUTO_X_MODE              0x0060  /* Auto crossover enabled
+                                                         * all speeds.
+                                                         */
+#define MII_AT001_PSCR_10BT_EXT_DIST_ENABLE     0x0080
+                                                        /* 1=Enable Extended 10BASE-T distance
+                                                         * (Lower 10BASE-T RX Threshold)
+                                                         * 0=Normal 10BASE-T RX Threshold */
+#define MII_AT001_PSCR_MII_5BIT_ENABLE          0x0100
+                                                        /* 1=5-Bit interface in 100BASE-TX
+                                                         * 0=MII interface in 100BASE-TX */
+#define MII_AT001_PSCR_SCRAMBLER_DISABLE        0x0200  /* 1=Scrambler disable */
+#define MII_AT001_PSCR_FORCE_LINK_GOOD          0x0400  /* 1=Force link good */
+#define MII_AT001_PSCR_ASSERT_CRS_ON_TX         0x0800  /* 1=Assert CRS on Transmit */
+#define MII_AT001_PSCR_POLARITY_REVERSAL_SHIFT    1
+#define MII_AT001_PSCR_AUTO_X_MODE_SHIFT          5
+#define MII_AT001_PSCR_10BT_EXT_DIST_ENABLE_SHIFT 7
+
+
+/* AT001 PHY Specific Status Register */
+#define MII_AT001_PSSR_SPD_DPLX_RESOLVED        0x0800  /* 1=Speed & Duplex resolved */
+#define MII_AT001_PSSR_DPLX                     0x2000  /* 1=Duplex 0=Half Duplex */
+#define MII_AT001_PSSR_SPEED                    0xC000  /* Speed, bits 14:15 */
+#define MII_AT001_PSSR_10MBS                    0x0000  /* 00=10Mbs */
+#define MII_AT001_PSSR_100MBS                   0x4000  /* 01=100Mbs */
+#define MII_AT001_PSSR_1000MBS                  0x8000  /* 10=1000Mbs */
+
+/*********************PCI Command Register ******************************/
+// PCI Command Register Bit Definitions
+#define PCI_REG_COMMAND         0x04    // PCI Command Register
+#define CMD_IO_SPACE            0x0001
+#define CMD_MEMORY_SPACE        0x0002
+#define CMD_BUS_MASTER          0x0004
+
+/* Wake Up Filter Control */
+#define AT_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
+#define AT_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
+#define AT_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
+#define AT_WUFC_MC   0x00000008 /* Multicast Wakeup Enable */
+#define AT_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
+
+/************************************************************************************************************************/
+
+/* Error Codes */
+
+#define AT_SUCCESS                      0
+#define AT_ERR_EEPROM                   1
+#define AT_ERR_PHY                      2
+#define AT_ERR_CONFIG                   3
+#define AT_ERR_PARAM                    4
+#define AT_ERR_MAC_TYPE                 5
+#define AT_ERR_PHY_TYPE                 6
+#define AT_ERR_PHY_SPEED                7
+#define AT_ERR_PHY_RES                  8
+
+#define SPEED_0             0xffff
+#define SPEED_10            10
+#define SPEED_100           100
+#define SPEED_1000          1000
+#define HALF_DUPLEX         1
+#define FULL_DUPLEX         2
+
+#define MEDIA_TYPE_AUTO_SENSOR			0
+#define MEDIA_TYPE_1000M_FULL			1
+#define MEDIA_TYPE_100M_FULL			2
+#define MEDIA_TYPE_100M_HALF			3
+#define MEDIA_TYPE_10M_FULL				4
+#define MEDIA_TYPE_10M_HALF				5
+
+
+
+
+#define ADVERTISE_10_HALF               0x0001
+#define ADVERTISE_10_FULL               0x0002
+#define ADVERTISE_100_HALF              0x0004
+#define ADVERTISE_100_FULL              0x0008
+#define ADVERTISE_1000_HALF             0x0010
+#define ADVERTISE_1000_FULL             0x0020
+#define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F /* Everything but 1000-Half */
+#define AUTONEG_ADVERTISE_10_100_ALL    0x000F /* All 10/100 speeds*/
+#define AUTONEG_ADVERTISE_10_ALL        0x0003 /* 10Mbps Full & Half speeds*/
+
+
+/* The size (in bytes) of a ethernet packet */
+#define ENET_HEADER_SIZE                14
+#define MAXIMUM_ETHERNET_FRAME_SIZE     1518 /* with FCS */
+#define MINIMUM_ETHERNET_FRAME_SIZE     64   /* with FCS */
+#define ETHERNET_FCS_SIZE               4
+#define MAX_JUMBO_FRAME_SIZE            0x2800
+
+#define PHY_AUTO_NEG_TIME               45          /* 4.5 Seconds */
+#define PHY_FORCE_TIME                  20          /* 2.0 Seconds */
+
+/* For checksumming , the sum of all words in the EEPROM should equal 0xBABA */
+#define EEPROM_SUM                      0xBABA
+#define NODE_ADDRESS_SIZE               6
+
+
+/* Statistics counters collected by the MAC */
+typedef struct stats_msg_block {
+        // rx
+        uint32_t            rx_ok;                  // The number of good packet received.
+        uint32_t            rx_bcast;               // The number of good broadcast packet received.
+        uint32_t            rx_mcast;               // The number of good multicast packet received.
+        uint32_t            rx_pause;               // The number of Pause packet received.
+        uint32_t            rx_ctrl;                // The number of Control packet received other than Pause frame.
+        uint32_t            rx_fcs_err;             // The number of packets with bad FCS.
+        uint32_t            rx_len_err;             // The number of packets with mismatch of length field and actual size.
+        uint32_t            rx_byte_cnt;            // The number of bytes of good packet received. FCS is NOT included.
+        uint32_t            rx_runt;                // The number of packets received that are less than 64 byte long and with good FCS.
+        uint32_t            rx_frag;                // The number of packets received that are less than 64 byte long and with bad FCS.
+        uint32_t            rx_sz_64;               // The number of good and bad packets received that are 64 byte long.
+        uint32_t            rx_sz_65_127;           // The number of good and bad packets received that are between 65 and 127-byte long.
+        uint32_t            rx_sz_128_255;          // The number of good and bad packets received that are between 128 and 255-byte long.
+        uint32_t            rx_sz_256_511;          // The number of good and bad packets received that are between 256 and 511-byte long.
+        uint32_t            rx_sz_512_1023;         // The number of good and bad packets received that are between 512 and 1023-byte long.
+        uint32_t            rx_sz_1024_1518;        // The number of good and bad packets received that are between 1024 and 1518-byte long.
+        uint32_t            rx_sz_1519_max;         // The number of good and bad packets received that are between 1519-byte and MTU.
+        uint32_t            rx_sz_ov;               // The number of good and bad packets received that are more than MTU size C truncated by Selene.
+        uint32_t            rx_rxf_ov;              // The number of frame dropped due to occurrence of RX FIFO overflow.
+        uint32_t            rx_rrd_ov;              // The number of frame dropped due to occurrence of RRD overflow.
+        uint32_t            rx_align_err;           // Alignment Error
+        uint32_t            rx_bcast_byte_cnt;      // The byte count of broadcast packet received, excluding FCS.
+        uint32_t            rx_mcast_byte_cnt;      // The byte count of multicast packet received, excluding FCS.
+        uint32_t            rx_err_addr;            // The number of packets dropped due to address filtering.
+
+        // tx
+        uint32_t            tx_ok;                  // The number of good packet transmitted.
+        uint32_t            tx_bcast;               // The number of good broadcast packet transmitted.
+        uint32_t            tx_mcast;               // The number of good multicast packet transmitted.
+        uint32_t            tx_pause;               // The number of Pause packet transmitted.
+        uint32_t            tx_exc_defer;           // The number of packets transmitted with excessive deferral.
+        uint32_t            tx_ctrl;                // The number of packets transmitted is a control frame, excluding Pause frame.
+        uint32_t            tx_defer;               // The number of packets transmitted that is deferred.
+        uint32_t            tx_byte_cnt;            // The number of bytes of data transmitted. FCS is NOT included.
+        uint32_t            tx_sz_64;               // The number of good and bad packets transmitted that are 64 byte long.
+        uint32_t            tx_sz_65_127;           // The number of good and bad packets transmitted that are between 65 and 127-byte long.
+        uint32_t            tx_sz_128_255;          // The number of good and bad packets transmitted that are between 128 and 255-byte long.
+        uint32_t            tx_sz_256_511;          // The number of good and bad packets transmitted that are between 256 and 511-byte long.
+        uint32_t            tx_sz_512_1023;         // The number of good and bad packets transmitted that are between 512 and 1023-byte long.
+        uint32_t            tx_sz_1024_1518;        // The number of good and bad packets transmitted that are between 1024 and 1518-byte long.
+        uint32_t            tx_sz_1519_max;         // The number of good and bad packets transmitted that are between 1519-byte and MTU.
+        uint32_t            tx_1_col;               // The number of packets subsequently transmitted successfully with a single prior collision.
+        uint32_t            tx_2_col;               // The number of packets subsequently transmitted successfully with multiple prior collisions.
+        uint32_t            tx_late_col;            // The number of packets transmitted with late collisions.
+        uint32_t            tx_abort_col;           // The number of transmit packets aborted due to excessive collisions.
+        uint32_t            tx_underrun;            // The number of transmit packets aborted due to transmit FIFO underrun, or TRD FIFO underrun
+        uint32_t            tx_rd_eop;              // The number of times that read beyond the EOP into the next frame area when TRD was not written timely
+        uint32_t            tx_len_err;             // The number of transmit packets with length field does NOT match the actual frame size.
+        uint32_t            tx_trunc;               // The number of transmit packets truncated due to size exceeding MTU.
+        uint32_t            tx_bcast_byte;          // The byte count of broadcast packet transmitted, excluding FCS.
+        uint32_t            tx_mcast_byte;          // The byte count of multicast packet transmitted, excluding FCS.
+        uint32_t            smb_updated;            // 1: SMB Updated. This is used by software as the indication of the statistics update. 
+                                                    // Software should clear this bit as soon as retrieving the statistics information.
+} _AT_ATTRIB_PACK_ stats_msg_block_t;
+
+/* Coalescing Message Block */
+typedef struct coals_msg_block {
+        uint32_t            int_stats;              // interrupt status
+        uint16_t            rrd_prod_idx;           // TRD Producer Index.
+        uint16_t            rfd_cons_idx;           // RFD Consumer Index.
+        uint16_t            update;                 // Selene sets this bit every time it DMA the CMB to host memory. 
+                                                    // Software supposes to clear this bit when CMB information is processed.
+        uint16_t            tpd_cons_idx;           // TPD Consumer Index.
+} _AT_ATTRIB_PACK_  coals_msg_block_t;
+
+
+/* RRD descriptor */
+typedef struct rx_return_desc {
+        uint8_t             num_buf;                // Number of RFD buffers used by the received packet
+        uint8_t             resved;
+        uint16_t            buf_indx;               // RFD Index of the first buffer
+	union {
+		uint32_t    valid;
+		struct {
+                    uint16_t    rx_chksum;
+		    uint16_t    pkt_size;
+		} xsum_sz;
+	}           xsz;
+
+      	uint16_t    pkt_flg;                // Packet flags
+        uint16_t    err_flg;                // Error flags
+        uint16_t            resved2;
+        uint16_t            vlan_tag;               // VLAN TAG
+} _AT_ATTRIB_PACK_ rx_return_desc_t ;
+
+#define PACKET_FLAG_ETH_TYPE        0x0080
+#define PACKET_FLAG_VLAN_INS        0x0100
+#define PACKET_FLAG_ERR             0x0200
+#define PACKET_FLAG_IPV4            0x0400
+#define PACKET_FLAG_UDP             0x0800
+#define PACKET_FLAG_TCP             0x1000
+#define PACKET_FLAG_BCAST           0x2000
+#define PACKET_FLAG_MCAST           0x4000
+#define PACKET_FLAG_PAUSE           0x8000
+
+
+
+#define ERR_FLAG_CRC                0x0001
+#define ERR_FLAG_CODE               0x0002
+#define ERR_FLAG_DRIBBLE            0x0004
+#define ERR_FLAG_RUNT               0x0008
+#define ERR_FLAG_OV                 0x0010
+#define ERR_FLAG_TRUNC              0x0020
+#define ERR_FLAG_IP_CHKSUM          0x0040
+#define ERR_FLAG_L4_CHKSUM          0x0080
+#define ERR_FLAG_LEN                0x0100
+#define ERR_FLAG_DES_ADDR           0x0200
+
+/* RFD descriptor */
+typedef struct rx_free_desc {
+        uint64_t            buffer_addr;            // Address of the descriptor's data buffer */
+        uint16_t            buf_len;                // Size of the receive buffer in host memory, in byte
+        uint16_t            coalese;                // Update consumer index to host after the reception of this frame
+} _AT_ATTRIB_PACK_ rx_free_desc_t;
+
+/* TPD descriptor */
+
+typedef struct tso_param  {
+        unsigned buf_len                : 14 ;
+        unsigned dma_int                : 1  ;
+        unsigned pkt_int                : 1  ;
+        uint16_t valan_tag                   ;
+        unsigned eop                    : 1  ;
+        /* command */
+        unsigned coalese                : 1  ;
+        unsigned ins_vlag               : 1  ;
+        unsigned custom_chksum          : 1  ;
+        unsigned segment                : 1  ;
+        unsigned ip_chksum              : 1  ;
+        unsigned tcp_chksum             : 1  ;
+        unsigned udp_chksum             : 1  ;
+        /* packet state */
+        unsigned vlan_tagged            : 1  ;
+        unsigned eth_type               : 1  ;
+        unsigned iphl                   : 4  ;
+        unsigned tcp_hdrlen             : 4  ;
+        unsigned hdr_flg                : 1  ;
+        unsigned mss                    : 13 ;
+} _AT_ATTRIB_PACK_ tso_param_t ;
+
+typedef struct csum_param  {
+        unsigned buf_len                : 14 ;
+        unsigned dma_int                : 1  ;
+        unsigned pkt_int                : 1  ;
+        uint16_t valan_tag               ;
+        unsigned eop                    : 1  ;
+        /* command */
+        unsigned coalese                : 1  ;
+        unsigned ins_vlag               : 1  ;
+        unsigned custom_chksum          : 1  ;
+        unsigned segment                : 1  ;
+        unsigned ip_chksum              : 1  ;
+        unsigned tcp_chksum             : 1  ;
+        unsigned udp_chksum             : 1  ;
+        /* packet state */
+        unsigned vlan_tagged            : 1  ;
+        unsigned eth_type               : 1  ;
+        unsigned iphl                   : 4  ;
+        unsigned                        : 2  ;
+        unsigned payload_offset         : 8  ;
+        unsigned xsum_offset            : 8  ;
+} _AT_ATTRIB_PACK_ csum_param_t ;
+
+typedef union tpd_descr {
+    uint64_t        data ;
+    csum_param_t    csum ;
+    tso_param_t     tso  ;
+} _AT_ATTRIB_PACK_  tpd_descr_t;
+
+typedef struct tx_packet_desc {
+        uint64_t    buffer_addr;
+        tpd_descr_t desc;
+} _AT_ATTRIB_PACK_  tx_packet_desc_t;
+
+
+/* DMA Order Settings */
+typedef enum {
+    at_dma_ord_in = 1,
+    at_dma_ord_enh = 2,
+    at_dma_ord_out = 4
+} at_dma_order;
+
+typedef enum {
+    at_rcb_64 = 0,
+    at_rcb_128 = 1
+} at_dma_rcb;
+
+typedef enum {
+    at_dma_req_128 = 0,
+    at_dma_req_256 = 1,
+    at_dma_req_512 = 2,
+    at_dam_req_1024 = 3,
+    at_dam_req_2048 = 4,
+    at_dma_req_4096 = 5
+} at_dma_req_block;
+
+typedef enum {
+    at_10_half = 0,
+    at_10_full = 1,
+    at_100_half = 2,
+    at_100_full = 3
+} at_speed_duplex_type;
+
+
+
+typedef struct _spi_flash_dev {
+    const char*     manu_name;  // manufacturer id
+    // op-code
+    uint8_t    cmdWRSR;
+    uint8_t    cmdREAD;
+    uint8_t    cmdPROGRAM;
+    uint8_t    cmdWREN;
+    uint8_t    cmdWRDI;
+    uint8_t    cmdRDSR;
+    uint8_t    cmdRDID;
+    uint8_t    cmdSECTOR_ERASE;
+    uint8_t    cmdCHIP_ERASE;
+} spi_flash_dev;
+
+
+/* Structure containing variables used by the shared code (e1000_hw.c) */
+struct at_hw {
+    uint8_t *hw_addr;           //
+    void *back;                 //
+
+    at_dma_order dma_ord;
+    at_dma_rcb rcb_value;
+    at_dma_req_block dmar_block;
+    at_dma_req_block dmaw_block;
+
+    uint8_t preamble_len;
+    uint8_t max_retry;          // Retransmission maximum , afterwards the packet will be discarded.
+    uint8_t jam_ipg;            // IPG to start JAM for collision based flow control in half-duplex mode. In unit of 8-bit time.
+    uint8_t ipgt;               // Desired back to back inter-packet gap. The default is 96-bit time.
+    uint8_t min_ifg;            // Minimum number of IFG to enforce in between RX frames. Frame gap below such IFP is dropped.
+    uint8_t ipgr1;              // 64bit Carrier-Sense window
+    uint8_t ipgr2;              // 96-bit IPG window
+
+    uint8_t tpd_burst;          // Number of TPD to prefetch in a cache-aligned burst. Each TPD is 16-byte in length.
+    uint8_t rfd_burst;          // Number of RFD to prefetch in a cache-aligned burst. Each RFD is 12-byte in length.
+    uint8_t rfd_fetch_gap;      //
+    uint8_t rrd_burst;          // Threshold of number of RRDs can be retired in a burst. Each RRD is 16-byte in length.
+    uint8_t tpd_fetch_th;       //
+    uint8_t tpd_fetch_gap;
+    uint16_t tx_jumbo_task_th;
+    uint16_t txf_burst;         // Number of data byte to read in a cache-aligned burst. Each SRAM entry is 8-byte in length.
+    uint16_t rx_jumbo_th;       // Jumbo packet size for non-VLAN packet. VLAN packet should add 4-byte
+    uint16_t rx_jumbo_lkah;
+    uint16_t rrd_ret_timer;     // RRD retirement timer. Decrement by 1 after every 512ns passes.
+    uint16_t lcol;              // Collision Window
+
+    uint16_t cmb_tpd;
+    uint16_t cmb_rrd;
+    uint16_t cmb_rx_timer;
+    uint16_t cmb_tx_timer;
+    uint32_t smb_timer;
+    uint16_t MediaType;
+    uint16_t autoneg_advertised;
+    uint16_t pci_cmd_word;
+
+    uint16_t mii_autoneg_adv_reg;
+    uint16_t mii_1000t_ctrl_reg;
+
+    uint32_t mem_rang;
+    uint32_t txcw;
+    uint32_t max_frame_size;    //
+    uint32_t min_frame_size;    //
+    uint32_t mc_filter_type;
+    uint32_t num_mc_addrs;
+    uint32_t collision_delta;
+    uint32_t tx_packet_delta;
+    uint16_t phy_spd_default;
+
+    uint16_t dev_rev;
+    uint16_t device_id;         //
+    uint16_t vendor_id;         //
+    uint16_t subsystem_id;      //
+    uint16_t subsystem_vendor_id;//
+    uint8_t revision_id;        //
+
+
+    // spi flash
+    uint8_t flash_vendor;
+
+    uint8_t dma_fairness;
+    uint8_t mac_addr[NODE_ADDRESS_SIZE];//
+    uint8_t perm_mac_addr[NODE_ADDRESS_SIZE];//
+
+//    boolean_t phy_preamble_sup;
+    boolean_t phy_configured;
+
+};
+
+#endif//_ATTANSIC_HW_H__
diff -Nurap old/drivers/net/atl1/at_main.c new/drivers/net/atl1/at_main.c
--- old/drivers/net/atl1/at_main.c	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_main.c	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,2977 @@
+#include "at.h"
+
+#define RUN_REALTIME 0
+
+char at_driver_name[] = "ATL1";
+char at_driver_string[] = "Attansic(R) L1 Ethernet Network Driver";
+#define DRV_VERSION "1.0.41.0"
+char at_driver_version[] = DRV_VERSION;
+char at_copyright[] = "Copyright (c) 1999-2005 Attansic Corporation.";
+
+/*
+ * at_pci_tbl - PCI Device ID Table
+ *
+ * Wildcard entries (PCI_ANY_ID) should come last
+ * Last entry must be all 0s
+ *
+ * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,
+ *   Class, Class Mask, private data (not used) }
+ */
+static struct pci_device_id at_pci_tbl[] = {
+    ATTANSIC_ETHERNET_DEVICE(0x1048),
+    /* required last entry */
+    {0,}
+};
+
+MODULE_DEVICE_TABLE(pci, at_pci_tbl);
+
+int32_t at_up(struct at_adapter *adapter);
+void at_down(struct at_adapter *adapter);
+int at_reset(struct at_adapter *adapter);
+int32_t at_setup_ring_resources(struct at_adapter *adapter);
+void at_free_ring_resources(struct at_adapter *adapter);
+
+/* Local Function Prototypes */
+static int at_init_module(void);
+static void at_exit_module(void);
+static int at_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void __devexit at_remove(struct pci_dev *pdev);
+static int at_sw_init(struct at_adapter *adapter);
+static int at_open(struct net_device *netdev);
+static int at_close(struct net_device *netdev);
+static int at_xmit_frame(struct sk_buff *skb, struct net_device *netdev);
+static struct net_device_stats * at_get_stats(struct net_device *netdev);
+static int at_change_mtu(struct net_device *netdev, int new_mtu);
+static void at_set_multi(struct net_device *netdev);
+static int at_set_mac(struct net_device *netdev, void *p);
+static int at_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+static void at_tx_timeout(struct net_device *dev);
+static irqreturn_t at_intr(int irq, void *data, struct pt_regs *regs);
+static void at_inc_smb(struct at_adapter * adapter);
+static void at_intr_rx(struct at_adapter* adapter);
+static void at_intr_tx(struct at_adapter* adapter);
+
+static void at_watchdog(unsigned long data);
+static void at_phy_config(unsigned long data);
+static void at_tx_timeout_task(struct net_device *netdev);
+static void at_check_for_link(struct at_adapter* adapter);
+static void at_link_chg_task(struct net_device* netdev);
+static uint32_t at_check_link(struct at_adapter* adapter);
+
+static void at_clean_tx_ring(struct at_adapter *adapter);
+static void at_clean_rx_ring(struct at_adapter *adapter);
+static uint16_t at_alloc_rx_buffers(struct at_adapter *adapter);
+static uint32_t at_configure(struct at_adapter *adapter);
+static void at_pcie_patch(struct at_adapter *adapter);
+
+#ifdef SIOCGMIIPHY
+static int at_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+#endif
+
+
+#ifdef NETIF_F_HW_VLAN_TX
+static void at_vlan_rx_register(struct net_device *netdev, struct vlan_group *grp);
+static void at_vlan_rx_add_vid(struct net_device *netdev, uint16_t vid);
+static void at_vlan_rx_kill_vid(struct net_device *netdev, uint16_t vid);
+static void at_restore_vlan(struct at_adapter *adapter);
+#endif
+
+static int at_notify_reboot(struct notifier_block *nb, unsigned long event, void *p);
+static int at_suspend(struct pci_dev *pdev, uint32_t state);
+#ifdef CONFIG_PM
+static int at_resume(struct pci_dev *pdev);
+#endif
+
+static void at_via_workaround(struct at_adapter * adapter);
+
+
+struct notifier_block at_notifier_reboot = {
+    .notifier_call  = at_notify_reboot,
+    .next       = NULL,
+    .priority   = 0
+};
+
+/* Exported from other modules */
+
+extern void at_check_options(struct at_adapter *adapter);
+extern int at_ethtool_ioctl(struct net_device *netdev, struct ifreq *ifr);
+#ifdef SIOCDEVPRIVATE
+extern int at_priv_ioctl(struct net_device* netdev, struct ifreq* ifr);
+#endif
+
+static struct pci_driver at_driver = {
+    .name     = at_driver_name,
+    .id_table = at_pci_tbl,
+    .probe    = at_probe,
+    .remove   = __devexit_p(at_remove),
+    /* Power Managment Hooks */
+#ifdef CONFIG_PM
+    .suspend  = at_suspend,
+    .resume   = at_resume
+#endif
+};
+
+MODULE_AUTHOR("Attansic Corporation, <xiong_huang@attansic.com>");
+MODULE_DESCRIPTION("Attansic 1000M Ethernet Network Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+/**
+ * at_init_module - Driver Registration Routine
+ *
+ * at_init_module is the first routine called when the driver is
+ * loaded. All it does is register with the PCI subsystem.
+ **/
+
+static int __init
+at_init_module(void)
+{
+    int ret;
+    printk(KERN_INFO "%s - version %s\n",
+           at_driver_string, at_driver_version);
+
+    printk(KERN_INFO "%s\n", at_copyright);
+
+    ret = pci_module_init(&at_driver);
+    if(ret >= 0) {
+        register_reboot_notifier(&at_notifier_reboot);
+    }
+    return ret;
+}
+
+module_init(at_init_module);
+
+/**
+ * at_exit_module - Driver Exit Cleanup Routine
+ *
+ * at_exit_module is called just before the driver is removed
+ * from memory.
+ **/
+
+static void __exit
+at_exit_module(void)
+{
+    unregister_reboot_notifier(&at_notifier_reboot);
+    pci_unregister_driver(&at_driver);
+}
+
+module_exit(at_exit_module);
+
+
+/**
+ * at_probe - Device Initialization Routine
+ * @pdev: PCI device information struct
+ * @ent: entry in at_pci_tbl
+ *
+ * Returns 0 on success, negative on failure
+ *
+ * at_probe initializes an adapter identified by a pci_dev structure.
+ * The OS initialization, configuring of the adapter private structure,
+ * and a hardware reset occur.
+ **/
+
+static int __devinit
+at_probe(struct pci_dev *pdev,
+            const struct pci_device_id *ent)
+{
+    struct net_device *netdev;
+    struct at_adapter *adapter;
+    static int cards_found = 0;
+    unsigned long mmio_start;
+    int mmio_len;
+    boolean_t pci_using_64 = TRUE;
+    int err;
+//    uint16_t eeprom_data;
+
+    DEBUGFUNC("at_probe !");
+
+    if((err = pci_enable_device(pdev)))
+        return err;
+
+    if((err = pci_set_dma_mask(pdev, PCI_DMA_64BIT))) {
+        if((err = pci_set_dma_mask(pdev, PCI_DMA_32BIT))) {
+            AT_ERR("No usable DMA configuration, aborting\n");
+            return err;
+        }
+        pci_using_64 = FALSE;
+    }
+
+
+    // Mark all PCI regions associated with PCI device
+    // pdev as being reserved by owner at_driver_name
+    if((err = pci_request_regions(pdev, at_driver_name)))
+        return err;
+
+    // Enables bus-mastering on the device and calls
+    // pcibios_set_master to do the needed arch specific settings
+    pci_set_master(pdev);
+
+    netdev = alloc_etherdev(sizeof(struct at_adapter));
+    if(!netdev) {
+        err = -ENOMEM;
+        goto err_alloc_etherdev;
+    }
+
+    SET_MODULE_OWNER(netdev);
+    SET_NETDEV_DEV(netdev, &pdev->dev);
+
+    pci_set_drvdata(pdev, netdev);
+    adapter = netdev_priv(netdev);
+    adapter->netdev = netdev;
+    adapter->pdev = pdev;
+    adapter->hw.back = adapter;
+
+    mmio_start = pci_resource_start(pdev, BAR_0);
+    mmio_len = pci_resource_len(pdev, BAR_0);
+
+    AT_DBG("base memory = %lx memory length = %x \n",
+        mmio_start, mmio_len);
+    adapter->hw.mem_rang = (uint32_t)mmio_len;
+    adapter->hw.hw_addr = ioremap_nocache(mmio_start, mmio_len);
+    if(!adapter->hw.hw_addr) {
+        err = -EIO;
+        goto err_ioremap;
+    }
+    /* get device reversion number */
+    adapter->hw.dev_rev =
+	    AT_READ_REGW(&adapter->hw, (REG_MASTER_CTRL+2));
+
+    netdev->open = &at_open;
+    netdev->stop = &at_close;
+    netdev->hard_start_xmit = &at_xmit_frame;
+    netdev->get_stats = &at_get_stats;
+    netdev->set_multicast_list = &at_set_multi;
+    netdev->set_mac_address = &at_set_mac;
+    netdev->change_mtu = &at_change_mtu;
+    netdev->do_ioctl = &at_ioctl;
+#ifdef HAVE_TX_TIMEOUT
+    netdev->tx_timeout = &at_tx_timeout;
+    netdev->watchdog_timeo = 5 * HZ;
+#endif
+#ifdef NETIF_F_HW_VLAN_TX
+    netdev->vlan_rx_register = at_vlan_rx_register;
+    netdev->vlan_rx_add_vid = at_vlan_rx_add_vid;
+    netdev->vlan_rx_kill_vid = at_vlan_rx_kill_vid;
+#endif
+
+    netdev->mem_start = mmio_start;
+    netdev->mem_end = mmio_start + mmio_len;
+    //netdev->base_addr = adapter->io_base;
+    adapter->bd_number = cards_found;
+    adapter->pci_using_64 = pci_using_64;
+
+    /* setup the private structure */
+
+    if((err = at_sw_init(adapter)))
+        goto err_sw_init;
+
+    netdev->features = NETIF_F_HW_CSUM;
+
+#ifdef MAX_SKB_FRAGS
+    netdev->features |= NETIF_F_SG;
+#endif
+#ifdef NETIF_F_HW_VLAN_TX
+    netdev->features |=
+               (NETIF_F_HW_VLAN_TX |
+                NETIF_F_HW_VLAN_RX );
+#endif
+#ifdef NETIF_F_TSO
+    netdev->features |= NETIF_F_TSO;
+#endif/*NETIF_F_TSO*/
+
+    if(pci_using_64) {
+        netdev->features |= NETIF_F_HIGHDMA;
+        AT_DBG("pci using 64bit address\n");
+    }
+#ifdef NETIF_F_LLTX
+	netdev->features |= NETIF_F_LLTX;
+#endif
+
+    /* patch for some L1 of old version,
+     * the final version of L1 may not need these
+     * patches
+     */
+    //KW
+    //at_pcie_patch(adapter);
+
+    /* really reset GPHY core */
+    AT_WRITE_REGW(&adapter->hw, REG_GPHY_ENABLE, 0);
+
+    /* reset the controller to
+     * put the device in a known good starting state */
+
+    if (at_reset_hw(&adapter->hw)) {
+        err = -EIO;
+        goto err_reset;
+    }
+
+    /* copy the MAC address out of the EEPROM */
+
+    at_read_mac_addr(&adapter->hw);
+    memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
+
+    if(!is_valid_ether_addr(netdev->dev_addr)) {
+        err = -EIO;
+        goto err_eeprom;
+    }
+
+    AT_DBG("mac address : %02x-%02x-%02x-%02x-%02x-%02x\n",
+        adapter->hw.mac_addr[0],
+        adapter->hw.mac_addr[1],
+        adapter->hw.mac_addr[2],
+        adapter->hw.mac_addr[3],
+        adapter->hw.mac_addr[4],
+        adapter->hw.mac_addr[5] );
+
+    at_check_options(adapter);
+
+    /* pre-init the MAC, and setup link */
+
+    if ((err = at_init_hw(&adapter->hw))) {
+        err = -EIO;
+        goto err_init_hw;
+    }
+
+    //KW add
+    at_pcie_patch(adapter);
+    /* assume we have no link for now */
+
+    netif_carrier_off(netdev);
+    netif_stop_queue(netdev);
+
+    init_timer(&adapter->watchdog_timer);
+    adapter->watchdog_timer.function = &at_watchdog;
+    adapter->watchdog_timer.data = (unsigned long) adapter;
+
+    init_timer(&adapter->phy_config_timer);
+    adapter->phy_config_timer.function = &at_phy_config;
+    adapter->phy_config_timer.data = (unsigned long) adapter;
+    adapter->phy_timer_pending = FALSE;
+
+    INIT_WORK(&adapter->tx_timeout_task,
+        (void (*)(void *))at_tx_timeout_task, netdev);
+
+    INIT_WORK(&adapter->link_chg_task,
+        (void (*)(void *))at_link_chg_task, netdev);
+
+    INIT_WORK(&adapter->pcie_dma_to_rst_task,
+        (void (*)(void *))at_tx_timeout_task, netdev);
+
+    if((err = register_netdev(netdev)))
+        goto err_register;
+
+
+    cards_found++;
+
+	at_via_workaround(adapter);
+
+    return 0;
+
+err_init_hw:
+err_reset:
+err_register:
+err_sw_init:
+err_eeprom:
+    iounmap(adapter->hw.hw_addr);
+err_ioremap:
+    free_netdev(netdev);
+err_alloc_etherdev:
+    pci_release_regions(pdev);
+    return err;
+}
+
+/**
+ * at_pcie_patch - Patch for PCIE module
+ **/
+void at_pcie_patch(struct at_adapter* adapter)
+{
+    uint32_t value;
+    value = 0x6500;
+    AT_WRITE_REG(&adapter->hw, 0x12FC, value);
+
+    /* pcie flow control mode change */
+    value = AT_READ_REG(&adapter->hw, 0x1008);
+    value |= 0x8000;
+    AT_WRITE_REG(&adapter->hw, 0x1008, value);
+}
+
+/**
+ * at_remove - Device Removal Routine
+ * @pdev: PCI device information struct
+ *
+ * at_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.  The could be caused by a
+ * Hot-Plug event, or because the driver is going to be removed from
+ * memory.
+ **/
+
+static void __devexit
+at_remove(struct pci_dev *pdev)
+{
+    struct net_device *netdev = pci_get_drvdata(pdev);
+    struct at_adapter *adapter;
+
+    DEBUGFUNC("at_remove");
+
+    /* Device not available. Return. */
+    if (!netdev)
+        return;
+
+    adapter = netdev_priv(netdev);
+
+    AT_WRITE_REGW(&adapter->hw, REG_GPHY_ENABLE, 0);
+
+    unregister_netdev(netdev);
+
+    iounmap(adapter->hw.hw_addr);
+    pci_release_regions(pdev);
+
+    free_netdev(netdev);
+}
+
+
+/**
+ * at_irq_disable - Mask off interrupt generation on the NIC
+ * @adapter: board private structure
+ **/
+inline void
+at_irq_disable(struct at_adapter *adapter)
+{
+    atomic_inc(&adapter->irq_sem);
+    AT_WRITE_REG(&adapter->hw, REG_IMR, 0);
+
+    synchronize_irq(adapter->pdev->irq);
+}
+
+/**
+ * at_irq_enable - Enable default interrupt generation settings
+ * @adapter: board private structure
+ **/
+inline void
+at_irq_enable(struct at_adapter *adapter)
+{
+    if(0 == atomic_dec_and_test(&adapter->irq_sem)) {
+        AT_WRITE_REG(&adapter->hw, REG_IMR, IMR_NORMAL_MASK);
+    }
+}
+
+static int
+at_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
+{
+    struct pci_dev *pdev = NULL;
+
+    DEBUGFUNC("at_notify_reboot !");
+
+    switch(event) {
+    case SYS_DOWN:
+    case SYS_HALT:
+    case SYS_POWER_OFF:
+        while((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev))) {
+            if(pci_dev_driver(pdev) == &at_driver)
+                at_suspend(pdev, 3);
+        }
+    }
+    return NOTIFY_DONE;
+}
+
+
+static int
+at_suspend(struct pci_dev *pdev, uint32_t state)
+{
+    struct net_device *netdev = pci_get_drvdata(pdev);
+    struct at_adapter *adapter = netdev_priv(netdev);
+    struct at_hw * hw = &adapter->hw;
+    uint32_t ctrl = 0;
+    uint32_t wufc = adapter->wol;
+
+    DEBUGFUNC("at_suspend !");
+
+    netif_device_detach(netdev);
+
+    if(netif_running(netdev))
+        at_down(adapter);
+
+    at_read_phy_reg(hw, MII_BMSR, (uint16_t*)&ctrl);
+    at_read_phy_reg(hw, MII_BMSR, (uint16_t*)&ctrl);
+    if(ctrl & BMSR_LSTATUS)
+        wufc &= ~AT_WUFC_LNKC;
+
+    // reduce speed to 10/100M
+    if (wufc) {
+        at_phy_enter_power_saving(hw);
+        // if resume, let driver to re- setup link
+        hw->phy_configured = FALSE;
+        set_mac_addr(hw);
+        at_set_multi(netdev);
+
+        ctrl = 0;
+        /* turn on magic packet wol */
+        if (wufc & AT_WUFC_MAG) {
+            ctrl = WOL_MAGIC_EN|WOL_MAGIC_PME_EN;
+        }
+        // turn on Link change WOL */
+        if (wufc & AT_WUFC_LNKC) {
+            ctrl |= (WOL_LINK_CHG_EN|WOL_LINK_CHG_PME_EN);
+        }
+        AT_WRITE_REG(hw, REG_WOL_CTRL, ctrl);
+
+        /* turn on all-multi mode if wake on multicast is enabled */
+        ctrl = AT_READ_REG(hw, REG_MAC_CTRL);
+        ctrl &= ~MAC_CTRL_DBG;
+        ctrl &= ~MAC_CTRL_PROMIS_EN;
+		if(wufc & AT_WUFC_MC) {
+		    ctrl |= MAC_CTRL_MC_ALL_EN;
+		} else {
+		    ctrl &= ~MAC_CTRL_MC_ALL_EN;
+		}
+		/* turn on broadcast mode if wake on-BC is enabled */
+		if (wufc & AT_WUFC_BC) {
+		    ctrl |= MAC_CTRL_BC_EN;
+		} else {
+		    ctrl &= ~MAC_CTRL_BC_EN;
+		}
+
+		// enable RX
+		ctrl |= MAC_CTRL_RX_EN;
+		AT_WRITE_REG(hw, REG_MAC_CTRL, ctrl);
+
+		pci_enable_wake(pdev, 3, 1);
+		pci_enable_wake(pdev, 4, 1); /* 4 == D3 cold */
+	} else {
+	    AT_WRITE_REG(hw, REG_WOL_CTRL, 0);
+		pci_enable_wake(pdev, 3, 0);
+		pci_enable_wake(pdev, 4, 0); /* 4 == D3 cold */
+	}
+
+	pci_save_state(pdev);
+	pci_disable_device(pdev);
+
+    state = (state > 0) ? 3 : 0;
+    pci_set_power_state(pdev, state);
+
+    return 0;
+}
+
+static int
+at_resume(struct pci_dev *pdev)
+{
+    struct net_device *netdev = pci_get_drvdata(pdev);
+    struct at_adapter *adapter = netdev_priv(netdev);
+    uint32_t ret_val;
+
+    DEBUGFUNC("at_resume !");
+
+    pci_set_power_state(pdev, 0);
+	pci_restore_state(pdev);
+
+    ret_val = pci_enable_device(pdev);
+    pci_enable_wake(pdev, 3, 0);
+    pci_enable_wake(pdev, 4, 0); /* 4 == D3 cold */
+
+    AT_WRITE_REG(&adapter->hw, REG_WOL_CTRL, 0);
+    at_reset(adapter);
+
+
+    if(netif_running(netdev))
+        at_up(adapter);
+
+    netif_device_attach(netdev);
+
+	at_via_workaround(adapter);
+
+    return 0;
+}
+
+
+/**
+ * at_sw_init - Initialize general software structures (struct at_adapter)
+ * @adapter: board private structure to initialize
+ *
+ * at_sw_init initializes the Adapter private data structure.
+ * Fields are initialized based on PCI device information and
+ * OS network device settings (MTU size).
+ **/
+
+static int __devinit
+at_sw_init(struct at_adapter *adapter)
+{
+    struct at_hw *hw = &adapter->hw;
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+
+    /* PCI config space info */
+
+    hw->vendor_id = pdev->vendor;
+    hw->device_id = pdev->device;
+    hw->subsystem_vendor_id = pdev->subsystem_vendor;
+    hw->subsystem_id = pdev->subsystem_device;
+
+    pci_read_config_byte(pdev, PCI_REVISION_ID, &hw->revision_id);
+
+    pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
+
+
+    hw->max_frame_size = netdev->mtu +
+                 ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
+    hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;
+
+    adapter->wol = 0;
+
+    adapter->rx_buffer_len = (hw->max_frame_size+7)&~7;
+    adapter->ict = 50000;  // 100ms
+
+    adapter->link_speed = SPEED_0;   // hardware init
+    adapter->link_duplex = FULL_DUPLEX; //
+
+
+    hw->phy_configured = FALSE;
+    hw->preamble_len = 7;
+    hw->ipgt = 0x60;
+    hw->min_ifg = 0x50;
+    hw->ipgr1 = 0x40;
+    hw->ipgr2 = 0x60;
+
+    hw->max_retry = 0xf;
+    hw->lcol = 0x37;
+    hw->jam_ipg = 7;
+
+    hw->rfd_burst = 8;
+    hw->rrd_burst = 8;
+    hw->rfd_fetch_gap = 1;
+    hw->rx_jumbo_th = adapter->rx_buffer_len / 8;
+    hw->rx_jumbo_lkah = 1;
+    hw->rrd_ret_timer = 16;
+
+    hw->tpd_burst = 4;
+    hw->tpd_fetch_th = 16;
+    hw->txf_burst = 0x100;
+    hw->tx_jumbo_task_th = (hw->max_frame_size+7)>>3;
+    hw->tpd_fetch_gap = 1;
+
+    hw->rcb_value = at_rcb_64;
+    hw->dma_ord = at_dma_ord_enh;
+    hw->dmar_block = at_dma_req_256;
+    hw->dmaw_block = at_dma_req_256;
+
+    hw->cmb_rrd = 4;
+    hw->cmb_tpd = 4;
+    hw->cmb_rx_timer = 1; //about 2us
+    hw->cmb_tx_timer = 1; //about 2us
+    hw->smb_timer = 100000 ; // about 200ms
+    atomic_set(&adapter->irq_sem, 0);
+    spin_lock_init(&adapter->stats_lock);
+    spin_lock_init(&adapter->tx_lock);
+    spin_lock_init(&adapter->mb_lock);
+
+    return 0;
+}
+
+int
+at_reset(struct at_adapter *adapter)
+{
+    int ret;
+
+    if (AT_SUCCESS != (ret = at_reset_hw(&adapter->hw)))
+        return ret;
+
+    return at_init_hw(&adapter->hw);
+}
+
+/**
+ * at_open - Called when a network interface is made active
+ * @netdev: network interface device structure
+ *
+ * Returns 0 on success, negative value on failure
+ *
+ * The open entry point is called when a network interface is made
+ * active by the system (IFF_UP).  At this point all resources needed
+ * for transmit and receive operations are allocated, the interrupt
+ * handler is registered with the OS, the watchdog timer is started,
+ * and the stack is notified that the interface is ready.
+ **/
+
+static int
+at_open(struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    int err;
+
+    DEBUGFUNC("at_open !");
+
+    /* allocate transmit descriptors */
+
+    if((err = at_setup_ring_resources(adapter)))
+        return err;
+
+    if((err = at_up(adapter)))
+        goto err_up;
+/* for test only */
+/*    { uint32_t value;
+       value = AT_READ_REG(&adapter->hw, 0x12FC);
+       DEBUGOUT1("reg 0x12fc = 0x%x", value);
+       value = AT_READ_REG(&adapter->hw, 0x1008);
+       DEBUGOUT1("reg 0x1008 = 0x%x", value);
+    }
+*/
+/**********end ****/
+
+
+
+    return 0;
+
+err_up:
+    at_reset(adapter);
+
+    return err;
+}
+
+/**
+ * at_close - Disables a network interface
+ * @netdev: network interface device structure
+ *
+ * Returns 0, this is not allowed to fail
+ *
+ * The close entry point is called when an interface is de-activated
+ * by the OS.  The hardware is still under the drivers control, but
+ * needs to be disabled.  A global MAC reset is issued to stop the
+ * hardware, and all transmit and receive resources are freed.
+ **/
+
+static int
+at_close(struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    DEBUGFUNC("at_close!");
+
+    at_down(adapter);
+
+    at_free_ring_resources(adapter);
+
+    return 0;
+}
+
+/**
+ * at_setup_mem_resources - allocate Tx / RX descriptor resources
+ * @adapter: board private structure
+ *
+ * Return 0 on success, negative on failure
+ **/
+
+int32_t
+at_setup_ring_resources(struct at_adapter *adapter)
+{
+    struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+    struct at_rfd_ring *rfd_ring = &adapter->rfd_ring;
+    struct at_rrd_ring *rrd_ring = &adapter->rrd_ring;
+    struct at_ring_header * ring_header = &adapter->ring_header;
+    struct pci_dev *pdev = adapter->pdev;
+    int size;
+    uint8_t offset = 0;
+
+//    DEBUGFUNC("at_setup_ring_resources !");
+
+//    DEBUGOUT1("TPD count = %x  RFD cont = %x  RRD = %x",
+//        tpd_ring->count, rfd_ring->count, rrd_ring->count);
+
+    DEBUGOUT1("sz TPD:%d, sz RFD:%d, sz RRD:%d",
+		    sizeof(tx_packet_desc_t),
+		    sizeof(rx_free_desc_t),
+		    sizeof(rx_return_desc_t));
+
+    size = sizeof(struct at_buffer) * (tpd_ring->count+rfd_ring->count);
+    tpd_ring->buffer_info = kmalloc(size, GFP_KERNEL);
+    if(!tpd_ring->buffer_info) {
+    DEBUGOUT1("kmalloc failed , size = D%d", size);
+        return -ENOMEM;
+    }
+    rfd_ring->buffer_info =
+         (struct at_buffer*)(tpd_ring->buffer_info+tpd_ring->count);
+
+    memset(tpd_ring->buffer_info, 0, size);
+
+    /* real ring DMA buffer */
+    ring_header->size = size =  sizeof(tx_packet_desc_t ) * tpd_ring->count
+                              + sizeof(rx_free_desc_t) *    rfd_ring->count
+                              + sizeof(rx_return_desc_t) *  rrd_ring->count
+                              + sizeof(coals_msg_block_t)
+                              + sizeof(stats_msg_block_t)
+                              + 40; // 40: for 8 bytes align
+
+    ring_header->desc =
+          pci_alloc_consistent(pdev, ring_header->size, &ring_header->dma);
+    if(!ring_header->desc) {
+        kfree(tpd_ring->buffer_info);
+        DEBUGOUT1("pci_alloc_consistent failed , size = D%d", size);
+        return -ENOMEM;
+    }
+
+    if (adapter->pci_using_64)
+    { // test whether HIDWORD dma buffer is not cross boundary
+        if (    ((ring_header->dma       &0xffffffff00000000ULL)>>32)
+             != (((ring_header->dma+size)&0xffffffff00000000ULL)>>32) )
+        {
+            kfree(tpd_ring->buffer_info);
+            pci_free_consistent(
+                     pdev,
+                     ring_header->size,
+                     ring_header->desc,
+                     ring_header->dma);
+            DEBUGOUT("memory allocated cross 32bit boundary !");
+            return -ENOMEM;
+        }
+    }
+
+//    DEBUGOUT("memory allocated successfully !");
+
+    memset(ring_header->desc, 0, ring_header->size);
+    DEBUGOUT1("whole ring dma addr=%x", ring_header->dma);
+
+    // init TPD ring
+    tpd_ring->dma = ring_header->dma;
+    offset = (tpd_ring->dma & 0x7) ? (8 - (ring_header->dma & 0x7)) : 0;
+    tpd_ring->dma += offset;
+    tpd_ring->desc = (uint8_t*) ring_header->desc + offset;
+    tpd_ring->size = sizeof(tx_packet_desc_t) * tpd_ring->count;
+    atomic_set(&tpd_ring->next_to_use, 0);
+    atomic_set(&tpd_ring->next_to_clean, 0);
+    DEBUGOUT1("tpd ring dma addr=%x", tpd_ring->dma);
+
+    // init RFD ring
+    rfd_ring->dma = tpd_ring->dma + tpd_ring->size;
+    offset = (rfd_ring->dma & 0x7) ? (8 - (rfd_ring->dma & 0x7)) : 0;
+    rfd_ring->dma += offset;
+    rfd_ring->desc = (uint8_t*) tpd_ring->desc + (tpd_ring->size+offset);
+    rfd_ring->size = sizeof(rx_free_desc_t) * rfd_ring->count;
+
+    rfd_ring->next_to_clean = 0;
+    //rfd_ring->next_to_use = rfd_ring->count - 1;
+    atomic_set(&rfd_ring->next_to_use, 0);
+    DEBUGOUT1("rfd ring dma addr=%x", rfd_ring->dma);
+
+    // init RRD ring
+    rrd_ring->dma = rfd_ring->dma + rfd_ring->size;
+    offset = (rrd_ring->dma & 0x7) ? (8 - (rrd_ring->dma & 0x7)) : 0;
+    rrd_ring->dma += offset;
+    rrd_ring->desc = (uint8_t*) rfd_ring->desc + (rfd_ring->size+offset);
+    rrd_ring->size = sizeof(rx_return_desc_t) * rrd_ring->count;
+    rrd_ring->next_to_use = 0;
+    atomic_set(&rrd_ring->next_to_clean, 0);
+    DEBUGOUT1("rrd ring dma addr=%x", rrd_ring->dma);
+
+    // init CMB
+    adapter->cmb.dma = rrd_ring->dma + rrd_ring->size;
+    offset = (adapter->cmb.dma & 0x7)? (8-(adapter->cmb.dma & 0x7)) : 0;
+    adapter->cmb.dma += offset;
+    adapter->cmb.cmb =
+       (coals_msg_block_t*)
+          ((uint8_t*)rrd_ring->desc + (rrd_ring->size+offset));
+    DEBUGOUT1("cmd dma addr=%x", adapter->cmb.dma);
+
+    // init SMB
+    adapter->smb.dma = adapter->cmb.dma + sizeof(coals_msg_block_t);
+    offset = (adapter->smb.dma&0x7) ? (8-(adapter->smb.dma&0x7)): 0;
+    adapter->smb.dma += offset;
+    adapter->smb.smb =
+	    (stats_msg_block_t*)
+          ((uint8_t*)adapter->cmb.cmb + (sizeof(coals_msg_block_t)+offset));
+    DEBUGOUT1("smb dma addr=%x", adapter->smb.dma);
+
+    return AT_SUCCESS;
+}
+
+/**
+ * at_free_ring_resources - Free Tx / RX descriptor Resources
+ * @adapter: board private structure
+ *
+ * Free all transmit software resources
+ **/
+
+void
+at_free_ring_resources(struct at_adapter *adapter)
+{
+    struct pci_dev *pdev = adapter->pdev;
+    struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+    struct at_rfd_ring *rfd_ring = &adapter->rfd_ring;
+    struct at_rrd_ring * rrd_ring = &adapter->rrd_ring;
+    struct at_ring_header * ring_header = &adapter->ring_header;
+
+//    DEBUGFUNC("at_free_ring_resources !");
+
+    at_clean_tx_ring(adapter);
+    at_clean_rx_ring(adapter);
+
+    kfree(tpd_ring->buffer_info);
+    pci_free_consistent(
+         pdev,
+         ring_header->size,
+         ring_header->desc,
+         ring_header->dma);
+
+    tpd_ring->buffer_info = NULL;
+    tpd_ring->desc = NULL;
+    tpd_ring->dma = 0;
+
+    rfd_ring->buffer_info = NULL;
+    rfd_ring->desc = NULL;
+    rfd_ring->dma = 0;
+
+    rrd_ring->desc = NULL;
+    rrd_ring->dma = 0;
+}
+
+
+int32_t
+at_up(struct at_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+    int err;
+
+    DEBUGFUNC("at_up !");
+
+    /* hardware has been reset, we need to reload some things */
+
+    at_set_multi(netdev);
+
+#ifdef NETIF_F_HW_VLAN_TX
+    at_restore_vlan(adapter);
+#endif
+
+    err = at_alloc_rx_buffers(adapter);
+    if (0 == err)
+    { // no RX BUFFER allocated
+        return -ENOMEM;
+    }
+
+    if (at_configure(adapter)) {
+        err = -EIO;
+        goto err_up;
+    }
+
+    if ((err = request_irq(adapter->pdev->irq,
+                          &at_intr,
+                          SA_SHIRQ | SA_SAMPLE_RANDOM,
+                          netdev->name, netdev)))
+        goto err_up;
+
+    mod_timer(&adapter->watchdog_timer, jiffies);
+
+    at_irq_enable(adapter);
+
+    at_check_link(adapter);
+
+    return 0;
+
+    // free irq
+    // disable any interrupt
+    AT_WRITE_REG(&adapter->hw, REG_IMR, 0);
+    free_irq(adapter->pdev->irq, netdev);
+
+err_up:
+
+    // free rx_buffers
+    at_clean_rx_ring(adapter);
+    return err;
+}
+
+inline  void
+at_setup_mac_ctrl(struct at_adapter* adapter)
+{
+    uint32_t value;
+    struct at_hw* hw = &adapter->hw;
+    struct net_device* netdev = adapter->netdev;
+
+    /* Config MAC CTRL Register */
+    value = MAC_CTRL_TX_EN | MAC_CTRL_RX_EN;
+    // duplex
+    if (FULL_DUPLEX == adapter->link_duplex)
+        value |= MAC_CTRL_DUPLX;
+    // speed
+    value |= ((uint32_t)((SPEED_1000 == adapter->link_speed) ?
+              MAC_CTRL_SPEED_1000 :
+              MAC_CTRL_SPEED_10_100)<< MAC_CTRL_SPEED_SHIFT);
+    // flow control
+    value |= (MAC_CTRL_TX_FLOW|MAC_CTRL_RX_FLOW);
+
+    // PAD & CRC
+    value |= (MAC_CTRL_ADD_CRC|MAC_CTRL_PAD);
+    // preamble length
+    value |= (((uint32_t)adapter->hw.preamble_len
+                  &MAC_CTRL_PRMLEN_MASK)<< MAC_CTRL_PRMLEN_SHIFT);
+    // vlan
+    if (adapter->vlgrp)
+        value |= MAC_CTRL_RMV_VLAN;
+/*
+    // rx checksum
+    if (adapter->rx_csum)
+        value |= MAC_CTRL_RX_CHKSUM_EN;
+*/
+
+    // filter mode
+    value |= MAC_CTRL_BC_EN;
+    if (netdev->flags & IFF_PROMISC)
+        value |= MAC_CTRL_PROMIS_EN;
+    else if (netdev->flags & IFF_ALLMULTI)
+        value |= MAC_CTRL_MC_ALL_EN;
+
+//        value |= MAC_CTRL_LOOPBACK;
+    AT_WRITE_REG(hw, REG_MAC_CTRL, value);
+}
+static uint32_t
+at_check_link(struct at_adapter* adapter)
+{
+    struct at_hw *hw = &adapter->hw;
+    struct net_device * netdev = adapter->netdev;
+    uint32_t ret_val;
+    uint16_t speed, duplex, phy_data;
+    int reconfig = 0;
+
+//    DEBUGFUNC("at_check_link !");
+	// MII_BMSR must read twise
+    at_read_phy_reg(hw, MII_BMSR, &phy_data);
+    at_read_phy_reg(hw, MII_BMSR, &phy_data);
+    if (!(phy_data&BMSR_LSTATUS)) { // link down
+		if (netif_carrier_ok(netdev)) { // old link state: Up
+			DEBUGOUT("NIC Link is Down");
+            adapter->link_speed = SPEED_0;
+            netif_carrier_off(netdev);
+            netif_stop_queue(netdev);
+        }
+        return AT_SUCCESS;
+    }
+
+    // Link Up
+	ret_val = at_get_speed_and_duplex(hw, &speed, &duplex);
+	if (ret_val)  return ret_val;
+	switch( hw->MediaType )
+	{
+	case MEDIA_TYPE_1000M_FULL:
+		if (speed  != SPEED_1000 || duplex != FULL_DUPLEX)
+			reconfig = 1;
+		break;
+	case MEDIA_TYPE_100M_FULL:
+		if (speed  != SPEED_100 || duplex != FULL_DUPLEX)
+			reconfig = 1;
+		break;
+	case MEDIA_TYPE_100M_HALF:
+		if (speed  != SPEED_100 || duplex != HALF_DUPLEX)
+			reconfig = 1;
+		break;
+	case MEDIA_TYPE_10M_FULL:
+		if (speed != SPEED_10 || duplex != FULL_DUPLEX)
+			reconfig = 1;
+	        break;
+	case MEDIA_TYPE_10M_HALF:
+		if (speed  != SPEED_10 || duplex != HALF_DUPLEX)
+			reconfig = 1;
+		break;
+	}
+	// link result is our setting
+	if (0 == reconfig)
+	{
+		if (adapter->link_speed != speed ||
+            adapter->link_duplex != duplex ) {
+			adapter->link_speed = speed;
+			adapter->link_duplex = duplex;
+			at_setup_mac_ctrl(adapter);
+			printk(KERN_INFO
+                   "%s: %s NIC Link is Up<%d Mbps %s>\n",
+		   			at_driver_name,
+                    netdev->name, adapter->link_speed,
+                    adapter->link_duplex == FULL_DUPLEX ?
+ 					"Full Duplex" : "Half Duplex");
+		}
+
+		if (!netif_carrier_ok(netdev)) { // Link down -> Up
+			netif_carrier_on(netdev);
+			netif_wake_queue(netdev);
+		}
+		return AT_SUCCESS;
+	}
+
+	// change orignal link status
+	if (netif_carrier_ok(netdev)) {
+		adapter->link_speed = SPEED_0;
+    	netif_carrier_off(netdev);
+    	netif_stop_queue(netdev);
+    }
+
+    if (hw->MediaType != MEDIA_TYPE_AUTO_SENSOR &&
+    	hw->MediaType != MEDIA_TYPE_1000M_FULL ) {
+    	switch (hw->MediaType)
+    	{
+    	case MEDIA_TYPE_100M_FULL:
+    		phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_100|MII_CR_RESET;
+    		break;
+    	case MEDIA_TYPE_100M_HALF:
+    		phy_data = MII_CR_SPEED_100|MII_CR_RESET;
+    		break;
+    	case MEDIA_TYPE_10M_FULL:
+    		phy_data = MII_CR_FULL_DUPLEX|MII_CR_SPEED_10|MII_CR_RESET;
+    		break;
+    	default: // MEDIA_TYPE_10M_HALF:
+    		phy_data = MII_CR_SPEED_10|MII_CR_RESET;
+    		break;
+    	}
+    	at_write_phy_reg(hw, MII_BMCR, phy_data);
+DEBUGOUT("RE-CONFIG-PHY !");
+    	return AT_SUCCESS;
+    }
+
+	// auto-neg, insert timer to re-config phy
+    if (!adapter->phy_timer_pending) {
+		adapter->phy_timer_pending = TRUE;
+		mod_timer(&adapter->phy_config_timer, jiffies + 3 * HZ);
+	}
+
+    return AT_SUCCESS;
+}
+
+
+void
+at_down(struct at_adapter *adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+
+    DEBUGFUNC("at_down !");
+
+    del_timer_sync(&adapter->watchdog_timer);
+    del_timer_sync(&adapter->phy_config_timer);
+    adapter->phy_timer_pending = FALSE;
+
+    at_irq_disable(adapter);
+    free_irq(adapter->pdev->irq, netdev);
+    at_reset_hw(&adapter->hw);
+    adapter->cmb.cmb->int_stats = 0;
+
+    adapter->link_speed = SPEED_0;
+    adapter->link_duplex = -1;
+    netif_carrier_off(netdev);
+    netif_stop_queue(netdev);
+
+    at_clean_tx_ring(adapter);
+    at_clean_rx_ring(adapter);
+}
+
+/**
+ * at_set_multi - Multicast and Promiscuous mode set
+ * @netdev: network interface device structure
+ *
+ * The set_multi entry point is called whenever the multicast address
+ * list or the network interface flags are updated.  This routine is
+ * responsible for configuring the hardware for proper multicast,
+ * promiscuous mode, and all-multi behavior.
+ **/
+
+static void
+at_set_multi(struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    struct at_hw *hw = &adapter->hw;
+    struct dev_mc_list *mc_ptr;
+    uint32_t rctl;
+    uint32_t hash_value;
+
+//    DEBUGFUNC("at_set_multi !");
+
+    /* Check for Promiscuous and All Multicast modes */
+
+    rctl = AT_READ_REG(hw, REG_MAC_CTRL);
+
+    if(netdev->flags & IFF_PROMISC) {
+        rctl |= MAC_CTRL_PROMIS_EN;
+    } else if(netdev->flags & IFF_ALLMULTI) {
+        rctl |= MAC_CTRL_MC_ALL_EN;
+        rctl &= ~MAC_CTRL_PROMIS_EN;
+    } else {
+        rctl &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);
+    }
+
+    AT_WRITE_REG(hw, REG_MAC_CTRL, rctl);
+
+    /* clear the old settings from the multicast hash table */
+    AT_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);
+    AT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);
+
+    /* comoute mc addresses' hash value ,and put it into hash table */
+
+    for(mc_ptr = netdev->mc_list; mc_ptr; mc_ptr = mc_ptr->next) {
+        hash_value = at_hash_mc_addr(hw, mc_ptr->dmi_addr);
+        at_hash_set(hw, hash_value);
+    }
+}
+
+#ifdef NETIF_F_HW_VLAN_TX
+static void
+at_vlan_rx_register(struct net_device *netdev, struct vlan_group *grp)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    uint32_t ctrl;
+
+ //   DEBUGFUNC("at_vlan_rx_register !");
+
+    at_irq_disable(adapter);
+    adapter->vlgrp = grp;
+
+    if(grp) {
+        /* enable VLAN tag insert/strip */
+
+        ctrl = AT_READ_REG(&adapter->hw, REG_MAC_CTRL);
+        ctrl |= MAC_CTRL_RMV_VLAN;
+        AT_WRITE_REG(&adapter->hw, REG_MAC_CTRL, ctrl);
+    } else {
+        /* disable VLAN tag insert/strip */
+
+        ctrl = AT_READ_REG(&adapter->hw, REG_MAC_CTRL);
+        ctrl &= ~MAC_CTRL_RMV_VLAN;
+        AT_WRITE_REG(&adapter->hw, REG_MAC_CTRL, ctrl);
+    }
+
+    at_irq_enable(adapter);
+}
+
+static void
+at_vlan_rx_add_vid(struct net_device *netdev, uint16_t vid)
+{
+    /* We don't do Vlan filtering */
+//    DEBUGFUNC("at_vlan_rx_add_vid !");
+    return ;
+}
+
+static void
+at_vlan_rx_kill_vid(struct net_device *netdev, uint16_t vid)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+
+//    DEBUGFUNC("at_vlan_rx_kill_vid !");
+    at_irq_disable(adapter);
+
+    if(adapter->vlgrp)
+        adapter->vlgrp->vlan_devices[vid] = NULL;
+
+    at_irq_enable(adapter);
+
+    /* We don't do Vlan filtering */
+
+    return;
+}
+
+static void
+at_restore_vlan(struct at_adapter *adapter)
+{
+//    DEBUGFUNC("at_restore_vlan !");
+    at_vlan_rx_register(adapter->netdev, adapter->vlgrp);
+
+    if(adapter->vlgrp) {
+        uint16_t vid;
+        for(vid = 0; vid < VLAN_GROUP_ARRAY_LEN; vid++) {
+            if(!adapter->vlgrp->vlan_devices[vid])
+                continue;
+            at_vlan_rx_add_vid(adapter->netdev, vid);
+        }
+    }
+}
+#endif
+
+static inline
+void set_flow_ctrl_old(struct at_adapter* adapter)
+{
+    uint32_t Hi, Lo, value;
+
+    // RFD Flow Control
+    value = adapter->rfd_ring.count;
+    Hi = value / 16;
+    if (Hi < 2) Hi = 2;
+    Lo = value * 7 / 8;
+
+   value = ((Hi&RXQ_RXF_PAUSE_TH_HI_MASK) << RXQ_RXF_PAUSE_TH_HI_SHIFT)|
+	((Lo&RXQ_RXF_PAUSE_TH_LO_MASK) << RXQ_RXF_PAUSE_TH_LO_SHIFT);
+    AT_WRITE_REG(&adapter->hw, REG_RXQ_RXF_PAUSE_THRESH, value);
+
+    // RRD Flow Control
+    value = adapter->rrd_ring.count;
+    Lo = value / 16;
+    Hi = value * 7 / 8;
+    if (Lo < 2) Lo = 2;
+
+   value = ((Hi&RXQ_RRD_PAUSE_TH_HI_MASK) << RXQ_RRD_PAUSE_TH_HI_SHIFT)|
+	((Lo&RXQ_RRD_PAUSE_TH_LO_MASK) << RXQ_RRD_PAUSE_TH_LO_SHIFT);
+    AT_WRITE_REG(&adapter->hw, REG_RXQ_RRD_PAUSE_THRESH, value);
+}
+
+static inline
+void set_flow_ctrl_new(struct at_hw* hw)
+{
+    uint32_t Hi, Lo, value;
+
+    // RXF Flow Control
+    value = AT_READ_REG(hw, REG_SRAM_RXF_LEN);
+    Lo = value / 16;
+    if (Lo < 192) Lo = 192;
+    Hi = value * 7 / 8;
+    if (Hi < Lo) Hi = Lo + 16;
+   value = ((Hi&RXQ_RXF_PAUSE_TH_HI_MASK) << RXQ_RXF_PAUSE_TH_HI_SHIFT)|
+	((Lo&RXQ_RXF_PAUSE_TH_LO_MASK) << RXQ_RXF_PAUSE_TH_LO_SHIFT);
+    AT_WRITE_REG(hw, REG_RXQ_RXF_PAUSE_THRESH, value);
+
+    // RRD Flow Control
+    value = AT_READ_REG(hw, REG_SRAM_RRD_LEN);
+    Lo = value / 8;
+    Hi = value * 7 / 8;
+    if (Lo < 2) Lo = 2;
+    if (Hi < Lo) Hi = Lo + 3;
+   value = ((Hi&RXQ_RRD_PAUSE_TH_HI_MASK) << RXQ_RRD_PAUSE_TH_HI_SHIFT)|
+	((Lo&RXQ_RRD_PAUSE_TH_LO_MASK) << RXQ_RRD_PAUSE_TH_LO_SHIFT);
+    AT_WRITE_REG(hw, REG_RXQ_RRD_PAUSE_THRESH, value);
+}
+
+/**
+ * at_configure - Configure Transmit&Receive Unit after Reset
+ * @adapter: board private structure
+ *
+ * Configure the Tx /Rx unit of the MAC after a reset.
+ **/
+
+static uint32_t
+at_configure(struct at_adapter *adapter)
+{
+    struct at_hw * hw = &adapter->hw;
+    uint32_t value;
+
+//  DEBUGFUNC("at_configure !");
+    // clear interrupt status
+    AT_WRITE_REG(&adapter->hw, REG_ISR, 0xffffffff);
+
+    // set MAC Address
+    value = (((uint32_t)hw->mac_addr[2]) << 24) |
+            (((uint32_t)hw->mac_addr[3]) << 16) |
+            (((uint32_t)hw->mac_addr[4]) << 8 ) |
+            (((uint32_t)hw->mac_addr[5])      ) ;
+    AT_WRITE_REG(hw, REG_MAC_STA_ADDR, value);
+    value = (((uint32_t)hw->mac_addr[0]) << 8 ) |
+            (((uint32_t)hw->mac_addr[1])      ) ;
+    AT_WRITE_REG(hw, (REG_MAC_STA_ADDR+4), value);
+
+    // tx / rx ring :
+
+    // HI base address
+    AT_WRITE_REG(
+          hw,
+          REG_DESC_BASE_ADDR_HI,
+          (uint32_t)((adapter->tpd_ring.dma&0xffffffff00000000ULL) >>32));
+    // LO base address
+    AT_WRITE_REG(
+          hw,
+          REG_DESC_RFD_ADDR_LO,
+          (uint32_t)(adapter->rfd_ring.dma& 0x00000000ffffffffULL));
+    AT_WRITE_REG(
+          hw,
+          REG_DESC_RRD_ADDR_LO,
+          (uint32_t)(adapter->rrd_ring.dma& 0x00000000ffffffffULL));
+    AT_WRITE_REG(hw,
+                 REG_DESC_TPD_ADDR_LO,
+                 (uint32_t)(adapter->tpd_ring.dma& 0x00000000ffffffffULL));
+    AT_WRITE_REG(hw,
+                 REG_DESC_CMB_ADDR_LO,
+                 (uint32_t)(adapter->cmb.dma& 0x00000000ffffffffULL));
+    AT_WRITE_REG(hw,
+                 REG_DESC_SMB_ADDR_LO,
+                 (uint32_t)(adapter->smb.dma& 0x00000000ffffffffULL));
+
+    // element count
+    value = adapter->rrd_ring.count;
+    value <<= 16;
+    value += adapter->rfd_ring.count;
+    AT_WRITE_REG(hw, REG_DESC_RFD_RRD_RING_SIZE, value);
+    AT_WRITE_REG(hw, REG_DESC_TPD_RING_SIZE, adapter->tpd_ring.count);
+
+/*
+    // config SRAM
+    // add RXF 256*8 bytes
+    value = ((2795 + 256) << 16) | 432;
+    AT_WRITE_REG(hw, REG_SRAM_RXF_ADDR, value);
+    value = 2364 + 256;
+    AT_WRITE_REG(hw, REG_SRAM_RXF_LEN, value);
+    // sub TXF 256*8 bytes
+    value = (4075 << 16) | (2796 + 256);
+    AT_WRITE_REG(hw, REG_SRAM_TXF_ADDR, value);
+    value = 1280 - 256;
+    AT_WRITE_REG(hw, REG_SRAM_TXF_LEN, value);
+*/
+    // Load Ptr
+    AT_WRITE_REG(hw, REG_LOAD_PTR, 1);
+
+
+    /* config Mailbox */
+
+    value =
+         (((uint32_t)atomic_read(&adapter->tpd_ring.next_to_use)
+            &MB_TPD_PROD_INDX_MASK)<<MB_TPD_PROD_INDX_SHIFT) |
+         (((uint32_t)atomic_read(&adapter->rrd_ring.next_to_clean)
+            &MB_RRD_CONS_INDX_MASK)<<MB_RRD_CONS_INDX_SHIFT) |
+         (((uint32_t)atomic_read(&adapter->rfd_ring.next_to_use)
+            &MB_RFD_PROD_INDX_MASK)<<MB_RFD_PROD_INDX_SHIFT);
+    AT_WRITE_REG(hw, REG_MAILBOX, value);
+
+//    DEBUGOUT1("init Mailbox with 0x%x", value);
+
+    /* config IPG/IFG */
+    value =
+        (((uint32_t)hw->ipgt&MAC_IPG_IFG_IPGT_MASK)
+              <<MAC_IPG_IFG_IPGT_SHIFT) |
+        (((uint32_t)hw->min_ifg &MAC_IPG_IFG_MIFG_MASK)
+              <<MAC_IPG_IFG_MIFG_SHIFT) |
+        (((uint32_t)hw->ipgr1&MAC_IPG_IFG_IPGR1_MASK)
+              <<MAC_IPG_IFG_IPGR1_SHIFT)|
+        (((uint32_t)hw->ipgr2&MAC_IPG_IFG_IPGR2_MASK)
+              <<MAC_IPG_IFG_IPGR2_SHIFT);
+    AT_WRITE_REG(hw, REG_MAC_IPG_IFG, value);
+//    DEBUGOUT1("init ipg/ifg with 0x%x", value);
+
+    /* config  Half-Duplex Control */
+    value =
+      ((uint32_t)hw->lcol&MAC_HALF_DUPLX_CTRL_LCOL_MASK) |
+      (((uint32_t)hw->max_retry&MAC_HALF_DUPLX_CTRL_RETRY_MASK)
+          <<MAC_HALF_DUPLX_CTRL_RETRY_SHIFT) |
+      MAC_HALF_DUPLX_CTRL_EXC_DEF_EN   |
+      (0xa<<MAC_HALF_DUPLX_CTRL_ABEBT_SHIFT) |
+      (((uint32_t)hw->jam_ipg&MAC_HALF_DUPLX_CTRL_JAMIPG_MASK)
+          <<MAC_HALF_DUPLX_CTRL_JAMIPG_SHIFT);
+    AT_WRITE_REG(hw, REG_MAC_HALF_DUPLX_CTRL, value);
+//    DEBUGOUT1("init Half Duplex with 0x%x", value);
+
+
+    /* set Interrupt Moderator Timer */
+    AT_WRITE_REGW(hw, REG_IRQ_MODU_TIMER_INIT, adapter->imt);
+    AT_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_ITIMER_EN);
+//    DEBUGOUT1("init Irq Modurator Timer with 0x%x", adapter->imt);
+
+    /* set Interrupt Clear Timer */
+    AT_WRITE_REGW(hw, REG_CMBDISDMA_TIMER, adapter->ict);
+//    DEBUGOUT1("init Irq Clear Timer with 0x%x", adapter->ict);
+
+    /* set MTU */
+    AT_WRITE_REG(hw, REG_MTU, hw->max_frame_size+4); // 4 : VLAN
+//    DEBUGOUT1("init MTU with 0x%x", hw->max_frame_size);
+
+    // jumbo size & rrd retirement timer
+    value =
+      (((uint32_t)hw->rx_jumbo_th&RXQ_JMBOSZ_TH_MASK)
+          << RXQ_JMBOSZ_TH_SHIFT)|
+      (((uint32_t)hw->rx_jumbo_lkah&RXQ_JMBO_LKAH_MASK)
+          << RXQ_JMBO_LKAH_SHIFT)|
+      (((uint32_t)hw->rrd_ret_timer&RXQ_RRD_TIMER_MASK)
+          << RXQ_RRD_TIMER_SHIFT) ;
+    AT_WRITE_REG(hw, REG_RXQ_JMBOSZ_RRDTIM, value);
+//    DEBUGOUT1("init RXQ Jumbo size RRD retirement Timer with 0x=%x", value);
+    // Flow Control
+    switch (hw->dev_rev)
+    {
+    case 0x8001:
+    case 0x9001:
+    case 0x9002:
+    case 0x9003:
+	    set_flow_ctrl_old(adapter);
+	    break;
+    default:
+	    set_flow_ctrl_new(hw);
+	    break;
+    }
+
+    /* config TXQ */
+    value =
+       (((uint32_t)hw->tpd_burst&TXQ_CTRL_TPD_BURST_NUM_MASK)
+           << TXQ_CTRL_TPD_BURST_NUM_SHIFT) |
+       (((uint32_t)hw->txf_burst&TXQ_CTRL_TXF_BURST_NUM_MASK)
+           << TXQ_CTRL_TXF_BURST_NUM_SHIFT) |
+       (((uint32_t)hw->tpd_fetch_th&TXQ_CTRL_TPD_FETCH_TH_MASK)
+           << TXQ_CTRL_TPD_FETCH_TH_SHIFT) |
+       TXQ_CTRL_ENH_MODE |
+       TXQ_CTRL_EN;
+    AT_WRITE_REG(hw, REG_TXQ_CTRL, value);
+//    DEBUGOUT1("init TXQ Control with 0x%x", value);
+
+    // min tpd fetch gap & tx jumbo packet size threshold for taskoffload
+    value =
+      (((uint32_t)hw->tx_jumbo_task_th&TX_JUMBO_TASK_TH_MASK)
+         << TX_JUMBO_TASK_TH_SHIFT) |
+      (((uint32_t)hw->tpd_fetch_gap&TX_TPD_MIN_IPG_MASK)
+         << TX_TPD_MIN_IPG_SHIFT);
+    AT_WRITE_REG(hw, REG_TX_JUMBO_TASK_TH_TPD_IPG, value);
+//    DEBUGOUT1("init TPD fetch gap & TX jumbo taskoffload threshold with 0x%x", value);
+
+    /* config RXQ */
+    value =
+      (((uint32_t)hw->rfd_burst&RXQ_CTRL_RFD_BURST_NUM_MASK)
+          << RXQ_CTRL_RFD_BURST_NUM_SHIFT)|
+      (((uint32_t)hw->rrd_burst&RXQ_CTRL_RRD_BURST_THRESH_MASK)
+          << RXQ_CTRL_RRD_BURST_THRESH_SHIFT)|
+      (((uint32_t)hw->rfd_fetch_gap&RXQ_CTRL_RFD_PREF_MIN_IPG_MASK)
+          << RXQ_CTRL_RFD_PREF_MIN_IPG_SHIFT) |
+      RXQ_CTRL_CUT_THRU_EN |
+      RXQ_CTRL_EN ;
+      AT_WRITE_REG(hw, REG_RXQ_CTRL, value);
+//     DEBUGOUT1("init RXQ control with 0x%x", value);
+
+    /* config  DMA Engine */
+    value =
+      ((((uint32_t)hw->dmar_block)&DMA_CTRL_DMAR_BURST_LEN_MASK)
+           << DMA_CTRL_DMAR_BURST_LEN_SHIFT)|
+      ((((uint32_t)hw->dmaw_block)&DMA_CTRL_DMAR_BURST_LEN_MASK)
+           << DMA_CTRL_DMAR_BURST_LEN_SHIFT) |
+      DMA_CTRL_DMAR_EN |
+      DMA_CTRL_DMAW_EN;
+    value  |= (uint32_t)hw->dma_ord;
+    if (at_rcb_128 == hw->rcb_value)
+    {
+        value |= DMA_CTRL_RCB_VALUE;
+    }
+    AT_WRITE_REG(hw, REG_DMA_CTRL, value);
+//    DEBUGOUT1("init DMA Engine with 0x%x", value);
+
+    /* config CMB / SMB */
+    value = hw->cmb_rrd | ((uint32_t)hw->cmb_tpd << 16);
+    AT_WRITE_REG(hw, REG_CMB_WRITE_TH, value);
+    value = hw->cmb_rx_timer | ((uint32_t)hw->cmb_tx_timer << 16);
+    AT_WRITE_REG(hw, REG_CMB_WRITE_TIMER, value);
+    AT_WRITE_REG(hw, REG_SMB_TIMER, hw->smb_timer);
+//    DEBUGOUT1("init CMB Write Timer with 0x%x", value);
+
+    // --- enable CMB / SMB
+    value = CSMB_CTRL_CMB_EN | CSMB_CTRL_SMB_EN;
+    AT_WRITE_REG(hw, REG_CSMB_CTRL, value);
+
+    value = AT_READ_REG(&adapter->hw, REG_ISR);
+    if ((value&ISR_PHY_LINKDOWN) != 0) {
+        value = 1; // config failed
+    } else {
+        value = 0;
+    }
+    // clear all interrupt status
+    AT_WRITE_REG(&adapter->hw, REG_ISR, 0x3fffffff);
+    AT_WRITE_REG(&adapter->hw, REG_ISR, 0);
+    return value;
+}
+
+/**
+ * at_set_mac - Change the Ethernet Address of the NIC
+ * @netdev: network interface device structure
+ * @p: pointer to an address structure
+ *
+ * Returns 0 on success, negative on failure
+ **/
+
+static int
+at_set_mac(struct net_device *netdev, void *p)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    struct sockaddr *addr = p;
+
+    DEBUGFUNC("at_set_mac !");
+
+    if (netif_running(netdev))
+        return -EBUSY;
+
+    if(!is_valid_ether_addr(addr->sa_data))
+        return -EADDRNOTAVAIL;
+
+    memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+    memcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);
+
+    set_mac_addr(&adapter->hw);
+
+
+    return 0;
+}
+
+
+
+/**
+ * at_change_mtu - Change the Maximum Transfer Unit
+ * @netdev: network interface device structure
+ * @new_mtu: new value for maximum frame size
+ *
+ * Returns 0 on success, negative on failure
+ **/
+
+static int
+at_change_mtu(struct net_device *netdev, int new_mtu)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    int old_mtu = netdev->mtu;
+    int max_frame = new_mtu + ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
+
+    DEBUGFUNC("at_change_mtu !");
+
+    if((max_frame < MINIMUM_ETHERNET_FRAME_SIZE) ||
+       (max_frame > MAX_JUMBO_FRAME_SIZE)) {
+        AT_ERR("Invalid MTU setting\n");
+        return -EINVAL;
+    }
+
+
+    adapter->hw.max_frame_size = max_frame;
+    adapter->hw.tx_jumbo_task_th = (max_frame+7)>>3;
+    adapter->rx_buffer_len = (max_frame+7) & ~7;
+
+    adapter->hw.rx_jumbo_th = adapter->rx_buffer_len  / 8;
+
+    netdev->mtu = new_mtu;
+
+    if((old_mtu != new_mtu) && netif_running(netdev)) {
+
+        at_down(adapter);
+        at_up(adapter);
+    }
+
+    return 0;
+}
+
+
+/**
+ * at_alloc_rx_buffers - Replace used receive buffers
+ * @adapter: address of board private structure
+ **/
+
+static uint16_t
+at_alloc_rx_buffers(struct at_adapter *adapter)
+{
+    struct at_rfd_ring *rfd_ring = &adapter->rfd_ring;
+    struct net_device *netdev = adapter->netdev;
+    struct pci_dev *pdev = adapter->pdev;
+    struct page *page;
+    unsigned long offset;
+    struct at_buffer *buffer_info, * next_info;
+    struct sk_buff *skb;
+    uint16_t num_alloc = 0;
+    uint16_t rfd_next_to_use, next_next;
+    rx_free_desc_t *rfd_desc;
+
+    next_next = rfd_next_to_use = (uint16_t)atomic_read(&rfd_ring->next_to_use);
+    if (++next_next == rfd_ring->count)      next_next = 0;
+    buffer_info = &rfd_ring->buffer_info[rfd_next_to_use];
+    next_info = &rfd_ring->buffer_info[next_next];
+
+    while (!buffer_info->alloced && !next_info->alloced) {
+        if (NULL != buffer_info->skb) {
+            buffer_info->alloced = 1;
+	    DEBUGOUT1("skip rfd allocate (%d)", rfd_next_to_use);
+            goto next;
+        }
+
+        rfd_desc = AT_RFD_DESC(rfd_ring, rfd_next_to_use);
+
+        skb = dev_alloc_skb(adapter->rx_buffer_len + NET_IP_ALIGN);
+
+        if(!skb) {
+            /* Better luck next round */
+            adapter->net_stats.rx_dropped++;
+            break;
+        }
+
+        /* Make buffer alignment 2 beyond a 16 byte boundary
+         * this will result in a 16 byte aligned IP header after
+         * the 14 byte MAC header is removed
+         */
+        skb_reserve(skb, NET_IP_ALIGN);
+
+        skb->dev = netdev;
+
+        buffer_info->alloced = 1;
+        buffer_info->skb = skb;
+        buffer_info->length = (uint16_t)adapter->rx_buffer_len;
+        page = virt_to_page(skb->data);
+        offset = (unsigned long) skb->data & ~PAGE_MASK;
+        buffer_info->dma =
+                pci_map_page(pdev,
+                             page,
+                             offset,
+                             adapter->rx_buffer_len,
+                             PCI_DMA_FROMDEVICE);
+        rfd_desc->buffer_addr = cpu_to_le64(buffer_info->dma);
+        rfd_desc->buf_len = cpu_to_le16(adapter->rx_buffer_len);
+        rfd_desc->coalese = 0;
+
+next:
+        rfd_next_to_use = next_next;
+        if (++next_next == rfd_ring->count)     next_next = 0;
+
+        buffer_info = &rfd_ring->buffer_info[rfd_next_to_use];
+        next_info = &rfd_ring->buffer_info[next_next];
+        num_alloc++;
+    }
+
+    if (0 != num_alloc) {
+        /* Force memory writes to complete before letting h/w
+         * know there are new descriptors to fetch.  (Only
+         * applicable for weak-ordered memory model archs,
+         * such as IA-64). */
+        wmb();
+        atomic_set(&rfd_ring->next_to_use, (int)rfd_next_to_use);
+    }
+    return num_alloc;
+}
+
+
+void
+at_read_pci_cfg(struct at_hw *hw, uint32_t reg, uint16_t *value)
+{
+    struct at_adapter *adapter = hw->back;
+
+    pci_read_config_word(adapter->pdev, reg, value);
+}
+
+void
+at_write_pci_cfg(struct at_hw *hw, uint32_t reg, uint16_t *value)
+{
+    struct at_adapter *adapter = hw->back;
+
+    pci_write_config_word(adapter->pdev, reg, *value);
+}
+
+/**
+ * at_clean_tx_ring - Free Tx Buffers
+ * @adapter: board private structure
+ **/
+
+static void
+at_clean_tx_ring(struct at_adapter *adapter)
+{
+    struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+    struct at_buffer *buffer_info;
+    struct pci_dev *pdev = adapter->pdev;
+    unsigned long size;
+    unsigned int i;
+
+//    DEBUGFUNC("at_clean_tx_ring !");
+
+    /* Free all the Tx ring sk_buffs */
+
+    for(i = 0; i < tpd_ring->count; i++) {
+        buffer_info = &tpd_ring->buffer_info[i];
+        if (buffer_info->dma) {
+            pci_unmap_page(pdev,
+                           buffer_info->dma,
+                           buffer_info->length,
+                           PCI_DMA_TODEVICE);
+            buffer_info->dma = 0;
+        }
+    }
+
+    for(i = 0; i < tpd_ring->count; i++) {
+        buffer_info = &tpd_ring->buffer_info[i];
+        if(buffer_info->skb) {
+            dev_kfree_skb_any(buffer_info->skb);
+            buffer_info->skb = NULL;
+        }
+    }
+
+    size = sizeof(struct at_buffer) * tpd_ring->count;
+    memset(tpd_ring->buffer_info, 0, size);
+
+    /* Zero out the descriptor ring */
+
+    memset(tpd_ring->desc, 0, tpd_ring->size);
+
+    atomic_set(&tpd_ring->next_to_use, 0);
+    atomic_set(&tpd_ring->next_to_clean, 0);
+}
+
+/**
+ * at_clean_rx_ring - Free RFD Buffers
+ * @adapter: board private structure
+ **/
+
+static void
+at_clean_rx_ring(struct at_adapter *adapter)
+{
+    struct at_rfd_ring *rfd_ring = &adapter->rfd_ring;
+    struct at_rrd_ring *rrd_ring = &adapter->rrd_ring;
+    struct at_buffer *buffer_info;
+    struct pci_dev *pdev = adapter->pdev;
+    unsigned long size;
+    unsigned int i;
+
+//    DEBUGFUNC("at_clean_rx_ring !");
+
+    /* Free all the Rx ring sk_buffs */
+
+    for(i = 0; i < rfd_ring->count; i++) {
+        buffer_info = &rfd_ring->buffer_info[i];
+        if(buffer_info->dma) {
+
+            pci_unmap_page(pdev,
+                           buffer_info->dma,
+                           buffer_info->length,
+                           PCI_DMA_FROMDEVICE);
+            buffer_info->dma = 0;
+        }
+        if(buffer_info->skb) {
+            dev_kfree_skb(buffer_info->skb);
+            buffer_info->skb = NULL;
+        }
+    }
+
+    size = sizeof(struct at_buffer) * rfd_ring->count;
+    memset(rfd_ring->buffer_info, 0, size);
+
+    /* Zero out the descriptor ring */
+
+    memset(rfd_ring->desc, 0, rfd_ring->size);
+
+    rfd_ring->next_to_clean = 0;
+    atomic_set(&rfd_ring->next_to_use, 0);
+
+    rrd_ring->next_to_use = 0;
+    atomic_set(&rrd_ring->next_to_clean, 0);
+}
+
+/**
+ * at_get_stats - Get System Network Statistics
+ * @netdev: network interface device structure
+ *
+ * Returns the address of the device statistics structure.
+ * The statistics are actually updated from the timer callback.
+ **/
+
+static struct net_device_stats *
+at_get_stats(struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+
+   // DEBUGFUNC("at_get_stats");
+    return &adapter->net_stats;
+}
+
+/**
+ * at_ioctl -
+ * @netdev:
+ * @ifreq:
+ * @cmd:
+ **/
+
+static int
+at_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+//    DEBUGFUNC("at_ioctl !");
+    switch (cmd) {
+#ifdef SIOCGMIIPHY
+    case SIOCGMIIPHY:
+    case SIOCGMIIREG:
+    case SIOCSMIIREG:
+        return at_mii_ioctl(netdev, ifr, cmd);
+#endif
+
+/*
+#ifdef ETHTOOL_OPS_COMPAT
+	case SIOCETHTOOL:
+		return at_ethtool_ioctl(ifr);
+#endif
+*/
+
+	//michael add 2005-11-1
+	case SIOCETHTOOL:
+		return at_ethtool_ioctl(netdev,ifr);
+#ifdef SIOCDEVPRIVATE
+    case SIOCDEVPRIVATE:
+        return at_priv_ioctl(netdev, ifr);
+#endif
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+#ifdef SIOCGMIIPHY
+/**
+ * at_mii_ioctl -
+ * @netdev:
+ * @ifreq:
+ * @cmd:
+ **/
+
+static int
+at_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
+    unsigned long flags;
+
+//    DEBUGFUNC("at_mii_ioctl !");
+
+    switch (cmd) {
+    case SIOCGMIIPHY:
+        data->phy_id = 0;
+        break;
+    case SIOCGMIIREG:
+        if (!capable(CAP_NET_ADMIN))
+            return -EPERM;
+        spin_lock_irqsave(&adapter->stats_lock, flags);
+        if (at_read_phy_reg(&adapter->hw, data->reg_num & 0x1F, &data->val_out)) {
+            spin_unlock_irqrestore(&adapter->stats_lock, flags);
+            return -EIO;
+        }
+        spin_unlock_irqrestore(&adapter->stats_lock, flags);
+        break;
+    case SIOCSMIIREG:
+        if (!capable(CAP_NET_ADMIN))
+            return -EPERM;
+        if (data->reg_num & ~(0x1F))
+            return -EFAULT;
+
+        spin_lock_irqsave(&adapter->stats_lock, flags);
+	DEBUGOUT1("<at_mii_ioctl> write %x %x",
+			data->reg_num,
+			data->val_in);
+        if (at_write_phy_reg(&adapter->hw, data->reg_num, data->val_in)) {
+            spin_unlock_irqrestore(&adapter->stats_lock, flags);
+            return -EIO;
+        }
+        // ......
+        spin_unlock_irqrestore(&adapter->stats_lock, flags);
+        break;
+
+    default:
+        return -EOPNOTSUPP;
+    }
+    return AT_SUCCESS;
+}
+
+#endif
+
+/**
+ * at_tx_timeout - Respond to a Tx Hang
+ * @netdev: network interface device structure
+ **/
+
+static void
+at_tx_timeout(struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+
+    DEBUGFUNC("at_tx_timeout !");
+
+    /* Do the reset outside of interrupt context */
+    schedule_work(&adapter->tx_timeout_task);
+}
+
+/*
+ * If TPD Buffer size equal to 0, PCIE DMAR_TO_INT
+ * will assert. We do soft reset <0x1400=1> according
+ * with the SPEC. BUT, it seemes that PCIE or DMA
+ * state-machine will not be reset. DMAR_TO_INT will
+ * assert again and again.
+ */
+static void
+at_tx_timeout_task(struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    //struct at_hw* hw = &adapter->hw;
+
+    //uint32_t val1, val2;
+
+    DEBUGFUNC("at_tx_timeout_task !");
+
+
+    netif_device_detach(netdev);
+
+    /*******   disp debug info **********
+    val1 = AT_READ_REG(hw, 0x15f0);
+    DEBUGOUT1("<15f0> = 0x%x", val1);
+    val1 = AT_READ_REG(hw, 0x1540);
+    val2 = AT_READ_REG(hw, 0x1544);
+    DEBUGOUT1("<1540> = 0x%x <1544> = 0x%x", val1, val2);
+    val1 = AT_READ_REG(hw, 0x1548);
+    val2 = AT_READ_REG(hw, 0x154c);
+    DEBUGOUT1("<1548> = 0x%x <154c> = 0x%x", val1, val2);
+    val1 = AT_READ_REG(hw, 0x1550);
+    val2 = AT_READ_REG(hw, 0x1554);
+    DEBUGOUT1("<1550> = 0x%x <1554> = 0x%x", val1, val2);
+    val1 = AT_READ_REG(hw, 0x1558);
+    val2 = AT_READ_REG(hw, 0x155c);
+    DEBUGOUT1("<1558> = 0x%x <155c> = 0x%x", val1, val2);
+
+    DEBUGOUT1("tpd next to clean %d, tpd next to use %d",
+		(uint16_t) atomic_read(&adapter->tpd_ring.next_to_clean),
+                (uint16_t) atomic_read(&adapter->tpd_ring.next_to_use));
+
+    DEBUGOUT1("rfd ring: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x",
+               *((uint32_t*)(adapter->rfd_ring.desc) + 0),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 1),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 2),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 3),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 4),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 5));
+
+    DEBUGOUT1("rfd ring: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x",
+               *((uint32_t*)(adapter->rfd_ring.desc) + 6),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 7),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 8),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 9),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 10),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 11));
+
+    DEBUGOUT1("rfd ring: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x",
+               *((uint32_t*)(adapter->rfd_ring.desc) + 12),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 13),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 14),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 15),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 16),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 17));
+
+    DEBUGOUT1("rfd ring: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x",
+               *((uint32_t*)(adapter->rfd_ring.desc) + 18),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 19),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 20),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 21),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 22),
+               *((uint32_t*)(adapter->rfd_ring.desc) + 23));
+    */
+    at_down(adapter);
+    at_up(adapter);
+    netif_device_attach(netdev);
+}
+/**
+ * at_link_chg_task - deal with link change event Out of interrupt context
+ * @netdev: network interface device structure
+ **/
+static void
+at_link_chg_task(struct net_device* netdev)
+{
+    struct at_adapter * adapter = netdev_priv(netdev);
+    unsigned long flags;
+    DEBUGFUNC("at_link_chg_task !");
+
+    spin_lock_irqsave(&adapter->stats_lock, flags);
+
+    at_check_link(adapter);
+
+    spin_unlock_irqrestore(&adapter->stats_lock, flags);
+}
+
+static void
+at_check_for_link(struct at_adapter* adapter)
+{
+    struct net_device *netdev = adapter->netdev;
+    uint16_t phy_data = 0;
+
+    DEBUGFUNC("at_check_for_link!");
+
+    spin_lock(&adapter->stats_lock);
+    adapter->phy_timer_pending = FALSE;
+    at_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);
+    at_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);
+    spin_unlock(&adapter->stats_lock);
+
+    DEBUGOUT1("MII_BMSR=%x <at_check_for_link>", phy_data);
+
+    // notify upper layer link down ASAP
+    if (!(phy_data&BMSR_LSTATUS)) { // Link Down
+        if (netif_carrier_ok(netdev)) { // old link state: Up
+            printk(KERN_INFO
+                   "%s: %s NIC Link is Down\n",
+		   			at_driver_name,
+                    netdev->name );
+            adapter->link_speed = SPEED_0;
+            netif_carrier_off(netdev);
+            netif_stop_queue(netdev);
+        }
+    }
+    schedule_work(&adapter->link_chg_task);
+}
+static inline void
+at_clear_phy_int(struct at_adapter* adapter)
+{
+	uint16_t phy_data;
+
+        spin_lock(&adapter->stats_lock);
+	at_read_phy_reg(&adapter->hw, 19, &phy_data);
+	spin_unlock(&adapter->stats_lock);
+}
+
+/**
+ * at_intr - Interrupt Handler
+ * @irq: interrupt number
+ * @data: pointer to a network interface device structure
+ * @pt_regs: CPU registers structure
+ **/
+
+static irqreturn_t
+at_intr(int irq, void *data, struct pt_regs *regs)
+{
+    struct at_adapter *adapter = ((struct net_device*)data)->priv;
+    uint32_t status;
+    uint8_t update_rx;
+    int max_ints = 10;
+
+    if (0 == (status = adapter->cmb.cmb->int_stats))
+        return IRQ_NONE;
+
+    update_rx = 0;
+
+    do {
+        // clear CMB interrupt status at once
+        adapter->cmb.cmb->int_stats = 0;
+
+	if (status & ISR_GPHY) { // clear phy status
+               at_clear_phy_int(adapter);
+	}
+        // clear ISR status, and Enable CMB DMA/Disable Interrupt
+        AT_WRITE_REG(&adapter->hw, REG_ISR, status|ISR_DIS_INT);
+
+        // check if SMB intr
+        if (status & ISR_SMB)
+        {
+            at_inc_smb(adapter);
+        }
+
+        // check if PCIE PHY Link down
+        if (status&ISR_PHY_LINKDOWN)
+        {
+            DEBUGOUT1("pcie phy linkdown %x", status);
+            if(netif_running(adapter->netdev)) { // reset MAC
+                AT_WRITE_REG(&adapter->hw, REG_IMR, 0);
+                schedule_work(&adapter->pcie_dma_to_rst_task);
+                return IRQ_HANDLED;
+            }
+        }
+
+        // check if DMA read/write error ?
+        if (status&(ISR_DMAR_TO_RST|ISR_DMAW_TO_RST))
+        {
+            DEBUGOUT1("PCIE DMA RW error (status = 0x%x) !", status);
+            //AT_WRITE_REG(&adapter->hw, REG_MASTER_CTRL, MASTER_CTRL_SOFT_RST);
+            AT_WRITE_REG(&adapter->hw, REG_IMR, 0);
+            schedule_work(&adapter->pcie_dma_to_rst_task);
+            return IRQ_HANDLED;
+        }
+
+
+        // link event
+        if (status&ISR_GPHY)
+        {
+            adapter->soft_stats.tx_carrier_errors++;
+            at_check_for_link(adapter);
+        }
+
+        // transmit event
+        if (status&ISR_CMB_TX) {
+            at_intr_tx(adapter);
+        }
+
+        // rx exception
+        if (    status&(ISR_RXF_OV|
+                        ISR_RFD_UNRUN|
+                        ISR_RRD_OV|
+                        ISR_HOST_RFD_UNRUN|
+                        ISR_HOST_RRD_OV|
+                        ISR_CMB_RX))    {
+            if (status&(ISR_RXF_OV|
+                        ISR_RFD_UNRUN|
+                        ISR_RRD_OV|
+                        ISR_HOST_RFD_UNRUN|
+                        ISR_HOST_RRD_OV)) {
+                DEBUGOUT1(KERN_INFO
+                          "Receive Exception ! status = 0x%x", status);
+            }
+            at_intr_rx(adapter);
+        }
+
+
+        if (--max_ints < 0)
+            break;
+
+    } while ((status = adapter->cmb.cmb->int_stats));
+
+    // re-enable Interrupt
+    AT_WRITE_REG(&adapter->hw, REG_ISR, ISR_DIS_SMB|ISR_DIS_DMA);
+    return IRQ_HANDLED;
+}
+
+static void
+at_intr_tx(struct at_adapter* adapter)
+{
+    struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+    struct at_buffer* buffer_info;
+    uint16_t sw_tpd_next_to_clean;
+    uint16_t cmb_tpd_next_to_clean;
+    uint8_t update = 0;
+
+
+    sw_tpd_next_to_clean = (uint16_t)atomic_read(&tpd_ring->next_to_clean);
+    cmb_tpd_next_to_clean = le16_to_cpu(adapter->cmb.cmb->tpd_cons_idx);
+
+    while (cmb_tpd_next_to_clean != sw_tpd_next_to_clean) {
+        tx_packet_desc_t* tpd;
+
+        update = 1;
+
+        tpd = AT_TPD_DESC(tpd_ring, sw_tpd_next_to_clean);
+        buffer_info = &tpd_ring->buffer_info[sw_tpd_next_to_clean];
+        if(buffer_info->dma) {
+            pci_unmap_page(adapter->pdev,
+                           buffer_info->dma,
+                           buffer_info->length,
+                           PCI_DMA_TODEVICE);
+            buffer_info->dma = 0;
+        }
+
+        if(buffer_info->skb) {
+            dev_kfree_skb_irq(buffer_info->skb);
+            buffer_info->skb = NULL;
+        }
+        tpd->buffer_addr = 0;
+        tpd->desc.data = 0;
+
+        if (++sw_tpd_next_to_clean == tpd_ring->count)
+            sw_tpd_next_to_clean = 0;
+    }
+    atomic_set(&tpd_ring->next_to_clean,sw_tpd_next_to_clean);
+
+    if(netif_queue_stopped(adapter->netdev) &&
+       netif_carrier_ok(adapter->netdev))
+        netif_wake_queue(adapter->netdev);
+}
+
+static inline void
+at_rx_checksum(struct at_adapter* adapter,
+        rx_return_desc_t* rrd,
+        struct sk_buff* skb)
+{
+    skb->ip_summed = CHECKSUM_NONE;
+
+    if (rrd->pkt_flg&PACKET_FLAG_ERR) {
+        if (rrd->err_flg&
+            (ERR_FLAG_CRC|ERR_FLAG_TRUNC|ERR_FLAG_CODE|ERR_FLAG_OV)) {
+            adapter->hw_csum_err++;
+	    DEBUGOUT("checksum error !");
+            return;
+        }
+    }
+
+    // none IPv4
+    if (!(rrd->pkt_flg&PACKET_FLAG_IPV4)) {
+        // checksum is invalid
+	DEBUGOUT("checksum is invalid because of non-IPv4");
+        return;
+    }
+
+    // IPv4 packet
+
+    if (!(rrd->err_flg&(ERR_FLAG_IP_CHKSUM|ERR_FLAG_L4_CHKSUM)) ) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		adapter->hw_csum_good++;
+		DEBUGOUT("IPv4, checkesum ok");
+		return;
+    }
+
+    // IPv4, but hardware think it's checksum is wrong
+    DEBUGOUT1("hardware xsum wrong pkt_flag:%x, err_flag:%x",
+		    rrd->pkt_flg, rrd->err_flg);
+    skb->ip_summed = CHECKSUM_HW;
+    skb->csum = htons(rrd->xsz.xsum_sz.rx_chksum);
+    adapter->hw_csum_err++;
+    return;
+}
+
+
+static void
+at_intr_rx(struct at_adapter* adapter)
+{
+    int i, count;
+    uint16_t length, rrd_next_to_clean;
+    struct at_rfd_ring *rfd_ring = &adapter->rfd_ring;
+    struct at_rrd_ring *rrd_ring = &adapter->rrd_ring;
+    struct at_buffer * buffer_info;
+    rx_return_desc_t* rrd;
+    struct sk_buff *skb;
+
+    count = 0;
+
+    rrd_next_to_clean = (uint16_t)atomic_read(&rrd_ring->next_to_clean);
+
+    while (1)
+    {
+        rrd = AT_RRD_DESC(rrd_ring, rrd_next_to_clean);
+        i = 1;
+        if (rrd->xsz.valid) { // packet valid
+chk_rrd:
+            // check rrd status
+	    if (rrd->num_buf != 1) {
+		DEBUGOUT1("RRD NumRfd %d", rrd->num_buf);
+                DEBUGOUT1("packet length = %d", rrd->xsz.xsum_sz.pkt_size);
+            } else {
+		goto rrd_ok;
+	    }
+
+            // rrd seems to be bad
+            if (i-- > 0) { // rrd may not be DMAed completely
+		DEBUGOUT("RRD may not be DMAed completely");
+                usec_delay(1);
+                goto chk_rrd;
+            }
+            // bad rrd
+            printk("BAD RRD\n");
+	    // see if update RFD index
+	    if (rrd->num_buf > 1) {
+	        uint16_t num_buf;
+	        num_buf =
+		(rrd->xsz.xsum_sz.pkt_size+adapter->rx_buffer_len - 1)/
+			adapter->rx_buffer_len;
+		DEBUGOUT1("RRD.buf_index (%d)", rrd->buf_indx);
+		if (rrd->num_buf == num_buf) {
+	            // clean alloc flag for bad rrd
+                    while (rfd_ring->next_to_clean !=
+		           (rrd->buf_indx + num_buf) ) {
+			DEBUGOUT1("clear index (%d)", rfd_ring->next_to_clean);
+	                rfd_ring->buffer_info[rfd_ring->next_to_clean].alloced = 0;
+	                if (++rfd_ring->next_to_clean ==
+			    rfd_ring->count) {
+		            rfd_ring->next_to_clean = 0;
+	                }
+	            } // end while
+		} // end if (rrd->num_buf == ...)
+	    }
+
+	    // update rrd
+            rrd->xsz.valid = 0;
+            if (++rrd_next_to_clean == rrd_ring->count)
+                rrd_next_to_clean = 0;
+            count++;
+            continue;
+        } else { // current rrd still not be updated
+          break;
+        }
+
+rrd_ok:
+	//printk(KERN_INFO "Receving Packet!\n");
+	// clean alloc flag for bad rrd
+	while (rfd_ring->next_to_clean != rrd->buf_indx) {
+	    rfd_ring->buffer_info[rfd_ring->next_to_clean].alloced = 0;
+	    if (++rfd_ring->next_to_clean == rfd_ring->count) {
+		rfd_ring->next_to_clean = 0;
+	    }
+	}
+
+        buffer_info = &rfd_ring->buffer_info[rrd->buf_indx];
+	if (++rfd_ring->next_to_clean == rfd_ring->count) {
+	    rfd_ring->next_to_clean = 0;
+	}
+
+
+        // update rrd next to clean
+        if (++rrd_next_to_clean == rrd_ring->count)
+            rrd_next_to_clean = 0;
+        count++;
+
+
+        if (rrd->pkt_flg&PACKET_FLAG_ERR) {
+            if (!(rrd->err_flg &
+                (ERR_FLAG_IP_CHKSUM|ERR_FLAG_L4_CHKSUM|ERR_FLAG_LEN))) {
+                /* packet error , don't need upstream */
+                buffer_info->alloced = 0;
+		rrd->xsz.valid = 0;
+                DEBUGOUT1("rrd error flag %x", rrd->err_flg);
+                continue;
+            }
+        }
+
+        /* Good Receive */
+
+        pci_unmap_page(adapter->pdev,
+                       buffer_info->dma,
+                       buffer_info->length,
+                       PCI_DMA_FROMDEVICE);
+        skb = buffer_info->skb;
+        length = le16_to_cpu(rrd->xsz.xsum_sz.pkt_size);
+
+        skb_put(skb, length - ETHERNET_FCS_SIZE);
+
+        /* Receive Checksum Offload */
+        at_rx_checksum(adapter, rrd, skb);
+        skb->protocol = eth_type_trans(skb, adapter->netdev);
+
+#ifdef NETIF_F_HW_VLAN_TX
+        if(adapter->vlgrp && (rrd->pkt_flg&PACKET_FLAG_VLAN_INS)) {
+            uint16_t vlan_tag =
+                    (rrd->vlan_tag>>4) |
+                    ((rrd->vlan_tag&7) << 13) |
+                    ((rrd->vlan_tag&8) << 9);
+            DEBUGOUT1("RX VLAN TAG<RRD>=0x%04x", rrd->vlan_tag);
+            vlan_hwaccel_rx(skb, adapter->vlgrp, vlan_tag);
+        } else
+#endif
+        netif_rx(skb);
+
+	// let protocol layer free skb
+        buffer_info->skb = NULL;
+        buffer_info->alloced = 0;
+        rrd->xsz.valid = 0;
+
+        adapter->netdev->last_rx = jiffies;
+    }
+
+    atomic_set(&rrd_ring->next_to_clean, rrd_next_to_clean);
+
+    at_alloc_rx_buffers(adapter);
+
+    // update mailbox ?
+    if (0 != count) {
+        uint32_t tpd_next_to_use;
+        uint32_t rfd_next_to_use;
+        uint32_t rrd_next_to_clean;
+
+        spin_lock(&adapter->mb_lock);
+
+        tpd_next_to_use = atomic_read(&adapter->tpd_ring.next_to_use);
+        rfd_next_to_use = (uint32_t)atomic_read(&adapter->rfd_ring.next_to_use);
+        rrd_next_to_clean = (uint32_t)atomic_read(&adapter->rrd_ring.next_to_clean);
+	//DEBUGOUT1("mailbox update, rfd_next_to_use (%d)", rfd_next_to_use);
+        AT_WRITE_REG(&adapter->hw, REG_MAILBOX,
+                ((rfd_next_to_use & MB_RFD_PROD_INDX_MASK) << MB_RFD_PROD_INDX_SHIFT) |
+                ((rrd_next_to_clean & MB_RRD_CONS_INDX_MASK) << MB_RRD_CONS_INDX_SHIFT) |
+                ((tpd_next_to_use & MB_TPD_PROD_INDX_MASK) << MB_TPD_PROD_INDX_SHIFT) ) ;
+
+        spin_unlock(&adapter->mb_lock);
+    }
+
+
+}
+
+
+static inline uint16_t tpd_avail(struct at_tpd_ring *tpd_ring)
+{
+    uint16_t next_to_clean = (uint16_t)atomic_read(&tpd_ring->next_to_clean);
+    uint16_t next_to_use = (uint16_t)atomic_read(&tpd_ring->next_to_use);
+    return ((next_to_clean > next_to_use) ?
+            next_to_clean - next_to_use - 1 :
+            tpd_ring->count + next_to_clean - next_to_use - 1);
+}
+
+static inline void
+at_update_mailbox(struct at_adapter* adapter)
+{
+    unsigned long flags;
+    uint32_t tpd_next_to_use;
+    uint32_t rfd_next_to_use;
+    uint32_t rrd_next_to_clean;
+
+    spin_lock_irqsave(&adapter->mb_lock, flags);
+
+    tpd_next_to_use = atomic_read(&adapter->tpd_ring.next_to_use);
+    rfd_next_to_use = (uint32_t)atomic_read(&adapter->rfd_ring.next_to_use);
+    rrd_next_to_clean = (uint32_t)atomic_read(&adapter->rrd_ring.next_to_clean);
+
+    AT_WRITE_REG(&adapter->hw, REG_MAILBOX,
+        ((rfd_next_to_use & MB_RFD_PROD_INDX_MASK) << MB_RFD_PROD_INDX_SHIFT) |
+        ((rrd_next_to_clean & MB_RRD_CONS_INDX_MASK) << MB_RRD_CONS_INDX_SHIFT) |
+        ((tpd_next_to_use & MB_TPD_PROD_INDX_MASK) << MB_TPD_PROD_INDX_SHIFT) );
+
+    spin_unlock_irqrestore(&adapter->mb_lock, flags);
+}
+
+static inline int
+at_tso(struct at_adapter *adapter, struct sk_buff *skb, tso_param_t * tso)
+{
+#ifdef NETIF_F_TSO
+    uint8_t ipofst;
+    int err;
+
+    if(skb_shinfo(skb)->tso_size) {
+	    if(skb_header_cloned(skb)) {
+	        err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
+	        if (err)
+	            return err;
+        }
+
+        if(skb->protocol == ntohs(ETH_P_IP)) {
+            skb->nh.iph->tot_len = 0;
+            skb->nh.iph->check = 0;
+            skb->h.th->check = ~csum_tcpudp_magic(skb->nh.iph->saddr,
+                                        skb->nh.iph->daddr,
+                                        0,
+                                        IPPROTO_TCP,
+                                        0);
+            ipofst = skb->nh.raw - skb->data;
+            if (14 != ipofst)  // 802.3 frame
+                tso->eth_type = 1;
+
+            tso->iphl = skb->nh.iph->ihl;
+            tso->tcp_hdrlen = skb->h.th->doff << 2;
+            tso->mss = skb_shinfo(skb)->tso_size;
+            tso->ip_chksum = 1;
+            tso->tcp_chksum = 1;
+            tso->segment = 1;
+            return TRUE;
+        }
+    }
+#endif
+
+    return FALSE;
+}
+
+static inline int
+at_tx_csum(struct at_adapter *adapter, struct sk_buff *skb, csum_param_t* csum)
+{
+    uint8_t css, cso;
+
+    if(skb->ip_summed == CHECKSUM_HW) {
+
+        cso = skb->h.raw - skb->data;
+        css = (skb->h.raw + skb->csum) - skb->data;
+        if(cso&0x1) {
+            AT_ERR("payload offset != even number !\n");
+            return  -1;
+        }
+        csum->payload_offset = cso;
+        csum->xsum_offset = css;
+        csum->custom_chksum = 1;
+	//DEBUGOUT1("hardware chekcsum: css=%d, cso=%d", css, cso);
+
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+static inline void
+at_tx_map(struct at_adapter *adapter, struct sk_buff *skb, boolean_t tcp_seg)
+{
+    struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+    struct at_buffer *buffer_info;
+    uint16_t first_buf_len = skb->len;
+    struct page *page;
+    unsigned long offset;
+
+    uint16_t tpd_next_to_use;
+#ifdef NETIF_F_TSO
+    uint16_t proto_hdr_len;
+#endif
+
+#ifdef MAX_SKB_FRAGS
+    unsigned int nr_frags;
+    unsigned int f;
+    first_buf_len -= skb->data_len;
+    nr_frags = skb_shinfo(skb)->nr_frags;
+#endif//MAX_SKB_FRAGS
+
+
+    tpd_next_to_use = (uint16_t) atomic_read(&tpd_ring->next_to_use);
+
+    buffer_info = &tpd_ring->buffer_info[tpd_next_to_use];
+    if (buffer_info->skb) {
+	    BUG();
+    }
+    buffer_info->skb = NULL;    // put skb in last TPD
+
+#ifdef NETIF_F_TSO
+    if (tcp_seg) {
+        proto_hdr_len = ((skb->h.raw - skb->data) + (skb->h.th->doff << 2));
+        buffer_info->length = proto_hdr_len;
+        page = virt_to_page(skb->data);
+        offset = (unsigned long)skb->data & ~PAGE_MASK;
+        buffer_info->dma =
+                        pci_map_page(adapter->pdev,
+                                     page,
+                                     offset,
+                                     proto_hdr_len,
+                                     PCI_DMA_TODEVICE);
+
+        if(++tpd_next_to_use == tpd_ring->count) tpd_next_to_use = 0;
+
+        if (first_buf_len > proto_hdr_len) {
+        	uint16_t len12 = first_buf_len - proto_hdr_len;
+        	uint16_t i, m = (len12 + MAX_TX_BUF_LEN - 1) / MAX_TX_BUF_LEN;
+        	for (i=0; i < m; i++) {
+        		buffer_info = &tpd_ring->buffer_info[tpd_next_to_use];
+            	buffer_info->skb = NULL;
+            	buffer_info->length =
+            		(MAX_TX_BUF_LEN >= len12) ? MAX_TX_BUF_LEN : len12;
+            	len12 -= buffer_info->length;
+                page = virt_to_page(skb->data+(proto_hdr_len+i*MAX_TX_BUF_LEN));
+            	offset = (unsigned long)(skb->data+(proto_hdr_len+i*MAX_TX_BUF_LEN)) & ~PAGE_MASK;
+               	buffer_info->dma =
+                        pci_map_page(adapter->pdev,
+                                     page,
+                                     offset,
+                                     buffer_info->length,
+                                     PCI_DMA_TODEVICE);
+            	if(++tpd_next_to_use == tpd_ring->count) tpd_next_to_use = 0;
+            }
+        }
+    } else {
+#endif//NETIF_F_TSO
+
+    buffer_info->length = first_buf_len;
+    page = virt_to_page(skb->data);
+    offset = (unsigned long)skb->data & ~PAGE_MASK;
+    buffer_info->dma =
+                    pci_map_page(adapter->pdev,
+                                 page,
+                                 offset,
+                                 first_buf_len,
+                                 PCI_DMA_TODEVICE);
+    if(++tpd_next_to_use == tpd_ring->count) tpd_next_to_use = 0;
+#ifdef NETIF_F_TSO
+    }
+#endif//NETIF_F_TSO
+
+#ifdef MAX_SKB_FRAGS
+    for(f = 0; f < nr_frags; f++) {
+        struct skb_frag_struct *frag;
+		uint16_t lenf, i, m;
+
+        frag = &skb_shinfo(skb)->frags[f];
+        lenf = frag->size;
+
+		m = (lenf + MAX_TX_BUF_LEN - 1) / MAX_TX_BUF_LEN;
+        for (i=0; i < m; i++) {
+        	buffer_info = &tpd_ring->buffer_info[tpd_next_to_use];
+        	if (buffer_info->skb) {
+		    	BUG();
+	    	}
+            buffer_info->skb = NULL;
+            buffer_info->length =
+            	(lenf > MAX_TX_BUF_LEN) ? MAX_TX_BUF_LEN : lenf;
+            lenf -= buffer_info->length;
+
+			buffer_info->dma =
+                pci_map_page(adapter->pdev,
+                             frag->page,
+                             frag->page_offset+i*MAX_TX_BUF_LEN,
+                             buffer_info->length,
+                             PCI_DMA_TODEVICE);
+
+            if(++tpd_next_to_use == tpd_ring->count) tpd_next_to_use = 0;
+        }
+    }
+#endif//MAX_SKB_FRAGS
+
+    // last tpd's buffer-info
+    buffer_info->skb = skb;
+}
+
+static inline void
+at_tx_queue(struct at_adapter *adapter, int count, tpd_descr_t * descr)
+{
+    struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+    int j;
+    struct at_buffer * buffer_info;
+    tx_packet_desc_t* tpd;
+    uint16_t tpd_next_to_use = (uint16_t)atomic_read(&tpd_ring->next_to_use);
+
+   // DEBUGOUT1("<at_tx_quue> count=%d, tpd_desc=%llx", count, descr->data);
+
+    for(j=0; j<count; j++) {
+        buffer_info = &tpd_ring->buffer_info[tpd_next_to_use];
+        tpd = AT_TPD_DESC(&adapter->tpd_ring, tpd_next_to_use);
+        tpd->buffer_addr = cpu_to_le64(buffer_info->dma);
+        tpd->desc.data = descr->data;
+        tpd->desc.csum.buf_len = cpu_to_le16(buffer_info->length);
+       /*
+	DEBUGOUT1("<at_tx_quue> TPD_NEXT_TO_USE: %d buf_len=%d",
+			tpd_next_to_use,
+			buffer_info->length);
+      	*/
+#ifdef NETIF_F_TSO
+        if ((descr->tso.segment)&& (0==j))
+            tpd->desc.tso.hdr_flg = 1;
+#endif//NETIF_F_TSO
+
+        if (j==(count-1))
+            tpd->desc.csum.eop = 1;
+
+        if(++tpd_next_to_use == tpd_ring->count) tpd_next_to_use = 0;
+    }
+
+    /* Force memory writes to complete before letting h/w
+     * know there are new descriptors to fetch.  (Only
+     * applicable for weak-ordered memory model archs,
+     * such as IA-64). */
+    wmb();
+
+    atomic_set(&tpd_ring->next_to_use, (int)tpd_next_to_use);
+}
+
+
+static int
+at_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
+{
+    struct at_adapter *adapter = netdev_priv(netdev);
+    unsigned int len = skb->len;
+    unsigned long flags;
+    unsigned int nr_frags = 0;
+    int tso;
+    int count = 1;
+    tpd_descr_t param;
+
+#ifdef NETIF_F_TSO
+    unsigned int mss = 0;
+#endif
+#ifdef MAX_SKB_FRAGS
+	unsigned int f;
+	len -= skb->data_len;
+#endif
+
+    //DEBUGFUNC("at_xmit_frame");
+
+    if(skb->len <= 0) {
+        dev_kfree_skb_any(skb);
+        return NETDEV_TX_OK;
+    }
+
+    param.data = 0;
+
+#ifdef MAX_SKB_FRAGS
+    nr_frags = skb_shinfo(skb)->nr_frags;
+    for(f = 0; f < nr_frags; f++) {
+    	uint16_t fg_size = skb_shinfo(skb)->frags[f].size;
+        if (fg_size) {
+        	count += (fg_size + MAX_TX_BUF_LEN - 1) / MAX_TX_BUF_LEN;
+        }
+    }
+#endif//MAX_SKB_FRAGS
+
+#ifdef NETIF_F_TSO
+    mss = skb_shinfo(skb)->tso_size;
+
+    // first buffer must be large(or equal) than protocol header length.
+    if(mss) {
+        unsigned int proto_hdr_len;
+        if(skb->protocol == ntohs(ETH_P_IP)) {
+            proto_hdr_len = ((skb->h.raw - skb->data) + (skb->h.th->doff << 2));
+            if (proto_hdr_len > len) {
+                printk(KERN_INFO "protocol header length = 0x%x, buffer header length = 0x%x\n",
+                    proto_hdr_len, len);
+                dev_kfree_skb_any(skb);
+		        return NETDEV_TX_OK;
+            }
+            // need additional TPD ?
+            if (proto_hdr_len != len) {
+            	count += (len - proto_hdr_len + MAX_TX_BUF_LEN - 1) / MAX_TX_BUF_LEN;
+            }
+        }
+    }
+#endif//NETIF_F_TSO
+#ifdef NETIF_F_LLTX
+	local_irq_save(flags);
+	if(!spin_trylock(&adapter->tx_lock)) {
+		/* Collision - tell upper layer to requeue */
+		local_irq_restore(flags);
+		return NETDEV_TX_LOCKED;
+	}
+#else
+	spin_lock_irqsave(&adapter->tx_lock, flags);
+#endif
+    if(tpd_avail(&adapter->tpd_ring) < count) {
+        // no enough descriptor
+        netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&adapter->tx_lock, flags);
+		return NETDEV_TX_BUSY;
+    }
+
+#ifndef NETIF_F_LLTX
+	spin_unlock_irqrestore(&adapter->tx_lock, flags);
+#endif
+
+    param.data = 0;
+
+#ifdef NETIF_F_HW_VLAN_TX
+	if(adapter->vlgrp && vlan_tx_tag_present(skb)) {
+            uint16_t vlan_tag = vlan_tx_tag_get(skb);
+            vlan_tag = (vlan_tag << 4)          |
+                       (vlan_tag >> 13)         |
+                       ((vlan_tag >>9) & 0x8)   ;
+	    param.csum.ins_vlag = 1;
+	    param.csum.valan_tag = vlan_tag;
+            DEBUGOUT1("TX VLAN TAG<TPD>=%04x", vlan_tag);
+	}
+#endif
+
+    tso = at_tso(adapter, skb, &param.tso);
+    if (tso < 0) {
+#ifdef NETIF_F_LLTX
+       spin_unlock_irqrestore(&adapter->tx_lock, flags);
+#endif
+       dev_kfree_skb_any(skb);
+	    return NETDEV_TX_OK;
+	}
+
+	if (!tso) {
+	    if (at_tx_csum(adapter, skb, &param.csum) < 0) {
+	        spin_unlock_irqrestore(&adapter->tx_lock, flags);
+            dev_kfree_skb_any(skb);
+	        return NETDEV_TX_OK;
+	    }
+    }
+
+    at_tx_map(adapter, skb, 1==param.csum.segment);
+    at_tx_queue(adapter, count, &param);
+
+    netdev->trans_start = jiffies;
+
+#ifdef NETIF_F_LLTX
+	spin_unlock_irqrestore(&adapter->tx_lock, flags);
+#endif
+
+    // update mailbox
+    at_update_mailbox(adapter);
+
+
+    return NETDEV_TX_OK;
+}
+
+
+
+
+static void at_inc_smb(struct at_adapter * adapter)
+{
+    stats_msg_block_t* smb = adapter->smb.smb;
+
+    /* Fill out the OS statistics structure */
+    adapter->soft_stats.rx_packets          += smb->rx_ok;
+    adapter->soft_stats.tx_packets          += smb->tx_ok;
+    adapter->soft_stats.rx_bytes            += smb->rx_byte_cnt;
+    adapter->soft_stats.tx_bytes            += smb->tx_byte_cnt;
+    adapter->soft_stats.multicast           += smb->rx_mcast;
+    adapter->soft_stats.collisions          += (smb->tx_1_col +
+                                                smb->tx_2_col*2 +
+                                                smb->tx_late_col +
+                                                smb->tx_abort_col * adapter->hw.max_retry);
+
+    /* Rx Errors */
+
+    adapter->soft_stats.rx_errors           += (smb->rx_frag +
+                                                smb->rx_fcs_err +
+                                                smb->rx_len_err +
+                                                smb->rx_sz_ov +
+                                                smb->rx_rxf_ov +
+                                                smb->rx_rrd_ov +
+                                                smb->rx_align_err );
+    adapter->soft_stats.rx_fifo_errors      += smb->rx_rxf_ov;
+    adapter->soft_stats.rx_length_errors    += smb->rx_len_err;
+    adapter->soft_stats.rx_crc_errors       += smb->rx_fcs_err;
+    adapter->soft_stats.rx_frame_errors     += smb->rx_align_err;
+    adapter->soft_stats.rx_missed_errors    += (smb->rx_rrd_ov +
+                                                smb->rx_rxf_ov);
+
+    adapter->soft_stats.rx_pause            += smb->rx_pause;
+    adapter->soft_stats.rx_rrd_ov           += smb->rx_rrd_ov;
+    adapter->soft_stats.rx_trunc            += smb->rx_sz_ov;
+
+    /* Tx Errors */
+
+    adapter->soft_stats.tx_errors           += (smb->tx_late_col +
+                                                smb->tx_abort_col +
+                                                smb->tx_underrun +
+                                                smb->tx_trunc );
+    adapter->soft_stats.tx_fifo_errors      += smb->tx_underrun;
+    adapter->soft_stats.tx_aborted_errors   += smb->tx_abort_col;
+    adapter->soft_stats.tx_window_errors    += smb->tx_late_col;
+
+    adapter->soft_stats.excecol             += smb->tx_abort_col;
+    adapter->soft_stats.deffer              += smb->tx_defer;
+    adapter->soft_stats.scc                 += smb->tx_1_col;
+    adapter->soft_stats.mcc                 += smb->tx_2_col;
+    adapter->soft_stats.latecol             += smb->tx_late_col;
+    adapter->soft_stats.tx_underun          += smb->tx_underrun;
+    adapter->soft_stats.tx_trunc            += smb->tx_trunc;
+    adapter->soft_stats.tx_pause            += smb->tx_pause;
+
+
+    // finally
+
+    adapter->net_stats.rx_packets           = adapter->soft_stats.rx_packets;
+    adapter->net_stats.tx_packets           = adapter->soft_stats.tx_packets;
+    adapter->net_stats.rx_bytes             = adapter->soft_stats.rx_bytes;
+    adapter->net_stats.tx_bytes             = adapter->soft_stats.tx_bytes;
+    adapter->net_stats.multicast            = adapter->soft_stats.multicast;
+    adapter->net_stats.collisions           = adapter->soft_stats.collisions;
+    adapter->net_stats.rx_errors            = adapter->soft_stats.rx_errors;
+    adapter->net_stats.rx_over_errors       = adapter->soft_stats.rx_missed_errors;
+    adapter->net_stats.rx_length_errors     = adapter->soft_stats.rx_length_errors;
+    adapter->net_stats.rx_crc_errors        = adapter->soft_stats.rx_crc_errors;
+    adapter->net_stats.rx_frame_errors      = adapter->soft_stats.rx_frame_errors;
+    adapter->net_stats.rx_fifo_errors       = adapter->soft_stats.rx_fifo_errors;
+    adapter->net_stats.rx_missed_errors     = adapter->soft_stats.rx_missed_errors;
+    adapter->net_stats.tx_errors            = adapter->soft_stats.tx_errors;
+    adapter->net_stats.tx_fifo_errors       = adapter->soft_stats.tx_fifo_errors;
+    adapter->net_stats.tx_aborted_errors    = adapter->soft_stats.tx_aborted_errors;
+    adapter->net_stats.tx_window_errors     = adapter->soft_stats.tx_window_errors;
+    adapter->net_stats.tx_carrier_errors    = adapter->soft_stats.tx_carrier_errors;
+}
+
+
+
+/**
+ * at_phy_config - Timer Call-back
+ * @data: pointer to netdev cast into an unsigned long
+ **/
+
+static void
+at_phy_config(unsigned long data)
+{
+    struct at_adapter *adapter = (struct at_adapter *) data;
+    struct at_hw *hw = &adapter->hw;
+    unsigned long flags;
+
+    DEBUGFUNC("at_phy_reconfig!");
+
+    spin_lock_irqsave(&adapter->stats_lock, flags);
+    adapter->phy_timer_pending = FALSE;
+    at_write_phy_reg(hw, MII_ADVERTISE, hw->mii_autoneg_adv_reg);
+    at_write_phy_reg(hw, MII_AT001_CR, hw->mii_1000t_ctrl_reg);
+    DEBUGOUT("4&9 registers written");
+    at_write_phy_reg(hw, MII_BMCR, MII_CR_RESET|MII_CR_AUTO_NEG_EN);
+    spin_unlock_irqrestore(&adapter->stats_lock, flags);
+}
+
+
+/**
+ * at_watchdog - Timer Call-back
+ * @data: pointer to netdev cast into an unsigned long
+ **/
+
+static void
+at_watchdog(unsigned long data)
+{
+    struct at_adapter *adapter = (struct at_adapter *) data;
+ //   struct at_hw *hw = &adapter->hw;
+ //   uint16_t phy_data;
+
+   // DEBUGFUNC("at_watchdog!");
+
+    // update LinkStatus
+//    at_read_phy_reg(hw, MII_BMSR, &phy_data);
+
+/*
+    if(netif_queue_stopped(adapter->netdev) &&
+       netif_carrier_ok(adapter->netdev)) {
+
+        //netif_wake_queue(adapter->netdev);
+	DEBUGFUNC("queue stopped !\n");
+    }
+*/
+    /* Reset the timer */
+    mod_timer(&adapter->watchdog_timer, jiffies + 2 * HZ);
+}
+
+
+/**
+ * When ACPI resume on some VIA MotherBoard, the Interrupt Disable bit/0x400
+ * on PCI Command register is disable.
+ * The function enable this bit.
+ * Brackett, 2006/03/15
+ */
+static void at_via_workaround(struct at_adapter * adapter)
+{
+	unsigned long value;
+	value = AT_READ_REGW(&adapter->hw, PCI_COMMAND);
+	if (value & PCI_COMMAND_INTX_DISABLE)
+	{
+		value &= ~PCI_COMMAND_INTX_DISABLE;
+	}
+
+	AT_WRITE_REG(&adapter->hw, PCI_COMMAND, value);
+}
diff -Nurap old/drivers/net/atl1/at_osdep.h new/drivers/net/atl1/at_osdep.h
--- old/drivers/net/atl1/at_osdep.h	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_osdep.h	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,81 @@
+
+#ifndef _ATTANSIC_OS_DEP_H_
+#define _ATTANSIC_OS_DEP_H_
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include "kcompat.h"
+
+#define usec_delay(x)	udelay(x)
+#ifndef msec_delay
+#define msec_delay(x)	do { if(in_interrupt()) { \
+			/* Don't mdelay in interrupt context!*/ \
+				BUG(); \
+			} else { \
+				msleep(x); \
+			}} while(0)
+/* Some workarounds require millisecond delays and are run during interrupt
+ * context.  Most notably, when establishing link, the phy may need tweaking
+ * but cannot process phy register reads/writes faster than millisecond
+ * intervals...and we establish link due to a "link status change" interrupt.
+ */
+#define msec_delay_irq(x) mdelay(x)
+#endif
+
+#define PCI_COMMAND_REGISTER	PCI_COMMAND
+#define CMD_MEM_WRT_INVALIDATE	PCI_COMMAND_INVALIDATE
+
+typedef enum {
+#undef FALSE
+	FALSE = 0,
+#undef TRUE
+	TRUE = 1
+} boolean_t;
+
+
+
+#ifdef DBG
+#define DEBUGOUT(S)		printk(KERN_DEBUG S "\n")
+#define DEBUGOUT1(S, A...)	printk(KERN_DEBUG S "\n", A)
+#else
+#define DEBUGOUT(S)
+#define DEBUGOUT1(S, A...)
+#endif
+
+#define DEBUGFUNC(F) DEBUGOUT(F)
+#define DEBUGOUT2 DEBUGOUT1
+#define DEBUGOUT3 DEBUGOUT2
+#define DEBUGOUT7 DEBUGOUT3
+
+
+#define AT_WRITE_REG(a, reg, value) ( \
+    writel((value), ((a)->hw_addr + reg)))
+
+#define AT_READ_REG(a, reg) ( \
+    readl((a)->hw_addr + reg ))
+
+
+#define AT_WRITE_REGB(a, reg, value) (\
+    writeb((value), ((a)->hw_addr + reg)))
+
+#define AT_READ_REGB(a, reg) (\
+    readb((a)->hw_addr + reg))
+
+#define AT_WRITE_REGW(a, reg, value) (\
+    writew((value), ((a)->hw_addr + reg)))
+
+#define AT_READ_REGW(a, reg) (\
+    readw((a)->hw_addr + reg))
+
+#define AT_WRITE_REG_ARRAY(a, reg, offset, value) ( \
+    writel((value), (((a)->hw_addr + reg) + ((offset) << 2))))
+
+#define AT_READ_REG_ARRAY(a, reg, offset) ( \
+    readl(((a)->hw_addr + reg) + ((offset) << 2)))
+
+
+#endif//_ATTANSIC_OS_DEP_H_
diff -Nurap old/drivers/net/atl1/at_param.c new/drivers/net/atl1/at_param.c
--- old/drivers/net/atl1/at_param.c	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_param.c	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,314 @@
+#include "at.h"
+
+/* This is the only thing that needs to be changed to adjust the
+ * maximum number of ports that the driver can manage.
+ */
+
+#define AT_MAX_NIC 32
+
+#define OPTION_UNSET    -1
+#define OPTION_DISABLED 0
+#define OPTION_ENABLED  1
+
+
+
+ /* All parameters are treated the same, as an integer array of values.
+ * This macro just reduces the need to repeat the same declaration code
+ * over and over (plus this helps to avoid typo bugs).
+ */
+#define AT_PARAM_INIT { [0 ... AT_MAX_NIC] = OPTION_UNSET }
+#ifndef module_param_array
+/* Module Parameters are always initialized to -1, so that the driver
+ * can tell the difference between no user specified value or the
+ * user asking for the default value.
+ * The true default values are loaded in when e1000_check_options is called.
+ *
+ * This is a GCC extension to ANSI C.
+ * See the item "Labeled Elements in Initializers" in the section
+ * "Extensions to the C Language Family" of the GCC documentation.
+ */
+
+#define AT_PARAM(X, desc) \
+	static const int __devinitdata X[AT_MAX_NIC+1] = AT_PARAM_INIT; \
+	MODULE_PARM(X, "1-" __MODULE_STRING(AT_MAX_NIC) "i"); \
+	MODULE_PARM_DESC(X, desc);
+#else
+#define AT_PARAM(X, desc) \
+	static int __devinitdata X[AT_MAX_NIC+1] = AT_PARAM_INIT; \
+	static int num_##X = 0; \
+	module_param_array_named(X, X, int, &num_##X, 0); \
+	MODULE_PARM_DESC(X, desc);
+#endif
+
+/* Transmit Descriptor Count
+ *
+ * Valid Range: 64-2048
+ *
+ * Default Value: 128
+ */
+
+AT_PARAM(TxDescriptors, "Number of transmit descriptors");
+
+/* Receive Descriptor Count
+ *
+ * Valid Range: 64-4096
+ *
+ * Default Value: 256
+ */
+
+AT_PARAM(RxDescriptors, "Number of receive descriptors");
+
+/* User Specified MediaType Override
+ *
+ * Valid Range: 0-5
+ *  - 0    - auto-negotiate at all supported speeds
+ *  - 1    - only link at 1000Mbps Full Duplex
+ *  - 2    - only link at 100Mbps Full Duplex
+ *  - 3    - only link at 100Mbps Half Duplex
+ *  - 4    - only link at 10Mbps Full Duplex
+ *  - 5    - only link at 10Mbps Half Duplex
+ * Default Value: 0
+ */
+
+AT_PARAM(MediaType, "MediaType Select");
+
+/* Interrupt Moderate Timer in units of 2 us
+ *
+ * Valid Range: 10-65535
+ *
+ * Default Value: 45000(90ms)
+ */
+
+AT_PARAM(IntModTimer, "Interrupt Moderator Timer");
+
+
+
+/* FlashVendor
+ * Valid Range: 0-2
+ * 0 - Atmel
+ * 1 - SST
+ * 2 - ST
+ */
+
+AT_PARAM(FlashVendor, "SPI Flash Vendor");
+
+
+
+#define AUTONEG_ADV_DEFAULT  0x2F
+#define AUTONEG_ADV_MASK     0x2F
+#define FLOW_CONTROL_DEFAULT FLOW_CONTROL_FULL
+
+#define DEFAULT_INT_MOD_CNT             100 // 200us
+#define MAX_INT_MOD_CNT                 65000
+#define MIN_INT_MOD_CNT                 50
+
+#define FLASH_VENDOR_DEFAULT    0
+#define FLASH_VENDOR_MIN        0
+#define FLASH_VENDOR_MAX        2
+
+
+struct at_option {
+	enum { enable_option, range_option, list_option } type;
+	char *name;
+	char *err;
+	int  def;
+	union {
+		struct { /* range_option info */
+			int min;
+			int max;
+		} r;
+		struct { /* list_option info */
+			int nr;
+			struct at_opt_list { int i; char *str; } *p;
+		} l;
+	} arg;
+};
+
+static int __devinit
+at_validate_option(int *value, struct at_option *opt)
+{
+	if(*value == OPTION_UNSET) {
+		*value = opt->def;
+		return 0;
+	}
+
+	switch (opt->type) {
+	case enable_option:
+		switch (*value) {
+		case OPTION_ENABLED:
+			printk(KERN_INFO "%s Enabled\n", opt->name);
+			return 0;
+		case OPTION_DISABLED:
+			printk(KERN_INFO "%s Disabled\n", opt->name);
+			return 0;
+		}
+		break;
+	case range_option:
+		if(*value >= opt->arg.r.min && *value <= opt->arg.r.max) {
+			printk(KERN_INFO "%s set to %i\n", opt->name, *value);
+			return 0;
+		}
+		break;
+	case list_option: {
+		int i;
+		struct at_opt_list *ent;
+
+		for(i = 0; i < opt->arg.l.nr; i++) {
+			ent = &opt->arg.l.p[i];
+			if(*value == ent->i) {
+				if(ent->str[0] != '\0')
+					printk(KERN_INFO "%s\n", ent->str);
+				return 0;
+			}
+		}
+	}
+		break;
+	default:
+		BUG();
+	}
+
+	printk(KERN_INFO "Invalid %s specified (%i) %s\n",
+	       opt->name, *value, opt->err);
+	*value = opt->def;
+	return -1;
+}
+
+/**
+ * at_check_options - Range Checking for Command Line Parameters
+ * @adapter: board private structure
+ *
+ * This routine checks all command line parameters for valid user
+ * input.  If an invalid value is given, or if no user specified
+ * value exists, a default value is used.  The final value is stored
+ * in a variable in the adapter structure.
+ **/
+
+void __devinit
+at_check_options(struct at_adapter *adapter)
+{
+	int bd = adapter->bd_number;
+	if(bd >= AT_MAX_NIC) {
+		printk(KERN_NOTICE
+		       "Warning: no configuration for board #%i\n", bd);
+		printk(KERN_NOTICE "Using defaults for all values\n");
+#ifndef module_param_array
+		bd = AT_MAX_NIC;
+#endif
+	}
+
+	{ /* Transmit Descriptor Count */
+		struct at_option opt = {
+			.type = range_option,
+			.name = "Transmit Descriptors",
+			.err  = "using default of "
+				__MODULE_STRING(AT_DEFAULT_TPD),
+			.def  = AT_DEFAULT_TPD,
+			.arg  = { .r = { .min = AT_MIN_TPD, .max = AT_MAX_TPD }}
+		};
+		struct at_tpd_ring *tpd_ring = &adapter->tpd_ring;
+		int val;
+#ifdef module_param_array
+		if(num_TxDescriptors > bd) {
+#endif
+		    val = TxDescriptors[bd];
+		    at_validate_option(&val, &opt);
+		    tpd_ring->count = ((uint16_t) val)&~1;
+#ifdef module_param_array
+		} else {
+			tpd_ring->count = (uint16_t)opt.def;
+		}
+#endif
+	}
+
+	{ /* Receive Descriptor Count */
+		struct at_option opt = {
+			.type = range_option,
+			.name = "Receive Descriptors",
+			.err  = "using default of "
+				__MODULE_STRING(AT_DEFAULT_RFD),
+			.def  = AT_DEFAULT_RFD,
+			.arg  = { .r = { .min = AT_MIN_RFD, .max = AT_MAX_RFD }}
+		};
+		struct at_rfd_ring *rfd_ring = &adapter->rfd_ring;
+        	struct at_rrd_ring * rrd_ring = &adapter->rrd_ring;
+		int val;
+#ifdef module_param_array
+		if(num_RxDescriptors > bd) {
+#endif
+        	val = RxDescriptors[bd];
+		    at_validate_option(&val, &opt);
+		    rrd_ring->count = rfd_ring->count = ((uint16_t)val)&~1; // even number
+#ifdef module_param_array
+		} else {
+			rfd_ring->count = rrd_ring->count = (uint16_t)opt.def;
+		}
+#endif
+	}
+
+	{ /* Interrupt Moderate Timer */
+	    struct at_option opt = {
+	        .type = range_option,
+	        .name = "Interrupt Moderate Timer",
+	        .err  = "using default of " __MODULE_STRING(DEFAULT_INT_MOD_CNT),
+	        .def  = DEFAULT_INT_MOD_CNT,
+	        .arg  = { .r = { .min = MIN_INT_MOD_CNT, .max = MAX_INT_MOD_CNT }}
+	    } ;
+        int val;
+#ifdef module_param_array
+		if(num_IntModTimer > bd) {
+#endif
+        val = IntModTimer[bd];
+	    at_validate_option(&val, &opt);
+            adapter->imt = (uint16_t) val;
+#ifdef module_param_array
+		} else {
+			adapter->imt = (uint16_t)(opt.def);
+		}
+#endif
+	}
+
+	{ /* Flsh Vendor */
+	    struct at_option opt = {
+	        .type = range_option,
+	        .name = "SPI Flash Vendor",
+	        .err  = "using default of " __MODULE_STRING(FLASH_VENDOR_DEFAULT),
+	        .def  = DEFAULT_INT_MOD_CNT,
+	        .arg  = { .r = { .min = FLASH_VENDOR_MIN, .max = FLASH_VENDOR_MAX }}
+	    } ;
+        int val;
+#ifdef module_param_array
+		if(num_FlashVendor > bd) {
+#endif
+        val = FlashVendor[bd];
+	    at_validate_option(&val, &opt);
+        adapter->hw.flash_vendor = (uint8_t) val;
+#ifdef module_param_array
+		} else {
+			adapter->hw.flash_vendor = (uint8_t)(opt.def);
+		}
+#endif
+	}
+
+	{ /* MediaType */
+	    struct at_option opt = {
+	        .type = range_option,
+	        .name = "Speed/Duplex Selection",
+	        .err  = "using default of " __MODULE_STRING(MEDIA_TYPE_AUTO_SENSOR),
+	        .def  = MEDIA_TYPE_AUTO_SENSOR,
+	        .arg  = { .r = { .min = MEDIA_TYPE_AUTO_SENSOR, .max = MEDIA_TYPE_10M_HALF }}
+	    } ;
+        int val;
+#ifdef module_param_array
+		if(num_MediaType > bd) {
+#endif
+        val = MediaType[bd];
+	    at_validate_option(&val, &opt);
+	    adapter->hw.MediaType = (uint16_t) val;
+#ifdef module_param_array
+		} else {
+			adapter->hw.MediaType = (uint16_t)(opt.def);
+		}
+#endif
+	}
+}
+
diff -Nurap old/drivers/net/atl1/at_test.c new/drivers/net/atl1/at_test.c
--- old/drivers/net/atl1/at_test.c	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/at_test.c	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,861 @@
+#include "at.h"
+#ifdef SIOCDEVPRIVATE
+#include "drv_ioctl.h"
+#include <asm/uaccess.h>
+extern int32_t at_up(struct at_adapter* adapter);
+extern void at_down(struct at_adapter* adapter);
+extern void at_reset(struct at_adapter* adapter);
+extern int32_t at_setup_ring_resources(struct at_adapter* adapter);
+extern void at_free_ring_resources(struct at_adapter* adapter);
+
+
+// set rfd buffer size. do not support !
+
+int at_priv_rbs(struct at_adapter* adapter, at_rbs* rbs)
+{
+   	int err;
+        if (rbs->size == adapter->rx_buffer_len)
+            return 0;
+
+	if(netif_running(adapter->netdev)){
+		at_down(adapter);
+                adapter->rx_buffer_len = rbs->size;
+                if ((err = at_up(adapter)))
+                    return err;
+        }
+        adapter->rx_buffer_len = rbs->size;
+        return 0;
+}
+
+// set rfd(rrd) ring size
+int at_priv_tbc(struct at_adapter* adapter, at_tbc* tbc)
+{
+   	int err;
+	struct at_tpd_ring *tpdr = &adapter->tpd_ring;
+	struct at_rrd_ring *rrdr = &adapter->rrd_ring;
+	struct at_rfd_ring *rfdr = &adapter->rfd_ring;
+
+	struct at_tpd_ring tpd_old, tpd_new;
+	struct at_rfd_ring rfd_old, rfd_new;
+	struct at_rrd_ring rrd_old , rrd_new;
+
+
+	tpd_old = adapter->tpd_ring;
+	rfd_old = adapter->rfd_ring;
+	rrd_old = adapter->rrd_ring;
+
+	if(netif_running(adapter->netdev))
+		at_down(adapter);
+
+	rfdr->count = rfd_old.count;
+	rrdr->count = rrd_old.count;
+	tpdr->count = tbc->size;
+
+	if(netif_running(adapter->netdev)) {
+	    /* try to get new resources before deleting old */
+	    if ((err = at_setup_ring_resources(adapter)))
+	        goto err_tbc;
+
+
+		/* save the new, restore the old in order to free it,
+		 * then restore the new back again */
+
+		rfd_new = adapter->rfd_ring;
+		rrd_new = adapter->rrd_ring;
+		tpd_new = adapter->tpd_ring;
+		adapter->rfd_ring = rfd_old;
+		adapter->rrd_ring = rrd_old;
+		adapter->tpd_ring = tpd_old;
+		at_free_ring_resources(adapter);
+        adapter->rfd_ring = rfd_new;
+		adapter->rrd_ring = rrd_new;
+		adapter->tpd_ring = tpd_new;
+
+		if((err = at_up(adapter)))
+			return err;
+	}
+	return 0;
+
+err_tbc:
+	adapter->rfd_ring = rfd_old;
+	adapter->rrd_ring = rrd_old;
+	adapter->tpd_ring = tpd_old;
+	at_up(adapter);
+	return err;
+}
+
+// set rfd(rrd)  ring size
+int at_priv_rbc(struct at_adapter* adapter, at_rbc* rbc)
+{
+   	int err;
+	struct at_tpd_ring *tpdr = &adapter->tpd_ring;
+	struct at_rrd_ring *rrdr = &adapter->rrd_ring;
+	struct at_rfd_ring *rfdr = &adapter->rfd_ring;
+
+	struct at_tpd_ring tpd_old, tpd_new;
+	struct at_rfd_ring rfd_old, rfd_new;
+	struct at_rrd_ring rrd_old , rrd_new;
+	tpd_old = adapter->tpd_ring;
+	rfd_old = adapter->rfd_ring;
+	rrd_old = adapter->rrd_ring;
+
+	if(netif_running(adapter->netdev))
+		at_down(adapter);
+
+	rfdr->count = rbc->size;
+	rrdr->count = rfdr->count;
+	tpdr->count = tpd_old.count;
+
+	if(netif_running(adapter->netdev)) {
+		/* try to get new resources before deleting old */
+	    if ((err = at_setup_ring_resources(adapter)))
+	        goto err_rbc;
+
+
+		/* save the new, restore the old in order to free it,
+		 * then restore the new back again */
+
+		rfd_new = adapter->rfd_ring;
+		rrd_new = adapter->rrd_ring;
+		tpd_new = adapter->tpd_ring;
+		adapter->rfd_ring = rfd_old;
+		adapter->rrd_ring = rrd_old;
+		adapter->tpd_ring = tpd_old;
+		at_free_ring_resources(adapter);
+        adapter->rfd_ring = rfd_new;
+		adapter->rrd_ring = rrd_new;
+		adapter->tpd_ring = tpd_new;
+
+		if((err = at_up(adapter)))
+			return err;
+	}
+	return 0;
+
+err_rbc:
+	adapter->rfd_ring = rfd_old;
+	adapter->rrd_ring = rrd_old;
+	adapter->tpd_ring = tpd_old;
+	at_up(adapter);
+	return err;
+}
+
+static int
+at_priv_sram_tpd(struct at_adapter* adapter, at_sram_tpd* drvtpd, void* usraddr)
+{
+    uint32_t    src, header, len;
+    uint32_t    i,size;
+    uint32_t*   buffer;
+    at_sram_tpd* p;
+
+    header = AT_READ_REG(&adapter->hw, REG_SRAM_TPD_ADDR);
+    if (header == 0xffffffff) {
+        return -EFAULT;
+    }
+    header &= 0xffff;
+    len = AT_READ_REG(&adapter->hw, REG_SRAM_TPD_LEN);
+    len = (len*8) / sizeof(tx_packet_desc_t); // number of TPD
+
+    if ((drvtpd->idx_start > len)||
+        (drvtpd->length > len)) {
+        return -EINVAL;
+    }
+    size = drvtpd->length*sizeof(tx_packet_desc_t) + sizeof(*drvtpd);
+
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint32_t*) p->data;
+    memcpy(p, drvtpd, sizeof(*p));
+
+    src = 0x8000 + (header*8 + drvtpd->idx_start*sizeof(tx_packet_desc_t));
+
+    for (i = 0; i < (drvtpd->length*sizeof(tx_packet_desc_t))/4; i++) {
+        *(buffer+i) = AT_READ_REG(&adapter->hw, src);
+        src += 4;
+    }
+    if (copy_to_user(usraddr, p, size))
+    {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+
+static int
+at_priv_sram_rfd(struct at_adapter* adapter, at_sram_rfd* drvrfd, void* usraddr)
+{
+    uint32_t    src, header, len;
+    uint32_t    i,size;
+    uint32_t*   buffer;
+    at_sram_rfd* p;
+
+    header = AT_READ_REG(&adapter->hw, REG_SRAM_RFD_ADDR);
+    if (header == 0xffffffff) {
+        return -EFAULT;
+    }
+    header &= 0xffff;
+    len = AT_READ_REG(&adapter->hw, REG_SRAM_RFD_LEN);
+    len = (len*8) / sizeof(rx_free_desc_t); // number of RFD
+
+    if ((drvrfd->idx_start > len)||
+        (drvrfd->length > len)) {
+        return -EFAULT;
+    }
+    size = drvrfd->length*sizeof(rx_free_desc_t) + sizeof(*drvrfd);
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint32_t*) p->data;
+    memcpy(p, drvrfd, sizeof(*p));
+
+    src = 0x8000 + (header*8 + drvrfd->idx_start*sizeof(rx_free_desc_t));
+
+    for (i = 0; i < (drvrfd->length*sizeof(rx_free_desc_t))/4; i++) {
+        *(buffer+i) = AT_READ_REG(&adapter->hw, src);
+        src += 4;
+    }
+    if (copy_to_user(usraddr, p, size))
+    {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+static int
+at_priv_sram_rrd(struct at_adapter* adapter, at_sram_rrd* drvrrd, void* usraddr)
+{
+    uint32_t    src, header, len;
+    uint32_t    i;
+    uint32_t*   buffer;
+    uint32_t    size;
+    at_sram_rrd* p;
+
+    header = AT_READ_REG(&adapter->hw, REG_SRAM_RRD_ADDR);
+    if (header == 0xffffffff) {
+        return -EFAULT;
+    }
+    header &= 0xffff;
+    len = AT_READ_REG(&adapter->hw, REG_SRAM_RRD_LEN);
+    len = (len*8) / sizeof(rx_return_desc_t); // number of TPD
+
+    if ((drvrrd->idx_start > len)||
+        (drvrrd->length > len)) {
+        return -EINVAL;
+    }
+    size = drvrrd->length*sizeof(rx_return_desc_t)+sizeof(*drvrrd);
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint32_t*)p->data;
+    memcpy(p, drvrrd,sizeof(*p));
+
+    src = 0x8000 + (header*8 + drvrrd->idx_start*sizeof(rx_return_desc_t));
+
+    for (i = 0; i < (drvrrd->length*sizeof(rx_return_desc_t))/4; i++) {
+        *(buffer+i) = AT_READ_REG(&adapter->hw, src);
+        src += 4;
+    }
+    if (copy_to_user(usraddr, p, size))
+    {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+static int
+at_priv_sram_trd(struct at_adapter* adapter, at_sram_trd* drvtrd, void* usraddr)
+{
+    uint32_t    src, header, len;
+    uint32_t    i,size;
+    uint32_t*   buffer;
+    at_sram_trd* p;
+
+    header = AT_READ_REG(&adapter->hw, REG_SRAM_TRD_ADDR);
+    if (header == 0xffffffff) {
+        return -EFAULT;
+    }
+    header &= 0xffff;
+    len = AT_READ_REG(&adapter->hw, REG_SRAM_TRD_LEN);
+    len = (len*8) / 8; // number of TRD
+
+    if ((drvtrd->idx_start > len)||
+        (drvtrd->length > len)) {
+        return -EINVAL;
+    }
+    size = drvtrd->length*8 + sizeof(*drvtrd);
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint32_t*) p->data;
+    memcpy(p, drvtrd, sizeof(*p));
+
+    src = 0x8000 + (header*8 + drvtrd->idx_start*8);
+
+    for (i = 0; i < (drvtrd->length*8)/4; i++) {
+        *(buffer+i) = AT_READ_REG(&adapter->hw, src);
+        src += 4;
+    }
+    if (copy_to_user(usraddr, p, size))
+    {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+static int
+at_priv_sram_txf(struct at_adapter* adapter, at_sram_txf* drvtxf, void* usraddr)
+{
+    uint32_t    src, header, len;
+    uint32_t    i;
+    uint32_t*   buffer;
+    at_sram_txf*   p;
+
+    header = AT_READ_REG(&adapter->hw, REG_SRAM_TXF_ADDR);
+    if (header == 0xffffffff) {
+        return -EFAULT;
+    }
+    header &= 0xffff;
+    len = AT_READ_REG(&adapter->hw, REG_SRAM_TXF_LEN);
+    len *= 2; // number of DWORDs
+
+    if (drvtxf->length > len) {
+        return -EINVAL;
+    }
+
+    p = kmalloc(sizeof(*drvtxf) + drvtxf->length*4, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint32_t*)&(p->data);
+    memcpy(p, drvtxf, sizeof(*p));
+
+    src = 0x8000 + header*8;
+
+    for (i = 0; i < drvtxf->length; i++) {
+        *(buffer+i) = AT_READ_REG(&adapter->hw, src);
+        src += 4;
+    }
+    if (copy_to_user(usraddr, p, sizeof(*drvtxf)+drvtxf->length*4))
+    {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+static int
+at_priv_drv_smb(struct at_adapter* adapter, at_drv_smb* drvsmb, void* usraddr)
+{
+     at_drv_smb* newsmb;
+
+     newsmb = kmalloc(sizeof(*drvsmb)+drvsmb->length, GFP_KERNEL);
+     if (!newsmb)
+     {
+         return -ENOMEM;
+     }
+     memcpy(newsmb, drvsmb, sizeof(*drvsmb));
+     if (newsmb->length > 0)
+     {
+         int length = newsmb->length;
+         if (length > sizeof(adapter->smb))
+         {
+              length = sizeof(adapter->smb);
+         }
+         memcpy(newsmb->data, &adapter->smb, length);
+         if(copy_to_user(usraddr, newsmb, sizeof(*newsmb)+newsmb->length))
+         {
+             kfree(newsmb);
+             return -EFAULT;
+         }
+      }
+      kfree(newsmb);
+      return 0;
+}
+
+static int
+at_priv_sram_rxf(struct at_adapter* adapter, at_sram_rxf* drvrxf, void* usraddr)
+{
+    uint32_t    src, header, len;
+    uint32_t    i;
+    uint32_t*   buffer;
+    at_sram_rxf* p;
+
+    header = AT_READ_REG(&adapter->hw, REG_SRAM_RXF_ADDR);
+    if (header == 0xffffffff) {
+        return -EFAULT;
+    }
+    header &= 0xffff;
+    len = AT_READ_REG(&adapter->hw, REG_SRAM_RXF_LEN);
+    len *= 2;// number of DWORDs
+
+    if (drvrxf->length > len) {
+        return -EINVAL;
+    }
+
+    p = kmalloc(sizeof(*drvrxf)+drvrxf->length*4, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    memcpy(p, drvrxf, sizeof(*p));
+    buffer = (uint32_t*)(p->data);
+
+    src = 0x8000 + header*8;
+
+    for (i = 0; i < drvrxf->length; i++) {
+        *(buffer+i) = AT_READ_REG(&adapter->hw, src);
+        src += 4;
+    }
+    if (copy_to_user(usraddr, p, sizeof(*p)+drvrxf->length*4))
+    {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+
+// read tpd from driver allocated memory
+static int at_priv_drv_tpd(struct at_adapter* adapter, at_drv_tpd* drvtpd, void* usraddr)
+{
+    struct at_tpd_ring* tpd_ring = &adapter->tpd_ring;
+    uint16_t i, index;
+    uint8_t* buffer;
+    tx_packet_desc_t * tpd;
+    uint32_t size;
+    at_drv_tpd* p;
+
+    if (drvtpd->length > tpd_ring->count ||
+        drvtpd->idx_start >= tpd_ring->count) {
+        return -EINVAL;
+    }
+    index = drvtpd->idx_start;
+    size = drvtpd->length*sizeof(tx_packet_desc_t)+sizeof(*drvtpd);
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint8_t*) p->data;
+    memcpy(p, drvtpd, sizeof(*p));
+
+    for (i=0; i<drvtpd->length; i++) {
+        tpd = AT_TPD_DESC(tpd_ring, index);
+        memcpy(buffer+i*sizeof(tx_packet_desc_t), tpd, sizeof(tx_packet_desc_t));
+        index++;
+        index = index % tpd_ring->count;
+    }
+    if (copy_to_user(usraddr, p, size)) {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+// read rfd from driver allocated memory
+
+static int at_priv_drv_rfd(struct at_adapter* adapter, at_drv_rfd* drvrfd, void* usraddr)
+{
+    struct at_rfd_ring* rfd_ring = &adapter->rfd_ring;
+    uint16_t i, index = drvrfd->idx_start % rfd_ring->count;
+    uint8_t* buffer;
+    rx_free_desc_t* rfd;
+    uint32_t size;
+    at_drv_rfd* p;
+
+    if (drvrfd->length > rfd_ring->count) {
+        return -EINVAL;
+    }
+    size = drvrfd->length*sizeof(rx_free_desc_t) + sizeof(*drvrfd);
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint8_t*) p->data;
+    memcpy(p, drvrfd, sizeof(*p));
+
+    for (i=0; i<drvrfd->length; i++) {
+        rfd = AT_RFD_DESC(rfd_ring, index);
+        memcpy(buffer+i*sizeof(rx_free_desc_t), rfd, sizeof(rx_free_desc_t));
+        index++;
+        index = index % rfd_ring->count;
+    }
+    if (copy_to_user(usraddr, p, size)) {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+// read rrd from driver allocated memory
+
+static int at_priv_drv_rrd(struct at_adapter* adapter, at_drv_rrd* drvrrd, void* usraddr)
+{
+    struct at_rrd_ring* rrd_ring = &adapter->rrd_ring;
+    uint16_t i, index = drvrrd->idx_start % rrd_ring->count;
+    uint8_t* buffer;
+    rx_return_desc_t* rrd;
+    uint32_t size;
+    at_drv_rrd* p;
+
+    if (drvrrd->length > rrd_ring->count) {
+        return -EINVAL;
+    }
+
+    size = drvrrd->length * sizeof(rx_return_desc_t) + sizeof(*drvrrd);
+    p = kmalloc(size, GFP_KERNEL);
+    if (!p) {
+        return -ENOMEM;
+    }
+    buffer = (uint8_t*) p->data;
+    memcpy(p, drvrrd, sizeof(*p));
+
+    for (i=0; i<drvrrd->length; i++) {
+        rrd = AT_RRD_DESC(rrd_ring, index);
+        memcpy(buffer+i*sizeof(rx_return_desc_t), rrd, sizeof(rx_return_desc_t));
+        index++;
+        index = index % rrd_ring->count;
+    }
+    if (copy_to_user(usraddr, p, size)) {
+        kfree(p);
+        return -EFAULT;
+    }
+    kfree(p);
+    return 0;
+}
+
+static int
+at_priv_dump_regs(struct at_adapter* adapter, at_dump_regs* regs, void* usraddr)
+{
+    at_dump_regs* new_regs;
+    uint32_t i;
+
+
+    new_regs = kmalloc(sizeof(*regs)+regs->length*4, GFP_KERNEL);
+    if (!new_regs) {
+        return -ENOMEM;
+    }
+    new_regs->length = regs->length;
+    new_regs->start = regs->start;
+    new_regs->cmd = LNX_CMD_DUMP_REGS;
+
+    for (i =0; i < regs->length; i++) {
+        ((uint32_t*)new_regs->data)[i] =
+            AT_READ_REG(&adapter->hw, (4*i+regs->start));
+    }
+
+    if (copy_to_user(usraddr, new_regs, sizeof(*new_regs)+regs->length*4)) {
+        kfree(new_regs);
+        return -EFAULT;
+    }
+    kfree(new_regs);
+    return 0;
+}
+
+static int
+at_priv_dump_dregs(struct at_adapter* adapter, at_dump_dregs* regs, void* usraddr)
+{
+    at_dump_dregs* new_regs;
+    uint32_t i;
+
+
+    new_regs = kmalloc(sizeof(*regs)+regs->length*4, GFP_KERNEL);
+    if (!new_regs) {
+        return -ENOMEM;
+    }
+    new_regs->length = regs->length;
+    new_regs->start = regs->start;
+    new_regs->cmd = LNX_CMD_DUMP_DREGS;
+
+    for (i =0; i < regs->length; i++) {
+        AT_WRITE_REG(&adapter->hw, 0x1900, i+regs->start);
+        ((uint32_t*)new_regs->data)[i] =
+            AT_READ_REG(&adapter->hw, 0x1904);
+    }
+
+    if (copy_to_user(usraddr, new_regs, sizeof(*new_regs)+regs->length*4)) {
+        kfree(new_regs);
+        return -EFAULT;
+    }
+    kfree(new_regs);
+    return 0;
+}
+
+int
+at_priv_ioctl(struct net_device* netdev, struct ifreq * ifr)
+{
+    struct  at_adapter *adapter = netdev->priv;
+    void *      addr = ifr->ifr_data;
+    uint16_t    cmd;
+
+    if(get_user(cmd, (uint16_t *) addr))
+	return -EFAULT;
+
+    switch (cmd) {
+    case LNX_CMD_RBS:
+    {
+        at_rbs rbs;
+	if(copy_from_user(&rbs, addr, sizeof(rbs)))
+	    return -EFAULT;
+	return at_priv_rbs(adapter, &rbs);
+    }
+    case LNX_CMD_RBC:
+    {
+        at_rbc rbc;
+        if(copy_from_user(&rbc, addr, sizeof(rbc)))
+            return  -EFAULT;
+        return at_priv_rbc(adapter, &rbc);
+    }
+    case LNX_CMD_TBC:
+    {
+        at_tbc tbc;
+        if(copy_from_user(&tbc, addr, sizeof(tbc)))
+            return -EFAULT;
+        return at_priv_tbc(adapter, &tbc);
+    }
+    case LNX_CMD_DRV_TPD:
+    {
+        at_drv_tpd tpd;
+        if (copy_from_user(&tpd, addr, sizeof(tpd)))
+            return -EFAULT;
+	return at_priv_drv_tpd(adapter, &tpd, addr);
+    }
+    case LNX_CMD_DRV_RFD:
+    {
+        at_drv_rfd rfd;
+        if(copy_from_user(&rfd, addr, sizeof(rfd)))
+            return -EFAULT;
+        return at_priv_drv_rfd(adapter, &rfd, addr);
+    }
+    case LNX_CMD_DRV_RRD:
+    {
+        at_drv_rrd rrd;
+        if(copy_from_user(&rrd, addr, sizeof(rrd)))
+            return -EFAULT;
+        return at_priv_drv_rrd(adapter, &rrd, addr);
+    }
+    case LNX_CMD_SRAM_TPD:
+    {
+        at_sram_tpd tpd;
+        if(copy_from_user(&tpd, addr, sizeof(tpd)))
+            return -EFAULT;
+        return at_priv_sram_tpd(adapter, &tpd, addr);
+    }
+    case LNX_CMD_SRAM_RFD:
+    {
+        at_sram_rfd rfd;
+        if(copy_from_user(&rfd, addr, sizeof(rfd)))
+            return -EFAULT;
+        return at_priv_sram_rfd(adapter, &rfd, addr);
+    }
+    case LNX_CMD_SRAM_RRD:
+    {
+        at_sram_rrd rrd;
+        if(copy_from_user(&rrd, addr, sizeof(rrd)))
+            return -EFAULT;
+        return at_priv_sram_rrd(adapter, &rrd, addr);
+    }
+    case LNX_CMD_SRAM_TRD:
+    {
+        at_sram_trd trd;
+        if(copy_from_user(&trd, addr, sizeof(trd)))
+            return -EFAULT;
+        return at_priv_sram_trd(adapter, &trd, addr);
+    }
+    case LNX_CMD_SRAM_TXF:
+    {
+        at_sram_txf txf;
+        if (copy_from_user(&txf, addr, sizeof(txf)))
+            return -EFAULT;
+        if (txf.length == 0) {
+	    txf.length = (uint16_t)AT_READ_REG(&adapter->hw, REG_SRAM_TXF_LEN);
+            txf.length *= 2; // DWORDs
+	    if (copy_to_user(addr, &txf, sizeof(txf))) {
+	        return -EFAULT;
+	    }
+	    return 0;
+	}
+	return at_priv_sram_txf(adapter, &txf, addr);
+    }
+    case LNX_CMD_SRAM_RXF:
+    {
+        at_sram_rxf rxf;
+	if (copy_from_user(&rxf, addr, sizeof(rxf)))
+	    return -EFAULT;
+        if (rxf.length == 0) {
+            rxf.length = (uint16_t)AT_READ_REG(&adapter->hw, REG_SRAM_RXF_LEN);
+            rxf.length *= 2; // DWORDs
+            if (copy_to_user(addr, &rxf, sizeof(rxf))) {
+                return -EFAULT;
+            }
+            return 0;
+        }
+        return at_priv_sram_rxf(adapter, &rxf, addr);
+    }
+    case LNX_CMD_DRV_SMB:
+    {
+        at_drv_smb drvsmb;
+        if (copy_from_user(&drvsmb, addr, sizeof(drvsmb)))
+            return -EFAULT;
+        return at_priv_drv_smb(adapter, &drvsmb, addr);
+    }
+    case LNX_CMD_DRV_CMB:
+    {
+        at_drv_cmb cmb;
+        if(copy_from_user(&cmb, addr, sizeof(cmb)))
+            return -EFAULT;
+
+        cmb.data[0] = adapter->cmb.cmb->int_stats;
+        cmb.data[1] = adapter->cmb.cmb->rrd_prod_idx;
+        cmb.data[2] = adapter->cmb.cmb->rfd_cons_idx;
+        cmb.data[3] = adapter->cmb.cmb->tpd_cons_idx;
+        if (copy_to_user(addr, &cmb, sizeof(cmb)))
+            return -EFAULT;
+        return 0;
+    }
+    case LNX_CMD_NIC_CMB:
+    {
+        at_sram_cmb cmb;
+	if(copy_from_user(&cmb, addr, sizeof(cmb)))
+	    return -EFAULT;
+	cmb.data[0] = AT_READ_REG(&adapter->hw, REG_RFD_RRD_IDX);
+	cmb.data[1] = AT_READ_REG(&adapter->hw, REG_TPD_IDX);
+	if(copy_to_user(addr, &cmb, sizeof(cmb)))
+	    return -EFAULT;
+	return 0;
+    }
+    case LNX_CMD_DUMP_REGS:
+    {
+	at_dump_regs regs;
+	if(copy_from_user(&regs, addr, sizeof(regs)))
+	    return -EFAULT;
+	return at_priv_dump_regs(adapter, &regs, addr);
+    }
+    case LNX_CMD_WRITE_REG:
+    {
+        at_write_reg wreg;
+        uint32_t    data;
+        if (copy_from_user(&wreg, addr, sizeof(wreg))) {
+            return -EFAULT;
+        }
+        if (0xffffffff != wreg.mask) {
+            data = AT_READ_REG(&adapter->hw, wreg.reg);
+            data = (wreg.data&wreg.mask) | (data&~wreg.mask);
+        } else {
+            data = wreg.data;
+        }
+        AT_WRITE_REG(&adapter->hw, wreg.reg, data);
+        return 0;
+    }
+    //////////////////////////////////// added at 05-06-25
+    case LNX_CMD_READ_BYTE:
+    {
+    	at_read_breg breg;
+    	if(copy_from_user(&breg, addr, sizeof(breg)))
+    		return -EFAULT;
+    	breg.data = AT_READ_REGB(&adapter->hw, breg.reg);
+    	if (copy_to_user(addr, &breg, sizeof(breg)))
+    		return -EFAULT;
+    	return 0;
+    }
+    case LNX_CMD_WRITE_BYTE:
+    {
+    	at_write_breg wbreg;
+
+    	if (copy_from_user(&wbreg, addr, sizeof(wbreg))) {
+    		return -EFAULT;
+    	}
+    	AT_WRITE_REGB(&adapter->hw, wbreg.reg, wbreg.data);
+    	return 0;
+    }
+    case LNX_CMD_READ_PHY:
+    {
+    	at_read_preg preg;
+    	if(copy_from_user(&preg, addr, sizeof(preg)))
+    		return -EFAULT;
+
+    	if (at_read_phy_reg(&adapter->hw,
+            				preg.reg,
+            				&preg.data))
+            return -EFAULT;
+    	if (copy_to_user(addr, &preg, sizeof(preg)))
+    		return -EFAULT;
+    	return 0;
+    }
+    case LNX_CMD_WRITE_PHY:
+    {
+    	at_write_preg preg;
+
+    	if (copy_from_user(&preg, addr, sizeof(preg))) {
+    		return -EFAULT;
+    	}
+    	if (at_write_phy_reg(&adapter->hw,
+							 preg.reg,
+        					 preg.data))
+        	return -EFAULT;
+    	return 0;
+    }
+    ///////////////////////////////////
+
+    case LNX_CMD_DUMP_DREGS:
+    {
+        at_dump_dregs regs;
+        if(copy_from_user(&regs, addr, sizeof(regs)))
+            return -EFAULT;
+        return at_priv_dump_dregs(adapter, &regs, addr);
+    }
+    case LNX_CMD_READ_CFG_REG:
+    {
+        at_read_cfg_reg reg;
+        if(copy_from_user(&reg, addr, sizeof(reg)))
+            return -EFAULT;
+
+        pci_read_config_dword(
+  			adapter->pdev,
+			reg.reg,
+			&reg.data);
+        if(copy_to_user(addr, &reg, sizeof(reg)))
+            return -EFAULT;
+        return 0;
+    }
+    case LNX_CMD_WRITE_CFG_REG:
+    {
+        at_write_cfg_reg reg;
+        uint32_t data;
+        if(copy_from_user(&reg, addr, sizeof(reg)))
+            return  -EFAULT;
+        if (reg.mask == 0xffffffff) {
+            data = reg.data;
+        } else {
+            pci_read_config_dword(
+                adapter->pdev,
+                reg.reg,
+                &data);
+            data = (data&~reg.mask) | (reg.data&reg.mask);
+        }
+	pci_write_config_dword(
+	       adapter->pdev,
+	       reg.reg,
+	       data);
+	return 0;
+    }
+    default:
+        return -EFAULT;
+    }
+}
+
+#endif//SIOCDEVPRIVATE
diff -Nurap old/drivers/net/atl1/drv_ioctl.h new/drivers/net/atl1/drv_ioctl.h
--- old/drivers/net/atl1/drv_ioctl.h	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/drv_ioctl.h	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,109 @@
+#ifndef _ATN_TEST_H___
+#define _ATN_TEST_H___
+
+/* drv specific */
+#define LNX_CMD_RBS             1
+#define LNX_CMD_RBC             2
+#define LNX_CMD_TBC             3
+#define LNX_CMD_DRV_TPD         4
+#define LNX_CMD_DRV_RFD         5
+#define LNX_CMD_DRV_RRD         6
+#define LNX_CMD_SRAM_TPD        7
+#define LNX_CMD_SRAM_RFD        8
+#define LNX_CMD_SRAM_RRD        9
+#define LNX_CMD_SRAM_TRD        10
+#define LNX_CMD_SRAM_RXF        11
+#define LNX_CMD_SRAM_TXF        12
+#define LNX_CMD_DRV_CMB         13
+#define LNX_CMD_NIC_CMB         14
+#define LNX_CMD_DUMP_REGS       15
+#define LNX_CMD_WRITE_REG       16
+#define LNX_CMD_READ_CFG_REG    17
+#define LNX_CMD_WRITE_CFG_REG   18
+#define LNX_CMD_DUMP_DREGS      19
+#define LNX_CMD_DRV_SMB	        20
+//////////////////////////////////// added at 05-06-25
+#define LNX_CMD_READ_BYTE           21
+#define LNX_CMD_READ_PHY            22
+#define LNX_CMD_WRITE_BYTE          23
+#define LNX_CMD_WRITE_PHY           24
+////////////////////////////////////
+
+
+typedef struct at_rbs {
+    u16     cmd;
+    u16     size;
+}at_rbs, at_rbc, at_tbc;
+
+typedef struct at_drv_tpd {
+    u16     cmd;
+    u16     idx_start;
+    u16     length;
+    u8      data[0];
+}at_drv_tpd, at_sram_tpd, at_drv_rfd, at_sram_rfd,
+ at_drv_rrd, at_sram_rrd, at_sram_trd;
+
+typedef struct at_sram_rxf {
+    u16     cmd;
+    u16	    length;
+    u8      data[0];
+}at_sram_rxf, at_sram_txf;
+
+typedef struct at_drv_cmb {
+    u16     cmd;
+    u32     data[4];
+}at_drv_cmb, at_sram_cmb;
+
+typedef struct at_drv_smb {
+    u16     cmd;
+    u16     length;
+    u8      data[0];
+} at_drv_smb;
+
+typedef struct at_dump_regs {
+    u16     cmd;
+    u16     start;
+    u16     length;
+    u8      data[0];
+}at_dump_regs, at_dump_dregs;
+
+typedef struct at_write_reg {
+    u16     cmd;
+    u16     reg;
+    u32     data;
+    u32     mask;
+}at_write_reg, at_write_cfg_reg;
+
+typedef struct at_read_cfg_reg {
+    u16     cmd;
+    u16     reg;
+    u32     data;
+}at_read_cfg_reg;
+
+//////////////////////////////////// added at 05-06-25
+typedef struct at_write_breg {
+    u16     cmd;
+    u16     reg;
+    u8      data;
+}at_write_breg;
+
+typedef struct at_read_breg {
+    u16     cmd;
+    u16     reg;
+    u8      data;
+}at_read_breg;
+
+typedef struct at_write_preg {
+    u16     cmd;
+    u8      reg;
+    u16     data;
+}at_write_preg;
+
+typedef struct at_read_preg {
+    u16     cmd;
+    u8      reg;
+    u16     data;
+}at_read_preg;
+////////////////////////////////////
+
+#endif
diff -Nurap old/drivers/net/atl1/kcompat.c new/drivers/net/atl1/kcompat.c
--- old/drivers/net/atl1/kcompat.c	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/kcompat.c	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,170 @@
+/*******************************************************************************
+
+
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your option)
+  any later version.
+
+  This program is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+#include "kcompat.h"
+
+/*****************************************************************************/
+/* 2.4.13 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+/**************************************/
+/* PCI DMA MAPPING */
+
+#if defined(CONFIG_HIGHMEM)
+
+#ifndef PCI_DRAM_OFFSET
+#define PCI_DRAM_OFFSET 0
+#endif
+
+u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction)
+{
+	return (((u64)(page - mem_map) << PAGE_SHIFT) + offset + PCI_DRAM_OFFSET);
+}
+
+#else /* CONFIG_HIGHMEM */
+
+u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction)
+{
+	return pci_map_single(dev, (void *)page_address(page) + offset, size, direction);
+}
+
+#endif /* CONFIG_HIGHMEM */
+
+void _kc_pci_unmap_page(struct pci_dev *dev, u64 dma_addr, size_t size, int direction)
+{
+	return pci_unmap_single(dev, dma_addr, size, direction);
+}
+
+#endif /* 2.4.13 => 2.4.3 */
+
+
+/*****************************************************************************/
+/* 2.4.3 => 2.4.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+
+/**************************************/
+/* PCI DRIVER API */
+
+int _kc_pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+	if(!pci_dma_supported(dev, mask))
+		return -EIO;
+	dev->dma_mask = mask;
+	return 0;
+}
+
+int _kc_pci_request_regions(struct pci_dev *dev, char *res_name)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		if (pci_resource_len(dev, i) == 0)
+			continue;
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO) {
+			if (!request_region(pci_resource_start(dev, i), pci_resource_len(dev, i), res_name)) {
+				pci_release_regions(dev);
+				return -EBUSY;
+			}
+		} else if (pci_resource_flags(dev, i) & IORESOURCE_MEM) {
+			if (!request_mem_region(pci_resource_start(dev, i), pci_resource_len(dev, i), res_name)) {
+				pci_release_regions(dev);
+				return -EBUSY;
+			}
+		}
+	}
+	return 0;
+}
+
+void _kc_pci_release_regions(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		if (pci_resource_len(dev, i) == 0)
+			continue;
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO)
+			release_region(pci_resource_start(dev, i), pci_resource_len(dev, i));
+
+		else if (pci_resource_flags(dev, i) & IORESOURCE_MEM)
+			release_mem_region(pci_resource_start(dev, i), pci_resource_len(dev, i));
+	}
+}
+
+/**************************************/
+/* NETWORK DRIVER API */
+
+struct net_device * _kc_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *dev;
+	int alloc_size;
+
+	alloc_size = sizeof (*dev) + sizeof_priv + IFNAMSIZ + 31;
+
+	dev = kmalloc(alloc_size, GFP_KERNEL);
+
+	if (!dev) return NULL;
+
+	memset(dev, 0, alloc_size);
+
+	if (sizeof_priv)
+		dev->priv = (void *) (((unsigned long)(dev + 1) + 31) & ~31);
+
+	dev->name[0] = '\0';
+
+	ether_setup(dev);
+
+	return dev;
+}
+
+int _kc_is_valid_ether_addr(u8 *addr)
+{
+	const char zaddr[6] = {0,};
+
+	return !(addr[0]&1) && memcmp( addr, zaddr, 6);
+}
+
+#endif /* 2.4.3 => 2.4.0 */
+
+
+/*****************************************************************************/
+/* 2.4.6 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+
+int _kc_pci_set_power_state(struct pci_dev *dev, int state)
+{ return 0; }
+int _kc_pci_save_state(struct pci_dev *dev, u32 *buffer)
+{ return 0; }
+int _kc_pci_restore_state(struct pci_dev *pdev, u32 *buffer)
+{ return 0; }
+int _kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable)
+{ return 0; }
+
+#endif /* 2.4.6 => 2.4.3 */
+
diff -Nurap old/drivers/net/atl1/kcompat.h new/drivers/net/atl1/kcompat.h
--- old/drivers/net/atl1/kcompat.h	1970-01-01 03:00:00.000000000 +0300
+++ new/drivers/net/atl1/kcompat.h	2007-04-02 14:59:53.000000000 +0400
@@ -0,0 +1,480 @@
+/*******************************************************************************
+
+
+  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your option)
+  any later version.
+
+  This program is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+#ifndef _KCOMPAT_H_
+#define _KCOMPAT_H_
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+#ifndef IRQ_HANDLED
+#define irqreturn_t void
+#define IRQ_HANDLED
+#define IRQ_NONE
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x)	kfree(x)
+#endif
+
+#ifdef HAVE_POLL_CONTROLLER
+#define CONFIG_NET_POLL_CONTROLLER
+#endif
+
+#ifndef module_param
+#define module_param(v,t,p) MODULE_PARM(v, "i");
+#endif
+
+/*****************************************************************************/
+#ifndef unlikely
+#define unlikely(_x) _x
+#define likely(_x) _x
+#endif
+/*****************************************************************************/
+
+#ifndef PCI_DEVICE
+#define PCI_DEVICE(vend,dev) \
+	.vendor = (vend), .device = (dev), \
+	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
+#endif
+
+/*****************************************************************************/
+/* Installations with ethtool version without eeprom, adapter id, or statistics
+ * support */
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS 0x1d
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+	uint32_t cmd;
+	char	 driver[32];
+	char	 version[32];
+	char	 fw_version[32];
+	char	 bus_info[32];
+	char	 reserved1[32];
+	char	 reserved2[16];
+	uint32_t n_stats;
+	uint32_t testinfo_len;
+	uint32_t eedump_len;
+	uint32_t regdump_len;
+};
+
+struct ethtool_stats {
+	uint32_t cmd;
+	uint32_t n_stats;
+	uint64_t data[0];
+};
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS 0x1b
+enum ethtool_stringset {
+	ETH_SS_TEST             = 0,
+	ETH_SS_STATS,
+};
+struct ethtool_gstrings {
+	u32     cmd;            /* ETHTOOL_GSTRINGS */
+	u32     string_set;     /* string set id e.c. ETH_SS_TEST, etc*/
+	u32     len;            /* number of strings in the string set */
+	u8      data[0];
+};
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST 0x1a
+enum ethtool_test_flags {
+	ETH_TEST_FL_OFFLINE	= (1 << 0),
+	ETH_TEST_FL_FAILED	= (1 << 1),
+};
+struct ethtool_test {
+	uint32_t cmd;
+	uint32_t flags;
+	uint32_t reserved;
+	uint32_t len;
+	uint64_t data[0];
+};
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+	uint32_t cmd;
+	uint32_t magic;
+	uint32_t offset;
+	uint32_t len;
+	uint8_t	 data[0];
+};
+
+struct ethtool_value {
+	uint32_t cmd;
+	uint32_t data;
+};
+
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK 0xa
+#endif /* Ethtool version without link support */
+#endif /* Ethtool version without eeprom support */
+#endif /* Ethtool version without test support */
+#endif /* Ethtool version without strings support */
+#endif /* Ethtool version wihtout adapter id support */
+#endif /* Ethtool version without statistics support */
+
+/*****************************************************************************/
+/* 2.4.3 => 2.4.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+
+/**************************************/
+/* PCI DRIVER API */
+
+#ifndef pci_set_dma_mask
+#define pci_set_dma_mask _kc_pci_set_dma_mask
+extern int _kc_pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask);
+#endif
+
+#ifndef pci_request_regions
+#define pci_request_regions _kc_pci_request_regions
+extern int _kc_pci_request_regions(struct pci_dev *pdev, char *res_name);
+#endif
+
+#ifndef pci_release_regions
+#define pci_release_regions _kc_pci_release_regions
+extern void _kc_pci_release_regions(struct pci_dev *pdev);
+#endif
+
+/**************************************/
+/* NETWORK DRIVER API */
+
+#ifndef alloc_etherdev
+#define alloc_etherdev _kc_alloc_etherdev
+extern struct net_device * _kc_alloc_etherdev(int sizeof_priv);
+#endif
+
+#ifndef is_valid_ether_addr
+#define is_valid_ether_addr _kc_is_valid_ether_addr
+extern int _kc_is_valid_ether_addr(u8 *addr);
+#endif
+
+/**************************************/
+/* MISCELLANEOUS */
+
+#ifndef INIT_TQUEUE
+#define INIT_TQUEUE(_tq, _routine, _data)		\
+	do {						\
+		INIT_LIST_HEAD(&(_tq)->list);		\
+		(_tq)->sync = 0;			\
+		(_tq)->routine = _routine;		\
+		(_tq)->data = _data;			\
+	} while(0)
+#endif
+
+#endif /* 2.4.3 => 2.4.0 */
+
+/*****************************************************************************/
+/* 2.4.6 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+
+#ifndef pci_set_power_state
+#define pci_set_power_state _kc_pci_set_power_state
+extern int _kc_pci_set_power_state(struct pci_dev *dev, int state);
+#endif
+
+#ifndef pci_save_state
+#define pci_save_state _kc_pci_save_state
+extern int _kc_pci_save_state(struct pci_dev *dev, u32 *buffer);
+#endif
+
+#ifndef pci_restore_state
+#define pci_restore_state _kc_pci_restore_state
+extern int _kc_pci_restore_state(struct pci_dev *pdev, u32 *buffer);
+#endif
+
+#ifndef pci_enable_wake
+#define pci_enable_wake _kc_pci_enable_wake
+extern int _kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable);
+#endif
+
+/* PCI PM entry point syntax changed, so don't support suspend/resume */
+#undef CONFIG_PM
+
+#endif /* 2.4.6 => 2.4.3 */
+
+/*****************************************************************************/
+/* 2.4.10 => 2.4.6 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10) )
+
+/**************************************/
+/* MODULE API */
+
+#ifndef MODULE_LICENSE
+	#define MODULE_LICENSE(X)
+#endif
+
+/**************************************/
+/* OTHER */
+
+#undef min
+#define min(x,y) ({ \
+	const typeof(x) _x = (x);	\
+	const typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x < _y ? _x : _y; })
+
+#undef max
+#define max(x,y) ({ \
+	const typeof(x) _x = (x);	\
+	const typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x > _y ? _x : _y; })
+
+#endif /* 2.4.10 -> 2.4.6 */
+
+
+/*****************************************************************************/
+/* 2.4.13 => 2.4.10 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+/**************************************/
+/* PCI DMA MAPPING */
+
+#ifndef virt_to_page
+	#define virt_to_page(v) (mem_map + (virt_to_phys(v) >> PAGE_SHIFT))
+#endif
+
+#ifndef pci_map_page
+#define pci_map_page _kc_pci_map_page
+extern u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction);
+#endif
+
+#ifndef pci_unmap_page
+#define pci_unmap_page _kc_pci_unmap_page
+extern void _kc_pci_unmap_page(struct pci_dev *dev, u64 dma_addr, size_t size, int direction);
+#endif
+
+/* pci_set_dma_mask takes dma_addr_t, which is only 32-bits prior to 2.4.13 */
+
+#undef PCI_DMA_32BIT
+#define PCI_DMA_32BIT	0xffffffff
+#undef PCI_DMA_64BIT
+#define PCI_DMA_64BIT	0xffffffff
+
+#endif /* 2.4.13 => 2.4.10 */
+
+/*****************************************************************************/
+/* 2.4.17 => 2.4.12 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,17) )
+
+#ifndef __devexit_p
+	#define __devexit_p(x) &(x)
+#endif
+
+#endif /* 2.4.17 => 2.4.13 */
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22) )
+#define pci_name(x)	((x)->slot_name)
+#endif
+
+/*****************************************************************************/
+/* 2.5.28 => 2.4.22 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28) )
+
+static inline void _kc_synchronize_irq() { synchronize_irq(); }
+#undef synchronize_irq
+#define synchronize_irq(X) _kc_synchronize_irq()
+
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#define INIT_WORK INIT_TQUEUE
+#define schedule_work schedule_task
+
+#endif /* 2.5.28 => 2.4.17 */
+
+
+/*****************************************************************************/
+/* 2.6.0 => 2.5.28 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+#define MODULE_INFO(version, _version)
+#endif /* 2.6.0 => 2.5.28 */
+
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) )
+#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
+#endif /* 2.6.4 => 2.6.0 */
+
+
+/*****************************************************************************/
+/* 2.6.5 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5) )
+#define pci_dma_sync_single_for_cpu	pci_dma_sync_single
+#define pci_dma_sync_single_for_device	pci_dma_sync_single_for_cpu
+#endif /* 2.6.5 => 2.6.0 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,25) || \
+    ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) ) )
+#define ETHTOOL_OPS_COMPAT
+#endif
+
+#ifndef HAVE_NETIF_MSG
+#define HAVE_NETIF_MSG 1
+enum {
+	NETIF_MSG_DRV		= 0x0001,
+	NETIF_MSG_PROBE		= 0x0002,
+	NETIF_MSG_LINK		= 0x0004,
+	NETIF_MSG_TIMER		= 0x0008,
+	NETIF_MSG_IFDOWN	= 0x0010,
+	NETIF_MSG_IFUP		= 0x0020,
+	NETIF_MSG_RX_ERR	= 0x0040,
+	NETIF_MSG_TX_ERR	= 0x0080,
+	NETIF_MSG_TX_QUEUED	= 0x0100,
+	NETIF_MSG_INTR		= 0x0200,
+	NETIF_MSG_TX_DONE	= 0x0400,
+	NETIF_MSG_RX_STATUS	= 0x0800,
+	NETIF_MSG_PKTDATA	= 0x1000,
+	NETIF_MSG_HW		= 0x2000,
+	NETIF_MSG_WOL		= 0x4000,
+};
+#endif /* ! HAVE_NETIF_MSG */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7) )
+#undef if_mii
+#define if_mii _kc_if_mii
+static inline struct mii_ioctl_data *_kc_if_mii(struct ifreq *rq)
+{
+       return (struct mii_ioctl_data *) &rq->ifr_ifru;
+}
+#endif /* < 2.6.7 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8) )
+#define msleep(x)	do { set_current_state(TASK_UNINTERRUPTIBLE); \
+				schedule_timeout((x * HZ)/1000 + 2); \
+			} while(0)
+#endif
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9) )
+#define msleep_interruptible(x)	do {set_current_state(TASK_INTERRUPTIBLE); \
+					schedule_timeout((x * HZ)/1000); \
+				} while(0)
+#endif
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,6) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) )
+#ifdef pci_save_state
+#undef pci_save_state
+#endif
+#define pci_save_state(X) { \
+	int i; \
+	if (adapter->pci_state) { \
+		for (i = 0; i < 16; i++) { \
+			pci_read_config_dword((X), \
+					      i * 4, \
+					      &adapter->pci_state[i]); \
+		} \
+	} \
+}
+
+#ifdef pci_restore_state
+#undef pci_restore_state
+#endif
+#define pci_restore_state(X) { \
+	int i; \
+	if (adapter->pci_state) { \
+		for (i = 0; i < 16; i++) { \
+			pci_write_config_dword((X), \
+					       i * 4, \
+					       adapter->pci_state[i]); \
+		} \
+	} else { \
+		for (i = 0; i < 6; i++) { \
+			pci_write_config_dword((X), \
+					       PCI_BASE_ADDRESS_0 + (i * 4), \
+					       (X)->resource[i].start); \
+		} \
+		pci_write_config_byte((X), PCI_INTERRUPT_LINE, (X)->irq); \
+	} \
+}
+#endif /* 2.4.6 <= x < 2.6.10 */
+
+#if (( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27) ) || \
+     (( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) ) && \
+      ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3) )))
+#define netdev_priv(x) x->priv
+#endif
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) )
+#ifdef module_param_array_named
+#undef module_param_array_named
+#define module_param_array_named(name, array, type, nump, perm)          \
+	static struct kparam_array __param_arr_##name                    \
+	= { ARRAY_SIZE(array), nump, param_set_##type, param_get_##type, \
+	    sizeof(array[0]), array };                                   \
+	module_param_call(name, param_array_set, param_array_get,        \
+			  &__param_arr_##name, perm)
+#endif /* module_param_array_named */
+
+#endif /* < 2.6.10 */
+
+#ifndef NET_IP_ALIGN
+#define NET_IP_ALIGN 2
+#endif
+
+#ifndef NETDEV_TX_OK
+#define NETDEV_TX_OK 0 /* driver took care of the packet */
+#endif
+
+#ifndef NETDEV_TX_BUSY
+#define NETDEV_TX_BUSY 1 /* driver tx path was busy */
+#endif
+
+#ifndef NETDEV_TX_LOCKED
+#define NETDEV_TX_LOCKED -1 /* driver tx lock was already taken */
+#endif
+
+/* if we do not have the infrastructure to detect if skb_header is cloned *
+ * just return false in all cases */
+#ifndef SKB_DATAREF_SHIFT
+#define skb_header_cloned(x) 0
+#endif /* SKB_DATAREF_SHIFT not defined */
+
+
+
+#endif /* _KCOMPAT_H_ */
+
