Patch from mainstream, ported by Kostja (khorenko@).

From: David Miller <davem@davemloft.net>
Date: Thu, 6 Nov 2008 08:37:40 +0000 (-0800)
Subject: net: Fix recursive descent in __scm_destroy().
X-Git-Tag: v2.6.28-rc4~85
X-Git-Url: http://git.kernel.org/?p=linux%2Fkernel%2Fgit%2Ftorvalds%2Flinux-2.6.git;a=commitdiff_plain;h=f8d570a

net: Fix recursive descent in __scm_destroy().

__scm_destroy() walks the list of file descriptors in the scm_fp_list
pointed to by the scm_cookie argument.

Those, in turn, can close sockets and invoke __scm_destroy() again.

There is nothing which limits how deeply this can occur.

The idea for how to fix this is from Linus.  Basically, we do all of
the fput()s at the top level by collecting all of the scm_fp_list
objects hit by an fput().  Inside of the initial __scm_destroy() we
keep running the list until it is empty.

Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
---

--- ./include/linux/sched.h.scm	2008-11-13 17:27:40.000000000 +0300
+++ ./include/linux/sched.h	2008-11-13 18:01:13.000000000 +0300
@@ -1101,6 +1101,8 @@ struct task_struct {
 #ifdef	CONFIG_TASK_DELAY_ACCT
 	struct task_delay_info *delays;
 #endif
+	struct list_head	*scm_work_list;
+
 #ifdef CONFIG_USER_RESOURCE
 	struct task_beancounter task_bc;
 #endif
--- ./include/net/scm.h.scm	2008-11-13 17:27:40.000000000 +0300
+++ ./include/net/scm.h	2008-11-13 17:52:45.000000000 +0300
@@ -12,8 +12,9 @@
 
 struct scm_fp_list
 {
-	int		count;
-	struct file	*fp[SCM_MAX_FD];
+	struct list_head	list;
+	int			count;
+	struct file		*fp[SCM_MAX_FD];
 };
 
 struct scm_cookie
--- ./net/core/scm.c.scm	2008-11-13 17:27:40.000000000 +0300
+++ ./net/core/scm.c	2008-11-13 17:52:45.000000000 +0300
@@ -76,6 +76,7 @@ static int scm_fp_copy(struct cmsghdr *c
 		if (!fpl)
 			return -ENOMEM;
 		*fplp = fpl;
+		INIT_LIST_HEAD(&fpl->list);
 		fpl->count = 0;
 	}
 	fpp = &fpl->fp[fpl->count];
@@ -107,9 +108,25 @@ void __scm_destroy(struct scm_cookie *sc
 
 	if (fpl) {
 		scm->fp = NULL;
-		for (i=fpl->count-1; i>=0; i--)
-			fput(fpl->fp[i]);
-		kfree(fpl);
+		if (current->scm_work_list) {
+			list_add_tail(&fpl->list, current->scm_work_list);
+		} else {
+			LIST_HEAD(work_list);
+
+			current->scm_work_list = &work_list;
+
+			list_add(&fpl->list, &work_list);
+			while (!list_empty(&work_list)) {
+				fpl = list_first_entry(&work_list, struct scm_fp_list, list);
+
+				list_del(&fpl->list);
+				for (i=fpl->count-1; i>=0; i--)
+					fput(fpl->fp[i]);
+				kfree(fpl);
+			}
+
+			current->scm_work_list = NULL;
+		}
 	}
 }
 
@@ -280,6 +297,7 @@ struct scm_fp_list *scm_fp_dup(struct sc
 
 	new_fpl = ub_kmalloc(sizeof(*fpl), GFP_KERNEL);
 	if (new_fpl) {
+		INIT_LIST_HEAD(&new_fpl->list);
 		for (i=fpl->count-1; i>=0; i--)
 			get_file(fpl->fp[i]);
 		memcpy(new_fpl, fpl, sizeof(*fpl));
