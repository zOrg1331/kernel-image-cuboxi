From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Thu, 18 Feb 2010 14:16:03 -0500
Subject: [net] bnx2x: update to 1.52.1-6
Message-id: <1266502564-2792-2-git-send-email-sgruszka@redhat.com>
Patchwork-id: 23346
O-Subject: [RHEL5.5 PATCH 1/2] bnx2x: update to 1.52.1-6 (part1 bugfixes)
Bugzilla: 560556
RH-Acked-by: Andy Gospodarek <gospo@redhat.com>
RH-Acked-by: Rob Evers <revers@redhat.com>

BZ#560556

Upstream:
    commit 0c43f43f48c5c60d62c4d26917da3ee71df464ea
    Author: Vladislav Zolotarov <vladz@broadcom.com>
    Date:   Wed Feb 17 02:04:00 2010 +0000

        bnx2x: fix in 57710 self-test

    commit d43a7e67ae2f911765b3d5b6cbb85221a9ffd0a4
    Author: Vladislav Zolotarov <vladz@broadcom.com>
    Date:   Wed Feb 17 02:03:40 2010 +0000

        bnx2x: Do not allow enabling LRO if disable_tpa=1

    commit f1e1a199f3a68a32cf86095b3650d761ee8798b9
    Author: Vladislav Zolotarov <vladz@broadcom.com>
    Date:   Wed Feb 17 02:03:33 2010 +0000

        bnx2x: clean up in case of error in bnx2x_init_hw()

    commit 6cbe5065bb367d4c8db0a71d2e828995bcfae336
    Author: Vladislav Zolotarov <vladz@broadcom.com>
    Date:   Wed Feb 17 02:03:27 2010 +0000

        bnx2x: Properly release allocated MSI-X/MSI vectors

    commit 4a6e47a460ce55e283063fc3f7391c8ea46bea27
    Author: Michael Chan <mchan@broadcom.com>
    Date:   Fri Dec 25 17:13:07 2009 -0800

        bnx2x: Initialize cnic status block during chip reset

diff --git a/drivers/net/bnx2x_main.c b/drivers/net/bnx2x_main.c
index e511c2f..56c1590 100644
--- a/drivers/net/bnx2x_main.c
+++ b/drivers/net/bnx2x_main.c
@@ -6937,19 +6937,21 @@ static void bnx2x_free_msix_irqs(struct bnx2x *bp)
 	}
 }
 
-static void bnx2x_free_irq(struct bnx2x *bp)
+static void bnx2x_free_irq(struct bnx2x *bp, bool disable_only)
 {
 	if (bp->flags & USING_MSIX_FLAG) {
-		bnx2x_free_msix_irqs(bp);
+		if (!disable_only)
+			bnx2x_free_msix_irqs(bp);
 		pci_disable_msix(bp->pdev);
 		bp->flags &= ~USING_MSIX_FLAG;
 
 	} else if (bp->flags & USING_MSI_FLAG) {
-		free_irq(bp->pdev->irq, bp->dev);
+		if (!disable_only)
+			free_irq(bp->pdev->irq, bp->dev);
 		pci_disable_msi(bp->pdev);
 		bp->flags &= ~USING_MSI_FLAG;
 
-	} else
+	} else if (!disable_only)
 		free_irq(bp->pdev->irq, bp->dev);
 }
 
@@ -7458,8 +7460,10 @@ static int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
 
 	rc = bnx2x_set_num_queues(bp);
 
-	if (bnx2x_alloc_mem(bp))
+	if (bnx2x_alloc_mem(bp)) {
+		bnx2x_free_irq(bp, true);
 		return -ENOMEM;
+	}
 
 	for_each_queue(bp, i)
 		bnx2x_fp(bp, i, disable_tpa) =
@@ -7472,7 +7476,7 @@ static int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
 	if (bp->flags & USING_MSIX_FLAG) {
 		rc = bnx2x_req_msix_irqs(bp);
 		if (rc) {
-			pci_disable_msix(bp->pdev);
+			bnx2x_free_irq(bp, true);
 			goto load_error1;
 		}
 	} else {
@@ -7484,8 +7488,7 @@ static int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
 		rc = bnx2x_req_irq(bp);
 		if (rc) {
 			BNX2X_ERR("IRQ request failed  rc %d, aborting\n", rc);
-			if (bp->flags & USING_MSI_FLAG)
-				pci_disable_msi(bp->pdev);
+			bnx2x_free_irq(bp, true);
 			goto load_error1;
 		}
 		if (bp->flags & USING_MSI_FLAG) {
@@ -7540,6 +7543,9 @@ static int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
 	rc = bnx2x_init_hw(bp, load_code);
 	if (rc) {
 		BNX2X_ERR("HW init failed, aborting\n");
+		bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_DONE);
+		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP);
+		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
 		goto load_error2;
 	}
 
@@ -7606,6 +7612,8 @@ static int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
 		if (bp->cnic_eth_dev.drv_state & CNIC_DRV_STATE_REGD) {
 			bnx2x_set_iscsi_eth_mac_addr(bp, 1);
 			bp->cnic_flags |= BNX2X_CNIC_FLAG_MAC_SET;
+			bnx2x_init_sb(bp, bp->cnic_sb, bp->cnic_sb_mapping,
+				      CNIC_SB_ID(bp));
 		}
 		mutex_unlock(&bp->cnic_mutex);
 #endif
@@ -7676,7 +7684,7 @@ load_error3:
 		bnx2x_free_rx_sge_range(bp, bp->fp + i, NUM_RX_SGE);
 load_error2:
 	/* Release IRQs */
-	bnx2x_free_irq(bp);
+	bnx2x_free_irq(bp, false);
 load_error1:
 	bnx2x_napi_disable(bp);
 	bnx2x_free_mem(bp);
@@ -7865,7 +7873,7 @@ static int bnx2x_nic_unload(struct bnx2x *bp, int unload_mode)
 	bnx2x_stats_handle(bp, STATS_EVENT_STOP);
 
 	/* Release IRQs */
-	bnx2x_free_irq(bp);
+	bnx2x_free_irq(bp, false);
 
 	/* Wait until tx fastpath tasks complete */
 	for_each_queue(bp, i) {
@@ -9979,12 +9987,14 @@ static int bnx2x_set_flags(struct net_device *dev, u32 data)
 
 	/* TPA requires Rx CSUM offloading */
 	if ((data & ETH_FLAG_LRO) && bp->rx_csum) {
-		if (!(dev->features & NETIF_F_LRO)) {
-			dev->features |= NETIF_F_LRO;
-			bp->flags |= TPA_ENABLE_FLAG;
-			changed = 1;
-		}
-
+		if (!disable_tpa) {
+			if (!(dev->features & NETIF_F_LRO)) {
+				dev->features |= NETIF_F_LRO;
+				bp->flags |= TPA_ENABLE_FLAG;
+				changed = 1;
+			}
+		} else
+			rc = -EINVAL;
 	} else if (dev->features & NETIF_F_LRO) {
 		dev->features &= ~NETIF_F_LRO;
 		bp->flags &= ~TPA_ENABLE_FLAG;
@@ -10450,7 +10460,8 @@ static int bnx2x_test_intr(struct bnx2x *bp)
 
 	config->hdr.length = 0;
 	if (CHIP_IS_E1(bp))
-		config->hdr.offset = (BP_PORT(bp) ? 32 : 0);
+		/* use last unicast entries */
+		config->hdr.offset = (BP_PORT(bp) ? 63 : 31);
 	else
 		config->hdr.offset = BP_FUNC(bp);
 	config->hdr.client_id = bp->fp->cl_id;
@@ -12358,7 +12369,7 @@ static int bnx2x_eeh_nic_unload(struct bnx2x *bp)
 	DP(BNX2X_MSG_STATS, "stats_state - DISABLED\n");
 
 	/* Release IRQs */
-	bnx2x_free_irq(bp);
+	bnx2x_free_irq(bp, false);
 
 	if (CHIP_IS_E1(bp)) {
 		struct mac_configuration_cmd *config =
