From: Jonathan Brassow <jbrassow@redhat.com>
Date: Thu, 11 Sep 2008 16:09:01 -0400
Subject: [md] move include files to include/linux for exposure
Message-id: 1208850715.300571221163741748.JavaMail.root@zmail01.collab.prod.int.phx2.redhat.com
O-Subject: Re: [RHEL 5.3 Patch 8 of 8]: device-mapper interface exposure (bz 429337)
Bugzilla: 429337
RH-Acked-by: Alasdair G Kergon <agk@redhat.com>
RH-Acked-by: Alasdair G Kergon <agk@redhat.com>

Repost because a change in patch #2 caused a change in this patch (patch 8).

 brassow

Move include files to include/linux for exposure.

Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>

diff --git a/drivers/md/dm-exception-store.c b/drivers/md/dm-exception-store.c
index feb3ce3..f6ce5ef 100644
--- a/drivers/md/dm-exception-store.c
+++ b/drivers/md/dm-exception-store.c
@@ -8,13 +8,13 @@
 
 #include "dm.h"
 #include "dm-snap.h"
-#include "dm-io.h"
 #include "kcopyd.h"
 
 #include <linux/mm.h>
 #include <linux/pagemap.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#include <linux/dm-io.h>
 
 #define DM_MSG_PREFIX "snapshots"
 #define DM_CHUNK_SIZE_DEFAULT_SECTORS 32	/* 16KB */
diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c
index 1ae4818..894c33b 100644
--- a/drivers/md/dm-io.c
+++ b/drivers/md/dm-io.c
@@ -5,13 +5,13 @@
  */
 
 #include "dm.h"
-#include "dm-io.h"
 
 #include <linux/bio.h>
 #include <linux/mempool.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/dm-io.h>
 
 static struct bio_set *_bios;
 
diff --git a/drivers/md/dm-io.h b/drivers/md/dm-io.h
deleted file mode 100644
index 94fc992..0000000
--- a/drivers/md/dm-io.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2003 Sistina Software
- * Copyright (C) 2004 - 2008 Red Hat, Inc. All rights reserved.
- *
- * Device-Mapper low-level I/O.
- *
- * This file is released under the GPL.
- */
-
-#ifndef _LINUX_DM_IO_H
-#define _LINUX_DM_IO_H
-
-#ifdef __KERNEL__
-
-#include <linux/types.h>
-
-struct io_region {
-	struct block_device *bdev;
-	sector_t sector;
-	sector_t count;
-};
-
-struct page_list {
-	struct page_list *next;
-	struct page *page;
-};
-
-
-/*
- * 'error' is a bitset, with each bit indicating whether an error
- * occurred doing io to the corresponding region.
- */
-typedef void (*io_notify_fn)(unsigned long error, void *context);
-
-enum dm_io_mem_type {
-	DM_IO_PAGE_LIST,/* Page list */
-	DM_IO_BVEC,	/* Bio vector */
-	DM_IO_VMA,	/* Virtual memory area */
-	DM_IO_KMEM,	/* Kernel memory */
-};
-
-struct dm_io_memory {
-	enum dm_io_mem_type type;
-
-	union {
-		struct page_list *pl;
-		struct bio_vec *bvec;
-		void *vma;
-		void *addr;
-	} ptr;
-
-	unsigned offset;
-};
-
-struct dm_io_notify {
-	io_notify_fn fn;	/* Callback for asynchronous requests */
-	void *context;		/* Passed to callback */
-};
-
-/*
- * IO request structure
- */
-struct dm_io_client;
-struct dm_io_request {
-	int bi_rw;			/* READ|WRITE - not READA */
-	struct dm_io_memory mem;	/* Memory to use for io */
-	struct dm_io_notify notify;	/* Synchronous if notify.fn is NULL */
-	struct dm_io_client *client;	/* Client memory handler */
-};
-
-/*
- * Before anyone uses the IO interface they should call
- * dm_io_get(), specifying roughly how many pages they are
- * expecting to perform io on concurrently.
- *
- * This function may block.
- */
-int dm_io_get(unsigned int num_pages);
-void dm_io_put(unsigned int num_pages);
-
-/*
- * For async io calls, users can alternatively use the dm_io() function below
- * and dm_io_client_create() to create private mempools for the client.
- *
- * Create/destroy may block.
- */
-struct dm_io_client *dm_io_client_create(unsigned num_pages);
-int dm_io_client_resize(unsigned num_pages, struct dm_io_client *client);
-void dm_io_client_destroy(struct dm_io_client *client);
-
-/*
- * Synchronous IO.
- *
- * Please ensure that the rw flag in the next two functions is
- * either READ or WRITE, ie. we don't take READA.  Any
- * regions with a zero count field will be ignored.
- */
-int dm_io_sync(unsigned int num_regions, struct io_region *where, int rw,
-	       struct page_list *pl, unsigned int offset,
-	       unsigned long *error_bits);
-
-int dm_io_sync_bvec(unsigned int num_regions, struct io_region *where, int rw,
-		    struct bio_vec *bvec, unsigned long *error_bits);
-
-int dm_io_sync_vm(unsigned int num_regions, struct io_region *where, int rw,
-		  void *data, unsigned long *error_bits);
-
-/*
- * Aynchronous IO.
- *
- * The 'where' array may be safely allocated on the stack since
- * the function takes a copy.
- */
-int dm_io_async(unsigned int num_regions, struct io_region *where, int rw,
-		struct page_list *pl, unsigned int offset,
-		io_notify_fn fn, void *context);
-
-int dm_io_async_bvec(unsigned int num_regions, struct io_region *where, int rw,
-		     struct bio_vec *bvec, io_notify_fn fn, void *context);
-
-int dm_io_async_vm(unsigned int num_regions, struct io_region *where, int rw,
-		   void *data, io_notify_fn fn, void *context);
-
-/*
- * IO interface using private per-client pools.
- * Each bit in the optional 'sync_error_bits' bitset indicates whether an
- * error occurred doing io to the corresponding region.
- */
-int dm_io(struct dm_io_request *io_req, unsigned num_regions,
-	  struct io_region *region, unsigned long *sync_error_bits);
-
-#endif	/* __KERNEL__ */
-#endif	/* _LINUX_DM_IO_H */
diff --git a/drivers/md/dm-log.c b/drivers/md/dm-log.c
index 110549d..23bfcdf 100644
--- a/drivers/md/dm-log.c
+++ b/drivers/md/dm-log.c
@@ -9,9 +9,11 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/vmalloc.h>
+#include <linux/bio.h>
+#include <linux/dm-io.h>
+#include <linux/dm-dirty-log.h>
 
-#include "dm-log.h"
-#include "dm-io.h"
+#include "dm.h"
 
 #define DM_MSG_PREFIX "dirty region log"
 
diff --git a/drivers/md/dm-log.h b/drivers/md/dm-log.h
deleted file mode 100644
index e8f19d4..0000000
--- a/drivers/md/dm-log.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 2003 Sistina Software
- *
- * This file is released under the LGPL.
- */
-
-#ifndef DM_DIRTY_LOG
-#define DM_DIRTY_LOG
-
-#include "dm.h"
-
-/*
- * Values returned by get_failure_response()
- *   DMLOG_IOERR_IGNORE:  ignore device failures
- *   DMLOG_IOERR_BLOCK:     issue dm event, and do not complete
- *                 I/O until presuspend is recieved.
- */
-#define DMLOG_IOERR_IGNORE 0
-#define DMLOG_IOERR_BLOCK  1
-
-typedef sector_t region_t;
-
-struct dm_dirty_log_type;
-
-struct dm_dirty_log {
-	struct dm_dirty_log_type *type;
-	void *context;
-};
-
-struct dm_dirty_log_type {
-	uint64_t features;
-	const char *name;
-	struct module *module;
-	unsigned int flags;
-
-	int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,
-		   unsigned int argc, char **argv);
-	void (*dtr)(struct dm_dirty_log *log);
-
-	/*
-	 * There are times when we don't want the log to touch
-	 * the disk.
-	 */
-	int (*presuspend)(struct dm_dirty_log *log);
-	int (*postsuspend)(struct dm_dirty_log *log);
-	int (*resume)(struct dm_dirty_log *log);
-
-	/*
-	 * Retrieves the smallest size of region that the log can
-	 * deal with.
-	 */
-	uint32_t (*get_region_size)(struct dm_dirty_log *log);
-
-        /*
-	 * A predicate to say whether a region is clean or not.
-	 * May block.
-	 */
-	int (*is_clean)(struct dm_dirty_log *log, region_t region);
-
-	/*
-	 *  Returns: 0, 1, -EWOULDBLOCK, < 0
-	 *
-	 * A predicate function to check the area given by
-	 * [sector, sector + len) is in sync.
-	 *
-	 * If -EWOULDBLOCK is returned the state of the region is
-	 * unknown, typically this will result in a read being
-	 * passed to a daemon to deal with, since a daemon is
-	 * allowed to block.
-	 */
-	int (*in_sync)(struct dm_dirty_log *log, region_t region,
-                      int can_block);
-
-	/*
-	 * Flush the current log state (eg, to disk).  This
-	 * function may block.
-	 */
-	int (*flush)(struct dm_dirty_log *log);
-
-	/*
-	 * Mark an area as clean or dirty.  These functions may
-	 * block, though for performance reasons blocking should
-	 * be extremely rare (eg, allocating another chunk of
-	 * memory for some reason).
-	 */
-	void (*mark_region)(struct dm_dirty_log *log, region_t region);
-	void (*clear_region)(struct dm_dirty_log *log, region_t region);
-
-	/*
-	 * Returns: <0 (error), 0 (no region), 1 (region)
-	 *
-	 * The mirrord will need perform recovery on regions of
-	 * the mirror that are in the NOSYNC state.  This
-	 * function asks the log to tell the caller about the
-	 * next region that this machine should recover.
-	 *
-	 * Do not confuse this function with 'in_sync()', one
-	 * tells you if an area is synchronised, the other
-	 * assigns recovery work.
-	*/
-	int (*get_resync_work)(struct dm_dirty_log *log, region_t *region);
-
-	/*
-	 * This notifies the log that the resync status of a region
-	 * has changed.  It also clears the region from the recovering
-	 * list (if present).
-	 */
-	void (*set_region_sync)(struct dm_dirty_log *log,
-				region_t region, int in_sync);
-
-        /*
-	 * Returns the number of regions that are in sync.
-         */
-        region_t (*get_sync_count)(struct dm_dirty_log *log);
-
-	/*
-	 * Support function for mirror status requests.
-	 */
-	int (*status)(struct dm_dirty_log *log, status_type_t status_type,
-		      char *result, unsigned int maxlen);
-
-	/*
-	 * Return the code describing what to do in the event
-	 * of a device failure.
-	 */
-	int (*get_failure_response)(struct dm_dirty_log *log);
-
-	/*
-	 * Returns: 0, 1
-	 *
-	 * This is necessary for cluster mirroring. It provides
-	 * a way to detect recovery on another node, so we
-	 * aren't writing concurrently.  This function is likely
-	 * to block (when a cluster log is used).
-	 */
-	int (*is_remote_recovering)(struct dm_dirty_log *log, region_t region);
-
-	int (*reserved[5])(int a);
-};
-
-int dm_dirty_log_type_register(struct dm_dirty_log_type *type);
-int dm_dirty_log_type_unregister(struct dm_dirty_log_type *type);
-
-
-/*
- * Make sure you use these two functions, rather than calling
- * type->constructor/destructor() directly.
- */
-struct dm_dirty_log *dm_dirty_log_create(const char *type_name,
-                                        struct dm_target *ti,
-				      unsigned int argc, char **argv);
-void dm_dirty_log_destroy(struct dm_dirty_log *log);
-
-#endif
diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
index 494dd63..94b0032 100644
--- a/drivers/md/dm-raid1.c
+++ b/drivers/md/dm-raid1.c
@@ -7,8 +7,6 @@
 #include "dm.h"
 #include "dm-bio-list.h"
 #include "dm-bio-record.h"
-#include "dm-io.h"
-#include "dm-log.h"
 #include "kcopyd.h"
 
 #include <linux/ctype.h>
@@ -20,6 +18,8 @@
 #include <linux/time.h>
 #include <linux/vmalloc.h>
 #include <linux/workqueue.h>
+#include <linux/dm-io.h>
+#include <linux/dm-dirty-log.h>
 
 #define DM_MSG_PREFIX "raid1"
 #define DM_IO_PAGES 64
diff --git a/drivers/md/kcopyd.h b/drivers/md/kcopyd.h
index 4621ea0..3fd15b1 100644
--- a/drivers/md/kcopyd.h
+++ b/drivers/md/kcopyd.h
@@ -11,7 +11,7 @@
 #ifndef DM_KCOPYD_H
 #define DM_KCOPYD_H
 
-#include "dm-io.h"
+#include <linux/dm-io.h>
 
 /* FIXME: make this configurable */
 #define KCOPYD_MAX_REGIONS 8
diff --git a/include/linux/dm-dirty-log.h b/include/linux/dm-dirty-log.h
new file mode 100644
index 0000000..d90de38
--- /dev/null
+++ b/include/linux/dm-dirty-log.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2003 Sistina Software
+ * Copyright (C) 2004-2008 Red Hat, Inc. All rights reserved.
+ *
+ * Device-Mapper dirty region log.
+ *
+ * This file is released under the LGPL.
+ */
+
+#ifndef _LINUX_DM_DIRTY_LOG
+#define _LINUX_DM_DIRTY_LOG
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/device-mapper.h>
+
+/*
+ * Values returned by get_failure_response()
+ *   DMLOG_IOERR_IGNORE:  ignore device failures
+ *   DMLOG_IOERR_BLOCK:     issue dm event, and do not complete
+ *                 I/O until presuspend is recieved.
+ */
+#define DMLOG_IOERR_IGNORE 0
+#define DMLOG_IOERR_BLOCK  1
+
+typedef sector_t region_t;
+
+struct dm_dirty_log_type;
+
+struct dm_dirty_log {
+	struct dm_dirty_log_type *type;
+	void *context;
+};
+
+struct dm_dirty_log_type {
+	uint64_t features;
+	const char *name;
+	struct module *module;
+	unsigned int flags;
+
+	int (*ctr)(struct dm_dirty_log *log, struct dm_target *ti,
+		   unsigned int argc, char **argv);
+	void (*dtr)(struct dm_dirty_log *log);
+
+	/*
+	 * There are times when we don't want the log to touch
+	 * the disk.
+	 */
+	int (*presuspend)(struct dm_dirty_log *log);
+	int (*postsuspend)(struct dm_dirty_log *log);
+	int (*resume)(struct dm_dirty_log *log);
+
+	/*
+	 * Retrieves the smallest size of region that the log can
+	 * deal with.
+	 */
+	uint32_t (*get_region_size)(struct dm_dirty_log *log);
+
+        /*
+	 * A predicate to say whether a region is clean or not.
+	 * May block.
+	 */
+	int (*is_clean)(struct dm_dirty_log *log, region_t region);
+
+	/*
+	 *  Returns: 0, 1, -EWOULDBLOCK, < 0
+	 *
+	 * A predicate function to check the area given by
+	 * [sector, sector + len) is in sync.
+	 *
+	 * If -EWOULDBLOCK is returned the state of the region is
+	 * unknown, typically this will result in a read being
+	 * passed to a daemon to deal with, since a daemon is
+	 * allowed to block.
+	 */
+	int (*in_sync)(struct dm_dirty_log *log, region_t region,
+		       int can_block);
+
+	/*
+	 * Flush the current log state (eg, to disk).  This
+	 * function may block.
+	 */
+	int (*flush)(struct dm_dirty_log *log);
+
+	/*
+	 * Mark an area as clean or dirty.  These functions may
+	 * block, though for performance reasons blocking should
+	 * be extremely rare (eg, allocating another chunk of
+	 * memory for some reason).
+	 */
+	void (*mark_region)(struct dm_dirty_log *log, region_t region);
+	void (*clear_region)(struct dm_dirty_log *log, region_t region);
+
+	/*
+	 * Returns: <0 (error), 0 (no region), 1 (region)
+	 *
+	 * The mirrord will need perform recovery on regions of
+	 * the mirror that are in the NOSYNC state.  This
+	 * function asks the log to tell the caller about the
+	 * next region that this machine should recover.
+	 *
+	 * Do not confuse this function with 'in_sync()', one
+	 * tells you if an area is synchronised, the other
+	 * assigns recovery work.
+	*/
+	int (*get_resync_work)(struct dm_dirty_log *log, region_t *region);
+
+	/*
+	 * This notifies the log that the resync status of a region
+	 * has changed.  It also clears the region from the recovering
+	 * list (if present).
+	 */
+	void (*set_region_sync)(struct dm_dirty_log *log,
+				region_t region, int in_sync);
+
+        /*
+	 * Returns the number of regions that are in sync.
+         */
+        region_t (*get_sync_count)(struct dm_dirty_log *log);
+
+	/*
+	 * Support function for mirror status requests.
+	 */
+	int (*status)(struct dm_dirty_log *log, status_type_t status_type,
+		      char *result, unsigned int maxlen);
+
+	/*
+	 * Return the code describing what to do in the event
+	 * of a device failure.
+	 */
+	int (*get_failure_response)(struct dm_dirty_log *log);
+
+	/*
+	 * Returns: 0, 1
+	 *
+	 * This is necessary for cluster mirroring. It provides
+	 * a way to detect recovery on another node, so we
+	 * aren't writing concurrently.  This function is likely
+	 * to block (when a cluster log is used).
+	 */
+	int (*is_remote_recovering)(struct dm_dirty_log *log, region_t region);
+
+	int (*reserved[5])(int a);
+};
+
+int dm_dirty_log_type_register(struct dm_dirty_log_type *type);
+int dm_dirty_log_type_unregister(struct dm_dirty_log_type *type);
+
+
+/*
+ * Make sure you use these two functions, rather than calling
+ * type->constructor/destructor() directly.
+ */
+struct dm_dirty_log *dm_dirty_log_create(const char *type_name,
+					 struct dm_target *ti,
+					 unsigned int argc, char **argv);
+void dm_dirty_log_destroy(struct dm_dirty_log *log);
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_DM_DIRTY_LOG_H */
diff --git a/include/linux/dm-io.h b/include/linux/dm-io.h
new file mode 100644
index 0000000..94fc992
--- /dev/null
+++ b/include/linux/dm-io.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2003 Sistina Software
+ * Copyright (C) 2004 - 2008 Red Hat, Inc. All rights reserved.
+ *
+ * Device-Mapper low-level I/O.
+ *
+ * This file is released under the GPL.
+ */
+
+#ifndef _LINUX_DM_IO_H
+#define _LINUX_DM_IO_H
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+
+struct io_region {
+	struct block_device *bdev;
+	sector_t sector;
+	sector_t count;
+};
+
+struct page_list {
+	struct page_list *next;
+	struct page *page;
+};
+
+
+/*
+ * 'error' is a bitset, with each bit indicating whether an error
+ * occurred doing io to the corresponding region.
+ */
+typedef void (*io_notify_fn)(unsigned long error, void *context);
+
+enum dm_io_mem_type {
+	DM_IO_PAGE_LIST,/* Page list */
+	DM_IO_BVEC,	/* Bio vector */
+	DM_IO_VMA,	/* Virtual memory area */
+	DM_IO_KMEM,	/* Kernel memory */
+};
+
+struct dm_io_memory {
+	enum dm_io_mem_type type;
+
+	union {
+		struct page_list *pl;
+		struct bio_vec *bvec;
+		void *vma;
+		void *addr;
+	} ptr;
+
+	unsigned offset;
+};
+
+struct dm_io_notify {
+	io_notify_fn fn;	/* Callback for asynchronous requests */
+	void *context;		/* Passed to callback */
+};
+
+/*
+ * IO request structure
+ */
+struct dm_io_client;
+struct dm_io_request {
+	int bi_rw;			/* READ|WRITE - not READA */
+	struct dm_io_memory mem;	/* Memory to use for io */
+	struct dm_io_notify notify;	/* Synchronous if notify.fn is NULL */
+	struct dm_io_client *client;	/* Client memory handler */
+};
+
+/*
+ * Before anyone uses the IO interface they should call
+ * dm_io_get(), specifying roughly how many pages they are
+ * expecting to perform io on concurrently.
+ *
+ * This function may block.
+ */
+int dm_io_get(unsigned int num_pages);
+void dm_io_put(unsigned int num_pages);
+
+/*
+ * For async io calls, users can alternatively use the dm_io() function below
+ * and dm_io_client_create() to create private mempools for the client.
+ *
+ * Create/destroy may block.
+ */
+struct dm_io_client *dm_io_client_create(unsigned num_pages);
+int dm_io_client_resize(unsigned num_pages, struct dm_io_client *client);
+void dm_io_client_destroy(struct dm_io_client *client);
+
+/*
+ * Synchronous IO.
+ *
+ * Please ensure that the rw flag in the next two functions is
+ * either READ or WRITE, ie. we don't take READA.  Any
+ * regions with a zero count field will be ignored.
+ */
+int dm_io_sync(unsigned int num_regions, struct io_region *where, int rw,
+	       struct page_list *pl, unsigned int offset,
+	       unsigned long *error_bits);
+
+int dm_io_sync_bvec(unsigned int num_regions, struct io_region *where, int rw,
+		    struct bio_vec *bvec, unsigned long *error_bits);
+
+int dm_io_sync_vm(unsigned int num_regions, struct io_region *where, int rw,
+		  void *data, unsigned long *error_bits);
+
+/*
+ * Aynchronous IO.
+ *
+ * The 'where' array may be safely allocated on the stack since
+ * the function takes a copy.
+ */
+int dm_io_async(unsigned int num_regions, struct io_region *where, int rw,
+		struct page_list *pl, unsigned int offset,
+		io_notify_fn fn, void *context);
+
+int dm_io_async_bvec(unsigned int num_regions, struct io_region *where, int rw,
+		     struct bio_vec *bvec, io_notify_fn fn, void *context);
+
+int dm_io_async_vm(unsigned int num_regions, struct io_region *where, int rw,
+		   void *data, io_notify_fn fn, void *context);
+
+/*
+ * IO interface using private per-client pools.
+ * Each bit in the optional 'sync_error_bits' bitset indicates whether an
+ * error occurred doing io to the corresponding region.
+ */
+int dm_io(struct dm_io_request *io_req, unsigned num_regions,
+	  struct io_region *region, unsigned long *sync_error_bits);
+
+#endif	/* __KERNEL__ */
+#endif	/* _LINUX_DM_IO_H */
