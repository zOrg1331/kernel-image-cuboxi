From: Neil Horman <nhorman@redhat.com>
Date: Tue, 9 Dec 2008 11:37:26 -0500
Subject: [x86_64] proc: export GART region through /proc/iomem
Message-id: 20081209163726.GB19156@hmsendeavour.rdu.redhat.com
O-Subject: [RHEL 5.3 PATCH] proc: export GART region through /proc/iomem (bz 475507)
Bugzilla: 475507
RH-Acked-by: Anton Arapov <aarapov@redhat.com>
RH-Acked-by: Jiri Pirko <jpirko@redhat.com>

Hey all

This is a backport of upstream commit 56dd669a138c40ea6cdae487f233430d12372767.
It exports the GART address space though /proc/iomem.  This is required so that
kdump can exclude the gart address range on systems when reading /proc/vmcore
and prevent mystery resets on some systems.  Resolves bz 475507

Neil

diff --git a/arch/x86_64/kernel/aperture.c b/arch/x86_64/kernel/aperture.c
index 2e171b1..e3f7547 100644
--- a/arch/x86_64/kernel/aperture.c
+++ b/arch/x86_64/kernel/aperture.c
@@ -17,6 +17,7 @@
 #include <linux/pci_ids.h>
 #include <linux/pci.h>
 #include <linux/bitops.h>
+#include <linux/ioport.h>
 #include <asm/e820.h>
 #include <asm/io.h>
 #include <asm/proto.h>
@@ -35,6 +36,18 @@ int fallback_aper_force __initdata = 0;
 
 int fix_aperture __initdata = 1;
 
+static struct resource gart_resource = {
+	.name	= "GART",
+	.flags	= IORESOURCE_MEM,
+};
+
+static void __init insert_aperture_resource(u32 aper_base, u32 aper_size)
+{
+	gart_resource.start = aper_base;
+	gart_resource.end = aper_base + aper_size - 1;
+	insert_resource(&iomem_resource, &gart_resource);
+}
+
 /* This code runs before the PCI subsystem is initialized, so just
    access the northbridge directly. */
 
@@ -63,6 +76,7 @@ static u32 __init allocate_aperture(void)
 	}
 	printk("Mapping aperture over %d KB of RAM @ %lx\n",
 	       aper_size >> 10, __pa(p)); 
+	insert_aperture_resource((u32)__pa(p), aper_size);
 	e820_mark_nosave_range((u32)__pa(p), (u32)__pa(p+aper_size));
 
 	return (u32)__pa(p); 
@@ -240,8 +254,13 @@ void __init iommu_hole_init(void)
 		last_aper_base = aper_base;
 	} 
 
-	if (!fix && !fallback_aper_force) 
+	if (!fix && !fallback_aper_force) {
+		if (last_aper_base) {
+			unsigned long n = (32 * 1024 * 1024) << last_aper_order;
+			insert_aperture_resource((u32)last_aper_base, n);
+		}
 		return; 
+	}
 
 	if (!fallback_aper_force)
 		aper_alloc = search_agp_bridge(&aper_order, &valid_agp); 
