From: Chad Dupuis <cdupuis@redhat.com>
Date: Thu, 26 Aug 2010 15:05:17 -0400
Subject: [scsi] qla4xxx: add PCIe AER support
Message-id: <20100826150516.2799.23265.sendpatchset@localhost.localdomain>
Patchwork-id: 27831
O-Subject: [RHEL 5.6 PATCH v2] qla4xxx: Add PCIe AER support.
Bugzilla: 624710
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

Bugzilla
--------

Bug 624710

Upstream Status
---------------

scsi-misc commit id 2232be0d5707cd331b92027c0fd7ea5e843c2121.
http://git.kernel.org/?p=linux/kernel/git/jejb/scsi-misc-2.6.git;a=commitdiff_plain;h=2232be0d5707cd331b92027c0fd7ea5e843c2121

Description
-----------

This is version 2 of this patch.  This incorporates changes based on feedback
to the original patch.  This patch adds support for PCI error handling
including PCIe AER.  This patch depends on the series:

qla4xxx: Update driver to 5.02.03.00.05.06-d.

Brew Build
----------

2708128

Testing
-------

The build of the patche was tested against the 2.6.18-213 RHEL 5 kernel.  The
patches were functionally tested internally at QLogic.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index 9d51d27..c2e452c 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -36,6 +36,7 @@
 
 #include "ql4_dbg.h"
 #include "ql4_nx.h"
+#include <linux/aer.h>
 
 #ifndef PCI_DEVICE_ID_QLOGIC_ISP4010
 #define PCI_DEVICE_ID_QLOGIC_ISP4010	0x4010
@@ -369,7 +370,11 @@ struct scsi_qla_host {
 #define AF_MSI_ENABLED			16 /* 0x00010000 */
 #define AF_MSIX_ENABLED			17 /* 0x00020000 */
 #define AF_HBA_GOING_AWAY		18 /* 0x00040000 */
-#define AF_MBOX_COMMAND_NOPOLL	19 /* 0x00080000 */
+#define AF_MBOX_COMMAND_NOPOLL		19 /* 0x00080000 */
+#define AF_PROBE_DONE			20 /* 0x00100000 */
+#define AF_FW_RECOVERY			21 /* 0x00200000 */
+#define AF_EEH_BUSY			22 /* 0x00400000 */
+#define AF_PCI_CHANNEL_IO_PERM_FAILURE	23 /* 0x00800000 */
 
 	unsigned long dpc_flags;
 
@@ -598,7 +603,7 @@ struct scsi_qla_host {
 	uint8_t revision_id;
 	uint8_t rsvd3[3];
 
-	int fw_heartbeat_counter;
+	uint32_t fw_heartbeat_counter;
 
 	struct isp_operations *isp_ops;
 	struct ql82xx_hw_data hw;
@@ -655,6 +660,22 @@ static inline int is_qla8022(struct scsi_qla_host *ha)
 	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022;
 }
 
+/* Note: Currently AER/EEH is now supported only for 8022 cards
+ * This function needs to be updated when AER/EEH is enabled
+ * for other cards.
+ */
+#if defined(CONFIG_PCIAER)
+static inline int is_aer_supported(struct scsi_qla_host *ha)
+{
+	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022;
+}
+#else
+static inline int is_aer_supported(struct scsi_qla_host *ha)
+{
+	return 0;
+}
+#endif
+
 static inline int adapter_up(struct scsi_qla_host *ha)
 {
 	return (test_bit(AF_ONLINE, &ha->flags) != 0) &&
diff --git a/drivers/scsi/qla4xxx/ql4_glbl.h b/drivers/scsi/qla4xxx/ql4_glbl.h
index b79bdbc..ecc2c23 100644
--- a/drivers/scsi/qla4xxx/ql4_glbl.h
+++ b/drivers/scsi/qla4xxx/ql4_glbl.h
@@ -84,6 +84,7 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 			uint8_t outCount, uint32_t *mbx_cmd, uint32_t *mbx_sts);
 extern void qla4xxx_queue_iocb(struct scsi_qla_host *ha);
 extern void qla4xxx_complete_iocb(struct scsi_qla_host *ha);
+void qla4xxx_mailbox_premature_completion(struct scsi_qla_host *ha);
 int qla4xxx_get_sys_info(struct scsi_qla_host *ha);
 extern int qla4xxx_iospace_config(struct scsi_qla_host *ha);
 extern void qla4xxx_pci_config(struct scsi_qla_host *ha);
@@ -162,7 +163,11 @@ int qla4_8xxx_idc_lock(struct scsi_qla_host *ha);
 void qla4_8xxx_idc_unlock(struct scsi_qla_host *ha);
 int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha);
 void qla4_8xxx_need_qsnt_handler(struct scsi_qla_host *ha);
+void qla4_8xxx_set_drv_active(struct scsi_qla_host *ha);
 void qla4_8xxx_clear_drv_active(struct scsi_qla_host *ha);
+extern int qla4_8xxx_start_firmware(struct scsi_qla_host *, uint32_t);
+extern int qla4xxx_init_firmware(struct scsi_qla_host *);
+extern int qla4xxx_initialize_ddb_list(struct scsi_qla_host *);
 
 extern int ql4xextended_error_logging;
 extern int ql4xdiscoverywait;
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index 378b505..03a08cf 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -310,6 +310,12 @@ static int qla4xxx_fw_ready(struct scsi_qla_host *ha)
 
 		}
 
+		if (test_bit(AF_FW_RECOVERY, &ha->flags)) {
+			DEBUG2(printk("scsi%ld: %s: qla8022, firmware hung -- "
+				"mmio_enabled\n", ha->host_no, __func__));
+			break;
+		}
+
 		if (ha->firmware_state & FW_STATE_ERROR) {
 			DEBUG2(printk("scsi%ld: %s: an unrecoverable error has"
 				      " occurred\n", ha->host_no, __func__));
@@ -433,10 +439,17 @@ static int qla4xxx_fw_ready(struct scsi_qla_host *ha)
  * @ha: pointer to host adapter structure.
  *
  **/
-static int qla4xxx_init_firmware(struct scsi_qla_host *ha)
+int qla4xxx_init_firmware(struct scsi_qla_host *ha)
 {
 	int status = QLA_ERROR;
 
+	if (is_aer_supported(ha) &&
+		test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))
+			return status;
+
+	if (is_qla8022(ha))
+		qla4_8xxx_stop_firmware(ha);
+
 	dev_info(&ha->pdev->dev, "Initializing firmware..\n");
 	if (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {
 		DEBUG2(printk("scsi%ld: %s: Failed to initialize firmware "
@@ -925,7 +938,7 @@ static void qla4xxx_flush_AENS(struct scsi_qla_host *ha)
 
 }
 
-static int qla4xxx_initialize_ddb_list(struct scsi_qla_host *ha)
+int qla4xxx_initialize_ddb_list(struct scsi_qla_host *ha)
 {
 	uint16_t fw_ddb_index;
 	int status = QLA_SUCCESS;
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
index 1f377d5..f866e6d 100644
--- a/drivers/scsi/qla4xxx/ql4_isr.c
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -858,7 +858,7 @@ irqreturn_t qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 irqreturn_t qla4_8xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct scsi_qla_host *ha;
-	uint32_t intr_status;
+	uint32_t intr_status = 0;
 	uint32_t status;
 	unsigned long flags = 0;
 	uint8_t reqs_count = 0;
@@ -870,6 +870,9 @@ irqreturn_t qla4_8xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 		return IRQ_NONE;
 	}
 
+	if (unlikely(pci_channel_offline(ha->pdev)))
+		return IRQ_HANDLED;
+
 	ha->isr_count++;
 	status = qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);
 	if (!(status & ha->nx_legacy_intr.int_vec_bit)) {
@@ -912,6 +915,14 @@ irqreturn_t qla4_8xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 	}
 
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+#ifdef QL_DEBUG_LEVEL_17
+	if (!irq && (test_bit(AF_EEH_BUSY, &ha->flags))) {
+		DEBUG2(printk(KERN_INFO "%s: status %x, intr_status %x\n",
+			__func__, status, intr_status));
+	}
+#endif
+
 	return IRQ_HANDLED;
 }
 
@@ -951,7 +962,7 @@ qla4_8xxx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct scsi_qla_host *ha = dev_id;
 	unsigned long	flags;
-	uint32_t intr_status;
+	uint32_t intr_status = 0;
 	uint8_t reqs_count = 0;
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
@@ -976,6 +987,14 @@ qla4_8xxx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 
 	ha->isr_count++;
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+#ifdef QL_DEBUG_LEVEL_17
+	if (!irq && (test_bit(AF_EEH_BUSY, &ha->flags))) {
+		DEBUG2(printk(KERN_INFO "%s: intr_status %x\n",
+			__func__, intr_status));
+	}
+#endif
+
 	return IRQ_HANDLED;
 }
 
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index 05bf893..de58bb6 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -38,7 +38,25 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	if (!mbx_cmd || !mbx_sts) {
 		DEBUG2(printk("scsi%ld: %s: Invalid mbx_cmd or mbx_sts "
 			      "pointer\n", ha->host_no, __func__));
-		return status;
+		goto mbox_exit_status;
+	}
+
+	if (is_aer_supported(ha)) {
+		if (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags)) {
+			DEBUG2(printk("scsi%ld: %s: Perm failure on EEH, "
+				"timeout MBX Exiting.\n",
+				ha->host_no, __func__));
+			goto mbox_exit_status;
+		}
+	}
+
+	if (is_qla8022(ha)) {
+		if (test_bit(AF_FW_RECOVERY, &ha->flags)) {
+			DEBUG2(printk("scsi%ld: %s: prematurely complete mbx "
+				" cmd as firmware recovery detected\n",
+				ha->host_no, __func__));
+			goto mbox_exit_status;
+		}
 	}
 
 	/* Mailbox code active */
@@ -181,8 +199,22 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 			      " Scheduling Adapter Reset\n", ha->host_no,
 			      mbx_cmd[0]));
 		ha->mailbox_timeout_count++;
-		mbx_sts[0] = (-1);
-		set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		/* If AER is in the process of handling a fw_hung,
+		 * complete the mbox command and return, AER/EEH
+		 * will do the reset
+		 */
+		/* Note: If the AF_EEH_BUSY flag is set here, do_dpc
+		 * checks for the AF_EEH_BUSY flag and returns w/o
+		 * doing a reset
+		 */
+		if (test_bit(AF_FW_RECOVERY, &ha->flags)) {
+			DEBUG2(printk("scsi%ld: %s: Mailbox Cmd 0x%08X timed "
+				"out & fw_hung, exit  let AER do reset\n",
+				ha->host_no, __func__, mbx_cmd[0]));
+		} else {
+			mbx_sts[0] = (-1);
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		}
 		goto mbox_exit;
 	}
 
@@ -224,9 +256,30 @@ mbox_exit:
 	mutex_unlock(&ha->mbox_sem);
 	clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
 
+mbox_exit_status:
 	return status;
 }
 
+void qla4xxx_mailbox_premature_completion(struct scsi_qla_host *ha)
+{
+	set_bit(AF_FW_RECOVERY, &ha->flags);
+	DEBUG2(printk("scsi%ld: %s: set FW RECOVERY!\n",
+		ha->host_no, __func__));
+
+	if (test_bit(AF_MBOX_COMMAND, &ha->flags)) {
+		if (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags)) {
+			complete(&ha->mbx_intr_comp);
+			DEBUG2(printk("scsi%ld: %s: Due to fw "
+				"recovery, doing premature completion of "
+				"mbx cmd\n", ha->host_no, __func__));
+		} else {
+			set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+			DEBUG2(printk("scsi%ld: %s: Due to fw "
+			"recovery, doing premature completion of "
+			"polling mbx cmd\n", ha->host_no, __func__));
+		}
+	}
+}
 
 /**
  * qla4xxx_issue_iocb - issue mailbox iocb command
diff --git a/drivers/scsi/qla4xxx/ql4_nx.c b/drivers/scsi/qla4xxx/ql4_nx.c
index 46809db..fcc19a6 100644
--- a/drivers/scsi/qla4xxx/ql4_nx.c
+++ b/drivers/scsi/qla4xxx/ql4_nx.c
@@ -1384,8 +1384,7 @@ static int qla4_8xxx_rcvpeg_ready(struct scsi_qla_host *ha)
 	return err;
 }
 
-static inline void
-qla4_8xxx_set_drv_active(struct scsi_qla_host *ha)
+void qla4_8xxx_set_drv_active(struct scsi_qla_host *ha)
 {
 	uint32_t drv_active;
 
@@ -1408,11 +1407,15 @@ qla4_8xxx_clear_drv_active(struct scsi_qla_host *ha)
 static inline int
 qla4_8xxx_need_reset(struct scsi_qla_host *ha)
 {
-	uint32_t drv_state;
+	uint32_t drv_state, drv_active;
 	int rval;
 
+	drv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
 	drv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
-	rval = drv_state & (1 << (ha->portnum * 4));
+	rval = (drv_state & (1 << (ha->portnum * 4)));
+	if ((test_bit(AF_EEH_BUSY, &ha->flags)) && drv_active)
+		rval = 1;
+
 	return rval;
 }
 
@@ -1447,8 +1450,7 @@ qla4_8xxx_set_qsnt_ready(struct scsi_qla_host *ha)
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);
 }
 
-static int
-qla4_8xxx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)
+int qla4_8xxx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)
 {
 	int           pcie_cap;
 	uint16_t      lnk;
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index afef969..a771145 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -519,6 +519,14 @@ static int qla4xxx_queuecommand(struct scsi_cmnd *cmd,
 	struct srb *srb;
 	int rval;
 
+	if (test_bit(AF_EEH_BUSY, &ha->flags)) {
+		if (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))
+			cmd->result = DID_NO_CONNECT << 16;
+		else
+			cmd->result = DID_REQUEUE << 16;
+		goto qc_fail_command;
+	}
+
 	if (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {
 		if (atomic_read(&ddb_entry->state) == DDB_STATE_DEAD) {
 			cmd->result = DID_NO_CONNECT << 16;
@@ -711,6 +719,14 @@ qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)
 	uint32_t fw_heartbeat_counter, halt_status;
 
 	fw_heartbeat_counter = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+	/* If PEG_ALIVE_COUNTER is 0xffffffff, AER/EEH is in progress, ignore */
+	if (fw_heartbeat_counter == 0xffffffff) {
+		DEBUG2(printk("scsi%ld: %s: Device in frozen state, "
+			"QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\n",
+			ha->host_no, __func__));
+			return;
+	}
+
 	if (ha->fw_heartbeat_counter == fw_heartbeat_counter) {
 		ha->seconds_since_last_heartbeat++;
 
@@ -727,6 +743,7 @@ qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)
 				set_bit(DPC_RESET_HA, &ha->dpc_flags);
 
 			qla4xxx_wake_dpc(ha);
+			qla4xxx_mailbox_premature_completion(ha);
 		}
 	}
 
@@ -752,6 +769,7 @@ void qla4_8xxx_watchdog(struct scsi_qla_host *ha)
 				ha->host_no, __func__);
 			set_bit(DPC_RESET_HA, &ha->dpc_flags);
 			qla4xxx_wake_dpc(ha);
+			qla4xxx_mailbox_premature_completion(ha);
 		} else if (dev_state == QLA82XX_DEV_NEED_QUIESCENT) {
 			printk("HW State: NEED QUIESCENT detected\n");
 			set_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags);
@@ -771,12 +789,20 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 {
 	struct ddb_entry *ddb_entry, *dtemp;
 	int start_dpc = 0;
+	uint16_t        w;
 
-	if (test_bit(AF_HBA_GOING_AWAY, &ha->flags)) {
-		DEBUG2(printk("%s exited. HBA GOING AWAY\n", __func__));
+	/* If we are in the middle of AER/EEH processing
+	 * skip any processing and reschedule the timer
+	 */
+	if (test_bit(AF_EEH_BUSY, &ha->flags)) {
+		mod_timer(&ha->timer, jiffies + HZ);
 		return;
 	}
 
+	/* Hardware read to trigger an EEH error during mailbox waits. */
+	if (!pci_channel_offline(ha->pdev))
+		pci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);
+
 	if (is_qla8022(ha)) {
 		qla4_8xxx_watchdog(ha);
 	}
@@ -1397,10 +1423,11 @@ static void qla4xxx_do_dpc(void *data)
 	if (!test_bit(AF_INIT_DONE, &ha->flags))
 		return;
 
-	/* HBA is in the process of being permanently disabled.
-	 * Don't process anything */
-	if (test_bit(AF_HBA_GOING_AWAY, &ha->flags))
-		return;
+	if (test_bit(AF_EEH_BUSY, &ha->flags)) {
+		DEBUG2(printk(KERN_INFO "scsi%ld: %s: flags = %lx\n",
+			ha->host_no, __func__, ha->flags));
+		goto do_dpc_exit;
+	}
 
 	if (is_qla8022(ha)) {
 		if (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {
@@ -1555,6 +1582,8 @@ dpc_post_reset_ha:
 		}
 		clear_bit(DPC_ASYNC_MSG_PDU, &ha->dpc_flags);
 	}
+do_dpc_exit:
+	clear_bit(AF_DPC_SCHEDULED, &ha->flags);
 }
 
 /**
@@ -1668,7 +1697,7 @@ iospace_error_exit:
  * @ha: pointer to adapter structure
  *
  * This routines maps HBA's registers from the pci address space
- * into the kernel virtual address space for memory mapped i/o. 
+ * into the kernel virtual address space for memory mapped i/o.
  **/
 int qla4xxx_iospace_config(struct scsi_qla_host *ha)
 {
@@ -1827,6 +1856,8 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	ha->host = host;
 	ha->host_no = host->host_no;
 
+	pci_enable_pcie_error_reporting(pdev);
+
 	/* Setup Runtime configurable options */
 	if (is_qla8022(ha))
 		ha->isp_ops = &qla4_8xxx_isp_ops;
@@ -1945,6 +1976,8 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 
 	ha->isp_ops->enable_intrs(ha);
 
+	pci_save_state(ha->pdev);
+
 	/* Start timer thread. */
 	qla4xxx_start_timer(ha, qla4xxx_timer, 1);
 
@@ -1987,6 +2020,7 @@ probe_failed:
 	qla4xxx_free_adapter(ha);
 
 probe_failed_iospace_config:
+	pci_disable_pcie_error_reporting(pdev);
 	scsi_host_put(ha->host);
 
 probe_disable_device:
@@ -2026,6 +2060,8 @@ static void __devexit qla4xxx_remove_adapter(struct pci_dev *pdev)
 
 	scsi_host_put(ha->host);
 
+	pci_disable_pcie_error_reporting(pdev);
+	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
 }
 
@@ -2125,6 +2161,18 @@ static int qla4xxx_eh_wait_on_command(struct scsi_qla_host *ha,
 #define ABORT_WAIT_ITER		1
 	int done = 0;
 	unsigned long wait_iter = ABORT_WAIT_ITER;
+	int ret = SUCCESS;
+
+	/* Dont wait on command if PCI error is being handled
+	 * by PCI AER driver
+	 */
+	if (unlikely(pci_channel_offline(ha->pdev)) ||
+			(test_bit(AF_EEH_BUSY, &ha->flags))) {
+		dev_warn(&ha->pdev->dev, "scsi%ld: Return from %s\n",
+				ha->host_no, __func__);
+		return ret;
+	}
+
 
 	do {
 		/* Checking to see if its returned to OS */
@@ -2482,6 +2530,278 @@ static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
 	return return_status;
 }
 
+/* PCI AER driver recovers from all correctable errors w/o
+ * driver intervention. For uncorrectable errors PCI AER
+ * driver calls the following device driver's callbacks
+ *
+ * - Fatal Errors - link_reset
+ * - Non-Fatal Errors - driver's pci_error_detected() which
+ * returns CAN_RECOVER, NEED_RESET or DISCONNECT.
+ *
+ * PCI AER driver calls
+ * CAN_RECOVER - driver's pci_mmio_enabled(), mmio_enabled
+ *               returns RECOVERED or NEED_RESET if fw_hung
+ * NEED_RESET - driver's slot_reset()
+ * DISCONNECT - device is dead & cannot recover
+ * RECOVERED - driver's pci_resume()
+ */
+static pci_ers_result_t
+qla4xxx_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
+{
+	struct scsi_qla_host *ha = pci_get_drvdata(pdev);
+
+	printk(KERN_WARNING "scsi%ld: func %x: %s: error detected:state %x\n",
+		ha->host_no, PCI_FUNC(pdev->devfn), __func__, state);
+
+	if (!is_aer_supported(ha))
+		return PCI_ERS_RESULT_NONE;
+
+	switch (state) {
+	case pci_channel_io_normal:
+		clear_bit(AF_EEH_BUSY, &ha->flags);
+		return PCI_ERS_RESULT_CAN_RECOVER;
+	case pci_channel_io_frozen:
+		set_bit(AF_EEH_BUSY, &ha->flags);
+		/* If the firmware is in a hung state and a mbox
+		 * command has been issued, complete the mbox, so
+		 * slot reset can be done
+		 */
+		set_bit(AF_FW_RECOVERY, &ha->flags);
+		if (test_bit(AF_MBOX_COMMAND, &ha->flags)) {
+			if (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags)) {
+				complete(&ha->mbx_intr_comp);
+				printk(KERN_WARNING "scsi%ld: func %x: %s: In "
+				    "nopoll mode doing premature completion "
+				    "of mbox command due to FW_RECOVERY\n",
+				    ha->host_no, PCI_FUNC(pdev->devfn),
+				    __func__);
+			} else {
+				set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+				printk(KERN_WARNING "scsi%ld: func %x: %s: "
+				    "FW_RECOVERY in polling mode, set "
+				    "AF_MBOX_COMMAND_DONE to stop polling\n",
+				    ha->host_no, PCI_FUNC(pdev->devfn),
+				    __func__);
+			}
+		}
+		qla4xxx_free_irqs(ha);
+		pci_disable_device(pdev);
+		/* Abort all active commands */
+		qla4xxx_abort_active_cmds(ha, DID_RESET << 16);
+		return PCI_ERS_RESULT_NEED_RESET;
+	case pci_channel_io_perm_failure:
+		set_bit(AF_EEH_BUSY, &ha->flags);
+		set_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags);
+		qla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);
+		return PCI_ERS_RESULT_DISCONNECT;
+	}
+	return PCI_ERS_RESULT_NEED_RESET;
+}
+
+/* qla4xxx_pci_mmio_enabled() gets called if
+ * qla4xxx_pci_error_detected() returns PCI_ERS_RESULT_CAN_RECOVER
+ * and read/write to the device still works.
+ */
+static pci_ers_result_t
+qla4xxx_pci_mmio_enabled(struct pci_dev *pdev)
+{
+	struct scsi_qla_host *ha = pci_get_drvdata(pdev);
+
+	if (!is_aer_supported(ha))
+		return PCI_ERS_RESULT_NONE;
+
+	return PCI_ERS_RESULT_RECOVERED;
+}
+
+uint32_t qla4_8xxx_error_recovery(struct scsi_qla_host *ha)
+{
+	uint32_t rval = QLA_ERROR;
+	int fn;
+	struct pci_dev *other_pdev = NULL;
+
+	printk(KERN_WARNING "scsi%ld func %x: In %s\n",
+		ha->host_no, PCI_FUNC(ha->pdev->devfn), __func__);
+
+	set_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
+
+	if (test_bit(AF_ONLINE, &ha->flags)) {
+		clear_bit(AF_ONLINE, &ha->flags);
+		qla4xxx_mark_all_devices_missing(ha);
+		qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+	}
+
+	fn = PCI_FUNC(ha->pdev->devfn);
+	while (fn > 0) {
+		fn--;
+		printk(KERN_INFO "scsi%ld: %s: Finding PCI device at "
+			"func %x\n", ha->host_no, __func__, fn);
+		/* Get the pci device given the domain, bus,
+		 * slot/function number */
+		other_pdev =
+		    pci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),
+		    ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
+		    fn));
+
+		if (other_pdev && other_pdev->is_enabled) {
+			printk(KERN_INFO "scsi%ld: %s: Found PCI func in "
+			    "enabled state%x\n", ha->host_no, __func__, fn);
+			pci_dev_put(other_pdev);
+			break;
+		}
+		pci_dev_put(other_pdev);
+	}
+
+	/* The first function on the card, the reset owner will
+	 * start & initialize the firmware. The other functions
+	 * on the card will reset the firmware context
+	 */
+	if (!fn) {
+		printk(KERN_INFO "scsi%ld: %s: devfn being reset 0x%x is the "
+			"owner\n", ha->host_no, __func__, ha->pdev->devfn);
+
+		qla4_8xxx_idc_lock(ha);
+		qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_COLD);
+
+		qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION,
+						QLA82XX_IDC_VERSION);
+
+		qla4_8xxx_idc_unlock(ha);
+
+		clear_bit(AF_FW_RECOVERY, &ha->flags);
+
+		rval = qla4xxx_initialize_adapter(ha, PRESERVE_DDB_LIST);
+		qla4_8xxx_idc_lock(ha);
+		if (rval != QLA_SUCCESS) {
+			printk(KERN_INFO "scsi%ld: %s: hw state: failed \n",
+				ha->host_no, __func__);
+			qla4_8xxx_clear_drv_active(ha);
+			qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+				QLA82XX_DEV_FAILED);
+		} else {
+			printk(KERN_INFO "scsi%ld: %s: hw state: ready \n",
+				ha->host_no, __func__);
+			qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+				QLA82XX_DEV_READY);
+			/* clear driver state register */
+			qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, 0);
+			set_bit(AF_ONLINE, &ha->flags);
+		}
+		qla4_8xxx_idc_unlock(ha);
+	} else {
+			printk(KERN_INFO "scsi%ld: %s: devfn 0x%x is not the "
+				"reset owner\n", ha->host_no, __func__,
+				ha->pdev->devfn);
+			if ((qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE) ==
+							QLA82XX_DEV_READY)) {
+				clear_bit(AF_FW_RECOVERY, &ha->flags);
+				/* Firmware has been loaded & started by the
+				 * first function Initialize the firmware and
+				 * ddb list
+				 */
+				rval = qla4xxx_initialize_adapter(ha,
+							PRESERVE_DDB_LIST);
+				if (rval == QLA_SUCCESS)
+					ha->isp_ops->enable_intrs(ha);
+				qla4_8xxx_idc_lock(ha);
+				qla4_8xxx_set_drv_active(ha);
+				qla4_8xxx_idc_unlock(ha);
+			}
+	}
+	clear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
+	return rval;
+}
+
+static pci_ers_result_t
+qla4xxx_pci_slot_reset(struct pci_dev *pdev)
+{
+	pci_ers_result_t ret = PCI_ERS_RESULT_DISCONNECT;
+	struct scsi_qla_host *ha = pci_get_drvdata(pdev);
+	int rc;
+
+	printk(KERN_WARNING "scsi%ld: func %x: %s: slot_reset \n",
+		ha->host_no, PCI_FUNC(pdev->devfn), __func__);
+
+	if (!is_aer_supported(ha))
+		return PCI_ERS_RESULT_NONE;
+
+	/* Workaround to properly reflect error_state as
+	 * pci_channel_io_online as result of eeh_reset_device()
+	 * called just prior to this callback.
+	 * eeh_driver.c delays updating error_state until
+	 * report_resume callback which is too late for
+	 * qla2xxx driver which access hardware earlier.
+	 * Can be removed when fixed in mainline.
+	 */
+	pdev->error_state = pci_channel_io_normal;
+
+	/* Restore the saved state of PCIe device -
+	 * Bar registers, pci config space, PCIx, MSI,
+	 * IOV states
+	 */
+	pci_restore_state(pdev);
+
+	/* pci_restore_state() clears the saved_state flag of the device
+	 * save restored state which resets saved_state flag.
+	 */
+	pci_save_state(pdev);
+
+	/* initialize device or resume if in suspended state */
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		printk(KERN_WARNING "scsi%ld: %s: Cant re-enable "
+			"device after reset\n", ha->host_no, __func__);
+		goto exit_slot_reset;
+	}
+
+	if (qla4xxx_request_irqs(ha)) {
+		dev_warn(&ha->pdev->dev, "Failed to reserve interrupt %d"
+				" already in use.\n", pdev->irq);
+		goto exit_slot_reset;
+	}
+
+	if (is_qla8022(ha)) {
+		if (qla4_8xxx_error_recovery(ha) == QLA_SUCCESS) {
+			ret = PCI_ERS_RESULT_RECOVERED;
+			goto exit_slot_reset;
+		} else
+			goto exit_slot_reset;
+	}
+
+exit_slot_reset:
+	printk(KERN_WARNING "scsi%ld: func %x: %s: Return=%x \n"
+		"device after reset\n",
+		ha->host_no, PCI_FUNC(pdev->devfn), __func__, ret);
+	return ret;
+}
+
+static void
+qla4xxx_pci_resume(struct pci_dev *pdev)
+{
+	struct scsi_qla_host *ha = pci_get_drvdata(pdev);
+	int ret;
+
+	printk(KERN_WARNING "scsi%ld: func %x: %s: pci_resume \n",
+		ha->host_no, PCI_FUNC(pdev->devfn), __func__);
+
+	ret = qla4xxx_wait_for_hba_online(ha);
+	if (ret != QLA_SUCCESS) {
+		printk(KERN_ERR "scsi%ld: func %x: %s:"
+			"the device failed to resume i/o "
+			"from slot/link_reset\n",
+			ha->host_no, PCI_FUNC(pdev->devfn), __func__);
+	}
+
+	pci_cleanup_aer_uncorrect_error_status(pdev);
+	clear_bit(AF_EEH_BUSY, &ha->flags);
+}
+
+static struct pci_error_handlers qla4xxx_err_handler = {
+	.error_detected	= qla4xxx_pci_error_detected,
+	.mmio_enabled	= qla4xxx_pci_mmio_enabled,
+	.slot_reset	= qla4xxx_pci_slot_reset,
+	.resume		= qla4xxx_pci_resume,
+};
+
 
 static struct pci_device_id qla4xxx_pci_tbl[] = {
 	{
@@ -2517,6 +2837,7 @@ struct pci_driver qla4xxx_pci_driver = {
 	.id_table	= qla4xxx_pci_tbl,
 	.probe		= qla4xxx_probe_adapter,
 	.remove		= qla4xxx_remove_adapter,
+	.err_handler	= &qla4xxx_err_handler,
 };
 
 static int __init qla4xxx_module_init(void)
