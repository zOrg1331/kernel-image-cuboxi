From: Jerome Marchand <jmarchan@redhat.com>
Date: Tue, 25 Jan 2011 14:07:08 -0500
Subject: [block] fix accounting bug on cross partition merges
Message-id: <4D3ED90C.3060100@redhat.com>
Patchwork-id: 32861
O-Subject: [PATCH RHEL5 v3] block: fix accounting bug on cross partition merges
Bugzilla: 646816
RH-Acked-by: Vivek Goyal <vgoyal@redhat.com>

This version fixes the last test in is_same_part() and initializes
*part1 and *part2.

Bugzilla:
https://bugzilla.redhat.com/show_bug.cgi?id=646816

When a bio is merged into a request which belongs to a different partition
by ELEVATOR_FRONT_MERGE, the part->in_flight value which is decreased when
request is completed, is not the same as the one that was increase when the
request was added and we end up having both in_flight value corrupted.

Here, we fix it by correctly updating the in_flight values when such a
merge occurs. This is not the way it is corrected upstream (caching the
partition in struct request), because the code of IO accounting changed a
lot since RHEL5. This fix is somewhat simpler and does not break kABI.

FYI, upstream fix are linux-next commits:
e4a683c899cd5a49f8d684a054c95bd115a0c005
09e099d4bafea3b15be003d548bdf94b4b6e0e17
6c23a9681c0fe7fb7dd331b39dda11926f43746e

Regards,
Jerome


diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
index d2505d6..3415e4a 100644
--- a/block/ll_rw_blk.c
+++ b/block/ll_rw_blk.c
@@ -2987,6 +2987,27 @@ static void init_request_from_bio(struct request *req, struct bio *bio)
 	req->start_time = jiffies;
 }
 
+static void blk_account_io_front_merge(struct request *req, sector_t newsector)
+{
+	if (blk_do_io_stat(req)) {
+		struct hd_struct *oldpart, *newpart;
+
+		rcu_read_lock();
+		if (!is_same_part(req->rq_disk, req->sector, newsector,
+				  &oldpart, &newpart)) {
+			if (oldpart) {
+				part_round_stats(oldpart);
+				get_partstats(oldpart)->in_flight--;
+			}
+			if (newpart) {
+				part_round_stats(newpart);
+				get_partstats(newpart)->in_flight++;
+			}
+		}
+		rcu_read_unlock();
+	}
+}
+
 static int __make_request(request_queue_t *q, struct bio *bio)
 {
 	struct request *req;
@@ -3061,6 +3082,12 @@ static int __make_request(request_queue_t *q, struct bio *bio)
 			req->buffer = bio_data(bio);
 			req->current_nr_sectors = cur_nr_sectors;
 			req->hard_cur_sectors = cur_nr_sectors;
+			
+			/*
+			 * The merge may happen accross partitions
+			 * We must update in_flight value accordingly
+			 */
+			blk_account_io_front_merge(req, sector);
 			req->sector = req->hard_sector = sector;
 			req->nr_sectors = req->hard_nr_sectors += nr_sectors;
 			req->ioprio = ioprio_best(req->ioprio, prio);
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index c7da74e..0835bec 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -161,6 +161,12 @@ struct disk_attribute {
  * The __ variants should only be called in critical sections. The full
  * variants disable/enable preemption.
  */
+static inline int sector_in_part(struct hd_struct *part, sector_t sector)
+{
+	return part->start_sect <= sector
+		&& sector < part->start_sect + part->nr_sects;
+}
+
 static inline struct hd_struct *get_part(struct gendisk *gendiskp,
 					 sector_t sector)
 {
@@ -168,13 +174,36 @@ static inline struct hd_struct *get_part(struct gendisk *gendiskp,
 	int i;
 	for (i = 0; i < gendiskp->minors - 1; i++) {
 		part = gendiskp->part[i];
-		if (part && part->start_sect <= sector
-		    && sector < part->start_sect + part->nr_sects)
+		if (part && sector_in_part(part, sector))
 			return part;
 	}
 	return NULL;
 }
 
+static inline int is_same_part(struct gendisk *gendiskp, sector_t sector1,
+			       sector_t sector2, struct hd_struct **part1,
+			       struct hd_struct **part2)
+{
+	struct hd_struct *part;
+	int i;
+
+	*part1 = *part2 = NULL;
+	for (i = 0; i < gendiskp->minors - 1; i++) {
+		part = gendiskp->part[i];
+		if (!part)
+			continue;
+		if (sector_in_part(part, sector1))
+			*part1 = part;
+		if (sector_in_part(part, sector2))
+			*part2 = part;
+		if (*part1 && *part2)
+			/* we found both partitions */
+			return *part1 == *part2;
+	}
+	/* we did not found at least one partition */
+	return *part1 == *part2;
+}
+
 #define disk_stats_index(field) (offsetof(struct disk_stats, field))
 /*
  * Maintain old stats field of struct hd_struct to avoid kABI breakage
