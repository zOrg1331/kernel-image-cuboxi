From: Eric Sandeen <sandeen@redhat.com>
Date: Wed, 25 Mar 2009 15:43:25 -0500
Subject: [misc] completion helpers
Message-id: 49CA976D.1070104@redhat.com
O-Subject: [PATCH 3/10] completion helpers
Bugzilla: 470845
RH-Acked-by: Steven Whitehouse <swhiteho@redhat.com>
RH-Acked-by: Josef Bacik <josef@redhat.com>

Backport of:

commit 39d2f1ab2a36ac527a6c41cfe689f50c239eaca3
Author: David Chinner <david@fromorbit.com>
Date:   Wed Aug 13 16:40:43 2008 +1000

    [XFS] extend completions to provide XFS object flush requirements

    XFS object flushing doesn't quite match existing completion semantics.  It
    mixed exclusive access with completion.  That is, we need to mark an object as
    being flushed before flushing it to disk, and then block any other attempt to
    flush it until the completion occurs.  We do this but adding an extra count to
    the completion before we start using them.  However, we still need to
    determine if there is a completion in progress, and allow no-blocking attempts
    fo completions to decrement the count.

    To do this we introduce:

    int try_wait_for_completion(struct completion *x)
    	returns a failure status if done == 0, otherwise decrements done
    	to zero and returns a "started" status. This is provided
    	to allow counted completions to begin safely while holding
    	object locks in inverted order.

    int completion_done(struct completion *x)
    	returns 1 if there is no waiter, 0 if there is a waiter
    	(i.e. a completion in progress).

    This replaces the use of semaphores for providing this exclusion
    and completion mechanism.

    SGI-PV: 981498

    SGI-Modid: xfs-linux-melb:xfs-kern:31816a

    Signed-off-by: David Chinner <david@fromorbit.com>
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>

AND

commit be4de35263f59ca1f4740edfffbfb02cc3f2189e
Author: Dave Chinner <david@fromorbit.com>
Date:   Fri Aug 15 00:40:44 2008 -0700

    completions: uninline try_wait_for_completion and completion_done

    m68k fails to build with these functions inlined in completion.h.  Move
    them out of line into sched.c and export them to avoid this problem.

    Signed-off-by: Dave Chinner <david@fromorbit.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/completion.h b/include/linux/completion.h
index 268c5a4..2f791b6 100644
--- a/include/linux/completion.h
+++ b/include/linux/completion.h
@@ -48,6 +48,8 @@ extern unsigned long FASTCALL(wait_for_completion_timeout(struct completion *x,
 						   unsigned long timeout));
 extern unsigned long FASTCALL(wait_for_completion_interruptible_timeout(
 			struct completion *x, unsigned long timeout));
+extern bool try_wait_for_completion(struct completion *x);
+extern bool completion_done(struct completion *x);
 
 extern void FASTCALL(complete(struct completion *));
 extern void FASTCALL(complete_all(struct completion *));
diff --git a/kernel/sched.c b/kernel/sched.c
index b579d0f..c375fe0 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -3994,6 +3994,52 @@ out:
 EXPORT_SYMBOL(wait_for_completion_interruptible_timeout);
 
 
+/**
+ *	try_wait_for_completion - try to decrement a completion without blocking
+ *	@x:	completion structure
+ *
+ *	Returns: 0 if a decrement cannot be done without blocking
+ *		 1 if a decrement succeeded.
+ *
+ *	If a completion is being used as a counting completion,
+ *	attempt to decrement the counter without blocking. This
+ *	enables us to avoid waiting if the resource the completion
+ *	is protecting is not available.
+ */
+bool try_wait_for_completion(struct completion *x)
+{
+	int ret = 1;
+
+	spin_lock_irq(&x->wait.lock);
+	if (!x->done)
+		ret = 0;
+	else
+		x->done--;
+	spin_unlock_irq(&x->wait.lock);
+	return ret;
+}
+EXPORT_SYMBOL(try_wait_for_completion);
+
+/**
+ *	completion_done - Test to see if a completion has any waiters
+ *	@x:	completion structure
+ *
+ *	Returns: 0 if there are waiters (wait_for_completion() in progress)
+ *		 1 if there are no waiters.
+ *
+ */
+bool completion_done(struct completion *x)
+{
+	int ret = 1;
+
+	spin_lock_irq(&x->wait.lock);
+	if (!x->done)
+		ret = 0;
+	spin_unlock_irq(&x->wait.lock);
+	return ret;
+}
+EXPORT_SYMBOL(completion_done);
+
 #define	SLEEP_ON_VAR					\
 	unsigned long flags;				\
 	wait_queue_t wait;				\
