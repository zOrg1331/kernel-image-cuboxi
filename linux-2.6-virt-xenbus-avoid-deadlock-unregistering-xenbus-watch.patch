From: Paolo Bonzini <pbonzini@redhat.com>
Date: Wed, 4 Aug 2010 15:24:12 -0400
Subject: [virt] xenbus: avoid deadlock unregistering xenbus watch
Message-id: <1280935454-22447-1-git-send-email-pbonzini@redhat.com>
Patchwork-id: 27382
O-Subject: [RHEL5.5 PATCH] xenbus: Avoid deadlock when unregistering a xenbus
	watch.
Bugzilla: 429102
RH-Acked-by: Don Dutile <ddutile@redhat.com>
RH-Acked-by: Andrew Jones <drjones@redhat.com>
RH-Acked-by: Miroslav Rezanina <mrezanin@redhat.com>

Bugzilla: 429102

Upstream: http://xenbits.xensource.com/staging/linux-2.6.18-xen.hg?rev/498

Brew build: https://brewweb.devel.redhat.com/taskinfo?taskID=2651766

Watch handlers which run in a separate thread (XBWF_new_thread) should
run without the xenbus_mutex held since kthread_run can block waiting
for memory which causes a deadlock if further watches need to be
unregistered in order to activate the swap device on resume.

XBWF_new_thread cannot be safely unregistered anyway since the mutex
only protects thread startup.

Signed-off-by: Ian Campbell <ian.campbell@citrix.com>

diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index 895a7e2..f1d2f7d 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -628,6 +628,8 @@ void unregister_xenbus_watch(struct xenbus_watch *watch)
 	char token[sizeof(watch) * 2 + 1];
 	int err;
 
+	BUG_ON(watch->flags & XBWF_new_thread);
+
 	sprintf(token, "%lX", (long)watch);
 
 	down_read(&xs_state.suspend_mutex);
@@ -742,16 +744,29 @@ static int xenwatch_thread(void *unused)
 			list_del(ent);
 		spin_unlock(&watch_events_lock);
 
-		if (ent != &watch_events) {
-			msg = list_entry(ent, struct xs_stored_msg, list);
-			if (msg->u.watch.handle->flags & XBWF_new_thread)
-				kthread_run(xenwatch_handle_callback,
-					    msg, "xenwatch_cb");
-			else
-				xenwatch_handle_callback(msg);
+		if (ent == &watch_events) {
+			mutex_unlock(&xenwatch_mutex);
+			continue;
 		}
 
-		mutex_unlock(&xenwatch_mutex);
+		msg = list_entry(ent, struct xs_stored_msg, list);
+
+		/*
+		 * Unlock the mutex before running an XBWF_new_thread
+		 * handler. kthread_run can block which can deadlock
+		 * against unregister_xenbus_watch() if we need to
+		 * unregister other watches in order to make
+		 * progress. This can occur on resume before the swap
+		 * device is attached.
+		 */
+		if (msg->u.watch.handle->flags & XBWF_new_thread) {
+			mutex_unlock(&xenwatch_mutex);
+			kthread_run(xenwatch_handle_callback,
+				    msg, "xenwatch_cb");
+		} else {
+			xenwatch_handle_callback(msg);
+			mutex_unlock(&xenwatch_mutex);
+		}
 	}
 
 	return 0;
