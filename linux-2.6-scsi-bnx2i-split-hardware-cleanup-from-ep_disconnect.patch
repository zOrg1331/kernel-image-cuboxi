From: Mike Christie <mchristi@redhat.com>
Date: Fri, 13 Aug 2010 09:46:29 -0400
Subject: [scsi] bnx2i: split hardware cleanup from ep_disconnect
Message-id: <1281692802-2810-2-git-send-email-mchristi@redhat.com>
Patchwork-id: 27539
O-Subject: [RHEL5.6 PATCH 01/14] BNX2I: Separated the hardware's cleanup
	procedure from ep_disconnect
Bugzilla: 568606

From: Eddie Wai <eddie.wai@broadcom.com>

For bz 568606.

This patch introduces a new bnx2i_hw_ep_disconnect routine which
contains all chip related disconnect and clean up procedure of
iSCSI offload connections.  This separation is intended as a
preparation for the subsequent bnx2i_stop patch.

http://git.kernel.org/?p=linux/kernel/git/jejb/scsi-misc-2.6.git;a=commit;h=6447f286326690a936c35f9f913499307f869934

diff --git a/drivers/scsi/bnx2i/bnx2i_iscsi.c b/drivers/scsi/bnx2i/bnx2i_iscsi.c
index a1fef07..d9efb7b 100644
--- a/drivers/scsi/bnx2i/bnx2i_iscsi.c
+++ b/drivers/scsi/bnx2i/bnx2i_iscsi.c
@@ -1876,55 +1876,34 @@ static int bnx2i_ep_tcp_conn_active(struct bnx2i_endpoint *bnx2i_ep)
 
 
 /**
- * bnx2i_ep_disconnect - executes TCP connection teardown process
- * @ep:		TCP connection (endpoint) handle
+ * bnx2i_hw_ep_disconnect - executes TCP connection teardown process in the hw
+ * @ep:		TCP connection (bnx2i endpoint) handle
  *
  * executes  TCP connection teardown process
  */
-static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
+int bnx2i_hw_ep_disconnect(struct bnx2i_endpoint *bnx2i_ep)
 {
-	struct bnx2i_endpoint *bnx2i_ep;
-	struct bnx2i_conn *bnx2i_conn = NULL;
-	struct iscsi_session *session = NULL;
-	struct iscsi_conn *conn;
+	struct bnx2i_hba *hba = bnx2i_ep->hba;
 	struct cnic_dev *cnic;
-	struct bnx2i_hba *hba;
+	struct iscsi_session *session = NULL;
+	struct iscsi_conn *conn = NULL;
+	int ret = 0;
 
-	bnx2i_ep = ep->dd_data;
+	if (!hba)
+		return 0;
 
-	/* driver should not attempt connection cleanup untill TCP_CONNECT
-	 * completes either successfully or fails. Timeout is 9-secs, so
-	 * wait for it to complete
-	 */
-	while ((bnx2i_ep->state == EP_STATE_CONNECT_START) &&
-		!time_after(jiffies, bnx2i_ep->timestamp + (12 * HZ)))
-		msleep(250);
+	cnic = hba->cnic;
+	if (!cnic)
+		return 0;
+
+	if (!bnx2i_ep_tcp_conn_active(bnx2i_ep))
+		goto destroy_conn;
 
 	if (bnx2i_ep->conn) {
-		bnx2i_conn = bnx2i_ep->conn;
-		conn = bnx2i_conn->cls_conn->dd_data;
+		conn = bnx2i_ep->conn->cls_conn->dd_data;
 		session = conn->session;
-
-		spin_lock_bh(&session->lock);
-		bnx2i_conn->is_bound = 0;
-		spin_unlock_bh(&session->lock);
 	}
 
-	hba = bnx2i_ep->hba;
-	if (bnx2i_ep->state == EP_STATE_IDLE)
-		goto return_bnx2i_ep;
-	cnic = hba->cnic;
-
-	mutex_lock(&hba->net_dev_lock);
-
-	if (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state))
-		goto free_resc;
-	if (bnx2i_ep->hba_age != hba->age)
-		goto free_resc;
-
-	if (!bnx2i_ep_tcp_conn_active(bnx2i_ep))
-		goto destory_conn;
-
 	bnx2i_ep->state = EP_STATE_DISCONN_START;
 
 	init_timer(&bnx2i_ep->ofld_timer);
@@ -1935,6 +1914,7 @@ static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
 
 	if (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {
 		int close = 0;
+		int close_ret = 0;
 
 		if (session) {
 			spin_lock_bh(&session->lock);
@@ -1943,11 +1923,13 @@ static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
 			spin_unlock_bh(&session->lock);
 		}
 		if (close)
-			cnic->cm_close(bnx2i_ep->cm_sk);
+			close_ret = cnic->cm_close(bnx2i_ep->cm_sk);
 		else
-			cnic->cm_abort(bnx2i_ep->cm_sk);
+			close_ret = cnic->cm_abort(bnx2i_ep->cm_sk);
+		if (close_ret)
+			bnx2i_ep->state = EP_STATE_DISCONN_COMPL;
 	} else
-		goto free_resc;
+		goto out;
 
 	/* wait for option-2 conn teardown */
 	wait_event_interruptible(bnx2i_ep->ofld_wait,
@@ -1957,20 +1939,74 @@ static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
 		flush_signals(current);
 	del_timer_sync(&bnx2i_ep->ofld_timer);
 
-destory_conn:
-	if (bnx2i_tear_down_conn(hba, bnx2i_ep)) {
+destroy_conn:
+	if (bnx2i_tear_down_conn(hba, bnx2i_ep))
+		ret = -EINVAL;
+out:
+	bnx2i_ep->state = EP_STATE_IDLE;
+	return ret;
+}
+
+
+/**
+ * bnx2i_ep_disconnect - executes TCP connection teardown process
+ * @ep:		TCP connection (iscsi endpoint) handle
+ *
+ * executes  TCP connection teardown process
+ */
+static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
+{
+	struct bnx2i_endpoint *bnx2i_ep;
+	struct bnx2i_conn *bnx2i_conn = NULL;
+	struct iscsi_session *session = NULL;
+	struct iscsi_conn *conn = NULL;
+	struct bnx2i_hba *hba;
+
+	bnx2i_ep = ep->dd_data;
+
+	/* driver should not attempt connection cleanup until TCP_CONNECT
+	 * completes either successfully or fails. Timeout is 9-secs, so
+	 * wait for it to complete
+	 */
+	while ((bnx2i_ep->state == EP_STATE_CONNECT_START) &&
+		!time_after(jiffies, bnx2i_ep->timestamp + (12 * HZ)))
+		msleep(250);
+
+	if (bnx2i_ep->conn) {
+		bnx2i_conn = bnx2i_ep->conn;
+		conn = bnx2i_conn->cls_conn->dd_data;
+		session = conn->session;
+
+		spin_lock_bh(&session->lock);
+		bnx2i_conn->is_bound = 0;
+		spin_unlock_bh(&session->lock);
+	}
+	hba = bnx2i_ep->hba;
+
+	mutex_lock(&hba->net_dev_lock);
+
+	if (bnx2i_ep->state == EP_STATE_IDLE)
+		goto return_bnx2i_ep;
+
+	if (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state))
+		goto free_resc;
+
+	if (bnx2i_ep->hba_age != hba->age)
+		goto free_resc;
+
+	/* Do all chip cleanup here */
+	if (bnx2i_hw_ep_disconnect(bnx2i_ep)) {
 		mutex_unlock(&hba->net_dev_lock);
 		return;
 	}
 free_resc:
-	mutex_unlock(&hba->net_dev_lock);
 	bnx2i_free_qp_resc(hba, bnx2i_ep);
 return_bnx2i_ep:
 	if (bnx2i_conn)
 		bnx2i_conn->ep = NULL;
 
 	bnx2i_free_ep(ep);
-
+	mutex_unlock(&hba->net_dev_lock);
 	if (!hba->ofld_conns_active)
 		bnx2i_unreg_dev_all();
 }
