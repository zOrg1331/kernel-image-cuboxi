From: peterm@redhat.com <peterm@redhat.com>
Date: Thu, 14 Aug 2008 10:45:59 -0400
Subject: [ipmi] control BMC device ordering
Message-id: 200808141445.m7EEjxp4008208@dhcp-100-18-167.bos.redhat.com
O-Subject: [RHEL 5.3 Patch] IPMI:Control BMC device ordering
Bugzilla: 430157
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>
RH-Acked-by: Neil Horman <nhorman@redhat.com>

Hello,

This patch addresses a problem on multinode IPMI enabled systems
by allowing users to control BMC device ordering through a kernel
parameter, ipmi_dev_order.  The default dmi scan handling in RHEL 5 is
to add the BMC devices in LIFO order.  This will still be the default in
RHEL5.  Setting, "ipmi_dev_order=2", in the kernel command line will
cause dmi scan to add the devices in FIFO order, which is what IBM
requested for RHEL 5.3.  This patch is limited to x86/x86_64, (I know of
no other multinode IPMI enabled systems outside of the x86/x86_64 systems
tested on).  The change allows RHEL 5.3 to mirror the upstream dmi
IPMI list handling change without breaking existing RHEL customer
configurations.

I modified the Xen setup code to keep the kernel variants in sync.

Testing:  The patch was tested against a brew kernel build in house, by the
onsite IBM partner, (Ed Pollard).  The patch was also tested at IBM's
Beaverton site with no problems to report.  Bill Burns tested the Xen
variant.

Brew build info: Task 1424482.

This resolves Bugzilla 430157.

Peter-

diff --git a/Documentation/IPMI.txt b/Documentation/IPMI.txt
index 0d0ebef..2b705df 100644
--- a/Documentation/IPMI.txt
+++ b/Documentation/IPMI.txt
@@ -658,3 +658,17 @@ registered.
 
 Note that if you have ACPI enabled, the system will prefer using ACPI to
 power off.
+
+
+BMC Device Ordering
+-------------------
+
+To control the order in which device nodes are created there is a kernel
+parameter named, "ipmi_dev_order".  By default dmi_scan.c creates ipmi 
+device nodes in LIFO order.  Users can specify, "ipmi_dev_order=2", in 
+the kernel command line to direct the system to create the device nodes
+in FIFO order.  
+
+Note that this option is only available on IA-32, and X86_64.  The option
+is only important to users on multinode systems.
+
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 234faba..9990e7f 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -707,6 +707,9 @@ running once the system is up.
 	ip2=		[HW] Set IO/IRQ pairs for up to 4 IntelliPort boards
 			See comment before ip2_setup() in drivers/char/ip2.c.
 
+	ipmi_dev_order=	[IA-32,X86_64]
+			See Documentation/IPMI.txt.
+
 	ips=		[HW,SCSI] Adaptec / IBM ServeRAID controller
 			See header of drivers/scsi/ips.c.
 
diff --git a/arch/i386/kernel/setup-xen.c b/arch/i386/kernel/setup-xen.c
index 0f55451..73cbf04 100644
--- a/arch/i386/kernel/setup-xen.c
+++ b/arch/i386/kernel/setup-xen.c
@@ -101,6 +101,9 @@ EXPORT_SYMBOL(boot_cpu_data);
 
 unsigned long mmu_cr4_features;
 
+unsigned int ipmi_dev_order=1;
+EXPORT_SYMBOL_GPL(ipmi_dev_order);
+
 #ifdef	CONFIG_ACPI
 	int acpi_disabled = 0;
 #else
@@ -1000,6 +1003,9 @@ static void __init parse_cmdline_early (char ** cmdline_p)
 		else if (!memcmp(from, "vmalloc=", 8))
 			__VMALLOC_RESERVE = memparse(from+8, &from);
 
+		else if (!memcmp(from, "ipmi_dev_order=", 15))
+			ipmi_dev_order = simple_strtoul(from + 15, NULL, 0);
+
 	next_char:
 		c = *(from++);
 		if (!c)
diff --git a/arch/i386/kernel/setup.c b/arch/i386/kernel/setup.c
index 2e63328..98e936d 100644
--- a/arch/i386/kernel/setup.c
+++ b/arch/i386/kernel/setup.c
@@ -90,6 +90,9 @@ EXPORT_SYMBOL(boot_cpu_data);
 
 unsigned long mmu_cr4_features;
 
+unsigned int ipmi_dev_order=1;
+EXPORT_SYMBOL_GPL(ipmi_dev_order);
+
 #ifdef	CONFIG_ACPI
 	int acpi_disabled = 0;
 #else
@@ -940,6 +943,9 @@ static void __init parse_cmdline_early (char ** cmdline_p)
 		else if (!memcmp(from, "vmalloc=", 8))
 			__VMALLOC_RESERVE = memparse(from+8, &from);
 
+		else if (!memcmp(from, "ipmi_dev_order=", 15))
+			ipmi_dev_order = simple_strtoul(from + 15, NULL, 0);
+
 	next_char:
 		c = *(from++);
 		if (!c)
diff --git a/arch/x86_64/kernel/setup-xen.c b/arch/x86_64/kernel/setup-xen.c
index 93efadf..50de168 100644
--- a/arch/x86_64/kernel/setup-xen.c
+++ b/arch/x86_64/kernel/setup-xen.c
@@ -120,6 +120,9 @@ EXPORT_SYMBOL(boot_cpu_data);
 
 unsigned long mmu_cr4_features;
 
+unsigned int ipmi_dev_order=1;
+EXPORT_SYMBOL_GPL(ipmi_dev_order);
+
 int acpi_disabled;
 EXPORT_SYMBOL(acpi_disabled);
 #ifdef	CONFIG_ACPI
@@ -499,6 +502,9 @@ static __init void parse_cmdline_early (char ** cmdline_p)
 			setup_additional_cpus(from+16);
 #endif
 
+		else if (!memcmp(from, "ipmi_dev_order=", 15))
+			ipmi_dev_order = simple_strtoul(from + 15, NULL, 0);
+
 	next_char:
 		c = *(from++);
 		if (!c)
diff --git a/arch/x86_64/kernel/setup.c b/arch/x86_64/kernel/setup.c
index 53c31fd..e18e3af 100644
--- a/arch/x86_64/kernel/setup.c
+++ b/arch/x86_64/kernel/setup.c
@@ -75,6 +75,9 @@ EXPORT_SYMBOL(boot_cpu_data);
 
 unsigned long mmu_cr4_features;
 
+unsigned int ipmi_dev_order=1;
+EXPORT_SYMBOL_GPL(ipmi_dev_order);
+
 int acpi_disabled;
 EXPORT_SYMBOL(acpi_disabled);
 #ifdef	CONFIG_ACPI
@@ -422,6 +425,9 @@ static __init void parse_cmdline_early (char ** cmdline_p)
 			setup_additional_cpus(from+16);
 #endif
 
+		else if (!memcmp(from, "ipmi_dev_order=", 15))
+			ipmi_dev_order = simple_strtoul(from + 15, NULL, 0);
+
 	next_char:
 		c = *(from++);
 		if (!c)
diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c
index bfa03a6..8ca0ff0 100644
--- a/drivers/firmware/dmi_scan.c
+++ b/drivers/firmware/dmi_scan.c
@@ -153,6 +153,9 @@ static void __init dmi_save_ipmi_device(struct dmi_header *dm)
 {
 	struct dmi_device *dev;
 	void * data;
+#ifdef CONFIG_X86
+	extern unsigned int ipmi_dev_order;
+#endif
 
 	data = dmi_alloc(dm->length);
 	if (data == NULL) {
@@ -172,7 +175,19 @@ static void __init dmi_save_ipmi_device(struct dmi_header *dm)
 	dev->name = "IPMI controller";
 	dev->device_data = data;
 
-	list_add(&dev->list, &dmi_devices);
+#ifdef CONFIG_X86
+	switch(ipmi_dev_order) {
+	case 2:		/* FIFO */
+	  list_add_tail(&dev->list, &dmi_devices);
+	  break;
+	default:	/* LIFO */
+#endif
+	  list_add(&dev->list, &dmi_devices);
+#ifdef CONFIG_X86
+	  break;
+	}
+#endif
+
 }
 
 /*
