From: Hans-Joachim Picht <hpicht@redhat.com>
Date: Thu, 12 Mar 2009 15:25:45 +0100
Subject: [s390] blktrace: add ioctls to SCSI generic devices
Message-id: 20090312142545.GM5103@redhat.com
O-Subject: [RHEL5 U4 PATCH 12/20] FEAT: s390 : blktrace: Add blktrace ioctls to SCSI generic devices
Bugzilla: 475334

Bugzilla
=========
BZ 475334
https://bugzilla.redhat.com/show_bug.cgi?id=475334

commit 6da127ad0918f93ea93678dad62ce15ffed18797
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Jan 11 10:09:43 2008 +0100

    blktrace: Add blktrace ioctls to SCSI generic devices

    Since the SCSI layer uses the request queues from the block layer, blktrace can
    also be used to trace the requests to all SCSI devices (like SCSI tape drives),
    not only disks. The only missing part is the ioctl interface to start and stop
    tracing.

    This patch adds the SETUP, START, STOP and TEARDOWN ioctls from blktrace to the
    sg device files. With this change, blktrace can be used for SCSI devices like
    for disks, e.g.: blktrace -d /dev/sg1 -o - | blkparse -i -

diff --git a/block/blktrace.c b/block/blktrace.c
index 2b4ef2b..a2cc2a8 100644
--- a/block/blktrace.c
+++ b/block/blktrace.c
@@ -200,7 +200,7 @@ static void blk_trace_cleanup(struct blk_trace *bt)
 	kfree(bt);
 }
 
-static int blk_trace_remove(request_queue_t *q)
+int blk_trace_remove(request_queue_t *q)
 {
 	struct blk_trace *bt;
 
@@ -214,6 +214,7 @@ static int blk_trace_remove(request_queue_t *q)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(blk_trace_remove);
 
 static int blk_dropped_open(struct inode *inode, struct file *filp)
 {
@@ -281,13 +282,12 @@ static struct rchan_callbacks blk_relay_callbacks = {
 /*
  * Setup everything required to start tracing
  */
-static int blk_trace_setup(request_queue_t *q, struct block_device *bdev,
+int blk_trace_setup(request_queue_t *q, char *name, dev_t dev,
 			   char __user *arg)
 {
 	struct blk_user_trace_setup buts;
 	struct blk_trace *old_bt, *bt = NULL;
 	struct dentry *dir = NULL;
-	char b[BDEVNAME_SIZE];
 	int ret, i;
 
 	if (copy_from_user(&buts, arg, sizeof(buts)))
@@ -296,7 +296,7 @@ static int blk_trace_setup(request_queue_t *q, struct block_device *bdev,
 	if (!buts.buf_size || !buts.buf_nr)
 		return -EINVAL;
 
-	strcpy(buts.name, bdevname(bdev, b));
+	strcpy(buts.name, name);
 
 	/*
 	 * some device names have larger paths - convert the slashes
@@ -324,7 +324,7 @@ static int blk_trace_setup(request_queue_t *q, struct block_device *bdev,
 		goto err;
 
 	bt->dir = dir;
-	bt->dev = bdev->bd_dev;
+	bt->dev = dev;
 	atomic_set(&bt->dropped, 0);
 
 	ret = -EIO;
@@ -371,8 +371,9 @@ err:
 	}
 	return ret;
 }
+EXPORT_SYMBOL_GPL(blk_trace_setup);
 
-static int blk_trace_startstop(request_queue_t *q, int start)
+int blk_trace_startstop(request_queue_t *q, int start)
 {
 	struct blk_trace *bt;
 	int ret;
@@ -403,6 +404,7 @@ static int blk_trace_startstop(request_queue_t *q, int start)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(blk_trace_startstop);
 
 /**
  * blk_trace_ioctl: - handle the ioctls associated with tracing
@@ -415,6 +417,7 @@ int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)
 {
 	request_queue_t *q;
 	int ret, start = 0;
+	char b[BDEVNAME_SIZE];
 
 	q = bdev_get_queue(bdev);
 	if (!q)
@@ -424,7 +427,8 @@ int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)
 
 	switch (cmd) {
 	case BLKTRACESETUP:
-		ret = blk_trace_setup(q, bdev, arg);
+		strcpy(b, bdevname(bdev, b));
+		ret = blk_trace_setup(q, b, bdev->bd_dev, arg);
 		break;
 	case BLKTRACESTART:
 		start = 1;
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index 5bc3b44..7fe5bd6 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -48,6 +48,7 @@ static int sg_version_num = 30534;	/* 2 digits for each component */
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/scatterlist.h>
+#include <linux/blktrace_api.h>
 
 #include "scsi.h"
 #include <scsi/scsi_dbg.h>
@@ -1067,6 +1068,17 @@ sg_ioctl(struct inode *inode, struct file *filp,
 	case BLKSECTGET:
 		return put_user(sdp->device->request_queue->max_sectors * 512,
 				ip);
+	case BLKTRACESETUP:
+		return blk_trace_setup(sdp->device->request_queue,
+			       sdp->disk->disk_name,
+				       MKDEV(SCSI_GENERIC_MAJOR, sdp->disk->first_minor),
+				       (char *)arg);
+	case BLKTRACESTART:
+		return blk_trace_startstop(sdp->device->request_queue, 1);
+	case BLKTRACESTOP:
+		return blk_trace_startstop(sdp->device->request_queue, 0);
+	case BLKTRACETEARDOWN:
+		return blk_trace_remove(sdp->device->request_queue);
 	default:
 		if (read_only)
 			return -EPERM;	/* don't know so take safe approach */
diff --git a/include/linux/blktrace_api.h b/include/linux/blktrace_api.h
index e1e0196..0d2cd38 100644
--- a/include/linux/blktrace_api.h
+++ b/include/linux/blktrace_api.h
@@ -295,6 +295,11 @@ static inline void blk_add_driver_data(struct request_queue *q,
 				0, BLK_TA_DRV_DATA, rq->errors, len, data);
 }
 
+extern int blk_trace_setup(request_queue_t *q, char *name, dev_t dev,
+			   char __user *arg);
+extern int blk_trace_startstop(request_queue_t *q, int start);
+extern int blk_trace_remove(request_queue_t *q);
+
 #else /* !CONFIG_BLK_DEV_IO_TRACE */
 #define blk_trace_ioctl(bdev, cmd, arg)		(-ENOTTY)
 #define blk_trace_shutdown(q)			do { } while (0)
@@ -303,6 +308,10 @@ static inline void blk_add_driver_data(struct request_queue *q,
 #define blk_add_trace_generic(q, rq, rw, what)	do { } while (0)
 #define blk_add_trace_pdu_int(q, what, bio, pdu)	do { } while (0)
 #define blk_add_trace_remap(q, bio, dev, f, t)	do {} while (0)
+#define do_blk_trace_setup(q, name, dev, buts)	(-ENOTTY)
+#define blk_trace_setup(q, name, dev, arg)	(-ENOTTY)
+#define blk_trace_startstop(q, start)		(-ENOTTY)
+#define blk_trace_remove(q)			(-ENOTTY)
 #define blk_add_driver_data(q, rq, data, len)  do {} while (0)
 #endif /* CONFIG_BLK_DEV_IO_TRACE */
 
