From: Mauro Carvalho Chehab <mchehab@redhat.com>
Date: Fri, 2 Jul 2010 23:13:44 -0400
Subject: [edac] i7core_edac: Backport driver to RHEL5
Message-id: <20100702201344.7b326a9e@pedra>
Patchwork-id: 26700
O-Subject: [RHEL5 BZ#468877 5/5] i7core_edac: Backport driver to RHEL5
Bugzilla: 468877
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 95a94d5..4c814c1 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -55,6 +55,8 @@ config EDAC_MM_EDAC
 	  occurred so that a particular failing memory module can be
 	  replaced.  If unsure, select 'Y'.
 
+config EDAC_MCE
+	bool
 
 config EDAC_AMD76X
 	tristate "AMD 76x (760, 762, 768)"
@@ -112,6 +114,16 @@ config EDAC_I5400
 	  Support for error detection and correction the Intel
 	  i5400 MCH chipset (Seaburg).
 
+config EDAC_I7CORE
+	tristate "Intel i7 Core (Nehalem) processors"
+	depends on EDAC_MM_EDAC && PCI && X86 && X86_MCE_INTEL
+	select EDAC_MCE
+	help
+	  Support for error detection and correction the Intel
+	  i7 Core (Nehalem) Integrated Memory Controller that exists on
+	  newer processors like i7 Core, i7 Core Extreme, Xeon 35xx
+	  and Xeon 55xx processors.
+
 config EDAC_I82860
 	tristate "Intel 82860"
 	depends on EDAC_MM_EDAC && PCI && X86_32
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index a48f46c..3758a3f 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -9,6 +9,7 @@
 
 
 obj-$(CONFIG_EDAC_MM_EDAC)		+= edac_mc.o
+obj-$(CONFIG_EDAC_MCE)			+= edac_mce.o
 obj-$(CONFIG_EDAC_AMD76X)		+= amd76x_edac.o
 obj-$(CONFIG_EDAC_E7XXX)		+= e7xxx_edac.o
 obj-$(CONFIG_EDAC_E752X)		+= e752x_edac.o
@@ -17,6 +18,7 @@ obj-$(CONFIG_EDAC_I3000)		+= i3000_edac.o
 obj-$(CONFIG_EDAC_I3200)                += i3200_edac.o
 obj-$(CONFIG_EDAC_I5000)		+= i5000_edac.o
 obj-$(CONFIG_EDAC_I5400)		+= i5400_edac.o
+obj-$(CONFIG_EDAC_I7CORE)		+= i7core_edac.o
 obj-$(CONFIG_EDAC_I82860)		+= i82860_edac.o
 obj-$(CONFIG_EDAC_K8)			+= k8_edac.o
 
diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 04eb6db..4ba4da3 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -31,13 +31,13 @@
 #include <linux/pci_ids.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
-#include <linux/edac.h>
 #include <linux/mmzone.h>
 #include <linux/edac_mce.h>
+#include <asm/mce.h>
 #include <linux/smp.h>
 #include <asm/processor.h>
 
-#include "edac_core.h"
+#include "edac_mc.h"
 
 /*
  * This is used for Nehalem-EP and Nehalem-EX devices, where the non-core
@@ -378,8 +378,6 @@ static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 	{0,}			/* 0 terminated list. */
 };
 
-static struct edac_pci_ctl_info *i7core_pci;
-
 /****************************************************************************
 			Anciliary status routines
  ****************************************************************************/
@@ -725,6 +723,8 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
 	return 0;
 }
 
+#if 0	/* FIXME: need to backport new edac sysfs routines to RHEL 5 */
+
 /****************************************************************************
 			Error insertion routines
  ****************************************************************************/
@@ -1183,6 +1183,8 @@ static struct mcidev_sysfs_attribute i7core_sysfs_attrs[] = {
 	{ .attr = { .name = NULL } }
 };
 
+#endif
+
 /****************************************************************************
 	Device initialization routines: put/get, init/exit
  ****************************************************************************/
@@ -1452,9 +1454,11 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 	 * For registered memory, this is not needed, since the counters
 	 * are already displayed at the standard locations
 	 */
+#if 0 /* FIXME: need to backport new edac sysfs routines to RHEL 5 */
 	if (!pvt->is_registered)
 		i7core_sysfs_attrs[ARRAY_SIZE(i7core_sysfs_attrs)-2].grp =
 			&i7core_udimm_counters;
+#endif
 
 	return 0;
 
@@ -1820,7 +1824,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 
 #ifdef CONFIG_SMP
 	/* Only handle if it is the right mc controller */
-	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket)
+	if (cpu_data[mce->cpu].phys_proc_id != pvt->i7core_dev->socket)
 		return 0;
 #endif
 
@@ -1853,8 +1857,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	int rc;
 
 	/* allocate a new MC control structure */
-	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels,
-			    i7core_dev->socket);
+	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels);
 	if (unlikely(!mci))
 		return -ENOMEM;
 
@@ -1880,7 +1883,9 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 				  i7core_dev->socket);
 	mci->dev_name = pci_name(i7core_dev->pdev[0]);
 	mci->ctl_page_to_phys = NULL;
+#if 0 /* FIXME: need to backport new edac sysfs routines to RHEL 5 */
 	mci->mc_driver_sysfs_attributes = i7core_sysfs_attrs;
+#endif
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 
@@ -1893,7 +1898,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	get_dimm_config(mci, &csrow);
 
 	/* add this new MC control structure to EDAC's list of MCs */
-	if (unlikely(edac_mc_add_mc(mci))) {
+	if (unlikely(edac_mc_add_mc(mci, 0))) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mc_add_mc()\n", __func__);
 		/* FIXME: perhaps some code should go here that disables error
@@ -1904,18 +1909,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 		goto fail;
 	}
 
-	/* allocating generic PCI control info */
-	i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
-						 EDAC_MOD_STR);
-	if (unlikely(!i7core_pci)) {
-		printk(KERN_WARNING
-			"%s(): Unable to create PCI control\n",
-			__func__);
-		printk(KERN_WARNING
-			"%s(): PCI error report via EDAC not setup\n",
-			__func__);
-	}
-
 	/* Default error mask is any memory */
 	pvt->inject.channel = 0;
 	pvt->inject.dimm = -1;
@@ -2010,9 +2003,6 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
-	if (i7core_pci)
-		edac_pci_release_generic_ctl(i7core_pci);
-
 	/*
 	 * we have a trouble here: pdev value for removal will be wrong, since
 	 * it will point to the X58 register used to detect that the machine
@@ -2064,10 +2054,7 @@ static int __init i7core_init(void)
 {
 	int pci_rc;
 
-	debugf2("MC: " __FILE__ ": %s()\n", __func__);
-
-	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
-	opstate_init();
+	debugf0("MC: " __FILE__ ": %s()\n", __func__);
 
 	i7core_xeon_pci_fixup(pci_dev_table);
 
@@ -2088,7 +2075,7 @@ static int __init i7core_init(void)
  */
 static void __exit i7core_exit(void)
 {
-	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	debugf0("MC: " __FILE__ ": %s()\n", __func__);
 	pci_unregister_driver(&i7core_driver);
 }
 
@@ -2100,6 +2087,3 @@ MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
 MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
 MODULE_DESCRIPTION("MC Driver for Intel i7 Core memory controllers - "
 		   I7CORE_REVISION);
-
-module_param(edac_op_state, int, 0444);
-MODULE_PARM_DESC(edac_op_state, "EDAC Error Reporting state: 0=Poll,1=NMI");
diff --git a/include/linux/edac_mce.h b/include/linux/edac_mce.h
index f974fc0..cac4d79 100644
--- a/include/linux/edac_mce.h
+++ b/include/linux/edac_mce.h
@@ -12,9 +12,10 @@
 #if defined(CONFIG_EDAC_MCE) || \
 			(defined(CONFIG_EDAC_MCE_MODULE) && defined(MODULE))
 
-#include <asm/mce.h>
 #include <linux/list.h>
 
+struct mce;
+
 struct edac_mce {
 	struct list_head list;
 
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 13c266b..02d432e 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -506,6 +506,7 @@ void pcibios_update_irq(struct pci_dev *, int irq);
 
 /* Generic PCI functions used internally */
 
+void pcibios_scan_specific_bus(int busn);
 extern struct pci_bus *pci_find_bus(int domain, int busnr);
 void pci_bus_add_devices(struct pci_bus *bus);
 struct pci_bus *pci_scan_bus_parented(struct device *parent, int bus, struct pci_ops *ops, void *sysdata);
