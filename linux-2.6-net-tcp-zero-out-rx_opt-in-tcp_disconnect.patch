From: Thomas Graf <tgraf@redhat.com>
Date: Thu, 26 Aug 2010 09:07:44 -0400
Subject: [net] tcp: zero out rx_opt in tcp_disconnect
Message-id: <20100826090744.GC14555@lsx.localdomain>
Patchwork-id: 27822
O-Subject: [RHEL5.6 PATCH] tcp: zero out rx_opt in tcp_disconnect()
Bugzilla: 539560
RH-Acked-by: Neil Horman <nhorman@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Jiri Pirko <jpirko@redhat.com>

Straight backport of the commit
b40b4f79ce789e9e28d382c85006f62be2725282:

    When the server drops its connection, NFS client reconnects using the
    same socket after disconnecting. If the new connection's SYN,ACK
    doesn't contain the TCP timestamp option and the old connection's did,
    tp->tcp_header_len is recomputed assuming no timestamp header but
    tp->rx_opt.tstamp_ok remains set. Then tcp_build_and_update_options()
    adds in a timestamp option past the end of the allocated TCP header,
    overwriting TCP data, or when the data is in skb_shinfo(skb)->frags[],
    overwriting skb_shinfo(skb) causing a crash soon after. (The issue was
    debugged from such a crash.)

    Similarly, wscale_ok and sack_ok also get set based on the SYN,ACK
    packet but not reset on disconnect, since they are zeroed out at
    initialization. The patch zeroes out the entire tp->rx_opt struct in
    tcp_disconnect() to avoid this sort of problem.

    Signed-off-by: Srinivas Aji <Aji_Srinivas@emc.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Tested by me.

Resolves BZ539560.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index abab66d..8cfa50c 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1772,8 +1772,7 @@ int tcp_disconnect(struct sock *sk, int flags)
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
 	sk->sk_send_head = NULL;
-	tp->rx_opt.saw_tstamp = 0;
-	tcp_sack_reset(&tp->rx_opt);
+	memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
 	__sk_dst_reset(sk);
 
 	BUG_TRAP(!inet->num || icsk->icsk_bind_hash);
