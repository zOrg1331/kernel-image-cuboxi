From: Paolo Bonzini <pbonzini@redhat.com>
Date: Mon, 30 Aug 2010 16:46:26 -0400
Subject: [xen] introduce get_isa_irq_vector and is_isa_irq_masked
Message-id: <1283186789-20909-2-git-send-email-pbonzini@redhat.com>
Patchwork-id: 27932
O-Subject: [RHEL5.6 XEN PATCH 1/4] introduce get_isa_irq_vector and
	is_isa_irq_masked
Bugzilla: 625902

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=625902

Upstream status: see below

Brew build: https://brewweb.devel.redhat.com/taskinfo?taskID=2719051

This patch simply introduces two functions to limit the differences
from upstream for the next patch.  This patch has otherwise no
semantic change.

The function were introduced upstream by xen-unstable.hg changesets
13096 and 13175.  However, instead of using the code from those
changesets, I simply redid the refactoring and extracted the new
functions out of pt_irq_vector and pt_irq_masked respectively.
---
 arch/x86/hvm/irq.c        |   20 ++++++++++++++++++++
 arch/x86/hvm/vpt.c        |   19 ++-----------------
 include/asm-x86/hvm/irq.h |    2 ++
 3 files changed, 24 insertions(+), 17 deletions(-)

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/arch/x86/hvm/irq.c b/arch/x86/hvm/irq.c
index a47d2fa..df01eea 100644
--- a/arch/x86/hvm/irq.c
+++ b/arch/x86/hvm/irq.c
@@ -326,6 +326,26 @@ int cpu_get_interrupt(struct vcpu *v, int *type)
     return -1;
 }
 
+int get_isa_irq_vector(struct vcpu *v, int isa_irq, int type)
+{
+    unsigned int gsi = hvm_isa_irq_to_gsi(isa_irq);
+
+    if ( type == APIC_DM_EXTINT )
+        return (v->domain->arch.hvm_domain.vpic[isa_irq >> 3].irq_base
+                + (isa_irq & 7));
+
+    return domain_vioapic(v->domain)->redirtbl[gsi].fields.vector;
+}
+
+int is_isa_irq_masked(struct vcpu *v, int isa_irq)
+{
+    unsigned int gsi = hvm_isa_irq_to_gsi(isa_irq);
+    uint8_t pic_imr = v->domain->arch.hvm_domain.vpic[isa_irq >> 3].imr;
+
+    return (((pic_imr & (1 << (isa_irq & 7))) || !vlapic_accept_pic_intr(v)) &&
+            domain_vioapic(v->domain)->redirtbl[gsi].fields.mask);
+}
+
 int hvm_local_events_need_delivery(struct vcpu *v)
 {
     int pending = cpu_has_pending_irq(v);
diff --git a/arch/x86/hvm/vpt.c b/arch/x86/hvm/vpt.c
index 586f7a3..5bb69ee 100644
--- a/arch/x86/hvm/vpt.c
+++ b/arch/x86/hvm/vpt.c
@@ -28,26 +28,16 @@
 static int pt_irq_vector(struct periodic_time *pt, int type)
 {
     struct vcpu *v = pt->vcpu;
-    unsigned int gsi, isa_irq;
 
     if ( pt->source == PTSRC_lapic )
         return pt->irq;
 
-    isa_irq = pt->irq;
-    gsi = hvm_isa_irq_to_gsi(isa_irq);
-
-    if ( type == APIC_DM_EXTINT )
-        return (v->domain->arch.hvm_domain.vpic[isa_irq >> 3].irq_base
-                + (isa_irq & 7));
-
-    return domain_vioapic(v->domain)->redirtbl[gsi].fields.vector;
+    return get_isa_irq_vector(v, pt->irq, type);
 }
 
 static int pt_irq_masked(struct periodic_time *pt)
 {
     struct vcpu *v = pt->vcpu;
-    unsigned int gsi, isa_irq;
-    uint8_t pic_imr;
 
     if ( pt->source == PTSRC_lapic )
     {
@@ -56,12 +46,7 @@ static int pt_irq_masked(struct periodic_time *pt)
                 (vlapic_get_reg(vlapic, APIC_LVTT) & APIC_LVT_MASKED));
     }
 
-    isa_irq = pt->irq;
-    gsi = hvm_isa_irq_to_gsi(isa_irq);
-    pic_imr = v->domain->arch.hvm_domain.vpic[isa_irq >> 3].imr;
-
-    return (((pic_imr & (1 << (isa_irq & 7))) || !vlapic_accept_pic_intr(v)) &&
-            domain_vioapic(v->domain)->redirtbl[gsi].fields.mask);
+    return is_isa_irq_masked(v, pt->irq);
 }
 
 static void pt_lock(struct periodic_time *pt)
diff --git a/include/asm-x86/hvm/irq.h b/include/asm-x86/hvm/irq.h
index 12c721d..ecaf91f 100644
--- a/include/asm-x86/hvm/irq.h
+++ b/include/asm-x86/hvm/irq.h
@@ -122,6 +122,8 @@ void hvm_set_callback_via(struct domain *d, uint64_t via);
 
 int cpu_get_interrupt(struct vcpu *v, int *type);
 int cpu_has_pending_irq(struct vcpu *v);
+int get_isa_irq_vector(struct vcpu *vcpu, int isa_irq, int type);
+int is_isa_irq_masked(struct vcpu *v, int isa_irq);
 
 /*
  * Currently IA64 Xen doesn't support MSI. So for x86, we define this macro
