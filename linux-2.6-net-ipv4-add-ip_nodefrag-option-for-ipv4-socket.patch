From: Jiri Olsa <jolsa@redhat.com>
Date: Tue, 13 Jul 2010 13:46:38 -0400
Subject: [net] ipv4: add IP_NODEFRAG option for IPv4 socket
Message-id: <20100713134638.GB3842@jolsa.brq.redhat.com>
Patchwork-id: 26838
O-Subject: Re: [PATCH RHEL5] BZ#562220 net - IP_NODEFRAG option for IPv4 socket
Bugzilla: 562220
RH-Acked-by: Neil Horman <nhorman@redhat.com>
RH-Acked-by: Thomas Graf <tgraf@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>

Bugzilla: 562220
https://bugzilla.redhat.com/show_bug.cgi?id=562220

Description:
============
this patch is implementing IP_NODEFRAG option for IPv4 socket.
The reason is, there's no other way to send out the packet with user
customized header of the reassembly part.

Upstream status:
================
net-next-2.6 tree
- net - IP_NODEFRAG option for IPv4 socket
commit 7b2ff18ee7b0ec4bc3162f821e221781aaca48bd

Brew:
=====
http://brewweb.devel.redhat.com/brew/taskinfo?taskID=2588909

Tested:
=======
Tested with patched hping (--no-defrag option)
http://people.redhat.com/jolsa/562220/hping3-0.0.20051105-7nodefrag.x86_64.rpm

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/include/linux/in.h b/include/linux/in.h
index 94f557f..72f46fc 100644
--- a/include/linux/in.h
+++ b/include/linux/in.h
@@ -73,6 +73,7 @@ struct in_addr {
 #define IP_IPSEC_POLICY	16
 #define IP_XFRM_POLICY	17
 #define IP_PASSSEC	18
+#define IP_NODEFRAG	22
 
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
diff --git a/include/net/inet_sock.h b/include/net/inet_sock.h
index f4caad5..e6af272 100644
--- a/include/net/inet_sock.h
+++ b/include/net/inet_sock.h
@@ -129,7 +129,12 @@ struct inet_sock {
 				is_icsk:1,
 				freebind:1,
 				hdrincl:1,
+#ifdef __GENKSYMS__
 				mc_loop:1;
+#else
+				mc_loop:1,
+				nodefrag:1;
+#endif
 	int			mc_index;
 	__u32			mc_addr;
 	struct ip_mc_socklist	*mc_list;
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 27801d3..41a8429 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -308,6 +308,8 @@ lookup_protocol:
 	inet = inet_sk(sk);
 	inet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) == INET_PROTOSW_ICSK;
 
+	inet->nodefrag = 0;
+
 	if (SOCK_RAW == sock->type) {
 		inet->num = protocol;
 		if (IPPROTO_RAW == protocol)
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index e9180d9..2cdb9d2 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -418,7 +418,7 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			    (1<<IP_TTL) | (1<<IP_HDRINCL) | 
 			    (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) | 
 			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |
-			    (1<<IP_PASSSEC))) ||
+			    (1<<IP_PASSSEC) | (1<<IP_NODEFRAG))) ||
 				optname == IP_MULTICAST_TTL || 
 				optname == IP_MULTICAST_LOOP) { 
 		if (optlen >= sizeof(int)) {
@@ -534,6 +534,13 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 			}
 			inet->hdrincl = val ? 1 : 0;
 			break;
+		case IP_NODEFRAG:
+			if (sk->sk_type != SOCK_RAW) {
+				err = -ENOPROTOOPT;
+				break;
+			}
+			inet->nodefrag = val ? 1 : 0;
+			break;
 		case IP_MTU_DISCOVER:
 			if (val<0 || val>2)
 				goto e_inval;
diff --git a/net/ipv4/netfilter/ip_conntrack_standalone.c b/net/ipv4/netfilter/ip_conntrack_standalone.c
index f75f573..3b3a393 100644
--- a/net/ipv4/netfilter/ip_conntrack_standalone.c
+++ b/net/ipv4/netfilter/ip_conntrack_standalone.c
@@ -436,13 +436,17 @@ static unsigned int ip_conntrack_defrag(unsigned int hooknum,
 				        const struct net_device *out,
 				        int (*okfn)(struct sk_buff *))
 {
+	struct inet_sock *inet = inet_sk((*pskb)->sk);
+
+	if (inet && inet->nodefrag)
+		return NF_ACCEPT;
+
 #if !defined(CONFIG_IP_NF_NAT) && !defined(CONFIG_IP_NF_NAT_MODULE)
 	/* Previously seen (loopback)?  Ignore.  Do this before
            fragment check. */
 	if ((*pskb)->nfct)
 		return NF_ACCEPT;
 #endif
-
 	/* Gather fragments. */
 	if ((*pskb)->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
 		*pskb = ip_ct_gather_frags(*pskb,
