From: Paolo Bonzini <pbonzini@redhat.com>
Date: Wed, 23 Jun 2010 14:07:56 -0400
Subject: [virt] xen: add tracepoint for kernel pagefault event
Message-id: <1277302078-10425-2-git-send-email-pbonzini@redhat.com>
Patchwork-id: 26466
O-Subject: [RHEL5.5 PATCH 1/3] xen: add tracepoint for kernel pagefault event
Bugzilla: 561385
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Bugzilla: 561385

Brew build: https://brewweb.devel.redhat.com/taskinfo?taskID=2540880

This forward-ports the patch for BZ517133 so that it is available
in xen-enabled kernels too.

diff --git a/arch/i386/mm/fault-xen.c b/arch/i386/mm/fault-xen.c
index 1e3a18c..fef31ed 100644
--- a/arch/i386/mm/fault-xen.c
+++ b/arch/i386/mm/fault-xen.c
@@ -22,6 +22,7 @@
 #include <linux/highmem.h>
 #include <linux/module.h>
 #include <linux/kprobes.h>
+#include <trace/mm.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -424,30 +425,15 @@ static inline int vmalloc_fault(unsigned long address)
 	return 0;
 }
 
-/*
- * This routine handles page faults.  It determines the address,
- * and the problem, and then passes it off to one of the appropriate
- * routines.
- *
- * error_code:
- *	bit 0 == 0 means no page found, 1 means protection fault
- *	bit 1 == 0 means read, 1 means write
- *	bit 2 == 0 means kernel, 1 means user-mode
- *	bit 3 == 1 means use of reserved bit detected
- *	bit 4 == 1 means fault was an instruction fetch
- */
-fastcall void __kprobes do_page_fault(struct pt_regs *regs,
+static inline void __do_page_fault(struct pt_regs *regs,
+				      unsigned long address,
 				      unsigned long error_code)
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
-	unsigned long address;
 	int write, si_code;
 
-	/* get the address */
-        address = read_cr2();
-
 	/* Set the "privileged fault" bit to something sane. */
 	error_code &= ~4;
 	error_code |= (regs->xcs & 2) << 1;
@@ -667,7 +653,6 @@ no_context:
  * Oops. The kernel tried to access some bad page. We'll have to
  * terminate things with extreme prejudice.
  */
-
 	bust_spinlocks(1);
 
 	if (oops_may_print()) {
@@ -732,6 +717,32 @@ do_sigbus:
 	force_sig_info_fault(SIGBUS, BUS_ADRERR, address, tsk);
 }
 
+/*
+ * This routine handles page faults.  It determines the address,
+ * and the problem, and then passes it off to one of the appropriate
+ * routines.
+ *
+ * error_code:
+ *	bit 0 == 0 means no page found, 1 means protection fault
+ *	bit 1 == 0 means read, 1 means write
+ *	bit 2 == 0 means kernel, 1 means user-mode
+ *	bit 3 == 1 means use of reserved bit detected
+ *	bit 4 == 1 means fault was an instruction fetch
+ */
+fastcall void __kprobes do_page_fault(struct pt_regs *regs,
+				      unsigned long error_code)
+{
+	unsigned long address;
+
+	/* get the address */
+	address = read_cr2();
+
+	__do_page_fault(regs, address, error_code);
+
+	if (!user_mode_vm(regs))
+		trace_mm_kernel_pagefault(current, address, regs->eip);
+}
+
 #ifndef CONFIG_X86_PAE
 void vmalloc_sync_all(void)
 {
diff --git a/arch/x86_64/mm/fault-xen.c b/arch/x86_64/mm/fault-xen.c
index 8a9a09d..0108f3b 100644
--- a/arch/x86_64/mm/fault-xen.c
+++ b/arch/x86_64/mm/fault-xen.c
@@ -23,6 +23,7 @@
 #include <linux/compiler.h>
 #include <linux/module.h>
 #include <linux/kprobes.h>
+#include <trace/mm.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -386,18 +387,13 @@ static int spurious_fault(struct pt_regs *regs,
 	return 1;
 }
 
-/*
- * This routine handles page faults.  It determines the address,
- * and the problem, and then passes it off to one of the appropriate
- * routines.
- */
-asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
+static inline void __do_page_fault(struct pt_regs *regs,
+					unsigned long address,
 					unsigned long error_code)
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
-	unsigned long address;
 	const struct exception_table_entry *fixup;
 	int write;
 	unsigned long flags;
@@ -410,10 +406,6 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 	mm = tsk->mm;
 	prefetchw(&mm->mmap_sem);
 
-	/* get the address */
-	address = HYPERVISOR_shared_info->vcpu_info[
-		smp_processor_id()].arch.cr2;
-
 	info.si_code = SEGV_MAPERR;
 
 
@@ -621,7 +613,6 @@ no_context:
  * Oops. The kernel tried to access some bad page. We'll have to
  * terminate things with extreme prejudice.
  */
-
 	flags = oops_begin();
 
 	if (address < PAGE_SIZE)
@@ -673,6 +664,26 @@ do_sigbus:
 	return;
 }
 
+/*
+ * This routine handles page faults.  It determines the address,
+ * and the problem, and then passes it off to one of the appropriate
+ * routines.
+ */
+asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
+					unsigned long error_code)
+{
+	unsigned long address;
+
+	/* get the address */
+	address = HYPERVISOR_shared_info->vcpu_info[
+		smp_processor_id()].arch.cr2;
+
+	__do_page_fault(regs, address, error_code);
+
+	if (!user_mode_vm(regs))
+		trace_mm_kernel_pagefault(current, address, regs->rip);
+}
+	
 DEFINE_SPINLOCK(pgd_lock);
 struct page *pgd_list;
 
