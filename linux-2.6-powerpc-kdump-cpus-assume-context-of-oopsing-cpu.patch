From: Steve Best <sbest@redhat.com>
Date: Mon, 15 Nov 2010 15:10:45 -0500
Subject: [powerpc] kdump: CPUs assume context of oopsing CPU
Message-id: <20101115150540.13980.47111.sendpatchset@squad5-lp1.lab.bos.redhat.com>
Patchwork-id: 29444
O-Subject: [PATCH RHEL5.6 BZ509792] powerpc/kdump: CPUs assume the context of
	the oopsing CPU
Bugzilla: 509792
RH-Acked-by: Neil Horman <nhorman@redhat.com>
RH-Acked-by: David Howells <dhowells@redhat.com>
RH-Acked-by: Stefan Assmann <sassmann@redhat.com>

RHBZ#:
------
https://bugzilla.redhat.com/show_bug.cgi?id=509792

Description:
------------
We wrap the crash_shutdown_handles[] calls with longjmp/setjmp, so if any
of them fault we can recover. The problem is we add a hook to the debugger
fault handler hook which calls longjmp unconditionally.

This first part of kdump is run before we marshall the other CPUs, so there
is a very good chance some CPU on the box is going to page fault. And when
it does it hits the longjmp code and assumes the context of the oopsing CPU.
The machine gets very confused when it has 10 CPUs all with the same stack,
all thinking they have the same CPU id. I get even more confused trying
to debug it.

The patch below adds crash_shutdown_cpu and uses it to specify which cpu is
in the protected region. Since it can only be -1 or the oopsing CPU, we don't
need to use memory barriers since it is only valid on the local CPU - no other
CPU will ever see a value that matches it's local CPU id.

Eventually we should switch the order and marshall all CPUs before doing the
crash_shutdown_handles[] calls, but that is a bigger fix.

Signed-off-by: Anton Blanchard <anton@samba.org>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

RHEL Version Found:
-------------------
RHEL 5.6

kABI Status:
------------
No symbols were harmed.

Brew:
-----
http://brewweb.devel.redhat.com/brew/taskinfo?taskID=2873327

Upstream Status:
----------------
back port from

http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;
a=commit;h=0644079410065567e3bb31fcb8e6441f2b7685a9

Test Status:
------------
Han Pingtian helped me test this.

===============================================================
Steve Best
IBM on-site partner

Proposed Patch:

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/arch/powerpc/kernel/crash.c b/arch/powerpc/kernel/crash.c
index 99fbabe..b2725ac 100644
--- a/arch/powerpc/kernel/crash.c
+++ b/arch/powerpc/kernel/crash.c
@@ -402,10 +402,12 @@ int crash_shutdown_unregister(crash_shutdown_t handler)
 EXPORT_SYMBOL(crash_shutdown_unregister);
 
 static unsigned long crash_shutdown_buf[JMP_BUF_LEN];
+static int crash_shutdown_cpu = -1;
 
 static int handle_fault(struct pt_regs *regs)
 {
-	longjmp(crash_shutdown_buf, 1);
+	if (crash_shutdown_cpu == smp_processor_id())
+		longjmp(crash_shutdown_buf, 1);
 	return 0;
 }
 
@@ -443,6 +445,7 @@ void default_machine_crash_shutdown(struct pt_regs *regs)
 	 */
 	old_handler = __debugger_fault_handler;
 	__debugger_fault_handler = handle_fault;
+	crash_shutdown_cpu = smp_processor_id();
 	for (i = 0; crash_shutdown_handles[i]; i++) {
 		if (setjmp(crash_shutdown_buf) == 0) {
 			/*
@@ -461,6 +464,7 @@ void default_machine_crash_shutdown(struct pt_regs *regs)
 			__delay(200);
 		}
 	}
+	crash_shutdown_cpu = -1;
 	__debugger_fault_handler = old_handler;
 
 	/*
