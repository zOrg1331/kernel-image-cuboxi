From: Josef Bacik <jbacik@redhat.com>
Date: Tue, 10 Feb 2009 13:49:30 -0500
Subject: [gfs2] remove generic aops stuff
Message-id: 1234291777-15344-18-git-send-email-jbacik@redhat.com
O-Subject: [PATCH 17/24] [RHEL 5.4] gfs2: remove generic aops stuff
Bugzilla: 445433
RH-Acked-by: Bob Peterson <rpeterso@redhat.com>
RH-Acked-by: Steven Whitehouse <swhiteho@redhat.com>

GFS2 had backported some of the aops stuff for its own use, this patch removes
it all since we've pulled it into the generic code.  This patch is in reference
to bz 445433.

Signed-off-by: Josef Bacik <jbacik@redhat.com>

diff --git a/fs/gfs2/ops_address.c b/fs/gfs2/ops_address.c
index 8aadb1e..4fbfe1f 100644
--- a/fs/gfs2/ops_address.c
+++ b/fs/gfs2/ops_address.c
@@ -36,28 +36,6 @@
 #include "util.h"
 #include "glops.h"
 
-static DEFINE_PER_CPU(struct pagevec, lru_add_pvecs) = { 0, };
-
-static void fastcall gfs2_lru_cache_add(struct page *page)
-{
-        struct pagevec *pvec = &get_cpu_var(lru_add_pvecs);
-
-        page_cache_get(page);
-        if (!pagevec_add(pvec, page))
-                __pagevec_lru_add(pvec);
-        put_cpu_var(lru_add_pvecs);
-}
-
-static int gfs2_add_to_page_cache_lru(struct page *page,
-				      struct address_space *mapping,
-				      pgoff_t offset, gfp_t gfp_mask)
-{
-	int ret = add_to_page_cache(page, mapping, offset, gfp_mask);
-	if (ret == 0)
-		gfs2_lru_cache_add(page);
-	return ret;
-}
-
 static void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,
 				   unsigned int from, unsigned int to)
 {
@@ -683,33 +661,6 @@ out_uninit:
 	return ret;
 }
 
-/*
- * Find or create a page at the given pagecache position. Return the locked
- * page. This function is specifically for buffered writes.
- */
-static struct page *__grab_cache_page(struct address_space *mapping,
-			       unsigned long index)
-{
-	int status;
-	struct page *page;
-repeat:
-	page = find_lock_page(mapping, index);
-	if (likely(page))
-		return page;
-
-	page = page_cache_alloc(mapping);
-	if (!page)
-		return NULL;
-	status = gfs2_add_to_page_cache_lru(page, mapping, index, GFP_KERNEL);
-	if (unlikely(status)) {
-		page_cache_release(page);
-		if (status == -EEXIST)
-			goto repeat;
-		return NULL;
-	}
-	return page;
-}
-
 /**
  * gfs2_write_begin - Begin to write to a file
  * @file: The file to write to
@@ -903,153 +854,6 @@ static int gfs2_stuffed_write_end(struct inode *inode, struct buffer_head *dibh,
 	return copied;
 }
 
-/*
- * If a page has any new buffers, zero them out here, and mark them uptodate
- * and dirty so they'll be written out (in order to prevent uninitialised
- * block data from leaking). And clear the new bit.
- */
-static void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)
-{
-	unsigned int block_start, block_end;
-	struct buffer_head *head, *bh;
-
-	BUG_ON(!PageLocked(page));
-	if (!page_has_buffers(page))
-		return;
-
-	bh = head = page_buffers(page);
-	block_start = 0;
-	do {
-		block_end = block_start + bh->b_size;
-
-		if (buffer_new(bh)) {
-			if (block_end > from && block_start < to) {
-				if (!PageUptodate(page)) {
-					unsigned start, size;
-
-					start = max(from, block_start);
-					size = min(to, block_end) - start;
-
-					zero_user(page, start, size);
-					set_buffer_uptodate(bh);
-				}
-
-				clear_buffer_new(bh);
-				mark_buffer_dirty(bh);
-			}
-		}
-
-		block_start = block_end;
-		bh = bh->b_this_page;
-	} while (bh != head);
-}
-
-static int __block_commit_write(struct inode *inode, struct page *page,
-		unsigned from, unsigned to)
-{
-	unsigned block_start, block_end;
-	int partial = 0;
-	unsigned blocksize;
-	struct buffer_head *bh, *head;
-
-	blocksize = 1 << inode->i_blkbits;
-
-	for(bh = head = page_buffers(page), block_start = 0;
-	    bh != head || !block_start;
-	    block_start=block_end, bh = bh->b_this_page) {
-		block_end = block_start + blocksize;
-		if (block_end <= from || block_start >= to) {
-			if (!buffer_uptodate(bh))
-				partial = 1;
-		} else {
-			set_buffer_uptodate(bh);
-			mark_buffer_dirty(bh);
-		}
-		clear_buffer_new(bh);
-	}
-
-	/*
-	 * If this is a partial write which happened to make all buffers
-	 * uptodate then we can optimize away a bogus readpage() for
-	 * the next read(). Here we 'discover' whether the page went
-	 * uptodate as a result of this (potentially partial) write.
-	 */
-	if (!partial)
-		SetPageUptodate(page);
-	return 0;
-}
-
-static int block_write_end(struct file *file, struct address_space *mapping,
-			loff_t pos, unsigned len, unsigned copied,
-			struct page *page, void *fsdata)
-{
-	struct inode *inode = mapping->host;
-	unsigned start;
-
-	start = pos & (PAGE_CACHE_SIZE - 1);
-
-	if (unlikely(copied < len)) {
-		/*
-		 * The buffers that were written will now be uptodate, so we
-		 * don't have to worry about a readpage reading them and
-		 * overwriting a partial write. However if we have encountered
-		 * a short write and only partially written into a buffer, it
-		 * will not be marked uptodate, so a readpage might come in and
-		 * destroy our partial write.
-		 *
-		 * Do the simplest thing, and just treat any short write to a
-		 * non uptodate page as a zero-length write, and force the
-		 * caller to redo the whole thing.
-		 */
-		if (!PageUptodate(page))
-			copied = 0;
-
-		page_zero_new_buffers(page, start+copied, start+len);
-	}
-	flush_dcache_page(page);
-
-	/* This could be a short (even 0-length) commit */
-	__block_commit_write(inode, page, start, start+copied);
-
-	return copied;
-}
-
-static int generic_write_end(struct file *file, struct address_space *mapping,
-			loff_t pos, unsigned len, unsigned copied,
-			struct page *page, void *fsdata)
-{
-	struct inode *inode = mapping->host;
-	int i_size_changed = 0;
-
-	copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);
-
-	/*
-	 * No need to use i_size_read() here, the i_size
-	 * cannot change under us because we hold i_mutex.
-	 *
-	 * But it's important to update i_size while still holding page lock:
-	 * page writeout could otherwise come in and zero beyond i_size.
-	 */
-	if (pos+copied > inode->i_size) {
-		i_size_write(inode, pos+copied);
-		i_size_changed = 1;
-	}
-
-	unlock_page(page);
-	page_cache_release(page);
-
-	/*
-	 * Don't mark the inode dirty under page lock. First, it unnecessarily
-	 * makes the holding time of page lock longer. Second, it forces lock
-	 * ordering of page lock and transaction start for journaling
-	 * filesystems.
-	 */
-	if (i_size_changed)
-		mark_inode_dirty(inode);
-
-	return copied;
-}
-
 /**
  * gfs2_write_end
  * @file: The file to write to
diff --git a/fs/gfs2/ops_file.c b/fs/gfs2/ops_file.c
index c9ed19b..5dcde81 100644
--- a/fs/gfs2/ops_file.c
+++ b/fs/gfs2/ops_file.c
@@ -712,7 +712,7 @@ again:
 		 * to check that the address is actually valid, when atomic
 		 * usercopies are used, below.
 		 */
-		if (unlikely(iov_iter_fault_in_readable(i))) {
+		if (unlikely(iov_iter_fault_in_readable(i, bytes))) {
 			status = -EFAULT;
 			break;
 		}
