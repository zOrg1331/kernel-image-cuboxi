From: Chad Dupuis <cdupuis@redhat.com>
Date: Tue, 20 Jul 2010 15:31:41 -0400
Subject: [net] qlcnic: clear device reset state after fw recovery
Message-id: <20100720153047.2978.50894.sendpatchset@localhost.localdomain>
Patchwork-id: 26963
O-Subject: [RHEL 5.6 PATCH 4/16] qlcnic: clear device reset state after fw
	recovery
Bugzilla: 562723
RH-Acked-by: David S. Miller <davem@redhat.com>

Bugzilla
========

562723

Upstream Status
===============

net-2.6 commit id 1b95a839587f40abab2f9cb3e5254dc821b9829b

Description
===========

>From d6762f3b09d7313ac2d6d47739c573cc5a486d5a Mon Sep 17 00:00:00 2001
From: Amit Kumar Salecha <amit.salecha@qlogic.com>
Date: Mon, 1 Feb 2010 05:24:56 +0000
Subject: [PATCH] qlcnic: clear device reset state after fw recovery

o After firmware recovery, clear device reset state transition register.
  Otherwise firmware reload can occur unnecessary.

Signed-off-by: Amit Kumar Salecha <amit.salecha@qlogic.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/net/qlcnic/qlcnic_main.c b/drivers/net/qlcnic/qlcnic_main.c
index 7cbf74b..3f0edb3 100644
--- a/drivers/net/qlcnic/qlcnic_main.c
+++ b/drivers/net/qlcnic/qlcnic_main.c
@@ -1881,6 +1881,23 @@ qlcnic_set_drv_state(struct qlcnic_adapter *adapter, int state)
 	qlcnic_api_unlock(adapter);
 }
 
+static int
+qlcnic_clr_drv_state(struct qlcnic_adapter *adapter)
+{
+	u32  val;
+
+	if (qlcnic_api_lock(adapter))
+		return -EBUSY;
+
+	val = QLCRD32(adapter, QLCNIC_CRB_DRV_STATE);
+	val &= ~((u32)0x3 << (adapter->portnum * 4));
+	QLCWR32(adapter, QLCNIC_CRB_DRV_STATE, val);
+
+	qlcnic_api_unlock(adapter);
+
+	return 0;
+}
+
 static void
 qlcnic_clr_all_drv_state(struct qlcnic_adapter *adapter)
 {
@@ -2132,7 +2149,10 @@ qlcnic_attach_work(void *data)
 done:
 	adapter->fw_fail_cnt = 0;
 	clear_bit(__QLCNIC_RESETTING, &adapter->state);
-	qlcnic_schedule_work(adapter, qlcnic_fw_poll_work, FW_POLL_DELAY);
+
+	if (!qlcnic_clr_drv_state(adapter))
+		qlcnic_schedule_work(adapter, qlcnic_fw_poll_work,
+							FW_POLL_DELAY);
 }
 
 static int
