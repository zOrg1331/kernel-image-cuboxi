From: Tetsu Yamamoto <tyamamot@redhat.com>
Date: Mon, 7 Jan 2008 17:15:45 -0500
Subject: [xen] ia64: warning fixes when checking EFI memory
Message-id: 4782A491.1000902@redhat.com
O-Subject: Re: [RHEL5.2 PATCH] [Xen] Many pointless warnning are happend when dom0 accesses UC|WB attribute memory
Bugzilla: 245566

Jarod Wilson wrote::
> Stephen C. Tweedie wrote:
>> Hi,
>>
>> On Thu, 2008-01-03 at 15:41 -0500, Tetsu Yamamoto wrote:
>>> These patches fix BZ#245566.
>>> https://bugzilla.redhat.com/show_bug.cgi?id=245566
>>>
>>> These are backported from the upstream to clean up warnings by fixing
>>> the check of EFI memory attribute.
>>>
>>> - [IA64] Update efi.c and efi.h to linux-2.6.21
>>> http://xenbits.xensource.com/ext/xen-ia64-unstable.hg?rev/301267d0db12
>>> - [IA64] Cleanup warnings for UC accesses to UC|WB pages
>>> http://xenbits.xensource.com/ext/xen-ia64-unstable.hg?rev/2372c3fbf7d2

Acked-by: Jarod Wilson <jwilson@redhat.com>
Acked-by: "Stephen C. Tweedie" <sct@redhat.com>
Acked-by: Bill Burns <bburns@redhat.com>

diff --git a/arch/ia64/xen/mm.c b/arch/ia64/xen/mm.c
index 42d7d52..6931be5 100644
--- a/arch/ia64/xen/mm.c
+++ b/arch/ia64/xen/mm.c
@@ -182,6 +182,7 @@
 static void domain_page_flush_and_put(struct domain* d, unsigned long mpaddr,
                                       volatile pte_t* ptep, pte_t old_pte, 
                                       struct page_info* page);
+static int efi_ucwb(unsigned long physaddr, unsigned long size);
 
 extern unsigned long ia64_iobase;
 
@@ -492,7 +493,9 @@ u64 translate_domain_pte(u64 pteval, u64 address, u64 itir__, u64* logps,
 			   This can happen when domU tries to touch i/o
 			   port space.  Also prevents possible address
 			   aliasing issues.  */
-			if (!(mpaddr - IO_PORTS_PADDR < IO_PORTS_SIZE))
+			if (!(mpaddr - IO_PORTS_PADDR < IO_PORTS_SIZE) &&
+			    /* and also except UC|WB page */
+			    (d != dom0 || !efi_ucwb(mpaddr, PAGE_SIZE))) 
 				gdprintk(XENLOG_WARNING, "Warning: UC to WB "
 				         "for mpaddr=%lx\n", mpaddr);
 			pteval = (pteval & ~_PAGE_MA_MASK) | _PAGE_MA_WB;
@@ -1020,6 +1023,46 @@ assign_domain_same_page(struct domain *d,
     }
 }
 
+static int
+efi_ucwb(unsigned long physaddr, unsigned long size)
+{
+    void *efi_map_start, *efi_map_end;
+    u64 efi_desc_size;
+    void* p;
+
+    efi_map_start = __va(ia64_boot_param->efi_memmap);
+    efi_map_end   = efi_map_start + ia64_boot_param->efi_memmap_size;
+    efi_desc_size = ia64_boot_param->efi_memdesc_size;
+
+    for (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {
+        efi_memory_desc_t* md = (efi_memory_desc_t *)p;
+        unsigned long start = md->phys_addr;
+        unsigned long end = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT);
+
+        if (start <= physaddr && physaddr < end) {
+            if ((physaddr + size) > end) {
+                gdprintk(XENLOG_INFO, "%s: physaddr 0x%lx size = 0x%lx\n",
+                        __func__, physaddr, size);
+                return 0;
+            }
+
+            // for UC|WB space
+            if( md->attribute & EFI_MEMORY_WB &&
+                md->attribute & EFI_MEMORY_UC )
+                    return 1;
+
+            return 0;
+        }
+
+        if (physaddr < start) {
+            break;
+        }
+    }
+
+    return 0;
+}
+
+
 int
 efi_mmio(unsigned long physaddr, unsigned long size)
 {
