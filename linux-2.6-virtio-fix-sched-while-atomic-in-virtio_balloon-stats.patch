From: Amit Shah <amit.shah@redhat.com>
Date: Tue, 31 Aug 2010 05:35:04 -0400
Subject: [virtio] fix sched while atomic in virtio_balloon stats
Message-id: <be651f2e9ec4fc3ec257aeafeb5ea7209ff06e80.1283231512.git.amit.shah@redhat.com>
Patchwork-id: 27955
O-Subject: [RHEL5.6 PATCH 2/3] virtio: Fix scheduling while atomic in
	virtio_balloon stats
Bugzilla: 601692
RH-Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>

From: Adam Litke <agl@us.ibm.com>

This is a fix for my earlier patch: "virtio: Add memory statistics reporting to
the balloon driver (V4)".

I discovered that all_vm_events() can sleep and therefore stats collection
cannot be done in interrupt context.  One solution is to handle the interrupt
by noting that stats need to be collected and waking the existing vballoon
kthread which will complete the work via stats_handle_request().  Rusty, is
this a saner way of doing business?

There is one issue that I would like a broader opinion on.  In stats_request, I
update vb->need_stats_update and then wake up the kthread.  The kthread uses
vb->need_stats_update as a condition variable.  Do I need a memory barrier
between the update and wake_up to ensure that my kthread sees the correct
value?  My testing suggests that it is not needed but I would like some
confirmation from the experts.

Signed-off-by: Adam Litke <agl@us.ibm.com>
To: Rusty Russell <rusty@rustcorp.com.au>
Cc: Anthony Liguori <aliguori@linux.vnet.ibm.com>
Cc: linux-kernel@vger.kernel.org
Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
(cherry picked from commit 1f34c71afe5115e77a49c4e67720a66e27053e54)

Signed-off-by: Amit Shah <amit.shah@redhat.com>

diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
index 7234421..3341851 100644
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -53,6 +53,7 @@ struct virtio_balloon
 	u32 pfns[256];
 
 	/* Memory statistics */
+	int need_stats_update;
 	struct virtio_balloon_stat stats[VIRTIO_BALLOON_S_NR];
 };
 
@@ -196,20 +197,30 @@ static void update_balloon_stats(struct virtio_balloon *vb)
  * the stats queue operates in reverse.  The driver initializes the virtqueue
  * with a single buffer.  From that point forward, all conversations consist of
  * a hypervisor request (a call to this function) which directs us to refill
- * the virtqueue with a fresh stats buffer.
+ * the virtqueue with a fresh stats buffer.  Since stats collection can sleep,
+ * we notify our kthread which does the actual work via stats_handle_request().
  */
-static void stats_ack(struct virtqueue *vq)
+static void stats_request(struct virtqueue *vq)
 {
 	struct virtio_balloon *vb;
 	unsigned int len;
-	struct scatterlist sg;
 
 	vb = vq->vq_ops->get_buf(vq, &len);
 	if (!vb)
 		return;
+	vb->need_stats_update = 1;
+	wake_up(&vb->config_change);
+}
+
+static void stats_handle_request(struct virtio_balloon *vb)
+{
+	struct virtqueue *vq;
+	struct scatterlist sg;
 
+	vb->need_stats_update = 0;
 	update_balloon_stats(vb);
 
+	vq = vb->stats_vq;
 	sg_init_one(&sg, vb->stats, sizeof(vb->stats));
 	if (vq->vq_ops->add_buf(vq, &sg, 1, 0, vb) < 0)
 		BUG();
@@ -252,8 +263,11 @@ static int balloon(void *_vballoon)
 		try_to_freeze();
 		wait_event_interruptible(vb->config_change,
 					 (diff = towards_target(vb)) != 0
+					 || vb->need_stats_update
 					 || kthread_should_stop()
 					 || freezing(current));
+		if (vb->need_stats_update)
+			stats_handle_request(vb);
 		if (diff > 0)
 			fill_balloon(vb, diff);
 		else if (diff < 0)
@@ -267,7 +281,7 @@ static int virtballoon_probe(struct virtio_device *vdev)
 {
 	struct virtio_balloon *vb;
 	struct virtqueue *vqs[3];
-	vq_callback_t *callbacks[] = { balloon_ack, balloon_ack, stats_ack };
+	vq_callback_t *callbacks[] = { balloon_ack, balloon_ack, stats_request };
 	const char *names[] = { "inflate", "deflate", "stats" };
 	int err, nvqs;
 
