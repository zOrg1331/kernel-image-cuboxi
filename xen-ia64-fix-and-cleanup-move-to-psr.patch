From: Tetsu Yamamoto <tyamamot@redhat.com>
Date: Fri, 22 Aug 2008 11:19:20 -0400
Subject: [xen] ia64: fix and cleanup move to psr
Message-id: 20080822151920.13356.5701.sendpatchset@pq0-1.lab.bos.redhat.com
O-Subject: [RHEL5.3 PATCH 1/3] xen-ia64: Fix and cleanup move to psr
Bugzilla: 447453
RH-Acked-by: Bill Burns <bburns@redhat.com>
RH-Acked-by: Jarod Wilson <jwilson@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

bz447453
# HG changeset patch
# User Alex Williamson <alex.williamson@hp.com>
# Date 1206390352 21600
# Node ID dba5f548b8943b0e0b00925cf362633a3585de5d
# Parent  bcf06182b795eb39095e7aa32304577047aa1c59
[IA64] Fix and cleanup move to psr

We need to both set and clear bits

Signed-off-by: Akio Takebe <takebe_akio@jp.fujitsu.com>
Signed-off-by: Alex Williamson <alex.williamson@hp.com>

diff --git a/arch/ia64/xen/vcpu.c b/arch/ia64/xen/vcpu.c
index 9b967c3..4394bc9 100644
--- a/arch/ia64/xen/vcpu.c
+++ b/arch/ia64/xen/vcpu.c
@@ -397,54 +397,35 @@ IA64FAULT vcpu_set_psr_l(VCPU * vcpu, u64 val)
 
 	newpsr = *(struct ia64_psr *)&val;
 	ipsr = (struct ia64_psr *)&regs->cr_ipsr;
-	// just handle psr.up and psr.pp for now
-	//if (val & ~(IA64_PSR_PP | IA64_PSR_UP | IA64_PSR_SP))
-	//	return IA64_ILLOP_FAULT;
-	// however trying to set other bits can't be an error as it is in ssm
-	if (newpsr.dfh) {
-		ipsr->dfh = 1;
-		PSCB(vcpu, vpsr_dfh) = 1;
-	} else {
-		ipsr->dfh = PSCB(vcpu, hpsr_dfh);
-		PSCB(vcpu, vpsr_dfh) = 0;
-	}       
-	if (newpsr.dfl)
-		ipsr->dfl = 1;
-	if (newpsr.pp) {
-		ipsr->pp = 1;
-		PSCB(vcpu, vpsr_pp) = 1;
-	} else {
-		ipsr->pp = 1;
-		PSCB(vcpu, vpsr_pp) = 0;
-	}
-	if (newpsr.up)
-		ipsr->up = 1;
-	if (newpsr.sp)
-		ipsr->sp = 1;
-	if (newpsr.i) {
-		if (vcpu->vcpu_info->evtchn_upcall_mask)
-			enabling_interrupts = 1;
-		vcpu->vcpu_info->evtchn_upcall_mask = 0;
-	}
-	if (newpsr.ic)
-		PSCB(vcpu, interrupt_collection_enabled) = 1;
-	if (newpsr.mfl)
-		ipsr->mfl = 1;
-	if (newpsr.mfh)
-		ipsr->mfh = 1;
-	if (newpsr.ac)
-		ipsr->ac = 1;
-	if (newpsr.up)
-		ipsr->up = 1;
-	if (newpsr.dt && newpsr.rt)
-		vcpu_set_metaphysical_mode(vcpu, FALSE);
-	else
-		vcpu_set_metaphysical_mode(vcpu, TRUE);
-	if (newpsr.be)
-		ipsr->be = 1;
+
+	ipsr->be = newpsr.be;
+	ipsr->up = newpsr.up;
+	ipsr->ac = newpsr.ac;
+	ipsr->mfl = newpsr.mfl;
+	ipsr->mfh = newpsr.mfh;
+
+	PSCB(vcpu, interrupt_collection_enabled) = newpsr.ic;
+
+	if (newpsr.i && vcpu->vcpu_info->evtchn_upcall_mask)
+		enabling_interrupts = 1;
+
+	vcpu->vcpu_info->evtchn_upcall_mask = !(newpsr.i);
+
+	vcpu_set_metaphysical_mode(vcpu, !(newpsr.dt && newpsr.rt));
+
+	ipsr->dfl = newpsr.dfl;
+	PSCB(vcpu, vpsr_dfh) = newpsr.dfh;
+	ipsr->dfh = newpsr.dfh ? 1 : PSCB(vcpu, hpsr_dfh);
+
+	ipsr->sp = newpsr.sp;
+
+	/* xenoprof: Don't change ipsr->pp, it is manipulated by xenoprof */
+	PSCB(vcpu, vpsr_pp) = newpsr.pp;
+
 	if (enabling_interrupts &&
 	    vcpu_check_pending_interrupts(vcpu) != SPURIOUS_VECTOR)
 		PSCB(vcpu, pending_interruption) = 1;
+
 	return IA64_NO_FAULT;
 }
 
