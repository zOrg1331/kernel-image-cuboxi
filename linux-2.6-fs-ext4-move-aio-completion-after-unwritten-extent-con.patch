From: Eric Sandeen <sandeen@redhat.com>
Date: Thu, 2 Sep 2010 17:47:59 -0400
Subject: [fs] ext4: move aio completion after unwritten extent con
Message-id: <4C7FE34F.3040408@redhat.com>
Patchwork-id: 28026
O-Subject: [RHEL5.6 PATCH 3/3] ext4: move aio completion after unwritten extent
	conversion
Bugzilla: 617690
RH-Acked-by: Dave Chinner <dchinner@redhat.com>

For Bug 617690 -
ext4 and xfs wrong data returned on read after write if file size was changed with ftruncate

See also kernel.org bz https://bugzilla.kernel.org/show_bug.cgi?id=16165

(note: this applies after the big ext4 update)

Backport of:

commit 5b3ff237bef43b9e7fb7d1eb858e29b73fd664f9
Author: jiayingz@google.com (Jiaying Zhang) <>
Date:   Tue Jul 27 11:56:06 2010 -0400

    ext4: move aio completion after unwritten extent conversion

    This patch is to be applied upon Christoph's "direct-io: move aio_complete
    into ->end_io" patch. It adds iocb and result fields to struct ext4_io_end_t,
    so that we can call aio_complete from  ext4_end_io_nolock() after the extent
    conversion has finished.

    I have verified with Christoph's aio-dio test that used to fail after a few
    runs on an original kernel but now succeeds on the patched kernel.

    See http://thread.gmane.org/gmane.comp.file-systems.ext4/19659 for details.

    Signed-off-by: Jiaying Zhang <jiayingz@google.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index fefea9c..1bb2b3c 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -125,13 +125,15 @@ struct ext4_allocation_request {
 };
 #define	DIO_AIO_UNWRITTEN	0x1
 typedef struct ext4_io_end {
-	struct list_head	list;		/* per-file finished AIO list */
+	struct list_head	list;		/* per-file finished IO list */
 	struct inode		*inode;		/* file being written to */
 	unsigned int		flag;		/* unwritten or not */
 	int			error;		/* I/O error code */
 	loff_t			offset;		/* offset in the file */
 	ssize_t			size;		/* size of the extent */
 	struct work_struct	work;		/* data work queue */
+	struct kiocb		*iocb;		/* iocb struct for AIO */
+	int			result;		/* error value for AIO */
 } ext4_io_end_t;
 
 /*
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index b8e48ea..8a3f138 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -3629,6 +3629,8 @@ static int ext4_end_aio_dio_nolock(ext4_io_end_t *io)
 		return ret;
 	}
 
+	if (io->iocb)
+		aio_complete(io->iocb, io->result, 0);
 	/* clear the DIO AIO unwritten flag */
 	io->flag = 0;
 	return ret;
@@ -3724,6 +3726,8 @@ static ext4_io_end_t *ext4_init_io_end (struct inode *inode)
 		io->offset = 0;
 		io->size = 0;
 		io->error = 0;
+		io->iocb = NULL;
+		io->result = 0;
 		INIT_WORK(&io->work, ext4_end_aio_dio_work, io);
 		INIT_LIST_HEAD(&io->list);
 	}
@@ -3755,11 +3759,18 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
 	if (io_end->flag != DIO_AIO_UNWRITTEN){
 		ext4_free_io_end(io_end);
 		iocb->private = NULL;
-		goto out;
+out:
+		if (is_async)
+			aio_complete(iocb, ret, 0);
+		return;
 	}
 
 	io_end->offset = offset;
 	io_end->size = size;
+	if (is_async) {
+		io_end->iocb = iocb;
+		io_end->result = ret;
+	}
 	wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;
 
 	spin_lock_irqsave(&ei->i_completed_io_lock, flags);
@@ -3771,9 +3782,6 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
 	/* queue the work to convert unwritten extents to written */
 	queue_work(wq, &io_end->work);
 	iocb->private = NULL;
-out:
-	if (is_async)
-		aio_complete(iocb, ret, 0);
 }
 /*
  * For ext4 extent files, ext4 will do direct-io write to holes,
