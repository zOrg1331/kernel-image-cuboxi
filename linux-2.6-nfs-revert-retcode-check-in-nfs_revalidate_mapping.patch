From: Jeff Layton <jlayton@redhat.com>
Date: Tue, 20 Apr 2010 16:43:13 -0400
Subject: [nfs] revert retcode check in nfs_revalidate_mapping()
Message-id: <1271781793-21756-1-git-send-email-jlayton@redhat.com>
Patchwork-id: 24262
O-Subject: [RHEL5 PATCH] BZ#557423: nfs: revert retcode check in
	nfs_revalidate_mapping()
Bugzilla: 557423
RH-Acked-by: Steve Dickson <SteveD@redhat.com>

From: Guru Anbalagane <guru.anbalagane@oracle.com>

When I did the patch for bug 511170, I backported a couple of patches
straight from upstream. One of those patches added a check for an error
return from invalidate_inode_pages2 (which is now
invalidate_inode_pages3 in RHEL5) in the pagecache revalidation
codepath. If that function returns an error, the patch for 511170 caused
that error to be propagated up to the caller.

This is more "correct", but it turns out that this function can easily
return an error due to the page writeback flag being set w/o the page
lock being held. This manifested itself as spurious -EIO errors when
multiple tasks are simultaneously reading from and writing to the same
file on NFS. This problem was fixed upstream by ensuring that the page
lock was held before allowing nfs to set the writeback flag. Those
patches are pretty invasive though. A far simpler fix is to revert the
part of the patch for 511170 that checks for errors in this codepath.

The following patch was provided by some of the Oracle developers and
fixes this issue in the testing I've done.

Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: Guru Anbalagane <guru.anbalagane@oracle.com>

diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 863c29b..5dd8ada 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -734,14 +734,9 @@ int nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping)
 
 	if (nfsi->cache_validity & NFS_INO_INVALID_DATA) {
 		if (mapping->nrpages != 0) {
-			if (S_ISREG(inode->i_mode)) {
-				ret = nfs_sync_mapping(mapping);
-				if (ret < 0)
-					goto out;
-			}
-			ret = invalidate_inode_pages3(mapping);
-			if (ret < 0)
-				goto out;
+			if (S_ISREG(inode->i_mode))
+				nfs_sync_mapping(mapping);
+			invalidate_inode_pages3(mapping);
 		}
 		spin_lock(&inode->i_lock);
 		nfsi->cache_validity &= ~NFS_INO_INVALID_DATA;
