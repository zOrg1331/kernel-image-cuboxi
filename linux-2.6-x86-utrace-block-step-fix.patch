From: Jerome Marchand <jmarchan@redhat.com>
Date: Mon, 22 Mar 2010 16:24:31 -0400
Subject: [x86] utrace: block-step fix
Message-id: <4BA799BF.40105@redhat.com>
Patchwork-id: 23692
O-Subject: [RHEL5.6 PATCH V2] utrace: block-step fix
Bugzilla: 463950
RH-Acked-by: Oleg Nesterov <oleg@redhat.com>

Bugzilla:
https://bugzilla.redhat.com/show_bug.cgi?id=463950

Description:
Utrace does not pass the test step-jump-cont-strict from ptrace
testsuite while vanilla 2.6.18 kernel does.
This patch is a backport of upstream commit
6718d0d6da2749d3bff522e6057e97e6aa85e4d1 which solves that issue.

Test status:
With that patch, utrace passes the step-jump-cont-strict test. The
results of other tests of ptrace testsuite remain unchanged.

Regards,
Jerome

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/arch/i386/kernel/ptrace.c b/arch/i386/kernel/ptrace.c
index a01c4cb..95289de 100644
--- a/arch/i386/kernel/ptrace.c
+++ b/arch/i386/kernel/ptrace.c
@@ -253,6 +253,7 @@ static inline int is_at_popf(struct task_struct *child, struct pt_regs *regs)
 void tracehook_enable_single_step(struct task_struct *child)
 {
 	struct pt_regs *regs = get_child_regs(child);
+	unsigned long oflags;
 
 	/*
 	 * Always set TIF_SINGLESTEP - this guarantees that 
@@ -261,11 +262,7 @@ void tracehook_enable_single_step(struct task_struct *child)
 	 */
 	set_tsk_thread_flag(child, TIF_SINGLESTEP);
 
-	/*
-	 * If TF was already set, don't do anything else
-	 */
-	if (regs->eflags & X86_EFLAGS_TF)
-		return;
+	oflags = regs->eflags;
 
 	/* Set TF on the kernel stack.. */
 	regs->eflags |= X86_EFLAGS_TF;
@@ -274,11 +271,22 @@ void tracehook_enable_single_step(struct task_struct *child)
 	 * ..but if TF is changed by the instruction we will trace,
 	 * don't mark it as being "us" that set it, so that we
 	 * won't clear it by hand later.
+	 *
+	 * Note that if we don't actually execute the popf because
+	 * of a signal arriving right now or suchlike, we will lose
+	 * track of the fact that it really was "us" that set it.
 	 */
-	if (is_at_popf(child, regs))
+	if (is_at_popf(child, regs)){
+		clear_tsk_thread_flag(child, TIF_FORCED_TF);
 		return;
-	
-	set_tsk_thread_flag(child, TIF_FORCED_TF);
+	}
+
+	/*
+	 * If TF was already set, check whether it was us who set it.
+	 * If not, we should never attempt a block step.
+	 */
+	if (!(oflags & X86_EFLAGS_TF))
+		set_tsk_thread_flag(child, TIF_FORCED_TF);
 }
 
 void tracehook_disable_single_step(struct task_struct *child)
diff --git a/arch/x86_64/kernel/ptrace.c b/arch/x86_64/kernel/ptrace.c
index f31fa47..a7e2e09 100644
--- a/arch/x86_64/kernel/ptrace.c
+++ b/arch/x86_64/kernel/ptrace.c
@@ -178,6 +178,7 @@ static int is_at_popf(struct task_struct *child, struct pt_regs *regs)
 void tracehook_enable_single_step(struct task_struct *child)
 {
 	struct pt_regs *regs = task_pt_regs(child);
+	unsigned long oflags;
 
 	/*
 	 * Always set TIF_SINGLESTEP - this guarantees that
@@ -186,11 +187,7 @@ void tracehook_enable_single_step(struct task_struct *child)
 	 */
 	set_tsk_thread_flag(child, TIF_SINGLESTEP);
 
-	/*
-	 * If TF was already set, don't do anything else
-	 */
-	if (regs->eflags & TRAP_FLAG)
-		return;
+	oflags = regs->eflags;
 
 	/* Set TF on the kernel stack.. */
 	regs->eflags |= TRAP_FLAG;
@@ -201,11 +198,22 @@ void tracehook_enable_single_step(struct task_struct *child)
 	 * won't clear it by hand later.
 	 *
 	 * AK: this is not enough, LAHF and IRET can change TF in user space too.
+	 *
+	 * Note that if we don't actually execute the popf because
+	 * of a signal arriving right now or suchlike, we will lose
+	 * track of the fact that it really was "us" that set it.
 	 */
-	if (is_at_popf(child, regs))
+	if (is_at_popf(child, regs)) {
+		clear_tsk_thread_flag(child, TIF_FORCED_TF);
 		return;
+	}
 
-	set_tsk_thread_flag(child, TIF_FORCED_TF);
+	/*
+	 * If TF was already set, check whether it was us who set it.
+	 * If not, we should never attempt a block step.
+	 */
+	if (!(oflags & X86_EFLAGS_TF))
+		set_tsk_thread_flag(child, TIF_FORCED_TF);
 }
 
 void tracehook_disable_single_step(struct task_struct *child)
