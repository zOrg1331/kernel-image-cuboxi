From: Chad Dupuis <cdupuis@redhat.com>
Date: Fri, 20 Aug 2010 19:28:13 -0400
Subject: [scsi] qla4xxx: resolve name space error with qla2xxx
Message-id: <20100820004054.6639.66026.sendpatchset@localhost.localdomain>
Patchwork-id: 27749
O-Subject: [RHEL 5.6 PATCH 1/2] qla4xxx: resolve name space error between
	qla4xxx and qla2xxx
Bugzilla: 623675

Bugzilla
========

623675

Upstream Status
===============

This patch is only the namespace changes from scsi-misc commit id
f4f5df23bf72208d0c2f1d8be629839924c2f4c2.

Description
===========

>From 2e85ab860027f62893a8b9816d140a84c96dc2fa Mon Sep 17 00:00:00 2001
From: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Date: Wed, 28 Jul 2010 10:55:42 -0700
Subject: [PATCH 01/10] qla4xxx: resolve name space error between qla4xxx and qla2xxx

Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Signed-off-by: Prasanna Mumbai <prasanna.mumbai@qlogic.com>
Signed-off-by: Poornima Vonti <poornima.vonti@qlogic.com>
Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index e82acb0..9d51d27 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -296,7 +296,7 @@ struct ql82xx_hw_data {
 	uint32_t        reserved;
 };
 
-struct qla82xx_legacy_intr_set {
+struct qla4_8xxx_legacy_intr_set {
 	uint32_t        int_vec_bit;
 	uint32_t        tgt_status_reg;
 	uint32_t        tgt_mask_reg;
@@ -574,7 +574,7 @@ struct scsi_qla_host {
 	uint16_t ifcb_size;
 
 	/* NetXen (NX3031) specific fields */
-	struct device_reg_82xx  __iomem *qla82xx_reg; /* Base I/O address */
+	struct device_reg_82xx  __iomem *qla4_8xxx_reg; /* Base I/O address */
 	unsigned long nx_pcibase;       /* Base I/O address */
 	uint8_t *nx_db_rd_ptr;         /* Doorbell read pointer */
 	unsigned long nx_db_wr_ptr;     /* Door bell write pointer */
@@ -592,7 +592,7 @@ struct scsi_qla_host {
 	int link_width;
 
 	void *rsvd4;
-	struct qla82xx_legacy_intr_set nx_legacy_intr;
+	struct qla4_8xxx_legacy_intr_set nx_legacy_intr;
 	u32 nx_crb_mask;
 
 	uint8_t revision_id;
diff --git a/drivers/scsi/qla4xxx/ql4_glbl.h b/drivers/scsi/qla4xxx/ql4_glbl.h
index e67cf05..b79bdbc 100644
--- a/drivers/scsi/qla4xxx/ql4_glbl.h
+++ b/drivers/scsi/qla4xxx/ql4_glbl.h
@@ -101,24 +101,24 @@ void qla4xxx_isr_decode_mailbox(struct scsi_qla_host *ha, uint32_t mbox_status);
 void qla4xxx_wake_dpc(struct scsi_qla_host *ha);
 
 /* ISP 3031 related functions */
-extern void qla82xx_pci_config(struct scsi_qla_host *);
-extern void qla82xx_reset_chip(struct scsi_qla_host *);
-extern int qla82xx_iospace_config(struct scsi_qla_host *ha);
-extern void qla82xx_reset_adapter(struct scsi_qla_host *);
-extern int qla82xx_nvram_config(struct scsi_qla_host *);
-extern int qla82xx_load_risc(struct scsi_qla_host *);
-extern char *qla82xx_get_fw_version_str(struct scsi_qla_host *, char *);
-extern int qla82xx_abort_command(struct srb *);
-extern int qla82xx_start_scsi(struct srb *);
-extern irqreturn_t qla82xx_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
-extern void qla82xx_queue_iocb(struct scsi_qla_host *ha);
-extern void qla82xx_complete_iocb(struct scsi_qla_host *ha);
+extern void qla4_8xxx_pci_config(struct scsi_qla_host *);
+extern void qla4_8xxx_reset_chip(struct scsi_qla_host *);
+extern int qla4_8xxx_iospace_config(struct scsi_qla_host *ha);
+extern void qla4_8xxx_reset_adapter(struct scsi_qla_host *);
+extern int qla4_8xxx_nvram_config(struct scsi_qla_host *);
+extern int qla4_8xxx_load_risc(struct scsi_qla_host *);
+extern char *qla4_8xxx_get_fw_version_str(struct scsi_qla_host *, char *);
+extern int qla4_8xxx_abort_command(struct srb *);
+extern int qla4_8xxx_start_scsi(struct srb *);
+extern irqreturn_t qla4_8xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
+extern void qla4_8xxx_queue_iocb(struct scsi_qla_host *ha);
+extern void qla4_8xxx_complete_iocb(struct scsi_qla_host *ha);
 
-extern int qla82xx_crb_win_lock(struct scsi_qla_host *);
-extern void qla82xx_crb_win_unlock(struct scsi_qla_host *);
-extern int qla82xx_pci_get_crb_addr_2M(struct scsi_qla_host *, u64 *);
-extern void qla82xx_wr_32(struct scsi_qla_host *, u64, u32);
-extern int qla82xx_rd_32(struct scsi_qla_host *, u64);
+extern int qla4_8xxx_crb_win_lock(struct scsi_qla_host *);
+extern void qla4_8xxx_crb_win_unlock(struct scsi_qla_host *);
+extern int qla4_8xxx_pci_get_crb_addr_2M(struct scsi_qla_host *, u64 *);
+extern void qla4_8xxx_wr_32(struct scsi_qla_host *, u64, u32);
+extern int qla4_8xxx_rd_32(struct scsi_qla_host *, u64);
 extern int QLA30XX_RDMEM(struct scsi_qla_host *, u64, void *, int);
 extern int QLA30XX_WRMEM(struct scsi_qla_host *, u64, void *, int);
 extern int check_for_bad_spd(struct scsi_qla_host *);
@@ -126,43 +126,43 @@ extern void load_fw (struct scsi_qla_host *);
 extern int rom_lock(struct scsi_qla_host *);
 extern void rom_unlock(struct scsi_qla_host *);
 extern int rom_fast_read(struct scsi_qla_host *, int , int*);
-extern int qla82xx_pci_mem_read_2M(struct scsi_qla_host *, u64, void*, int);
-extern int qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha, u64, void*, int);
-extern int qla82xx_pci_write_immediate_2M(struct scsi_qla_host *, u64, u32);
-extern u32 qla82xx_pci_read_immediate_2M(struct scsi_qla_host *, u64);
+extern int qla4_8xxx_pci_mem_read_2M(struct scsi_qla_host *, u64, void*, int);
+extern int qla4_8xxx_pci_mem_write_2M(struct scsi_qla_host *ha, u64, void*, int);
+extern int qla4_8xxx_pci_write_immediate_2M(struct scsi_qla_host *, u64, u32);
+extern u32 qla4_8xxx_pci_read_immediate_2M(struct scsi_qla_host *, u64);
 extern void qla80xx_update_crb_int_ptr(struct scsi_qla_host *);
 
-extern int qla82xx_isp_reset(struct scsi_qla_host *ha);
+extern int qla4_8xxx_isp_reset(struct scsi_qla_host *ha);
 extern uint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha);
-extern uint16_t qla82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha);
-extern uint16_t qla82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha);
-void qla82xx_interrupt_service_routine(struct scsi_qla_host *ha, uint32_t intr_status);
-int qla82xx_get_sys_info(struct scsi_qla_host *ha);
-void qla82xx_init_local_data(struct scsi_qla_host *ha);
-void qla82xx_watchdog(struct scsi_qla_host *ha);
-int qla82xx_stop_firmware(struct scsi_qla_host *ha);
-void qla82xx_restore_known_fw_state(struct scsi_qla_host *ha);
+extern uint16_t qla4_8xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha);
+extern uint16_t qla4_8xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha);
+void qla4_8xxx_interrupt_service_routine(struct scsi_qla_host *ha, uint32_t intr_status);
+int qla4_8xxx_get_sys_info(struct scsi_qla_host *ha);
+void qla4_8xxx_init_local_data(struct scsi_qla_host *ha);
+void qla4_8xxx_watchdog(struct scsi_qla_host *ha);
+int qla4_8xxx_stop_firmware(struct scsi_qla_host *ha);
+void qla4_8xxx_restore_known_fw_state(struct scsi_qla_host *ha);
 
 int qla4xxx_send_marker_iocb(struct scsi_qla_host *ha,
 	struct ddb_entry *ddb_entry, int lun);
 int qla4_is_relogin_allowed(struct scsi_qla_host *ha, uint32_t conn_err);
 
-int qla82xx_get_flash_info(struct scsi_qla_host *ha);
-void qla82xx_enable_intrs(struct scsi_qla_host *ha);
-void qla82xx_disable_intrs(struct scsi_qla_host *ha);
-int qla82xx_enable_msix(struct scsi_qla_host *ha);
-void qla82xx_disable_msix(struct scsi_qla_host *ha);
-irqreturn_t qla82xx_msi_handler(int irq, void *dev_id, struct pt_regs *regs);
-irqreturn_t qla82xx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
-irqreturn_t qla82xx_msix_rsp_q(int irq, void *dev_id);
+int qla4_8xxx_get_flash_info(struct scsi_qla_host *ha);
+void qla4_8xxx_enable_intrs(struct scsi_qla_host *ha);
+void qla4_8xxx_disable_intrs(struct scsi_qla_host *ha);
+int qla4_8xxx_enable_msix(struct scsi_qla_host *ha);
+void qla4_8xxx_disable_msix(struct scsi_qla_host *ha);
+irqreturn_t qla4_8xxx_msi_handler(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t qla4_8xxx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t qla4_8xxx_msix_rsp_q(int irq, void *dev_id);
 void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res);
 void qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha);
 void qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha);
-int qla82xx_idc_lock(struct scsi_qla_host *ha);
-void qla82xx_idc_unlock(struct scsi_qla_host *ha);
-int qla82xx_device_state_handler(struct scsi_qla_host *ha);
-void qla82xx_need_qsnt_handler(struct scsi_qla_host *ha);
-void qla82xx_clear_drv_active(struct scsi_qla_host *ha);
+int qla4_8xxx_idc_lock(struct scsi_qla_host *ha);
+void qla4_8xxx_idc_unlock(struct scsi_qla_host *ha);
+int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha);
+void qla4_8xxx_need_qsnt_handler(struct scsi_qla_host *ha);
+void qla4_8xxx_clear_drv_active(struct scsi_qla_host *ha);
 
 extern int ql4xextended_error_logging;
 extern int ql4xdiscoverywait;
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index cf5a4e7..378b505 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -130,9 +130,9 @@ int qla4xxx_init_rings(struct scsi_qla_host *ha)
 	ha->response_ptr = &ha->response_ring[ha->response_out];
 
 	if (is_qla8022(ha)) {
-		writel(0, (unsigned long  __iomem *)&ha->qla82xx_reg->req_q_out);
-		writel(0, (unsigned long  __iomem *)&ha->qla82xx_reg->rsp_q_in);
-		writel(0, (unsigned long  __iomem *)&ha->qla82xx_reg->rsp_q_out);
+		writel(0, (unsigned long  __iomem *)&ha->qla4_8xxx_reg->req_q_out);
+		writel(0, (unsigned long  __iomem *)&ha->qla4_8xxx_reg->rsp_q_in);
+		writel(0, (unsigned long  __iomem *)&ha->qla4_8xxx_reg->rsp_q_out);
 	} else {
 		/*
 		 * Initialize DMA Shadow registers.  The firmware is really supposed to
@@ -1068,10 +1068,10 @@ static int qla4xxx_config_nvram(struct scsi_qla_host *ha)
 }
 
 /**
- * qla82xx_pci_config() - Setup ISP30xx PCI configuration registers.
+ * qla4_8xxx_pci_config() - Setup ISP30xx PCI configuration registers.
  * @ha: HA context
  **/
-void qla82xx_pci_config(struct scsi_qla_host *ha)
+void qla4_8xxx_pci_config(struct scsi_qla_host *ha)
 {
 	pci_set_master(ha->pdev);
 
diff --git a/drivers/scsi/qla4xxx/ql4_iocb.c b/drivers/scsi/qla4xxx/ql4_iocb.c
index 0b489b9..da781fd 100644
--- a/drivers/scsi/qla4xxx/ql4_iocb.c
+++ b/drivers/scsi/qla4xxx/ql4_iocb.c
@@ -207,13 +207,13 @@ void qla4xxx_build_scsi_iocbs(struct srb *srb,
 }
 
 /**
- * qla82xx_queue_iocb - Tell ISP it's got new request(s)
+ * qla4_8xxx_queue_iocb - Tell ISP it's got new request(s)
  * @ha: pointer to host adapter structure.
  *
  * This routine is notifies the ISP that one or more new request
  * queue entries have been placed on the request queue.
  **/
-void qla82xx_queue_iocb(struct scsi_qla_host *ha)
+void qla4_8xxx_queue_iocb(struct scsi_qla_host *ha)
 {
 	uint32_t   dbval = 0;
 	unsigned long wtime;
@@ -232,17 +232,17 @@ void qla82xx_queue_iocb(struct scsi_qla_host *ha)
 }
 
 /**
- * qla82xx_complete_iocb - Tell ISP we're done with response(s)
+ * qla4_8xxx_complete_iocb - Tell ISP we're done with response(s)
  * @ha: pointer to host adapter structure.
  *
  * This routine is notifies the ISP that one or more response/completion
  * queue entries have been processed by the driver.
  * This also clears the interrupt.
  **/
-void qla82xx_complete_iocb(struct scsi_qla_host *ha)
+void qla4_8xxx_complete_iocb(struct scsi_qla_host *ha)
 {
-	writel(ha->response_out, &ha->qla82xx_reg->rsp_q_out);
-	readl(&ha->qla82xx_reg->rsp_q_out);
+	writel(ha->response_out, &ha->qla4_8xxx_reg->rsp_q_out);
+	readl(&ha->qla4_8xxx_reg->rsp_q_out);
 }
 
 /**
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
index 5220b8c..1f377d5 100644
--- a/drivers/scsi/qla4xxx/ql4_isr.c
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -514,7 +514,7 @@ void qla4xxx_isr_decode_mailbox(struct scsi_qla_host *ha,
 			 */
 			for (i = 0; i < ha->mbox_status_count; i++)
 				ha->mbox_status[i] = is_qla8022(ha)
-					? readl(&ha->qla82xx_reg->mailbox_out[i])
+					? readl(&ha->qla4_8xxx_reg->mailbox_out[i])
 					: readl(&ha->reg->mailbox[i]);
 
 			set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
@@ -525,7 +525,7 @@ void qla4xxx_isr_decode_mailbox(struct scsi_qla_host *ha,
 	} else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {
 		for (i = 0; i < MBOX_AEN_REG_COUNT; i++)
 			mbox_sts[i] = is_qla8022(ha)
-				? readl(&ha->qla82xx_reg->mailbox_out[i])
+				? readl(&ha->qla4_8xxx_reg->mailbox_out[i])
 				: readl(&ha->reg->mailbox[i]);
 		/* Immediately process the AENs that don't require much work.
 		 * Only queue the database_changed AENs */
@@ -681,13 +681,13 @@ void qla4xxx_isr_decode_mailbox(struct scsi_qla_host *ha,
 }
 
 /**
- * qla82xx_interrupt_service_routine - isr
+ * qla4_8xxx_interrupt_service_routine - isr
  * @ha: pointer to host adapter structure.
  *
  * This is the main interrupt service routine.
  * hardware_lock locked upon entry. runs in interrupt context.
  **/
-void qla82xx_interrupt_service_routine(struct scsi_qla_host *ha,
+void qla4_8xxx_interrupt_service_routine(struct scsi_qla_host *ha,
 					uint32_t intr_status)
 {
 	/* Process response queue interrupt. */
@@ -697,12 +697,12 @@ void qla82xx_interrupt_service_routine(struct scsi_qla_host *ha,
 
 	/* Process mailbox/asynch event interrupt.*/
 	if (intr_status & HSRX_RISC_MB_INT) {
-		qla4xxx_isr_decode_mailbox(ha, readl(&ha->qla82xx_reg->mailbox_out[0]));
+		qla4xxx_isr_decode_mailbox(ha, readl(&ha->qla4_8xxx_reg->mailbox_out[0]));
 	}
 
 	/* clear the interrupt */
-	writel(0, &ha->qla82xx_reg->host_int);
-	readl(&ha->qla82xx_reg->host_int);
+	writel(0, &ha->qla4_8xxx_reg->host_int);
+	readl(&ha->qla4_8xxx_reg->host_int);
 }
 
 /**
@@ -732,12 +732,12 @@ void qla4xxx_interrupt_service_routine(struct scsi_qla_host * ha,
 }
 
 /**
- * qla82xx_spurious_interrupt - processes spurious interrupt
+ * qla4_8xxx_spurious_interrupt - processes spurious interrupt
  * @ha: pointer to host adapter structure.
  * @reqs_count: .
  *
  **/
-static void qla82xx_spurious_interrupt(struct scsi_qla_host *ha,
+static void qla4_8xxx_spurious_interrupt(struct scsi_qla_host *ha,
 				       uint8_t reqs_count)
 {
 	if (reqs_count)
@@ -745,9 +745,9 @@ static void qla82xx_spurious_interrupt(struct scsi_qla_host *ha,
 
 	DEBUG2(printk(KERN_INFO"Spurious Interrupt\n"));
 	if (is_qla8022(ha)) {
-		writel(0, &ha->qla82xx_reg->host_int);
+		writel(0, &ha->qla4_8xxx_reg->host_int);
 		if (test_bit(AF_INTx_ENABLED, &ha->flags))
-			qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+			qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
 	}
 	ha->spurious_int_count++;
 
@@ -851,11 +851,11 @@ irqreturn_t qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 }
 
 /**
- * qla82xx_intr_handler - hardware interrupt handler.
+ * qla4_8xxx_intr_handler - hardware interrupt handler.
  * @irq: Unused
  * @dev_id: Pointer to host adapter structure
  **/
-irqreturn_t qla82xx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t qla4_8xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct scsi_qla_host *ha;
 	uint32_t intr_status;
@@ -871,41 +871,41 @@ irqreturn_t qla82xx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 	}
 
 	ha->isr_count++;
-	status = qla82xx_rd_32(ha, ISR_INT_VECTOR);
+	status = qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);
 	if (!(status & ha->nx_legacy_intr.int_vec_bit)) {
 		DEBUG2(printk(KERN_INFO"%s legacy Int Vec bit set\n", __func__));
 		return IRQ_NONE;
 	}
 
-	status = qla82xx_rd_32(ha, ISR_INT_STATE_REG);
+	status = qla4_8xxx_rd_32(ha, ISR_INT_STATE_REG);
 	if (!ISR_IS_LEGACY_INTR_TRIGGERED(status)) {
 		DEBUG2(printk("%s legacy Int not triggered\n", __func__));
 		return IRQ_NONE;
 	}
 
 	/* clear the interrupt */
-	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);
+	qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);
 
 	/* read twice to ensure write is flushed */
-	qla82xx_rd_32(ha, ISR_INT_VECTOR);
-	qla82xx_rd_32(ha, ISR_INT_VECTOR);
+	qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);
+	qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	while (1) {
-		if (!(readl(&ha->qla82xx_reg->host_int) & ISRX_82XX_RISC_INT))  {
-			qla82xx_spurious_interrupt(ha, reqs_count);
+		if (!(readl(&ha->qla4_8xxx_reg->host_int) & ISRX_82XX_RISC_INT))  {
+			qla4_8xxx_spurious_interrupt(ha, reqs_count);
 			break;
 		}
-		intr_status =  readl(&ha->qla82xx_reg->host_status);
+		intr_status =  readl(&ha->qla4_8xxx_reg->host_status);
 		if  ((intr_status & (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0)  {
-			qla82xx_spurious_interrupt(ha, reqs_count);
+			qla4_8xxx_spurious_interrupt(ha, reqs_count);
 			break;
 		}
 
 		ha->isp_ops->interrupt_service_routine(ha, intr_status);
 
 		/* Enable Interrupt */
-		qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+		qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
 
 		if (++reqs_count == MAX_REQS_SERVICED_PER_INTR)
 				break;
@@ -916,7 +916,7 @@ irqreturn_t qla82xx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 }
 
 irqreturn_t
-qla82xx_msi_handler(int irq, void *dev_id, struct pt_regs *regs)
+qla4_8xxx_msi_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct scsi_qla_host *ha;
 
@@ -929,17 +929,17 @@ qla82xx_msi_handler(int irq, void *dev_id, struct pt_regs *regs)
 
 	ha->isr_count++;
 	/* clear the interrupt */
-	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);
+	qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);
 
 	/* read twice to ensure write is flushed */
-	qla82xx_rd_32(ha, ISR_INT_VECTOR);
-	qla82xx_rd_32(ha, ISR_INT_VECTOR);
+	qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);
+	qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);
 
-	return qla82xx_default_intr_handler(irq, dev_id, (struct pt_regs *)ha);
+	return qla4_8xxx_default_intr_handler(irq, dev_id, (struct pt_regs *)ha);
 }
 
 /**
- * qla82xx_default_intr_handler - hardware interrupt handler.
+ * qla4_8xxx_default_intr_handler - hardware interrupt handler.
  * @irq: Unused
  * @dev_id: Pointer to host adapter structure
  *
@@ -947,7 +947,7 @@ qla82xx_msi_handler(int irq, void *dev_id, struct pt_regs *regs)
  * called indirectly for MSI.
  **/
 irqreturn_t
-qla82xx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+qla4_8xxx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct scsi_qla_host *ha = dev_id;
 	unsigned long	flags;
@@ -956,15 +956,15 @@ qla82xx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	while (1) {
-		if (!(readl(&ha->qla82xx_reg->host_int) & ISRX_82XX_RISC_INT))  {
-			qla82xx_spurious_interrupt(ha, reqs_count);
+		if (!(readl(&ha->qla4_8xxx_reg->host_int) & ISRX_82XX_RISC_INT)) {
+			qla4_8xxx_spurious_interrupt(ha, reqs_count);
 			break;
 		}
 
-		intr_status =  readl(&ha->qla82xx_reg->host_status);
+		intr_status =  readl(&ha->qla4_8xxx_reg->host_status);
 		if  ((intr_status &
-		      (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0)  {
-			qla82xx_spurious_interrupt(ha, reqs_count);
+		      (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0) {
+			qla4_8xxx_spurious_interrupt(ha, reqs_count);
 			break;
 		}
 
@@ -980,14 +980,14 @@ qla82xx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 }
 
 irqreturn_t
-qla82xx_msix_rsp_q(int irq, void *dev_id)
+qla4_8xxx_msix_rsp_q(int irq, void *dev_id)
 {
 	struct scsi_qla_host *ha = dev_id;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	qla4xxx_process_response_queue(ha);
-	writel(0, &ha->qla82xx_reg->host_int);
+	writel(0, &ha->qla4_8xxx_reg->host_int);
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	ha->isr_count++;
@@ -1101,7 +1101,7 @@ int qla4xxx_request_irqs(struct scsi_qla_host *ha)
 		goto try_intx;
 
 	/* Trying MSI-X */
-	ret = qla82xx_enable_msix(ha);
+	ret = qla4_8xxx_enable_msix(ha);
 	if (!ret) {
 		DEBUG2(printk("MSI-X: Enabled (0x%X).\n", ha->revision_id));
 		goto irq_attached;
@@ -1113,7 +1113,7 @@ try_msi:
 	/* Trying MSI */
 	ret = pci_enable_msi(ha->pdev);
 	if (!ret) {
-		ret = request_irq(ha->pdev->irq, qla82xx_msi_handler,
+		ret = request_irq(ha->pdev->irq, qla4_8xxx_msi_handler,
 		    IRQF_DISABLED|IRQF_SHARED, DRIVER_NAME, ha);
 		if (!ret) {
 			DEBUG2(printk(KERN_INFO"MSI: Enabled.\n"));
@@ -1154,7 +1154,7 @@ void
 qla4xxx_free_irqs(struct scsi_qla_host *ha)
 {
 	if (test_bit(AF_MSIX_ENABLED, &ha->flags))
-			qla82xx_disable_msix(ha);
+			qla4_8xxx_disable_msix(ha);
 	else if (test_and_clear_bit(AF_MSI_ENABLED, &ha->flags)) {
 			free_irq(ha->pdev->irq, ha);
 			pci_disable_msi(ha->pdev);
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index c2d2cb2..05bf893 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -67,18 +67,18 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	 */
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	if (is_qla8022(ha)) {
-		intr_status = readl(&ha->qla82xx_reg->host_int);
+		intr_status = readl(&ha->qla4_8xxx_reg->host_int);
 		if (intr_status & ISRX_82XX_RISC_INT) {
 			/* Service existing interrupt */
 			DEBUG2(printk("scsi%ld: %s: "
 				"servicing existing interrupt\n",
 				ha->host_no, __func__));
-			intr_status = readl(&ha->qla82xx_reg->host_status);
+			intr_status = readl(&ha->qla4_8xxx_reg->host_status);
 			ha->isp_ops->interrupt_service_routine(ha, intr_status);
 			clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
 			if (test_bit(AF_INTERRUPTS_ON, &ha->flags) &&
 				test_bit(AF_INTx_ENABLED, &ha->flags))
-				qla82xx_wr_32(ha,
+				qla4_8xxx_wr_32(ha,
 					ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
 		}
 	} else {
@@ -98,10 +98,10 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	if (is_qla8022(ha)) {
 		/* Load all mailbox registers, except mailbox 0. */
 		for (i = 1; i < inCount; i++)
-			writel(mbx_cmd[i], &ha->qla82xx_reg->mailbox_in[i]);
-		writel(mbx_cmd[0], &ha->qla82xx_reg->mailbox_in[0]);
-		readl(&ha->qla82xx_reg->mailbox_in[0]);
-		writel(HINT_MBX_INT_PENDING, &ha->qla82xx_reg->hint);
+			writel(mbx_cmd[i], &ha->qla4_8xxx_reg->mailbox_in[i]);
+		writel(mbx_cmd[0], &ha->qla4_8xxx_reg->mailbox_in[0]);
+		readl(&ha->qla4_8xxx_reg->mailbox_in[0]);
+		writel(HINT_MBX_INT_PENDING, &ha->qla4_8xxx_reg->hint);
 	} else {
 		/* Load all mailbox registers, except mailbox 0. */
 		for (i = 1; i < inCount; i++)
@@ -152,14 +152,14 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 			 */
 			spin_lock_irqsave(&ha->hardware_lock, flags);
 			if (is_qla8022(ha)) {
-				intr_status = readl(&ha->qla82xx_reg->host_int);
+				intr_status = readl(&ha->qla4_8xxx_reg->host_int);
 				if (intr_status & ISRX_82XX_RISC_INT) {
 					ha->mbox_status_count = outCount;
-					intr_status = readl(&ha->qla82xx_reg->host_status);
+					intr_status = readl(&ha->qla4_8xxx_reg->host_status);
 					ha->isp_ops->interrupt_service_routine(ha, intr_status);
 					if (test_bit(AF_INTERRUPTS_ON, &ha->flags) &&
 						test_bit(AF_INTx_ENABLED, &ha->flags))
-						qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,
+						qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,
 							0xfbff);
 				}
 			} else {
diff --git a/drivers/scsi/qla4xxx/ql4_nx.c b/drivers/scsi/qla4xxx/ql4_nx.c
index 9ed8326..46809db 100644
--- a/drivers/scsi/qla4xxx/ql4_nx.c
+++ b/drivers/scsi/qla4xxx/ql4_nx.c
@@ -24,7 +24,7 @@
 #define CRB_SUBBLK(off)	((off >> 16) & 0xf)
 #define CRB_WINDOW_2M	(0x130060)
 #define QLA82XX_PCI_CAMQM_2M_END	(0x04800800UL)
-#define CRB_HI(off)	((qla82xx_crb_hub_agt[CRB_BLK(off)] << 20) | ((off) & 0xf0000))
+#define CRB_HI(off)	((qla4_8xxx_crb_hub_agt[CRB_BLK(off)] << 20) | ((off) & 0xf0000))
 #define QLA82XX_PCI_CAMQM_2M_BASE	(0x000ff800UL)
 #define CRB_INDIRECT_2M	(0x1e0000UL)
 
@@ -41,7 +41,7 @@ static void writeq(u64 val, void __iomem *reg)
 }
 #endif
 
-static inline void *qla82xx_pci_base_offsetfset(struct scsi_qla_host *ha, unsigned long off)
+static inline void *qla4_8xxx_pci_base_offsetfset(struct scsi_qla_host *ha, unsigned long off)
 {
 	if ((off < ha->first_page_group_end) &&
 	    (off >= ha->first_page_group_start))
@@ -52,70 +52,70 @@ static inline void *qla82xx_pci_base_offsetfset(struct scsi_qla_host *ha, unsign
 
 #define MAX_CRB_XFORM 60
 static unsigned long crb_addr_xform[MAX_CRB_XFORM];
-int qla82xx_crb_table_initialized;
+int qla4_8xxx_crb_table_initialized;
 
-#define qla82xx_crb_addr_transform(name) \
+#define qla4_8xxx_crb_addr_transform(name) \
 	(crb_addr_xform[QLA82XX_HW_PX_MAP_CRB_##name] = \
 	QLA82XX_HW_CRB_HUB_AGT_ADR_##name << 20)
 static void
-qla82xx_crb_addr_transform_setup(void)
-{
-	qla82xx_crb_addr_transform(XDMA);
-	qla82xx_crb_addr_transform(TIMR);
-	qla82xx_crb_addr_transform(SRE);
-	qla82xx_crb_addr_transform(SQN3);
-	qla82xx_crb_addr_transform(SQN2);
-	qla82xx_crb_addr_transform(SQN1);
-	qla82xx_crb_addr_transform(SQN0);
-	qla82xx_crb_addr_transform(SQS3);
-	qla82xx_crb_addr_transform(SQS2);
-	qla82xx_crb_addr_transform(SQS1);
-	qla82xx_crb_addr_transform(SQS0);
-	qla82xx_crb_addr_transform(RPMX7);
-	qla82xx_crb_addr_transform(RPMX6);
-	qla82xx_crb_addr_transform(RPMX5);
-	qla82xx_crb_addr_transform(RPMX4);
-	qla82xx_crb_addr_transform(RPMX3);
-	qla82xx_crb_addr_transform(RPMX2);
-	qla82xx_crb_addr_transform(RPMX1);
-	qla82xx_crb_addr_transform(RPMX0);
-	qla82xx_crb_addr_transform(ROMUSB);
-	qla82xx_crb_addr_transform(SN);
-	qla82xx_crb_addr_transform(QMN);
-	qla82xx_crb_addr_transform(QMS);
-	qla82xx_crb_addr_transform(PGNI);
-	qla82xx_crb_addr_transform(PGND);
-	qla82xx_crb_addr_transform(PGN3);
-	qla82xx_crb_addr_transform(PGN2);
-	qla82xx_crb_addr_transform(PGN1);
-	qla82xx_crb_addr_transform(PGN0);
-	qla82xx_crb_addr_transform(PGSI);
-	qla82xx_crb_addr_transform(PGSD);
-	qla82xx_crb_addr_transform(PGS3);
-	qla82xx_crb_addr_transform(PGS2);
-	qla82xx_crb_addr_transform(PGS1);
-	qla82xx_crb_addr_transform(PGS0);
-	qla82xx_crb_addr_transform(PS);
-	qla82xx_crb_addr_transform(PH);
-	qla82xx_crb_addr_transform(NIU);
-	qla82xx_crb_addr_transform(I2Q);
-	qla82xx_crb_addr_transform(EG);
-	qla82xx_crb_addr_transform(MN);
-	qla82xx_crb_addr_transform(MS);
-	qla82xx_crb_addr_transform(CAS2);
-	qla82xx_crb_addr_transform(CAS1);
-	qla82xx_crb_addr_transform(CAS0);
-	qla82xx_crb_addr_transform(CAM);
-	qla82xx_crb_addr_transform(C2C1);
-	qla82xx_crb_addr_transform(C2C0);
-	qla82xx_crb_addr_transform(SMB);
-	qla82xx_crb_addr_transform(OCM0);
+qla4_8xxx_crb_addr_transform_setup(void)
+{
+	qla4_8xxx_crb_addr_transform(XDMA);
+	qla4_8xxx_crb_addr_transform(TIMR);
+	qla4_8xxx_crb_addr_transform(SRE);
+	qla4_8xxx_crb_addr_transform(SQN3);
+	qla4_8xxx_crb_addr_transform(SQN2);
+	qla4_8xxx_crb_addr_transform(SQN1);
+	qla4_8xxx_crb_addr_transform(SQN0);
+	qla4_8xxx_crb_addr_transform(SQS3);
+	qla4_8xxx_crb_addr_transform(SQS2);
+	qla4_8xxx_crb_addr_transform(SQS1);
+	qla4_8xxx_crb_addr_transform(SQS0);
+	qla4_8xxx_crb_addr_transform(RPMX7);
+	qla4_8xxx_crb_addr_transform(RPMX6);
+	qla4_8xxx_crb_addr_transform(RPMX5);
+	qla4_8xxx_crb_addr_transform(RPMX4);
+	qla4_8xxx_crb_addr_transform(RPMX3);
+	qla4_8xxx_crb_addr_transform(RPMX2);
+	qla4_8xxx_crb_addr_transform(RPMX1);
+	qla4_8xxx_crb_addr_transform(RPMX0);
+	qla4_8xxx_crb_addr_transform(ROMUSB);
+	qla4_8xxx_crb_addr_transform(SN);
+	qla4_8xxx_crb_addr_transform(QMN);
+	qla4_8xxx_crb_addr_transform(QMS);
+	qla4_8xxx_crb_addr_transform(PGNI);
+	qla4_8xxx_crb_addr_transform(PGND);
+	qla4_8xxx_crb_addr_transform(PGN3);
+	qla4_8xxx_crb_addr_transform(PGN2);
+	qla4_8xxx_crb_addr_transform(PGN1);
+	qla4_8xxx_crb_addr_transform(PGN0);
+	qla4_8xxx_crb_addr_transform(PGSI);
+	qla4_8xxx_crb_addr_transform(PGSD);
+	qla4_8xxx_crb_addr_transform(PGS3);
+	qla4_8xxx_crb_addr_transform(PGS2);
+	qla4_8xxx_crb_addr_transform(PGS1);
+	qla4_8xxx_crb_addr_transform(PGS0);
+	qla4_8xxx_crb_addr_transform(PS);
+	qla4_8xxx_crb_addr_transform(PH);
+	qla4_8xxx_crb_addr_transform(NIU);
+	qla4_8xxx_crb_addr_transform(I2Q);
+	qla4_8xxx_crb_addr_transform(EG);
+	qla4_8xxx_crb_addr_transform(MN);
+	qla4_8xxx_crb_addr_transform(MS);
+	qla4_8xxx_crb_addr_transform(CAS2);
+	qla4_8xxx_crb_addr_transform(CAS1);
+	qla4_8xxx_crb_addr_transform(CAS0);
+	qla4_8xxx_crb_addr_transform(CAM);
+	qla4_8xxx_crb_addr_transform(C2C1);
+	qla4_8xxx_crb_addr_transform(C2C0);
+	qla4_8xxx_crb_addr_transform(SMB);
+	qla4_8xxx_crb_addr_transform(OCM0);
 	/*
 	 * Used only in P3 just define it for P2 also.
 	 */
-	qla82xx_crb_addr_transform(I2C0);
+	qla4_8xxx_crb_addr_transform(I2C0);
 
-	qla82xx_crb_table_initialized = 1;
+	qla4_8xxx_crb_table_initialized = 1;
 }
 
 struct crb_128M_2M_block_map crb_128M_2M_map[64] = {
@@ -278,7 +278,7 @@ struct crb_128M_2M_block_map crb_128M_2M_map[64] = {
 /*
  * top 12 bits of crb internal address (hub, agent)
  */
-unsigned qla82xx_crb_hub_agt[64] = {
+unsigned qla4_8xxx_crb_hub_agt[64] = {
 	0,
 	QLA82XX_HW_CRB_HUB_AGT_ADR_PS,
 	QLA82XX_HW_CRB_HUB_AGT_ADR_MN,
@@ -349,7 +349,7 @@ unsigned qla82xx_crb_hub_agt[64] = {
  * Set the CRB window based on the offset.
  * Return 0 if successful; 1 otherwise
 */
-void qla82xx_pci_change_crbwindow_128M(struct scsi_qla_host *ha, int wndw)
+void qla4_8xxx_pci_change_crbwindow_128M(struct scsi_qla_host *ha, int wndw)
 {
 	WARN_ON(1);
 }
@@ -360,7 +360,7 @@ void qla82xx_pci_change_crbwindow_128M(struct scsi_qla_host *ha, int wndw)
  * side effect: lock crb window
  */
 static void
-qla82xx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, u64 *off)
+qla4_8xxx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, u64 *off)
 {
 	u32 win_read;
 
@@ -379,49 +379,49 @@ qla82xx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, u64 *off)
 }
 
 void
-qla82xx_wr_32(struct scsi_qla_host *ha, u64 off, u32 data)
+qla4_8xxx_wr_32(struct scsi_qla_host *ha, u64 off, u32 data)
 {
 	unsigned long flags = 0;
 	int rv;
 
-	rv = qla82xx_pci_get_crb_addr_2M(ha, &off);
+	rv = qla4_8xxx_pci_get_crb_addr_2M(ha, &off);
 
 	BUG_ON(rv == -1);
 
 	if (rv == 1) {
 		write_lock_irqsave(&ha->hw_lock, flags);
-		qla82xx_crb_win_lock(ha);
-		qla82xx_pci_set_crbwindow_2M(ha, &off);
+		qla4_8xxx_crb_win_lock(ha);
+		qla4_8xxx_pci_set_crbwindow_2M(ha, &off);
 	}
 
 	writel(data, (void __iomem *)((unsigned long)off));
 
 	if (rv == 1) {
-		qla82xx_crb_win_unlock(ha);
+		qla4_8xxx_crb_win_unlock(ha);
 		write_unlock_irqrestore(&ha->hw_lock, flags);
 	}
 }
 
 int
-qla82xx_rd_32(struct scsi_qla_host *ha, u64 off)
+qla4_8xxx_rd_32(struct scsi_qla_host *ha, u64 off)
 {
 	unsigned long flags = 0;
 	int rv;
 	u32 data;
 
-	rv = qla82xx_pci_get_crb_addr_2M(ha, &off);
+	rv = qla4_8xxx_pci_get_crb_addr_2M(ha, &off);
 
 	BUG_ON(rv == -1);
 
 	if (rv == 1) {
 		write_lock_irqsave(&ha->hw_lock, flags);
-		qla82xx_crb_win_lock(ha);
-		qla82xx_pci_set_crbwindow_2M(ha, &off);
+		qla4_8xxx_crb_win_lock(ha);
+		qla4_8xxx_pci_set_crbwindow_2M(ha, &off);
 	}
 	data = readl((void __iomem *)((unsigned long)off));
 
 	if (rv == 1) {
-		qla82xx_crb_win_unlock(ha);
+		qla4_8xxx_crb_win_unlock(ha);
 		write_unlock_irqrestore(&ha->hw_lock, flags);
 	}
 	return data;
@@ -429,14 +429,14 @@ qla82xx_rd_32(struct scsi_qla_host *ha, u64 off)
 
 #define CRB_WIN_LOCK_TIMEOUT 100000000
 
-int qla82xx_crb_win_lock(struct scsi_qla_host *ha)
+int qla4_8xxx_crb_win_lock(struct scsi_qla_host *ha)
 {
 	int i;
 	int done = 0, timeout = 0;
 
 	while (!done) {
 		/* acquire semaphore3 from PCI HW block */
-		done = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));
+		done = qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));
 		if (done == 1)
 			break;
 		if (timeout >= CRB_WIN_LOCK_TIMEOUT)
@@ -452,32 +452,32 @@ int qla82xx_crb_win_lock(struct scsi_qla_host *ha)
 				cpu_relax();    /*This a nop instr on i386*/
 		}
 	}
-	qla82xx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->portnum);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->portnum);
 	return 0;
 }
 
-void qla82xx_crb_win_unlock(struct scsi_qla_host *ha)
+void qla4_8xxx_crb_win_unlock(struct scsi_qla_host *ha)
 {
-	qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));
+	qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));
 }
 
 #define IDC_LOCK_TIMEOUT 100000000
 
 /**
- * qla82xx_idc_lock - hw_lock
+ * qla4_8xxx_idc_lock - hw_lock
  * @ha: pointer to adapter structure
  *
  * General purpose lock used to synchronize access to
  * CRB_DEV_STATE, CRB_DEV_REF_COUNT, etc.
  **/
-int qla82xx_idc_lock(struct scsi_qla_host *ha)
+int qla4_8xxx_idc_lock(struct scsi_qla_host *ha)
 {
 	int i;
 	int done = 0, timeout = 0;
 
 	while (!done) {
 		/* acquire semaphore5 from PCI HW block */
-		done = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));
+		done = qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));
 		if (done == 1)
 			break;
 		if (timeout >= IDC_LOCK_TIMEOUT)
@@ -496,13 +496,13 @@ int qla82xx_idc_lock(struct scsi_qla_host *ha)
 	return 0;
 }
 
-void qla82xx_idc_unlock(struct scsi_qla_host *ha)
+void qla4_8xxx_idc_unlock(struct scsi_qla_host *ha)
 {
-	qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));
+	qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));
 }
 
 int
-qla82xx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, u64 *off)
+qla4_8xxx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, u64 *off)
 {
 	struct crb_128M_2M_sub_block_map *m;
 
@@ -545,7 +545,7 @@ qla82xx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, u64 *off)
 * used by test agent. support ddr access only for now
 */
 static unsigned long
-qla82xx_pci_mem_bound_check(struct scsi_qla_host *ha,
+qla4_8xxx_pci_mem_bound_check(struct scsi_qla_host *ha,
 		unsigned long long addr, int size)
 {
 	if (!QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET, QLA82XX_ADDR_DDR_NET_MAX) ||
@@ -556,10 +556,10 @@ qla82xx_pci_mem_bound_check(struct scsi_qla_host *ha,
 	return 1;
 }
 
-static int qla82xx_pci_set_window_warning_count;
+static int qla4_8xxx_pci_set_window_warning_count;
 
 static unsigned long
-qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
+qla4_8xxx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
 {
 	int window;
 	u32 win_read;
@@ -569,8 +569,8 @@ qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
 		/* DDR network side */
 		window = MN_WIN(addr);
 		ha->ddr_mn_window = window;
-		qla82xx_wr_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);
-		win_read = qla82xx_rd_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE);
+		qla4_8xxx_wr_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);
+		win_read = qla4_8xxx_rd_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE);
 		if ((win_read << 17) != window) {
 			DEBUG2(printk(KERN_WARNING"%s: Written MNwin (0x%x) != Read MNwin (0x%x)\n",
 			__func__, window, win_read));
@@ -585,8 +585,8 @@ qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
 
 		window = OCM_WIN(addr);
 		ha->ddr_mn_window = window;
-		qla82xx_wr_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);
-		win_read = qla82xx_rd_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE);
+		qla4_8xxx_wr_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);
+		win_read = qla4_8xxx_rd_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE);
 		temp1 = ((window & 0x1FF) << 7) | ((window & 0x0FFFE0000) >> 17);
 		if (win_read != temp1) {
 			DEBUG2(printk("%s: Written OCMwin (0x%x) != Read OCMwin (0x%x)\n",
@@ -597,8 +597,8 @@ qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
 		/* QDR network side */
 		window = MS_WIN(addr);
 		ha->qdr_sn_window = window;
-		qla82xx_wr_32(ha, ha->ms_win_crb | QLA82XX_PCI_CRBSPACE, window);
-		win_read = qla82xx_rd_32(ha, ha->ms_win_crb | QLA82XX_PCI_CRBSPACE);
+		qla4_8xxx_wr_32(ha, ha->ms_win_crb | QLA82XX_PCI_CRBSPACE, window);
+		win_read = qla4_8xxx_rd_32(ha, ha->ms_win_crb | QLA82XX_PCI_CRBSPACE);
 		if (win_read != window) {
 			DEBUG2(printk("%s: Written MSwin (0x%x) != Read MSwin (0x%x)\n",
 			__func__, window, win_read));
@@ -610,8 +610,8 @@ qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
 		 * peg gdb frequently accesses memory that doesn't exist,
 		 * this limits the chit chat so debugging isn't slowed down.
 		 */
-		if ((qla82xx_pci_set_window_warning_count++ < 8)
-				|| (qla82xx_pci_set_window_warning_count % 64 == 0)) {
+		if ((qla4_8xxx_pci_set_window_warning_count++ < 8)
+				|| (qla4_8xxx_pci_set_window_warning_count % 64 == 0)) {
 			DEBUG2(printk("%s: Warning:%s Unknown address range!\n", __func__,
 						DRIVER_NAME));
 		}
@@ -621,7 +621,7 @@ qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
 }
 
 /* check if address is in the same windows as the previous access */
-static int qla82xx_pci_is_same_window(struct scsi_qla_host *ha,
+static int qla4_8xxx_pci_is_same_window(struct scsi_qla_host *ha,
 		unsigned long long addr)
 {
 	int window;
@@ -650,7 +650,7 @@ static int qla82xx_pci_is_same_window(struct scsi_qla_host *ha,
 	return 0;
 }
 
-static int qla82xx_pci_mem_read_direct(struct scsi_qla_host *ha,
+static int qla4_8xxx_pci_mem_read_direct(struct scsi_qla_host *ha,
 			u64 off, void *data, int size)
 {
 	unsigned long   flags;
@@ -667,16 +667,16 @@ static int qla82xx_pci_mem_read_direct(struct scsi_qla_host *ha,
 	 * If attempting to access unknown address or straddle hw windows,
 	 * do not access.
 	 */
-	start = qla82xx_pci_set_window(ha, off);
+	start = qla4_8xxx_pci_set_window(ha, off);
 	if ((start == -1UL) ||
-	    (qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {
+	    (qla4_8xxx_pci_is_same_window(ha, off + size - 1) == 0)) {
 		write_unlock_irqrestore(&ha->hw_lock, flags);
 		DEBUG2(printk(KERN_ERR"%s out of bound pci memory access. "
 		    "offset is 0x%llx\n", DRIVER_NAME, off));
 		return -1;
 	}
 
-	addr = qla82xx_pci_base_offsetfset(ha, start);
+	addr = qla4_8xxx_pci_base_offsetfset(ha, start);
 	if (!addr) {
 		write_unlock_irqrestore(&ha->hw_lock, flags);
 		mem_base = pci_resource_start(ha->pdev, 0);
@@ -722,7 +722,7 @@ static int qla82xx_pci_mem_read_direct(struct scsi_qla_host *ha,
 }
 
 static int
-qla82xx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,
+qla4_8xxx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,
 		void *data, int size)
 {
 	unsigned long flags;
@@ -739,16 +739,16 @@ qla82xx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,
 	 * If attempting to access unknown address or straddle hw windows,
 	 * do not access.
 	 */
-	start = qla82xx_pci_set_window(ha, off);
+	start = qla4_8xxx_pci_set_window(ha, off);
 	if ((start == -1UL) ||
-	    (qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {
+	    (qla4_8xxx_pci_is_same_window(ha, off + size - 1) == 0)) {
 		write_unlock_irqrestore(&ha->hw_lock, flags);
 		DEBUG2(printk("%s out of bound pci memory access. "
 		    "offset is 0x%llx\n", DRIVER_NAME, off));
 		return -1;
 	}
 
-	addr = qla82xx_pci_base_offsetfset(ha, start);
+	addr = qla4_8xxx_pci_base_offsetfset(ha, start);
 	if (!addr) {
 		write_unlock_irqrestore(&ha->hw_lock, flags);
 		mem_base = pci_resource_start(ha->pdev, 0);
@@ -794,13 +794,13 @@ qla82xx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,
 #define MTU_FUDGE_FACTOR 100
 
 static unsigned long
-qla82xx_decode_crb_addr(unsigned long addr)
+qla4_8xxx_decode_crb_addr(unsigned long addr)
 {
 	int i;
 	unsigned long base_addr, offset, pci_base;
 
-	if (!qla82xx_crb_table_initialized)
-		qla82xx_crb_addr_transform_setup();
+	if (!qla4_8xxx_crb_table_initialized)
+		qla4_8xxx_crb_addr_transform_setup();
 
 	pci_base = ADDR_ERROR;
 	base_addr = addr & 0xfff00000;
@@ -819,10 +819,10 @@ qla82xx_decode_crb_addr(unsigned long addr)
 }
 
 static long rom_max_timeout = 100;
-static long qla82xx_rom_lock_timeout = 100;
+static long qla4_8xxx_rom_lock_timeout = 100;
 
 static int
-qla82xx_rom_lock(struct scsi_qla_host *ha)
+qla4_8xxx_rom_lock(struct scsi_qla_host *ha)
 {
 	int i;
 	int done = 0, timeout = 0;
@@ -830,10 +830,10 @@ qla82xx_rom_lock(struct scsi_qla_host *ha)
 	while (!done) {
 		/* acquire semaphore2 from PCI HW block */
 
-		done = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));
+		done = qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));
 		if (done == 1)
 			break;
-		if (timeout >= qla82xx_rom_lock_timeout)
+		if (timeout >= qla4_8xxx_rom_lock_timeout)
 			return -1;
 
 		timeout++;
@@ -846,24 +846,24 @@ qla82xx_rom_lock(struct scsi_qla_host *ha)
 				cpu_relax();    /*This a nop instr on i386*/
 		}
 	}
-	qla82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ROM_LOCK_DRIVER);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ROM_LOCK_DRIVER);
 	return 0;
 }
 
 static void
-qla82xx_rom_unlock(struct scsi_qla_host *ha)
+qla4_8xxx_rom_unlock(struct scsi_qla_host *ha)
 {
-	qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));
+	qla4_8xxx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));
 }
 
 static int
-qla82xx_wait_rom_done(struct scsi_qla_host *ha)
+qla4_8xxx_wait_rom_done(struct scsi_qla_host *ha)
 {
 	long timeout = 0;
 	long done = 0 ;
 
 	while (done == 0) {
-		done = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);
+		done = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);
 		done &= 2;
 		timeout++;
 		if (timeout >= rom_max_timeout) {
@@ -876,41 +876,41 @@ qla82xx_wait_rom_done(struct scsi_qla_host *ha)
 }
 
 static int
-qla82xx_do_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
+qla4_8xxx_do_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
 {
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0xb);
-	if (qla82xx_wait_rom_done(ha)) {
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0xb);
+	if (qla4_8xxx_wait_rom_done(ha)) {
 		DEBUG2(printk("%s: Error waiting for rom done\n", DRIVER_NAME));
 		return -1;
 	}
 	/* reset abyte_cnt and dummy_byte_cnt */
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);
 	udelay(10);
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);
 
-	*valp = qla82xx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);
+	*valp = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);
 	return 0;
 }
 
 static int
-qla82xx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
+qla4_8xxx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
 {
 	int ret, loops = 0;
 
-	while ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {
+	while ((qla4_8xxx_rom_lock(ha) != 0) && (loops < 50000)) {
 		udelay(100);
 		schedule();
 		loops++;
 	}
 	if (loops >= 50000) {
-		DEBUG2(printk("%s: qla82xx_rom_lock failed\n", DRIVER_NAME));
+		DEBUG2(printk("%s: qla4_8xxx_rom_lock failed\n", DRIVER_NAME));
 		return -1;
 	}
-	ret = qla82xx_do_rom_fast_read(ha, addr, valp);
-	qla82xx_rom_unlock(ha);
+	ret = qla4_8xxx_do_rom_fast_read(ha, addr, valp);
+	qla4_8xxx_rom_unlock(ha);
 	return ret;
 }
 
@@ -919,7 +919,7 @@ qla82xx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
  * to put the ISP into operational state
  **/
 static int
-qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
+qla4_8xxx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 {
 	int addr, val;
 	int i ;
@@ -934,19 +934,19 @@ qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	};
 
 	/* Grab the lock so that no one can read flash when we reset the chip. */
-	qla82xx_rom_lock(ha);
+	qla4_8xxx_rom_lock(ha);
 
 	if (test_bit(DPC_RESET_HA, &ha->dpc_flags)) { /* don't reset CAM block on reset */
-		qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);
+		qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);
 	} else {
-		qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);
+		qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);
 	}
 
 	/* Just in case it was held when we reset the chip */
-	qla82xx_rom_unlock(ha);
+	qla4_8xxx_rom_unlock(ha);
 
-	if (qla82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||
-		qla82xx_rom_fast_read(ha, 4, &n) != 0) {
+	if (qla4_8xxx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||
+		qla4_8xxx_rom_fast_read(ha, 4, &n) != 0) {
 		DEBUG2(printk("[ERROR] Reading crb_init area: n: %08x\n", n));
 		return -1;
 	}
@@ -967,8 +967,8 @@ qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	}
 
 	for (i = 0; i < n; i++) {
-		if (qla82xx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||
-			qla82xx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) != 0) {
+		if (qla4_8xxx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||
+			qla4_8xxx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) != 0) {
 			kfree(buf);
 			return -1;
 		}
@@ -978,7 +978,7 @@ qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	}
 
 	for (i = 0; i < n; i++) {
-		off = qla82xx_decode_crb_addr((unsigned long)buf[i].addr) + QLA82XX_PCI_CRBSPACE;
+		off = qla4_8xxx_decode_crb_addr((unsigned long)buf[i].addr) + QLA82XX_PCI_CRBSPACE;
 		/* skipping cold reboot MAGIC */
 		if (off == QLA82XX_CAM_RAM(0x1fc))
 			continue;
@@ -1014,7 +1014,7 @@ qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 			init_delay = 1;
 		}
 
-		qla82xx_wr_32(ha, off, buf[i].data);
+		qla4_8xxx_wr_32(ha, off, buf[i].data);
 		if (init_delay == 1) {
 			msleep(1000);
 			init_delay = 0;
@@ -1025,33 +1025,33 @@ qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	kfree(buf);
 
 	/* p2dn replyCount */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D + 0xec, 0x1e);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_D + 0xec, 0x1e);
 	/* disable_peg_cache 0 */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D + 0x4c, 8);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_D + 0x4c, 8);
 	/* disable_peg_cache 1 */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_I + 0x4c, 8);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_I + 0x4c, 8);
 
 	/* peg_clr_all */
 	/* peg_clr 0 */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x8, 0);
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0xc, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x8, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0xc, 0);
 	/* peg_clr 1 */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x8, 0);
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0xc, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x8, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0xc, 0);
 	/* peg_clr 2 */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x8, 0);
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0xc, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x8, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0xc, 0);
 	/* peg_clr 3 */
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x8, 0);
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0xc, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x8, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0xc, 0);
 
 	return 0;
 }
 
-static int qla82xx_check_for_bad_spd(struct scsi_qla_host *ha)
+static int qla4_8xxx_check_for_bad_spd(struct scsi_qla_host *ha)
 {
 	u32 val = 0;
-	val = qla82xx_rd_32(ha, BOOT_LOADER_DIMM_STATUS) ;
+	val = qla4_8xxx_rd_32(ha, BOOT_LOADER_DIMM_STATUS) ;
 	val &= QLA82XX_BOOT_LOADER_MN_ISSUE;
 	if (val & QLA82XX_PEG_TUNE_MN_SPD_ZEROED) {
 		printk("Memory DIMM SPD not programmed.  Assumed valid.\n");
@@ -1064,7 +1064,7 @@ static int qla82xx_check_for_bad_spd(struct scsi_qla_host *ha)
 }
 
 static int
-qla82xx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
+qla4_8xxx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
 {
 	int  i;
 	long size = 0;
@@ -1079,12 +1079,12 @@ qla82xx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
 				ha->host_no, __func__, flashaddr, image_start));
 
 		for (i = 0; i < size; i++) {
-			if ((qla82xx_rom_fast_read(ha, flashaddr, (int *)&low)) ||
-			    (qla82xx_rom_fast_read(ha, flashaddr + 4, (int *)&high))) {
+			if ((qla4_8xxx_rom_fast_read(ha, flashaddr, (int *)&low)) ||
+			    (qla4_8xxx_rom_fast_read(ha, flashaddr + 4, (int *)&high))) {
 				return -1;
 			}
 			data = ((u64)high << 32) | low ;
-			qla82xx_pci_mem_write_2M(ha, memaddr, &data, 8);
+			qla4_8xxx_pci_mem_write_2M(ha, memaddr, &data, 8);
 			flashaddr += 8;
 			memaddr   += 8;
 
@@ -1096,18 +1096,18 @@ qla82xx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
 	udelay(100);
 
 	read_lock(&ha->hw_lock);
-	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);
 	read_unlock(&ha->hw_lock);
 	return 0;
 }
 
-static int qla82xx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)
+static int qla4_8xxx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)
 {
 	u32 rst;
 
-	qla82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);
-	if (qla82xx_pinit_from_rom(ha, 0) != QLA_SUCCESS) {
+	qla4_8xxx_wr_32(ha, CRB_CMDPEG_STATE, 0);
+	if (qla4_8xxx_pinit_from_rom(ha, 0) != QLA_SUCCESS) {
 		printk(KERN_WARNING "%s: Error during CRB Initialization\n",
 					__func__);
 		return QLA_ERROR;
@@ -1120,12 +1120,12 @@ static int qla82xx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)
 	 * To get around this, QM is brought out of reset.
 	 */
 
-	rst = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);
+	rst = qla4_8xxx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);
 	/* unreset qm */
 	rst &= ~(1 << 28);
-	qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);
+	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);
 
-	if (qla82xx_load_from_flash(ha, image_start)) {
+	if (qla4_8xxx_load_from_flash(ha, image_start)) {
 		DEBUG2(printk("%s: Error trying to load fw from flash!\n", __func__));
 		return QLA_ERROR;
 	}
@@ -1133,7 +1133,7 @@ static int qla82xx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)
 }
 
 int
-qla82xx_pci_mem_read_2M(struct scsi_qla_host *ha,
+qla4_8xxx_pci_mem_read_2M(struct scsi_qla_host *ha,
 		u64 off, void *data, int size)
 {
 	int i, j = 0, k, start, end, loop, sz[2], off0[2];
@@ -1149,8 +1149,8 @@ qla82xx_pci_mem_read_2M(struct scsi_qla_host *ha,
 		mem_crb = QLA82XX_CRB_QDR_NET;
 	else {
 		mem_crb = QLA82XX_CRB_DDR_NET;
-		if (qla82xx_pci_mem_bound_check(ha, off, size) == 0)
-			return qla82xx_pci_mem_read_direct(ha,
+		if (qla4_8xxx_pci_mem_bound_check(ha, off, size) == 0)
+			return qla4_8xxx_pci_mem_read_direct(ha,
 					off, data, size);
 	}
 
@@ -1165,16 +1165,16 @@ qla82xx_pci_mem_read_2M(struct scsi_qla_host *ha,
 
 	for (i = 0; i < loop; i++) {
 		temp = off8 + (i << shift_amount);
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);
 		temp = 0;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);
 		temp = MIU_TA_CTL_ENABLE;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
 		temp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
 
 		for (j = 0; j < MAX_CTL_CHECK; j++) {
-			temp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);
+			temp = qla4_8xxx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);
 			if ((temp & MIU_TA_CTL_BUSY) == 0)
 				break;
 		}
@@ -1189,7 +1189,7 @@ qla82xx_pci_mem_read_2M(struct scsi_qla_host *ha,
 		start = off0[i] >> 2;
 		end   = (off0[i] + sz[i] - 1) >> 2;
 		for (k = start; k <= end; k++) {
-			temp = qla82xx_rd_32(ha,
+			temp = qla4_8xxx_rd_32(ha,
 				mem_crb + MIU_TEST_AGT_RDDATA(k));
 			word[i] |= ((uint64_t)temp << (32 * (k & 1)));
 		}
@@ -1223,7 +1223,7 @@ qla82xx_pci_mem_read_2M(struct scsi_qla_host *ha,
 }
 
 int
-qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha,
+qla4_8xxx_pci_mem_write_2M(struct scsi_qla_host *ha,
 		u64 off, void *data, int size)
 {
 	int i, j, ret = 0, loop, sz[2], off0;
@@ -1238,8 +1238,8 @@ qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha,
 		mem_crb = QLA82XX_CRB_QDR_NET;
 	else {
 		mem_crb = QLA82XX_CRB_DDR_NET;
-		if (qla82xx_pci_mem_bound_check(ha, off, size) == 0)
-			return qla82xx_pci_mem_write_direct(ha,
+		if (qla4_8xxx_pci_mem_bound_check(ha, off, size) == 0)
+			return qla4_8xxx_pci_mem_write_direct(ha,
 					off, data, size);
 	}
 
@@ -1254,7 +1254,7 @@ qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha,
 	startword = (off & 0xf)/8;
 
 	for (i = 0; i < loop; i++) {
-		if (qla82xx_pci_mem_read_2M(ha, off8 + (i << shift_amount),
+		if (qla4_8xxx_pci_mem_read_2M(ha, off8 + (i << shift_amount),
 					&word[i * scale], 8))
 			return -1;
 	}
@@ -1289,25 +1289,25 @@ qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha,
 
 	for (i = 0; i < loop; i++) {
 		temp = off8 + (i << shift_amount);
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);
 		temp = 0;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);
 		temp = word[i * scale] & 0xffffffff;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_LO, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_LO, temp);
 		temp = (word[i * scale] >> 32) & 0xffffffff;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_HI, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_HI, temp);
 		temp = word[i*scale + 1] & 0xffffffff;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_LO, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_LO, temp);
 		temp = (word[i*scale + 1] >> 32) & 0xffffffff;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_HI, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_HI, temp);
 
 		temp = MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
 		temp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;
-		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+		qla4_8xxx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
 
 		for (j = 0; j < MAX_CTL_CHECK; j++) {
-			temp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);
+			temp = qla4_8xxx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);
 			if ((temp & MIU_TA_CTL_BUSY) == 0)
 				break;
 		}
@@ -1324,14 +1324,14 @@ qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha,
 	return ret;
 }
 
-static int qla82xx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)
+static int qla4_8xxx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)
 {
 	u32 val = 0;
 	int retries = 60;
 
 	if (!pegtune_val) {
 		do {
-			val = qla82xx_rd_32(ha, CRB_CMDPEG_STATE);
+			val = qla4_8xxx_rd_32(ha, CRB_CMDPEG_STATE);
 			if ((val == PHAN_INITIALIZE_COMPLETE) ||
 			     (val == PHAN_INITIALIZE_ACK))
 				return 0;
@@ -1340,10 +1340,10 @@ static int qla82xx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)
 
 		} while (--retries);
 
-		qla82xx_check_for_bad_spd(ha);
+		qla4_8xxx_check_for_bad_spd(ha);
 
 		if (!retries) {
-			pegtune_val = qla82xx_rd_32(ha,
+			pegtune_val = qla4_8xxx_rd_32(ha,
 			    QLA82XX_ROMUSB_GLB_PEGTUNE_DONE);
 			printk(KERN_WARNING "%s: init failed, "
 			    "pegtune_val = %x\n", __func__, pegtune_val);
@@ -1354,14 +1354,14 @@ static int qla82xx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)
 	return 0;
 }
 
-static int qla82xx_rcvpeg_ready(struct scsi_qla_host *ha)
+static int qla4_8xxx_rcvpeg_ready(struct scsi_qla_host *ha)
 {
 	uint32_t state = 0;
 	int loops = 0, err = 0;
 
 	/* Window 1 call */
 	read_lock(&ha->hw_lock);
-	state = qla82xx_rd_32(ha, CRB_RCVPEG_STATE);
+	state = qla4_8xxx_rd_32(ha, CRB_RCVPEG_STATE);
 	read_unlock(&ha->hw_lock);
 
 	while ((state != PHAN_PEG_RCV_INITIALIZED) && (loops < 30000)) {
@@ -1370,7 +1370,7 @@ static int qla82xx_rcvpeg_ready(struct scsi_qla_host *ha)
 		/* Window 1 call */
 
 		read_lock(&ha->hw_lock);
-		state = qla82xx_rd_32(ha, CRB_RCVPEG_STATE);
+		state = qla4_8xxx_rd_32(ha, CRB_RCVPEG_STATE);
 		read_unlock(&ha->hw_lock);
 
 		loops++;
@@ -1385,90 +1385,90 @@ static int qla82xx_rcvpeg_ready(struct scsi_qla_host *ha)
 }
 
 static inline void
-qla82xx_set_drv_active(struct scsi_qla_host *ha)
+qla4_8xxx_set_drv_active(struct scsi_qla_host *ha)
 {
 	uint32_t drv_active;
 
-	drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+	drv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
 
 	drv_active |= (1 << (ha->portnum * 4));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);
 }
 
 void
-qla82xx_clear_drv_active(struct scsi_qla_host *ha)
+qla4_8xxx_clear_drv_active(struct scsi_qla_host *ha)
 {
 	uint32_t drv_active;
 
-	drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+	drv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
 	drv_active &= ~(1 << (ha->portnum * 4));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);
 }
 
 static inline int
-qla82xx_need_reset(struct scsi_qla_host *ha)
+qla4_8xxx_need_reset(struct scsi_qla_host *ha)
 {
 	uint32_t drv_state;
 	int rval;
 
-	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	drv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
 	rval = drv_state & (1 << (ha->portnum * 4));
 	return rval;
 }
 
 static inline void
-qla82xx_set_rst_ready(struct scsi_qla_host *ha)
+qla4_8xxx_set_rst_ready(struct scsi_qla_host *ha)
 {
 	uint32_t drv_state;
 
-	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	drv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
 
 	drv_state |= (1 << (ha->portnum * 4));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);
 }
 
 static inline void
-qla82xx_clear_rst_ready(struct scsi_qla_host *ha)
+qla4_8xxx_clear_rst_ready(struct scsi_qla_host *ha)
 {
 	uint32_t drv_state;
 
-	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	drv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
 	drv_state &= ~(1 << (ha->portnum * 4));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);
 }
 
 static inline void
-qla82xx_set_qsnt_ready(struct scsi_qla_host *ha)
+qla4_8xxx_set_qsnt_ready(struct scsi_qla_host *ha)
 {
 	uint32_t qsnt_state;
 
-	qsnt_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	qsnt_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
 	qsnt_state |= (2 << (ha->portnum * 4));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);
 }
 
 static int
-qla82xx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)
+qla4_8xxx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)
 {
 	int           pcie_cap;
 	uint16_t      lnk;
 
 	/* scrub dma mask expansion register */
-	qla82xx_wr_32(ha, CRB_DMA_SHIFT, 0x55555555);
+	qla4_8xxx_wr_32(ha, CRB_DMA_SHIFT, 0x55555555);
 
 	/* Overwrite stale initialization register values */
-	qla82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);
-	qla82xx_wr_32(ha, CRB_RCVPEG_STATE, 0);
-	qla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);
-	qla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);
+	qla4_8xxx_wr_32(ha, CRB_CMDPEG_STATE, 0);
+	qla4_8xxx_wr_32(ha, CRB_RCVPEG_STATE, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);
+	qla4_8xxx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);
 
-	if (qla82xx_load_fw(ha, image_start) != QLA_SUCCESS) {
+	if (qla4_8xxx_load_fw(ha, image_start) != QLA_SUCCESS) {
 		printk("%s: Error trying to start fw!\n", __func__);
 		return QLA_ERROR;
 	}
 
 	/* Handshake with the card before we register the devices. */
-	if (qla82xx_cmdpeg_ready(ha, 0) != QLA_SUCCESS) {
+	if (qla4_8xxx_cmdpeg_ready(ha, 0) != QLA_SUCCESS) {
 		printk("%s: Error during card handshake!\n", __func__);
 		return QLA_ERROR;
 	}
@@ -1479,11 +1479,11 @@ qla82xx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)
 	ha->link_width = (lnk >> 4) & 0x3f;
 
 	/* Synchronize with Receive peg */
-	return qla82xx_rcvpeg_ready(ha);
+	return qla4_8xxx_rcvpeg_ready(ha);
 }
 
 static int
-qla82xx_try_start_fw(struct scsi_qla_host *ha)
+qla4_8xxx_try_start_fw(struct scsi_qla_host *ha)
 {
 	int rval = QLA_ERROR;
 
@@ -1494,11 +1494,11 @@ qla82xx_try_start_fw(struct scsi_qla_host *ha)
 	 */
 
 	DEBUG2(printk(KERN_INFO"FW: Retrieving flash offsets from FLT/FDT ...\n"));
-	rval = qla82xx_get_flash_info(ha);
+	rval = qla4_8xxx_get_flash_info(ha);
 	if (rval != QLA_SUCCESS)
 		return rval;
 
-	rval = qla82xx_start_firmware(ha, ha->hw.flt_region_fw);
+	rval = qla4_8xxx_start_firmware(ha, ha->hw.flt_region_fw);
 	if (rval == QLA_SUCCESS)
 		return rval;
 
@@ -1508,31 +1508,31 @@ qla82xx_try_start_fw(struct scsi_qla_host *ha)
 }
 
 /**
- * qla82xx_device_bootstrap - Initialize device, set DEV_READY, start fw
+ * qla4_8xxx_device_bootstrap - Initialize device, set DEV_READY, start fw
  * @ha: pointer to adapter structure
  *
  * Note: IDC lock must be held upon entry
  **/
 static int
-qla82xx_device_bootstrap(struct scsi_qla_host *ha)
+qla4_8xxx_device_bootstrap(struct scsi_qla_host *ha)
 {
 	int rval, i, timeout;
 	uint32_t old_count, count;
 
-	if (qla82xx_need_reset(ha))
+	if (qla4_8xxx_need_reset(ha))
 		goto dev_initialize;
 
-	old_count = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+	old_count = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
 
 	for (i = 0; i < 10; i++) {
 		timeout = msleep_interruptible(200);
 		if (timeout) {
-			qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+			qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
 			    QLA82XX_DEV_FAILED);
 			return QLA_ERROR;  /* FIXME: CHANGE AT LATER POINT IN TIME */
 		}
 
-		count = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+		count = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
 		if (count != old_count)
 			goto dev_ready;
 	}
@@ -1540,37 +1540,37 @@ qla82xx_device_bootstrap(struct scsi_qla_host *ha)
 dev_initialize:
 	/* set to DEV_INITIALIZING */
 	DEBUG2(printk(KERN_INFO"HW State: INITIALIZING\n"));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_INITIALIZING);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_INITIALIZING);
 
 	/* Driver that sets device state to initializating sets IDC version */
-	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION, QLA82XX_IDC_VERSION);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION, QLA82XX_IDC_VERSION);
 
-	qla82xx_idc_unlock(ha);
-	rval = qla82xx_try_start_fw(ha);
-	qla82xx_idc_lock(ha);
+	qla4_8xxx_idc_unlock(ha);
+	rval = qla4_8xxx_try_start_fw(ha);
+	qla4_8xxx_idc_lock(ha);
 
 	if (rval != QLA_SUCCESS) {
 		DEBUG2(printk(KERN_INFO"HW State: FAILED\n"));
-		qla82xx_clear_drv_active(ha);
-		qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);
+		qla4_8xxx_clear_drv_active(ha);
+		qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);
 		return rval;
 	}
 
 dev_ready:
 	DEBUG2(printk(KERN_INFO"HW State: READY\n"));
-	qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_READY);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_READY);
 
 	return QLA_SUCCESS;
 }
 
 /**
- * qla82xx_need_reset_handler - Code to start reset sequence
+ * qla4_8xxx_need_reset_handler - Code to start reset sequence
  * @ha: pointer to adapter structure
  *
  * Note: IDC lock must be held upon entry
  **/
 static void
-qla82xx_need_reset_handler(struct scsi_qla_host *ha)
+qla4_8xxx_need_reset_handler(struct scsi_qla_host *ha)
 {
 	uint32_t dev_state, drv_state, drv_active;
 	unsigned long reset_timeout;
@@ -1578,18 +1578,18 @@ qla82xx_need_reset_handler(struct scsi_qla_host *ha)
 	DEBUG2(printk(KERN_INFO"Performing ISP error recovery\n"));
 
 	if (test_and_clear_bit(AF_ONLINE, &ha->flags)) {
-		qla82xx_idc_unlock(ha);
+		qla4_8xxx_idc_unlock(ha);
 		ha->isp_ops->disable_intrs(ha);
-		qla82xx_idc_lock(ha);
+		qla4_8xxx_idc_lock(ha);
 	}
 
-	qla82xx_set_rst_ready(ha);
+	qla4_8xxx_set_rst_ready(ha);
 
 	/* wait for 10 seconds for reset ack from all functions */
 	reset_timeout = jiffies + (ha->nx_reset_timeout * HZ);
 
-	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
-	drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+	drv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	drv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
 
 	while (drv_state != drv_active) {
 
@@ -1598,42 +1598,42 @@ qla82xx_need_reset_handler(struct scsi_qla_host *ha)
 			break;
 		}
 
-		qla82xx_idc_unlock(ha);
+		qla4_8xxx_idc_unlock(ha);
 		msleep(1000);
-		qla82xx_idc_lock(ha);
+		qla4_8xxx_idc_lock(ha);
 
-		drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
-		drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+		drv_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+		drv_active = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
 	}
 
-	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+	dev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
 
 	/* Force to DEV_COLD unless someone else is starting a reset */
 	if (dev_state != QLA82XX_DEV_INITIALIZING) {
 		DEBUG2(printk(KERN_INFO"HW State: COLD/RE-INIT\n"));
-		qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_COLD);
+		qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_COLD);
 	}
 }
 
 /**
- * qla82xx_need_qsnt_handler - Code to start qsnt
+ * qla4_8xxx_need_qsnt_handler - Code to start qsnt
  * @ha: pointer to adapter structure
  **/
 void
-qla82xx_need_qsnt_handler(struct scsi_qla_host *ha)
+qla4_8xxx_need_qsnt_handler(struct scsi_qla_host *ha)
 {
-	qla82xx_idc_lock(ha);
-	qla82xx_set_qsnt_ready(ha);
-	qla82xx_idc_unlock(ha);
+	qla4_8xxx_idc_lock(ha);
+	qla4_8xxx_set_qsnt_ready(ha);
+	qla4_8xxx_idc_unlock(ha);
 }
 
 /*
- * qla82xx_device_state_handler - Adapter state machine
+ * qla4_8xxx_device_state_handler - Adapter state machine
  * @ha: pointer to host adapter structure.
  *
  * Note: IDC lock must be held upon entry
  **/
-int qla82xx_device_state_handler(struct scsi_qla_host *ha)
+int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 {
 	uint32_t dev_state;
 	int rval = QLA_SUCCESS;
@@ -1641,54 +1641,54 @@ int qla82xx_device_state_handler(struct scsi_qla_host *ha)
 
 	if (!test_bit(AF_INIT_DONE, &ha->flags)) {
 		DEBUG2(printk("scsi%ld: %s: calling set_drv_active\n", ha->host_no, __func__));
-		qla82xx_set_drv_active(ha);
+		qla4_8xxx_set_drv_active(ha);
 	}
 
 	/* wait for 30 seconds for device to go ready */
 	dev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);
 
 	while (1) {
-		qla82xx_idc_lock(ha);
+		qla4_8xxx_idc_lock(ha);
 
 		if (time_after_eq(jiffies, dev_init_timeout)) {
 			DEBUG2(printk("%s: device init failed!\n", DRIVER_NAME));
-			qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);
+			qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);
 			DEBUG2(printk("HW State: Failed\n"));
 		}
 
-		dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+		dev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
 		DEBUG2(printk("scsi%ld: %s: dev_state = 0x%x\n", ha->host_no, __func__, dev_state));
 		/* NOTE: Make sure idc unlocked upon exit of switch statement */
 		switch (dev_state) {
 		case QLA82XX_DEV_READY:
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			goto exit;
 		case QLA82XX_DEV_COLD:
-			rval = qla82xx_device_bootstrap(ha);
-			qla82xx_idc_unlock(ha);
+			rval = qla4_8xxx_device_bootstrap(ha);
+			qla4_8xxx_idc_unlock(ha);
 			goto exit;
 		case QLA82XX_DEV_INITIALIZING:
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			msleep(1000);
 			break;
 		case QLA82XX_DEV_NEED_RESET:
 			if (!ql4xdontresethba)
-				qla82xx_need_reset_handler(ha);
+				qla4_8xxx_need_reset_handler(ha);
 			/* Update timeout value after need reset handler */
 			dev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			break;
 		case QLA82XX_DEV_NEED_QUIESCENT:
-			qla82xx_idc_unlock(ha);
-			qla82xx_need_qsnt_handler(ha);
-			qla82xx_idc_lock(ha);
+			qla4_8xxx_idc_unlock(ha);
+			qla4_8xxx_need_qsnt_handler(ha);
+			qla4_8xxx_idc_lock(ha);
 		case QLA82XX_DEV_QUIESCENT:
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			DEBUG2(printk("scsi%ld: %s: quiescent.. sleep\n", ha->host_no, __func__));
 			msleep(1000);
 			break;
 		case QLA82XX_DEV_FAILED:
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			qla4xxx_dead_adapter_cleanup(ha);
 			rval = QLA_ERROR;
 			goto exit;
@@ -1697,7 +1697,7 @@ int qla82xx_device_state_handler(struct scsi_qla_host *ha)
 			 * contains unknown value during reset
 			 */
 			DEBUG2(printk("scsi%ld: %s: default.. sleep\n", ha->host_no, __func__));
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			qla4xxx_dead_adapter_cleanup(ha);
 			rval = QLA_ERROR;
 			goto exit;
@@ -1707,29 +1707,29 @@ exit:
 	return rval;
 }
 
-int qla82xx_load_risc(struct scsi_qla_host *ha)
+int qla4_8xxx_load_risc(struct scsi_qla_host *ha)
 {
-	return qla82xx_device_state_handler(ha);
+	return qla4_8xxx_device_state_handler(ha);
 }
 
 
 
 /* ISR related functions */
-uint32_t qla82xx_isr_int_target_mask_enable[8] = {
+uint32_t qla4_8xxx_isr_int_target_mask_enable[8] = {
 	ISR_INT_TARGET_MASK, ISR_INT_TARGET_MASK_F1,
 	ISR_INT_TARGET_MASK_F2, ISR_INT_TARGET_MASK_F3,
 	ISR_INT_TARGET_MASK_F4, ISR_INT_TARGET_MASK_F5,
 	ISR_INT_TARGET_MASK_F7, ISR_INT_TARGET_MASK_F7
 };
 
-uint32_t qla82xx_isr_int_target_status[8] = {
+uint32_t qla4_8xxx_isr_int_target_status[8] = {
 	ISR_INT_TARGET_STATUS, ISR_INT_TARGET_STATUS_F1,
 	ISR_INT_TARGET_STATUS_F2, ISR_INT_TARGET_STATUS_F3,
 	ISR_INT_TARGET_STATUS_F4, ISR_INT_TARGET_STATUS_F5,
 	ISR_INT_TARGET_STATUS_F7, ISR_INT_TARGET_STATUS_F7
 };
 
-static struct qla82xx_legacy_intr_set legacy_intr[] = {
+static struct qla4_8xxx_legacy_intr_set legacy_intr[] = {
 	{
 		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F0,
 		.tgt_status_reg =       ISR_INT_TARGET_STATUS,
@@ -1774,7 +1774,7 @@ static struct qla82xx_legacy_intr_set legacy_intr[] = {
 
 void qla80xx_update_crb_int_ptr(struct scsi_qla_host *ha)
 {
-	struct qla82xx_legacy_intr_set *nx_legacy_intr;
+	struct qla4_8xxx_legacy_intr_set *nx_legacy_intr;
 
 	nx_legacy_intr = &legacy_intr[ha->portnum];
 
@@ -1785,11 +1785,11 @@ void qla80xx_update_crb_int_ptr(struct scsi_qla_host *ha)
 }
 
 /**
- * qla82xx_init_local_data - initialize adapter specific local data
+ * qla4_8xxx_init_local_data - initialize adapter specific local data
  * @ha: pointer to host adapter structure.
  *
  **/
-void qla82xx_init_local_data(struct scsi_qla_host *ha)
+void qla4_8xxx_init_local_data(struct scsi_qla_host *ha)
 {
 	/* ISP 8022 initializations */
 	rwlock_init(&ha->hw_lock);
@@ -1824,13 +1824,13 @@ flash_data_addr(struct ql82xx_hw_data *hw, uint32_t faddr)
 }
 
 static uint32_t *
-qla82xx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,
+qla4_8xxx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,
     uint32_t faddr, uint32_t length)
 {
 	uint32_t i;
 	uint32_t val;
 	int loops = 0;
-	while ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {
+	while ((qla4_8xxx_rom_lock(ha) != 0) && (loops < 50000)) {
 		udelay(100);
 		cond_resched();
 		loops++;
@@ -1843,7 +1843,7 @@ qla82xx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,
 
 	/* Dword reads to flash. */
 	for (i = 0; i < length/4; i++, faddr += 4) {
-		if (qla82xx_do_rom_fast_read(ha, faddr, &val)) {
+		if (qla4_8xxx_do_rom_fast_read(ha, faddr, &val)) {
 			dev_warn(&ha->pdev->dev,
 			    "Do ROM fast read failed\n");
 			goto done_read;
@@ -1852,7 +1852,7 @@ qla82xx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,
 	}
 
 done_read:
-	qla82xx_rom_unlock(ha);
+	qla4_8xxx_rom_unlock(ha);
 	return dwptr;
 }
 
@@ -1860,15 +1860,15 @@ done_read:
  * Address and length are byte address
  **/
 static uint8_t *
-qla82xx_read_optrom_data(struct scsi_qla_host *ha, uint8_t *buf,
+qla4_8xxx_read_optrom_data(struct scsi_qla_host *ha, uint8_t *buf,
     uint32_t offset, uint32_t length)
 {
-	qla82xx_read_flash_data(ha, (uint32_t *)buf, offset, length);
+	qla4_8xxx_read_flash_data(ha, (uint32_t *)buf, offset, length);
 	return buf;
 }
 
 static int
-qla82xx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)
+qla4_8xxx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)
 {
 	const char *loc, *locations[] = { "DEF", "PCI" };
 
@@ -1884,7 +1884,7 @@ qla82xx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)
 }
 
 static void
-qla82xx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)
+qla4_8xxx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)
 {
 	const char *loc, *locations[] = { "DEF", "FLT" };
 	uint16_t *wptr;
@@ -1898,7 +1898,7 @@ qla82xx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)
 	wptr = (uint16_t *)ha->request_ring;
 	flt = (struct qla_flt_header *)ha->request_ring;
 	region = (struct qla_flt_region *)&flt[1];
-	qla82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
+	qla4_8xxx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
 	    flt_addr << 2, OPTROM_BURST_SIZE);
 	if (*wptr == __constant_cpu_to_le16(0xffff))
 		goto no_flash_data;
@@ -1966,7 +1966,7 @@ done:
 }
 
 static void
-qla82xx_get_fdt_info(struct scsi_qla_host *ha)
+qla4_8xxx_get_fdt_info(struct scsi_qla_host *ha)
 {
 #define FLASH_BLK_SIZE_4K       0x1000
 #define FLASH_BLK_SIZE_32K      0x8000
@@ -1983,7 +1983,7 @@ qla82xx_get_fdt_info(struct scsi_qla_host *ha)
 
 	wptr = (uint16_t *)ha->request_ring;
 	fdt = (struct qla_fdt_layout *)ha->request_ring;
-	qla82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
+	qla4_8xxx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
 	    hw->flt_region_fdt << 2, OPTROM_BURST_SIZE);
 
 	if (*wptr == __constant_cpu_to_le16(0xffff))
@@ -2033,7 +2033,7 @@ done:
 }
 
 static void
-qla82xx_get_idc_param(struct scsi_qla_host *ha)
+qla4_8xxx_get_idc_param(struct scsi_qla_host *ha)
 {
 #define QLA82XX_IDC_PARAM_ADDR      0x003e885c
 	uint32_t *wptr;
@@ -2041,7 +2041,7 @@ qla82xx_get_idc_param(struct scsi_qla_host *ha)
 	if (!is_qla8022(ha))
 		return;
 	wptr = (uint32_t *)ha->request_ring;
-	qla82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
+	qla4_8xxx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
 	    QLA82XX_IDC_PARAM_ADDR , 8);
 
 	if (*wptr == __constant_cpu_to_le32(0xffffffff)) {
@@ -2060,24 +2060,24 @@ qla82xx_get_idc_param(struct scsi_qla_host *ha)
 }
 
 int
-qla82xx_get_flash_info(struct scsi_qla_host *ha)
+qla4_8xxx_get_flash_info(struct scsi_qla_host *ha)
 {
 	int ret;
 	uint32_t flt_addr;
 
-	ret = qla82xx_find_flt_start(ha, &flt_addr);
+	ret = qla4_8xxx_find_flt_start(ha, &flt_addr);
 	if (ret != QLA_SUCCESS)
 		return ret;
 
-	qla82xx_get_flt_info(ha, flt_addr);
-	qla82xx_get_fdt_info(ha);
-	qla82xx_get_idc_param(ha);
+	qla4_8xxx_get_flt_info(ha, flt_addr);
+	qla4_8xxx_get_fdt_info(ha);
+	qla4_8xxx_get_idc_param(ha);
 
 	return QLA_SUCCESS;
 }
 
 /**
- * qla82xx_stop_firmware - stops firmware on specified adapter instance
+ * qla4_8xxx_stop_firmware - stops firmware on specified adapter instance
  * @ha: pointer to host adapter structure.
  *
  * Remarks:
@@ -2086,7 +2086,7 @@ qla82xx_get_flash_info(struct scsi_qla_host *ha)
  * outstanding I/O's after calling this funcion.
  **/
 int
-qla82xx_stop_firmware(struct scsi_qla_host *ha)
+qla4_8xxx_stop_firmware(struct scsi_qla_host *ha)
 {
 	int rval;
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
@@ -2105,42 +2105,42 @@ qla82xx_stop_firmware(struct scsi_qla_host *ha)
 }
 
 /**
- * qla82xx_isp_reset - Resets ISP and aborts all outstanding commands.
+ * qla4_8xxx_isp_reset - Resets ISP and aborts all outstanding commands.
  * @ha: pointer to host adapter structure.
  **/
 int
-qla82xx_isp_reset(struct scsi_qla_host *ha)
+qla4_8xxx_isp_reset(struct scsi_qla_host *ha)
 {
 	int rval;
 	uint32_t dev_state;
 
-	qla82xx_idc_lock(ha);
-	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+	qla4_8xxx_idc_lock(ha);
+	dev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
 
 	if (dev_state == QLA82XX_DEV_READY) {
 		DEBUG2(printk(KERN_INFO"HW State: NEED RESET\n"));
-		qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+		qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
 		    QLA82XX_DEV_NEED_RESET);
 	} else
 		DEBUG2(printk(KERN_INFO"HW State: DEVICE INITIALIZING\n"));
 
-	qla82xx_idc_unlock(ha);
+	qla4_8xxx_idc_unlock(ha);
 
-	rval = qla82xx_device_state_handler(ha);
+	rval = qla4_8xxx_device_state_handler(ha);
 
-	qla82xx_idc_lock(ha);
-	qla82xx_clear_rst_ready(ha);
-	qla82xx_idc_unlock(ha);
+	qla4_8xxx_idc_lock(ha);
+	qla4_8xxx_clear_rst_ready(ha);
+	qla4_8xxx_idc_unlock(ha);
 
 	return rval;
 }
 
 /**
- * qla82xx_get_sys_info - Get sys info params
+ * qla4_8xxx_get_sys_info - Get sys info params
  * @ha: pointer to host adapter structure.
  *
  **/
-int qla82xx_get_sys_info(struct scsi_qla_host *ha)
+int qla4_8xxx_get_sys_info(struct scsi_qla_host *ha)
 {
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
 	uint32_t mbox_sts[MBOX_REG_COUNT];
@@ -2204,7 +2204,7 @@ exit_sys_info_free:
 /* Interrupt handling helpers. */
 
 static int
-qla82xx_mbx_intr_enable(struct scsi_qla_host *ha)
+qla4_8xxx_mbx_intr_enable(struct scsi_qla_host *ha)
 {
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
 	uint32_t mbox_sts[MBOX_REG_COUNT];
@@ -2226,7 +2226,7 @@ qla82xx_mbx_intr_enable(struct scsi_qla_host *ha)
 }
 
 static int
-qla82xx_mbx_intr_disable(struct scsi_qla_host *ha)
+qla4_8xxx_mbx_intr_disable(struct scsi_qla_host *ha)
 {
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
 	uint32_t mbox_sts[MBOX_REG_COUNT];
@@ -2246,26 +2246,26 @@ qla82xx_mbx_intr_disable(struct scsi_qla_host *ha)
 }
 
 void
-qla82xx_enable_intrs(struct scsi_qla_host *ha)
+qla4_8xxx_enable_intrs(struct scsi_qla_host *ha)
 {
-	qla82xx_mbx_intr_enable(ha);
+	qla4_8xxx_mbx_intr_enable(ha);
 
 	spin_lock_irq(&ha->hardware_lock);
 	/* BIT 10 - reset */
-	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+	qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
 	spin_unlock_irq(&ha->hardware_lock);
 	set_bit(AF_INTERRUPTS_ON, &ha->flags);
 }
 
 void
-qla82xx_disable_intrs(struct scsi_qla_host *ha)
+qla4_8xxx_disable_intrs(struct scsi_qla_host *ha)
 {
 	if (test_bit(AF_INTERRUPTS_ON, &ha->flags))
-		qla82xx_mbx_intr_disable(ha);
+		qla4_8xxx_mbx_intr_disable(ha);
 
 	spin_lock_irq(&ha->hardware_lock);
 	/* BIT 10 - set */
-	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);
+	qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);
 	spin_unlock_irq(&ha->hardware_lock);
 	clear_bit(AF_INTERRUPTS_ON, &ha->flags);
 }
@@ -2277,26 +2277,26 @@ struct ql4_init_msix_entry {
 	irq_handler_t handler;
 };
 
-static struct ql4_init_msix_entry qla82xx_msix_entries[QLA_MSIX_ENTRIES] = {
+static struct ql4_init_msix_entry qla4_8xxx_msix_entries[QLA_MSIX_ENTRIES] = {
 	{ QLA_MSIX_DEFAULT, QLA_MIDX_DEFAULT,
-	    "qla4xxx (default)", (irq_handler_t)qla82xx_default_intr_handler },
+	    "qla4xxx (default)", (irq_handler_t)qla4_8xxx_default_intr_handler },
 
 	{ QLA_MSIX_RSP_Q, QLA_MIDX_RSP_Q,
-		"qla4xxx (rsp_q)", (irq_handler_t)qla82xx_msix_rsp_q },
+		"qla4xxx (rsp_q)", (irq_handler_t)qla4_8xxx_msix_rsp_q },
 };
 
 void
-qla82xx_disable_msix(struct scsi_qla_host *ha)
+qla4_8xxx_disable_msix(struct scsi_qla_host *ha)
 {
 	int i;
 	struct ql4_msix_entry *qentry;
 
 	for (i = 0; i < QLA_MSIX_ENTRIES; i++) {
-		qentry = &ha->msix_entries[qla82xx_msix_entries[i].index];
+		qentry = &ha->msix_entries[qla4_8xxx_msix_entries[i].index];
 		if (qentry->have_irq) {
 			free_irq(qentry->msix_vector, ha);
 			DEBUG2(printk(KERN_INFO "%s: %s\n",
-				__func__, qla82xx_msix_entries[i].name));
+				__func__, qla4_8xxx_msix_entries[i].name));
 		}
 	}
 	pci_disable_msix(ha->pdev);
@@ -2304,14 +2304,14 @@ qla82xx_disable_msix(struct scsi_qla_host *ha)
 }
 
 int
-qla82xx_enable_msix(struct scsi_qla_host *ha)
+qla4_8xxx_enable_msix(struct scsi_qla_host *ha)
 {
 	int i, ret;
 	struct msix_entry entries[QLA_MSIX_ENTRIES];
 	struct ql4_msix_entry *qentry;
 
 	for (i = 0; i < QLA_MSIX_ENTRIES; i++)
-		entries[i].entry = qla82xx_msix_entries[i].entry;
+		entries[i].entry = qla4_8xxx_msix_entries[i].entry;
 
 	ret = pci_enable_msix(ha->pdev, entries, ARRAY_SIZE(entries));
 	if (ret) {
@@ -2323,18 +2323,18 @@ qla82xx_enable_msix(struct scsi_qla_host *ha)
 	set_bit(AF_MSIX_ENABLED, &ha->flags);
 
 	for (i = 0; i < QLA_MSIX_ENTRIES; i++) {
-		qentry = &ha->msix_entries[qla82xx_msix_entries[i].index];
+		qentry = &ha->msix_entries[qla4_8xxx_msix_entries[i].index];
 		qentry->msix_vector = entries[i].vector;
 		qentry->msix_entry = entries[i].entry;
 		qentry->have_irq = 0;
 		ret = request_irq(qentry->msix_vector,
-		    qla82xx_msix_entries[i].handler, 0,
-		    qla82xx_msix_entries[i].name, ha);
+		    qla4_8xxx_msix_entries[i].handler, 0,
+		    qla4_8xxx_msix_entries[i].name, ha);
 		if (ret) {
 			printk(KERN_WARNING
 			    "MSI-X: Unable to register handler -- %x/%d.\n",
-			    qla82xx_msix_entries[i].index, ret);
-			qla82xx_disable_msix(ha);
+			    qla4_8xxx_msix_entries[i].index, ret);
+			qla4_8xxx_disable_msix(ha);
 			goto msix_out;
 		}
 		qentry->have_irq = 1;
diff --git a/drivers/scsi/qla4xxx/ql4_nx.h b/drivers/scsi/qla4xxx/ql4_nx.h
index acc086a..ec3a915 100644
--- a/drivers/scsi/qla4xxx/ql4_nx.h
+++ b/drivers/scsi/qla4xxx/ql4_nx.h
@@ -715,7 +715,7 @@ struct crb_addr_pair {
 #define	PCIX_INT_VECTOR_BIT_F6	0x2000
 #define	PCIX_INT_VECTOR_BIT_F7	0x4000
 
-/* struct qla82xx_legacy_intr_set defined in ql4_def.h */
+/* struct qla4_8xxx_legacy_intr_set defined in ql4_def.h */
 
 #define QLA82XX_LEGACY_INTR_CONFIG                                      \
 {                                                                       \
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 000b1ce..afef969 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -700,24 +700,24 @@ mem_alloc_error_exit:
 }
 
 /**
- * qla82xx_check_fw_alive - Check firmware health
+ * qla4_8xxx_check_fw_alive - Check firmware health
  * @ha: Pointer to host adapter structure.
  *
  * Context: Interrupt
  **/
 static void
-qla82xx_check_fw_alive(struct scsi_qla_host *ha)
+qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)
 {
 	uint32_t fw_heartbeat_counter, halt_status;
 
-	fw_heartbeat_counter = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+	fw_heartbeat_counter = qla4_8xxx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
 	if (ha->fw_heartbeat_counter == fw_heartbeat_counter) {
 		ha->seconds_since_last_heartbeat++;
 
 		/* FW not alive after 2 seconds */
 		if (ha->seconds_since_last_heartbeat == 2) {
 			ha->seconds_since_last_heartbeat = 0;
-			halt_status = qla82xx_rd_32(ha, QLA82XX_PEG_HALT_STATUS1);
+			halt_status = qla4_8xxx_rd_32(ha, QLA82XX_PEG_HALT_STATUS1);
 			/* Since we cannot change dev_state in interrupt
 			 * context, set appropriate DPC flag then wakeup
 			 * DPC */
@@ -734,16 +734,16 @@ qla82xx_check_fw_alive(struct scsi_qla_host *ha)
 }
 
 /**
- * qla82xx_watchdog - Poll dev state
+ * qla4_8xxx_watchdog - Poll dev state
  * @ha: Pointer to host adapter structure.
  *
  * Context: Interrupt
  **/
-void qla82xx_watchdog(struct scsi_qla_host *ha)
+void qla4_8xxx_watchdog(struct scsi_qla_host *ha)
 {
 	uint32_t dev_state;
 
-	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+	dev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
 
 	/* don't poll if reset is going on */
 	if (!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags)) {
@@ -758,7 +758,7 @@ void qla82xx_watchdog(struct scsi_qla_host *ha)
 			qla4xxx_wake_dpc(ha);
 		} else {
 			/* Check firmware health */
-			qla82xx_check_fw_alive(ha);
+			qla4_8xxx_check_fw_alive(ha);
 		}
 	}
 }
@@ -778,7 +778,7 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 	}
 
 	if (is_qla8022(ha)) {
-		qla82xx_watchdog(ha);
+		qla4_8xxx_watchdog(ha);
 	}
 
 	/* Search for relogin's to time-out and port down retry. */
@@ -1404,15 +1404,15 @@ static void qla4xxx_do_dpc(void *data)
 
 	if (is_qla8022(ha)) {
 		if (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {
-			qla82xx_idc_lock(ha);
-			qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+			qla4_8xxx_idc_lock(ha);
+			qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
 				QLA82XX_DEV_FAILED);
-			qla82xx_idc_unlock(ha);
+			qla4_8xxx_idc_unlock(ha);
 			DEBUG2(printk(KERN_INFO"HW State: FAILED\n"));
-			qla82xx_device_state_handler(ha);
+			qla4_8xxx_device_state_handler(ha);
 		}
 		if (test_and_clear_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {
-			qla82xx_need_qsnt_handler(ha);
+			qla4_8xxx_need_qsnt_handler(ha);
 		}
 	}
 
@@ -1580,9 +1580,9 @@ static void qla4xxx_free_adapter(struct scsi_qla_host *ha)
 	/* Put firmware in a known state */
 	ha->isp_ops->reset_firmware(ha);
 	if (is_qla8022(ha)) {
-		qla82xx_idc_lock(ha);
-		qla82xx_clear_drv_active(ha);
-		qla82xx_idc_unlock(ha);
+		qla4_8xxx_idc_lock(ha);
+		qla4_8xxx_clear_drv_active(ha);
+		qla4_8xxx_idc_unlock(ha);
 	}
 
 	/* Detach interrupts */
@@ -1595,7 +1595,7 @@ static void qla4xxx_free_adapter(struct scsi_qla_host *ha)
 	pci_disable_device(ha->pdev);
 }
 
-int qla82xx_iospace_config(struct scsi_qla_host *ha)
+int qla4_8xxx_iospace_config(struct scsi_qla_host *ha)
 {
 	int status = 0;
 	uint8_t revision_id;
@@ -1633,7 +1633,7 @@ int qla82xx_iospace_config(struct scsi_qla_host *ha)
 	/* Mapping of IO base pointer, door bell read and write pointer */
 
 	/* mapping of IO base pointer */
-	ha->qla82xx_reg = (struct device_reg_82xx  __iomem *)((uint8_t *)ha->nx_pcibase +
+	ha->qla4_8xxx_reg = (struct device_reg_82xx  __iomem *)((uint8_t *)ha->nx_pcibase +
 			0xbc000 + (ha->pdev->devfn << 11));
 
 	db_base = pci_resource_start(pdev, 4);  /* doorbell is on bar 4 */
@@ -1744,21 +1744,21 @@ struct isp_operations qla4xxx_isp_ops = {
 	.rd_shdw_rsp_q_in	= qla4xxx_rd_shdw_rsp_q_in,
 	.get_sys_info		= qla4xxx_get_sys_info,
 };
-struct isp_operations qla82xx_isp_ops = {
-	.iospace_config		= qla82xx_iospace_config,
-	.pci_config		= qla82xx_pci_config,
-	.disable_intrs		= qla82xx_disable_intrs,
-	.enable_intrs		= qla82xx_enable_intrs,
-	.start_firmware		= qla82xx_load_risc,
-	.intr_handler		= qla82xx_intr_handler,
-	.interrupt_service_routine = qla82xx_interrupt_service_routine,
-	.reset_chip			= qla82xx_isp_reset,
-	.reset_firmware		= qla82xx_stop_firmware,
-	.queue_iocb		= qla82xx_queue_iocb,
-	.complete_iocb		= qla82xx_complete_iocb,
-	.rd_shdw_req_q_out	= qla82xx_rd_shdw_req_q_out,
-	.rd_shdw_rsp_q_in	= qla82xx_rd_shdw_rsp_q_in,
-	.get_sys_info		= qla82xx_get_sys_info,
+struct isp_operations qla4_8xxx_isp_ops = {
+	.iospace_config		= qla4_8xxx_iospace_config,
+	.pci_config		= qla4_8xxx_pci_config,
+	.disable_intrs		= qla4_8xxx_disable_intrs,
+	.enable_intrs		= qla4_8xxx_enable_intrs,
+	.start_firmware		= qla4_8xxx_load_risc,
+	.intr_handler		= qla4_8xxx_intr_handler,
+	.interrupt_service_routine = qla4_8xxx_interrupt_service_routine,
+	.reset_chip			= qla4_8xxx_isp_reset,
+	.reset_firmware		= qla4_8xxx_stop_firmware,
+	.queue_iocb		= qla4_8xxx_queue_iocb,
+	.complete_iocb		= qla4_8xxx_complete_iocb,
+	.rd_shdw_req_q_out	= qla4_8xxx_rd_shdw_req_q_out,
+	.rd_shdw_rsp_q_in	= qla4_8xxx_rd_shdw_rsp_q_in,
+	.get_sys_info		= qla4_8xxx_get_sys_info,
 };
 
 uint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)
@@ -1766,9 +1766,9 @@ uint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)
 	return (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
 }
 
-uint16_t qla82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha)
+uint16_t qla4_8xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)
 {
-	return (uint16_t) le32_to_cpu(readl(&ha->qla82xx_reg->req_q_out));
+	return (uint16_t) le32_to_cpu(readl(&ha->qla4_8xxx_reg->req_q_out));
 }
 
 uint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)
@@ -1776,9 +1776,9 @@ uint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)
 	return (uint16_t) le32_to_cpu(ha->shadow_regs->rsp_q_in);
 }
 
-uint16_t qla82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)
+uint16_t qla4_8xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)
 {
-	return (uint16_t) le32_to_cpu(readl(&ha->qla82xx_reg->rsp_q_in));
+	return (uint16_t) le32_to_cpu(readl(&ha->qla4_8xxx_reg->rsp_q_in));
 }
 
 static void ql4_get_aen_log(struct scsi_qla_host *ha, struct ql4_aen_log *aenl)
@@ -1829,14 +1829,14 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 
 	/* Setup Runtime configurable options */
 	if (is_qla8022(ha))
-		ha->isp_ops = &qla82xx_isp_ops;
+		ha->isp_ops = &qla4_8xxx_isp_ops;
 	else
 		ha->isp_ops = &qla4xxx_isp_ops;
 
 
 	/* ISP 8022 initializations */
 	if (is_qla8022(ha)) {
-		qla82xx_init_local_data(ha);
+		qla4_8xxx_init_local_data(ha);
 	}
 
 	ha->ql4mbx = qla4xxx_mailbox_command;
@@ -1886,7 +1886,7 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	}
 
 	if (is_qla8022(ha))
-		(void) qla82xx_get_flash_info(ha);
+		(void) qla4_8xxx_get_flash_info(ha);
 
 	/*
 	 * Initialize the Host adapter request/response queues and firmware
