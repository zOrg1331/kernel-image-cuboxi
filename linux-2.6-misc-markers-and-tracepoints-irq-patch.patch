From: jbaron@redhat.com <jbaron@redhat.com>
Date: Fri, 22 Aug 2008 14:04:53 -0400
Subject: [misc] markers and tracepoints: irq patch
Message-id: 1219428298-7519-10-git-send-email-jbaron@redhat.com
O-Subject: [rhel5.3 patch 09/14] markers and tracepoints - hitachi irq patch
Bugzilla: 329821

bz# 329821

diff --git a/include/trace/irq.h b/include/trace/irq.h
new file mode 100644
index 0000000..a457a52
--- /dev/null
+++ b/include/trace/irq.h
@@ -0,0 +1,32 @@
+#ifndef _TRACE_IRQ_H
+#define _TRACE_IRQ_H
+
+#include <linux/tracepoint.h>
+#include <linux/interrupt.h>
+
+DEFINE_TRACE(irq_entry,
+	TPPROTO(unsigned int id, struct pt_regs *regs),
+	TPARGS(id, regs));
+DEFINE_TRACE(irq_exit,
+	TPPROTO(unsigned int id, irqreturn_t retval),
+	TPARGS(id, retval));
+DEFINE_TRACE(irq_softirq_entry,
+	TPPROTO(struct softirq_action *h, struct softirq_action *softirq_vec),
+	TPARGS(h, softirq_vec));
+DEFINE_TRACE(irq_softirq_exit,
+	TPPROTO(struct softirq_action *h, struct softirq_action *softirq_vec),
+	TPARGS(h, softirq_vec));
+DEFINE_TRACE(irq_tasklet_low_entry,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+DEFINE_TRACE(irq_tasklet_low_exit,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+DEFINE_TRACE(irq_tasklet_high_entry,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+DEFINE_TRACE(irq_tasklet_high_exit,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+
+#endif
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index 3fc2833..af3c3bf 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -15,6 +15,7 @@
 #include <linux/random.h>
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
+#include <trace/irq.h>
 
 #include "internals.h"
 
@@ -134,6 +135,8 @@ irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 	irqreturn_t ret, retval = IRQ_NONE;
 	unsigned int status = 0;
 
+	trace_irq_entry(irq, regs);
+
 	handle_dynamic_tick(action);
 
 	if (!(action->flags & IRQF_DISABLED))
@@ -151,6 +154,8 @@ irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 		add_interrupt_randomness(irq);
 	local_irq_disable();
 
+	trace_irq_exit(irq, retval);
+
 	return retval;
 }
 
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 865589c..8e342e1 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -17,6 +17,7 @@
 #include <linux/kthread.h>
 #include <linux/rcupdate.h>
 #include <linux/smp.h>
+#include <trace/irq.h>
 
 #include <asm/irq.h>
 /*
@@ -227,7 +228,9 @@ restart:
 
 	do {
 		if (pending & 1) {
+			trace_irq_softirq_entry(h, softirq_vec);
 			h->action(h);
+			trace_irq_softirq_exit(h, softirq_vec);
 			rcu_bh_qsctr_inc(cpu);
 		}
 		h++;
@@ -384,7 +387,9 @@ static void tasklet_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+				trace_irq_tasklet_low_entry(t);
 				t->func(t->data);
+				trace_irq_tasklet_low_exit(t);
 				tasklet_unlock(t);
 				continue;
 			}
@@ -417,7 +422,9 @@ static void tasklet_hi_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+				trace_irq_tasklet_high_entry(t);
 				t->func(t->data);
+				trace_irq_tasklet_high_exit(t);
 				tasklet_unlock(t);
 				continue;
 			}
