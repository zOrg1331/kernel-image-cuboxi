From: Josef Bacik <jbacik@redhat.com>
Date: Tue, 10 Feb 2009 13:49:25 -0500
Subject: [gfs2] remove static iov iter stuff
Message-id: 1234291777-15344-13-git-send-email-jbacik@redhat.com
O-Subject: [PATCH 12/24] [RHEL 5.4] gfs2: remove static iov iter stuff
Bugzilla: 445433
RH-Acked-by: Bob Peterson <rpeterso@redhat.com>
RH-Acked-by: Steven Whitehouse <swhiteho@redhat.com>
RH-Acked-by: Jeff Layton <jlayton@redhat.com>

Gfs2 had put all of the iov iter static within its own code.  This patch removes
that code since we've put the generic code in.  This patch is in reference to bz
445433.

Signed-off-by: Josef Bacik <jbacik@redhat.com>

diff --git a/fs/gfs2/ops_file.c b/fs/gfs2/ops_file.c
index 9d057ef..c9ed19b 100644
--- a/fs/gfs2/ops_file.c
+++ b/fs/gfs2/ops_file.c
@@ -46,24 +46,6 @@
 #include "eaops.h"
 #include "ops_address.h"
 
-static void iov_iter_advance(struct iov_iter *i, size_t bytes);
-static inline void iov_iter_init(struct iov_iter *i,
-                        const struct iovec *iov, unsigned long nr_segs,
-                        size_t count, size_t written)
-{
-        i->iov = iov;
-        i->nr_segs = nr_segs;
-        i->iov_offset = 0;
-        i->count = count + written;
-
-        iov_iter_advance(i, written);
-}
-
-static inline size_t iov_iter_count(struct iov_iter *i)
-{
-        return i->count;
-}
-
 /*
  * Most fields left uninitialised to catch anybody who tries to
  * use them. f_flags set to prevent file_accessed() from touching
@@ -671,53 +653,6 @@ static int gfs2_flock(struct file *file, int cmd, struct file_lock *fl)
 		return do_flock(file, cmd, fl);
 }
 
-/**
- * generic_file functions backported from upstream filemap.c:
- * In many cases I needed to change generic_* to gfs2_*
- */
-
-static unsigned long iov_iter_single_seg_count(struct iov_iter *i)
-{
-	const struct iovec *iov = i->iov;
-	if (i->nr_segs == 1)
-		return i->count;
-	else
-		return min(i->count, iov->iov_len - i->iov_offset);
-}
-
-static void iov_iter_advance(struct iov_iter *i, size_t bytes)
-{
-	BUG_ON(i->count < bytes);
-
-	if (likely(i->nr_segs == 1)) {
-		i->iov_offset += bytes;
-		i->count -= bytes;
-	} else {
-		const struct iovec *iov = i->iov;
-		size_t base = i->iov_offset;
-
-		/*
-		 * The !iov->iov_len check ensures we skip over unlikely
-		 * zero-length segments (without overruning the iovec).
-		 */
-		while (bytes || unlikely(i->count && !iov->iov_len)) {
-			int copy;
-
-			copy = min(bytes, iov->iov_len - base);
-			BUG_ON(!i->count || i->count < copy);
-			i->count -= copy;
-			bytes -= copy;
-			base += copy;
-			if (iov->iov_len == base) {
-				iov++;
-				base = 0;
-			}
-		}
-		i->iov = iov;
-		i->iov_offset = base;
-	}
-}
-
 static inline int gfs2_fault_in_pages_readable(const char __user *uaddr,
 					       int size)
 {
@@ -737,12 +672,6 @@ static inline int gfs2_fault_in_pages_readable(const char __user *uaddr,
         }
         return ret;
 }
-static int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes)
-{
-	char __user *buf = i->iov->iov_base + i->iov_offset;
-	bytes = min(bytes, i->iov->iov_len - i->iov_offset);
-	return gfs2_fault_in_pages_readable(buf, bytes);
-}
 
 static ssize_t gfs2_perform_write(struct file *file,
 				  struct iov_iter *i, loff_t pos)
@@ -783,7 +712,7 @@ again:
 		 * to check that the address is actually valid, when atomic
 		 * usercopies are used, below.
 		 */
-		if (unlikely(iov_iter_fault_in_readable(i, bytes))) {
+		if (unlikely(iov_iter_fault_in_readable(i))) {
 			status = -EFAULT;
 			break;
 		}
