From: Prarit Bhargava <prarit@redhat.com>
Date: Wed, 2 Jun 2010 20:09:15 -0400
Subject: [x86_64] unify apic mapping code
Message-id: <20100602200406.3134.81119.sendpatchset@prarit.bos.redhat.com>
Patchwork-id: 25939
O-Subject: [RHEL5 PATCH]: x86_64: unify apic mapping code
Bugzilla: 573858
RH-Acked-by: Bob Picco <bpicco@redhat.com>

RHEL5 currently determines the apic mapping at two different times in the boot.
The first is early on when the apic mapping is determined, and the second is
when the kernel determines if the tsc is stable.

The problem is that these two methods are different from one another and at
times they can result in two different conclusions.  This patch attempts to
unify the two paths into a single call, apic_is_clustered_box() so we have
consistency between the two call paths.

I have pushed a patch upstream which checks the ACPI FADT values for the
apic mappings: http://marc.info/?l=linux-kernel&m=127550701007427&w=2

That patch does not apply to RHEL5 because the code is very different,
so I am not introducing apic_is_acpi_clustered_box() in RHEL5.  I have put the
ACPI checking code into apic_is_clustered_box() and modified the
genapic code to call apic_is_clustered_box().

The difference in the AMD code path is that now a ScaleMP(vsmp) AMD system
will be properly marked as a clustered box.

[I also fixed a compile warning on the multi_dmi_table declaration.]

Successfully tested by me on a few Intel and AMD boxes.

Resolves BZ 573858.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/arch/x86_64/kernel/apic.c b/arch/x86_64/kernel/apic.c
index 3a22107..7f08ec4 100644
--- a/arch/x86_64/kernel/apic.c
+++ b/arch/x86_64/kernel/apic.c
@@ -27,6 +27,8 @@
 #include <linux/sysdev.h>
 #include <linux/module.h>
 
+#include <acpi/acpi_bus.h> /* for acpi_fadt */
+
 #include <asm/atomic.h>
 #include <asm/smp.h>
 #include <asm/mtrr.h>
@@ -1082,7 +1084,7 @@ static int __cpuinit set_multi(struct dmi_system_id *d)
 	return 0;
 }
 
-static const struct dmi_system_id multi_dmi_table[] = {
+static struct dmi_system_id multi_dmi_table[] = {
 	{
 		.callback = set_multi,
 		.ident = "IBM System Summit2",
@@ -1109,10 +1111,46 @@ static void __cpuinit dmi_check_multi(void)
  * Thus far, the major user of this is IBM's Summit2 series:
  * Clustered boxes may have unsynced TSC problems if they are
  * multi-chassis.
- * Use DMI to check them
+ *
+ * Use ACPI & DMI to check the apic mapping.
  */
-__cpuinit int apic_is_clustered_box(void)
+int apic_is_clustered_box(void)
 {
+#ifdef CONFIG_ACPI
+	/*
+	 * Some x86_64 machines use physical or clustered APIC mode regardless
+	 * of how many procs/clusters are present.
+	 */
+	if (acpi_fadt.revision >= FADT2_REVISION_ID) {
+		/*
+		 * Default to physical flat if both clustered and physical
+		 * flat are set.
+		 */
+		if ((acpi_fadt.force_apic_cluster_model) &&
+		    (acpi_fadt.force_apic_physical_destination_mode)) {
+			printk(KERN_WARNING "Firmware Bug: ACPI has set apic "
+			       " mode to both clustered and physical flat."
+			       "  Please contact your firmware vendor for an"
+			       " update.");
+			/*
+			 * In this case assume physical flat as only a
+			 * very limited number of systems use cluster
+			 */
+			printk(KERN_DEBUG "system APIC: using physical flat\n");
+			return 0;
+		}
+		if (acpi_fadt.force_apic_cluster_model) {
+			printk(KERN_DEBUG "system APIC: can only use cluster\n");
+			return 1;
+		}
+		if (acpi_fadt.force_apic_physical_destination_mode) {
+			printk(KERN_DEBUG "system APIC: can only use "
+			       "physical\n");
+			return 0;
+		}
+	}
+#endif
+
 	dmi_check_multi();
 	if (multi)
 		return 1;
diff --git a/arch/x86_64/kernel/genapic.c b/arch/x86_64/kernel/genapic.c
index 8e78a75..5df61c1 100644
--- a/arch/x86_64/kernel/genapic.c
+++ b/arch/x86_64/kernel/genapic.c
@@ -40,38 +40,14 @@ struct genapic *genapic = &apic_flat;
  */
 void __init clustered_apic_check(void)
 {
-	long i;
-	u8 clusters, max_cluster;
-	u8 id;
-	u8 cluster_cnt[NUM_APIC_CLUSTERS];
-	int max_apic = 0;
+	int i, max_apic = 0;
 
-#if defined(CONFIG_ACPI)
-	/*
-	 * Some x86_64 machines use physical APIC mode regardless of how many
-	 * procs/clusters are present (x86_64 ES7000 is an example).
-	 */
-	if (acpi_fadt.revision > FADT2_REVISION_ID)
-		if (acpi_fadt.force_apic_physical_destination_mode) {
-			genapic = &apic_cluster;
-			goto print;
-		}
-#endif
-
-	memset(cluster_cnt, 0, sizeof(cluster_cnt));
-	for (i = 0; i < NR_CPUS; i++) {
-		id = bios_cpu_apicid[i];
-		if (id == BAD_APICID)
-			continue;
-		if (id > max_apic)
-			max_apic = id;
-		cluster_cnt[APIC_CLUSTERID(id)]++;
-	}
-
-	/* Don't use clustered mode on AMD platforms. */
- 	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+	if (apic_is_clustered_box()) {
+		genapic = &apic_cluster;
+	} else {
+#ifdef CONFIG_HOTPLUG_CPU
+		/* Don't use APIC shortcuts in CPU hotplug to avoid races */
 		genapic = &apic_physflat;
-#ifndef CONFIG_HOTPLUG_CPU
 		/* In the CPU hotplug case we cannot use broadcast mode
 		   because that opens a race when a CPU is removed.
 		   Stay at physflat mode in this case.
@@ -79,41 +55,22 @@ void __init clustered_apic_check(void)
 		   we have ACPI platform support for CPU hotplug
 		   we should detect hotplug capablity from ACPI tables and
 		   only do this when really needed. -AK */
-		if (max_apic <= 8)
-			genapic = &apic_flat;
-#endif
- 		goto print;
- 	}
-
-	clusters = 0;
-	max_cluster = 0;
-
-	for (i = 0; i < NUM_APIC_CLUSTERS; i++) {
-		if (cluster_cnt[i] > 0) {
-			++clusters;
-			if (cluster_cnt[i] > max_cluster)
-				max_cluster = cluster_cnt[i];
+		if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+			for (i = 0; i < NR_CPUS; i++) {
+				if (bios_cpu_apicid[i] == BAD_APICID)
+					continue;
+				if (bios_cpu_apicid[i] > max_apic)
+					max_apic = bios_cpu_apicid[i];
+			}
+
+			if (max_apic <= 8)
+				genapic = &apic_flat;
 		}
-	}
-
-	/*
-	 * If we have clusters <= 1 and CPUs <= 8 in cluster 0, then flat mode,
-	 * else if max_cluster <= 4 and cluster_cnt[15] == 0, clustered logical
-	 * else physical mode.
-	 * (We don't use lowest priority delivery + HW APIC IRQ steering, so
-	 * can ignore the clustered logical case and go straight to physical.)
-	 */
-	if (clusters <= 1 && max_cluster <= 8 && cluster_cnt[0] == max_cluster) {
-#ifdef CONFIG_HOTPLUG_CPU
-		/* Don't use APIC shortcuts in CPU hotplug to avoid races */
-		genapic = &apic_physflat;
 #else
 		genapic = &apic_flat;
 #endif
-	} else
-		genapic = &apic_cluster;
+	}
 
-print:
 	printk(KERN_INFO "Setting APIC routing to %s\n", genapic->name);
 }
 
