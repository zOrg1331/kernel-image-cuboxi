From: Matthew Garrett <mjg@redhat.com>
Date: Fri, 5 Sep 2008 10:22:29 +0100
Subject: [x86_64] suspend to disk fails with >4GB of RAM
Message-id: 20080905092229.GA27410@srcf.ucam.org
O-Subject: [RHEL5.3 patch] BZ#459980 - Suspend to disk fails with >4GB of RAM
Bugzilla: 459980
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>
RH-Acked-by: Peter Martuccelli <peterm@redhat.com>
RH-Acked-by: Brian Maly <bmaly@redhat.com>

On x86_64 systems, suspend to disk currently saves the aperture memory.
This causes problems when it's written back on resume. Simply flagging
the aperture as unsavable prevents this. Confirmed to work by AMD
contact.

diff --git a/arch/x86_64/kernel/aperture.c b/arch/x86_64/kernel/aperture.c
index d99c749..2e171b1 100644
--- a/arch/x86_64/kernel/aperture.c
+++ b/arch/x86_64/kernel/aperture.c
@@ -63,6 +63,8 @@ static u32 __init allocate_aperture(void)
 	}
 	printk("Mapping aperture over %d KB of RAM @ %lx\n",
 	       aper_size >> 10, __pa(p)); 
+	e820_mark_nosave_range((u32)__pa(p), (u32)__pa(p+aper_size));
+
 	return (u32)__pa(p); 
 }
 
diff --git a/arch/x86_64/kernel/e820.c b/arch/x86_64/kernel/e820.c
index 55a9a53..f98cc6d 100644
--- a/arch/x86_64/kernel/e820.c
+++ b/arch/x86_64/kernel/e820.c
@@ -302,7 +302,7 @@ void __init e820_reserve_resources(void)
 }
 
 /* Mark pages corresponding to given address range as nosave */
-static void __init
+void __init
 e820_mark_nosave_range(unsigned long start, unsigned long end)
 {
 	unsigned long pfn, max_pfn;
diff --git a/include/asm-x86_64/e820.h b/include/asm-x86_64/e820.h
index 25b8d2e..43a595c 100644
--- a/include/asm-x86_64/e820.h
+++ b/include/asm-x86_64/e820.h
@@ -57,6 +57,8 @@ extern void e820_setup_gap(void);
 extern unsigned long e820_hole_size(unsigned long start_pfn,
 				    unsigned long end_pfn);
 
+extern void __init e820_mark_nosave_range(unsigned long start, 
+					  unsigned long end);
 extern void __init parse_memopt(char *p, char **end);
 extern void __init parse_memmapopt(char *p, char **end);
 
