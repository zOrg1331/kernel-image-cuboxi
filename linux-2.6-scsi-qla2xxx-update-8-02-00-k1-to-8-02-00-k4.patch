From: Marcus Barrow <mbarrow@redhat.com>
Date: Thu, 7 Aug 2008 13:30:13 -0400
Subject: [scsi] qla2xxx: update 8.02.00-k1 to 8.02.00.k4
Message-id: 20080807173013.11306.47190.sendpatchset@file.bos.redhat.com
O-Subject: [rhel 5.3 patch] [V2] qla2xxx - upstream changes from 8.02.00-k1 to 8.02.00.k4
Bugzilla: 455264
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>

BZ 455264 [QLogic 5.3 feat] [2/n] [V2] qla2xxx- Upstream updates: 8.02.00-k1 to 8.02.00-k4

This is the second version of this patch and removes usage of
scsi_dma_map(), which is not in 2-6-18...

This set of patches ports upstream fixes from 8.02.00-k1 to
8.02.00-k4  driver versions.

Tested at QLogic and applies and builds cleanly with 2.6.18-101.el5

Missing fixes from 8.02.00-k1 to 8.02.00-k4.

commit 26ff776d1dd9147eb658c55f1df42c2c232036b5
[SCSI] qla2xxx: Sparse cleanups in qla_mid.c

commit 8fef696b00b863c8c898293bd09be581b934849b
[SCSI] qla2xxx: Don't modify parity bits during ISP25XX restart.
                modified to make change for ISP84xx instead.

commit 4b39c1d98327b0a572392cdb0ee22db1de0e7cb9
[SCSI] qla2xxx: Data accessors Cleanup of last merge

commit 385d70b4e2659ae525a00e46a9f97146949cfc14
[SCSI] qla2xxx: convert to use the data buffer accessors

commit 476834c25a04025d895f64d42affcd31bfb318cc
[SCSI] aacraid,qla2xxx: use irq_handler_t where appropriate

diff --git a/drivers/scsi/qla2xxx/qla_dbg.c b/drivers/scsi/qla2xxx/qla_dbg.c
index 2f02f6c..ca7f70d 100644
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@ -1414,9 +1414,9 @@ qla2x00_print_scsi_cmd(struct scsi_cmnd * cmd)
 		printk("0x%02x ", cmd->cmnd[i]);
 	}
 	printk("\n  seg_cnt=%d, allowed=%d, retries=%d\n",
-	    cmd->use_sg, cmd->allowed, cmd->retries);
+	       scsi_sg_count(cmd), cmd->allowed, cmd->retries);
 	printk("  request buffer=0x%p, request buffer len=0x%x\n",
-	    cmd->request_buffer, cmd->request_bufflen);
+	       scsi_sglist(cmd), scsi_bufflen(cmd));
 	printk("  tag=%d, transfersize=0x%x\n",
 	    cmd->tag, cmd->transfersize);
 	printk("  serial_number=%lx, SP=%p\n", cmd->serial_number, sp);
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 1076d29..fb3a183 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -3291,8 +3291,7 @@ qla2x00_restart_isp(scsi_qla_host_t *ha)
 
 			spin_lock_irqsave(&ha->hardware_lock, flags);
 
-			if (!IS_QLA24XX(ha) && !IS_QLA54XX(ha) &&
-			    !IS_QLA25XX(ha)) {
+			if (!IS_FWI2_CAPABLE(ha)) {
 				/*
 				 * Disable SRAM, Instruction RAM and GP RAM
 				 * parity.
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index 207ff0f..84e10ed 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -163,7 +163,7 @@ void qla2x00_build_scsi_iocbs_32(srb_t *sp, cmd_entry_t *cmd_pkt,
 	    __constant_cpu_to_le32(COMMAND_TYPE);
 
 	/* No data transfer */
-	if (cmd->request_bufflen == 0 || cmd->sc_data_direction == DMA_NONE) {
+	if (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {
 		cmd_pkt->byte_count = __constant_cpu_to_le32(0);
 		return;
 	}
@@ -177,11 +177,11 @@ void qla2x00_build_scsi_iocbs_32(srb_t *sp, cmd_entry_t *cmd_pkt,
 	cur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;
 
 	/* Load data segments */
-	if (cmd->use_sg != 0) {
+	if (scsi_sg_count(cmd) != 0) {
 		struct	scatterlist *cur_seg;
 		struct	scatterlist *end_seg;
 
-		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		cur_seg = scsi_sglist(cmd);
 		end_seg = cur_seg + tot_dsds;
 		while (cur_seg < end_seg) {
 			cont_entry_t	*cont_pkt;
@@ -205,7 +205,7 @@ void qla2x00_build_scsi_iocbs_32(srb_t *sp, cmd_entry_t *cmd_pkt,
 		}
 	} else {
 		*cur_dsd++ = cpu_to_le32(sp->dma_handle);
-		*cur_dsd++ = cpu_to_le32(cmd->request_bufflen);
+		*cur_dsd++ = cpu_to_le32(scsi_bufflen(cmd));
 	}
 }
 
@@ -232,7 +232,7 @@ void qla2x00_build_scsi_iocbs_64(srb_t *sp, cmd_entry_t *cmd_pkt,
 	    __constant_cpu_to_le32(COMMAND_A64_TYPE);
 
 	/* No data transfer */
-	if (cmd->request_bufflen == 0 || cmd->sc_data_direction == DMA_NONE) {
+	if (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {
 		cmd_pkt->byte_count = __constant_cpu_to_le32(0);
 		return;
 	}
@@ -246,11 +246,11 @@ void qla2x00_build_scsi_iocbs_64(srb_t *sp, cmd_entry_t *cmd_pkt,
 	cur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;
 
 	/* Load data segments */
-	if (cmd->use_sg != 0) {
+	if (scsi_sg_count(cmd) != 0) {
 		struct	scatterlist *cur_seg;
 		struct	scatterlist *end_seg;
 
-		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		cur_seg = scsi_sglist(cmd);
 		end_seg = cur_seg + tot_dsds;
 		while (cur_seg < end_seg) {
 			dma_addr_t	sle_dma;
@@ -278,7 +278,7 @@ void qla2x00_build_scsi_iocbs_64(srb_t *sp, cmd_entry_t *cmd_pkt,
 	} else {
 		*cur_dsd++ = cpu_to_le32(LSD(sp->dma_handle));
 		*cur_dsd++ = cpu_to_le32(MSD(sp->dma_handle));
-		*cur_dsd++ = cpu_to_le32(cmd->request_bufflen);
+		*cur_dsd++ = cpu_to_le32(scsi_bufflen(cmd));
 	}
 }
 
@@ -337,17 +337,17 @@ qla2x00_start_scsi(srb_t *sp)
 		goto queuing_error;
 
 	/* Map the sg table so we have an accurate count of sg entries needed */
-	if (cmd->use_sg) {
-		sg = (struct scatterlist *) cmd->request_buffer;
-		tot_dsds = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+	if (scsi_sg_count(cmd)) {
+		sg = scsi_sglist(cmd);
+		tot_dsds = pci_map_sg(ha->pdev, sg, scsi_sg_count(cmd),
 		    cmd->sc_data_direction);
 		if (tot_dsds == 0)
 			goto queuing_error;
-	} else if (cmd->request_bufflen) {
+	} else if (scsi_bufflen(cmd)) {
 		dma_addr_t	req_dma;
 
-		req_dma = pci_map_single(ha->pdev, cmd->request_buffer,
-		    cmd->request_bufflen, cmd->sc_data_direction);
+		req_dma = pci_map_single(ha->pdev, scsi_sglist(cmd),
+		    scsi_bufflen(cmd), cmd->sc_data_direction);
 		if (dma_mapping_error(req_dma))
 			goto queuing_error;
 
@@ -391,7 +391,7 @@ qla2x00_start_scsi(srb_t *sp)
 
 	/* Load SCSI command packet. */
 	memcpy(cmd_pkt->scsi_cdb, cmd->cmnd, cmd->cmd_len);
-	cmd_pkt->byte_count = cpu_to_le32((uint32_t)cmd->request_bufflen);
+	cmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));
 
 	/* Build IOCB segments */
 	ha->isp_ops->build_iocbs(sp, cmd_pkt, tot_dsds);
@@ -423,13 +423,13 @@ qla2x00_start_scsi(srb_t *sp)
 	return (QLA_SUCCESS);
 
 queuing_error:
-	if (cmd->use_sg && tot_dsds) {
-		sg = (struct scatterlist *) cmd->request_buffer;
-		pci_unmap_sg(ha->pdev, sg, cmd->use_sg,
+	if (scsi_sg_count(cmd) && tot_dsds) {
+		sg = scsi_sglist(cmd);
+		pci_unmap_sg(ha->pdev, sg, scsi_sg_count(cmd),
 		    cmd->sc_data_direction);
 	} else if (tot_dsds) {
 		pci_unmap_single(ha->pdev, sp->dma_handle,
-		    cmd->request_bufflen, cmd->sc_data_direction);
+		    scsi_bufflen(cmd), cmd->sc_data_direction);
 	}
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
@@ -652,7 +652,7 @@ qla24xx_build_scsi_iocbs(srb_t *sp, struct cmd_type_7 *cmd_pkt,
 	    __constant_cpu_to_le32(COMMAND_TYPE_7);
 
 	/* No data transfer */
-	if (cmd->request_bufflen == 0 || cmd->sc_data_direction == DMA_NONE) {
+	if (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {
 		cmd_pkt->byte_count = __constant_cpu_to_le32(0);
 		return;
 	}
@@ -672,11 +672,11 @@ qla24xx_build_scsi_iocbs(srb_t *sp, struct cmd_type_7 *cmd_pkt,
 	cur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;
 
 	/* Load data segments */
-	if (cmd->use_sg != 0) {
+	if (scsi_sg_count(cmd) != 0) {
 		struct	scatterlist *cur_seg;
 		struct	scatterlist *end_seg;
 
-		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		cur_seg = scsi_sglist(cmd);
 		end_seg = cur_seg + tot_dsds;
 		while (cur_seg < end_seg) {
 			dma_addr_t	sle_dma;
@@ -704,7 +704,7 @@ qla24xx_build_scsi_iocbs(srb_t *sp, struct cmd_type_7 *cmd_pkt,
 	} else {
 		*cur_dsd++ = cpu_to_le32(LSD(sp->dma_handle));
 		*cur_dsd++ = cpu_to_le32(MSD(sp->dma_handle));
-		*cur_dsd++ = cpu_to_le32(cmd->request_bufflen);
+		*cur_dsd++ = cpu_to_le32(scsi_bufflen(cmd));
 	}
 }
 
@@ -764,17 +764,17 @@ qla24xx_start_scsi(srb_t *sp)
 		goto queuing_error;
 
 	/* Map the sg table so we have an accurate count of sg entries needed */
-	if (cmd->use_sg) {
-		sg = (struct scatterlist *) cmd->request_buffer;
-		tot_dsds = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+	if (scsi_sg_count(cmd)) {
+		sg = scsi_sglist(cmd);
+		tot_dsds = pci_map_sg(ha->pdev, sg, scsi_sg_count(cmd),
 		    cmd->sc_data_direction);
 		if (tot_dsds == 0)
 			goto queuing_error;
-	} else if (cmd->request_bufflen) {
+	} else if (scsi_bufflen(cmd)) {
 		dma_addr_t      req_dma;
 
 		req_dma = pci_map_single(ha->pdev, cmd->request_buffer,
-		    cmd->request_bufflen, cmd->sc_data_direction);
+		    scsi_bufflen(cmd), cmd->sc_data_direction);
 		if (dma_mapping_error(req_dma))
 			goto queuing_error;
 
@@ -824,7 +824,7 @@ qla24xx_start_scsi(srb_t *sp)
 	memcpy(cmd_pkt->fcp_cdb, cmd->cmnd, cmd->cmd_len);
 	host_to_fcp_swap(cmd_pkt->fcp_cdb, sizeof(cmd_pkt->fcp_cdb));
 
-	cmd_pkt->byte_count = cpu_to_le32((uint32_t)cmd->request_bufflen);
+	cmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));
 
 	/* Build IOCB segments */
 	qla24xx_build_scsi_iocbs(sp, cmd_pkt, tot_dsds);
@@ -856,13 +856,13 @@ qla24xx_start_scsi(srb_t *sp)
 	return QLA_SUCCESS;
 
 queuing_error:
-	if (cmd->use_sg && tot_dsds) {
-		sg = (struct scatterlist *) cmd->request_buffer;
-		pci_unmap_sg(ha->pdev, sg, cmd->use_sg,
+	if (scsi_sg_count(cmd) && tot_dsds) {
+		sg = scsi_sglist(cmd);
+		pci_unmap_sg(ha->pdev, sg, scsi_sg_count(cmd),
 		    cmd->sc_data_direction);
 	} else if (tot_dsds) {
 		pci_unmap_single(ha->pdev, sp->dma_handle,
-		    cmd->request_bufflen, cmd->sc_data_direction);
+		    scsi_bufflen(cmd), cmd->sc_data_direction);
 	}
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index efa4823..8530e9b 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -975,19 +975,19 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 		}
 		if (scsi_status & (SS_RESIDUAL_UNDER | SS_RESIDUAL_OVER)) {
 			resid = resid_len;
-			cp->resid = resid;
+			scsi_set_resid(cp, resid);
 			CMD_RESID_LEN(cp) = resid;
 
 			if (!lscsi_status &&
-			    ((unsigned)(cp->request_bufflen - resid) <
+			    ((unsigned)(scsi_bufflen(cp) - resid) <
 			     cp->underflow)) {
 				qla_printk(KERN_INFO, ha,
-				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
-				    "detected (%x of %x bytes)...returning "
-				    "error status.\n", ha->host_no,
-				    cp->device->channel, cp->device->id,
-				    cp->device->lun, resid,
-				    cp->request_bufflen);
+					   "scsi(%ld:%d:%d:%d): Mid-layer underflow "
+					   "detected (%x of %x bytes)...returning "
+					   "error status.\n", ha->host_no,
+					   cp->device->channel, cp->device->id,
+					   cp->device->lun, resid,
+					   scsi_bufflen(cp));
 
 				cp->result = DID_ERROR << 16;
 				break;
@@ -1055,7 +1055,7 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 		}
 
 		if (scsi_status & SS_RESIDUAL_UNDER) {
-			cp->resid = resid;
+			scsi_set_resid(cp, resid);
 			CMD_RESID_LEN(cp) = resid;
 		} else {
 			DEBUG2(printk(KERN_INFO
@@ -1129,7 +1129,7 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 			 * values.
 			 */
 			if (resid &&
-			    ((unsigned)(cp->request_bufflen - resid) <
+			    ((unsigned)(scsi_bufflen(cp) - resid) <
 			     cp->underflow)) {
 				DEBUG2(qla_printk(KERN_INFO, ha,
 				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
@@ -1137,7 +1137,7 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 				    "error status.\n", ha->host_no,
 				    cp->device->channel, cp->device->id,
 				    cp->device->lun, resid,
-				    cp->request_bufflen));
+				    scsi_bufflen(cp)));
 
 				cp->result = DID_ERROR << 16 | lscsi_status;
 			}
@@ -1153,26 +1153,26 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 			 */
 			if (!(scsi_status & SS_RESIDUAL_UNDER)) {
 				DEBUG2(printk("scsi(%ld:%d:%d:%d) Dropped "
-				    "frame(s) detected (%x of %x bytes)..."
-				    "retrying command.\n", ha->host_no,
-				    cp->device->channel, cp->device->id,
-				    cp->device->lun, resid,
-				    cp->request_bufflen));
+					      "frame(s) detected (%x of %x bytes)..."
+					      "retrying command.\n", ha->host_no,
+					      cp->device->channel, cp->device->id,
+					      cp->device->lun, resid,
+					      scsi_bufflen(cp)));
 
 				cp->result = DID_BUS_BUSY << 16;
 				break;
 			}
 
 			/* Handle mid-layer underflow */
-			if ((unsigned)(cp->request_bufflen - resid) <
+			if ((unsigned)(scsi_bufflen(cp) - resid) <
 			    cp->underflow) {
 				qla_printk(KERN_INFO, ha,
-				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
-				    "detected (%x of %x bytes)...returning "
-				    "error status.\n", ha->host_no,
-				    cp->device->channel, cp->device->id,
-				    cp->device->lun, resid,
-				    cp->request_bufflen);
+					   "scsi(%ld:%d:%d:%d): Mid-layer underflow "
+					   "detected (%x of %x bytes)...returning "
+					   "error status.\n", ha->host_no,
+					   cp->device->channel, cp->device->id,
+					   cp->device->lun, resid,
+					   scsi_bufflen(cp));
 
 				cp->result = DID_ERROR << 16;
 				break;
@@ -1195,7 +1195,7 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 		DEBUG2(printk(KERN_INFO
 		    "PID=0x%lx req=0x%x xtra=0x%x -- returning DID_ERROR "
 		    "status!\n",
-		    cp->serial_number, cp->request_bufflen, resid_len));
+		    cp->serial_number, scsi_bufflen(cp), resid_len));
 
 		cp->result = DID_ERROR << 16;
 		break;
@@ -1798,7 +1798,7 @@ struct qla_init_msix_entry {
 	uint16_t entry;
 	uint16_t index;
 	const char *name;
-	irqreturn_t (*handler)(int, void *, struct pt_regs *);
+	irq_handler_t handler;
 };
 
 static struct qla_init_msix_entry imsix_entries[QLA_MSIX_ENTRIES] = {
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index 3a06ae1..efd2e69 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -104,7 +104,7 @@ qla24xx_find_vhost_by_name(scsi_qla_host_t *ha, uint8_t *port_name)
  *
  * Context:
  */
-void
+static void
 qla2x00_mark_vp_devices_dead(scsi_qla_host_t *vha)
 {
 	fc_port_t *fcport;
@@ -187,37 +187,7 @@ enable_failed:
 	return 1;
 }
 
-/**
- * qla24xx_modify_vport() -  Modifies the virtual fabric port's configuration
- * @ha: HA context
- * @vp: pointer to buffer of virtual port parameters.
- * @ret_code: return error code:
- *
- * Returns the virtual port id, or MAX_VSAN_ID, if couldn't create.
- */
-uint32_t
-qla24xx_modify_vhba(scsi_qla_host_t *ha, vport_params_t *vp, uint32_t *vp_id)
-{
-	scsi_qla_host_t *vha;
-
-	vha = qla24xx_find_vhost_by_name(ha, vp->port_name);
-	if (!vha) {
-		*vp_id = MAX_NUM_VPORT_LOOP;
-		return VP_RET_CODE_WWPN;
-	}
-
-	if (qla24xx_enable_vp(vha)) {
-		scsi_host_put(vha->host);
-		qla2x00_mem_free(vha);
-		*vp_id = MAX_NUM_VPORT_LOOP;
-		return VP_RET_CODE_RESOURCES;
-	}
-
-	*vp_id = vha->vp_idx;
-	return VP_RET_CODE_OK;
-}
-
-void
+static void
 qla24xx_configure_vp(scsi_qla_host_t *vha)
 {
 	// struct fc_vport *fc_vport;
