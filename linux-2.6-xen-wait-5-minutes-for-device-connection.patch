From: Chris Lalancette <clalance@redhat.com>
Date: Thu, 5 Mar 2009 14:12:08 +0100
Subject: [xen] wait 5 minutes for device connection
Message-id: 49AFCFA8.6050809@redhat.com
O-Subject: [RHEL5.4 PATCH 2/2]: Wait 5 minutes for device connection
Bugzilla: 396621
RH-Acked-by: Don Dutile <ddutile@redhat.com>

Increase the device timeout from 10s to 5 minutes.  Give the user a visual
indication during that time, in case there are problems.  This is a backport of
upstream linux-2.6.18-xen.hg c/s 144, 146, and 150.

>From cab7098f7173ff7c043c571a7dccf1f3bbf5ef42 Mon Sep 17 00:00:00 2001
From: Chris Lalancette <clalance@redhat.com>
Date: Sun, 1 Mar 2009 14:11:03 +0100
Subject: [PATCH] xenbus: Wait for 5 minutes for devices to connect (previously 10s).

Give a visual update to the user on the console every 5s during this
period.

Combination of upstream linux-2.6.18-xen c/s 144, 146, and 150.

Signed-off-by: Chris Lalancette <clalance@redhat.com>

diff --git a/drivers/xen/xenbus/xenbus_probe.c b/drivers/xen/xenbus/xenbus_probe.c
index 4648e88..d4c28dd 100644
--- a/drivers/xen/xenbus/xenbus_probe.c
+++ b/drivers/xen/xenbus/xenbus_probe.c
@@ -1224,7 +1224,7 @@ static int is_disconnected_device(struct device *dev, void *data)
 		return 0;
 
 	xendrv = to_xenbus_driver(dev->driver);
-	return (xendev->state != XenbusStateConnected ||
+	return (xendev->state < XenbusStateConnected ||
 		(xendrv->is_ready && !xendrv->is_ready(xendev)));
 }
 
@@ -1250,10 +1250,13 @@ static int print_device_status(struct device *dev, void *data)
 		/* Information only: is this too noisy? */
 		printk(KERN_INFO "XENBUS: Device with no driver: %s\n",
 		       xendev->nodename);
-	} else if (xendev->state != XenbusStateConnected) {
+	} else if (xendev->state < XenbusStateConnected) {
+		enum xenbus_state rstate = XenbusStateUnknown;
+		if (xendev->otherend)
+			rstate = xenbus_read_driver_state(xendev->otherend);
 		printk(KERN_WARNING "XENBUS: Timeout connecting "
-		       "to device: %s (state %d)\n",
-		       xendev->nodename, xendev->state);
+		       "to device: %s (local state %d, remote state %d)\n",
+		       xendev->nodename, xendev->state, rstate);
 	}
 
 	return 0;
@@ -1263,7 +1266,7 @@ static int print_device_status(struct device *dev, void *data)
 static int ready_to_wait_for_devices;
 
 /*
- * On a 10 second timeout, wait for all devices currently configured.  We need
+ * On a 5-minute timeout, wait for all devices currently configured.  We need
  * to do this to guarantee that the filesystems and / or network devices
  * needed for boot are available, before we can allow the boot to proceed.
  *
@@ -1278,17 +1281,30 @@ static int ready_to_wait_for_devices;
  */
 static void wait_for_devices(struct xenbus_driver *xendrv)
 {
-	unsigned long timeout = jiffies + 10*HZ;
+	unsigned long start = jiffies;
 	struct device_driver *drv = xendrv ? &xendrv->driver : NULL;
+	unsigned int seconds_waited = 0;
 
 	if (!ready_to_wait_for_devices || !is_running_on_xen())
 		return;
 
 	while (exists_disconnected_device(drv)) {
-		if (time_after(jiffies, timeout))
-			break;
+		if (time_after(jiffies, start + (seconds_waited+5)*HZ)) {
+			if (!seconds_waited)
+				printk(KERN_WARNING "XENBUS: Waiting for "
+				       "devices to initialise: ");
+			seconds_waited += 5;
+			printk("%us...", 300 - seconds_waited);
+			if (seconds_waited == 300)
+				break;
+		}
+		
 		schedule_timeout_interruptible(HZ/10);
 	}
+
+	if (seconds_waited)
+		printk("\n");
+
 	bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,
 			 print_device_status);
 }
