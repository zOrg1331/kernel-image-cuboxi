X-Account-Key: account4
X-UIDL: 11c7c01bc5da931d
X-Mozilla-Status: 0001
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                 
Received: from relay.parallels.com (relay.parallels.com [195.214.232.42])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OICFGo019449
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
	Wed, 24 Mar 2010 21:12:16 +0300 (MSK)
Received: from mx1.parallels.com ([64.131.89.18])
	by relay.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3u-0008IY-Mn; Wed, 24 Mar 2010 21:12:15 +0300
Received: from mailhub.sw.ru ([195.214.232.25] helo=relay.sw.ru)
	by mx1.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3s-00047q-Nh; Wed, 24 Mar 2010 14:12:13 -0400
Received: from localhost.localdomain ([10.30.18.218])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OIC3ct007235;
	Wed, 24 Mar 2010 21:12:10 +0300 (MSK)
From: Vitaliy Gusev <vgusev@openvz.org>
To: xemul@openvz.org
Cc: vz@lists.sw.ru, Vitaliy Gusev <vgusev@openvz.org>
Subject: [2.6.18][PATCH 5/8] pacct: make internal code work with passed bsd_acct_struct, not global
Date: Wed, 24 Mar 2010 21:17:26 +0300
Message-Id: <1269454649-887-6-git-send-email-vgusev@openvz.org>
X-Mailer: git-send-email 1.6.0.2
In-Reply-To: <1269454649-887-1-git-send-email-vgusev@openvz.org>
References: <1269454649-887-1-git-send-email-vgusev@openvz.org>

This is mostly backport commit

   commit 6248b1b342005a428b1247b4e89249da1528d88d

   This adds the appropriate pointer to all the internal (i.e.  static)
   functions that work with global acct instance.  API calls pass a global
   instance to them (while we still have such).

   Mostly this is a s/acct_globals./acct->/ over the file.
   Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
---
 kernel/acct.c |   72 +++++++++++++++++++++++++++++---------------------------
 1 files changed, 37 insertions(+), 35 deletions(-)

diff --git a/kernel/acct.c b/kernel/acct.c
index 817850b..5ae8526 100644
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@ -71,10 +71,12 @@ int acct_parm[3] = {4, 2, 30};
 #define SUSPEND		(acct_parm[1])	/* <foo% free space - suspend */
 #define ACCT_TIMEOUT	(acct_parm[2])	/* foo second timeout between checks */
 
+struct bsd_acct_struct;
+
 /*
  * External references and all of the globals.
  */
-static void do_acct_process(struct file *);
+static void do_acct_process(struct bsd_acct_struct *acct, struct file *);
 
 /*
  * This structure is used so that all the data protected by lock
@@ -105,7 +107,7 @@ static void acct_timeout(unsigned long x)
 /*
  * Check the amount of free space and suspend/resume accordingly.
  */
-static int check_free_space(struct file *file)
+static int check_free_space(struct bsd_acct_struct *acct, struct file *file)
 {
 	struct kstatfs sbuf;
 	int res;
@@ -114,8 +116,8 @@ static int check_free_space(struct file *file)
 	sector_t suspend;
 
 	spin_lock(&acct_lock);
-	res = acct_globals.active;
-	if (!file || !acct_globals.needcheck)
+	res = acct->active;
+	if (!file || !acct->needcheck)
 		goto out;
 	spin_unlock(&acct_lock);
 
@@ -136,33 +138,33 @@ static int check_free_space(struct file *file)
 		act = 0;
 
 	/*
-	 * If some joker switched acct_globals.file under us we'ld better be
+	 * If some joker switched acct->file under us we'ld better be
 	 * silent and _not_ touch anything.
 	 */
 	spin_lock(&acct_lock);
-	if (file != acct_globals.file) {
+	if (file != acct->file) {
 		if (act)
 			res = act>0;
 		goto out;
 	}
 
-	if (acct_globals.active) {
+	if (acct->active) {
 		if (act < 0) {
-			acct_globals.active = 0;
+			acct->active = 0;
 			printk(KERN_INFO "Process accounting paused\n");
 		}
 	} else {
 		if (act > 0) {
-			acct_globals.active = 1;
+			acct->active = 1;
 			printk(KERN_INFO "Process accounting resumed\n");
 		}
 	}
 
-	del_timer(&acct_globals.timer);
-	acct_globals.needcheck = 0;
-	acct_globals.timer.expires = jiffies + ACCT_TIMEOUT*HZ;
-	add_timer(&acct_globals.timer);
-	res = acct_globals.active;
+	del_timer(&acct->timer);
+	acct->needcheck = 0;
+	acct->timer.expires = jiffies + ACCT_TIMEOUT*HZ;
+	add_timer(&acct->timer);
+	res = acct->active;
 out:
 	spin_unlock(&acct_lock);
 	return res;
@@ -174,31 +176,31 @@ out:
  *
  * NOTE: acct_lock MUST be held on entry and exit.
  */
-static void acct_file_reopen(struct file *file)
+static void acct_file_reopen(struct bsd_acct_struct *acct, struct file *file)
 {
 	struct file *old_acct = NULL;
 
-	if (acct_globals.file) {
-		old_acct = acct_globals.file;
-		del_timer(&acct_globals.timer);
-		acct_globals.active = 0;
-		acct_globals.needcheck = 0;
-		acct_globals.file = NULL;
+ 	if (acct->file) {
+ 		old_acct = acct->file;
+ 		del_timer(&acct->timer);
+ 		acct->active = 0;
+ 		acct->needcheck = 0;
+ 		acct->file = NULL;
 	}
 	if (file) {
-		acct_globals.file = file;
-		acct_globals.needcheck = 0;
-		acct_globals.active = 1;
+ 		acct->file = file;
+ 		acct->needcheck = 0;
+ 		acct->active = 1;
 		/* It's been deleted if it was used before so this is safe */
 		setup_timer(&acct_globals.timer, acct_timeout,
-			    (unsigned long)&acct_globals);
-		acct_globals.timer.expires = jiffies + ACCT_TIMEOUT*HZ;
-		add_timer(&acct_globals.timer);
+			    (unsigned long)acct);
+		acct->timer.expires = jiffies + ACCT_TIMEOUT*HZ;
+		add_timer(&acct->timer);
 	}
 	if (old_acct) {
 		mnt_unpin(old_acct->f_vfsmnt);
 		spin_unlock(&acct_lock);
-		do_acct_process(old_acct);
+		do_acct_process(acct, old_acct);
 		filp_close(old_acct, NULL);
 		spin_lock(&acct_lock);
 	}
@@ -232,7 +234,7 @@ static int acct_on(char *name)
 
 	spin_lock(&acct_lock);
 	mnt_pin(file->f_vfsmnt);
-	acct_file_reopen(file);
+	acct_file_reopen(&acct_globals, file);
 	spin_unlock(&acct_lock);
 
 	mntput(file->f_vfsmnt);	/* it's pinned, now give up active reference */
@@ -268,7 +270,7 @@ asmlinkage long sys_acct(const char __user *name)
 		error = security_acct(NULL);
 		if (!error) {
 			spin_lock(&acct_lock);
-			acct_file_reopen(NULL);
+			acct_file_reopen(&acct_globals, NULL);
 			spin_unlock(&acct_lock);
 		}
 	}
@@ -286,7 +288,7 @@ void acct_auto_close_mnt(struct vfsmount *m)
 {
 	spin_lock(&acct_lock);
 	if (acct_globals.file && acct_globals.file->f_vfsmnt == m)
-		acct_file_reopen(NULL);
+		acct_file_reopen(&acct_globals, NULL);
 	spin_unlock(&acct_lock);
 }
 
@@ -302,7 +304,7 @@ void acct_auto_close(struct super_block *sb)
 	spin_lock(&acct_lock);
 	if (acct_globals.file &&
 	    acct_globals.file->f_vfsmnt->mnt_sb == sb) {
-		acct_file_reopen(NULL);
+		acct_file_reopen(&acct_globals, NULL);
 	}
 	spin_unlock(&acct_lock);
 }
@@ -421,7 +423,7 @@ static u32 encode_float(u64 value)
 /*
  *  do_acct_process does all actual work. Caller holds the reference to file.
  */
-static void do_acct_process(struct file *file)
+static void do_acct_process(struct bsd_acct_struct *acct, struct file *file)
 {
 	struct pacct_struct *pacct = &current->signal->pacct;
 	acct_t ac;
@@ -435,7 +437,7 @@ static void do_acct_process(struct file *file)
 	 * First check to see if there is enough free_space to continue
 	 * the process accounting system.
 	 */
-	if (!check_free_space(file))
+	if (!check_free_space(acct, file))
 		return;
 
 	/*
@@ -602,7 +604,7 @@ void acct_process(void)
 	get_file(file);
 	spin_unlock(&acct_lock);
 
-	do_acct_process(file);
+	do_acct_process(&acct_globals, file);
 	fput(file);
 }
 
-- 
1.6.0.2


