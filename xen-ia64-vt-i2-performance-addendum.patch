From: Bill Burns <bburns@redhat.com>
Date: Mon, 25 Aug 2008 08:22:19 -0400
Subject: [xen] ia64: VT-i2 performance addendum
Message-id: 20080825122221.5101.25500.sendpatchset@localhost.localdomain
O-Subject: [RHEL5.3 PATCH 1/1] Xen ia64 VT-i2 performance addendum
Bugzilla: 437096
RH-Acked-by: Rik van Riel <riel@redhat.com>
RH-Acked-by: Don Dutile <ddutile@redhat.com>

Fixes bz 437096

This is an additional patch to the 3 already posted
and integrated. The initial patches raised a performance
concern at Fujitsu and Intel has addressed that with this
patch. Fujitsu has evauated the new patch and tested with it.

Problem description:
This Intel feature patch adds support for VT-i2.
VT-i2 supports the new hardware virtualization features of a new
ia64 processor. This processor will be used on the upcoming Tukwila
system.

Patches were provided by Intel. They apply cleanly
to our 3.1.2 based code base and brew build cleanly.

Upstream in Xen Unstable:
http://xenbits.xensource.com/xen-unstable.hg?rev/e5244d14486c
http://xenbits.xensource.com/xen-unstable.hg?rev/6cf504b4de7d

Brew build:
https://brewweb.devel.redhat.com/taskinfo?taskID=1433626

Testing:
Partner tested by Intel and Fujitsu.

Please review and ACK.

Thanks,
 Bill

# HG changeset patch
# User xiantao.zhang@intel.com
# Date 1218693541 -28800
# Node ID 197331831e5904121eac4aa399b20098d323ac78
# Parent  ee6d4cebc877a14f8b7d00092fdbcf0c7d91fb25
Fix thash's optimization code for handling long-format VHPT.
Don't ruin r24, r25, since it maybe used by fault_back path.

diff --git a/arch/ia64/vmx/optvfault.S b/arch/ia64/vmx/optvfault.S
index c64cb6f..cf2090d 100644
--- a/arch/ia64/vmx/optvfault.S
+++ b/arch/ia64/vmx/optvfault.S
@@ -18,6 +18,7 @@
 #include <asm/vmx_pal_vsa.h>
 #include <asm/asm-offsets.h>
 #include <asm-ia64/vmx_mm_def.h>
+#include <asm/virt_event.h>
 
 //#define ACCE_MOV_FROM_AR
 //#define ACCE_MOV_FROM_RR
@@ -523,24 +524,25 @@ GLOBAL_ENTRY(vmx_asm_thash)
     ;;                                                     
 vmx_asm_thash_back1:
     shr.u r23=r19,61		// get RR number
-    adds r25=VCPU_VRR0_OFS,r21	// get vcpu->arch.arch_vmx.vrr[0]'s addr
+    adds r28=VCPU_VRR0_OFS,r21	// get vcpu->arch.arch_vmx.vrr[0]'s addr
     adds r16=IA64_VPD_VPTA_OFFSET,r16	// get vpta 
     ;;
-    shladd r27=r23,3,r25	// get vcpu->arch.arch_vmx.vrr[r23]'s addr
+    shladd r27=r23,3,r28	// get vcpu->arch.arch_vmx.vrr[r23]'s addr
     ld8 r17=[r16]		// get PTA
     mov r26=1
     ;;
     extr.u r29=r17,2,6		// get pta.size
-    ld8 r25=[r27]		// get vcpu->arch.arch_vmx.vrr[r23]'s value
+    ld8 r28=[r27]		// get vcpu->arch.arch_vmx.vrr[r23]'s value
+    mov b0=r24
     ;;
     // Fall-back to C if VF (long format) is set
     tbit.nz p6,p0=r17,8
-    mov b0=r24
+    (p6) mov r24 =EVENT_THASH
     (p6) br.cond.dpnt.many vmx_virtualization_fault_back
-    extr.u r25=r25,2,6		// get rr.ps
+    extr.u r28=r28,2,6		// get rr.ps
     shl r22=r26,r29		// 1UL << pta.size
     ;;
-    shr.u r23=r19,r25		// vaddr >> rr.ps
+    shr.u r23=r19,r28		// vaddr >> rr.ps
     adds r26=3,r29		// pta.size + 3 
     shl r27=r17,3		// pta << 3 
     ;;
