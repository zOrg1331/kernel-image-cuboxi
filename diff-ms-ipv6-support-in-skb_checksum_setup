Subject:
[patch 3/3] [v2] Implemented support of IPv6 in function skb_checksum_setup()
From:
Dmitry Skorodumov <sdmitry@parallels.com>
Date:
Wed, 16 Feb 2011 18:24:23 +0300
To:
Pavel Emelianov <xemul@parallels.com>
CC:
Denis Lunev <den@parallels.com>

Implemented support of IPv6 in function skb_checksum_setup()

When some packet from VM goes through bridge to another VM, function __br_forward resets skb->ip_summed to CHECKSUM_NONE.
Then skb goes to dev_queue_xmit() which calls skb_shecksum_setup() and if it doesn't support IPv6, the skb is dropped.

So, to allow VM<->VM IPv6 traffic, skb_checksum_setup() must support it.

Signed-off-by: Dmitry Skorodumov <sdmitry@parallels.com>


patch3.patch

Implemented support of IPv6 in function skb_checksum_setup()

When some packet from VM goes through bridge to another VM,
function __br_forward resets skb->ip_summed to CHECKSUM_NONE.
Then skb goes to dev_queue_xmit() which calls skb_shecksum_setup()
and if it doesn't support IPv6, the skb is dropped.

So, to allow VM<->VM IPv6 traffic, skb_checksum_setup()
must support it.

Signed-off-by: Dmitry Skorodumov <sdmitry@parallels.com>
--- a/net/core/dev.c	2011-02-11 19:37:59.000000000 +0300
+++ a/net/core/dev.c	2011-02-11 20:59:46.000000000 +0300
@@ -125,6 +125,7 @@
 
 #if defined(CONFIG_XEN) || defined(CONFIG_VE)
 #include <net/ip.h>
+#include <net/ipv6.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #endif
@@ -1540,14 +1541,9 @@ out_kfree_skb:
 }
 
 #if defined(CONFIG_XEN) || defined(CONFIG_VE)
-static inline int skb_checksum_setup_v4(struct sk_buff *skb)
+static inline int skb_setup_csum_ptr(struct sk_buff *skb, int proto)
 {
-	if (unlikely(skb->data < skb->nh.raw + sizeof(*skb->nh.iph) &&
-	    !pskb_may_pull(skb, skb->nh.raw + sizeof(*skb->nh.iph) -
-				skb->data)))
-		goto out;
-	skb->h.raw = (unsigned char *)skb->nh.iph + 4*skb->nh.iph->ihl;
-	switch (skb->nh.iph->protocol) {
+	switch (proto) {
 	case IPPROTO_TCP:
 		skb->csum = offsetof(struct tcphdr, check);
 		break;
@@ -1558,7 +1554,7 @@ static inline int skb_checksum_setup_v4(
 		if (net_ratelimit())
 			printk(KERN_ERR "Attempting to checksum a non-"
 			       "TCP/UDP packet, dropping a protocol"
-			       " %d packet", skb->nh.iph->protocol);
+			       " %d packet", proto);
 		goto out;
 	}
 	if (unlikely(skb->data < skb->h.raw + skb->csum + 2 &&
@@ -1571,11 +1567,43 @@ out:
 	return -EPROTO;
 }
 
+static inline int skb_checksum_setup_v4(struct sk_buff *skb)
+{
+	if (unlikely(skb->data < skb->nh.raw + sizeof(*skb->nh.iph) &&
+	    !pskb_may_pull(skb, skb->nh.raw + sizeof(*skb->nh.iph) -
+				skb->data)))
+		return -EPROTO;
+	skb->h.raw = (unsigned char *)skb->nh.iph + 4*skb->nh.iph->ihl;
+	return skb_setup_csum_ptr(skb, skb->nh.iph->protocol);
+}
+
+static inline int skb_checksum_setup_v6(struct sk_buff *skb)
+{
+	int ptr;
+	u8 nexthdr;
+	if (unlikely(skb->data < skb->nh.raw + sizeof(*skb->nh.ipv6h) &&
+	    !pskb_may_pull(skb, skb->nh.raw + sizeof(*skb->nh.ipv6h) -
+				skb->data)))
+		return -EPROTO;
+
+	ptr = (u8*)(skb->nh.ipv6h + 1) - skb->data;
+	nexthdr = skb->nh.ipv6h->nexthdr;
+
+	ptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);
+	if (unlikely(ptr < 0))
+		return -EPROTO;
+
+	skb->h.raw = skb->data + ptr;
+	return skb_setup_csum_ptr(skb, nexthdr);
+}
+
 inline int skb_checksum_setup(struct sk_buff *skb)
 {
 	if (skb->proto_csum_blank) {
 		if (skb->protocol == htons(ETH_P_IP))
 			return skb_checksum_setup_v4(skb);
+		else if (skb->protocol == htons(ETH_P_IPV6))
+			return skb_checksum_setup_v6(skb);
 		return -EPROTO;
 	}
 	return 0;
