From: Ian Kent <ikent@redhat.com>
Date: Mon, 8 Jun 2009 11:02:52 +0800
Subject: [fs] autofs4: remove hashed check in validate_wait
Message-id: 20090608030252.6319.75180.stgit@zeus.themaw.net
O-Subject: [RHEL 5.4 PATCH] autofs4 - remove hashed check in validate_wait() [bz490078]
Bugzilla: 490078

From: Ian Kent <raven@themaw.net>

This patch is an addition to the deadlock fix of bug 490078.

During stress testing autofs submount handling using our RHTS autofs
submount-test a race which causes incorrect callbacks to the daemon
was identified. This is a side effect of the recent fix for a deadlock
in ->lookup(). See bug 490078, comment #8 for a little additional
information, compared to what is in this description.

The recent ->lookup() deadlock correction required the directory
inode mutex to be dropped while waiting for expire completion.

When checking if a mount has already completed prior to adding a
new mount request to the wait queue we check if the dentry is hashed
and, if so, if it is a mount point. But, if a mount successfully
completed while we slept on the wait queue mutex the dentry must
exist for the mount to have completed so the test is not really
needed.

Mounts can also be done on top of a global root dentry, so for the
above case, where a mount request completes and the wait queue entry
has already been removed, the hashed test returning false can cause
an incorrect callback to the daemon. Also, d_mountpoint() is not
sufficient to check if a mount has completed for the multi-mount
case when we don't have a real mount at the base of the tree.

Signed-off-by: Ian Kent <raven@themaw.net>

diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c
index 17f5376..319e2f8 100644
--- a/fs/autofs4/waitq.c
+++ b/fs/autofs4/waitq.c
@@ -293,20 +293,14 @@ static int validate_request(struct autofs_wait_queue **wait,
 	 */
 	if (notify == NFY_MOUNT) {
 		/*
-		 * If the dentry isn't hashed just go ahead and try the
-		 * mount again with a new wait (not much else we can do).
-		*/
-		if (!d_unhashed(dentry)) {
-			/*
-			 * But if the dentry is hashed, that means that we
-			 * got here through the revalidate path.  Thus, we
-			 * need to check if the dentry has been mounted
-			 * while we waited on the wq_mutex. If it has,
-			 * simply return success.
-			 */
-			if (d_mountpoint(dentry))
-				return 0;
-		}
+		 * If the dentry was successfully mounted while we slept
+		 * on the wait queue mutex we can return success. If it
+		 * isn't mounted (doesn't have submounts for the case of
+		 * a multi-mount with no mount at it's base) we can
+		 * continue on and create a new request.
+		 */
+		if (have_submounts(dentry))
+			return 0;
 	}
 
 	return 1;
