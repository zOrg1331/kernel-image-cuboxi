From: Mauro Carvalho Chehab <mchehab@redhat.com>
Date: Mon, 18 Aug 2008 21:31:08 -0300
Subject: [ide] Fix issue when appending data on an existing DVD
Message-id: 20080818213108.2c307596@mchehab.chehab.org
O-Subject: [RHEL5.3 PATCH] Fix OOPS when appending data on an existing DVD
Bugzilla: 457025
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>
RH-Acked-by: Eugene Teo <eteo@redhat.com>

https://bugzilla.redhat.com/show_bug.cgi?id=457025

The bug were reported originally at LKML http://lkml.org/lkml/2008/6/22/90.

The first fix is at upstream patch e8e7b9eb11c34ee18bde8b7011af41938d1ad667,
but it presents a wrong printk msg. So, a later fix were aplied at
commit 938bb03d188a1e688fb0bcae49788f540193e80a.

This fix backports both patches to RHEL4.

Tried to reproduce the bug here, with commands like:
	$ growisofs -M /dev/dvd <some files>
without producing the OOPS, applying the patch or not. Yet, the patch
seems to be important, as it tracks some weird contitions that may
happen at users environment.

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

Please ACK and apply.

Thanks,
Mauro.

diff --git a/drivers/ide/ide-cd.c b/drivers/ide/ide-cd.c
index 8ab958c..537ed07 100644
--- a/drivers/ide/ide-cd.c
+++ b/drivers/ide/ide-cd.c
@@ -2216,6 +2216,7 @@ static int cdrom_read_capacity(ide_drive_t *drive, unsigned long *capacity,
 
 	int stat;
 	struct request req;
+	u32 blocklen;
 
 	cdrom_prepare_request(drive, &req);
 
@@ -2226,13 +2227,31 @@ static int cdrom_read_capacity(ide_drive_t *drive, unsigned long *capacity,
 	req.flags |= REQ_QUIET;
 
 	stat = cdrom_queue_packet_command(drive, &req);
-	if (stat == 0) {
-		*capacity = 1 + be32_to_cpu(capbuf.lba);
-		*sectors_per_frame =
-			be32_to_cpu(capbuf.blocklen) >> SECTOR_BITS;
-	}
+	if (stat)
+		return stat;
 
-	return stat;
+	/*
+	 * Sanity check the given block size
+	 */
+	blocklen = be32_to_cpu(capbuf.blocklen);
+	switch (blocklen) {
+	case 512:
+	case 1024:
+	case 2048:
+	case 4096:
+		break;
+	default:
+		printk(KERN_ERR "%s: weird block size %u\n",
+			drive->name, blocklen);
+		printk(KERN_ERR "%s: default to 2kb block size\n",
+			drive->name);
+		blocklen = 2048;
+		break;
+ 	}
+ 
+	*capacity = 1 + be32_to_cpu(capbuf.lba);
+	*sectors_per_frame = blocklen >> SECTOR_BITS;
+	return 0;
 }
 
 static int cdrom_read_tocentry(ide_drive_t *drive, int trackno, int msf_flag,
