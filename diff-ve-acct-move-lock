X-Account-Key: account4
X-UIDL: 451373f238316408
X-Mozilla-Status: 0001
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                 
Received: from relay.parallels.com (relay.parallels.com [195.214.232.42])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OICDc1025929
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
	Wed, 24 Mar 2010 21:12:14 +0300 (MSK)
Received: from mx1.parallels.com ([64.131.89.18])
	by relay.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3r-0008IE-Oq; Wed, 24 Mar 2010 21:12:12 +0300
Received: from mailhub.sw.ru ([195.214.232.25] helo=relay.sw.ru)
	by mx1.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3q-00047R-It; Wed, 24 Mar 2010 14:12:11 -0400
Received: from localhost.localdomain ([10.30.18.218])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OIC3cr007235;
	Wed, 24 Mar 2010 21:12:08 +0300 (MSK)
From: Vitaliy Gusev <vgusev@openvz.org>
To: xemul@openvz.org
Cc: vz@lists.sw.ru, Vitaliy Gusev <vgusev@openvz.org>
Subject: [2.6.18][PATCH 3/8] pacct: move acct_lock from bsd_acct_struct to global
Date: Wed, 24 Mar 2010 21:17:24 +0300
Message-Id: <1269454649-887-4-git-send-email-vgusev@openvz.org>
X-Mailer: git-send-email 1.6.0.2
In-Reply-To: <1269454649-887-1-git-send-email-vgusev@openvz.org>
References: <1269454649-887-1-git-send-email-vgusev@openvz.org>

Don't use per-struct lock as it can cause some lock  issues (
difficulties, deadlocks)

Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
---
 kernel/acct.c |   41 +++++++++++++++++++++--------------------
 1 files changed, 21 insertions(+), 20 deletions(-)

diff --git a/kernel/acct.c b/kernel/acct.c
index 84f09ea..51424c7 100644
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@ -82,14 +82,15 @@ static void do_acct_process(struct file *);
  * the cache line to have the data after getting the lock.
  */
 struct bsd_acct_struct {
-	spinlock_t		lock;
 	volatile int		active;
 	volatile int		needcheck;
 	struct file		*file;
 	struct timer_list	timer;
 };
 
-static struct bsd_acct_struct acct_globals __cacheline_aligned = {SPIN_LOCK_UNLOCKED};
+static DEFINE_SPINLOCK(acct_lock);
+
+static struct bsd_acct_struct acct_globals __cacheline_aligned;
 
 /*
  * Called whenever the timer says to check the free space.
@@ -110,11 +111,11 @@ static int check_free_space(struct file *file)
 	sector_t resume;
 	sector_t suspend;
 
-	spin_lock(&acct_globals.lock);
+	spin_lock(&acct_lock);
 	res = acct_globals.active;
 	if (!file || !acct_globals.needcheck)
 		goto out;
-	spin_unlock(&acct_globals.lock);
+	spin_unlock(&acct_lock);
 
 	/* May block */
 	if (vfs_statfs(file->f_dentry, &sbuf))
@@ -136,7 +137,7 @@ static int check_free_space(struct file *file)
 	 * If some joker switched acct_globals.file under us we'ld better be
 	 * silent and _not_ touch anything.
 	 */
-	spin_lock(&acct_globals.lock);
+	spin_lock(&acct_lock);
 	if (file != acct_globals.file) {
 		if (act)
 			res = act>0;
@@ -161,7 +162,7 @@ static int check_free_space(struct file *file)
 	add_timer(&acct_globals.timer);
 	res = acct_globals.active;
 out:
-	spin_unlock(&acct_globals.lock);
+	spin_unlock(&acct_lock);
 	return res;
 }
 
@@ -169,7 +170,7 @@ out:
  * Close the old accounting file (if currently open) and then replace
  * it with file (if non-NULL).
  *
- * NOTE: acct_globals.lock MUST be held on entry and exit.
+ * NOTE: acct_lock MUST be held on entry and exit.
  */
 static void acct_file_reopen(struct file *file)
 {
@@ -194,10 +195,10 @@ static void acct_file_reopen(struct file *file)
 	}
 	if (old_acct) {
 		mnt_unpin(old_acct->f_vfsmnt);
-		spin_unlock(&acct_globals.lock);
+		spin_unlock(&acct_lock);
 		do_acct_process(old_acct);
 		filp_close(old_acct, NULL);
-		spin_lock(&acct_globals.lock);
+		spin_lock(&acct_lock);
 	}
 }
 
@@ -227,10 +228,10 @@ static int acct_on(char *name)
 		return error;
 	}
 
-	spin_lock(&acct_globals.lock);
+	spin_lock(&acct_lock);
 	mnt_pin(file->f_vfsmnt);
 	acct_file_reopen(file);
-	spin_unlock(&acct_globals.lock);
+	spin_unlock(&acct_lock);
 
 	mntput(file->f_vfsmnt);	/* it's pinned, now give up active reference */
 
@@ -264,9 +265,9 @@ asmlinkage long sys_acct(const char __user *name)
 	} else {
 		error = security_acct(NULL);
 		if (!error) {
-			spin_lock(&acct_globals.lock);
+			spin_lock(&acct_lock);
 			acct_file_reopen(NULL);
-			spin_unlock(&acct_globals.lock);
+			spin_unlock(&acct_lock);
 		}
 	}
 	return error;
@@ -281,10 +282,10 @@ asmlinkage long sys_acct(const char __user *name)
  */
 void acct_auto_close_mnt(struct vfsmount *m)
 {
-	spin_lock(&acct_globals.lock);
+	spin_lock(&acct_lock);
 	if (acct_globals.file && acct_globals.file->f_vfsmnt == m)
 		acct_file_reopen(NULL);
-	spin_unlock(&acct_globals.lock);
+	spin_unlock(&acct_lock);
 }
 
 /**
@@ -296,12 +297,12 @@ void acct_auto_close_mnt(struct vfsmount *m)
  */
 void acct_auto_close(struct super_block *sb)
 {
-	spin_lock(&acct_globals.lock);
+	spin_lock(&acct_lock);
 	if (acct_globals.file &&
 	    acct_globals.file->f_vfsmnt->mnt_sb == sb) {
 		acct_file_reopen(NULL);
 	}
-	spin_unlock(&acct_globals.lock);
+	spin_unlock(&acct_lock);
 }
 
 /*
@@ -590,14 +591,14 @@ void acct_process(void)
 	if (!acct_globals.file)
 		return;
 
-	spin_lock(&acct_globals.lock);
+	spin_lock(&acct_lock);
 	file = acct_globals.file;
 	if (unlikely(!file)) {
-		spin_unlock(&acct_globals.lock);
+		spin_unlock(&acct_lock);
 		return;
 	}
 	get_file(file);
-	spin_unlock(&acct_globals.lock);
+	spin_unlock(&acct_lock);
 
 	do_acct_process(file);
 	fput(file);
-- 
1.6.0.2


