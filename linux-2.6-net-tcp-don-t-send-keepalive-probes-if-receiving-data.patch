From: Flavio Leitner <fleitner@redhat.com>
Date: Mon, 17 May 2010 17:51:21 -0400
Subject: [net] tcp: don't send keepalive probes if receiving data
Message-id: <20100517175121.GA3261@redhat.com>
Patchwork-id: 25141
O-Subject: [RHEL5.6 PATCH] BZ593040: TCP: avoid to send keepalive probes if
	receiving data
Bugzilla: 593040
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Jiri Pirko <jpirko@redhat.com>
RH-Acked-by: Amerigo Wang <amwang@redhat.com>

RHBZ#:
======
https://bugzilla.redhat.com/show_bug.cgi?id=593040

Description:
============
Customer has an application that receives a connection and keeps
receiving data without sending anything back, just pure ACKs. After
some time receiving periodic data from the client, the server starts
to send keepalive packets.

RFC 1122 says the following:
...
  Keep-alive packets MUST only be sent when no data or
  acknowledgement packets have been received for the
  connection within an interval.
...

The acknowledgement packet is reseting the keepalive
timer but the data packet isn't. This patch fixes it by
checking the timestamp of the last received data packet
too when the keepalive timer expires.

Brew:
=====
https://brewweb.devel.redhat.com/taskinfo?taskID=2444536

Upstream:
=========
http://git.kernel.org/?p=linux/kernel/git/davem/net-next-2.6.git;a=commitdiff;h=6c37e5de456987f5bc80879afde05aa120784095

Proposed patch:
==============
It's a straightforward backport of the upstream commit to 5.6.0.

Please review,
thanks,
Flavio Leitner

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/include/net/tcp.h b/include/net/tcp.h
index 92466dd..79160cf 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1004,6 +1004,14 @@ static inline int keepalive_time_when(const struct tcp_sock *tp)
 	return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
 }
 
+static inline u32 keepalive_time_elapsed(const struct tcp_sock *tp)
+{
+	const struct inet_connection_sock *icsk = &tp->inet_conn;
+
+	return min_t(u32, tcp_time_stamp - icsk->icsk_ack.lrcvtime,
+			  tcp_time_stamp - tp->rcv_tstamp);
+}
+
 static inline int tcp_fin_time(const struct sock *sk)
 {
 	int fin_timeout = tcp_sk(sk)->linger2 ? : sysctl_tcp_fin_timeout;
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index db89e55..a64b145 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1875,7 +1875,7 @@ static int do_tcp_setsockopt(struct sock *sk, int level,
 			if (sock_flag(sk, SOCK_KEEPOPEN) &&
 			    !((1 << sk->sk_state) &
 			      (TCPF_CLOSE | TCPF_LISTEN))) {
-				__u32 elapsed = tcp_time_stamp - tp->rcv_tstamp;
+				u32 elapsed = keepalive_time_elapsed(tp);
 				if (tp->keepalive_time > elapsed)
 					elapsed = tp->keepalive_time - elapsed;
 				else
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index f233121..38a9d5b 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -480,7 +480,7 @@ static void tcp_keepalive_timer (unsigned long data)
 	struct sock *sk = (struct sock *) data;
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
-	__u32 elapsed;
+	u32 elapsed;
 
 	/* Only process if socket is not in use. */
 	bh_lock_sock(sk);
@@ -517,7 +517,7 @@ static void tcp_keepalive_timer (unsigned long data)
 	if (tp->packets_out || sk->sk_send_head)
 		goto resched;
 
-	elapsed = tcp_time_stamp - tp->rcv_tstamp;
+	elapsed = keepalive_time_elapsed(tp);
 
 	if (elapsed >= keepalive_time_when(tp)) {
 		if ((!tp->keepalive_probes && icsk->icsk_probes_out >= sysctl_tcp_keepalive_probes) ||
