From: Hans-Joachim Picht <hpicht@redhat.com>
Date: Sat, 25 Oct 2008 10:56:01 +0200
Subject: [s390] qdio: speedup multicast on full HiperSocket queue
Message-id: 20081025085601.GB25269@redhat.com
O-Subject: RHEL5 U3 PATCH 1/1] s390 - qdio: speed up multicast traffic on full HiperSocket queue
Bugzilla: 463162
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>

Description
============

If an asynchronous HiperSockets queue runs full, no further packet
can be sent. In this case the next initiative to give transmitted
skbs back to the stack is triggered only by a 10-seconds qdio timer.
This timer has been introduced for low multicast traffic scenarios
to guarantee freeing of skbs in a limited amount of time. For high
HiperSocket multicast traffic scenarios progress checking on the
outbound queue should be enforced by tasklet rescheduling.

Bugzilla
=========

BZ  463162
https://bugzilla.redhat.com/show_bug.cgi?id= 463162

Upstream status of the patch:
=============================

Included in linux-2.6 as git commit 4bcb3a37180ee4dffaef8298f373b334a7bedabb

Test status:
============

The patch has been tested and fixes the problem.
The fix has been verified by the IBM test department.

Please ACK.

With best regards,

	--Hans

diff --git a/drivers/s390/cio/qdio.c b/drivers/s390/cio/qdio.c
index c2194dc..df55883 100644
--- a/drivers/s390/cio/qdio.c
+++ b/drivers/s390/cio/qdio.c
@@ -1001,7 +1001,10 @@ __qdio_outbound_processing(struct qdio_q *q)
 		if ((!q->hydra_gives_outbound_pcis) &&
 		    (!qdio_is_outbound_q_done(q)))
 			qdio_mark_q(q);
-	}
+	} else if ((q->is_iqdio_q) && (atomic_read(&q->number_of_buffers_used) >
+				       IQDIO_FILL_LEVEL_TO_POLL))
+		/* for asynchronous queues check if fill level is high */
+		qdio_mark_q(q);
 	else if (((!q->is_iqdio_q) && (!q->is_pci_out)) ||
 		 (q->queue_type == QDIO_IQDIO_QFMT_ASYNCH)) {
 		if (qdio_is_outbound_q_done(q)) {
diff --git a/drivers/s390/cio/qdio.h b/drivers/s390/cio/qdio.h
index 9ed673c..94b0ecb 100644
--- a/drivers/s390/cio/qdio.h
+++ b/drivers/s390/cio/qdio.h
@@ -21,11 +21,11 @@
  * unfortunately this can't be (QDIO_MAX_BUFFERS_PER_Q*4/3) or so -- as
  * we never know, whether we'll get initiative again, e.g. to give the
  * transmit skb's back to the stack, however the stack may be waiting for
- * them... therefore we define 4 as threshold to start polling (which
+ * them... therefore we define 65 as threshold to start polling (which
  * will stop as soon as the asynchronous queue catches up)
  * btw, this only applies to the asynchronous HiperSockets queue
  */
-#define IQDIO_FILL_LEVEL_TO_POLL 4
+#define IQDIO_FILL_LEVEL_TO_POLL 65
 
 #define TIQDIO_THININT_ISC 3
 #define TIQDIO_DELAY_TARGET 0
