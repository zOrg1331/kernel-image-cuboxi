From: Luming Yu <luyu@redhat.com>
Date: Thu, 16 Aug 2007 17:12:12 +0800
Subject: [net] CIPSO packets generate kernel unaligned access
Message-id: 46C414EC.1000407@redhat.com
O-Subject: [RHEL 5.2 PATCH] bz 242955: CIPSO packets generate kernel unaligned access messages
Bugzilla: 242955

bz 242955

Description of problem:

The kernel performs several unaligned accesses when validating and parsing
incoming CIPSO tagged packets which result in error messages on IA64
platforms, although it is likely other alignment sensitive platforms are
affected as well.  The attached patch fixes this problem.

upstream status:
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=50e5d35ce2c4190cead13a091ea1ceab47d29cc2

According to the bug report, the following back port has been tested by HP and the problem is fixed.
I also did some general testing with this patch. It works.

Please help review, test and ACK.

Thanks,
Luming

Acked-by: Eric Paris <eparis@redhat.com>
Acked-by: Prarit Bhargava <prarit@redhat.com>
Acked-by: Doug Chapman <dchapman@redhat.com>

diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index 10fc9d9..7bde6c3 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -45,6 +45,7 @@
 #include <net/cipso_ipv4.h>
 #include <asm/atomic.h>
 #include <asm/bug.h>
+#include <asm/unaligned.h>
 
 struct cipso_v4_domhsh_entry {
 	char *domain;
@@ -1137,7 +1138,7 @@ int cipso_v4_validate(unsigned char **option)
 	}
 
 	rcu_read_lock();
-	doi_def = cipso_v4_doi_search(ntohl(*((u32 *)&opt[2])));
+	doi_def = cipso_v4_doi_search(ntohl(get_unaligned((u32 *)&opt[2])));
 	if (doi_def == NULL) {
 		err_offset = 2;
 		goto validate_return_locked;
@@ -1380,7 +1381,7 @@ int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
 	if (ret_val == 0)
 		return ret_val;
 
-	doi = ntohl(*(u32 *)&cipso_ptr[2]);
+	doi = ntohl(get_unaligned((u32 *)&cipso_ptr[2]));
 	rcu_read_lock();
 	doi_def = cipso_v4_doi_search(doi);
 	if (doi_def == NULL) {
@@ -1448,7 +1449,7 @@ int cipso_v4_skbuff_getattr(const struct sk_buff *skb,
 	if (cipso_v4_cache_check(cipso_ptr, cipso_ptr[1], secattr) == 0)
 		return 0;
 
-	doi = ntohl(*(u32 *)&cipso_ptr[2]);
+	doi = ntohl(get_unaligned((u32 *)&cipso_ptr[2]));
 	rcu_read_lock();
 	doi_def = cipso_v4_doi_search(doi);
 	if (doi_def == NULL)
