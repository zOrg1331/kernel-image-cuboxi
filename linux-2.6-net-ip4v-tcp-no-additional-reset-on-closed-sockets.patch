From: Neil Horman <nhorman@redhat.com>
Date: Fri, 30 Jul 2010 17:07:38 -0400
Subject: [net] ip4v/tcp: no additional reset on closed sockets
Message-id: <20100730170738.GH11298@hmsreliant.think-freely.org>
Patchwork-id: 27263
O-Subject: [RHEL5.6 PATCH] don't send additional reset on closed tcp sockets
	(bz 605259)
Bugzilla: 605259
RH-Acked-by: Jiri Pirko <jpirko@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>

Hey all-
	Backport of upstream commit 565b7b2d2e632b5792879c0c9cccdd9eecd31195.
Prevents tcp sockets that have already moved to TCP_CLOSE state from sending an
additional reset if the remote end closes later.  Fixes bz 605259.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index a64b145..abab66d 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1579,6 +1579,10 @@ void tcp_close(struct sock *sk, long timeout)
 
 	sk_mem_reclaim(sk);
 
+	/* If socket has been already reset (e.g. in tcp_reset()) - kill it. */
+	if (sk->sk_state == TCP_CLOSE)
+		goto adjudge_to_death;
+
 	/* As outlined in draft-ietf-tcpimpl-prob-03.txt, section
 	 * 3.10, we send a RST here because data was lost.  To
 	 * witness the awful effects of the old behavior of always
