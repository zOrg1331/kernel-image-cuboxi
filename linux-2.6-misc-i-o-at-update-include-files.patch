From: John Feeney <jfeeney@redhat.com>
Date: Tue, 21 Apr 2009 19:01:33 -0400
Subject: [misc] I/O AT: update include files
Message-id: 49EE504D.3070801@redhat.com
O-Subject: [RHEL5.4 PATCH 1/8] Update I/O AT: include files
Bugzilla: 436048
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: John W. Linville <linville@redhat.com>

bz436048 Update I/O AT code to upstream

This patch contains the include/* files that need modification.

 asm-i386/cpufeature.h      |    1
 asm-x86_64/cpufeature.h |    1
 linux/dca.h                        |   52 ++++++
 linux/dmaengine.h       |  402
+++++++++++++++++++++++++++++++++++++++++++++---
 linux/pci_ids.h         |   11 +
 5 files changed, 445 insertions(+), 22 deletions(-)

The commits to each file and any modifications are listed below.
include/asm-x86_64/cpufeature.h
 same as upstream
  2ed6dc34f9ed39bb8e4c81ea1056f0ba56315841 Nelson 10/16/07

include/linux/pci_ids.h
  same as upstream
  57c651f74cd8383df10a648e677902849de1bc0b Miller 5/24/06
  223758c77a67b1eb383a92b35d67de29502a9f55 Nelson 10/16/2007
  7bb67c14fd3778504fb77da30ce11582336dfced   Nelson 11/15/07
  7f1b358a236ee9c19657a619ac6f2dcabcaa0924 Sosnowski 7/23/2008

include/linux/dmaengine.h
  significant changes due to kabi issues
   Added #if defined(CONFIG_DMA_ENGINE_V3) in addition to
     defined (CONFIG_DMA_ENGINE)
  Added #ifndef __GENKSYMS__ around linux/dma-mapping.h (kabi)
  Added device_v3 pointer and client_count to dma_chan (kabi)
  Added prototypes for dmaengine_v3 interface functions
    (dma_chan_cleanup_v3(), dma_pin_iovec_pages_v3(),
    dma_unpin_iovec_pages_v3(), dma_async_client_register_v3(),
    dma_async_client_unregister_v3(), dma_async_client_chan_request_v3(),
    dma_async_memcpy_buf_to_buf_v3(), dma_async_memcpy_buf_to_pg_v3(),
    dma_async_memcpy_pg_to_pg_v3(), dma_async_tx_descriptor_init_v3()
    dma_async_device_register_v3() and dma_async_device_unregister_v3()).
  Added dma_memcpy_pg_to_iovec_v3().
  Added dma_async_memcpy_issue_pending_v3() macro.
  Changed dma_chan_put to use dma_chan_cleanup_v3 as argument.
  Had to move dma_client definition down to end of file.
  Could not change base_address in dma_page_list (kabi) so added
     base_address_v3.
  Could not replace dma_event enum with dma_state so kept both and had
     to add "_STATE_" to each DMA_ value to differentiate. (kabi)
  Added struct dma_device_v3.
 In addition to the following commits:
  c13c8260da3155f2cefb63b0d1b7dcdcb405c644 Leech 6/18/06 new file
  de5506e155276d385712c2aa1c2d9a27cd4ed947 Leech 6/18/06
  1c0f16e5cdff59f3b132a1b0c0d44a941f8813d2 Woodhouse 6/28/06
  fe4ada2d6f0b746246e9b5bf0f4f2e4d3a07d26e Dunlop 7/4/06
Up to this point, already in RHEL5.

  7405f74badf46b5d023c5d2b670b4471525f6c91 Williams 1/2/07
  d379b01e9087a582d58f4b678208a4f8d8376fe7 Williams 7/9/07
  0036731c88fdb5bf4f04a796a30b5e445fc57f54 Williams 2/3/08
  d4c56f97ff21df405d0cebe11f49e3c3c79662b5 Williams 2/6/08
  ec8670f1f795badedaa056a3a3245b9b82201747 Williams 3/1/08
  b2ddb9019ea13fb7b62d8e45adcc468376af0de7 Viro 3/30/08
  19242d7233df7d658405d4b7ee1758d21414cfaa Williams 4/17/08
  ce4d65a5db77e1568c82d5151a746f627c4f6ed5 Williams 4/17/08
  636bdeaa1243327501edfd2a597ed7443eb4239a Williams 4/17/08
  8a5703f846e2363fc466aff3f53608340a1ae33f Siewior 4/21/08
  7cc5bf9a3a84e5a02e23e5739fb894790b37c101 Williams 7/8/08
  848c536a37b8db4e461f14ca15fe29850151c822 Skinnemoen 7/8/08
  e1d181efb14a93cf263d6c588a5395518edf3294 Williams 7/4/08
  dc0ee6435cb92ccc81b14ff28d163fecc5a7f120 Skinnemoen 7/8/08
  0839875e0c197ded56bbae820e699f26d6fa2697 Williams 7/18/08

include/linux/dca.h
 same as upstream
  7589670f37736bcc119ebfbd69aafea6d585d1d4 Nelson 10/16/07
  765cdb6cef63c0b41c3f6c9285769080b3f41bb0 Sievers 2/8/08
  7f1b358a236ee9c19657a619ac6f2dcabcaa0924 Sosnowski 7/23/08

include/asm-i386/cpufeature.h
 same as upstream
  2ed6dc34f9ed39bb8e4c81ea1056f0ba56315841 Nelson 10/16/07

diff --git a/include/asm-i386/cpufeature.h b/include/asm-i386/cpufeature.h
index 77809a7..ab09612 100644
--- a/include/asm-i386/cpufeature.h
+++ b/include/asm-i386/cpufeature.h
@@ -86,6 +86,7 @@
 #define X86_FEATURE_CID		(4*32+10) /* Context ID */
 #define X86_FEATURE_CX16        (4*32+13) /* CMPXCHG16B */
 #define X86_FEATURE_XTPR	(4*32+14) /* Send Task Priority Messages */
+#define X86_FEATURE_DCA		(4*32+18) /* Direct Cache Access */
 #define X86_FEATURE_HYPERVISOR	(4*32+31) /* Running on a hypervisor */
 
 /* VIA/Cyrix/Centaur-defined CPU features, CPUID level 0xC0000001, word 5 */
diff --git a/include/asm-x86_64/cpufeature.h b/include/asm-x86_64/cpufeature.h
index 5159224..7eeea4f 100644
--- a/include/asm-x86_64/cpufeature.h
+++ b/include/asm-x86_64/cpufeature.h
@@ -83,6 +83,7 @@
 #define X86_FEATURE_CID		(4*32+10) /* Context ID */
 #define X86_FEATURE_CX16	(4*32+13) /* CMPXCHG16B */
 #define X86_FEATURE_XTPR	(4*32+14) /* Send Task Priority Messages */
+#define X86_FEATURE_DCA		(4*32+18) /* Direct Cache Access */
 #define X86_FEATURE_HYPERVISOR	(4*32+31) /* Running on a hypervisor */
 
 /* VIA/Cyrix/Centaur-defined CPU features, CPUID level 0xC0000001, word 5 */
diff --git a/include/linux/dca.h b/include/linux/dca.h
new file mode 100644
index 0000000..1a1df85
--- /dev/null
+++ b/include/linux/dca.h
@@ -0,0 +1,52 @@
+#ifndef DCA_H
+#define DCA_H
+/* DCA Provider API */
+
+/* DCA Notifier Interface */
+void dca_register_notify(struct notifier_block *nb);
+void dca_unregister_notify(struct notifier_block *nb);
+
+#define DCA_PROVIDER_ADD	0x0001
+#define DCA_PROVIDER_REMOVE	0x0002
+
+struct dca_provider {
+	struct list_head	node;
+	struct dca_ops		*ops;
+	struct device		*cd;
+	int			 id;
+};
+
+struct dca_ops {
+	int	(*add_requester)	(struct dca_provider *, struct device *);
+	int	(*remove_requester)	(struct dca_provider *, struct device *);
+	u8	(*get_tag)		(struct dca_provider *, struct device *,
+					 int cpu);
+	int	(*dev_managed)		(struct dca_provider *, struct device *);
+};
+
+struct dca_provider *alloc_dca_provider(struct dca_ops *ops, int priv_size);
+void free_dca_provider(struct dca_provider *dca);
+int register_dca_provider(struct dca_provider *dca, struct device *dev);
+void unregister_dca_provider(struct dca_provider *dca);
+
+static inline void *dca_priv(struct dca_provider *dca)
+{
+	return (void *)dca + sizeof(struct dca_provider);
+}
+
+/* Requester API */
+#define DCA_GET_TAG_TWO_ARGS
+int dca_add_requester(struct device *dev);
+int dca_remove_requester(struct device *dev);
+u8 dca_get_tag(int cpu);
+u8 dca3_get_tag(struct device *dev, int cpu);
+
+/* internal stuff */
+int __init dca_sysfs_init(void);
+void __exit dca_sysfs_exit(void);
+int dca_sysfs_add_provider(struct dca_provider *dca, struct device *dev);
+void dca_sysfs_remove_provider(struct dca_provider *dca);
+int dca_sysfs_add_req(struct dca_provider *dca, struct device *dev, int slot);
+void dca_sysfs_remove_req(struct dca_provider *dca, int slot);
+
+#endif /* DCA_H */
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index c94d8f1..21a17e6 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -21,13 +21,16 @@
 #ifndef DMAENGINE_H
 #define DMAENGINE_H
 
-#ifdef CONFIG_DMA_ENGINE
+#if defined(CONFIG_DMA_ENGINE_V3) || defined(CONFIG_DMA_ENGINE)
 
 #include <linux/device.h>
 #include <linux/uio.h>
 #include <linux/kref.h>
 #include <linux/completion.h>
 #include <linux/rcupdate.h>
+#ifndef __GENKSYMS__
+#include <linux/dma-mapping.h>
+#endif
 
 /**
  * enum dma_event - resource PNP/power managment events
@@ -91,6 +94,8 @@ struct dma_chan_percpu {
  * @client_node: used to add this to the client chan list
  * @device_node: used to add this to the device chan list
  * @local: per-cpu pointer to a struct dma_chan_percpu
+ * @device_v3: pointer to dma_device version 3 structure
+ * @client_count: how many clients are using this channel
  */
 struct dma_chan {
 	struct dma_client *client;
@@ -108,8 +113,14 @@ struct dma_chan {
 	struct list_head client_node;
 	struct list_head device_node;
 	struct dma_chan_percpu *local;
+
+#ifndef __GENKSYMS__
+	struct dma_device_v3 *device_v3;
+	int client_count;
+#endif
 };
 
+void dma_chan_cleanup_v3(struct kref *kref);
 void dma_chan_cleanup(struct kref *kref);
 
 static inline void dma_chan_get(struct dma_chan *chan)
@@ -125,7 +136,7 @@ static inline void dma_chan_get(struct dma_chan *chan)
 static inline void dma_chan_put(struct dma_chan *chan)
 {
 	if (unlikely(chan->slow_ref))
-		kref_put(&chan->refcount, dma_chan_cleanup);
+		kref_put(&chan->refcount, dma_chan_cleanup_v3);
 	else {
 		local_dec(&(per_cpu_ptr(chan->local, get_cpu())->refcount));
 		put_cpu();
@@ -139,25 +150,6 @@ typedef void (*dma_event_callback) (struct dma_client *client,
 		struct dma_chan *chan, enum dma_event event);
 
 /**
- * struct dma_client - info on the entity making use of DMA services
- * @event_callback: func ptr to call when something happens
- * @chan_count: number of chans allocated
- * @chans_desired: number of chans requested. Can be +/- chan_count
- * @lock: protects access to the channels list
- * @channels: the list of DMA channels allocated
- * @global_node: list_head for global dma_client_list
- */
-struct dma_client {
-	dma_event_callback	event_callback;
-	unsigned int		chan_count;
-	unsigned int		chans_desired;
-
-	spinlock_t		lock;
-	struct list_head	channels;
-	struct list_head	global_node;
-};
-
-/**
  * struct dma_device - info on the entity supplying DMA services
  * @chancnt: how many DMA channels are supported
  * @channels: the list of struct dma_chan
@@ -319,7 +311,7 @@ static inline enum dma_status dma_async_memcpy_complete(struct dma_chan *chan,
  * @last_used: last cookie value handed out
  *
  * dma_async_is_complete() is used in dma_async_memcpy_complete()
- * the test logic is seperated for lightweight testing of multiple cookies
+ * the test logic is separated for lightweight testing of multiple cookies
  */
 static inline enum dma_status dma_async_is_complete(dma_cookie_t cookie,
 			dma_cookie_t last_complete, dma_cookie_t last_used)
@@ -346,6 +338,9 @@ struct dma_page_list {
 	char *base_address;
 	int nr_pages;
 	struct page **pages;
+#ifndef __GENKSYMS__
+	char __user *base_address_v3;
+#endif
 };
 
 struct dma_pinned_list {
@@ -354,7 +349,9 @@ struct dma_pinned_list {
 };
 
 struct dma_pinned_list *dma_pin_iovec_pages(struct iovec *iov, size_t len);
+struct dma_pinned_list *dma_pin_iovec_pages_v3(struct iovec *iov, size_t len);
 void dma_unpin_iovec_pages(struct dma_pinned_list* pinned_list);
+void dma_unpin_iovec_pages_v3(struct dma_pinned_list* pinned_list);
 
 dma_cookie_t dma_memcpy_to_iovec(struct dma_chan *chan, struct iovec *iov,
 	struct dma_pinned_list *pinned_list, unsigned char *kdata, size_t len);
@@ -362,5 +359,366 @@ dma_cookie_t dma_memcpy_pg_to_iovec(struct dma_chan *chan, struct iovec *iov,
 	struct dma_pinned_list *pinned_list, struct page *page,
 	unsigned int offset, size_t len);
 
+dma_cookie_t dma_memcpy_to_iovec_v3(struct dma_chan *chan, struct iovec *iov,
+	struct dma_pinned_list *pinned_list, unsigned char *kdata, size_t len);
+dma_cookie_t dma_memcpy_pg_to_iovec_v3(struct dma_chan *chan, struct iovec *iov,
+	struct dma_pinned_list *pinned_list, struct page *page,
+	unsigned int offset, size_t len);
+
+/**
+ * enum dma_state - resource PNP/power management state
+ * @DMA_STATE_RESOURCE_SUSPEND: DMA device going into low power state
+ * @DMA_STATE_RESOURCE_RESUME: DMA device returning to full power
+ * @DMA_STATE_RESOURCE_AVAILABLE: DMA device available to the system
+ * @DMA_STATE_RESOURCE_REMOVED: DMA device removed from the system
+ */
+enum dma_state {
+	DMA_STATE_RESOURCE_SUSPEND,
+	DMA_STATE_RESOURCE_RESUME,
+	DMA_STATE_RESOURCE_AVAILABLE,
+	DMA_STATE_RESOURCE_REMOVED,
+};
+
+/**
+ * enum dma_state_client - state of the channel in the client
+ * @DMA_ACK: client would like to use, or was using this channel
+ * @DMA_DUP: client has already seen this channel, or is not using this channel
+ * @DMA_NAK: client does not want to see any more channels
+ */
+enum dma_state_client {
+	DMA_ACK,
+	DMA_DUP,
+	DMA_NAK,
+};
+
+#define dma_submit_error(cookie) ((cookie) < 0 ? 1 : 0)
+
+/**
+ * enum dma_transaction_type - DMA transaction types/indexes
+ */
+enum dma_transaction_type {
+	DMA_MEMCPY,
+	DMA_XOR,
+	DMA_PQ_XOR,
+	DMA_DUAL_XOR,
+	DMA_PQ_UPDATE,
+	DMA_ZERO_SUM,
+	DMA_PQ_ZERO_SUM,
+	DMA_MEMSET,
+	DMA_MEMCPY_CRC32C,
+	DMA_INTERRUPT,
+	DMA_SLAVE,
+};
+
+/* last transaction type for creation of the capabilities mask */
+#define DMA_TX_TYPE_END (DMA_SLAVE + 1)
+
+/**
+ * enum dma_slave_width - DMA slave register access width.
+ * @DMA_SLAVE_WIDTH_8BIT: Do 8-bit slave register accesses
+ * @DMA_SLAVE_WIDTH_16BIT: Do 16-bit slave register accesses
+ * @DMA_SLAVE_WIDTH_32BIT: Do 32-bit slave register accesses
+ */
+enum dma_slave_width {
+	DMA_SLAVE_WIDTH_8BIT,
+	DMA_SLAVE_WIDTH_16BIT,
+	DMA_SLAVE_WIDTH_32BIT,
+};
+
+/**
+ * enum dma_ctrl_flags - DMA flags to augment operation preparation,
+ *      control completion, and communicate status.
+ * @DMA_PREP_INTERRUPT - trigger an interrupt (callback) upon completion of
+ *      this transaction
+ * @DMA_CTRL_ACK - the descriptor cannot be reused until the client
+ *      acknowledges receipt, i.e. has has a chance to establish any
+ *      dependency chains
+ * @DMA_COMPL_SKIP_SRC_UNMAP - set to disable dma-unmapping the source buffer(s)
+ * @DMA_COMPL_SKIP_DEST_UNMAP - set to disable dma-unmapping the destination(s)
+ */
+enum dma_ctrl_flags {
+	DMA_PREP_INTERRUPT = (1 << 0),
+	DMA_CTRL_ACK = (1 << 1),
+	DMA_COMPL_SKIP_SRC_UNMAP = (1 << 2),
+	DMA_COMPL_SKIP_DEST_UNMAP = (1 << 3),
+};
+
+/**
+ * dma_cap_mask_t - capabilities bitmap modeled after cpumask_t.
+ * See linux/cpumask.h
+ */
+typedef struct { DECLARE_BITMAP(bits, DMA_TX_TYPE_END); } dma_cap_mask_t;
+
+/**
+ * struct dma_slave - Information about a DMA slave
+ * @dev: device acting as DMA slave
+ * @dma_dev: required DMA master device. If non-NULL, the client can not be
+ *      bound to other masters than this.
+ * @tx_reg: physical address of data register used for
+ *      memory-to-peripheral transfers
+ * @rx_reg: physical address of data register used for
+ *      peripheral-to-memory transfers
+ * @reg_width: peripheral register width
+ *
+ * If dma_dev is non-NULL, the client can not be bound to other DMA
+ * masters than the one corresponding to this device. The DMA master
+ * driver may use this to determine if there is controller-specific
+ * data wrapped around this struct. Drivers of platform code that sets
+ * the dma_dev field must therefore make sure to use an appropriate
+ * controller-specific dma slave structure wrapping this struct.
+ */
+struct dma_slave {
+	struct device		*dev;
+	struct device		*dma_dev;
+	dma_addr_t		tx_reg;
+	dma_addr_t		rx_reg;
+	enum dma_slave_width	reg_width;
+};
+
+/*
+ * typedef dma_event_callback_v3 - function pointer to a DMA event callback
+ * For each channel added to the system this routine is called for each client.
+ * If the client would like to use the channel it returns '1' to signal (ack)
+ * the dmaengine core to take out a reference on the channel and its
+ * corresponding device.  A client must not 'ack' an available channel more
+ * than once.  When a channel is removed all clients are notified.  If a client
+ * is using the channel it must 'ack' the removal.  A client must not 'ack' a
+ * removed channel more than once.
+ * @client - 'this' pointer for the client context
+ * @chan - channel to be acted upon
+ * @state - available or removed
+ */
+typedef enum dma_state_client (*dma_event_callback_v3)
+			       (struct dma_client *client,
+			       struct dma_chan *chan, enum dma_state state);
+
+typedef void (*dma_async_tx_callback)(void *dma_async_param);
+
+/**
+ * struct dma_async_tx_descriptor - async transaction descriptor
+ * ---dma generic offload fields---
+ * @cookie: tracking cookie for this transaction, set to -EBUSY if
+ *      this tx is sitting on a dependency list
+ * @flags: flags to augment operation preparation, control completion, and
+ *      communicate status
+ * @phys: physical address of the descriptor
+ * @tx_list: driver common field for operations that require multiple
+ *      descriptors
+ * @chan: target channel for this operation
+ * @tx_submit: set the prepared descriptor(s) to be executed by the engine
+ * @callback: routine to call after this operation is complete
+ * @callback_param: general parameter to pass to the callback routine
+ * ---async_tx api specific fields---
+ * @next: at completion submit this descriptor
+ * @parent: pointer to the next level up in the dependency chain
+ * @lock: protect the parent and next pointers
+ */
+struct dma_async_tx_descriptor {
+	dma_cookie_t cookie;
+	enum dma_ctrl_flags flags; /* not a 'long' to pack with cookie */
+	dma_addr_t phys;
+	struct list_head tx_list;
+	struct dma_chan *chan;
+	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *tx);
+	dma_async_tx_callback callback;
+	void *callback_param;
+	struct dma_async_tx_descriptor *next;
+	struct dma_async_tx_descriptor *parent;
+	spinlock_t lock;
+};
+
+/**
+ * struct dma_device_v3 - info on the entity supplying DMA services
+ * @chancnt: how many DMA channels are supported
+ * @channels: the list of struct dma_chan
+ * @global_node: list_head for global dma_device_list
+ * @cap_mask: one or more dma_capability flags
+ * @max_xor: maximum number of xor sources, 0 if no capability
+ * @refcount: reference count
+ * @done: IO completion struct
+ * @dev_id: unique device ID
+ * @dev: struct device reference for dma mapping api
+ * @device_alloc_chan_resources: allocate resources and return the
+ *      number of allocated descriptors
+ * @device_free_chan_resources: release DMA channel's resources
+ * @device_prep_dma_memcpy: prepares a memcpy operation
+ * @device_prep_dma_xor: prepares a xor operation
+ * @device_prep_dma_zero_sum: prepares a zero_sum operation
+ * @device_prep_dma_memset: prepares a memset operation
+ * @device_prep_dma_interrupt: prepares an end of chain interrupt operation
+ * @device_prep_slave_sg: prepares a slave dma operation
+ * @device_terminate_all: terminate all pending operations
+ * @device_issue_pending: push pending transactions to hardware
+ */
+struct dma_device_v3 {
+	unsigned int chancnt;
+	struct list_head channels;
+	struct list_head global_node;
+	dma_cap_mask_t  cap_mask;
+	int max_xor;
+
+	struct kref refcount;
+	struct completion done;
+
+	int dev_id;
+	struct device *dev;
+
+	int (*device_alloc_chan_resources)(struct dma_chan *chan,
+		struct dma_client *client);
+	void (*device_free_chan_resources)(struct dma_chan *chan);
+
+	struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
+		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+		size_t len, unsigned long flags);
+	struct dma_async_tx_descriptor *(*device_prep_dma_xor)(
+		struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
+		unsigned int src_cnt, size_t len, unsigned long flags);
+	struct dma_async_tx_descriptor *(*device_prep_dma_zero_sum)(
+		struct dma_chan *chan, dma_addr_t *src, unsigned int src_cnt,
+		size_t len, u32 *result, unsigned long flags);
+	struct dma_async_tx_descriptor *(*device_prep_dma_memset)(
+		struct dma_chan *chan, dma_addr_t dest, int value, size_t len,
+		unsigned long flags);
+	struct dma_async_tx_descriptor *(*device_prep_dma_interrupt)(
+		struct dma_chan *chan, unsigned long flags);
+
+	struct dma_async_tx_descriptor *(*device_prep_slave_sg)(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_data_direction direction,
+		unsigned long flags);
+	void (*device_terminate_all)(struct dma_chan *chan);
+
+	enum dma_status (*device_is_tx_complete)(struct dma_chan *chan,
+		dma_cookie_t cookie, dma_cookie_t *last,
+		dma_cookie_t *used);
+	void (*device_issue_pending)(struct dma_chan *chan);
+};
+
+/* --- public DMA engine API --- */
+
+void dma_async_client_register_v3(struct dma_client *client);
+void dma_async_client_unregister_v3(struct dma_client *client);
+void dma_async_client_chan_request_v3(struct dma_client *client);
+dma_cookie_t dma_async_memcpy_buf_to_buf_v3(struct dma_chan *chan,
+	void *dest, void *src, size_t len);
+dma_cookie_t dma_async_memcpy_buf_to_pg_v3(struct dma_chan *chan,
+	struct page *page, unsigned int offset, void *kdata, size_t len);
+dma_cookie_t dma_async_memcpy_pg_to_pg_v3(struct dma_chan *chan,
+	struct page *dest_pg, unsigned int dest_off, struct page *src_pg,
+	unsigned int src_off, size_t len);
+void dma_async_tx_descriptor_init_v3(struct dma_async_tx_descriptor *tx,
+	struct dma_chan *chan);
+
+static inline void async_tx_ack(struct dma_async_tx_descriptor *tx)
+{
+	tx->flags |= DMA_CTRL_ACK;
+}
+
+static inline bool async_tx_test_ack(struct dma_async_tx_descriptor *tx)
+{
+	return (tx->flags & DMA_CTRL_ACK) == DMA_CTRL_ACK;
+}
+
+#define first_dma_cap(mask) __first_dma_cap(&(mask))
+static inline int __first_dma_cap(const dma_cap_mask_t *srcp)
+{
+	return min_t(int, DMA_TX_TYPE_END,
+		     find_first_bit(srcp->bits, DMA_TX_TYPE_END));
+}
+
+#define next_dma_cap(n, mask) __next_dma_cap((n), &(mask))
+static inline int __next_dma_cap(int n, const dma_cap_mask_t *srcp)
+{
+	return min_t(int, DMA_TX_TYPE_END,
+		     find_next_bit(srcp->bits, DMA_TX_TYPE_END, n+1));
+}
+
+#define dma_cap_set(tx, mask) __dma_cap_set((tx), &(mask))
+static inline void
+__dma_cap_set(enum dma_transaction_type tx_type, dma_cap_mask_t *dstp)
+{
+	set_bit(tx_type, dstp->bits);
+}
+
+#define dma_has_cap(tx, mask) __dma_has_cap((tx), &(mask))
+static inline int
+__dma_has_cap(enum dma_transaction_type tx_type, dma_cap_mask_t *srcp)
+{
+	return test_bit(tx_type, srcp->bits);
+}
+
+#define for_each_dma_cap_mask(cap, mask) \
+		for ((cap) = first_dma_cap(mask); \
+			(cap) < DMA_TX_TYPE_END; \
+			(cap) = next_dma_cap((cap), (mask)))
+
+/**
+ * dma_async_issue_pending - flush pending transactions to HW
+ * @chan: target DMA channel
+ *
+ * This allows drivers to push copies to HW in batches,
+ * reducing MMIO writes where possible.
+ */
+static inline void dma_async_issue_pending(struct dma_chan *chan)
+{
+	chan->device_v3->device_issue_pending(chan);
+}
+
+#define dma_async_memcpy_issue_pending_v3(chan) dma_async_issue_pending(chan)
+
+/**
+ * dma_async_is_tx_complete - poll for transaction completion
+ * @chan: DMA channel
+ * @cookie: transaction identifier to check status of
+ * @last: returns last completed cookie, can be NULL
+ * @used: returns last issued cookie, can be NULL
+ *
+ * If @last and @used are passed in, upon return they reflect the driver
+ * internal state and can be used with dma_async_is_complete() to check
+ * the status of multiple cookies without re-checking hardware state.
+ */
+static inline enum dma_status dma_async_is_tx_complete(struct dma_chan *chan,
+	dma_cookie_t cookie, dma_cookie_t *last, dma_cookie_t *used)
+{
+	return chan->device_v3->device_is_tx_complete(chan, cookie, last, used);
+}
+
+#define dma_async_memcpy_complete_v3(chan, cookie, last, used)\
+	dma_async_is_tx_complete(chan, cookie, last, used)
+
+/* --- DMA device --- */
+
+int dma_async_device_register_v3(struct dma_device_v3 *device);
+void dma_async_device_unregister_v3(struct dma_device_v3 *device);
+
+/**
+ * struct dma_client - info on the entity making use of DMA services
+ * @event_callback: func ptr to call when something happens
+ * @chan_count: number of chans allocated
+ * @chans_desired: number of chans requested. Can be +/- chan_count
+ * @lock: protects access to the channels list
+ * @channels: the list of DMA channels allocated
+ * @global_node: list_head for global dma_client_list
+ * @event_callback_v3: func ptr to call when something happens
+ * @cap_mask: only return channels that satisfy the requested capabilities
+ *  a value of zero corresponds to any capability
+ * @slave: data for preparing slave transfer. Must be non-NULL iff the
+ *  DMA_SLAVE capability is requested.
+ */
+struct dma_client {
+	dma_event_callback	event_callback;
+	unsigned int		chan_count;
+	unsigned int		chans_desired;
+
+	spinlock_t		lock;
+	struct list_head	channels;
+	struct list_head	global_node;
+#ifndef __GENKSYMS__
+	dma_event_callback_v3	event_callback_v3;
+	dma_cap_mask_t		cap_mask;
+	struct dma_slave	*slave;
+#endif
+};
+
 #endif /* CONFIG_DMA_ENGINE */
 #endif /* DMAENGINE_H */
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index e749e2d..98cf867 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2290,6 +2290,17 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_5	0x2915
 #define PCI_DEVICE_ID_INTEL_ICH9_6	0x2930
 #define PCI_DEVICE_ID_INTEL_82855PM_HB	0x3340
+#define PCI_DEVICE_ID_INTEL_IOAT_SNB	0x402f
+#define PCI_DEVICE_ID_INTEL_IOAT_CNB	0x360b
+#define PCI_DEVICE_ID_INTEL_IOAT_SCNB	0x65ff
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG4	0x3429
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG5	0x342a
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG6	0x342b
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG7	0x342c
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG0	0x3430
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG1	0x3431
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG2	0x3432
+#define PCI_DEVICE_ID_INTEL_IOAT_TBG3	0x3433
 #define PCI_DEVICE_ID_INTEL_82830_HB	0x3575
 #define PCI_DEVICE_ID_INTEL_82830_CGC	0x3577
 #define PCI_DEVICE_ID_INTEL_82855GM_HB	0x3580
