From: Don Dutile <ddutile@redhat.com>
Date: Wed, 1 Sep 2010 21:39:06 -0400
Subject: [pci] clean up resource alignment management
Message-id: <4C7EC7FA.6010402@redhat.com>
Patchwork-id: 28002
O-Subject: Re: [RHEL5.6 PATCH 2/3] PCI: clean up resource alignment management
Bugzilla: 523341
RH-Acked-by: Michal Schmidt <mschmidt@redhat.com>
RH-Acked-by: Chris Wright <chrisw@redhat.com>

Backport of following upstream commit ids:

884525655d07fdee9245716b998ecdc45cdd8007
-- resource alignment fixes per Linus recommendations

934b7024f0ed29003c95cef447d92737ab86dc4f
-- fixes Carbus resource allocation

5f17cfce5776c566d64430f543a289e5cfa4538b
-- fix pbus_size_mem() resource alignment for CardBus controllers

See 0/3 for bz, brew build & testing done.

Please review and ack.

- Don

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c61bbff..25d8764 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -209,7 +209,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 	if (type == pci_bar_unknown) {
 		type = decode_bar(res, l);
-		res->flags |= pci_calc_resource_flags(l);
+		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
 		if (type == pci_bar_io) {
 			l &= PCI_BASE_ADDRESS_IO_MASK;
 			mask = PCI_BASE_ADDRESS_IO_MASK & 0xffff;
@@ -285,7 +285,8 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 		struct resource *res = &dev->resource[PCI_ROM_RESOURCE];
 		dev->rom_base_reg = rom;
 		res->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |
-				IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
+				IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
+				IORESOURCE_SIZEALIGN;
 		__pci_read_base(dev, pci_bar_mem32, res, rom);
 	}
 }
diff --git a/drivers/pci/setup-bus.c b/drivers/pci/setup-bus.c
index b525c6a..e1bd909 100644
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@ -340,6 +340,7 @@ pbus_size_io(struct pci_bus *bus)
 	/* Alignment of the IO window is always 4K */
 	b_res->start = 4096;
 	b_res->end = b_res->start + size - 1;
+	b_res->flags |= IORESOURCE_STARTALIGN;
 }
 
 /* Calculate the size of the bus and minimal alignment which
@@ -371,12 +372,13 @@ pbus_size_mem(struct pci_bus *bus, unsigned long mask, unsigned long type)
 				continue;
 			r_size = r->end - r->start + 1;
 			/* For bridges size != alignment */
-			align = (i < PCI_BRIDGE_RESOURCES) ? r_size : r->start;
+			align = resource_alignment(r);
 			order = __ffs(align) - 20;
 			if (order > 11) {
 				printk(KERN_WARNING "PCI: region %s/%d "
-				       "too large: %016llx-%016llx\n",
+				       "bad alignment %llx: %016llx-%016llx\n",
 					pci_name(dev), i,
+				       (unsigned long long)align,
 				       (unsigned long long)r->start,
 				       (unsigned long long)r->end);
 				r->flags = 0;
@@ -415,6 +417,7 @@ pbus_size_mem(struct pci_bus *bus, unsigned long mask, unsigned long type)
 	}
 	b_res->start = min_align;
 	b_res->end = size + min_align - 1;
+	b_res->flags |= IORESOURCE_STARTALIGN;
 	return 1;
 }
 
@@ -429,13 +432,13 @@ pci_bus_size_cardbus(struct pci_bus *bus)
 	 * Reserve some resources for CardBus.  We reserve
 	 * a fixed amount of bus space for CardBus bridges.
 	 */
-	b_res[0].start = CARDBUS_IO_SIZE;
-	b_res[0].end = b_res[0].start + CARDBUS_IO_SIZE - 1;
-	b_res[0].flags |= IORESOURCE_IO;
+	b_res[0].start = 0;
+	b_res[0].end = CARDBUS_IO_SIZE - 1;
+	b_res[0].flags |= IORESOURCE_IO | IORESOURCE_SIZEALIGN;
 
-	b_res[1].start = CARDBUS_IO_SIZE;
-	b_res[1].end = b_res[1].start + CARDBUS_IO_SIZE - 1;
-	b_res[1].flags |= IORESOURCE_IO;
+	b_res[1].start = 0;
+	b_res[1].end = CARDBUS_IO_SIZE - 1;
+	b_res[1].flags |= IORESOURCE_IO | IORESOURCE_SIZEALIGN;
 
 	/*
 	 * Check whether prefetchable memory is supported
@@ -454,17 +457,17 @@ pci_bus_size_cardbus(struct pci_bus *bus)
 	 * twice the size.
 	 */
 	if (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0) {
-		b_res[2].start = CARDBUS_MEM_SIZE;
-		b_res[2].end = b_res[2].start + CARDBUS_MEM_SIZE - 1;
-		b_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;
+		b_res[2].start = 0;
+		b_res[2].end = CARDBUS_MEM_SIZE - 1;
+		b_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH  | IORESOURCE_SIZEALIGN;
 
-		b_res[3].start = CARDBUS_MEM_SIZE;
-		b_res[3].end = b_res[3].start + CARDBUS_MEM_SIZE - 1;
-		b_res[3].flags |= IORESOURCE_MEM;
+		b_res[3].start = 0;
+		b_res[3].end = CARDBUS_MEM_SIZE - 1;
+		b_res[3].flags |= IORESOURCE_MEM  | IORESOURCE_SIZEALIGN;
 	} else {
-		b_res[3].start = CARDBUS_MEM_SIZE * 2;
-		b_res[3].end = b_res[3].start + CARDBUS_MEM_SIZE * 2 - 1;
-		b_res[3].flags |= IORESOURCE_MEM;
+		b_res[3].start = 0;
+		b_res[3].end = CARDBUS_MEM_SIZE * 2 - 1;
+		b_res[3].flags |= IORESOURCE_MEM  | IORESOURCE_SIZEALIGN;
 	}
 }
 
diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index 013637e..1f3dadc 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -139,11 +139,16 @@ int pci_assign_resource(struct pci_dev *dev, int resno)
 
 	size = res->end - res->start + 1;
 	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
-	/* The bridge resources are special, as their
-	   size != alignment. Sizing routines return
-	   required alignment in the "start" field. */
-	align = (resno < PCI_BRIDGE_RESOURCES ||
-		 resno > PCI_NUM_RESOURCES) ? size : res->start;
+
+	align = resource_alignment(res);
+	if (!align) {
+		printk(KERN_ERR "PCI: Cannot allocate resource (bogus "
+			"alignment) %d [%llx:%llx] (flags %lx) of %s\n",
+			resno, (unsigned long long)res->start,
+			(unsigned long long)res->end, res->flags,
+			pci_name(dev));
+		return -EINVAL;
+	}
 
 	/* First, try exact prefetching match.. */
 	ret = pci_bus_alloc_resource(bus, res, size, align, min,
@@ -212,8 +217,10 @@ int pci_assign_resource_fixed(struct pci_dev *dev, int resno)
 			res->flags & IORESOURCE_IO ? "I/O" : "mem",
 			resno, (unsigned long long)(res->end - res->start + 1),
 			(unsigned long long)res->start, pci_name(dev));
-	} else if (resno < PCI_BRIDGE_RESOURCES) {
-		pci_update_resource(dev, res, resno);
+	} else {
+		res->flags &= ~IORESOURCE_STARTALIGN;
+		if (resno < PCI_BRIDGE_RESOURCES)
+			pci_update_resource(dev, res, resno);
 	}
 
 	return ret;
@@ -241,35 +248,26 @@ pdev_sort_resources(struct pci_dev *dev, struct resource_list *head)
 				continue;
 			r = &dev->sriov->res[i - PCI_IOV_RESOURCES];
 		}
-		r_align = r->end - r->start;
 		
 		if (!(r->flags) || r->parent)
 			continue;
+
+		r_align = resource_alignment(r);
 		if (!r_align) {
-			printk(KERN_WARNING "PCI: Ignore bogus resource %d "
-				"[%llx:%llx] of %s\n",
+			printk(KERN_WARNING "PCI: bogus alignment of resource "
+				"%d [%llx:%llx] (flags %lx) of %s\n",
 				i, (unsigned long long)r->start,
-				(unsigned long long)r->end, pci_name(dev));
+				(unsigned long long)r->end, r->flags,
+				pci_name(dev));
 			continue;
 		}
-		r_align = (i < PCI_BRIDGE_RESOURCES ||
-			   i > PCI_NUM_RESOURCES) ? r_align + 1 : r->start;
 		for (list = head; ; list = list->next) {
 			resource_size_t align = 0;
 			struct resource_list *ln = list->next;
-			unsigned long idx;
-
-			if (ln) {
-				idx = ln->res - &ln->dev->resource[0];
-				if (idx > PCI_NUM_RESOURCES) {
-					idx = ln->res - &ln->dev->sriov->res[0];
-					idx += PCI_IOV_RESOURCES;
-				}
-				align = (idx < PCI_BRIDGE_RESOURCES ||
-					 idx > PCI_NUM_RESOURCES) ?
-					ln->res->end - ln->res->start + 1 :
-					ln->res->start;
-			}
+
+			if (ln)
+				align = resource_alignment(ln->res);
+
 			if (r_align > align) {
 				tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
 				if (!tmp)
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index 7009c85..83a4f2c 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -43,7 +43,9 @@ struct resource_list {
 #define IORESOURCE_CACHEABLE	0x00004000
 #define IORESOURCE_RANGELENGTH	0x00008000
 #define IORESOURCE_SHADOWABLE	0x00010000
-#define IORESOURCE_BUS_HAS_VGA	0x00080000
+
+#define IORESOURCE_SIZEALIGN	0x00020000	/* size indicates alignment */
+#define IORESOURCE_STARTALIGN	0x00040000	/* start field is alignment */
 
 #define IORESOURCE_DISABLED	0x10000000
 #define IORESOURCE_UNSET	0x20000000
@@ -107,6 +109,7 @@ extern int allocate_resource(struct resource *root, struct resource *new,
 			     void *alignf_data);
 int adjust_resource(struct resource *res, resource_size_t start,
 		    resource_size_t size);
+resource_size_t resource_alignment(struct resource *res);
 
 /* get registered SYSTEM_RAM resources in specified area */
 extern int find_next_system_ram(struct resource *res);
diff --git a/kernel/resource.c b/kernel/resource.c
index 4628643..eb422f4 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -450,6 +450,24 @@ int adjust_resource(struct resource *res, resource_size_t start, resource_size_t
 
 EXPORT_SYMBOL(adjust_resource);
 
+/**
+ * resource_alignment - calculate resource's alignment
+ * @res: resource pointer
+ *
+ * Returns alignment on success, 0 (invalid alignment) on failure.
+ */
+resource_size_t resource_alignment(struct resource *res)
+{
+	switch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {
+	case IORESOURCE_SIZEALIGN:
+		return res->end - res->start + 1;
+	case IORESOURCE_STARTALIGN:
+		return res->start;
+	default:
+		return 0;
+	}
+}
+
 /*
  * This is compatibility stuff for IO resources.
  *
