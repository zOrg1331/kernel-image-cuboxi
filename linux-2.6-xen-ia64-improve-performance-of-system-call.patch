From: Kei Tokunaga <ktokunag@redhat.com>
Subject: [RHEL5.1 PATCH 11/21] performance up patch series for ia64 system  call of xen
Date: Thu, 07 Jun 2007 03:41:23 -0400
Bugzilla: 223910
Message-Id: <4667B6A3.1010400@redhat.com>
Changelog: [xen] ia64: improve performance of system call


bz223910
https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=223910

Backport of cset#13477, 13448, 13459, 13475, 13476, 13478,
13480, 13488, 13486, and 14804.

This is to improve syscall performance.  The throughput of
syscall in unixbench has been lifted more than 2 times totally.
The details are below:

        C/S of ia64-unstable    syscall (lps)
----------------------------------------------------
        cs?????                  95691.4
        cs????? + (p1-2)        110680.4
        cs13111 + (p3)          132783.4
        cs13111 + (p3-4)        168623.8
        cs13364                 163274.5
        cs13364 + (p5-10)       170991.6
        cs13364 + (p5-11)       171355.7
        cs13364 + (p5-12)       214037.5
        cs13364 + (p5-13)       216131.5

The benchmark was run on a machine who has four-core (1.4GHz) and 4GB
RAM.  The guest had 1 vCPU and 1GB vRAM.  Unfortunately, I forgot the
C/S number about the first two measurements but it was not too old.
The parenthesis encloses patch numbers (see below).  It is natural
that more realistic workload such as SPECjbb did not achieve a
significant improvement because system call dominated only a part of
such workload.

Series of patches:
p1/  [IA64] vcpu_get_psr fix
p2/  [IA64] remove the requirement (vpsr.ic==0) from hyperprivop
p3/  [IA64] Enable fast hyperprivop for ssm.i and rfi
p4/  [IA64] Use rum psr.be instead of XEN_HYPER_RSM_BE

p5/ [Xen-ia64-devel]PATCH 1/3]Can't inject event, when guest is executing rfi

p6/  [Xen-ia64-devel][PATCH 2/3] merge increment_iip
p7/  [Xen-ia64-devel][PATCH 3/3]provide hypercall the same path with syscall

p8/ RE: [Xen-ia64-devel][PATCH 3/3]provide hypercall the same path with syscall p9/ RE: [Xen-ia64-devel][PATCH
3/3]provide hypercall the same path with syscall p10/ RE: [Xen-ia64-devel][PATCH 3/3]provide hypercall the same path
with syscall

p11/ [Xen-ia64-devel][PATCH] Simplify lazy cover algorithm
p12/ [Xen-ia64-devel][PATCH] Implement hyper_get_psr
p13/ [Xen-ia64-devel]PATCH] Remove duplicate check is_running_on_xen

Thanks,
Kei


# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1168631780 25200
# Node ID c1b98df7386d25e5223ffcb0f173b45b17c49fed
# Parent  cd6598396086157a9eeb2f368462ddeb6e8f8201
[IA64] Fix xencomm_arch_hypercall_suspend

This hypercall is changed to new hypercall mechanism

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xensetup.S |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff -puN arch/ia64/xen/xensetup.S~13477-IA64_Fix_xencomm_arch_hypercall_suspend arch/ia64/xen/xensetup.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xensetup.S~13477-IA64_Fix_xencomm_arch_hypercall_suspend	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xensetup.S	2007-06-07 02:44:30.000000000 -0400
@@ -37,14 +37,14 @@ END(early_xen_setup)
 /* Stub for suspend.
    Just force the stacked registers to be written in memory.  */	
 GLOBAL_ENTRY(xencomm_arch_hypercall_suspend)
-	mov r15=r32
 	;; 
-	alloc r20=ar.pfs,0,0,0,0
+	alloc r20=ar.pfs,0,0,2,0
 	mov r2=__HYPERVISOR_sched_op
 	;; 
 	/* We don't want to deal with RSE.  */
 	flushrs
-	mov r14=2 // SCHEDOP_shutdown
+	mov r33=r32
+	mov r32=2 // SCHEDOP_shutdown
 	;;
 	break 0x1000
 	;; 

_


rh bug 223910

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1167780470 25200
# Node ID 99ff540b0efefad4c2402b9f93a59c2d597d824c
# Parent  a50fd1fed61ecb4909899010c0f44ac90d75f7aa
[IA64] remove the requirement (vpsr.ic==0) from hyperprivop

remove the requirement (vpsr.ic==0) from hyperprivop

There two reasons for this.
1. make xen-parse code more readable.
2. a little bit performance improvement

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/gate.S           |   24 --
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/gate.lds.S       |    8 
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/patch.c          |    4 
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S         |  103 ----------
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenentry.S          |   27 +-
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenivt.S            |   48 +---
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenpal.S            |   12 -
 linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h     |   10 
 linux-2.6.18-21.el5-gerd-order-kei/include/xen/interface/arch-ia64.h |   53 ++---
 9 files changed, 77 insertions(+), 212 deletions(-)

diff -puN arch/ia64/kernel/gate.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/kernel/gate.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/gate.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/gate.S	2007-06-07 02:44:30.000000000 -0400
@@ -55,18 +55,6 @@
 [1:]	movl reg=0;					\
 	.xdata4 ".data.patch.running_on_xen", 1b-.
 
-	.section ".data.patch.brl_xen_rsm_be_i", "a"
-	.previous
-#define BRL_COND_XEN_RSM_BE_I(pr)			\
-[1:](pr)brl.cond.sptk 0;				\
-	.xdata4 ".data.patch.brl_xen_rsm_be_i", 1b-.
-
-	.section ".data.patch.brl_xen_get_psr", "a"
-	.previous
-#define BRL_COND_XEN_GET_PSR(pr)			\
-[1:](pr)brl.cond.sptk 0;				\
-	.xdata4 ".data.patch.brl_xen_get_psr", 1b-.
-
 	.section ".data.patch.brl_xen_ssm_i_0", "a"
 	.previous
 #define BRL_COND_XEN_SSM_I_0(pr)			\
@@ -154,9 +142,9 @@ GLOBAL_ENTRY(__kernel_syscall_via_epc)
 	cmp.ne isXen,isRaw=r0,r30
 	;;
 (isRaw)	rsm psr.be | psr.i
-	BRL_COND_XEN_RSM_BE_I(isXen)
-	.global .vdso_rsm_be_i_ret
-.vdso_rsm_be_i_ret:
+(isXen)	st1 [r22]=r20
+(isXen)	XEN_HYPER_RSM_BE
+	;;
 #else
 	rsm psr.be | psr.i			// M2 (5 cyc to srlz.d)
 #endif
@@ -169,9 +157,9 @@ GLOBAL_ENTRY(__kernel_syscall_via_epc)
 	lfetch [r18]				// M0|1
 #ifdef CONFIG_XEN_IA64_VDSO_PARAVIRT
 (isRaw)	mov r29=psr
-	BRL_COND_XEN_GET_PSR(isXen)
-	.global .vdso_get_psr_ret
-.vdso_get_psr_ret:
+(isXen)	XEN_HYPER_GET_PSR
+	;;
+(isXen)	mov r29=r8
 #else
 	mov r29=psr				// M2 (12 cyc)
 #endif
diff -puN arch/ia64/kernel/gate.lds.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/kernel/gate.lds.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/gate.lds.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/gate.lds.S	2007-06-07 02:44:30.000000000 -0400
@@ -49,14 +49,6 @@ SECTIONS
 				    *(.data.patch.running_on_xen)
 				    __end_gate_running_on_xen_patchlist = .;
 
-				    __start_gate_brl_xen_rsm_be_i_patchlist = .;
-				    *(.data.patch.brl_xen_rsm_be_i)
-				    __end_gate_brl_xen_rsm_be_i_patchlist = .;
-
-				    __start_gate_brl_xen_get_psr_patchlist = .;
-				    *(.data.patch.brl_xen_get_psr)
-				    __end_gate_brl_xen_get_psr_patchlist = .;
-
 				    __start_gate_brl_xen_ssm_i_0_patchlist = .;
 				    *(.data.patch.brl_xen_ssm_i_0)
 				    __end_gate_brl_xen_ssm_i_0_patchlist = .;
diff -puN arch/ia64/kernel/patch.c~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/kernel/patch.c
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/patch.c~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/patch.c	2007-06-07 02:44:30.000000000 -0400
@@ -236,13 +236,9 @@ patch_brl_symaddr(unsigned long start, u
 static void __init
 patch_brl_in_vdso(void)
 {
-	EXTERN_PATCHLIST(xen_rsm_be_i);
-	EXTERN_PATCHLIST(xen_get_psr);
 	EXTERN_PATCHLIST(xen_ssm_i_0);
 	EXTERN_PATCHLIST(xen_ssm_i_1);
 
-	PATCH_BRL_SYMADDR(xen_rsm_be_i);
-	PATCH_BRL_SYMADDR(xen_get_psr);
 	PATCH_BRL_SYMADDR(xen_ssm_i_0);
 	PATCH_BRL_SYMADDR(xen_ssm_i_1);
 }
diff -puN arch/ia64/xen/hypercall.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/xen/hypercall.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/hypercall.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S	2007-06-07 02:44:30.000000000 -0400
@@ -7,27 +7,6 @@
 #include <asm/processor.h>
 #include <asm/asmmacro.h>
 
-/* To clear vpsr.ic, vpsr.i needs to be cleared first */
-#define XEN_CLEAR_PSR_IC				\
-	mov r14=1;					\
-	movl r15=XSI_PSR_I_ADDR;			\
-	movl r2=XSI_PSR_IC;				\
-	;;						\
-	ld8 r15=[r15];					\
-	ld4 r3=[r2];					\
-	;;						\
-	ld1 r16=[r15];					\
-	;;						\
-	st1 [r15]=r14;					\
-	st4 [r2]=r0;					\
-	;;
-
-/* First restore vpsr.ic, and then vpsr.i */
-#define XEN_RESTORE_PSR_IC				\
-	st4 [r2]=r3;					\
-	st1 [r15]=r16;					\
-	;;
-
 GLOBAL_ENTRY(xen_get_ivr)
 	movl r8=running_on_xen;;
 	ld4 r8=[r8];;
@@ -35,12 +14,8 @@ GLOBAL_ENTRY(xen_get_ivr)
 (p7)	mov r8=cr.ivr;;
 (p7)	br.ret.sptk.many rp
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_GET_IVR
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_get_ivr)
@@ -52,12 +27,8 @@ GLOBAL_ENTRY(xen_get_tpr)
 (p7)	mov r8=cr.tpr;;
 (p7)	br.ret.sptk.many rp
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_GET_TPR
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_get_tpr)
@@ -71,12 +42,8 @@ GLOBAL_ENTRY(xen_set_tpr)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_SET_TPR
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_set_tpr)
@@ -90,12 +57,8 @@ GLOBAL_ENTRY(xen_eoi)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_EOI
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_eoi)
@@ -109,12 +72,8 @@ GLOBAL_ENTRY(xen_thash)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_THASH
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_thash)
@@ -128,12 +87,8 @@ GLOBAL_ENTRY(xen_set_itm)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_SET_ITM
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_set_itm)
@@ -148,12 +103,8 @@ GLOBAL_ENTRY(xen_ptcga)
 	mov r8=r32
 	mov r9=r33
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_PTC_GA
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_ptcga)
@@ -167,12 +118,8 @@ GLOBAL_ENTRY(xen_get_rr)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_GET_RR
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_get_rr)
@@ -187,12 +134,8 @@ GLOBAL_ENTRY(xen_set_rr)
 	mov r8=r32
 	mov r9=r33
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_SET_RR
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_set_rr)
@@ -239,12 +182,8 @@ GLOBAL_ENTRY(xen_set_kr)
 1:	mov r8=r32
 	mov r9=r33
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_SET_KR
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 END(xen_set_kr)
 
@@ -257,12 +196,8 @@ GLOBAL_ENTRY(xen_fc)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_FC
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 END(xen_fc)
 
@@ -275,12 +210,8 @@ GLOBAL_ENTRY(xen_get_cpuid)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_GET_CPUID
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 END(xen_get_cpuid)
 
@@ -293,12 +224,8 @@ GLOBAL_ENTRY(xen_get_pmd)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_GET_PMD
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 END(xen_get_pmd)
 
@@ -312,12 +239,8 @@ GLOBAL_ENTRY(xen_get_eflag)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_GET_EFLAG
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 END(xen_get_eflag)
 	
@@ -331,12 +254,8 @@ GLOBAL_ENTRY(xen_set_eflag)
 	;;
 	mov r8=r32
 	;;
-	XEN_CLEAR_PSR_IC
-	;;
 	XEN_HYPER_SET_EFLAG
 	;;
-	XEN_RESTORE_PSR_IC
-	;;
 	br.ret.sptk.many rp
 END(xen_set_eflag)
 #endif
@@ -354,27 +273,6 @@ END(xen_send_ipi)
 #ifdef CONFIG_XEN_IA64_VDSO_PARAVIRT
 // Those are vdso specialized.
 // In fsys mode, call, ret can't be used.
-GLOBAL_ENTRY(xen_rsm_be_i)
-	st1 [r22]=r20
-	st4 [r23]=r0
-	XEN_HYPER_RSM_BE
-	st4 [r23]=r20
-	brl.cond.sptk	.vdso_rsm_be_i_ret
-	;; 
-END(xen_rsm_be_i)
-
-GLOBAL_ENTRY(xen_get_psr)
-	mov r31=r8
-	mov r25=IA64_PSR_IC
-	st4 [r23]=r0
-	XEN_HYPER_GET_PSR
-	;; 
-	st4 [r23]=r20
-	or r29=r8,r25 // vpsr.ic was cleared for hyperprivop
-	mov r8=r31
-	brl.cond.sptk	.vdso_get_psr_ret
-	;; 
-END(xen_get_psr)
 
 	// see xen_ssm_i() in privop.h
 	// r22 = &vcpu->vcpu_info->evtchn_upcall_mask
@@ -394,7 +292,6 @@ END(xen_get_psr)
 (p14)	cmp.ne.unc p11,p0=r0,r25;	\
 	;;				\
 (p11)	st1 [r22]=r20;			\
-(p11)	st4 [r23]=r0;			\
 (p11)	XEN_HYPER_SSM_I;
 		
 GLOBAL_ENTRY(xen_ssm_i_0)
diff -puN arch/ia64/xen/xenentry.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/xen/xenentry.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenentry.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenentry.S	2007-06-07 02:44:30.000000000 -0400
@@ -57,12 +57,6 @@ GLOBAL_ENTRY(ia64_switch_to)
 	shr.u r26=r20,IA64_GRANULE_SHIFT
 	cmp.eq p7,p6=r25,in0
 	;;
-#ifdef CONFIG_XEN
-	movl r8=XSI_PSR_IC
-	;;
-	st4 [r8]=r0	// force psr.ic off for hyperprivop(s)
-	;;
-#endif
 	/*
 	 * If we've already mapped this task's page, we can skip doing it again.
 	 */
@@ -70,19 +64,13 @@ GLOBAL_ENTRY(ia64_switch_to)
 (p6)	br.cond.dpnt .map
 	;;
 .done:
+	ld8 sp=[r21]			// load kernel stack pointer of new task
 #ifdef CONFIG_XEN
-	// psr.ic already off
 	// update "current" application register
 	mov r8=IA64_KR_CURRENT
 	mov r9=in0;;
 	XEN_HYPER_SET_KR
-	ld8 sp=[r21]			// load kernel stack pointer of new task
-	movl r27=XSI_PSR_IC
-	mov r8=1
-	;;
-	st4 [r27]=r8			// psr.ic back on
 #else
-	ld8 sp=[r21]			// load kernel stack pointer of new task
 	mov IA64_KR(CURRENT)=in0	// update "current" application register
 #endif
 	mov r8=r13			// return pointer to previously running task
@@ -97,7 +85,10 @@ GLOBAL_ENTRY(ia64_switch_to)
 
 .map:
 #ifdef CONFIG_XEN
-	// psr.ic already off
+    movl r25=XSI_PSR_IC			// clear psr.ic
+    ;;
+    st4 [r25]=r0
+    ;;
 #else
 	rsm psr.ic			// interrupts (psr.i) are already disabled here
 #endif
@@ -130,7 +121,13 @@ GLOBAL_ENTRY(ia64_switch_to)
 #endif
 	;;
 	itr.d dtr[r25]=r23		// wire in new mapping...
-#ifndef CONFIG_XEN
+#ifdef CONFIG_XEN
+	mov r9=1
+	movl r8=XSI_PSR_IC
+	;;
+	st4 [r8]=r9
+	;;
+#else
 	ssm psr.ic			// reenable the psr.ic bit
 	;;
 	srlz.d
diff -puN arch/ia64/xen/xenivt.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/xen/xenivt.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenivt.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenivt.S	2007-06-07 02:44:30.000000000 -0400
@@ -707,11 +707,23 @@ ENTRY(page_fault)
 	;;
 #endif
 #ifdef CONFIG_XEN
-	br.cond.sptk.many	xen_page_fault
+
+#define MASK_TO_PEND_OFS    (-1)
+
+(p15)	movl r14=XSI_PSR_I_ADDR
 	;;
-done_xen_page_fault:
-#endif
+(p15)	ld8 r14=[r14]
+	;;
+(p15)	st1 [r14]=r0,MASK_TO_PEND_OFS		// if (p15) vpsr.i = 1
+	;;		// if (p15) (vcpu->vcpu_info->evtchn_upcall_mask)=0
+(p15)	ld1 r14=[r14]	// if (vcpu->vcpu_info->evtchn_upcall_pending)
+	;;
+(p15)	cmp.ne	p15,p0=r14,r0
+	;;
+(p15)	XEN_HYPER_SSM_I
+#else
 (p15)	ssm psr.i				// restore psr.i
+#endif
 	movl r14=ia64_leave_kernel
 	;;
 	SAVE_REST
@@ -727,25 +739,6 @@ END(page_fault)
 ENTRY(dkey_miss)
 	DBG_FAULT(7)
 	FAULT(7)
-#ifdef CONFIG_XEN
-	// Leaving this code inline above results in an IVT section overflow
-	// There is no particular reason for this code to be here...
-xen_page_fault:
-(p15)	movl r3=XSI_PSR_I_ADDR
-	;;
-(p15)	ld8 r3=[r3]
-	;;
-(p15)	st1 [r3]=r0,-1	// if (p15) vpsr.i = 1
-	mov r14=r0
-	;;
-(p15)	ld1 r14=[r3]				// if (pending_events)
-	adds r3=8,r2				// re-set up second base pointer
-	;;
-(p15)	cmp.ne	p15,p0=r14,r0
-	;;
-	br.cond.sptk.many done_xen_page_fault
-	;;
-#endif
 END(dkey_miss)
 
 	.org ia64_ivt+0x2000
@@ -1168,14 +1161,13 @@ ENTRY(break_fault)
 #ifdef CONFIG_XEN
 (p15)	ld8 r16=[r16]				// vpsr.i
 	;;
-(p15)	st1 [r16]=r0,-1		// if (p15) vpsr.i = 1
-	mov r2=r0
-	;;
-(p15)	ld1 r2=[r16]				// if (pending_events)
+(p15)	st1 [r16]=r0,MASK_TO_PEND_OFS		// if (p15) vpsr.i = 1
+	;;		// if (p15) (vcpu->vcpu_info->evtchn_upcall_mask)=0
+(p15)	ld1 r2=[r16]	// if (vcpu->vcpu_info->evtchn_upcall_pending)
 	;;
-	cmp.ne	p6,p0=r2,r0
+(p15)	cmp.ne.unc p6,p0=r2,r0
 	;;
-(p6)	ssm	psr.i				//   do a real ssm psr.i
+(p6)	XEN_HYPER_SSM_I				//   do a real ssm psr.i
 #else
 (p15)	ssm psr.i				// M2   restore psr.i
 #endif
diff -puN arch/ia64/xen/xenpal.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop arch/ia64/xen/xenpal.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenpal.S~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenpal.S	2007-06-07 02:44:30.000000000 -0400
@@ -41,16 +41,16 @@ GLOBAL_ENTRY(xen_pal_call_static)
 #ifdef CONFIG_XEN
 	// this is low priority for paravirtualization, but is called
 	// from the idle loop so confuses privop counting
-	movl r31=XSI_PSR_IC
+	movl r31=XSI_PSR_I_ADDR
 	;;
-(p6)	st4 [r31]=r0
+	ld8 r31=[r31]
+	mov r22=1
 	;;
-(p7)	adds r31=XSI_PSR_I_ADDR_OFS-XSI_PSR_IC_OFS,r31
-(p7)	mov r22=1
+	st1 [r31]=r22
 	;;
-(p7)	ld8 r31=[r31]
+(p6)	movl r31=XSI_PSR_IC
 	;;
-(p7)	st1 [r31]=r22
+(p6)	st4.rel [r31]=r0
 	;;
 	mov r31 = in3
 	mov b7 = loc2
diff -puN include/asm-ia64/xen/privop.h~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop include/asm-ia64/xen/privop.h
--- linux-2.6.18-21.el5-gerd-order/include/asm-ia64/xen/privop.h~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h	2007-06-07 02:44:30.000000000 -0400
@@ -123,8 +123,6 @@ extern void xen_set_eflag(unsigned long)
  * that we inline it */
 #define xen_hyper_ssm_i()						\
 ({									\
-	xen_set_virtual_psr_i(0);					\
-	xen_set_virtual_psr_ic(0);					\
 	XEN_HYPER_SSM_I;						\
 })
 
@@ -139,8 +137,12 @@ extern void xen_set_eflag(unsigned long)
 #define xen_ssm_i()							\
 ({									\
 	int old = xen_get_virtual_psr_i();				\
-	xen_set_virtual_psr_i(1);					\
-	if (!old && xen_get_virtual_pend()) xen_hyper_ssm_i();		\
+	if (!old) {							\
+		if (xen_get_virtual_pend())				\
+			xen_hyper_ssm_i();				\
+		else							\
+			xen_set_virtual_psr_i(1);			\
+	}								\
 })
 
 #define xen_ia64_intrin_local_irq_restore(x)				\
diff -puN include/xen/interface/arch-ia64.h~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop include/xen/interface/arch-ia64.h
--- linux-2.6.18-21.el5-gerd-order/include/xen/interface/arch-ia64.h~13448-IA64_remove_the_requirement_vpsr.ic==0_from_hyperprivop	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/xen/interface/arch-ia64.h	2007-06-07 02:44:30.000000000 -0400
@@ -404,32 +404,33 @@ struct xen_ia64_boot_param {
 #define XMAPPEDREGS_OFS			XSI_SIZE
 
 /* Hyperprivops.  */
-#define HYPERPRIVOP_RFI			0x1
-#define HYPERPRIVOP_RSM_DT		0x2
-#define HYPERPRIVOP_SSM_DT		0x3
-#define HYPERPRIVOP_COVER		0x4
-#define HYPERPRIVOP_ITC_D		0x5
-#define HYPERPRIVOP_ITC_I		0x6
-#define HYPERPRIVOP_SSM_I		0x7
-#define HYPERPRIVOP_GET_IVR		0x8
-#define HYPERPRIVOP_GET_TPR		0x9
-#define HYPERPRIVOP_SET_TPR		0xa
-#define HYPERPRIVOP_EOI			0xb
-#define HYPERPRIVOP_SET_ITM		0xc
-#define HYPERPRIVOP_THASH		0xd
-#define HYPERPRIVOP_PTC_GA		0xe
-#define HYPERPRIVOP_ITR_D		0xf
-#define HYPERPRIVOP_GET_RR		0x10
-#define HYPERPRIVOP_SET_RR		0x11
-#define HYPERPRIVOP_SET_KR		0x12
-#define HYPERPRIVOP_FC			0x13
-#define HYPERPRIVOP_GET_CPUID		0x14
-#define HYPERPRIVOP_GET_PMD		0x15
-#define HYPERPRIVOP_GET_EFLAG		0x16
-#define HYPERPRIVOP_SET_EFLAG		0x17
-#define HYPERPRIVOP_RSM_BE		0x18
-#define HYPERPRIVOP_GET_PSR		0x19
-#define HYPERPRIVOP_MAX			0x19
+#define HYPERPRIVOP_START		0x1
+#define HYPERPRIVOP_RFI			(HYPERPRIVOP_START + 0x0)
+#define HYPERPRIVOP_RSM_DT		(HYPERPRIVOP_START + 0x1)
+#define HYPERPRIVOP_SSM_DT		(HYPERPRIVOP_START + 0x2)
+#define HYPERPRIVOP_COVER		(HYPERPRIVOP_START + 0x3)
+#define HYPERPRIVOP_ITC_D		(HYPERPRIVOP_START + 0x4)
+#define HYPERPRIVOP_ITC_I		(HYPERPRIVOP_START + 0x5)
+#define HYPERPRIVOP_SSM_I		(HYPERPRIVOP_START + 0x6)
+#define HYPERPRIVOP_GET_IVR		(HYPERPRIVOP_START + 0x7)
+#define HYPERPRIVOP_GET_TPR		(HYPERPRIVOP_START + 0x8)
+#define HYPERPRIVOP_SET_TPR		(HYPERPRIVOP_START + 0x9)
+#define HYPERPRIVOP_EOI			(HYPERPRIVOP_START + 0xa)
+#define HYPERPRIVOP_SET_ITM		(HYPERPRIVOP_START + 0xb)
+#define HYPERPRIVOP_THASH		(HYPERPRIVOP_START + 0xc)
+#define HYPERPRIVOP_PTC_GA		(HYPERPRIVOP_START + 0xd)
+#define HYPERPRIVOP_ITR_D		(HYPERPRIVOP_START + 0xe)
+#define HYPERPRIVOP_GET_RR		(HYPERPRIVOP_START + 0xf)
+#define HYPERPRIVOP_SET_RR		(HYPERPRIVOP_START + 0x10)
+#define HYPERPRIVOP_SET_KR		(HYPERPRIVOP_START + 0x11)
+#define HYPERPRIVOP_FC			(HYPERPRIVOP_START + 0x12)
+#define HYPERPRIVOP_GET_CPUID		(HYPERPRIVOP_START + 0x13)
+#define HYPERPRIVOP_GET_PMD		(HYPERPRIVOP_START + 0x14)
+#define HYPERPRIVOP_GET_EFLAG		(HYPERPRIVOP_START + 0x15)
+#define HYPERPRIVOP_SET_EFLAG		(HYPERPRIVOP_START + 0x16)
+#define HYPERPRIVOP_RSM_BE		(HYPERPRIVOP_START + 0x17)
+#define HYPERPRIVOP_GET_PSR		(HYPERPRIVOP_START + 0x18)
+#define HYPERPRIVOP_MAX			(0x19)
 
 /* Fast and light hypercalls.  */
 #define __HYPERVISOR_ia64_fast_eoi	0x0200

_


rh bug 242128

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1167952657 25200
# Node ID b1c00767c6ae8c383c9fb9dcd92e7acc3467ee95
# Parent  d9cc772c6bde7c3eb13360ddd91a82dc432d8c20
[IA64] Use rum psr.be instead of XEN_HYPER_RSM_BE

Good for guest syscall performance

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/gate.S       |    2 +-
 linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h |    1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff -puN arch/ia64/kernel/gate.S~13459-IA64_Use_rum_psr.be_instead_of_XEN_HYPER_RSM_BE arch/ia64/kernel/gate.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/gate.S~13459-IA64_Use_rum_psr.be_instead_of_XEN_HYPER_RSM_BE	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/gate.S	2007-06-07 02:44:30.000000000 -0400
@@ -143,7 +143,7 @@ GLOBAL_ENTRY(__kernel_syscall_via_epc)
 	;;
 (isRaw)	rsm psr.be | psr.i
 (isXen)	st1 [r22]=r20
-(isXen)	XEN_HYPER_RSM_BE
+(isXen)	rum psr.be
 	;;
 #else
 	rsm psr.be | psr.i			// M2 (5 cyc to srlz.d)
diff -puN include/asm-ia64/xen/privop.h~13459-IA64_Use_rum_psr.be_instead_of_XEN_HYPER_RSM_BE include/asm-ia64/xen/privop.h
--- linux-2.6.18-21.el5-gerd-order/include/asm-ia64/xen/privop.h~13459-IA64_Use_rum_psr.be_instead_of_XEN_HYPER_RSM_BE	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h	2007-06-07 02:44:30.000000000 -0400
@@ -45,7 +45,6 @@
 #define	XEN_HYPER_GET_PMD		break HYPERPRIVOP_GET_PMD
 #define	XEN_HYPER_GET_EFLAG		break HYPERPRIVOP_GET_EFLAG
 #define	XEN_HYPER_SET_EFLAG		break HYPERPRIVOP_SET_EFLAG
-#define	XEN_HYPER_RSM_BE		break HYPERPRIVOP_RSM_BE
 #define	XEN_HYPER_GET_PSR		break HYPERPRIVOP_GET_PSR
 
 #define XSI_IFS			(XSI_BASE + XSI_IFS_OFS)

_


rh bug 242129

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1168559818 25200
# Node ID 01ea554f1c5e8bdbfa172349438298b15da6fc5c
# Parent  db72b85b81bb1478cb2e91b6411596648bdc9a2c
[IA64] Hypercall optimizations

provide hypercall the same path with system
most of scrach registers don't need to be saved/restored
it is good for performance

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S         |    7 
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypervisor.c        |    2 
 linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/hypercall.h      |  108 ++--------
 linux-2.6.18-21.el5-gerd-order-kei/include/xen/interface/arch-ia64.h |    2 
 4 files changed, 37 insertions(+), 82 deletions(-)

diff -puN arch/ia64/xen/hypercall.S~13475-IA64_Hypercall_optimizations arch/ia64/xen/hypercall.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/hypercall.S~13475-IA64_Hypercall_optimizations	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S	2007-06-07 02:44:30.000000000 -0400
@@ -305,4 +305,11 @@ GLOBAL_ENTRY(xen_ssm_i_1)
 	brl.cond.sptk	.vdso_ssm_i_1_ret
 	;; 
 END(xen_ssm_i_1)
+
+GLOBAL_ENTRY(__hypercall)
+	mov r2=r37
+	break 0x1000
+	br.ret.sptk.many b0
+	;;
+END(__hypercall)
 #endif
diff -puN arch/ia64/xen/hypervisor.c~13475-IA64_Hypercall_optimizations arch/ia64/xen/hypervisor.c
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/hypervisor.c~13475-IA64_Hypercall_optimizations	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypervisor.c	2007-06-07 02:44:30.000000000 -0400
@@ -49,6 +49,8 @@ static int p2m_expose_init(void);
 #define p2m_expose_init() (-ENOSYS)
 #endif
 
+EXPORT_SYMBOL(__hypercall);
+
 //XXX same as i386, x86_64 contiguous_bitmap_set(), contiguous_bitmap_clear()
 // move those to lib/contiguous_bitmap?
 //XXX discontigmem/sparsemem
diff -puN include/asm-ia64/hypercall.h~13475-IA64_Hypercall_optimizations include/asm-ia64/hypercall.h
--- linux-2.6.18-21.el5-gerd-order/include/asm-ia64/hypercall.h~13475-IA64_Hypercall_optimizations	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/hypercall.h	2007-06-07 02:44:30.000000000 -0400
@@ -39,6 +39,9 @@
 
 #include <asm/xen/xcom_hcall.h>
 struct xencomm_handle;
+extern unsigned long __hypercall(unsigned long a1, unsigned long a2,
+                                 unsigned long a3, unsigned long a4,
+                                 unsigned long a5, unsigned long cmd);
 
 /*
  * Assembler stubs for hyper-calls.
@@ -47,115 +50,58 @@ struct xencomm_handle;
 #define _hypercall0(type, name)					\
 ({								\
 	long __res;						\
-	__asm__ __volatile__ (";;\n"				\
-			      "mov r2=%1\n"			\
-			      "break 0x1000 ;;\n"		\
-			      "mov %0=r8 ;;\n"			\
-			      : "=r" (__res)			\
-			      : "J" (__HYPERVISOR_##name)	\
-			      : "r2","r8",			\
-			        "memory" );			\
+	__res=__hypercall(0, 0, 0, 0, 0, __HYPERVISOR_##name);	\
 	(type)__res;						\
 })
 
 #define _hypercall1(type, name, a1)				\
 ({								\
 	long __res;						\
-	__asm__ __volatile__ (";;\n"				\
-			      "mov r14=%2\n"			\
-			      "mov r2=%1\n"			\
-			      "break 0x1000 ;;\n"		\
-			      "mov %0=r8 ;;\n"			\
-			      : "=r" (__res)			\
-			      : "J" (__HYPERVISOR_##name),	\
-				"rI" ((unsigned long)(a1))	\
-			      : "r14","r2","r8",		\
-				"memory" );			\
+	__res = __hypercall((unsigned long)a1,			\
+	                     0, 0, 0, 0, __HYPERVISOR_##name);	\
 	(type)__res;						\
 })
 
 #define _hypercall2(type, name, a1, a2)				\
 ({								\
 	long __res;						\
-	__asm__ __volatile__ (";;\n"				\
-			      "mov r14=%2\n"			\
-			      "mov r15=%3\n"			\
-			      "mov r2=%1\n"			\
-			      "break 0x1000 ;;\n"		\
-			      "mov %0=r8 ;;\n"			\
-			      : "=r" (__res)			\
-			      : "J" (__HYPERVISOR_##name),	\
-				"rI" ((unsigned long)(a1)),	\
-				"rI" ((unsigned long)(a2))	\
-			      : "r14","r15","r2","r8",		\
-				"memory" );			\
+	__res = __hypercall((unsigned long)a1,			\
+	                    (unsigned long)a2,			\
+	                    0, 0, 0, __HYPERVISOR_##name);	\
 	(type)__res;						\
 })
 
 #define _hypercall3(type, name, a1, a2, a3)			\
 ({								\
 	long __res;						\
-	__asm__ __volatile__ (";;\n"                            \
-			      "mov r14=%2\n"                    \
-			      "mov r15=%3\n"                    \
-			      "mov r16=%4\n"                    \
-			      "mov r2=%1\n"                     \
-			      "break 0x1000 ;;\n"               \
-			      "mov %0=r8 ;;\n"                  \
-			      : "=r" (__res)                    \
-			      : "J" (__HYPERVISOR_##name),      \
-				"rI" ((unsigned long)(a1)),     \
-				"rI" ((unsigned long)(a2)),     \
-				"rI" ((unsigned long)(a3))      \
-			      : "r14","r15","r16","r2","r8",	\
-			        "memory" );                     \
-	(type)__res;                                            \
+	__res = __hypercall((unsigned long)a1,			\
+	                    (unsigned long)a2,			\
+	                    (unsigned long)a3,			\
+	                    0, 0, __HYPERVISOR_##name);		\
+	(type)__res;						\
 })
 
 #define _hypercall4(type, name, a1, a2, a3, a4)			\
 ({								\
 	long __res;						\
-	__asm__ __volatile__ (";;\n"                            \
-			      "mov r14=%2\n"                    \
-			      "mov r15=%3\n"                    \
-			      "mov r16=%4\n"                    \
-			      "mov r17=%5\n"                    \
-			      "mov r2=%1\n"                     \
-			      "break 0x1000 ;;\n"               \
-			      "mov %0=r8 ;;\n"                  \
-			      : "=r" (__res)                    \
-			      : "J" (__HYPERVISOR_##name),      \
-				"rI" ((unsigned long)(a1)),     \
-				"rI" ((unsigned long)(a2)),     \
-				"rI" ((unsigned long)(a3)),     \
-				"rI" ((unsigned long)(a4))      \
-			      : "r14","r15","r16","r2","r8",	\
-			        "r17","memory" );               \
-	(type)__res;                                            \
+	__res = __hypercall((unsigned long)a1,			\
+	                    (unsigned long)a2,			\
+	                    (unsigned long)a3,			\
+	                    (unsigned long)a4,			\
+	                    0, __HYPERVISOR_##name);		\
+	(type)__res;						\
 })
 
 #define _hypercall5(type, name, a1, a2, a3, a4, a5)		\
 ({								\
 	long __res;						\
-	__asm__ __volatile__ (";;\n"                            \
-			      "mov r14=%2\n"                    \
-			      "mov r15=%3\n"                    \
-			      "mov r16=%4\n"                    \
-			      "mov r17=%5\n"                    \
-			      "mov r18=%6\n"                    \
-			      "mov r2=%1\n"                     \
-			      "break 0x1000 ;;\n"               \
-			      "mov %0=r8 ;;\n"                  \
-			      : "=r" (__res)                    \
-			      : "J" (__HYPERVISOR_##name),      \
-				"rI" ((unsigned long)(a1)),     \
-				"rI" ((unsigned long)(a2)),     \
-				"rI" ((unsigned long)(a3)),     \
-				"rI" ((unsigned long)(a4)),     \
-				"rI" ((unsigned long)(a5))      \
-			      : "r14","r15","r16","r2","r8",	\
-			        "r17","r18","memory" );         \
-	(type)__res;                                            \
+	__res = __hypercall((unsigned long)a1,			\
+	                    (unsigned long)a2,			\
+	                    (unsigned long)a3,			\
+	                    (unsigned long)a4,			\
+	                    (unsigned long)a5,			\
+	                    __HYPERVISOR_##name);		\
+	(type)__res;						\
 })
 
 
diff -puN include/xen/interface/arch-ia64.h~13475-IA64_Hypercall_optimizations include/xen/interface/arch-ia64.h
--- linux-2.6.18-21.el5-gerd-order/include/xen/interface/arch-ia64.h~13475-IA64_Hypercall_optimizations	2007-06-07 02:44:30.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/xen/interface/arch-ia64.h	2007-06-07 02:44:30.000000000 -0400
@@ -433,7 +433,7 @@ struct xen_ia64_boot_param {
 #define HYPERPRIVOP_MAX			(0x19)
 
 /* Fast and light hypercalls.  */
-#define __HYPERVISOR_ia64_fast_eoi	0x0200
+#define __HYPERVISOR_ia64_fast_eoi	__HYPERVISOR_arch_1
 
 /* Xencomm macros.  */
 #define XENCOMM_INLINE_MASK 0xf800000000000000UL

_


rh bug 242130

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1168629071 25200
# Node ID cd6598396086157a9eeb2f368462ddeb6e8f8201
# Parent  01ea554f1c5e8bdbfa172349438298b15da6fc5c
[IA64] Simplify lazy cover algorithm

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/asm-offsets.c    |    1 
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenminstate.h       |   11 ----------
 linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h     |    1 
 linux-2.6.18-21.el5-gerd-order-kei/include/xen/interface/arch-ia64.h |    5 +---
 4 files changed, 3 insertions(+), 15 deletions(-)

diff -puN arch/ia64/kernel/asm-offsets.c~13476-IA64_Simplify_lazy_cover_algorithm arch/ia64/kernel/asm-offsets.c
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/asm-offsets.c~13476-IA64_Simplify_lazy_cover_algorithm	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/asm-offsets.c	2007-06-07 02:44:31.000000000 -0400
@@ -288,7 +288,6 @@ void foo(void)
 	DEFINE_MAPPED_REG_OFS(XSI_IHA_OFS, iha);
 	DEFINE_MAPPED_REG_OFS(XSI_ITIR_OFS, itir);
 	DEFINE_MAPPED_REG_OFS(XSI_PSR_IC_OFS, interrupt_collection_enabled);
-	DEFINE_MAPPED_REG_OFS(XSI_INCOMPL_REGFR_OFS, incomplete_regframe);
 	DEFINE_MAPPED_REG_OFS(XSI_BANKNUM_OFS, banknum);
 	DEFINE_MAPPED_REG_OFS(XSI_BANK0_R16_OFS, bank0_regs[0]);
 	DEFINE_MAPPED_REG_OFS(XSI_BANK1_R16_OFS, bank1_regs[0]);
diff -puN arch/ia64/xen/xenminstate.h~13476-IA64_Simplify_lazy_cover_algorithm arch/ia64/xen/xenminstate.h
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenminstate.h~13476-IA64_Simplify_lazy_cover_algorithm	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenminstate.h	2007-06-07 02:44:31.000000000 -0400
@@ -150,16 +150,7 @@
 .mem.offset 8,0; st8.spill [r17]=r11,24;							\
         ;;											\
 	/* xen special handling for possibly lazy cover */					\
-	movl r8=XSI_INCOMPL_REGFR;								\
-	;;											\
-	ld4 r30=[r8];										\
-	;;											\
-	/* set XSI_INCOMPL_REGFR 0 */								\
-	st4 [r8]=r0;										\
-	cmp.eq	p6,p7=r30,r0;									\
-	;; /* not sure if this stop bit is necessary */						\
-(p6)	adds r8=XSI_PRECOVER_IFS-XSI_INCOMPL_REGFR,r8;						\
-(p7)	adds r8=XSI_IFS-XSI_INCOMPL_REGFR,r8;							\
+	movl r8=XSI_PRECOVER_IFS;								\
 	;;											\
 	ld8 r30=[r8];										\
 	;;											\
diff -puN include/asm-ia64/xen/privop.h~13476-IA64_Simplify_lazy_cover_algorithm include/asm-ia64/xen/privop.h
--- linux-2.6.18-21.el5-gerd-order/include/asm-ia64/xen/privop.h~13476-IA64_Simplify_lazy_cover_algorithm	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h	2007-06-07 02:44:31.000000000 -0400
@@ -49,7 +49,6 @@
 
 #define XSI_IFS			(XSI_BASE + XSI_IFS_OFS)
 #define XSI_PRECOVER_IFS	(XSI_BASE + XSI_PRECOVER_IFS_OFS)
-#define XSI_INCOMPL_REGFR	(XSI_BASE + XSI_INCOMPL_REGFR_OFS)
 #define XSI_IFA			(XSI_BASE + XSI_IFA_OFS)
 #define XSI_ISR			(XSI_BASE + XSI_ISR_OFS)
 #define XSI_IIM			(XSI_BASE + XSI_IIM_OFS)
diff -puN include/xen/interface/arch-ia64.h~13476-IA64_Simplify_lazy_cover_algorithm include/xen/interface/arch-ia64.h
--- linux-2.6.18-21.el5-gerd-order/include/xen/interface/arch-ia64.h~13476-IA64_Simplify_lazy_cover_algorithm	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/xen/interface/arch-ia64.h	2007-06-07 02:44:31.000000000 -0400
@@ -263,10 +263,9 @@ struct mapped_regs {
              */
             unsigned char *interrupt_mask_addr;
             int pending_interruption;
-            int incomplete_regframe; // see SDM vol2 6.8
             unsigned char vpsr_pp;
-            unsigned char reserved5_2[7];
-            unsigned long reserved5_1[3];
+            unsigned char reserved5_2[3];
+            unsigned long reserved5_1[4];
             int metaphysical_mode; // 1 = use metaphys mapping, 0 = use virtual
             int banknum; // 0 or 1, which virtual register bank is active
             unsigned long rrs[8]; // region registers

_


rh bug 242131

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1168632085 25200
# Node ID 809043a22786e2b31972577e1aca881ae6683a06
# Parent  c1b98df7386d25e5223ffcb0f173b45b17c49fed
[IA64] Implement hyper_get_psr

Mov from psr is used frequently by xeno.

Signed-of-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S     |   13 +++++++
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenentry.S      |   18 ++++++++++
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenpal.S        |    9 +++++
 linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h |    6 +++
 4 files changed, 46 insertions(+)

diff -puN arch/ia64/xen/hypercall.S~13478-IA64_Implement_hyper_get_psr arch/ia64/xen/hypercall.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/hypercall.S~13478-IA64_Implement_hyper_get_psr	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S	2007-06-07 02:44:31.000000000 -0400
@@ -7,6 +7,19 @@
 #include <asm/processor.h>
 #include <asm/asmmacro.h>
 
+GLOBAL_ENTRY(xen_get_psr)
+	movl r8=running_on_xen;;
+	ld4 r8=[r8];;
+	cmp.eq p7,p0=r8,r0;;
+(p7)	mov r8=psr;;
+(p7)	br.ret.sptk.many rp
+	;;
+	XEN_HYPER_GET_PSR
+	;;
+	br.ret.sptk.many rp
+	;;
+END(xen_get_psr)
+
 GLOBAL_ENTRY(xen_get_ivr)
 	movl r8=running_on_xen;;
 	ld4 r8=[r8];;
diff -puN arch/ia64/xen/xenentry.S~13478-IA64_Implement_hyper_get_psr arch/ia64/xen/xenentry.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenentry.S~13478-IA64_Implement_hyper_get_psr	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenentry.S	2007-06-07 02:44:31.000000000 -0400
@@ -410,7 +410,16 @@ ENTRY(ia64_leave_syscall)
 (pUStk) add r14=IA64_TASK_THREAD_ON_USTACK_OFFSET,r13
 	;;
 	ld8 r26=[r2],PT(B0)-PT(AR_PFS)	// M0|1 load ar.pfs
+#ifdef CONFIG_XEN
+(pKStk)	mov r21=r8
+(pKStk)	XEN_HYPER_GET_PSR
+	;;
+(pKStk)	mov r22=r8
+(pKStk)	mov r8=r21
+	;;
+#else
 (pKStk)	mov r22=psr			// M2   read PSR now that interrupts are disabled
+#endif
 	nop 0
 	;;
 	ld8 r21=[r2],PT(AR_RNAT)-PT(B0) // M0|1 load b0
@@ -640,7 +649,16 @@ GLOBAL_ENTRY(ia64_leave_kernel)
 	adds r16=PT(CR_IPSR)+16,r12
 	adds r17=PT(CR_IIP)+16,r12
 
+#ifdef CONFIG_XEN
+(pKStk)	mov r29=r8
+(pKStk)	XEN_HYPER_GET_PSR
+	;;
+(pKStk)	mov r22=r8
+(pKStk)	mov r8=r29
+	;;
+#else
 (pKStk)	mov r22=psr		// M2 read PSR now that interrupts are disabled
+#endif
 	nop.i 0
 	nop.i 0
 	;;
diff -puN arch/ia64/xen/xenpal.S~13478-IA64_Implement_hyper_get_psr arch/ia64/xen/xenpal.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenpal.S~13478-IA64_Implement_hyper_get_psr	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenpal.S	2007-06-07 02:44:31.000000000 -0400
@@ -33,7 +33,16 @@ GLOBAL_ENTRY(xen_pal_call_static)
 	mov loc4=ar.rsc			// save RSE configuration
 	;;
 	mov ar.rsc=0			// put RSE in enforced lazy, LE mode
+#ifdef CONFIG_XEN
+	mov r9 = r8
+	XEN_HYPER_GET_PSR
+	;;
+	mov loc3 = r8
+	mov r8 = r9
+	;;
+#else
 	mov loc3 = psr
+#endif
 	mov loc0 = rp
 	.body
 	mov r30 = in2
diff -puN include/asm-ia64/xen/privop.h~13478-IA64_Implement_hyper_get_psr include/asm-ia64/xen/privop.h
--- linux-2.6.18-21.el5-gerd-order/include/asm-ia64/xen/privop.h~13478-IA64_Implement_hyper_get_psr	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h	2007-06-07 02:44:31.000000000 -0400
@@ -182,6 +182,7 @@ extern void xen_set_eflag(unsigned long)
  * be properly handled by Xen, some are frequent enough that we use
  * hyperprivops for performance. */
 
+extern unsigned long xen_get_psr(void);
 extern unsigned long xen_get_ivr(void);
 extern unsigned long xen_get_tpr(void);
 extern void xen_set_itm(unsigned long);
@@ -201,6 +202,11 @@ extern void xen_ptcga(unsigned long addr
 	__u64 ia64_intri_res;						\
 									\
 	switch(regnum) {						\
+	case _IA64_REG_PSR:						\
+		ia64_intri_res = (is_running_on_xen()) ?			\
+			xen_get_psr() :					\
+			__ia64_getreg(regnum);				\
+		break;							\
 	case _IA64_REG_CR_IVR:						\
 		ia64_intri_res = (is_running_on_xen()) ?			\
 			xen_get_ivr() :					\

_


rh bug 242132

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1168838318 25200
# Node ID c6b683ba68f5417a5b397d8530edd9df14ad586c
# Parent  43c5302ee92dc0a12df02084c07e6172f2b6ebe8
[IA64] Fix save/restore

Using the new hypercall path, scratch registers are not saved/restored.

So after returning from hypercall, r20 may contain garbage data.
This triggered General Exception.

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xensetup.S |    3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff -puN arch/ia64/xen/xensetup.S~13480-IA64_Fix_saverestore arch/ia64/xen/xensetup.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xensetup.S~13480-IA64_Fix_saverestore	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xensetup.S	2007-06-07 02:44:31.000000000 -0400
@@ -38,7 +38,7 @@ END(early_xen_setup)
    Just force the stacked registers to be written in memory.  */	
 GLOBAL_ENTRY(xencomm_arch_hypercall_suspend)
 	;; 
-	alloc r20=ar.pfs,0,0,2,0
+	alloc r20=ar.pfs,0,0,6,0
 	mov r2=__HYPERVISOR_sched_op
 	;; 
 	/* We don't want to deal with RSE.  */
@@ -48,6 +48,5 @@ GLOBAL_ENTRY(xencomm_arch_hypercall_susp
 	;;
 	break 0x1000
 	;; 
-	mov ar.pfs=r20
 	br.ret.sptk.many b0
 END(xencomm_arch_hypercall_suspend)

_


rh bug 242134

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1169088700 25200
# Node ID efaf9c2de07e74a847c05e2cddae8df08851f55c
# Parent  2056bc71fa55f08a09b0d7dacfec55915d057087
[IA64] Remove duplicate check is_running_on_xen

When these functions are called, it is running on XEN.

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S |  162 -----------
 1 file changed, 2 insertions(+), 160 deletions(-)

diff -puN arch/ia64/xen/hypercall.S~13488-IA64_Remove_duplicate_check_is_running_on_xen arch/ia64/xen/hypercall.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/hypercall.S~13488-IA64_Remove_duplicate_check_is_running_on_xen	2007-06-07 02:44:31.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/hypercall.S	2007-06-07 02:44:31.000000000 -0400
@@ -8,267 +8,109 @@
 #include <asm/asmmacro.h>
 
 GLOBAL_ENTRY(xen_get_psr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=psr;;
-(p7)	br.ret.sptk.many rp
-	;;
 	XEN_HYPER_GET_PSR
-	;;
 	br.ret.sptk.many rp
-	;;
+    ;;
 END(xen_get_psr)
 
 GLOBAL_ENTRY(xen_get_ivr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=cr.ivr;;
-(p7)	br.ret.sptk.many rp
-	;;
 	XEN_HYPER_GET_IVR
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_get_ivr)
 
 GLOBAL_ENTRY(xen_get_tpr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=cr.tpr;;
-(p7)	br.ret.sptk.many rp
-	;;
 	XEN_HYPER_GET_TPR
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_get_tpr)
 
 GLOBAL_ENTRY(xen_set_tpr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov cr.tpr=r32;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_SET_TPR
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_set_tpr)
 
 GLOBAL_ENTRY(xen_eoi)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov cr.eoi=r0;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_EOI
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_eoi)
 
 GLOBAL_ENTRY(xen_thash)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	thash r8=r32;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_THASH
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_thash)
 
 GLOBAL_ENTRY(xen_set_itm)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov cr.itm=r32;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_SET_ITM
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_set_itm)
 
 GLOBAL_ENTRY(xen_ptcga)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	ptc.ga r32,r33;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
 	mov r9=r33
-	;;
 	XEN_HYPER_PTC_GA
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_ptcga)
 
 GLOBAL_ENTRY(xen_get_rr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=rr[r32];;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_GET_RR
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_get_rr)
 
 GLOBAL_ENTRY(xen_set_rr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov rr[r32]=r33;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
 	mov r9=r33
-	;;
 	XEN_HYPER_SET_RR
-	;;
 	br.ret.sptk.many rp
 	;;
 END(xen_set_rr)
 
 GLOBAL_ENTRY(xen_set_kr)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.ne p7,p0=r8,r0;;
-(p7)	br.cond.spnt.few 1f;
-	;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar0=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar1=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar2=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar3=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar4=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar5=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar6=r9
-(p7)	br.ret.sptk.many rp;;
-	cmp.eq p7,p0=r8,r0
-	adds r8=-1,r8;;
-(p7)	mov ar7=r9
-(p7)	br.ret.sptk.many rp;;
-
-1:	mov r8=r32
+	mov r8=r32
 	mov r9=r33
-	;;
 	XEN_HYPER_SET_KR
-	;;
 	br.ret.sptk.many rp
 END(xen_set_kr)
 
 GLOBAL_ENTRY(xen_fc)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	fc r32;;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_FC
-	;;
 	br.ret.sptk.many rp
 END(xen_fc)
 
 GLOBAL_ENTRY(xen_get_cpuid)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=cpuid[r32];;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_GET_CPUID
-	;;
 	br.ret.sptk.many rp
 END(xen_get_cpuid)
 
 GLOBAL_ENTRY(xen_get_pmd)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=pmd[r32];;
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_GET_PMD
-	;;
 	br.ret.sptk.many rp
 END(xen_get_pmd)
 
 #ifdef CONFIG_IA32_SUPPORT
 GLOBAL_ENTRY(xen_get_eflag)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov r8=ar24;;
-(p7)	br.ret.sptk.many rp
-	;;
-	mov r8=r32
-	;;
 	XEN_HYPER_GET_EFLAG
-	;;
 	br.ret.sptk.many rp
 END(xen_get_eflag)
 	
 // some bits aren't set if pl!=0, see SDM vol1 3.1.8
 GLOBAL_ENTRY(xen_set_eflag)
-	movl r8=running_on_xen;;
-	ld4 r8=[r8];;
-	cmp.eq p7,p0=r8,r0;;
-(p7)	mov ar24=r32
-(p7)	br.ret.sptk.many rp
-	;;
 	mov r8=r32
-	;;
 	XEN_HYPER_SET_EFLAG
-	;;
 	br.ret.sptk.many rp
 END(xen_set_eflag)
 #endif

_


rh bug 242133

# HG changeset patch
# User awilliam@xenbuild2.aw
# Date 1168974063 25200
# Node ID 43115ffc6635fe2526c1c5ccc98b93bfd80495b6
# Parent  7a2c224a9252bb9ca6ada21cf372f22f37ad98fe
[IA64] Paravirtualize syscall path in file fsys.S

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/fsys.S |   41 +++++++++++++
 1 file changed, 41 insertions(+)

diff -puN arch/ia64/kernel/fsys.S~13486-IA64_Paravirtualize_syscall_path_in_file_fsys.S arch/ia64/kernel/fsys.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/fsys.S~13486-IA64_Paravirtualize_syscall_path_in_file_fsys.S	2007-06-07 02:44:32.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/fsys.S	2007-06-07 02:44:32.000000000 -0400
@@ -571,11 +571,34 @@ ENTRY(fsys_fallback_syscall)
 	adds r17=-1024,r15
 	movl r14=sys_call_table
 	;;
+#ifdef CONFIG_XEN
+	movl r18=running_on_xen;;
+	ld4 r18=[r18];;
+	// p14 = running_on_xen
+	// p15 = !running_on_xen
+	cmp.ne p14,p15=r0,r18
+	;;
+(p14)	movl r18=XSI_PSR_I_ADDR;;
+(p14)	ld8 r18=[r18]
+(p14)	mov r29=1;;
+(p14)	st1 [r18]=r29
+(p15)	rsm psr.i
+#else
 	rsm psr.i
+#endif
 	shladd r18=r17,3,r14
 	;;
 	ld8 r18=[r18]				// load normal (heavy-weight) syscall entry-point
+#ifdef CONFIG_XEN
+(p14)	mov r27=r8
+(p14)	XEN_HYPER_GET_PSR
+	;;
+(p14)	mov r29=r8
+(p14)	mov r8=r27
+(p15)	mov r29=psr				// read psr (12 cyc load latency)
+#else
 	mov r29=psr				// read psr (12 cyc load latency)
+#endif
 	mov r27=ar.rsc
 	mov r21=ar.fpsr
 	mov r26=ar.pfs
@@ -687,7 +710,25 @@ GLOBAL_ENTRY(fsys_bubble_down)
 	mov rp=r14				// I0   set the real return addr
 	and r3=_TIF_SYSCALL_TRACEAUDIT,r3	// A
 	;;
+#ifdef CONFIG_XEN
+	movl r14=running_on_xen;;
+	ld4 r14=[r14];;
+	// p14 = running_on_xen
+	// p15 = !running_on_xen
+	cmp.ne p14,p15=r0,r14
+	;;
+(p14)	movl r28=XSI_PSR_I_ADDR;;
+(p14)	ld8 r28=[r28];;
+(p14)	adds r28=-1,r28;;			// event_pending
+(p14)	ld1 r14=[r28];;
+(p14)	cmp.ne.unc p13,p14=r14,r0;;
+(p13)	XEN_HYPER_SSM_I
+(p14)	adds r28=1,r28;;			// event_mask
+(p14)	st1 [r28]=r0;;
+(p15)	ssm psr.i
+#else
 	ssm psr.i				// M2   we're on kernel stacks now, reenable irqs
+#endif
 	cmp.eq p8,p0=r3,r0			// A
 (p10)	br.cond.spnt.many ia64_ret_from_syscall	// B    return if bad call-frame or r15 is a NaT
 

_


rh bug 242142

# HG changeset patch
# User Alex Williamson <alex.williamson@hp.com>
# Date 1176297884 21600
# Node ID 7158623a1b3dd28f86f908fce7e8e56c37a49179
# Parent  1bde28f762a66276008da38e3fb24751f83dc128
[IA64] Handle NAT bit for dom0 and domU

This fixes ia32 apps running under the IA32-EL.

Signed-off-by: Anthony Xu <anthony.xu@intel.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/asm-offsets.c |    2 
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenentry.S       |    6 
 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenivt.S         |   61 +++++-----
 linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h  |    1 
 4 files changed, 43 insertions(+), 27 deletions(-)

diff -puN arch/ia64/kernel/asm-offsets.c~14804-IA64_Handle_NAT_bit_for_dom0_and_domU arch/ia64/kernel/asm-offsets.c
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/kernel/asm-offsets.c~14804-IA64_Handle_NAT_bit_for_dom0_and_domU	2007-06-07 02:44:32.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/kernel/asm-offsets.c	2007-06-07 02:44:32.000000000 -0400
@@ -291,5 +291,7 @@ void foo(void)
 	DEFINE_MAPPED_REG_OFS(XSI_BANKNUM_OFS, banknum);
 	DEFINE_MAPPED_REG_OFS(XSI_BANK0_R16_OFS, bank0_regs[0]);
 	DEFINE_MAPPED_REG_OFS(XSI_BANK1_R16_OFS, bank1_regs[0]);
+	DEFINE_MAPPED_REG_OFS(XSI_B0NATS_OFS, vbnat);
+	DEFINE_MAPPED_REG_OFS(XSI_B1NATS_OFS, vnat);
 #endif /* CONFIG_XEN */
 }
diff -puN arch/ia64/xen/xenentry.S~14804-IA64_Handle_NAT_bit_for_dom0_and_domU arch/ia64/xen/xenentry.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenentry.S~14804-IA64_Handle_NAT_bit_for_dom0_and_domU	2007-06-07 02:44:32.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenentry.S	2007-06-07 02:44:32.000000000 -0400
@@ -612,6 +612,7 @@ GLOBAL_ENTRY(ia64_leave_kernel)
 #ifdef CONFIG_XEN
 	;;
 	// r16-r31 all now hold bank1 values
+	mov r15=ar.unat
 	movl r2=XSI_BANK1_R16
 	movl r3=XSI_BANK1_R16+8
 	;;
@@ -639,6 +640,11 @@ GLOBAL_ENTRY(ia64_leave_kernel)
 .mem.offset 0,0; st8.spill [r2]=r30,16
 .mem.offset 8,0; st8.spill [r3]=r31,16
 	;;
+	mov r3=ar.unat
+	movl r2=XSI_B1NAT
+	;;
+	st8 [r2]=r3
+	mov ar.unat=r15
 	movl r2=XSI_BANKNUM;;
 	st4 [r2]=r0;
 #else
diff -puN arch/ia64/xen/xenivt.S~14804-IA64_Handle_NAT_bit_for_dom0_and_domU arch/ia64/xen/xenivt.S
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xenivt.S~14804-IA64_Handle_NAT_bit_for_dom0_and_domU	2007-06-07 02:44:32.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xenivt.S	2007-06-07 02:44:32.000000000 -0400
@@ -2013,33 +2013,6 @@ END(ia32_interrupt)
 	DBG_FAULT(66)
 	FAULT(66)
 
-#ifdef CONFIG_XEN
-	/*
-	 * There is no particular reason for this code to be here, other than that
-	 * there happens to be space here that would go unused otherwise.  If this
-	 * fault ever gets "unreserved", simply moved the following code to a more
-	 * suitable spot...
-	 */
-
-GLOBAL_ENTRY(xen_bsw1)
-	/* FIXME: THIS CODE IS NOT NaT SAFE! */
-	movl r30=XSI_BANKNUM;
-	mov r31=1;;
-	st4 [r30]=r31;
-	movl r30=XSI_BANK1_R16;
-	movl r31=XSI_BANK1_R16+8;;
-	ld8 r16=[r30],16; ld8 r17=[r31],16;;
-	ld8 r18=[r30],16; ld8 r19=[r31],16;;
-	ld8 r20=[r30],16; ld8 r21=[r31],16;;
-	ld8 r22=[r30],16; ld8 r23=[r31],16;;
-	ld8 r24=[r30],16; ld8 r25=[r31],16;;
-	ld8 r26=[r30],16; ld8 r27=[r31],16;;
-	ld8 r28=[r30],16; ld8 r29=[r31],16;;
-	ld8 r30=[r30]; ld8 r31=[r31];;
-	br.ret.sptk.many b0
-END(xen_bsw1)
-#endif
-
 	.org ia64_ivt+0x7f00
 /////////////////////////////////////////////////////////////////////////////////////////
 // 0x7f00 Entry 67 (size 16 bundles) Reserved
@@ -2167,4 +2140,38 @@ GLOBAL_ENTRY(xen_event_callback)
 	(p6) br.spnt.few 1b	// call evtchn_do_upcall again.
 	br.sptk.many ia64_leave_kernel
 END(xen_event_callback)
+
+
+	/*
+	 * There is no particular reason for this code to be here, other than that
+	 * there happens to be space here that would go unused otherwise.  If this
+	 * fault ever gets "unreserved", simply moved the following code to a more
+	 * suitable spot...
+	 */
+
+GLOBAL_ENTRY(xen_bsw1)
+	/* FIXME: THIS CODE IS NOT NaT SAFE! */
+	mov r14=ar.unat
+	movl r30=XSI_B1NAT
+	;;
+	ld8 r30=[r30];;
+	mov ar.unat=r30
+	movl r30=XSI_BANKNUM;
+	mov r31=1;;
+	st4 [r30]=r31;
+	movl r30=XSI_BANK1_R16;
+	movl r31=XSI_BANK1_R16+8;;
+	ld8.fill r16=[r30],16; ld8.fill r17=[r31],16;;
+	ld8.fill r18=[r30],16; ld8.fill r19=[r31],16;;
+	ld8.fill r20=[r30],16; ld8.fill r21=[r31],16;;
+	ld8.fill r22=[r30],16; ld8.fill r23=[r31],16;;
+	ld8.fill r24=[r30],16; ld8.fill r25=[r31],16;;
+	ld8.fill r26=[r30],16; ld8.fill r27=[r31],16;;
+	ld8.fill r28=[r30],16; ld8.fill r29=[r31],16;;
+	ld8.fill r30=[r30]; ld8.fill r31=[r31];;
+	mov ar.unat=r14
+	br.ret.sptk.many b0
+END(xen_bsw1)
+
+
 #endif
diff -puN include/asm-ia64/xen/privop.h~14804-IA64_Handle_NAT_bit_for_dom0_and_domU include/asm-ia64/xen/privop.h
--- linux-2.6.18-21.el5-gerd-order/include/asm-ia64/xen/privop.h~14804-IA64_Handle_NAT_bit_for_dom0_and_domU	2007-06-07 02:44:32.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/include/asm-ia64/xen/privop.h	2007-06-07 02:44:32.000000000 -0400
@@ -57,6 +57,7 @@
 #define XSI_PSR_IC		(XSI_BASE + XSI_PSR_IC_OFS)
 #define XSI_IPSR		(XSI_BASE + XSI_IPSR_OFS)
 #define XSI_IIP			(XSI_BASE + XSI_IIP_OFS)
+#define XSI_B1NAT		(XSI_BASE + XSI_B1NATS_OFS)
 #define XSI_BANK1_R16		(XSI_BASE + XSI_BANK1_R16_OFS)
 #define XSI_BANKNUM		(XSI_BASE + XSI_BANKNUM_OFS)
 #define XSI_IHA			(XSI_BASE + XSI_IHA_OFS)

_

