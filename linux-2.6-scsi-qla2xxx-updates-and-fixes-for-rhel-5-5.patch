From: Marcus Barrow <mbarrow@redhat.com>
Date: Fri, 9 Oct 2009 15:50:58 -0400
Subject: [scsi] qla2xxx: updates and fixes for RHEL-5.5
Message-id: <20091009155057.24275.73560.sendpatchset@file.bos.redhat.com>
Patchwork-id: 21078
O-Subject: [rhel 5.5 patch] qla2xxx - initial 5.5 fixes from testing.
Bugzilla: 519447
RH-Acked-by: Tomas Henzl <thenzl@redhat.com>

BZ 519447

This patch contains the initial updates to the qla2xxx driver for 5.5.. These updates address issues found during testing by QLogic and our partners.

I have included the upstream commit numbers where I have found them. We push everything relevent upstream first usually, but when problems are found in rhel testing the fixes may get here first.

It applies and builds cleanly with 2.6.18-165.


qla2xxx - Initial rhel 5.5 updates. 8.03.01.02.05.05-k

 - Fix qla2x00_eh_wait_on_command to wait correctly
   d970432c48ab8dd28216e80942723aeb505b623e

 - Do not wait for command on non EH path

 - Correctly set FCF_TAPE_PRESENT flag based on scsi-device
   8474f3a02a18e18459663ad88951822c62a45068

 - Further limit device-table (qla_devtbl) lookup to non-24xx
   ab67114935d611caffe18063d1777f8c4f8b4272

 - Avoid panic if application requests AEN on deleted vport
   rhel 5 specific.

 - Process VP DPC only if topology is Fabric

 - Perform an implicit login to the Management Server
   e1f916035f149540e5090207ceafca9ba779084e

 - Properly handle UNDERRUN. Fixes-BZ-480315
 - Fix DEBUG compilation errors
 - Get FW versions when MPI is responding, FCoE fix
 - Fix garbage character at the end of port name

 - Fix compilation warnings on PPC

 - Correct Multi ID IOCBs structure definition

 - Ensure Vports rport delete on isp abort
   rhel 5 specific

 - Updated version to 8.03.01.02.05.05-k
   c59c61493febac295e71a2c017fc0075620dbc6f

diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index 3e7bf14..dd41c52 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -1593,8 +1593,9 @@ static ssize_t
 qla24xx_node_name(struct class_device *cdev, char *buf)
 {
 	scsi_qla_host_t *ha = to_qla_host(class_to_shost(cdev));
-	uint8_t fc_wwnn_str[16];
+	uint8_t fc_wwnn_str[17];
 
+	memset(fc_wwnn_str, 0, 17);
 	fc_convert_hex_char(ha->node_name, fc_wwnn_str, WWN_SIZE);
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", fc_wwnn_str);
@@ -1604,8 +1605,9 @@ static ssize_t
 qla24xx_port_name(struct class_device *cdev, char *buf)
 {
 	scsi_qla_host_t *ha = to_qla_host(class_to_shost(cdev));
-	uint8_t fc_wwpn_str[16];
+	uint8_t fc_wwpn_str[17];
 
+	memset(fc_wwpn_str, 0, 17);
 	fc_convert_hex_char(ha->port_name, fc_wwpn_str, WWN_SIZE);
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", fc_wwpn_str);
@@ -1616,8 +1618,9 @@ qla24xx_vport_id_show(struct class_device *cdev, char *buf)
 {
 	scsi_qla_host_t *ha = to_qla_host(class_to_shost(cdev));
 	uint8_t fc_vport_id[2];
-	uint8_t fc_vport_id_str[4];
-	
+	uint8_t fc_vport_id_str[5];
+
+	memset(fc_vport_id_str, 0, 5);	
 	fc_vport_id[0] = (ha->vp_idx & 0xff00) >> 0x08;
 	fc_vport_id[1] = ha->vp_idx & 0xff;
 
@@ -1665,11 +1668,12 @@ qla24xx_symbolic_port_name_show(struct class_device *cdev, char *buf)
 {
 	int	len = 0;
 	char	fw_str[30];
-	char	fc_vp_idx_str[4];
+	char	fc_vp_idx_str[5];
 	uint8_t	vp_idx[2];
 
 	scsi_qla_host_t *ha = to_qla_host(class_to_shost(cdev));
-
+	
+	memset(fc_vp_idx_str, 0, 5);
 	len = snprintf(buf, PAGE_SIZE, ha->model_number);
 	len += snprintf(buf + len, PAGE_SIZE, " FW:");
 	len += snprintf(buf + len, PAGE_SIZE,
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 599769b..f5745d7 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -1703,6 +1703,7 @@ typedef struct fc_port {
 #define FCF_DSXXX_DEVICE	BIT_23
 #define FCF_AA_EVA_DEVICE	BIT_24
 #define FCF_AA_MSA_DEVICE	BIT_25
+#define FCF_FCP2_DEVICE		BIT_26
 
 /* No loop ID flag. */
 #define FC_NO_LOOP_ID		0x1000
@@ -2570,7 +2571,7 @@ typedef struct scsi_qla_host {
 	dma_addr_t	edc_data_dma;
 	uint16_t	edc_data_len;
 
-#define DCBX_TLV_DATA_SIZE PAGE_SIZE
+#define DCBX_TLV_DATA_SIZE 4096 /* Page size */
 	void		*dcbx_tlv;
 	dma_addr_t	dcbx_tlv_dma;
 
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index cb40a78..65b566c 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -1016,22 +1016,6 @@ struct mid_db_entry_24xx {
 	uint8_t reserved_1;
 };
 
- /*
- * Virtual Fabric ID type definition.
- */
-typedef struct vf_id {
-        uint16_t id : 12;
-        uint16_t priority : 4;
-} vf_id_t;
-
-/*
- * Virtual Fabric HopCt type definition.
- */
-typedef struct vf_hopct {
-        uint16_t reserved : 8;
-        uint16_t hopct : 8;
-} vf_hopct_t;
-
 /*
  * Virtual Port Control IOCB
  */
@@ -1056,17 +1040,17 @@ struct vp_ctrl_entry_24xx {
 #define VCE_COMMAND_DISABLE_VPS	0x08	/* Disable VPs. */
 #define VCE_COMMAND_DISABLE_VPS_REINIT	0x09 /* Disable VPs and reinit link. */
 #define VCE_COMMAND_DISABLE_VPS_LOGO	0x0a /* Disable VPs and LOGO ports. */
-#define VCE_COMMAND_DISABLE_VPS_LOGO_ALL	0x0b	/* Disable VPs & LOGO */
+#define VCE_COMMAND_DISABLE_VPS_LOGO_ALL	0x0b /* Disable VPs and
+							LOGO ports. */
 
 	uint16_t vp_count;
 
 	uint8_t vp_idx_map[16];
-
 	uint16_t flags;
-	struct vf_id    id;
+	uint16_t id;
 	uint16_t reserved_4;
-	struct vf_hopct  hopct;
-	uint8_t reserved_5[8];
+	uint16_t hopct;
+	uint8_t reserved_5[24];
 };
 
 /*
@@ -1095,7 +1079,8 @@ struct vp_config_entry_24xx {
 
 	uint8_t command;
 #define VCT_COMMAND_MOD_VPS	0x00	/* Modify VP configurations. */
-#define VCT_COMMAND_MOD_ENABLE_VPS	0x01	/* above cmd + enable VPs. */
+#define VCT_COMMAND_MOD_ENABLE_VPS	0x01	/* Modify configuration
+						   & enable VPs. */
 
 	uint8_t vp_count;
 
@@ -1113,11 +1098,10 @@ struct vp_config_entry_24xx {
 	uint16_t reserved_vp2;
 	uint8_t port_name_idx2[WWN_SIZE];
 	uint8_t node_name_idx2[WWN_SIZE];
-
-	struct vf_id    id;
+	uint16_t id;
 	uint16_t reserved_4;
-	struct vf_hopct  hopct;
-	uint8_t reserved_5;
+	uint16_t hopct;
+	uint8_t reserved_5[2];
 };
 
 #define VP_RPT_ID_IOCB_TYPE	0x32	/* Report ID Acquisition entry. */
diff --git a/drivers/scsi/qla2xxx/qla_gs.c b/drivers/scsi/qla2xxx/qla_gs.c
index db04b18..eba7ad1 100644
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@ -1110,7 +1110,7 @@ qla2x00_mgmt_svr_login(scsi_qla_host_t *ha)
 		return ret;
 
 	ha->isp_ops->fabric_login(ha, ha->mgmt_svr_loop_id, 0xff, 0xff, 0xfa,
-	    mb, BIT_1);
+	    mb, BIT_1 | BIT_0);
 	if (mb[0] != MBS_COMMAND_COMPLETE) {
 		DEBUG2_13(printk("%s(%ld): Failed MANAGEMENT_SERVER login: "
 		    "loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x\n",
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 2feb01d..a64fdf8 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -1605,7 +1605,8 @@ qla2x00_set_model_info(scsi_qla_host_t *ha, uint8_t *model, size_t len, char *de
 {
 	char *st, *en;
 	uint16_t index;
-	int use_tbl = !IS_QLA25XX(ha) && !IS_QLA81XX(ha);
+	int use_tbl = !IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&
+	    !IS_QLA81XX(ha);
 
 	if (memcmp(model, BINZERO, len) != 0) {
 		strncpy(ha->model_number, model, len);
@@ -3129,7 +3130,7 @@ qla2x00_fabric_login(scsi_qla_host_t *ha, fc_port_t *fcport,
 			} else {
 				fcport->port_type = FCT_TARGET;
 				if (mb[1] & BIT_1) {
-					fcport->flags |= FCF_TAPE_PRESENT;
+					fcport->flags |= FCF_FCP2_DEVICE;
 				}
 			}
 
@@ -3377,6 +3378,16 @@ qla2x00_abort_isp(scsi_qla_host_t *ha)
 			ha->isp_abort_cnt = 0;
 			clear_bit(ISP_ABORT_RETRY, &ha->dpc_flags);
 
+			if (IS_QLA81XX(ha))
+				/* Update the FW versions */
+				qla2x00_get_fw_version(ha,
+				    &ha->fw_major_version,
+				    &ha->fw_minor_version,
+				    &ha->fw_subminor_version,
+				    &ha->fw_attributes, &ha->fw_memory_size,
+				    ha->mpi_version, &ha->mpi_capabilities,
+				    ha->phy_version);
+
 			if (ha->eft) {
 				rval = qla2x00_trace_control(ha, TC_ENABLE,
 				    ha->eft_dma, EFT_NUM_BUFFERS);
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index a15e66f..5021c27 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -1047,16 +1047,22 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 
 	sense_len = rsp_info_len = resid_len = fw_resid_len = 0;
 	if (IS_FWI2_CAPABLE(ha)) {
-		sense_len = le32_to_cpu(sts24->sense_len);
-		rsp_info_len = le32_to_cpu(sts24->rsp_data_len);
-		resid_len = le32_to_cpu(sts24->rsp_residual_count);
-		fw_resid_len = le32_to_cpu(sts24->residual_len);
+		if (scsi_status & SS_SENSE_LEN_VALID)
+			sense_len = le32_to_cpu(sts24->sense_len);
+		if (scsi_status & SS_RESPONSE_INFO_LEN_VALID)
+			rsp_info_len = le32_to_cpu(sts24->rsp_data_len);
+		if (scsi_status & (SS_RESIDUAL_UNDER | SS_RESIDUAL_OVER))
+			resid_len = le32_to_cpu(sts24->rsp_residual_count);
+		if (comp_status == CS_DATA_UNDERRUN)
+			fw_resid_len = le32_to_cpu(sts24->residual_len);
 		rsp_info = sts24->data;
 		sense_data = sts24->data;
 		host_to_fcp_swap(sts24->data, sizeof(sts24->data));
 	} else {
-		sense_len = le16_to_cpu(sts->req_sense_length);
-		rsp_info_len = le16_to_cpu(sts->rsp_info_len);
+		if (scsi_status & SS_SENSE_LEN_VALID)
+			sense_len = le16_to_cpu(sts->req_sense_length);
+		if (scsi_status & SS_RESPONSE_INFO_LEN_VALID)
+			rsp_info_len = le16_to_cpu(sts->rsp_info_len);
 		resid_len = le32_to_cpu(sts->residual_length);
 		rsp_info = sts->rsp_info;
 		sense_data = sts->req_sense_data;
@@ -1144,38 +1150,68 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 		break;
 
 	case CS_DATA_UNDERRUN:
-		resid = resid_len;
-		/* Use F/W calculated residual length. */
-		if (IS_FWI2_CAPABLE(ha)) {
-			if (!(scsi_status & SS_RESIDUAL_UNDER)) {
-				lscsi_status = 0;
-			} else if (resid != fw_resid_len) {
-				scsi_status &= ~SS_RESIDUAL_UNDER;
-				lscsi_status = 0;
-			}
-			resid = fw_resid_len;
-		}
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld:%d:%d) UNDERRUN status detected: "
+		    "0x%x-0x%x. resid=0x%x fw_resid=0x%x cdb=0x%x "
+		    "os_underflow=0x%x srb_flags=0x%x\n", ha->host_no,
+		    cp->device->id, cp->device->lun, comp_status,
+		    scsi_status, resid_len, fw_resid_len, cp->cmnd[0],
+		    cp->underflow, sp->flags));
 
+		/* Use F/W calculated residual length. */
+		resid = IS_FWI2_CAPABLE(ha) ? fw_resid_len : resid_len;
+		scsi_set_resid(cp, resid);
 		if (scsi_status & SS_RESIDUAL_UNDER) {
-			scsi_set_resid(cp, resid);
 			CMD_RESID_LEN(cp) = resid;
-		} else {
-			DEBUG2(printk(KERN_INFO
-			    "scsi(%ld:%d:%d) UNDERRUN status detected "
-			    "0x%x-0x%x. resid=0x%x fw_resid=0x%x cdb=0x%x "
-			    "os_underflow=0x%x\n", ha->host_no,
-			    cp->device->id, cp->device->lun, comp_status,
-			    scsi_status, resid_len, resid, cp->cmnd[0],
-			    cp->underflow));
+			if (IS_FWI2_CAPABLE(ha) && fw_resid_len != resid_len) {
+				DEBUG2(printk("scsi(%ld:%d:%d:%d) Dropped "
+				    "frame(s) detected (0x%x of 0x%x bytes)..."
+				    "residual length mismatch...retrying"
+				    " command.\n", ha->host_no,
+				    cp->device->channel, cp->device->id,
+				    cp->device->lun, resid, scsi_bufflen(cp)));
+
+				cp->result = DID_ERROR << 16 | lscsi_status;
+				break;
+			}
+
+			if (!lscsi_status &&
+			    ((unsigned)(scsi_bufflen(cp) - resid) <
+			    cp->underflow)) {
+				qla_printk(KERN_INFO, ha,
+				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
+				    "detected (%x of %x bytes)...returning "
+				    "error status.\n", ha->host_no,
+				    cp->device->channel, cp->device->id,
+				    cp->device->lun, resid,
+				    scsi_bufflen(cp));
+
+				cp->result = DID_ERROR << 16;
+				break;
+			}
+		} else if (!lscsi_status) {
+			/*
+			 * If RISC reports underrun and target does not report
+			 * it then we must have a lost frame, so tell upper
+			 * layer to retry it by reporting an error.
+			 */
+			DEBUG2(printk("scsi(%ld:%d:%d:%d) Dropped "
+			    "frame(s) detected (0x%x of 0x%x bytes)..."
+			    "firmware reported underrun...retrying command.\n",
+			    ha->host_no, cp->device->channel, cp->device->id,
+			    cp->device->lun, resid, scsi_bufflen(cp)));
 
+			cp->result = DID_ERROR << 16;
+			break;
 		}
 
+		cp->result = DID_OK << 16 | lscsi_status;
+
 		/*
 		 * Check to see if SCSI Status is non zero. If so report SCSI
 		 * Status.
 		 */
 		if (lscsi_status != 0) {
-			cp->result = DID_OK << 16 | lscsi_status;
 
 			if (lscsi_status == SAM_STAT_TASK_SET_FULL) {
 				DEBUG2(printk(KERN_INFO
@@ -1204,60 +1240,6 @@ qla2x00_status_entry(scsi_qla_host_t *ha, void *pkt)
 				break;
 
 			qla2x00_handle_sense(sp, sense_data, sense_len);
-
-			/*
-			 * In case of a Underrun condition, set both the lscsi
-			 * status and the completion status to appropriate
-			 * values.
-			 */
-			if (resid &&
-			    ((unsigned)(scsi_bufflen(cp) - resid) <
-			     cp->underflow)) {
-				DEBUG2(qla_printk(KERN_INFO, ha,
-				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
-				    "detected (%x of %x bytes)...returning "
-				    "error status.\n", ha->host_no,
-				    cp->device->channel, cp->device->id,
-				    cp->device->lun, resid,
-				    scsi_bufflen(cp)));
-
-				cp->result = DID_ERROR << 16 | lscsi_status;
-			}
-		} else {
-			/*
-			 * If RISC reports underrun and target does not report
-			 * it then we must have a lost frame, so tell upper
-			 * layer to retry it by reporting a did error.
-			 */
-			if (!(scsi_status & SS_RESIDUAL_UNDER)) {
-				DEBUG2(printk("scsi(%ld:%d:%d:%d) Dropped "
-					      "frame(s) detected (%x of %x bytes)..."
-					      "retrying command.\n", ha->host_no,
-					      cp->device->channel, cp->device->id,
-					      cp->device->lun, resid,
-					      scsi_bufflen(cp)));
-				scsi_set_resid(cp, resid);
-				cp->result = DID_ERROR << 16;
-				break;
-			}
-
-			/* Handle mid-layer underflow */
-			if ((unsigned)(scsi_bufflen(cp) - resid) <
-			    cp->underflow) {
-				qla_printk(KERN_INFO, ha,
-					   "scsi(%ld:%d:%d:%d): Mid-layer underflow "
-					   "detected (%x of %x bytes)...returning "
-					   "error status.\n", ha->host_no,
-					   cp->device->channel, cp->device->id,
-					   cp->device->lun, resid,
-					   scsi_bufflen(cp));
-
-				cp->result = DID_ERROR << 16;
-				break;
-			}
-
-			/* Everybody online, looking good... */
-			cp->result = DID_OK << 16;
 		}
 		break;
 
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 495c42e..870a0c8 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -3352,7 +3352,7 @@ qla2x00_loopback_test(scsi_qla_host_t *ha, struct msg_loopback *req,
 	mbx_cmd_t	*mcp = &mc;
 
 	DEBUG11(printk("%s(%ld): Options=%x iterations=%x MAILBOX_CNT=%d.\n",
-	     __func__, ha->host_no, req->Options, req->IterationCount,
+	     __func__, ha->host_no, req->options, req->iter_cnt,
 	     MAILBOX_REGISTER_COUNT));
 
 	memset(mcp->mb, 0 , sizeof(mcp->mb));
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index 601c72a..73cc416 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -314,6 +314,9 @@ qla2x00_do_dpc_all_vps(scsi_qla_host_t *ha)
 
 	clear_bit(VP_DPC_NEEDED, &ha->dpc_flags);
 
+	if (!(ha->current_topology & ISP_CFG_F))
+			return;
+
 	for_each_mapped_vp_idx(ha, i) {
 		vp_idx_matched = 0;
 
diff --git a/drivers/scsi/qla2xxx/qla_nlnk.c b/drivers/scsi/qla2xxx/qla_nlnk.c
index 049b622..05fa342 100644
--- a/drivers/scsi/qla2xxx/qla_nlnk.c
+++ b/drivers/scsi/qla2xxx/qla_nlnk.c
@@ -607,7 +607,7 @@ ql_fc_proc_nl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, int rcvlen)
 		return -EBADMSG;
 
 	shost = scsi_host_lookup(ql_cmd->host_no);
-	if (IS_ERR(shost)) {
+	if (!shost) {
 		DEBUG16(printk(KERN_ERR "%s: could not find host no %u\n",
 		    __func__, ql_cmd->host_no));
 		err = -ENODEV;
@@ -627,16 +627,19 @@ ql_fc_proc_nl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, int rcvlen)
 		rsp_hdr_len = offsetof(struct qla_fc_msg, u);
 		ql_cmd->error = 0;
 		ql_fc_get_aen(ha);
-		return ql_fc_nl_rsp(NETLINK_CREDS(skb)->pid, nlh->nlmsg_seq,
+		err =  ql_fc_nl_rsp(NETLINK_CREDS(skb)->pid, nlh->nlmsg_seq,
 			(uint32_t)nlh->nlmsg_type, ql_cmd, rsp_hdr_len,
 			&aen_log, sizeof(struct qlfc_aen_log));
+		goto exit_proc_nl_rcv_msg;
 
 	case QLFC_LOOPBACK_CMD:
 	case QLFC_LOOPBACK_DATA:
-		return ql_fc_loopback(ha, skb, nlh, ql_cmd, rcvlen);
+		err = ql_fc_loopback(ha, skb, nlh, ql_cmd, rcvlen);
+		goto exit_proc_nl_rcv_msg;
 
 	case QLFC_IIDMA:
-		return ql_fc_iidma(ha, skb, nlh, ql_cmd, rcvlen);
+		err = ql_fc_iidma(ha, skb, nlh, ql_cmd, rcvlen);
+		goto exit_proc_nl_rcv_msg;
 	}
 
 	/* Use existing 84xx interface to get MPI XGMAC statistics for
@@ -690,6 +693,8 @@ ql_fc_proc_nl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, int rcvlen)
 	}
 
 exit_proc_nl_rcv_msg:
+	if (shost)
+		scsi_host_put(shost);
 	return err;
 }
 
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 89e5a6e..b1aa938 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -567,11 +567,8 @@ qla2x00_eh_wait_on_command(scsi_qla_host_t *ha, struct scsi_cmnd *cmd)
 		return ret;
 	}
 
-	while (CMD_SP(cmd)) {
+	while (CMD_SP(cmd) && wait_iter--) {
 		msleep(ABORT_POLLING_PERIOD);
-
-		if (--wait_iter)
-			break;
 	}
 	if (CMD_SP(cmd))
 		ret = QLA_FUNCTION_FAILED;
@@ -739,6 +736,14 @@ qla2x00_abort_fcport_cmds(fc_port_t *fcport)
 	spin_unlock_irqrestore(&pha->hardware_lock, flags);
 }
 
+static int
+qla2x00_is_eh_active(struct Scsi_Host *shost)
+{
+	if (shost->shost_state == SHOST_RECOVERY)
+		return 1;
+	return 0;
+}
+
 static void
 qla2x00_block_error_handler(struct scsi_cmnd *cmnd)
 {
@@ -868,6 +873,9 @@ qla2x00_eh_wait_for_pending_target_commands(scsi_qla_host_t *ha, unsigned int t)
 
 	status = 0;
 
+	if (!qla2x00_is_eh_active(ha->host))
+		return status;
+
 	/*
 	 * Waiting for all commands for the designated target in the active
 	 * array
@@ -1006,6 +1014,9 @@ qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *ha)
 
 	status = 1;
 
+	if (!qla2x00_is_eh_active(ha->host))
+		return status;
+
 	/*
 	 * Waiting for all commands for the designated target in the active
 	 * array
@@ -1287,6 +1298,7 @@ qla2xxx_slave_configure(struct scsi_device *sdev)
 {
 	scsi_qla_host_t *ha = to_qla_host(sdev->host);
 	struct fc_rport *rport = starget_to_rport(sdev->sdev_target);
+	fc_port_t *fcport = *(fc_port_t **)rport->dd_data;
 
 	if (sdev->tagged_supported)
 		scsi_activate_tcq(sdev, ha->max_q_depth);
@@ -1294,6 +1306,8 @@ qla2xxx_slave_configure(struct scsi_device *sdev)
 		scsi_deactivate_tcq(sdev, ha->max_q_depth);
 
 	rport->dev_loss_tmo = ha->port_down_retry_count;
+	if (sdev->type == TYPE_TAPE)
+		fcport->flags |= FCF_TAPE_PRESENT;
 
 	return 0;
 }
@@ -2292,7 +2306,7 @@ qla2x00_mark_all_devices_lost(scsi_qla_host_t *ha, int defer)
 	scsi_qla_host_t *pha = to_qla_parent(ha);
 
 	list_for_each_entry(fcport, &pha->fcports, list) {
-		if (ha->vp_idx != 0 && ha->vp_idx != fcport->vp_idx)
+		if (ha->vp_idx != fcport->vp_idx)
 			continue;
 
 		/*
@@ -2301,12 +2315,9 @@ qla2x00_mark_all_devices_lost(scsi_qla_host_t *ha, int defer)
 		 */
 		if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD)
 			continue;
-		if (atomic_read(&fcport->state) == FCS_ONLINE) {
-			if (defer)
-				qla2x00_schedule_rport_del(ha, fcport, defer);
-			else if (ha->vp_idx == fcport->vp_idx)
-				qla2x00_schedule_rport_del(ha, fcport, defer);
-		}
+		if (atomic_read(&fcport->state) == FCS_ONLINE)
+			qla2x00_schedule_rport_del(ha, fcport, defer);
+
 		atomic_set(&fcport->state, FCS_DEVICE_LOST);
 	}
 
diff --git a/drivers/scsi/qla2xxx/qla_sup.c b/drivers/scsi/qla2xxx/qla_sup.c
index a96bd14..2c89255 100644
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@ -937,7 +937,8 @@ qla2xxx_flash_npiv_conf(scsi_qla_host_t *ha)
 		wwnn = wwn_to_u64(entry->node_name);
 
 		DEBUG2(qla_printk(KERN_DEBUG, ha, "NPIV[%02x]: wwpn=%llx "
-		    "wwnn=%llx vf_id=0x%x qos=0x%x.\n", cnt, wwpn, wwnn,
+		    "wwnn=%llx vf_id=0x%x qos=0x%x.\n", cnt,
+		    (unsigned long long)wwpn, (unsigned long long)wwnn,
 		    le16_to_cpu(entry->vf_id), le16_to_cpu(entry->qos)));
 
 		qla24xx_vport_create(ha, wwpn, wwnn);
@@ -1065,7 +1066,8 @@ qla24xx_write_flash_data(scsi_qla_host_t *ha, uint32_t *dwptr, uint32_t faddr,
 				    0xff0000) | ((fdata >> 16) & 0xff));
                         ret = qla24xx_erase_sector(ha, fdata);
                         if (ret != QLA_SUCCESS) {
-                                DEBUG9(qla_printk("Unable to erase sector: "
+				DEBUG9(qla_printk(KERN_ERR, ha,
+				    "Unable to erase sector: "
                                     "address=%x.\n", faddr));
                                 break;
                         }
diff --git a/drivers/scsi/qla2xxx/qla_version.h b/drivers/scsi/qla2xxx/qla_version.h
index 02298e1..ed31feb 100644
--- a/drivers/scsi/qla2xxx/qla_version.h
+++ b/drivers/scsi/qla2xxx/qla_version.h
@@ -7,7 +7,7 @@
 /*
  * Driver version
  */
-#define QLA2XXX_VERSION      "8.03.00.1.05.05-k"
+#define QLA2XXX_VERSION      "8.03.01.02.05.05-k"
 
 #define QLA_DRIVER_MAJOR_VER	8
 #define QLA_DRIVER_MINOR_VER	3
