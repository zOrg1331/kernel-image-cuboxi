From: Mauro Carvalho Chehab <mchehab@redhat.com>
Date: Tue, 28 Sep 2010 14:34:20 -0400
Subject: [edac] i7300_edac: properly init per-csrow memory size
Message-id: <20100928113420.66abefa9@pedra>
Patchwork-id: 28458
O-Subject: [PATCH RHEL5 27/27] i7300_edac: Properly initialize per-csrow
	memory size
Bugzilla: 487428
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

Due to the current edac-core limits, we cannot represent a per-channel
memory size, for FB-DIMM drivers. So, we need to sum-up all values
for each slot, in order to properly represent the total amount of
memory found by the i7300 driver.

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 3053a3f..4a9fdde 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -612,7 +612,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,
 		      struct i7300_dimm_info *dinfo,
 		      struct csrow_info *p_csrow,
-		      u32 *last_page)
+		      u32 *nr_pages)
 {
 	int mtr, ans, addrBits, channel;
 
@@ -644,6 +644,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	addrBits -= 3;	/* 8 bits per bytes */
 
 	dinfo->megabytes = 1 << addrBits;
+	*nr_pages = dinfo->megabytes << 8;
 
 	debugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));
 
@@ -657,12 +658,8 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
 
 	p_csrow->grain = 8;
-	p_csrow->nr_pages = dinfo->megabytes << 8;
 	p_csrow->mtype = MEM_FB_DDR2;
 	p_csrow->csrow_idx = slot;
-	p_csrow->first_page = *last_page;
-	*last_page += p_csrow->nr_pages;
-	p_csrow->last_page = *last_page;
 	p_csrow->page_mask = 0;
 
 	/*
@@ -775,7 +772,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	int rc = -ENODEV;
 	int mtr;
 	int ch, branch, slot, channel;
-	u32 last_page = 0;
+	u32 last_page = 0, nr_pages;
 
 	pvt = mci->pvt_info;
 
@@ -813,11 +810,17 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 				p_csrow = &mci->csrows[slot];
 
 				mtr = decode_mtr(pvt, slot, ch, branch,
-						 dinfo, p_csrow, &last_page);
+						 dinfo, p_csrow, &nr_pages);
 				/* if no DIMMS on this row, continue */
 				if (!MTR_DIMMS_PRESENT(mtr))
 					continue;
 
+				/* Update per_csrow memory count */
+				p_csrow->nr_pages += nr_pages;
+				p_csrow->first_page = last_page;
+				last_page += nr_pages;
+				p_csrow->last_page = last_page;
+
 				rc = 0;
 			}
 		}
