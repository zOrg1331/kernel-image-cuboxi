From: Chad Dupuis <cdupuis@redhat.com>
Date: Tue, 30 Nov 2010 20:01:07 -0500
Subject: [scsi] qla4xxx: free DDB when application calls for it
Message-id: <20101130200107.10450.72213.sendpatchset@localhost.localdomain>
Patchwork-id: 29715
O-Subject: [RHEL 5.6 PATCH 24/28] qla4xxx: Freeing DDB explicitly when
	application calls to free it.
Bugzilla: 656999

Bugzilla
--------

Bug 656999 (https://bugzilla.redhat.com/show_bug.cgi?id=656999)

Upstream Status
---------------

RHEL 5 specific.

Description
-----------

>From 6f31462c868d85f6edd754db3a3bcf74ff417f64 Mon Sep 17 00:00:00 2001
From: Prasanna Mumbai <prasanna.mumbai@qlogic.com>
Date: Tue, 23 Nov 2010 11:32:30 -0800
Subject: [PATCH 25/29] qla4xxx: Freeing DDB explicitly when application calls to free it.

The mailbox commands used to free DDBs (MBOX_CMD_FREE_DATABASE_ENTRY (0x31)
MBOX_CMD_CONN_CLOSE (0x56)) do not result in an AEN, so we need to explicitly
check for successful completion of those mailbox commands and remove the
corresponding internal ddb structure accordingly.

Signed-off-by: Prasanna Mumbai <prasanna.mumbai@qlogic.com>

diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index 3e422bb..e1dce66 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -395,6 +395,7 @@ struct scsi_qla_host {
 #define DPC_AEN				9 /* 0x00000200 */
 #define DPC_GET_DHCP_IP_ADDR		15 /* 0x00008000 */
 #define DPC_ASYNC_MSG_PDU		16 /* 0x00010000 */
+#define DPC_REMOVE_DEVICE		17 /* 0x00020000 */
 #define DPC_LINK_CHANGED		19 /* 0x00020000 */
 #define DPC_RESET_ACTIVE		20 /* 0x00040000 */
 #define DPC_HA_UNRECOVERABLE	21 /* 0x00080000 ISP-82xx only*/
diff --git a/drivers/scsi/qla4xxx/ql4_fw.h b/drivers/scsi/qla4xxx/ql4_fw.h
index c8a3fa1..0513b2b 100644
--- a/drivers/scsi/qla4xxx/ql4_fw.h
+++ b/drivers/scsi/qla4xxx/ql4_fw.h
@@ -344,8 +344,11 @@ struct qla_flt_region {
 #define MBOX_CMD_COPY_FLASH			0x0024
 #define MBOX_CMD_WRITE_FLASH			0x0025
 #define MBOX_CMD_READ_FLASH			0x0026
-#define MBOX_CMD_CLEAR_DATABASE_ENTRY		0x0031
-#define MBOX_CMD_CONN_CLOSE_SESS_LOGOUT		0x0056
+#define MBOX_CMD_FREE_DATABASE_ENTRY		0x0031
+#define MBOX_CMD_CONN_CLOSE			0x0056
+	#define LOGOUT_OPTION_CLOSE_SESSION		0x02
+	#define LOGOUT_OPTION_RESET			0x04
+	#define LOGOUT_OPTION_FREE_DDB			0x08
 #define LOGOUT_OPTION_CLOSE_SESSION		0x02
 #define LOGOUT_OPTION_RESET			0x04
 #define MBOX_CMD_EXECUTE_IOCB_A64		0x005A
diff --git a/drivers/scsi/qla4xxx/ql4_inline.h b/drivers/scsi/qla4xxx/ql4_inline.h
index 4cc9f12..f51c552 100644
--- a/drivers/scsi/qla4xxx/ql4_inline.h
+++ b/drivers/scsi/qla4xxx/ql4_inline.h
@@ -52,6 +52,38 @@ qla4xxx_lookup_ddb_by_os_index(struct scsi_qla_host *ha, int os_idx)
 	return ddb_entry;
 }
 
+/**
+ * The mailbox commands used to free DDBs (MBOX_CMD_FREE_DATABASE_ENTRY (0x31)
+ * MBOX_CMD_CONN_CLOSE (0x56)) do not result in an AEN, so we need to explicitly
+ * check for successful completion of those mailbox commands and remove the
+ * corresponding internal ddb structure accordingly.
+ **/
+static inline void qla4xxx_check_for_free_ddb(struct scsi_qla_host *ha,
+		uint32_t *mbox_cmd)
+{
+	uint32_t fw_ddb_index;
+	struct ddb_entry *ddb_entry = NULL;
+
+	if (mbox_cmd[0] == MBOX_CMD_FREE_DATABASE_ENTRY ||
+	    (mbox_cmd[0] == MBOX_CMD_CONN_CLOSE &&
+	     mbox_cmd[3] & LOGOUT_OPTION_FREE_DDB)) {
+
+		fw_ddb_index = mbox_cmd[1];
+
+		if (fw_ddb_index < MAX_DDB_ENTRIES)
+			ddb_entry = ha->fw_ddb_index_map[fw_ddb_index];
+
+		if (ddb_entry != ((struct ddb_entry *)INVALID_ENTRY)) {
+			printk(KERN_INFO "%s: ddb[%d] os[%d] freed\n",
+				__func__, ddb_entry->fw_ddb_index,
+				ddb_entry->os_target_id);
+			set_bit(DF_REMOVE, &ddb_entry->flags);
+			set_bit(DPC_REMOVE_DEVICE, &ha->dpc_flags);
+			qla4xxx_wake_dpc(ha);
+		}
+	}
+}
+
 static inline void
 __qla4xxx_enable_intrs(struct scsi_qla_host *ha)
 {
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index dd8e66a..81bd773 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -237,6 +237,8 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 mbox_exit:
+	if (status == QLA_SUCCESS)
+		qla4xxx_check_for_free_ddb(ha, mbx_cmd);
 	mutex_lock(&ha->mbox_sem);
 	clear_bit(AF_MBOX_COMMAND, &ha->flags);
 	mutex_unlock(&ha->mbox_sem);
@@ -309,7 +311,7 @@ int qla4xxx_conn_close_sess_logout(struct scsi_qla_host * ha,
 	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
 	memset(&mbox_sts, 0, sizeof(mbox_sts));
 
-	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;
+	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE;
 	mbox_cmd[1] = fw_ddb_index;
 	mbox_cmd[2] = connection_id;
 	mbox_cmd[3] = option;
@@ -336,7 +338,7 @@ int qla4xxx_clear_database_entry(struct scsi_qla_host * ha,
 	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
 	memset(&mbox_sts, 0, sizeof(mbox_sts));
 
-	mbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;
+	mbox_cmd[0] = MBOX_CMD_FREE_DATABASE_ENTRY;
 	mbox_cmd[1] = fw_ddb_index;
 
 	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 823159a..fa5d11b 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -882,6 +882,7 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 	     test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||
 	     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
 	     test_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||
+	     test_bit(DPC_REMOVE_DEVICE, &ha->dpc_flags) ||
 		 test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||
 	     test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||
 		 test_bit(DPC_DYNAMIC_LUN_SCAN, &ha->dpc_flags) ||
@@ -1531,6 +1532,20 @@ dpc_post_reset_ha:
 		}
 	}
 
+	/* ---- remove device ? ---- */
+	if (test_and_clear_bit(DPC_REMOVE_DEVICE, &ha->dpc_flags)) {
+		list_for_each_entry_safe(ddb_entry, dtemp,
+			&ha->ddb_list, list) {
+			if (test_and_clear_bit(DF_REMOVE, &ddb_entry->flags)) {
+				printk(KERN_INFO
+					"%s: ddb[%d] os[%d] - removed\n",
+					__func__, ddb_entry->fw_ddb_index,
+					ddb_entry->os_target_id);
+				qla4xxx_free_ddb(ha, ddb_entry);
+			}
+		}
+	}
+
 	/* ---- relogin device? --- */
 	if (adapter_up(ha) &&
 	    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {
