From: Don Zickus <dzickus@lorax.boston.redhat.com>
Date: Thu, 10 Jan 2008 18:34:59 -0500
Subject: Revert: [misc] offlining a CPU with realtime process running
Message-id: pt-dummy.1200036509.671413759.dzickus@lorax.boston.redhat.com
O-Subject: Revert "[misc] offlining a CPU with realtime process running"
Bugzilla: 240232

This reverts '[misc] offlining a CPU with realtime process running'

diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h
index 20a73d8..bf62923 100644
--- a/include/linux/workqueue.h
+++ b/include/linux/workqueue.h
@@ -103,8 +103,4 @@ static inline int delayed_work_pending(struct work_struct *work)
 	return test_bit(0, &work->pending);
 }
 
-struct sched_param;
-extern int workqueue_setscheduler(struct workqueue_struct *wq, int policy,
-				  struct sched_param *param);
-
 #endif
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 48a2e3b..4f9c60e 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -121,17 +121,10 @@ static void keventd_create_kthread(void *_create)
 	if (pid < 0) {
 		create->result = ERR_PTR(pid);
 	} else {
-		struct sched_param param = { .sched_priority = 0 };
 		wait_for_completion(&create->started);
 		read_lock(&tasklist_lock);
 		create->result = find_task_by_pid(pid);
 		read_unlock(&tasklist_lock);
-		/*
-		 * We (the kthread wq) run with SCHED_FIFO, but we don't want
-		 * the kthreads we create to have it too by default.
-		 */
-		sched_setscheduler(create->result, SCHED_NORMAL, &param);
-		set_user_nice(create->result, -5);
 	}
 	complete(&create->done);
 }
@@ -251,11 +244,8 @@ EXPORT_SYMBOL(kthread_stop);
 
 static __init int helper_init(void)
 {
-	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
-
 	helper_wq = create_singlethread_workqueue("kthread");
 	BUG_ON(!helper_wq);
-	workqueue_setscheduler(helper_wq, SCHED_FIFO, &param);
 
 	return 0;
 }
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 270969e..8594efb 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -688,18 +688,6 @@ static int __devinit workqueue_cpu_callback(struct notifier_block *nfb,
 }
 #endif
 
-int workqueue_setscheduler(struct workqueue_struct *wq, int policy,
-			   struct sched_param *param)
-{
-	struct task_struct *t;
-
-	/* the only user of this (kthread.c) uses a singlethreaded wq */
-	BUG_ON(!is_single_threaded(wq));
-
-	t = per_cpu_ptr(wq->cpu_wq, singlethread_cpu)->thread;
-	return sched_setscheduler(t, policy, param);
-}
-
 void init_workqueues(void)
 {
 	singlethread_cpu = first_cpu(cpu_possible_map);
