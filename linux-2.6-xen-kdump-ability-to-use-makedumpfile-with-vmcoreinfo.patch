From: Neil Horman <nhorman@redhat.com>
Date: Mon, 18 Aug 2008 11:00:28 -0400
Subject: [xen] kdump: ability to use makedumpfile with vmcoreinfo
Message-id: 20080818150028.GE7052@hmsendeavour.rdu.redhat.com
O-Subject: [RHEL 5.3 PATCH] 2/2: xen: add ability for dom0 kernels to use makedumpfile with vmcoreinfo (bz 454498)
Bugzilla: 454498
RH-Acked-by: Bill Burns <bburns@redhat.com>
RH-Acked-by: Bill Burns <bburns@redhat.com>

Hey-
	The kernel portion of this patch

diff --git a/drivers/xen/core/machine_kexec.c b/drivers/xen/core/machine_kexec.c
index 2a44474..54bfe42 100644
--- a/drivers/xen/core/machine_kexec.c
+++ b/drivers/xen/core/machine_kexec.c
@@ -16,6 +16,9 @@ int xen_max_nr_phys_cpus;
 struct resource xen_hypervisor_res;
 struct resource *xen_phys_cpus;
 
+size_t vmcoreinfo_size_xen;
+unsigned long paddr_vmcoreinfo_xen;
+
 void xen_machine_kexec_setup_resources(void)
 {
 	xen_kexec_range_t range;
@@ -93,6 +96,18 @@ void xen_machine_kexec_setup_resources(void)
 		crashk_res.end = range.start + range.size - 1;
 	}
 
+	/* get physical address of vmcoreinfo */
+	memset(&range, 0, sizeof(range));
+	range.range = KEXEC_RANGE_MA_VMCOREINFO;
+
+	if (HYPERVISOR_kexec_op(KEXEC_CMD_kexec_get_range, &range))
+		return;
+
+	if (range.size) {
+		paddr_vmcoreinfo_xen = range.start;
+		vmcoreinfo_size_xen = range.size;
+	}
+
 	return;
 
  err:
diff --git a/drivers/xen/core/xen_sysfs.c b/drivers/xen/core/xen_sysfs.c
index fd8bfdb..eec5ec8 100644
--- a/drivers/xen/core/xen_sysfs.c
+++ b/drivers/xen/core/xen_sysfs.c
@@ -15,6 +15,7 @@
 #include <xen/features.h>
 #include <xen/hypervisor_sysfs.h>
 #include <xen/xenbus.h>
+#include <xen/interface/kexec.h>
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mike D. Day <ncmike@us.ibm.com>");
@@ -330,6 +331,33 @@ static void xen_properties_destroy(void)
 			   &xen_properties_group);
 }
 
+#ifdef CONFIG_KEXEC
+static ssize_t vmcoreinfo_show(struct hyp_sysfs_attr *attr, char *page)
+{
+	return sprintf(page, "%lx %zx\n",
+		paddr_vmcoreinfo_xen, vmcoreinfo_size_xen);
+}
+
+HYPERVISOR_ATTR_RO(vmcoreinfo);
+
+#endif
+
+static int __init xen_sysfs_vmcoreinfo_init(void)
+{
+#ifdef CONFIG_KEXEC
+	return sysfs_create_file(&hypervisor_subsys.kset.kobj, &vmcoreinfo_attr.attr);
+#else
+	return 0;
+#endif
+}
+
+static void xen_sysfs_vmcoreinfo_destroy(void)
+{
+#ifdef CONFIG_KEXEC
+	sysfs_remove_file(&hypervisor_subsys.kset.kobj, &vmcoreinfo_attr.attr);
+#endif
+}
+
 static int __init hyper_sysfs_init(void)
 {
 	int ret;
@@ -350,9 +378,14 @@ static int __init hyper_sysfs_init(void)
 	if (ret)
 		goto uuid_out;
 	ret = xen_properties_init();
+	if (ret)
+		goto prop_out;
+	ret = xen_sysfs_vmcoreinfo_init();
 	if (!ret)
 		goto out;
 
+	xen_properties_destroy();
+prop_out:
 	xen_sysfs_uuid_destroy();
 uuid_out:
 	xen_compilation_destroy();
@@ -366,6 +399,7 @@ out:
 
 static void hyper_sysfs_exit(void)
 {
+	xen_sysfs_vmcoreinfo_destroy();
 	xen_properties_destroy();
 	xen_compilation_destroy();
 	xen_sysfs_uuid_destroy();
diff --git a/include/xen/interface/kexec.h b/include/xen/interface/kexec.h
index 7bc8b27..46b98f6 100644
--- a/include/xen/interface/kexec.h
+++ b/include/xen/interface/kexec.h
@@ -109,6 +109,11 @@ typedef struct xen_kexec_load {
 #define KEXEC_RANGE_MA_XEN   1   /* machine address and size of Xen itself */
 #define KEXEC_RANGE_MA_CPU   2   /* machine address and size of a CPU note */
 
+#define KEXEC_RANGE_MA_VMCOREINFO 6 /* machine address and size of vmcoreinfo */
+ 
+extern size_t vmcoreinfo_size_xen;
+extern unsigned long paddr_vmcoreinfo_xen;
+
 /*
  * Find the address and size of certain memory areas
  * range == KEXEC_RANGE_... [in]
