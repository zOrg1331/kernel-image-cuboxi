From: Amerigo Wang <amwang@redhat.com>
Date: Wed, 2 Dec 2009 06:59:46 -0500
Subject: [mm] call vfs_check_frozen after unlocking the spinlock
Message-id: <20091202070245.10623.36438.sendpatchset@localhost.localdomain>
Patchwork-id: 21643
O-Subject: [PATCH RHEL5.5] mm: call vfs_check_frozen after unlocking the spinlock
Bugzilla: 541956
RH-Acked-by: Eugene Teo <eugene@redhat.com>
RH-Acked-by: Eric Sandeen <sandeen@redhat.com>

BZ:
https://bugzilla.redhat.com/show_bug.cgi?id=541956

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=2111628

Description:
The do_wp_page() function takes the ptl lock and then calls vfs_check_frozen()
which may go to sleep if the bdev in question is frozen.

Move vfs_check_frozen() down after unlocking the ptl spinlock.

Upstream status:
Upstream already moved vfs_check_frozen() to other place, doesn't need
this.

Signed-off-by: WANG Cong <amwang@redhat.com>


diff --git a/mm/memory.c b/mm/memory.c
index fcd906b..5cd8e42 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1776,14 +1776,13 @@ static int do_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,
 		unlock_page(old_page);
 	} else if (unlikely((vma->vm_flags & (VM_WRITE|VM_SHARED)) ==
 					(VM_WRITE|VM_SHARED))) {
-		/*
-		 * Only catch write-faults on shared writable pages,
-		 * read-only shared pages can get COWed by
-		 * get_user_pages(.write=1, .force=1).
-		 */
-		vfs_check_frozen(vma->vm_file->f_dentry->d_inode->i_sb,
-				 SB_FREEZE_WRITE);
-		if (vma->vm_ops && vma->vm_ops->page_mkwrite) {
+		struct super_block *sb;
+		int (*mkwrite)(struct vm_area_struct *vma, struct page *page);
+
+		sb = vma->vm_file->f_dentry->d_inode->i_sb;
+		mkwrite = vma->vm_ops ? vma->vm_ops->page_mkwrite : NULL;
+
+		if (mkwrite || sb->s_frozen != SB_UNFROZEN) {
 			/*
 			 * Notify the address space that the page is about to
 			 * become writable so that it can prohibit this or wait
@@ -1795,7 +1794,13 @@ static int do_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,
 			page_cache_get(old_page);
 			pte_unmap_unlock(page_table, ptl);
 
-			if (vma->vm_ops->page_mkwrite(vma, old_page) < 0)
+			/*
+			 * Only catch write-faults on shared writable pages,
+			 * read-only shared pages can get COWed by
+			 * get_user_pages(.write=1, .force=1).
+			 */
+			vfs_check_frozen(sb, SB_FREEZE_WRITE);
+			if (mkwrite && mkwrite(vma, old_page) < 0)
 				goto unwritable_page;
 
 			page_cache_release(old_page);
