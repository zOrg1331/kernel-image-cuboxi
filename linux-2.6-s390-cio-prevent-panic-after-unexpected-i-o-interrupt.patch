From: Hendrik Brueckner <brueckner@redhat.com>
Date: Fri, 29 Oct 2010 09:27:46 -0400
Subject: [s390] cio: prevent panic after unexpected I/O interrupt
Message-id: <20101029092744.GA4687@redhat.com>
Patchwork-id: 28976
O-Subject: [RHEL5.6 PATCH 1/1] [s390x] cio: prevent kernel panic after
	unexpected I/O interrupt
Bugzilla: 647502
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Description
-----------
After a ccw device malfunction, a kernel panic with the
following text occurs:
"dev_jumptable[0][1] == NULL / kernel BUG at drivers/s390/cio/device_fsm.c".

When Linux detects a problem with a ccw device, it disables
interrupts for the associated subchannel. If an I/O interrupt
arrives for a device in such a state, a kernel panic is
triggered even though the situation is non-fatal and should
not cause any other problems.

When an I/O interrupt arrives on a subchannel which is supposed
to be disabled for interrupts, repeat the attempt to disable the
subchannel and do not cause a kernel panic.

Bugzilla
--------
BZ 647502
https://bugzilla.redhat.com/show_bug.cgi?id=647502

Upstream status of the patch
----------------------------
The patch is upstream as of kernel version 2.6.33
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=16b9a0571da4ee5cd15ca75e871722b0b5aee64d

Test status
-----------
The patch has been tested and fixes the problem.
The fix has been verified by the IBM test department.


diff --git a/drivers/s390/cio/device_fsm.c b/drivers/s390/cio/device_fsm.c
index 9feab04..c38ca2f 100644
--- a/drivers/s390/cio/device_fsm.c
+++ b/drivers/s390/cio/device_fsm.c
@@ -1164,14 +1164,14 @@ device_trigger_reprobe(struct subchannel *sch)
 	ccw_device_start_id(cdev, 0);
 }
 
-static void
-ccw_device_offline_irq(struct ccw_device *cdev, enum dev_event dev_event)
+static void ccw_device_disabled_irq(struct ccw_device *cdev,
+				    enum dev_event dev_event)
 {
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
 	/*
-	 * An interrupt in state offline means a previous disable was not
+	 * An interrupt in a disabled state means a previous disable was not
 	 * successful - should not happen, but we try to disable again.
 	 */
 	cio_disable_subchannel(sch);
@@ -1234,23 +1234,12 @@ ccw_device_nop(struct ccw_device *cdev, enum dev_event dev_event)
 }
 
 /*
- * Bug operation action. 
- */
-static void
-ccw_device_bug(struct ccw_device *cdev, enum dev_event dev_event)
-{
-	printk(KERN_EMERG "dev_jumptable[%i][%i] == NULL\n",
-	       cdev->private->state, dev_event);
-	BUG();
-}
-
-/*
  * device statemachine
  */
 fsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS] = {
 	[DEV_STATE_NOT_OPER] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_nop,
-		[DEV_EVENT_INTERRUPT]	= ccw_device_bug,
+		[DEV_EVENT_INTERRUPT]	= ccw_device_disabled_irq,
 		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_nop,
 	},
@@ -1268,7 +1257,7 @@ fsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS] = {
 	},
 	[DEV_STATE_OFFLINE] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_generic_notoper,
-		[DEV_EVENT_INTERRUPT]	= ccw_device_offline_irq,
+		[DEV_EVENT_INTERRUPT]	= ccw_device_disabled_irq,
 		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_nop,
 	},
@@ -1331,7 +1320,7 @@ fsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS] = {
 	[DEV_STATE_DISCONNECTED] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_nop,
 		[DEV_EVENT_INTERRUPT]	= ccw_device_start_id,
-		[DEV_EVENT_TIMEOUT]	= ccw_device_bug,
+		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_start_id,
 	},
 	[DEV_STATE_DISCONNECTED_SENSE_ID] = {
