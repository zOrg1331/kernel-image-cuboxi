X-Account-Key: account4
X-UIDL: 0ab733f6c6cc5849
X-Mozilla-Status: 0001
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                 
Received: from relay.parallels.com (relay.parallels.com [195.214.232.42])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OICHaQ011657
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
	Wed, 24 Mar 2010 21:12:18 +0300 (MSK)
Received: from mx1.parallels.com ([64.131.89.18])
	by relay.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3w-0008J9-7M; Wed, 24 Mar 2010 21:12:16 +0300
Received: from mailhub.sw.ru ([195.214.232.25] helo=relay.sw.ru)
	by mx1.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3v-00048K-7g; Wed, 24 Mar 2010 14:12:15 -0400
Received: from localhost.localdomain ([10.30.18.218])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OIC3cv007235;
	Wed, 24 Mar 2010 21:12:13 +0300 (MSK)
From: Vitaliy Gusev <vgusev@openvz.org>
To: xemul@openvz.org
Cc: vz@lists.sw.ru, Vitaliy Gusev <vgusev@openvz.org>
Subject: [2.6.18][PATCH 7/8] pacct: correct acct_auto_close_mnt and acct_auto_close
Date: Wed, 24 Mar 2010 21:17:28 +0300
Message-Id: <1269454649-887-8-git-send-email-vgusev@openvz.org>
X-Mailer: git-send-email 1.6.0.2
In-Reply-To: <1269454649-887-1-git-send-email-vgusev@openvz.org>
References: <1269454649-887-1-git-send-email-vgusev@openvz.org>

Emergency remount is called from VE0 context so it needs a tool
that give us proper VE context.

Also sys_umount that calls acct_auto_close_mnt() can be called from
VE0 context.

Thus use list of all "accts" and walk on him.

Idea is taken from
     commit b5a7174875ea570cc675f2c503e800db8efdd6a7
     All the bsd_acct_strcts with opened accounting are linked into a global
     list.  So, the acct_auto_close(_mnt) walks one and drops the accounting
     for each.

     Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
---
 kernel/acct.c |   25 +++++++++++++------------
 1 files changed, 13 insertions(+), 12 deletions(-)

diff --git a/kernel/acct.c b/kernel/acct.c
index 4b244a9..4225e4c 100644
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@ -88,9 +88,11 @@ struct bsd_acct_struct {
 	volatile int		needcheck;
 	struct file		*file;
 	struct timer_list	timer;
+	struct list_head	list;
 };
 
 static DEFINE_SPINLOCK(acct_lock);
+static LIST_HEAD(acct_list);
 
 /*
  * Called whenever the timer says to check the free space.
@@ -184,6 +186,7 @@ static void acct_file_reopen(struct bsd_acct_struct *acct, struct file *file)
  		acct->active = 0;
  		acct->needcheck = 0;
  		acct->file = NULL;
+		list_del(&acct->list);
 	}
 	if (file) {
  		acct->file = file;
@@ -194,6 +197,7 @@ static void acct_file_reopen(struct bsd_acct_struct *acct, struct file *file)
 			    (unsigned long)acct);
 		acct->timer.expires = jiffies + ACCT_TIMEOUT*HZ;
 		add_timer(&acct->timer);
+		list_add(&acct->list, &acct_list);
 	}
 	if (old_acct) {
 		mnt_unpin(old_acct->f_vfsmnt);
@@ -306,14 +310,13 @@ asmlinkage long sys_acct(const char __user *name)
  */
 void acct_auto_close_mnt(struct vfsmount *m)
 {
-	struct bsd_acct_struct *acct = get_exec_env()->bacct;
-
-	if (!acct)
-		return;
+	struct bsd_acct_struct *acct, *temp;
 
 	spin_lock(&acct_lock);
-	if (acct->file && acct->file->f_vfsmnt == m)
-		acct_file_reopen(acct, NULL);
+	list_for_each_entry_safe(acct, temp, &acct_list, list) {
+		if (acct->file && acct->file->f_vfsmnt == m)
+			acct_file_reopen(acct, NULL);
+	}
 	spin_unlock(&acct_lock);
 }
 
@@ -326,14 +329,12 @@ void acct_auto_close_mnt(struct vfsmount *m)
  */
 void acct_auto_close(struct super_block *sb)
 {
-	struct bsd_acct_struct *acct = get_exec_env()->bacct;
-
-	if (!acct)
-		return;
+	struct bsd_acct_struct *acct, *temp;
 
 	spin_lock(&acct_lock);
-	if (acct->file && acct->file->f_vfsmnt->mnt_sb == sb) {
-		acct_file_reopen(acct, NULL);
+	list_for_each_entry_safe(acct, temp, &acct_list, list) {
+		if (acct->file && acct->file->f_vfsmnt->mnt_sb == sb)
+			acct_file_reopen(acct, NULL);
 	}
 	spin_unlock(&acct_lock);
 }
-- 
1.6.0.2


