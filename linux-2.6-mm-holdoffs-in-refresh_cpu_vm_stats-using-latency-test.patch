From: George Beshers <gbeshers@redhat.com>
Date: Wed, 20 Aug 2008 18:32:21 -0400
Subject: [mm] holdoffs in refresh_cpu_vm_stats using latency test
Message-id: 48AC9B75.4040104@redhat.com
O-Subject: [RHEL5.3 PATCH] BZ 447654: Holdoffs in refresh_cpu_vm_stats() when running latency tests
Bugzilla: 447654
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>
RH-Acked-by: Rik van Riel <riel@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: Mikulas Patocka <mpatocka@redhat.com>

BZ#447654: [v2] Holdoffs in refresh_cpu_vm_stats() when running latency tests

NOTE: Don this is a repost of the original post (there was another modified
   post in between).  Is the [v2] correct?

This is admittedly somewhat ugly --- appologies to Mikulas for
not understanding his earlier comment until after his email today.

The problem is that SGI has a few, but important, customers
who demand very short latencies for their applications and
have requested RHEL and this is a minimalist solution.

The patch improves latency when refresh_cpu_vm_stats() is called
from cache_reap(); refresh_vm_stats() has no in-tree callers.
Notice that cache_reap() calls cond_resched() a few lines before
calling refresh_cpu_vm_stats().

Please comment or ACK.

http://git2.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=468fd62ed9090ccbe872489df5d0d099510df4b5

vmstats: add cond_resched() to refresh_cpu_vm_stats()

We've found that it can take quite a bit of time (100's of usec) to get
through the zone loop in refresh_cpu_vm_stats().

Adding a cond_resched() to allow other threads to run in the non-preemptive
case.

Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
Acked-by: Christoph Lameter <clameter@sgi.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/vmstat.c b/mm/vmstat.c
index 321668a..6c4c611 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -330,6 +330,8 @@ void refresh_cpu_vm_stats(int cpu)
 				pcp->vm_stat_diff[i] = 0;
 				local_irq_restore(flags);
 			}
+
+		cond_resched();
 	}
 }
 
