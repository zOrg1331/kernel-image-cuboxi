From: Ed Pollard <epollard@redhat.com>
Date: Mon, 11 Aug 2008 14:20:16 -0400
Subject: [ppc64] spu: add cpufreq governor
Message-id: 48A082E0.5050709@redhat.com
O-Subject: [RHEL 5.3 PATCH] RHBZ442410 Enhance the Power Management of Cell by adding spu aware cpufreq governor
Bugzilla: 442410
RH-Acked-by: David Howells <dhowells@redhat.com>

Bugzilla: 442410

Brew:
http://brewweb.devel.redhat.com/brew/taskinfo?taskID=1426297

Description:
Original patch commit message:
===
committer Benjamin Herrenschmidt <benh@kernel.crashing.org>
commit 880e710580c09bf86cddac687fc492a8318934fe

powerpc/cell/cpufreq: Add spu aware cpufreq governor

This patch adds a cpufreq governor that takes the number of running spus
into account. It's very similar to the ondemand governor, but not as
complex.
Instead of hacking spu load into the ondemand governor it might be easier to
have cpufreq accepting multiple governors per cpu in future.
Don't know if this is the right way, but it would keep the governors simple.

Signed-off-by: Christian Krafft <krafft@de.ibm.com>
Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Acked-by: Dave Jones <davej@redhat.com>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
===

It was found recently that this depends on the SPUFS update, specifically
cbe_spu_info needs busy_spus that the spufs update added in
include/asm-powerpc/spu.h
 https://bugzilla.redhat.com/show_bug.cgi?id=439483
 http://post-office.corp.redhat.com/archives/rhkernel-list/2008-July/msg00886.html

ARCH: Only modified code in the Cell arch.
kABI: No symbols were modified

I have added the config file change needed for this to my git tree as well
and ended up with the following patch.

Diffstat:
 arch/powerpc/platforms/cell/Kconfig             |    9 +
 arch/powerpc/platforms/cell/Makefile            |    1
 arch/powerpc/platforms/cell/cpufreq_spudemand.c |  185
++++++++++++++++++++++++
 redhat/configs/config-powerpc64                 |    1
 4 files changed, 196 insertions(+)

diff --git a/arch/powerpc/platforms/cell/Kconfig b/arch/powerpc/platforms/cell/Kconfig
index 4ff987d..b8ea38c 100644
--- a/arch/powerpc/platforms/cell/Kconfig
+++ b/arch/powerpc/platforms/cell/Kconfig
@@ -80,4 +80,13 @@ config CBE_AXON_PCI
 	  The Axon chip delivers error conditions detected in the
 	  PCI bridge as error interrupts.
 
+config CBE_CPUFREQ_SPU_GOVERNOR
+    tristate "CBE frequency scaling based on SPU usage"
+    depends on SPU_FS && CPU_FREQ
+    default m
+    help
+      This governor checks for spu usage to adjust the cpu frequency.
+      If no spu is running on a given cpu, that cpu will be throttled to
+      the minimal possible frequency.
+
 endmenu
diff --git a/arch/powerpc/platforms/cell/Makefile b/arch/powerpc/platforms/cell/Makefile
index 314cf9b..ffb65fd 100644
--- a/arch/powerpc/platforms/cell/Makefile
+++ b/arch/powerpc/platforms/cell/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_CBE_THERM)			+= cbe_thermal.o
 obj-$(CONFIG_CBE_CPUFREQ_PMI)           += cbe_cpufreq_pmi.o
 obj-$(CONFIG_CBE_CPUFREQ)               += cbe-cpufreq.o
 cbe-cpufreq-y                           += cbe_cpufreq_pervasive.o cbe_cpufreq.o
+obj-$(CONFIG_CBE_CPUFREQ_SPU_GOVERNOR)    += cpufreq_spudemand.o
 
 obj-$(CONFIG_CBE_AXON_UTL)		+= axon_utl.o
 obj-$(CONFIG_CBE_AXON_PCI)		+= axon_pci-error.o
diff --git a/arch/powerpc/platforms/cell/cpufreq_spudemand.c b/arch/powerpc/platforms/cell/cpufreq_spudemand.c
new file mode 100644
index 0000000..06cd3c4
--- /dev/null
+++ b/arch/powerpc/platforms/cell/cpufreq_spudemand.c
@@ -0,0 +1,185 @@
+/*
+ * spu aware cpufreq governor for the cell processor
+ *
+ * © Copyright IBM Corporation 2006-2008
+ *
+ * Author: Christian Krafft <krafft@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/cpufreq.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <asm/atomic.h>
+#include <asm/machdep.h>
+#include <asm/spu.h>
+
+#define POLL_TIME    100000        /* in µs */
+#define EXP        753        /* exp(-1) in fixed-point */
+
+struct spu_gov_info_struct {
+    unsigned long busy_spus;    /* fixed-point */
+    struct cpufreq_policy *policy;
+    struct work_struct work;
+    unsigned int poll_int;        /* µs */
+};
+static DEFINE_PER_CPU(struct spu_gov_info_struct, spu_gov_info);
+
+static struct workqueue_struct *kspugov_wq;
+
+static int calc_freq(struct spu_gov_info_struct *info)
+{
+    int cpu;
+    int busy_spus;
+
+    cpu = info->policy->cpu;
+    busy_spus = atomic_read(&cbe_spu_info[cpu_to_node(cpu)].busy_spus);
+
+    CALC_LOAD(info->busy_spus, EXP, busy_spus * FIXED_1);
+    pr_debug("cpu %d: busy_spus=%d, info->busy_spus=%ld\n",
+            cpu, busy_spus, info->busy_spus);
+
+    return info->policy->max * info->busy_spus / FIXED_1;
+}
+
+static void spu_gov_work(void *data)
+{
+    struct spu_gov_info_struct *info;
+    int delay;
+    unsigned long target_freq;
+
+    info = data;
+
+    /* after cancel_delayed_work_sync we unset info->policy */
+    BUG_ON(info->policy == NULL);
+
+    target_freq = calc_freq(info);
+    __cpufreq_driver_target(info->policy, target_freq, CPUFREQ_RELATION_H);
+
+    delay = usecs_to_jiffies(info->poll_int);
+    queue_delayed_work_on(info->policy->cpu, kspugov_wq, &info->work, delay);
+}
+
+static void spu_gov_init_work(struct spu_gov_info_struct *info)
+{
+    int delay = usecs_to_jiffies(info->poll_int);
+    INIT_WORK(&info->work, spu_gov_work, info);
+    queue_delayed_work_on(info->policy->cpu, kspugov_wq, &info->work, delay);
+}
+
+static void spu_gov_cancel_work(struct spu_gov_info_struct *info)
+{
+    cancel_delayed_work(&info->work);
+    flush_workqueue(kspugov_wq);
+}
+
+static int spu_gov_govern(struct cpufreq_policy *policy, unsigned int event)
+{
+    unsigned int cpu = policy->cpu;
+    struct spu_gov_info_struct *info, *affected_info;
+    int i;
+    int ret = 0;
+
+    info = &per_cpu(spu_gov_info, cpu);
+
+    switch (event) {
+    case CPUFREQ_GOV_START:
+        if (!cpu_online(cpu)) {
+            printk(KERN_ERR "cpu %d is not online\n", cpu);
+            ret = -EINVAL;
+            break;
+        }
+
+        if (!policy->cur) {
+            printk(KERN_ERR "no cpu specified in policy\n");
+            ret = -EINVAL;
+            break;
+        }
+
+        /* initialize spu_gov_info for all affected cpus */
+        for_each_cpu_mask(i, policy->cpus) {
+            affected_info = &per_cpu(spu_gov_info, i);
+            affected_info->policy = policy;
+        }
+
+        info->poll_int = POLL_TIME;
+
+        /* setup timer */
+        spu_gov_init_work(info);
+
+        break;
+
+    case CPUFREQ_GOV_STOP:
+        /* cancel timer */
+        spu_gov_cancel_work(info);
+
+        /* clean spu_gov_info for all affected cpus */
+        for_each_cpu_mask (i, policy->cpus) {
+            info = &per_cpu(spu_gov_info, i);
+            info->policy = NULL;
+        }
+
+        break;
+    }
+
+    return ret;
+}
+
+static struct cpufreq_governor spu_governor = {
+    .name = "spudemand",
+    .governor = spu_gov_govern,
+    .owner = THIS_MODULE,
+};
+
+/*
+ * module init and destoy
+ */
+
+static int __init spu_gov_init(void)
+{
+    int ret;
+
+    kspugov_wq = create_workqueue("kspugov");
+    if (!kspugov_wq) {
+        printk(KERN_ERR "creation of kspugov failed\n");
+        ret = -EFAULT;
+        goto out;
+    }
+
+    ret = cpufreq_register_governor(&spu_governor);
+    if (ret) {
+        printk(KERN_ERR "registration of governor failed\n");
+        destroy_workqueue(kspugov_wq);
+        goto out;
+    }
+out:
+    return ret;
+}
+
+static void __exit spu_gov_exit(void)
+{
+    cpufreq_unregister_governor(&spu_governor);
+    destroy_workqueue(kspugov_wq);
+}
+
+
+module_init(spu_gov_init);
+module_exit(spu_gov_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Christian Krafft <krafft@de.ibm.com>");
+
