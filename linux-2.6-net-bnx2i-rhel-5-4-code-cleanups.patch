From: mchristi@redhat.com <mchristi@redhat.com>
Date: Tue, 7 Jul 2009 13:33:19 -0500
Subject: [net] bnx2i: RHEL-5.4 code cleanups
Message-id: 1246991599-2969-1-git-send-email-mchristi@redhat.com
O-Subject: [PATCH] RHEL 5.4: bnx2i Fixes from review comments.
Bugzilla: 504181
RH-Acked-by: David Miller <davem@redhat.com>

From: Mike Christie <mchristi@redhat.com>

This patch fixes issues found during our review of the driver
including:
- ifdef LINUX_VERSION not needed.
- cnic_iscsi_nl_msg_recv does not match upstream definition
- indicate_inetevent is in RHEL5 patch, but not upstream and is not
used or needed.
- Fix the handling of exp_statsn.
- bnx2i_compat.h is not used.

Broadcom has sent patches to the linux scsi list for
the next issues, but they are not yet upstream:

http://www.spinics.net/lists/linux-scsi/msg37025.html
http://www.spinics.net/lists/linux-scsi/msg37026.html
http://www.spinics.net/lists/linux-scsi/msg37027.html
- Fix a lockdep warning during ep_connect().
- Removed bnx2i_reg_devices.
- Fixed bnx2i_init_one()'s error return path.
- Other style and comment cleanups.

I have only compile tested the patch. Broadcom has tested them.

diff --git a/drivers/net/cnic.c b/drivers/net/cnic.c
index 5bcd4bd..d025274 100644
--- a/drivers/net/cnic.c
+++ b/drivers/net/cnic.c
@@ -10,7 +10,6 @@
  * Modified and maintained by: Michael Chan <mchan@broadcom.com>
  */
 
-#include <linux/version.h>
 #include <linux/module.h>
 
 #include <linux/kernel.h>
@@ -235,9 +234,11 @@ static int cnic_send_nlmsg(struct cnic_local *cp, u32 type,
 	return 0;
 }
 
-static void cnic_iscsi_nl_msg_recv(struct cnic_dev *dev, u32 msg_type,
-				   char *buf, u16 len)
+static int cnic_iscsi_nl_msg_recv(struct cnic_dev *dev, u32 msg_type,
+				  char *buf, u16 len)
 {
+	int rc = -EINVAL;
+
 	switch (msg_type) {
 	case ISCSI_UEVENT_PATH_UPDATE: {
 		struct cnic_local *cp;
@@ -268,9 +269,12 @@ static void cnic_iscsi_nl_msg_recv(struct cnic_dev *dev, u32 msg_type,
 				cnic_cm_set_pg(csk);
 		}
 		csk_put(csk);
+		rc = 0;
 		break;
 	}
 	}
+
+	return rc;
 }
 
 static int cnic_offld_prep(struct cnic_sock *csk)
@@ -1031,11 +1035,7 @@ done:
 		BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);
 }
 
-#if (LINUX_VERSION_CODE >= 0x20613)
-static irqreturn_t cnic_irq(int irq, void *dev_instance)
-#else
 static irqreturn_t cnic_irq(int irq, void *dev_instance, struct pt_regs *regs)
-#endif
 {
 	struct cnic_dev *dev = dev_instance;
 	struct cnic_local *cp = dev->cnic_priv;
@@ -1472,11 +1472,7 @@ static int cnic_get_v4_route(struct sockaddr_in *dst_addr,
 	memset(&fl, 0, sizeof(fl));
 	fl.nl_u.ip4_u.daddr = dst_addr->sin_addr.s_addr;
 
-#if (LINUX_VERSION_CODE >= 0x020619)
-	err = ip_route_output_key(&init_net, &rt, &fl);
-#else
 	err = ip_route_output_key(&rt, &fl);
-#endif
 	if (!err)
 		*dst = &rt->u.dst;
 	return err;
@@ -1493,11 +1489,7 @@ static int cnic_get_v6_route(struct sockaddr_in6 *dst_addr,
 	if (ipv6_addr_type(&fl.fl6_dst) & IPV6_ADDR_LINKLOCAL)
 		fl.oif = dst_addr->sin6_scope_id;
 
-#if (LINUX_VERSION_CODE >= 0x02061a)
-	*dst = ip6_route_output(&init_net, NULL, &fl);
-#else
 	*dst = ip6_route_output(NULL, &fl);
-#endif
 	if (*dst)
 		return 0;
 #endif
diff --git a/drivers/net/cnic_if.h b/drivers/net/cnic_if.h
index ea8979c..b125b9c 100644
--- a/drivers/net/cnic_if.h
+++ b/drivers/net/cnic_if.h
@@ -12,8 +12,8 @@
 #ifndef CNIC_IF_H
 #define CNIC_IF_H
 
-#define CNIC_MODULE_VERSION	"1.7.8"
-#define CNIC_MODULE_RELDATE	"March 10, 2009"
+#define CNIC_MODULE_VERSION	"2.0.0"
+#define CNIC_MODULE_RELDATE	"March 21, 2009"
 
 #define CNIC_ULP_RDMA		0
 #define CNIC_ULP_ISCSI		1
@@ -247,8 +247,8 @@ struct cnic_dev {
 	int (*cm_abort)(struct cnic_sock *);
 	int (*cm_close)(struct cnic_sock *);
 	struct cnic_dev *(*cm_select_dev)(struct sockaddr_in *, int ulp_type);
-	void (*iscsi_nl_msg_recv)(struct cnic_dev *dev, u32 msg_type,
-				  char *data, u16 data_size);
+	int (*iscsi_nl_msg_recv)(struct cnic_dev *dev, u32 msg_type,
+				 char *data, u16 data_size);
 	unsigned long	flags;
 #define CNIC_F_CNIC_UP		1
 #define CNIC_F_BNX2_CLASS	3
@@ -282,7 +282,6 @@ struct cnic_ulp_ops {
 	void (*indicate_kcqes)(void *ulp_ctx, struct kcqe *cqes[],
 				u32 num_cqes);
 	void (*indicate_netevent)(void *ulp_ctx, unsigned long event);
-	void (*indicate_inetevent)(void *ulp_ctx, unsigned long event);
 	void (*cm_connect_complete)(struct cnic_sock *);
 	void (*cm_close_complete)(struct cnic_sock *);
 	void (*cm_abort_complete)(struct cnic_sock *);
diff --git a/drivers/scsi/bnx2i/bnx2i.h b/drivers/scsi/bnx2i/bnx2i.h
index fc9c3ed..2b433dc 100644
--- a/drivers/scsi/bnx2i/bnx2i.h
+++ b/drivers/scsi/bnx2i/bnx2i.h
@@ -1,6 +1,6 @@
 /* bnx2i.h: Broadcom NetXtreme II iSCSI driver.
  *
- * Copyright (c) 2006 - 2008 Broadcom Corporation
+ * Copyright (c) 2006 - 2009 Broadcom Corporation
  * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.
  * Copyright (c) 2007, 2008 Mike Christie
  *
@@ -59,8 +59,6 @@
 #define MAX_PAGES_PER_CTRL_STRUCT_POOL	8
 #define BNX2I_RESERVED_SLOW_PATH_CMD_SLOTS	4
 
-#define BNX2I_STATSN_UPDATE_SIGNATURE	0xFABCAFE
-
 /* 5706/08 hardware has limit on maximum buffer size per BD it can handle */
 #define MAX_BD_LENGTH			65535
 #define BD_SPLIT_SIZE			32768
@@ -220,7 +218,6 @@ struct bnx2i_cmd {
  *
  * @cls_conn:              pointer to iscsi cls conn
  * @hba:                   adapter structure pointer
- * @exp_statsn:            iscsi expected statsn
  * @iscsi_conn_cid:        iscsi conn id
  * @fw_cid:                firmware iscsi context id
  * @ep:                    endpoint structure pointer
@@ -236,7 +233,6 @@ struct bnx2i_conn {
 	struct completion cmd_cleanup_cmpl;
 	int is_bound;
 
-	u32 exp_statsn;
 	u32 iscsi_conn_cid;
 #define BNX2I_CID_RESERVED	0x5AFF
 	u32 fw_cid;
@@ -383,7 +379,7 @@ struct bnx2i_hba {
 	dma_addr_t dummy_buf_dma;
 
 	spinlock_t lock;	/* protects hba structure access */
-	spinlock_t net_dev_lock;/* sync net device access */
+	struct mutex net_dev_lock;/* sync net device access */
 
 	/*
 	 * PCI related info.
@@ -705,7 +701,6 @@ extern struct class_device_attribute *bnx2i_dev_attributes[];
  */
 extern void bnx2i_identify_device(struct bnx2i_hba *hba);
 extern void bnx2i_register_device(struct bnx2i_hba *hba);
-extern void bnx2i_check_nx2_dev_busy(void);
 
 extern void bnx2i_ulp_init(struct cnic_dev *dev);
 extern void bnx2i_ulp_exit(struct cnic_dev *dev);
diff --git a/drivers/scsi/bnx2i/bnx2i_compat.h b/drivers/scsi/bnx2i/bnx2i_compat.h
deleted file mode 100644
index e283e80..0000000
--- a/drivers/scsi/bnx2i/bnx2i_compat.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#ifndef BNX2I_COMPAT
-#define BNX2I_COMPAT
-
-#include <linux/bitops.h>
-
-
-#define scsi_for_each_sg(cmd, sg, nseg, __i)	\
-	for_each_sg(scsi_sglist(cmd), sg, nseg, __i)
-
-/*
- * round down to nearest power of two
- */
-static inline __attribute__((const))
-unsigned long __rounddown_pow_of_two(unsigned long n)
-{
-        return 1UL << (fls_long(n) - 1);
-}
-
-#endif
diff --git a/drivers/scsi/bnx2i/bnx2i_hwi.c b/drivers/scsi/bnx2i/bnx2i_hwi.c
index 94a60f0..75796cb 100644
--- a/drivers/scsi/bnx2i/bnx2i_hwi.c
+++ b/drivers/scsi/bnx2i/bnx2i_hwi.c
@@ -1,6 +1,6 @@
 /* bnx2i_hwi.c: Broadcom NetXtreme II iSCSI driver.
  *
- * Copyright (c) 2006 - 2008 Broadcom Corporation
+ * Copyright (c) 2006 - 2009 Broadcom Corporation
  * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.
  * Copyright (c) 2007, 2008 Mike Christie
  *
@@ -578,7 +578,7 @@ void bnx2i_update_iscsi_conn(struct iscsi_conn *conn)
 	update_wqe->max_recv_pdu_length = conn->max_recv_dlength;
 	update_wqe->first_burst_length = conn->session->first_burst;
 	update_wqe->max_burst_length = conn->session->max_burst;
-	update_wqe->exp_stat_sn = bnx2i_conn->exp_statsn;
+	update_wqe->exp_stat_sn = conn->exp_statsn;
 	update_wqe->max_outstanding_r2ts = conn->session->max_r2t;
 	update_wqe->session_error_recovery_level = conn->session->erl;
 	iscsi_conn_printk(KERN_ALERT, conn,
@@ -1368,13 +1368,6 @@ static int bnx2i_process_login_resp(struct iscsi_session *session,
 		}
 	}
 
-	/*
-	 * check if this is the first login response for this connection.
-	 * If yes, we need to copy initial StatSN to connection structure.
-	 */
-	if (bnx2i_conn->exp_statsn == BNX2I_STATSN_UPDATE_SIGNATURE)
-		bnx2i_conn->exp_statsn = be32_to_cpu(resp_hdr->statsn) + 1;
-
 	__iscsi2_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr,
 		bnx2i_conn->gen_pdu.resp_buf,
 		bnx2i_conn->gen_pdu.resp_wr_ptr - bnx2i_conn->gen_pdu.resp_buf);
@@ -2195,26 +2188,6 @@ static void bnx2i_indicate_kcqe(void *context, struct kcqe *kcqe[],
 	}
 }
 
-
-/*
- * Generic netstack event handler
- */
-static void bnx2i_indicate_inetevent(void *context, unsigned long event)
-{
-	struct bnx2i_hba *hba = context;
-
-	switch (event) {
-	case NETDEV_UP:
-		iscsi2_host_for_each_session(hba->shost,
-					    bnx2i_drop_session);
-		break;
-	case NETDEV_CHANGE:
-		break;
-	default:
-		;
-	}
-}
-
 /**
  * bnx2i_indicate_netevent - Generic netdev event handler
  * @context:	adapter structure pointer
@@ -2367,7 +2340,6 @@ struct cnic_ulp_ops bnx2i_cnic_cb = {
 	.cnic_stop = bnx2i_stop,
 	.indicate_kcqes = bnx2i_indicate_kcqe,
 	.indicate_netevent = bnx2i_indicate_netevent,
-	.indicate_inetevent = bnx2i_indicate_inetevent,
 	.cm_connect_complete = bnx2i_cm_connect_cmpl,
 	.cm_close_complete = bnx2i_cm_close_cmpl,
 	.cm_abort_complete = bnx2i_cm_abort_cmpl,
diff --git a/drivers/scsi/bnx2i/bnx2i_init.c b/drivers/scsi/bnx2i/bnx2i_init.c
index 2ad81b1..1f16439 100644
--- a/drivers/scsi/bnx2i/bnx2i_init.c
+++ b/drivers/scsi/bnx2i/bnx2i_init.c
@@ -1,6 +1,6 @@
 /* bnx2i.c: Broadcom NetXtreme II iSCSI driver.
  *
- * Copyright (c) 2006 - 2008 Broadcom Corporation
+ * Copyright (c) 2006 - 2009 Broadcom Corporation
  * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.
  * Copyright (c) 2007, 2008 Mike Christie
  *
@@ -16,11 +16,10 @@
 
 static struct list_head adapter_list = LIST_HEAD_INIT(adapter_list);
 static u32 adapter_count;
-static int bnx2i_reg_device;
 
 #define DRV_MODULE_NAME		"bnx2i"
-#define DRV_MODULE_VERSION	"2.0.1d"
-#define DRV_MODULE_RELDATE	"Mar 25, 2009"
+#define DRV_MODULE_VERSION	"2.0.1e"
+#define DRV_MODULE_RELDATE	"June 22, 2009"
 
 static char version[] __devinitdata =
 		"Broadcom NetXtreme II iSCSI Driver " DRV_MODULE_NAME \
@@ -32,7 +31,7 @@ MODULE_DESCRIPTION("Broadcom NetXtreme II BCM5706/5708/5709 iSCSI Driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRV_MODULE_VERSION);
 
-static DEFINE_RWLOCK(bnx2i_dev_lock);
+static DEFINE_MUTEX(bnx2i_dev_lock);
 
 unsigned int event_coal_div = 1;
 module_param(event_coal_div, int, 0664);
@@ -101,14 +100,14 @@ struct bnx2i_hba *get_adapter_list_head(void)
 	if (!adapter_count)
 		goto hba_not_found;
 
-	read_lock(&bnx2i_dev_lock);
+	mutex_lock(&bnx2i_dev_lock);
 	list_for_each_entry(tmp_hba, &adapter_list, link) {
 		if (tmp_hba->cnic && tmp_hba->cnic->cm_select_dev) {
 			hba = tmp_hba;
 			break;
 		}
 	}
-	read_unlock(&bnx2i_dev_lock);
+	mutex_unlock(&bnx2i_dev_lock);
 hba_not_found:
 	return hba;
 }
@@ -123,14 +122,14 @@ struct bnx2i_hba *bnx2i_find_hba_for_cnic(struct cnic_dev *cnic)
 {
 	struct bnx2i_hba *hba, *temp;
 
-	read_lock(&bnx2i_dev_lock);
+	mutex_lock(&bnx2i_dev_lock);
 	list_for_each_entry_safe(hba, temp, &adapter_list, link) {
 		if (hba->cnic == cnic) {
-			read_unlock(&bnx2i_dev_lock);
+			mutex_unlock(&bnx2i_dev_lock);
 			return hba;
 		}
 	}
-	read_unlock(&bnx2i_dev_lock);
+	mutex_unlock(&bnx2i_dev_lock);
 	return NULL;
 }
 
@@ -187,17 +186,14 @@ void bnx2i_stop(void *handle)
  */
 void bnx2i_register_device(struct bnx2i_hba *hba)
 {
-	spin_lock(&hba->lock);	/* called from ep_connect context */
 	if (test_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state) ||
 	    test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {
-		goto rel_lock;
+		return;
 	}
 
 	hba->cnic->register_device(hba->cnic, CNIC_ULP_ISCSI, hba);
-	bnx2i_reg_device++;
+
 	set_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);
-rel_lock:
-	spin_unlock(&hba->lock);
 }
 
 
@@ -211,10 +207,10 @@ void bnx2i_reg_dev_all(void)
 {
 	struct bnx2i_hba *hba, *temp;
 
-	read_lock(&bnx2i_dev_lock);
+	mutex_lock(&bnx2i_dev_lock);
 	list_for_each_entry_safe(hba, temp, &adapter_list, link)
 		bnx2i_register_device(hba);
-	read_unlock(&bnx2i_dev_lock);
+	mutex_unlock(&bnx2i_dev_lock);
 }
 
 
@@ -227,22 +223,18 @@ void bnx2i_reg_dev_all(void)
  */
 static void bnx2i_unreg_one_device(struct bnx2i_hba *hba)
 {
-	spin_lock(&hba->lock); /* ep_connect/ep_disconnect() */
 	if (hba->ofld_conns_active ||
 	    !test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic) ||
-	    test_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state)) {
-		spin_unlock(&hba->lock);
+	    test_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state))
 		return;
-	}
 
 	hba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);
-	bnx2i_reg_device--;
+
 	/* ep_disconnect could come before NETDEV_DOWN, driver won't
 	 * see NETDEV_DOWN as it already unregistered itself.
 	 */
 	hba->adapter_state = 0;
 	clear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);
-	spin_unlock(&hba->lock);
 }
 
 /**
@@ -255,10 +247,10 @@ void bnx2i_unreg_dev_all(void)
 {
 	struct bnx2i_hba *hba, *temp;
 
-	read_lock(&bnx2i_dev_lock);
+	mutex_lock(&bnx2i_dev_lock);
 	list_for_each_entry_safe(hba, temp, &adapter_list, link)
 		bnx2i_unreg_one_device(hba);
-	read_unlock(&bnx2i_dev_lock);
+	mutex_unlock(&bnx2i_dev_lock);
 }
 
 
@@ -267,33 +259,34 @@ void bnx2i_unreg_dev_all(void)
  * @hba:	bnx2i adapter instance
  * @cnic:	cnic device handle
  *
- * Global resource lock and host adapter lock is held during critical sections
- *	below. This routine is called from cnic_register_driver() context and
- *	work horse thread which does majority of device specific initialization
+ * Global resource lock is held during critical sections below. This routine is
+ *	called from either cnic_register_driver() or device hot plug context and
+ *	and does majority of device specific initialization
  */
 static int bnx2i_init_one(struct bnx2i_hba *hba, struct cnic_dev *cnic)
 {
 	int rc;
 
-	read_lock(&bnx2i_dev_lock);
-	if (bnx2i_reg_device &&
-	    !test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {
-		spin_lock(&hba->lock);	/* hot plug */
-		rc = cnic->register_device(cnic, CNIC_ULP_ISCSI, hba);
-		if (rc)		/* duplicate registration */
-			printk(KERN_ERR "bnx2i- dev reg failed\n");
-		bnx2i_reg_device++;
+	mutex_lock(&bnx2i_dev_lock);
+	rc = cnic->register_device(cnic, CNIC_ULP_ISCSI, hba);
+	if (!rc) {
 		hba->age++;
 		set_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);
-		spin_unlock(&hba->lock);
-	}
-	read_unlock(&bnx2i_dev_lock);
-
-	write_lock(&bnx2i_dev_lock);
-	list_add_tail(&hba->link, &adapter_list);
-	adapter_count++;
-	write_unlock(&bnx2i_dev_lock);
-	return 0;
+		list_add_tail(&hba->link, &adapter_list);
+		adapter_count++;
+	} else if (rc == -EBUSY) 	/* duplicate registration */
+		printk(KERN_ALERT "bnx2i, duplicate registration"
+				  "hba=%p, cnic=%p\n", hba, cnic);
+	else if (rc == -EAGAIN)
+		printk(KERN_ERR "bnx2i, driver not registered\n");
+	else if (rc == -EINVAL)
+		printk(KERN_ERR "bnx2i, invalid type %d\n", CNIC_ULP_ISCSI);
+	else
+		printk(KERN_ERR "bnx2i dev reg, unknown error, %d\n", rc);
+
+	mutex_unlock(&bnx2i_dev_lock);
+
+	return rc;
 }
 
 
@@ -341,18 +334,15 @@ void bnx2i_ulp_exit(struct cnic_dev *dev)
 				 "found, dev 0x%p\n", dev);
 		return;
 	}
-	write_lock(&bnx2i_dev_lock);
+	mutex_lock(&bnx2i_dev_lock);
 	list_del_init(&hba->link);
 	adapter_count--;
 
 	if (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {
-		spin_lock(&hba->lock);	/* hot remove */
 		hba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);
 		clear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);
-		bnx2i_reg_device--;
-		spin_unlock(&hba->lock);
 	}
-	write_unlock(&bnx2i_dev_lock);
+	mutex_unlock(&bnx2i_dev_lock);
 
 	bnx2i_free_hba(hba);
 }
@@ -374,6 +364,8 @@ static int __init bnx2i_mod_init(void)
 	if (!is_power_of_2(sq_size))
 		sq_size = roundup_pow_of_two(sq_size);
 
+	mutex_init(&bnx2i_dev_lock);
+
 	bnx2i_scsi_xport_template =
 			iscsi2_register_transport(&bnx2i_iscsi_transport);
 	if (!bnx2i_scsi_xport_template) {
@@ -409,7 +401,7 @@ static void __exit bnx2i_mod_exit(void)
 {
 	struct bnx2i_hba *hba;
 
-	write_lock(&bnx2i_dev_lock);
+	mutex_lock(&bnx2i_dev_lock);
 	while (!list_empty(&adapter_list)) {
 		hba = list_entry(adapter_list.next, struct bnx2i_hba, link);
 		list_del(&hba->link);
@@ -418,14 +410,11 @@ static void __exit bnx2i_mod_exit(void)
 		if (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {
 			hba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);
 			clear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);
-			bnx2i_reg_device--;
 		}
 
-		write_unlock(&bnx2i_dev_lock);
 		bnx2i_free_hba(hba);
-		write_lock(&bnx2i_dev_lock);
 	}
-	write_unlock(&bnx2i_dev_lock);
+	mutex_unlock(&bnx2i_dev_lock);
 
 	iscsi2_unregister_transport(&bnx2i_iscsi_transport);
 	cnic_unregister_driver(CNIC_ULP_ISCSI);
diff --git a/drivers/scsi/bnx2i/bnx2i_iscsi.c b/drivers/scsi/bnx2i/bnx2i_iscsi.c
index 97774d4..4b8c949 100644
--- a/drivers/scsi/bnx2i/bnx2i_iscsi.c
+++ b/drivers/scsi/bnx2i/bnx2i_iscsi.c
@@ -1,7 +1,7 @@
 /*
  * bnx2i_iscsi.c: Broadcom NetXtreme II iSCSI driver.
  *
- * Copyright (c) 2006 - 2008 Broadcom Corporation
+ * Copyright (c) 2006 - 2009 Broadcom Corporation
  * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.
  * Copyright (c) 2007, 2008 Mike Christie
  *
@@ -274,7 +274,7 @@ static u32 bnx2i_alloc_iscsi_cid(struct bnx2i_hba *hba)
 	int idx;
 
 	if (!hba->cid_que.cid_free_cnt)
-		return RESERVED_ITT;
+		return -1;
 
 	idx = hba->cid_que.cid_q_cons_idx;
 	hba->cid_que.cid_q_cons_idx++;
@@ -295,7 +295,7 @@ static void bnx2i_free_iscsi_cid(struct bnx2i_hba *hba, u16 iscsi_cid)
 {
 	int idx;
 
-	if (iscsi_cid == (u16)RESERVED_ITT)
+	if (iscsi_cid == (u16) -1)
 		return;
 
 	hba->cid_que.cid_free_cnt++;
@@ -591,9 +591,9 @@ void bnx2i_drop_session(struct iscsi_cls_session *cls_session)
 static int bnx2i_ep_destroy_list_add(struct bnx2i_hba *hba,
 				     struct bnx2i_endpoint *ep)
 {
-	write_lock(&hba->ep_rdwr_lock);
+	write_lock_bh(&hba->ep_rdwr_lock);
 	list_add_tail(&ep->link, &hba->ep_destroy_list);
-	write_unlock(&hba->ep_rdwr_lock);
+	write_unlock_bh(&hba->ep_rdwr_lock);
 	return 0;
 }
 
@@ -608,9 +608,9 @@ static int bnx2i_ep_destroy_list_add(struct bnx2i_hba *hba,
 static int bnx2i_ep_destroy_list_del(struct bnx2i_hba *hba,
 				     struct bnx2i_endpoint *ep)
 {
-	write_lock(&hba->ep_rdwr_lock);
+	write_lock_bh(&hba->ep_rdwr_lock);
 	list_del_init(&ep->link);
-	write_unlock(&hba->ep_rdwr_lock);
+	write_unlock_bh(&hba->ep_rdwr_lock);
 
 	return 0;
 }
@@ -625,9 +625,9 @@ static int bnx2i_ep_destroy_list_del(struct bnx2i_hba *hba,
 static int bnx2i_ep_ofld_list_add(struct bnx2i_hba *hba,
 				  struct bnx2i_endpoint *ep)
 {
-	write_lock(&hba->ep_rdwr_lock);
+	write_lock_bh(&hba->ep_rdwr_lock);
 	list_add_tail(&ep->link, &hba->ep_ofld_list);
-	write_unlock(&hba->ep_rdwr_lock);
+	write_unlock_bh(&hba->ep_rdwr_lock);
 	return 0;
 }
 
@@ -641,9 +641,9 @@ static int bnx2i_ep_ofld_list_add(struct bnx2i_hba *hba,
 static int bnx2i_ep_ofld_list_del(struct bnx2i_hba *hba,
 				  struct bnx2i_endpoint *ep)
 {
-	write_lock(&hba->ep_rdwr_lock);
+	write_lock_bh(&hba->ep_rdwr_lock);
 	list_del_init(&ep->link);
-	write_unlock(&hba->ep_rdwr_lock);
+	write_unlock_bh(&hba->ep_rdwr_lock);
 	return 0;
 }
 
@@ -662,7 +662,7 @@ bnx2i_find_ep_in_ofld_list(struct bnx2i_hba *hba, u32 iscsi_cid)
 	struct list_head *tmp;
 	struct bnx2i_endpoint *ep;
 
-	read_lock(&hba->ep_rdwr_lock);
+	read_lock_bh(&hba->ep_rdwr_lock);
 	list_for_each_safe(list, tmp, &hba->ep_ofld_list) {
 		ep = (struct bnx2i_endpoint *)list;
 
@@ -670,7 +670,7 @@ bnx2i_find_ep_in_ofld_list(struct bnx2i_hba *hba, u32 iscsi_cid)
 			break;
 		ep = NULL;
 	}
-	read_unlock(&hba->ep_rdwr_lock);
+	read_unlock_bh(&hba->ep_rdwr_lock);
 
 	if (!ep)
 		printk(KERN_ERR "l5 cid %d not found\n", iscsi_cid);
@@ -691,7 +691,7 @@ bnx2i_find_ep_in_destroy_list(struct bnx2i_hba *hba, u32 iscsi_cid)
 	struct list_head *tmp;
 	struct bnx2i_endpoint *ep;
 
-	read_lock(&hba->ep_rdwr_lock);
+	read_lock_bh(&hba->ep_rdwr_lock);
 	list_for_each_safe(list, tmp, &hba->ep_destroy_list) {
 		ep = (struct bnx2i_endpoint *)list;
 
@@ -699,7 +699,7 @@ bnx2i_find_ep_in_destroy_list(struct bnx2i_hba *hba, u32 iscsi_cid)
 			break;
 		ep = NULL;
 	}
-	read_unlock(&hba->ep_rdwr_lock);
+	read_unlock_bh(&hba->ep_rdwr_lock);
 
 	if (!ep)
 		printk(KERN_ERR "l5 cid %d not found\n", iscsi_cid);
@@ -819,7 +819,7 @@ struct bnx2i_hba *bnx2i_alloc_hba(struct cnic_dev *cnic)
 	hba->num_ccell = hba->max_sqes / 2;
 
 	spin_lock_init(&hba->lock);
-	spin_lock_init(&hba->net_dev_lock);
+	mutex_init(&hba->net_dev_lock);
 
 	if (iscsi2_host_add(shost, &hba->pcidev->dev))
 		goto free_dump_mem;
@@ -1223,6 +1223,7 @@ bnx2i_session_create(struct iscsi_endpoint *ep,
 	struct iscsi_cls_session *cls_session;
 	struct bnx2i_hba *hba;
 	struct bnx2i_endpoint *bnx2i_ep;
+
 	if (!ep) {
 		printk(KERN_ERR "bnx2i: missing ep.\n");
 		return NULL;
@@ -1304,7 +1305,6 @@ bnx2i_conn_create(struct iscsi_cls_session *cls_session, uint32_t cid)
 	bnx2i_conn->hba = hba;
 	/* 'ep' ptr will be assigned in bind() call */
 	bnx2i_conn->ep = NULL;
-	bnx2i_conn->exp_statsn = BNX2I_STATSN_UPDATE_SIGNATURE;
 	init_completion(&bnx2i_conn->cmd_cleanup_cmpl);
 
 	if (bnx2i_conn_alloc_login_resources(hba, bnx2i_conn)) {
@@ -1543,18 +1543,6 @@ static void bnx2i_conn_get_stats(struct iscsi_cls_conn *cls_conn,
 }
 
 
-
-/**
- * bnx2i_check_nx2_dev_busy - this routine unregister devices.
- *
- * This should only unregister if there are no active conns.
- */
-void bnx2i_check_nx2_dev_busy(void)
-{
-	bnx2i_unreg_dev_all();
-}
-
-
 /**
  * bnx2i_check_route - checks if target IP route belongs to one of NX2 devices
  * @dst_addr:	target IP address
@@ -1698,17 +1686,17 @@ static struct iscsi_endpoint *bnx2i_ep_connect(struct Scsi_Host *shost,
 	}
 	bnx2i_ep = ep->dd_data;
 
-	spin_lock(&hba->net_dev_lock);
+	mutex_lock(&hba->net_dev_lock);
 	if (bnx2i_adapter_ready(hba)) {
 		rc = -EPERM;
 		goto net_if_down;
 	}
 
 	bnx2i_ep->state = EP_STATE_IDLE;
-	bnx2i_ep->ep_iscsi_cid = (u16)RESERVED_ITT;
+	bnx2i_ep->ep_iscsi_cid = (u16) -1;
 	bnx2i_ep->num_active_cmds = 0;
 	iscsi_cid = bnx2i_alloc_iscsi_cid(hba);
-	if (iscsi_cid == RESERVED_ITT) {
+	if (iscsi_cid == -1) {
 		printk(KERN_ALERT "alloc_ep: unable to allocate iscsi cid\n");
 		rc = -ENOMEM;
 		goto iscsi_cid_err;
@@ -1784,12 +1772,12 @@ static struct iscsi_endpoint *bnx2i_ep_connect(struct Scsi_Host *shost,
 
 	if (bnx2i_map_ep_dbell_regs(bnx2i_ep))
 		goto release_ep;
-	spin_unlock(&hba->net_dev_lock);
+	mutex_unlock(&hba->net_dev_lock);
 	return ep;
 
 release_ep:
 	if (bnx2i_tear_down_conn(hba, bnx2i_ep)) {
-		spin_unlock(&hba->net_dev_lock);
+		mutex_unlock(&hba->net_dev_lock);
 		return ERR_PTR(rc);
 	}
 conn_failed:
@@ -1798,9 +1786,9 @@ iscsi_cid_err:
 	bnx2i_free_qp_resc(hba, bnx2i_ep);
 qp_resc_err:
 	bnx2i_free_ep(ep);
-	spin_unlock(&hba->net_dev_lock);
+	mutex_unlock(&hba->net_dev_lock);
 check_busy:
-	bnx2i_check_nx2_dev_busy();
+	bnx2i_unreg_dev_all();
 	return ERR_PTR(rc);
 }
 
@@ -1930,7 +1918,7 @@ static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
 		goto return_bnx2i_ep;
 	cnic = hba->cnic;
 
-	spin_lock(&hba->net_dev_lock);
+	mutex_lock(&hba->net_dev_lock);
 
 	if (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state))
 		goto free_resc;
@@ -1974,11 +1962,11 @@ static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
 
 destory_conn:
 	if (bnx2i_tear_down_conn(hba, bnx2i_ep)) {
-		spin_unlock(&hba->net_dev_lock);
+		mutex_unlock(&hba->net_dev_lock);
 		return;
 	}
 free_resc:
-	spin_unlock(&hba->net_dev_lock);
+	mutex_unlock(&hba->net_dev_lock);
 	bnx2i_free_qp_resc(hba, bnx2i_ep);
 return_bnx2i_ep:
 	if (bnx2i_conn)
@@ -1987,14 +1975,13 @@ return_bnx2i_ep:
 	bnx2i_free_ep(ep);
 
 	if (!hba->ofld_conns_active)
-		bnx2i_check_nx2_dev_busy();
+		bnx2i_unreg_dev_all();
 }
 
 
 /**
- * bnx2i_nl_mesg_recv -
- * @buf:	pointer to buffer containing vendor specific message
- * @buf:	buffer length
+ * bnx2i_nl_set_path - ISCSI_UEVENT_PATH_UPDATE user message handler
+ * @buf:	pointer to buffer containing iscsi path message
  *
  */
 static int bnx2i_nl_set_path(struct Scsi_Host *shost, struct iscsi_path *params)
