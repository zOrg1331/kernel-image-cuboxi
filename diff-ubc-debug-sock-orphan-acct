diff -up ./include/net/sock.h.skocdebug ./include/net/sock.h
--- ./include/net/sock.h.skocdebug	2010-09-02 12:57:17.000000000 +0400
+++ ./include/net/sock.h	2010-09-02 14:11:50.000000000 +0400
@@ -398,6 +398,8 @@ enum sock_flags {
 	SOCK_RCVTSTAMP, /* %SO_TIMESTAMP setting */
 	SOCK_LOCALROUTE, /* route locally only, %SO_DONTROUTE setting */
 	SOCK_QUEUE_SHRUNK, /* write queue has been shrunk recently */
+	SOCK_ORPHAN_COUNT,
+	SOCK_ORPHAN_COUNT_UB,
 };
 
 static inline void sock_copy_flags(struct sock *nsk, struct sock *osk)
diff -up ./include/ub/beancounter.h.skocdebug ./include/ub/beancounter.h
--- ./include/ub/beancounter.h.skocdebug	2010-09-02 12:57:03.000000000 +0400
+++ ./include/ub/beancounter.h	2010-09-02 14:24:39.000000000 +0400
@@ -159,7 +159,9 @@ struct sock_private {
 #define UB_RMEM_SHRINK          2
 	struct list_head	ubp_other_socks;
 	struct list_head	ubp_tcp_socks;
+#if 0
 	atomic_t		ubp_orphan_count;
+#endif
 };
 
 struct ub_percpu_struct {
diff -up ./include/ub/ub_orphan.h.skocdebug ./include/ub/ub_orphan.h
--- ./include/ub/ub_orphan.h.skocdebug	2010-09-02 12:56:51.000000000 +0400
+++ ./include/ub/ub_orphan.h	2010-09-02 14:16:09.000000000 +0400
@@ -19,21 +19,25 @@
 
 static inline atomic_t *__ub_get_orphan_count_ptr(struct sock *sk)
 {
-#ifdef CONFIG_USER_RESOURCE
+#if 0
 	if (sock_has_ubc(sk))
 		return &sock_bc(sk)->ub->ub_orphan_count;
 #endif
 	return sk->sk_prot->orphan_count;
 }
 
+extern void sock_mark_orphan_acct(struct sock *sk);
 static inline void ub_inc_orphan_count(struct sock *sk)
 {
+	sock_mark_orphan_acct(sk);
 	atomic_inc(__ub_get_orphan_count_ptr(sk));
 }
 
+extern void sock_check_orphan_acct(struct sock *sk);
 static inline void ub_dec_orphan_count(struct sock *sk)
 {
 	atomic_dec(__ub_get_orphan_count_ptr(sk));
+	sock_check_orphan_acct(sk);
 }
 
 static inline int ub_get_orphan_count(struct sock *sk)
@@ -44,7 +48,7 @@ static inline int ub_get_orphan_count(st
 extern int __ub_too_many_orphans(struct sock *sk, int count);
 static inline int ub_too_many_orphans(struct sock *sk, int count)
 {
-#ifdef CONFIG_USER_RESOURCE
+#if 0
 	if (__ub_too_many_orphans(sk, count))
 		return 1;
 #endif
diff -up ./kernel/ub/ub_net.c.skocdebug ./kernel/ub/ub_net.c
--- ./kernel/ub/ub_net.c.skocdebug	2010-09-02 12:56:57.000000000 +0400
+++ ./kernel/ub/ub_net.c	2010-09-02 17:37:26.000000000 +0400
@@ -114,6 +114,62 @@ int __ub_too_many_orphans(struct sock *s
 	return 0;
 }
 
+static int orphan_balance_checks = 1;
+
+void sock_mark_orphan_acct(struct sock *sk)
+{
+	if (!orphan_balance_checks)
+		return;
+
+	sock_set_flag(sk, SOCK_ORPHAN_COUNT);
+	if (sock_has_ubc(sk))
+		sock_set_flag(sk, SOCK_ORPHAN_COUNT_UB);
+}
+EXPORT_SYMBOL(sock_mark_orphan_acct);
+
+void sock_print_bc(struct sock *sk)
+{
+	struct user_beancounter *ub;
+
+	ub = sock_bc(sk)->ub;
+	if (ub == NULL) {
+		printk("(none)");
+		return;
+	}
+
+	if (ub->parent != NULL)
+		printk("%d.", ub->parent->ub_uid);
+	printk("%d", ub->ub_uid);
+}
+
+void sock_check_orphan_acct(struct sock *sk)
+{
+	char *msg = NULL;
+
+	if (!orphan_balance_checks)
+		return;
+
+	if (!sock_flag(sk, SOCK_ORPHAN_COUNT))
+		msg = "Dec orphans with no inc";
+	else {
+		if (sock_has_ubc(sk) && !sock_flag(sk, SOCK_ORPHAN_COUNT_UB))
+			msg = "Dec orphan on UB but inc on PROT";
+		else if (!sock_has_ubc(sk) && sock_flag(sk, SOCK_ORPHAN_COUNT_UB))
+			msg = "Dec orphan on PROT but inc on UB";
+	}
+
+	sock_reset_flag(sk, SOCK_ORPHAN_COUNT);
+	sock_reset_flag(sk, SOCK_ORPHAN_COUNT_UB);
+
+	if (msg != NULL) {
+		orphan_balance_checks = 0;
+		printk("WARNING: %s ", msg);
+		sock_print_bc(sk);
+		printk("\n");
+		dump_stack();
+	}
+}
+
 /*
  * Queueing
  */
diff -up ./net/ipv4/inet_connection_sock.c.skocdebug ./net/ipv4/inet_connection_sock.c
--- ./net/ipv4/inet_connection_sock.c.skocdebug	2010-09-02 12:56:59.000000000 +0400
+++ ./net/ipv4/inet_connection_sock.c	2010-09-02 14:21:39.000000000 +0400
@@ -617,6 +617,8 @@ int inet_csk_listen_start(struct sock *s
 
 EXPORT_SYMBOL_GPL(inet_csk_listen_start);
 
+extern void sock_print_bc(struct sock *sk);
+
 /*
  *	This routine closes sockets which have been at least partially
  *	opened, but not yet accepted.
@@ -644,6 +646,7 @@ void inet_csk_listen_stop(struct sock *s
 
 	while ((req = acc_req) != NULL) {
 		struct sock *child = req->sk;
+		static int once = 1;
 
 		acc_req = req->dl_next;
 
@@ -658,8 +661,17 @@ void inet_csk_listen_stop(struct sock *s
 
 		sock_orphan(child);
 
-		ub_inc_orphan_count(sk);
+		ub_inc_orphan_count(child);
 
+		if (once && sock_bc(sk)->ub != sock_bc(child)->ub) {
+			once = 0;
+			printk("WARNING: Mismatch in sk/child sockets: ");
+			sock_print_bc(sk);
+			sock_print_bc(child);
+			printk("\n");
+			dump_stack();
+		}
+
 		inet_csk_destroy_sock(child);
 
 		bh_unlock_sock(child);
