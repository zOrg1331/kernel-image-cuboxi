From: Tomas Henzl <thenzl@redhat.com>
Date: Sun, 29 Aug 2010 15:49:57 -0400
Subject: [block] cciss: reorder functions
Message-id: <1283097002-3341-59-git-send-email-thenzl@redhat.com>
Patchwork-id: 27903
O-Subject: [RHEL6 PATCH 58/63] cciss: reorder functions
Bugzilla: 568830
RH-Acked-by: Neil Horman <nhorman@redhat.com>

This patch *only* reorders functions to better match kernel.org source code
to make future patching go more smoothly.  It does not change any functionality.

diff --git a/drivers/block/cciss.c b/drivers/block/cciss.c
index c578efa..c448b1d 100644
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -192,6 +192,12 @@ static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c);
 static void cciss_free_gendisk(ctlr_info_t *h, int drv_index);
 static void cciss_free_drive_info(ctlr_info_t *h, int drv_index);
 static void cciss_clear_drive_info(drive_info_struct *drive_info);
+static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
+			drive_info_struct *drv);
+static inline void complete_pc_buffers(struct bio *bio,
+	unsigned int nr_bytes, int status);
+static inline void complete_fs_buffers(struct bio *bio, int status);
+static unsigned int blk_rq_bytes(struct request *rq);
 
 #ifdef CONFIG_PROC_FS
 static void cciss_procinit(int i);
@@ -244,13 +250,6 @@ static inline void removeQ(CommandList_struct *c)
 	hlist_del_init(&c->list);
 }
 
-static void log_unit_to_scsi3addr(ctlr_info_t *h, unsigned char scsi3addr[],
-	uint32_t log_unit)
-{
-	memcpy(scsi3addr, h->drv[log_unit]->LunID,
-		sizeof(h->drv[log_unit]->LunID));
-}
-
 static void cciss_free_sg_chain_blocks(SGDescriptor_struct **cmd_sg_list,
 	int nr_cmds)
 {
@@ -326,17 +325,12 @@ static void cciss_map_sg_chain_block(ctlr_info_t *h, CommandList_struct *c,
 
 #include "cciss_scsi.c"		/* For SCSI tape support */
 
-#ifdef CONFIG_PROC_FS
+static const char *raid_label[] = { "0", "4", "1(1+0)", "5", "5+1", "ADG",
+	"UNKNOWN"
+};
+#define RAID_UNKNOWN (sizeof(raid_label) / sizeof(raid_label[0]) - 1)
 
-/* cciss_hba_release is called when the reference count
- * of h->dev goes to zero.
- */
-static void cciss_hba_release(struct device *dev)
-{
-	/* nothing to do, but need this to avoid a warning
-	 * about not having a release handler from lib/kref.c.
-	 */
-}
+#ifdef CONFIG_PROC_FS
 
 /*
  * Report information about this controller.
@@ -344,10 +338,6 @@ static void cciss_hba_release(struct device *dev)
 #define ENG_GIG 1000000000
 #define ENG_GIG_FACTOR (ENG_GIG/512)
 #define ENGAGE_SCSI	"engage scsi"
-static const char *raid_label[] = { "0", "4", "1(1+0)", "5", "5+1", "ADG",
-	"UNKNOWN"
-};
-#define RAID_UNKNOWN (sizeof(raid_label) / sizeof(raid_label[0]) - 1)
 
 static struct proc_dir_entry *proc_cciss;
 
@@ -734,6 +724,15 @@ static struct bus_type cciss_bus_type = {
 	.name		= "cciss",
 };
 
+/* cciss_hba_release is called when the reference count
+ * of h->dev goes to zero.
+ */
+static void cciss_hba_release(struct device *dev)
+{
+	/* nothing to do, but need this to avoid a warning
+	 * about not having a release handler from lib/kref.c.
+	 */
+}
 
 /*
  * Initialize sysfs entry for each controller.  This sets up and registers
@@ -1132,53 +1131,13 @@ static int cciss_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 	return 0;
 }
 
-static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
-			drive_info_struct *drv)
-{
-	int return_code;
-	InquiryData_struct *inq_buff;
-	unsigned char scsi3addr[8];
-
-	/* If there are no heads then this is the controller disk and
-	 * not a valid logical drive so don't query it.
-	 */
-	if (!drv->heads)
-		return;
-
-	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
-	if (!inq_buff) {
-		printk(KERN_ERR "cciss: out of memory\n");
-		goto err;
-	}
-	log_unit_to_scsi3addr(hba[ctlr], scsi3addr, logvol);
-	return_code = sendcmd_withirq(CISS_INQUIRY, ctlr,
-		inq_buff, sizeof(*inq_buff), 0, scsi3addr, TYPE_CMD);
-	if (return_code == IO_OK) {
-		memcpy(drv->vendor, &inq_buff->data_byte[8], 8);
-		drv->vendor[8]='\0';
-		memcpy(drv->model, &inq_buff->data_byte[16], 16);
-		drv->model[16] = '\0';
-		memcpy(drv->rev, &inq_buff->data_byte[32], 4);
-		drv->rev[4] = '\0';
-	} else { /* Get geometry failed */
-		printk(KERN_WARNING "cciss: inquiry for VPD page 0 failed\n");
-	}
-
-	cciss_get_uid(ctlr, logvol, drv->uid, sizeof(drv->uid));
-	
-err:
-	drv->vendor[8] = '\0';
-	drv->model[16] = '\0';
-	drv->rev[4] = '\0';
-
-}
-
 static void check_ioctl_unit_attention(ctlr_info_t *host, CommandList_struct *c)
 {
 	if (c->err_info->CommandStatus == CMD_TARGET_STATUS &&
 			c->err_info->ScsiStatus != SAM_STAT_CHECK_CONDITION)
 		(void)check_for_unit_attention(host, c);
 }
+
 /*
  * ioctl
  */
@@ -1692,37 +1651,6 @@ static int cciss_ioctl(struct inode *inode, struct file *filep,
 	}
 }
 
-static inline void complete_pc_buffers(struct bio *bio, unsigned int nr_bytes, int status)
-{
-	unsigned int bytes_remaining = nr_bytes;
-
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
-
-		if (bytes_in_this_bio > bytes_remaining)
-			bytes_in_this_bio = bytes_remaining;
-
-		bio->bi_next = NULL;
-		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
-		bio = xbh;
-
-		bytes_remaining -= bytes_in_this_bio;
-	}
-}
-
-static inline void complete_fs_buffers(struct bio *bio, int status)
-{
-	while (bio) {
-		struct bio *xbh = bio->bi_next;
-		unsigned int nr_bytes = bio_sectors(bio) << 9;
- 
-		bio->bi_next = NULL;
-		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
-		bio = xbh;
-	}
-}
-
 static void cciss_check_queues(ctlr_info_t *h)
 {
 	int start_queue = h->next_to_run;
@@ -1771,23 +1699,6 @@ static void cciss_check_queues(ctlr_info_t *h)
 	}
 }
 
-/**
- * blk_rq_bytes - Returns bytes left to complete in the entire request
- * @rq: the request being processed
- * this function is copied from later kernels (2.6.29-ish), where it is
- * normally defined in blk/blk-core.c
- * Slightly modified for older kernels.
- **/
-static unsigned int blk_rq_bytes(struct request *rq)
-{
-	int nr_sectors = bio_sectors(rq->bio);
-
-	if (blk_fs_request(rq))
-		return nr_sectors << 9;
-
-	return rq->data_len;
-}
-
 static void cciss_softirq_done(struct request *rq)
 {
 	CommandList_struct *cmd = rq->completion_data;
@@ -1844,6 +1755,13 @@ static void cciss_softirq_done(struct request *rq)
 	spin_unlock_irqrestore(&h->lock, flags);
 }
 
+static void log_unit_to_scsi3addr(ctlr_info_t *h, unsigned char scsi3addr[],
+	uint32_t log_unit)
+{
+	memcpy(scsi3addr, h->drv[log_unit]->LunID,
+		sizeof(h->drv[log_unit]->LunID));
+}
+
 /* This function gets the SCSI vendor, model, and revision of a logical drive
  * via the inquiry page 0.  Model, vendor, and rev are set to empty strings if
  * they cannot be read.
@@ -4503,5 +4421,95 @@ static void fail_all_cmds(unsigned long ctlr)
 	return;
 }
 
+static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
+			drive_info_struct *drv)
+{
+	int return_code;
+	InquiryData_struct *inq_buff;
+	unsigned char scsi3addr[8];
+
+	/* If there are no heads then this is the controller disk and
+	 * not a valid logical drive so don't query it.
+	 */
+	if (!drv->heads)
+		return;
+
+	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
+	if (!inq_buff) {
+		printk(KERN_ERR "cciss: out of memory\n");
+		goto err;
+	}
+	log_unit_to_scsi3addr(hba[ctlr], scsi3addr, logvol);
+	return_code = sendcmd_withirq(CISS_INQUIRY, ctlr,
+		inq_buff, sizeof(*inq_buff), 0, scsi3addr, TYPE_CMD);
+	if (return_code == IO_OK) {
+		memcpy(drv->vendor, &inq_buff->data_byte[8], 8);
+		drv->vendor[8]='\0';
+		memcpy(drv->model, &inq_buff->data_byte[16], 16);
+		drv->model[16] = '\0';
+		memcpy(drv->rev, &inq_buff->data_byte[32], 4);
+		drv->rev[4] = '\0';
+	} else { /* Get geometry failed */
+		printk(KERN_WARNING "cciss: inquiry for VPD page 0 failed\n");
+	}
+
+	cciss_get_uid(ctlr, logvol, drv->uid, sizeof(drv->uid));
+	
+err:
+	drv->vendor[8] = '\0';
+	drv->model[16] = '\0';
+	drv->rev[4] = '\0';
+
+}
+
+static inline void complete_pc_buffers(struct bio *bio,
+	unsigned int nr_bytes, int status)
+{
+	unsigned int bytes_remaining = nr_bytes;
+
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int bytes_in_this_bio = bio_sectors(bio) << 9;
+
+		if (bytes_in_this_bio > bytes_remaining)
+			bytes_in_this_bio = bytes_remaining;
+
+		bio->bi_next = NULL;
+		bio_endio(bio, bytes_in_this_bio, status ? 0 : -EIO);
+		bio = xbh;
+
+		bytes_remaining -= bytes_in_this_bio;
+	}
+}
+
+static inline void complete_fs_buffers(struct bio *bio, int status)
+{
+	while (bio) {
+		struct bio *xbh = bio->bi_next;
+		unsigned int nr_bytes = bio_sectors(bio) << 9;
+ 
+		bio->bi_next = NULL;
+		bio_endio(bio, nr_bytes, status ? 0 : -EIO);
+		bio = xbh;
+	}
+}
+
+/**
+ * blk_rq_bytes - Returns bytes left to complete in the entire request
+ * @rq: the request being processed
+ * this function is copied from later kernels (2.6.29-ish), where it is
+ * normally defined in blk/blk-core.c
+ * Slightly modified for older kernels.
+ **/
+static unsigned int blk_rq_bytes(struct request *rq)
+{
+	int nr_sectors = bio_sectors(rq->bio);
+
+	if (blk_fs_request(rq))
+		return nr_sectors << 9;
+
+	return rq->data_len;
+}
+
 module_init(cciss_init);
 module_exit(cciss_cleanup);
