From: ddugger@redhat.com <ddugger@redhat.com>
Date: Mon, 23 Mar 2009 10:23:23 -0600
Subject: [xen] sync VT-d2 code with xen-unstable
Message-id: 200903231623.n2NGNNeR022111@sobek.n0ano.com
O-Subject: [RHEL5.4 PATCH 14/21 V2] sync VT-d2 code with xen-unstable
Bugzilla: 484227
RH-Acked-by: Chris Lalancette <clalance@redhat.com>
RH-Acked-by: Gerd Hoffmann <kraxel@redhat.com>
RH-Acked-by: Chris Lalancette <clalance@redhat.com>

Mainly change ordering of struct declarations and definitions, no actual
code differences. Make it consistent with xen-unstable, and make it
easier to pick up fixes from xen-unstable if needed.

Upstream Status: Accepted

BZ: 484227

Signed-off-by: Weidong Han <weidong.han@intel.com>
Signed-off-by: Gerd Hoffman <kraxel@redhat.com>
Signed-off-by: Don Dugger <donald.d.dugger@intel.com>

diff --git a/drivers/passthrough/vtd/dmar.c b/drivers/passthrough/vtd/dmar.c
index 62c65d1..4e20aef 100644
--- a/drivers/passthrough/vtd/dmar.c
+++ b/drivers/passthrough/vtd/dmar.c
@@ -107,6 +107,36 @@ static void __init disable_all_dmar_units(void)
     }
 }
 
+static int acpi_ioapic_device_match(
+    struct list_head *ioapic_list, unsigned int apic_id)
+{
+    struct acpi_ioapic_unit *ioapic;
+    list_for_each_entry( ioapic, ioapic_list, list ) {
+        if (ioapic->apic_id == apic_id)
+            return 1;
+    }
+    return 0;
+}
+
+struct acpi_drhd_unit * ioapic_to_drhd(unsigned int apic_id)
+{
+    struct acpi_drhd_unit *drhd;
+    list_for_each_entry( drhd, &acpi_drhd_units, list )
+        if ( acpi_ioapic_device_match(&drhd->ioapic_list, apic_id) )
+            return drhd;
+    return NULL;
+}
+
+struct iommu * ioapic_to_iommu(unsigned int apic_id)
+{
+    struct acpi_drhd_unit *drhd;
+
+    list_for_each_entry( drhd, &acpi_drhd_units, list )
+        if ( acpi_ioapic_device_match(&drhd->ioapic_list, apic_id) )
+            return drhd->iommu;
+    return NULL;
+}
+
 static int __init acpi_register_atsr_unit(struct acpi_atsr_unit *atsr)
 {
     /*
@@ -164,36 +194,6 @@ struct acpi_atsr_unit * acpi_find_matched_atsr_unit(u8 bus, u8 devfn)
     return found ? found : include_all;
 }
 
-static int acpi_ioapic_device_match(
-    struct list_head *ioapic_list, unsigned int apic_id)
-{
-    struct acpi_ioapic_unit *ioapic;
-    list_for_each_entry( ioapic, ioapic_list, list ) {
-        if (ioapic->apic_id == apic_id)
-            return 1;
-    }
-    return 0;
-}
-
-struct acpi_drhd_unit * ioapic_to_drhd(unsigned int apic_id)
-{
-    struct acpi_drhd_unit *drhd;
-    list_for_each_entry( drhd, &acpi_drhd_units, list )
-        if ( acpi_ioapic_device_match(&drhd->ioapic_list, apic_id) )
-            return drhd;
-    return NULL;
-}
-
-struct iommu * ioapic_to_iommu(unsigned int apic_id)
-{
-    struct acpi_drhd_unit *drhd;
-
-    list_for_each_entry( drhd, &acpi_drhd_units, list )
-        if ( acpi_ioapic_device_match(&drhd->ioapic_list, apic_id) )
-            return drhd->iommu;
-    return NULL;
-}
-
 /*
  * Count number of devices in device scope.  Do not include PCI sub
  * hierarchies.
diff --git a/drivers/passthrough/vtd/extern.h b/drivers/passthrough/vtd/extern.h
index 924cdeb..1909121 100644
--- a/drivers/passthrough/vtd/extern.h
+++ b/drivers/passthrough/vtd/extern.h
@@ -23,14 +23,15 @@
 
 #include "dmar.h"
 
+extern struct qi_ctrl *qi_ctrl;
+extern struct ir_ctrl *ir_ctrl;
 
 void print_iommu_regs(struct acpi_drhd_unit *drhd);
 void print_vtd_entries(struct iommu *iommu, int bus, int devfn, u64 gmfn);
 void dump_iommu_info(unsigned char key);
 
-void clear_fault_bits(struct iommu *iommu);
-
 int qinval_setup(struct iommu *iommu);
+int intremap_setup(struct iommu *iommu);
 int queue_invalidate_context(struct iommu *iommu,
     u16 did, u16 source_id, u8 function_mask, u8 granu);
 int queue_invalidate_iotlb(struct iommu *iommu,
@@ -40,9 +41,8 @@ int queue_invalidate_iec(struct iommu *iommu,
 int invalidate_sync(struct iommu *iommu);
 int iommu_flush_iec_global(struct iommu *iommu);
 int iommu_flush_iec_index(struct iommu *iommu, u8 im, u16 iidx);
-
-int intremap_setup(struct iommu *iommu);
 struct iommu * ioapic_to_iommu(unsigned int apic_id);
 struct acpi_drhd_unit * ioapic_to_drhd(unsigned int apic_id);
+void clear_fault_bits(struct iommu *iommu);
 
 #endif // _VTD_EXTERN_H_
diff --git a/drivers/passthrough/vtd/iommu.h b/drivers/passthrough/vtd/iommu.h
index 63bb446..5037e57 100644
--- a/drivers/passthrough/vtd/iommu.h
+++ b/drivers/passthrough/vtd/iommu.h
@@ -271,6 +271,41 @@ struct dma_pte {
             (p).val |= ((addr) & PAGE_MASK_4K); } while (0)
 #define dma_pte_present(p) (((p).val & 3) != 0)
 
+/* interrupt remap entry */
+struct iremap_entry {
+  union {
+    u64 lo_val;
+    struct {
+        u64 p       : 1,
+            fpd     : 1,
+            dm      : 1,
+            rh      : 1,
+            tm      : 1,
+            dlm     : 3,
+            avail   : 4,
+            res_1   : 4,
+            vector  : 8,
+            res_2   : 8,
+            dst     : 32;
+    }lo;
+  };
+  union {
+    u64 hi_val;
+    struct {
+        u64 sid     : 16,
+            sq      : 2,
+            svt     : 2,
+            res_1   : 44;
+    }hi;
+  };
+};
+#define IREMAP_ENTRY_NR (PAGE_SIZE_4K/sizeof(struct iremap_entry))
+#define iremap_present(v) ((v).lo & 1)
+#define iremap_fault_disable(v) (((v).lo >> 1) & 1)
+
+#define iremap_set_present(v) do {(v).lo |= 1;} while(0)
+#define iremap_clear_present(v) do {(v).lo &= ~1;} while(0)
+
 /* queue invalidation entry */
 struct qinval_entry {
     union {
@@ -382,42 +417,6 @@ struct poll_info {
 
 #define IEC_GLOBAL_INVL         0
 #define IEC_INDEX_INVL          1
-
-/* interrupt remap entry */
-struct iremap_entry {
-  union {
-    u64 lo_val;
-    struct {
-        u64 p       : 1,
-            fpd     : 1,
-            dm      : 1,
-            rh      : 1,
-            tm      : 1,
-            dlm     : 3,
-            avail   : 4,
-            res_1   : 4,
-            vector  : 8,
-            res_2   : 8,
-            dst     : 32;
-    }lo;
-  };
-  union {
-    u64 hi_val;
-    struct {
-        u64 sid     : 16,
-            sq      : 2,
-            svt     : 2,
-            res_1   : 44;
-    }hi;
-  };
-};
-#define IREMAP_ENTRY_NR (PAGE_SIZE_4K/sizeof(struct iremap_entry))
-#define iremap_present(v) ((v).lo & 1)
-#define iremap_fault_disable(v) (((v).lo >> 1) & 1)
-
-#define iremap_set_present(v) do {(v).lo |= 1;} while(0)
-#define iremap_clear_present(v) do {(v).lo &= ~1;} while(0)
-
 #define IRTA_REG_EIME_SHIFT     11
 #define IRTA_REG_TABLE_SIZE     7    // 4k page = 256 * 16 byte entries
                                      // 2^^(IRTA_REG_TABLE_SIZE + 1) = 256
@@ -433,13 +432,6 @@ extern struct list_head acpi_drhd_units;
 extern struct list_head acpi_rmrr_units;
 extern struct list_head acpi_ioapic_units;
 
-struct iommu_flush {
-    int (*context)(void *iommu, u16 did, u16 source_id,
-                   u8 function_mask, u64 type, int non_present_entry_flush);
-    int (*iotlb)(void *iommu, u16 did, u64 addr, unsigned int size_order,
-                 u64 type, int non_present_entry_flush);
-};
-
 struct qi_ctrl {
     u64 qinval_maddr;  /* queue invalidation page machine address */
     int qinval_index;                    /* queue invalidation index */
@@ -454,10 +446,17 @@ struct ir_ctrl {
     spinlock_t iremap_lock;      /* lock for irq remappping table */
 };
 
+struct iommu_flush {
+    int (*context)(void *iommu, u16 did, u16 source_id,
+                   u8 function_mask, u64 type, int non_present_entry_flush);
+    int (*iotlb)(void *iommu, u16 did, u64 addr, unsigned int size_order,
+                 u64 type, int non_present_entry_flush);
+};
+
 struct intel_iommu {
-    struct iommu_flush flush;
     struct qi_ctrl qi_ctrl;
     struct ir_ctrl ir_ctrl;
+    struct iommu_flush flush;
 };
 
 #endif
diff --git a/include/xen/iommu.h b/include/xen/iommu.h
index e9aa08d..9edc12c 100644
--- a/include/xen/iommu.h
+++ b/include/xen/iommu.h
@@ -78,9 +78,9 @@ unsigned int io_apic_read_remap_rte(unsigned int apic, unsigned int reg);
 void io_apic_write_remap_rte(unsigned int apic,
                              unsigned int reg, unsigned int value);
 
-struct iommu_flush *iommu_get_flush(struct iommu *iommu);
 struct qi_ctrl *iommu_qi_ctrl(struct iommu *iommu);
 struct ir_ctrl *iommu_ir_ctrl(struct iommu *iommu);
+struct iommu_flush *iommu_get_flush(struct iommu *iommu);
 void hvm_dpci_isairq_eoi(struct domain *d, unsigned int isairq);
 struct hvm_irq_dpci *domain_get_irq_dpci(struct domain *domain);
 int domain_set_irq_dpci(struct domain *domain, struct hvm_irq_dpci *dpci);
