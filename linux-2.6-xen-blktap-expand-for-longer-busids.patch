From: Chris Lalancette <clalance@redhat.com>
Date: Fri, 18 Jul 2008 10:05:37 +0200
Subject: [xen] blktap: expand for longer busids
Message-id: 48804ED1.2070701@redhat.com
O-Subject: [RHEL5.3 PATCH 3/5]: Expand blktap kernel side for longer busids
Bugzilla: 442723
RH-Acked-by: Bill Burns <bburns@redhat.com>
RH-Acked-by: Mark McLoughlin <markmc@redhat.com>
RH-Acked-by: Rik van Riel <riel@redhat.com>

Because we are now using at least 28 bits for the extended vbd structure, we
need to use a 32-bit busid quantity to store this information.  Unfortunately,
the in-kernel representation of the busid, and the ioctl() between the userland
and the kernel both represent the busid as an unsigned short.  To remedy this,
add a new IOCTL (BLKTAP_IOCTL_NEWINTF_EXT) that accepts a pointer to the
extended structure, which contains a 32-bit quantity for storing the busid.
This corresponds to Xen linux-2.6.18-xen.hg c/s 582 and 598.

diff --git a/drivers/xen/blktap/blktapmain.c b/drivers/xen/blktap/blktapmain.c
index 6d377e8..c4682e8 100644
--- a/drivers/xen/blktap/blktapmain.c
+++ b/drivers/xen/blktap/blktapmain.c
@@ -132,7 +132,12 @@ typedef struct domid_translate {
 	unsigned short busid;
 } domid_translate_t ;
 
-static domid_translate_t  translate_domid[MAX_TAP_DEV];
+typedef struct domid_translate_ext {
+	unsigned short domid;
+	u32 busid;
+} domid_translate_ext_t ;
+
+static domid_translate_ext_t  translate_domid[MAX_TAP_DEV];
 static tap_blkif_t *tapfds[MAX_TAP_DEV];
 
 static int __init set_blkif_reqs(char *str)
@@ -238,6 +243,7 @@ static int blktap_major;
 #define BLKTAP_IOCTL_MAJOR	     7
 #define BLKTAP_QUERY_ALLOC_REQS      8
 #define BLKTAP_IOCTL_FREEINTF        9
+#define BLKTAP_IOCTL_NEWINTF_EXT     50
 #define BLKTAP_IOCTL_PRINT_IDXS      100  
 
 /* blktap switching modes: (Set with BLKTAP_IOCTL_SETMODE)             */
@@ -395,6 +401,13 @@ void signal_tapdisk(int idx)
 	tap_blkif_t *info;
 	struct task_struct *ptask;
 
+	/*
+	 * if the userland tools set things up wrong, this could be negative;
+	 * just don't try to signal in this case
+	 */
+	if (idx < 0)
+		return;
+
 	info = tapfds[idx];
 	if ( (idx > 0) && (idx < MAX_TAP_DEV) && (info->pid > 0) ) {
 		ptask = find_task_by_pid(info->pid);
@@ -635,6 +648,27 @@ static int blktap_ioctl(struct inode *inode, struct file *filp,
 		translate_domid[newdev].busid = tr->busid;
 		return newdev;
 	}
+	case BLKTAP_IOCTL_NEWINTF_EXT:
+	{
+		void __user *udata = (void __user *) arg;
+		domid_translate_ext_t tr;
+		int newdev;
+
+		if (copy_from_user(&tr, udata, sizeof(domid_translate_ext_t)))
+			return -EFAULT;
+
+		DPRINTK("NEWINTF_EXT Req for domid %d and bus id %d\n", 
+		       tr.domid, tr.busid);
+		newdev = get_next_free_dev();
+		if (newdev < 1) {
+			WPRINTK("Error initialising /dev/xen/blktap - "
+				"No more devices\n");
+			return -1;
+		}
+		translate_domid[newdev].domid = tr.domid;
+		translate_domid[newdev].busid = tr.busid;
+		return newdev;
+	}
 	case BLKTAP_IOCTL_FREEINTF:
 	{
 		unsigned long dev = arg;
