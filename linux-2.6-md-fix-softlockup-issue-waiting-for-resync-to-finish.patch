From: James Paradis <jparadis@redhat.com>
Date: Wed, 6 Oct 2010 20:31:32 -0400
Subject: [md] fix softlockup issue waiting for resync to finish
Message-id: <20101006203524.7364.85555.sendpatchset@localhost.localdomain>
Patchwork-id: 28636
O-Subject: [RHEL5.6 PATCH] Fix softlockup issue in md
Bugzilla: 573106
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

https://bugzilla.redhat.com/show_bug.cgi?id=573106

This is a backport of upstream patch 9744197c3d7b329590c2be33ad7b17409bd798fe

>From the commit comments:

    md: Don't wait UNINTERRUPTIBLE for other resync to finish

    When two md arrays share some block device (e.g each uses different
    partitions on the one device), a resync of one array will wait for
    the resync on the other to finish.

    This can be a long time and as it currently waits TASK_UNINTERRUPTIBLE,
    the softlockup code notices and complains.

    So use TASK_INTERRUPTIBLE instead and make sure to flush signals
    before calling schedule.

Stratus' partner NEC ran into this, but it's an issue of general concern.

 md.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/md/md.c b/drivers/md/md.c
index 1272711..086fa43 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -5191,7 +5191,11 @@ void md_do_sync(mddev_t *mddev)
 					 * time 'round when curr_resync == 2
 					 */
 					continue;
-				prepare_to_wait(&resync_wait, &wq, TASK_UNINTERRUPTIBLE);
+				/* We need to wait 'interruptible' so as not to
+				 * contribute to the load average, and not to
+				 * be caught by 'softlockup'
+				 */
+				prepare_to_wait(&resync_wait, &wq, TASK_INTERRUPTIBLE);
 				if (!kthread_should_stop() &&
 				    mddev2->curr_resync >= mddev->curr_resync) {
 					printk(KERN_INFO "md: delaying resync of %s"
@@ -5199,6 +5203,8 @@ void md_do_sync(mddev_t *mddev)
 					       " share one or more physical units)\n",
 					       mdname(mddev), mdname(mddev2));
 					mddev_put(mddev2);
+					if (signal_pending(current))
+						flush_signals(current);
 					schedule();
 					finish_wait(&resync_wait, &wq);
 					goto try_again;
