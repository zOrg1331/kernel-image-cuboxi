From: Hendrik Brueckner <brueckner@redhat.com>
Date: Wed, 4 Aug 2010 10:02:58 -0400
Subject: [s390] qeth: wait for finished recovery
Message-id: <1280916181-27024-6-git-send-email-brueckner@redhat.com>
Patchwork-id: 27369
O-Subject: [RHEL5.6 PATCH 5/8] [s390x] qeth: wait for finished recovery
Bugzilla: 619456
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>

Description
-----------
recovery of qeth device fails

The qeth net_device_ops set_mac_address, set_multicast_list
vlan_rx_add_vid, and vlan_rx_kill_vid use IPA commands.
IPA commands can only be invoked, if the initialization
sequence of a qeth device has been run completely.
If those operations are running while a qeth device is
reinitialized due to a scheduled recovery, the sequence of
requests and responses to initialize the qeth device is
broken and recovery fails.

Wait till recovery is finished when changing a mac address,
configuring a VLAN interface on top, or when adding
multicast addresses.

Bugzilla
--------
BZ 619456
https://bugzilla.redhat.com/show_bug.cgi?id=619456

Upstream status of the patch
----------------------------
The patch is upstream as of kernel version 2.6.30
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=8e98ac48d06068470f1b954e599cf7b706cfceba

Test status
-----------
The patch has been tested and fixes the problem.
The fix has been verified by the IBM test department.

diff --git a/drivers/s390/net/qeth_main.c b/drivers/s390/net/qeth_main.c
index 1344cac..a36bf28 100644
--- a/drivers/s390/net/qeth_main.c
+++ b/drivers/s390/net/qeth_main.c
@@ -5654,6 +5654,10 @@ qeth_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
 		QETH_DBF_TEXT(trace, 3, "aidOSM");
 		return;
 	}
+	if (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {
+		QETH_DBF_TEXT(trace, 3, "aidREC");
+		return;
+	}
 	qeth_layer2_send_setdelvlan(card, vid, IPA_CMD_SETVLAN);
 }
 
@@ -5667,6 +5671,10 @@ qeth_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
 	QETH_DBF_TEXT_(trace, 4, "kid:%d", vid);
 
 	card = (struct qeth_card *) dev->priv;
+	if (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {
+		QETH_DBF_TEXT(trace, 3, "kidREC");
+		return;
+	}
 	/* free all skbs for the vlan device */
 	if (card->info.type == QETH_CARD_TYPE_OSM) {
 		QETH_DBF_TEXT(trace, 3, "kidOSM");
@@ -5738,6 +5746,8 @@ qeth_setadp_promisc_mode(struct qeth_card *card)
 	qeth_send_ipa_cmd(card, iob, qeth_setadp_promisc_mode_cb, NULL);
 }
 
+static int qeth_threads_running(struct qeth_card *, unsigned long);
+
 /**
  * set multicast address on card
  */
@@ -5750,6 +5760,9 @@ qeth_set_multicast_list(struct net_device *dev)
 		return ;
 
 	QETH_DBF_TEXT(trace, 3, "setmulti");
+	if (qeth_threads_running(card, QETH_RECOVER_THREAD) &&
+	    (card->state != CARD_STATE_UP))
+		return;
 	qeth_delete_mc_addresses(card);
 	if (card->options.layer2) {
 		qeth_layer2_add_multicast(card);
@@ -6264,6 +6277,10 @@ qeth_layer2_set_mac_address(struct net_device *dev, void *p)
 	}
 	QETH_DBF_TEXT_(trace, 3, "%s", CARD_BUS_ID(card));
 	QETH_DBF_HEX(trace, 3, addr->sa_data, OSA_ADDR_LEN);
+	if (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {
+		QETH_DBF_TEXT(trace, 3, "setmcREC");
+		return -ERESTARTSYS;
+	}
 	rc = qeth_layer2_send_delmac(card, &card->dev->dev_addr[0]);
 	if (!rc)
 		rc = qeth_layer2_send_setmac(card, addr->sa_data);
@@ -7883,7 +7900,7 @@ qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,
 	wake_up(&card->wait_q);
 }
 
-static inline int
+static int
 qeth_threads_running(struct qeth_card *card, unsigned long threads)
 {
 	unsigned long flags;
