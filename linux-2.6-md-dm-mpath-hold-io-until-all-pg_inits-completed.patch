From: Mike Snitzer <snitzer@redhat.com>
Date: Tue, 8 Feb 2011 18:49:07 -0500
Subject: [md] dm-mpath: hold io until all pg_inits completed
Message-id: <1297190949-29149-8-git-send-email-snitzer@redhat.com>
Patchwork-id: 33173
O-Subject: [RHEL5.7 PATCH 6/8] dm mpath: hold io until all pg_inits completed
Bugzilla: 673058
RH-Acked-by: Alasdair G Kergon <agk@redhat.com>

BZ 673058

Upstream commit d0259bf0eefc503d3c9c9ccda35033c3dd3aac30
Author: Kiyoshi Ueda <k-ueda@ct.jp.nec.com>
Date:   Sat Mar 6 02:30:02 2010 +0000

    dm mpath: hold io until all pg_inits completed

    m->queue_io is set to block processing I/Os, and it needs to be kept
    while pg-init, which issues multiple path activations, is in progress.
    But m->queue is cleared when a path activation completes without error
    in pg_init_done(), even while other path activations are in progress.
    That may cause undesired -EIO on paths which are not complete activation.

    This patch fixes that by not clearing m->queue_io until all path
    activations complete.

    (Before the hardware handlers were moved into the SCSI layer, pg_init
    only used one path.)

    Signed-off-by: Kiyoshi Ueda <k-ueda@ct.jp.nec.com>
    Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>

diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 4de9a33..b8adff1 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1243,16 +1243,20 @@ static void pg_init_done(void *data, int errors)
 			m->current_pgpath = NULL;
 			m->current_pg = NULL;
 		}
-	} else if (!m->pg_init_required) {
-		m->queue_io = 0;
+	} else if (!m->pg_init_required)
 		pg->bypassed = 0;
-	}
 
-	m->pg_init_in_progress--;
-	if (!m->pg_init_in_progress) {
-		m->pg_init_delay = delay;
-		queue_work(kmultipathd, &m->process_queued_ios);
-	}
+	if (--m->pg_init_in_progress)
+		/* Activations of other paths are still on going */
+		goto out;
+
+	if (!m->pg_init_required)
+		m->queue_io = 0;
+
+	m->pg_init_delay = delay;
+	queue_work(kmultipathd, &m->process_queued_ios);
+
+out:
 	spin_unlock_irqrestore(&m->lock, flags);
 }
 
