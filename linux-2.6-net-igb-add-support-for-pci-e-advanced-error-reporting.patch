From: Stefan Assmann <sassmann@redhat.com>
Date: Thu, 25 Feb 2010 15:45:01 -0500
Subject: [net] igb: Add support for pci-e Advanced Error Reporting
Message-id: <4B869AFD.500@redhat.com>
Patchwork-id: 23431
O-Subject: [RHEL 5.5 PATCH] igb: Add support for pci-e Advanced Error Reporting
Bugzilla: 568221
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: Andy Gospodarek <gospo@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>

Bugzilla:
https://bugzilla.redhat.com/show_bug.cgi?id=568221

Description:
Add the calls necessary to enable advanced error reporting for igb on
systems with AER enabled.
Note: RHEL5 requires the commandline parameter pci=aer to be set.

Upstream Status:
http://git.kernel.org/linus/40a914fa72abdb9193ecad7dd82e48d952ab9d24

Brew Build:
https://brewweb.devel.redhat.com/taskinfo?taskID=2283647

Test Status:
Tested by prarit and myself.

  Stefan

diff --git a/drivers/net/igb/igb_main.c b/drivers/net/igb/igb_main.c
index f4a2833..e802398 100644
--- a/drivers/net/igb/igb_main.c
+++ b/drivers/net/igb/igb_main.c
@@ -41,6 +41,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/if_ether.h>
+#include <linux/aer.h>
 #ifdef CONFIG_IGB_DCA
 #include <linux/dca.h>
 #endif
@@ -1265,6 +1266,8 @@ static int __devinit igb_probe(struct pci_dev *pdev,
 	if (err)
 		goto err_pci_reg;
 
+	pci_enable_pcie_error_reporting(pdev);
+
 	pci_set_master(pdev);
 	pci_save_state(pdev);
 
@@ -1659,6 +1662,8 @@ static void __devexit igb_remove(struct pci_dev *pdev)
 
 	free_netdev(netdev);
 
+	pci_disable_pcie_error_reporting(pdev);
+
 	pci_disable_device(pdev);
 }
 
@@ -5180,22 +5185,26 @@ static pci_ers_result_t igb_io_slot_reset(struct pci_dev *pdev)
 	struct net_device *netdev = pci_get_drvdata(pdev);
 	struct igb_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
+	pci_ers_result_t result;
 
 	if (pci_enable_device_mem(pdev)) {
 		dev_err(&pdev->dev,
 			"Cannot re-enable PCI device after reset.\n");
-		return PCI_ERS_RESULT_DISCONNECT;
-	}
-	pci_set_master(pdev);
-	pci_restore_state(pdev);
+		result = PCI_ERS_RESULT_DISCONNECT;
+	} else {
+		pci_set_master(pdev);
+		pci_restore_state(pdev);
 
-	pci_enable_wake(pdev, PCI_D3hot, 0);
-	pci_enable_wake(pdev, PCI_D3cold, 0);
+		pci_enable_wake(pdev, PCI_D3hot, 0);
+		pci_enable_wake(pdev, PCI_D3cold, 0);
 
-	igb_reset(adapter);
-	wr32(E1000_WUS, ~0);
+		igb_reset(adapter);
+		wr32(E1000_WUS, ~0);
+		return PCI_ERS_RESULT_RECOVERED;
+	}
+	pci_cleanup_aer_uncorrect_error_status(pdev);
 
-	return PCI_ERS_RESULT_RECOVERED;
+	return result;
 }
 
 /**
