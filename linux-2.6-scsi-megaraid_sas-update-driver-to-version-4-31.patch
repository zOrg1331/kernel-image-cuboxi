From: Tomas Henzl <thenzl@redhat.com>
Date: Fri, 30 Jul 2010 14:57:24 -0400
Subject: [scsi] megaraid_sas: update driver to version 4.31
Message-id: <4C52E854.5030608@redhat.com>
Patchwork-id: 27254
O-Subject: Re: [RHEL5.6 PATCH 2/1] V3 megaraid_sas: update driver to version 4.31
Bugzilla: 564249
RH-Acked-by: Mike Christie <mchristi@redhat.com>

https://bugzilla.redhat.com/show_bug.cgi?id=564249

Description provided by Bo Yang, LSI Megaraid maintainer.
1. Add the three times online controller reset if driver detects the
   fw in failure state.  also do online controller reset (OCR) before
   driver kill adapter to have the last chance to bringup FW.

2. Add input parameter of max_sectors to 1MB.  Customer can change the
   max_sectors size upto 1MB.

3. Fix the issue of during the system reboot test, FW raises the interrupt
   as FW state change and system hang.

4. Fix the issue of fw report the enclure as system PDs.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/Documentation/scsi/ChangeLog.megaraid_sas b/Documentation/scsi/ChangeLog.megaraid_sas
index 7acc121..4b5c736 100644
--- a/Documentation/scsi/ChangeLog.megaraid_sas
+++ b/Documentation/scsi/ChangeLog.megaraid_sas
@@ -1,3 +1,24 @@
+
+1 Release Date    : Tues.  June. 15, 2010 09:12:45 PST 2010 -
+			(emaild-id:megaraidlinux@lsi.com)
+			Bo Yang
+
+2 Current Version : 00.00.04.31
+3 Older Version   : 00.00.04.27
+
+1.	Add the three times online controller reset if driver detects the fw in failure state.
+	also do online controller reset (OCR) before driver kill adapter to have the last chance
+	to bringup FW. 
+
+2.	Add input parameter of max_sectors to 1MB.  Customer can change the max_sectors size upto
+	1MB.
+
+3.	Fix the issue of during the system reboot test, FW raises the interrupt as FW state change and
+	system hang.
+
+4.	Fix the issue of fw report the enclure as system PDs.
+
+
 1 Release Date    : Thur.  Feb. 18, 2010 09:12:45 PST 2009 -
 			(emaild-id:megaraidlinux@lsi.com)
 			Bo Yang
diff --git a/drivers/scsi/megaraid/megaraid_sas.c b/drivers/scsi/megaraid/megaraid_sas.c
index 391d68d..72128ca 100644
--- a/drivers/scsi/megaraid/megaraid_sas.c
+++ b/drivers/scsi/megaraid/megaraid_sas.c
@@ -53,6 +53,16 @@ module_param_named(poll_mode_io, poll_mode_io, int, 0);
 MODULE_PARM_DESC(poll_mode_io,
 	"Complete cmds from IO path, (default=0)");
 
+/*
+ * Number of sectors per IO command
+ * Will be set in megasas_init_mfi if user does not provide
+ */
+static unsigned int max_sectors;
+module_param_named(max_sectors, max_sectors, int, 0);
+MODULE_PARM_DESC(max_sectors,
+	"Maximum number of sectors per IO command");
+
+
 MODULE_LICENSE("GPL");
 MODULE_VERSION(MEGASAS_VERSION);
 MODULE_AUTHOR("megaraidlinux@lsi.com");
@@ -988,6 +998,7 @@ megasas_make_sgl_skinny(struct megasas_instance *instance, struct scsi_cmnd *scp
 	for (i = 0; i < sge_count; i++, os_sgl++) {
 		mfi_sgl->sge_skinny[i].length = sg_dma_len(os_sgl);
 		mfi_sgl->sge_skinny[i].phys_addr = sg_dma_address(os_sgl);
+		 mfi_sgl->sge_skinny[i].flag = 0;
 	}
 
 	return sge_count;
@@ -1492,12 +1503,19 @@ static int megasas_slave_configure(struct scsi_device *sdev)
 	 * 	  That will be fixed once LSI engineers have audited the
 	 * 	  firmware for possible issues.
 	 */
-	if (sdev->channel < MEGASAS_MAX_PD_CHANNELS && sdev->type == TYPE_DISK) {
-		pd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;
-		
-		if (instance->pd_list[pd_index].driveState == MR_PD_STATE_SYSTEM) {
-			sdev->timeout = 90 * HZ;
+	if (sdev->channel < MEGASAS_MAX_PD_CHANNELS) {
+
+		if (sdev->type == TYPE_TAPE) {
+			sdev->timeout = MEGASAS_DEFAULT_CMD_TIMEOUT * HZ;
 			return 0;
+		} else if (sdev->type == TYPE_DISK) {
+
+			pd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;
+			if ((instance->pd_list[pd_index].driveState == MR_PD_STATE_SYSTEM) &&
+				(instance->pd_list[pd_index].driveType == TYPE_DISK)) {
+				sdev->timeout = MEGASAS_DEFAULT_CMD_TIMEOUT * HZ;
+				return 0;
+			}
 		}
 		return -ENXIO;
 	}
@@ -1622,6 +1640,25 @@ static void megasas_complete_cmd_dpc(unsigned long instance_addr)
 
 }
 
+static void megasas_internal_reset_defer_cmds(struct megasas_instance *instance);
+
+void megasas_do_ocr(struct megasas_instance *instance)
+{
+	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||
+		(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||
+		(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR))
+	{
+		*instance->consumer     = MEGASAS_ADPRESET_INPROG_SIGN;
+	}
+
+	instance->instancet->disable_intr(instance->reg_set);
+	instance->adprecovery   = MEGASAS_ADPRESET_SM_INFAULT;
+	instance->issuepend_done = 0;
+	atomic_set(&instance->fw_outstanding, 0);
+	megasas_internal_reset_defer_cmds(instance);
+	process_fw_state_change_wq(instance);
+}
+
 /**
  * megasas_wait_for_outstanding -	Wait for all outstanding cmds
  * @instance:				Adapter soft state
@@ -1632,13 +1669,16 @@ static void megasas_complete_cmd_dpc(unsigned long instance_addr)
  */
 static int megasas_wait_for_outstanding(struct megasas_instance *instance)
 {
-	int i;
+	int i, sl;
 	u32 reset_index;
 	u32 wait_time = MEGASAS_RESET_WAIT_TIME;
 	u8 adprecovery;
 	unsigned long flags;
 	struct list_head clist_local;
 	struct megasas_cmd *reset_cmd;
+	u32 fw_state;
+	u8 kill_adapter_flag;
+
 
 	// If we are in-process if internal reset, we should wait for that process to
 	// complete
@@ -1730,7 +1770,51 @@ static int megasas_wait_for_outstanding(struct megasas_instance *instance)
 		msleep(1000);
 	}
 
-	if (atomic_read(&instance->fw_outstanding)) {
+        /**
+        for the fw state fault case, driver need to reset three times before kill adapter.
+        */
+        i = 0;
+        kill_adapter_flag = 0;
+        do {
+                fw_state = instance->instancet->read_fw_status_reg(instance->reg_set) & MFI_STATE_MASK;
+                if ((fw_state == MFI_STATE_FAULT) && (instance->disableOnlineCtrlReset == 0)) {
+                        printk("megasas: waiting_for_outstanding: before issue OCR. FW state = %x\n", fw_state);
+                        if (i == 3) {
+                                kill_adapter_flag = 2;
+                                break;
+                        }
+                        megasas_do_ocr(instance);
+                       kill_adapter_flag = 1;
+                        printk("megasas: waiting_for_outstanding: after issue OCR. \n");
+
+                        /* wait for 5 secs to let the FW finish all the pending cmds*/
+                        for (sl=0; sl<10; sl++)
+                                msleep(500);
+                }
+                       i++;
+        } while (i <= 3);
+
+        /**
+        for the fw state not fault case, it is maybe fw hang, driver need to reset the controller before kill the adapter.
+        */
+        if (atomic_read(&instance->fw_outstanding) && !kill_adapter_flag) {
+                if (instance->disableOnlineCtrlReset == 0) {
+                        printk("megasas: waiting_for_outstanding: before issue OCR. FW state = %x\n", fw_state);
+                        megasas_do_ocr(instance);
+                        printk("megasas: waiting_for_outstanding: after issue OCR. \n");
+
+                        /* wait for 5 secs to let the FW finish all the pending cmds*/
+                        for (i = 0; i < wait_time; i++) {
+                                int outstanding = atomic_read(&instance->fw_outstanding);
+
+                                if (!outstanding)
+                                        return SUCCESS;
+                                msleep(1000);
+                        }
+                }
+        }
+
+        if (atomic_read(&instance->fw_outstanding) || (kill_adapter_flag == 2)) {
 		printk("megaraid_sas: pending commands remain even after reset handling.\n");
 		/*
 		* Send signal to FW to stop processing any pending cmds.
@@ -1945,6 +2029,30 @@ megasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)
 	}
 }
 
+static ssize_t
+sysfs_max_sectors_read(struct class_device *class_dev, char *buf)
+{
+	struct Scsi_Host *host = class_to_shost(class_dev);
+
+	struct megasas_instance *instance =
+				(struct megasas_instance *)host->hostdata;
+
+	return sprintf(buf,"%u\n", instance->max_sectors_per_req);
+}
+
+static struct class_device_attribute dev_attr_max_sector = {
+	.attr = {
+		.name = "max_sectors",
+		.mode = S_IRUGO,
+	},
+	.show = sysfs_max_sectors_read
+};
+
+static struct class_device_attribute *megasas_shost_sysfs_attr[] = {
+	&dev_attr_max_sector,
+	NULL,
+};
+
 /*
  * Scsi host template for megaraid_sas driver
  */
@@ -1963,6 +2071,7 @@ static struct scsi_host_template megasas_template = {
 	.eh_timed_out = megasas_reset_timer,
 	.bios_param = megasas_bios_param,
 	.use_clustering = ENABLE_CLUSTERING,
+	.shost_attrs	= megasas_shost_sysfs_attr,
 };
 
 /**
@@ -2434,12 +2543,12 @@ megasas_deplete_reply_queue(struct megasas_instance *instance, u8 alt_status)
 			// adapter reset state machine.
                        	printk("megaraid_sas: FW state detected, current:%x, reset stage:%d\n", fw_state, instance->adprecovery);
 			schedule_work(&instance->work_init);
+			return IRQ_HANDLED;
 		}
 		else {
 			printk("megaraid_sas: fw state while internal state changes, state:%x, disableOCR=%x\n",
 				fw_state, instance->disableOnlineCtrlReset);
 		}
-		return IRQ_HANDLED;
 	}
 
 	// Schedule the tasklet for cmd completion
@@ -2760,6 +2869,8 @@ static int megasas_create_frame_pool(struct megasas_instance *instance)
 			return -ENOMEM;
 		}
 
+		memset(cmd->frame, 0, total_sz);
+
 		cmd->frame->io.context = cmd->index;
 
 		/*
@@ -3693,6 +3804,28 @@ static int megasas_io_attach(struct megasas_instance *instance)
 			instance->max_fw_cmds - MEGASAS_INT_CMDS;
 	host->this_id = instance->init_id;
 	host->sg_tablesize = instance->max_num_sge;
+
+	/*
+	 * Check if the module parameter value for max_sectors can be used
+	 */
+	if (max_sectors && max_sectors < instance->max_sectors_per_req)
+		instance->max_sectors_per_req = max_sectors;
+	else {
+		if (max_sectors) {
+			if (((instance->pdev->device ==
+				PCI_DEVICE_ID_LSI_SAS1078GEN2) ||
+				(instance->pdev->device ==
+				PCI_DEVICE_ID_LSI_SAS0079GEN2)) &&
+				(max_sectors <= MEGASAS_MAX_SECTORS)) {
+				instance->max_sectors_per_req = max_sectors;
+			} else {
+			printk(KERN_INFO "megasas: max_sectors should be > 0"
+				"and <= %d (or < 1MB for GEN2 controller)\n",
+				instance->max_sectors_per_req);
+			}
+		}
+	}
+
 	host->max_sectors = instance->max_sectors_per_req;
 	host->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;
 	host->max_channel = MEGASAS_MAX_CHANNELS - 1;
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index 402e529..e2a6b80 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -18,9 +18,9 @@
 /*
  * MegaRAID SAS Driver meta data
  */
-#define MEGASAS_VERSION				"00.00.04.27-RH1"
-#define MEGASAS_RELDATE				"Mar. 09, 2010"
-#define MEGASAS_EXT_VERSION			"Tues. Mar. 09 14:13:02 EST 2010"
+#define MEGASAS_VERSION				"00.00.04.31-RH1"
+#define MEGASAS_RELDATE				"June. 15, 2010"
+#define MEGASAS_EXT_VERSION			"Tues. June. 15 14:13:02 EST 2010"
 
 /*
  * Device IDs
@@ -731,7 +731,7 @@ struct megasas_ctrl_info {
 							MEGASAS_MAX_DEV_PER_CHANNEL)
 
 
-
+#define MEGASAS_MAX_SECTORS                    (2*1024)
 #define MEGASAS_DBG_LVL				1
 #define MEGASAS_FW_BUSY				1
 /* Frame Type */
