X-Account-Key: account4
X-UIDL: 1ab8a9fa9cae6228
X-Mozilla-Status: 0001
X-Mozilla-Status2: 00000000
X-Mozilla-Keys:                                                                                 
Received: from relay.parallels.com (relay.parallels.com [195.214.232.42])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OICGZH019581
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
	Wed, 24 Mar 2010 21:12:17 +0300 (MSK)
Received: from mx1.parallels.com ([64.131.89.18])
	by relay.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3v-0008Iq-2K; Wed, 24 Mar 2010 21:12:15 +0300
Received: from mailhub.sw.ru ([195.214.232.25] helo=relay.sw.ru)
	by mx1.parallels.com with esmtps (TLSv1:AES256-SHA:256)
	(Exim 4.71)
	(envelope-from <vgusev@openvz.org>)
	id 1NuV3u-000482-04; Wed, 24 Mar 2010 14:12:14 -0400
Received: from localhost.localdomain ([10.30.18.218])
	by relay.sw.ru (8.13.4/8.13.4) with ESMTP id o2OIC3cu007235;
	Wed, 24 Mar 2010 21:12:11 +0300 (MSK)
From: Vitaliy Gusev <vgusev@openvz.org>
To: xemul@openvz.org
Cc: vz@lists.sw.ru, Vitaliy Gusev <vgusev@openvz.org>
Subject: [2.6.18][PATCH 6/8] pacct: Make acct per VE
Date: Wed, 24 Mar 2010 21:17:27 +0300
Message-Id: <1269454649-887-7-git-send-email-vgusev@openvz.org>
X-Mailer: git-send-email 1.6.0.2
In-Reply-To: <1269454649-887-1-git-send-email-vgusev@openvz.org>
References: <1269454649-887-1-git-send-email-vgusev@openvz.org>

Now ve_struct->bacct points to bsd_acc_struct.An Userspace that
called sys_acct whould read events from own VE.

One problem is still exist: emergency remount to readonly. Next
patch will fix it.

Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
---
 include/linux/acct.h |    2 +
 include/linux/ve.h   |    3 ++
 kernel/acct.c        |   74 +++++++++++++++++++++++++++++++++++++++----------
 kernel/ve/vecalls.c  |    3 ++
 4 files changed, 67 insertions(+), 15 deletions(-)

diff --git a/include/linux/acct.h b/include/linux/acct.h
index e86bae7..afcc975 100644
--- a/include/linux/acct.h
+++ b/include/linux/acct.h
@@ -126,6 +126,7 @@ extern void acct_collect(long exitcode, int group_dead);
 extern void acct_process(void);
 extern void acct_update_integrals(struct task_struct *tsk);
 extern void acct_clear_integrals(struct task_struct *tsk);
+extern void acct_exit_ve(struct bsd_acct_struct *acct);
 #else
 #define acct_auto_close_mnt(x)	do { } while (0)
 #define acct_auto_close(x)	do { } while (0)
@@ -134,6 +135,7 @@ extern void acct_clear_integrals(struct task_struct *tsk);
 #define acct_process()		do { } while (0)
 #define acct_update_integrals(x)		do { } while (0)
 #define acct_clear_integrals(task)	do { } while (0)
+#define acct_exit_ve(acct) do { } while (0)
 #endif
 
 /*
diff --git a/include/linux/ve.h b/include/linux/ve.h
index e2dacb7..7fcf6b0 100644
--- a/include/linux/ve.h
+++ b/include/linux/ve.h
@@ -361,6 +361,9 @@ struct ve_struct {
 	} grsec;
 #endif /* CONFIG_GRKERNSEC */
 	struct afs_sysnames_struct	*afs_sysnames;
+#ifdef CONFIG_BSD_PROCESS_ACCT
+	struct bsd_acct_struct	*bacct;
+#endif
 };
 
 #define VE_MEMINFO_DEFAULT	1	/* default behaviour */
diff --git a/kernel/acct.c b/kernel/acct.c
index 5ae8526..4b244a9 100644
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@ -92,8 +92,6 @@ struct bsd_acct_struct {
 
 static DEFINE_SPINLOCK(acct_lock);
 
-static struct bsd_acct_struct acct_globals __cacheline_aligned;
-
 /*
  * Called whenever the timer says to check the free space.
  */
@@ -192,7 +190,7 @@ static void acct_file_reopen(struct bsd_acct_struct *acct, struct file *file)
  		acct->needcheck = 0;
  		acct->active = 1;
 		/* It's been deleted if it was used before so this is safe */
-		setup_timer(&acct_globals.timer, acct_timeout,
+		setup_timer(&acct->timer, acct_timeout,
 			    (unsigned long)acct);
 		acct->timer.expires = jiffies + ACCT_TIMEOUT*HZ;
 		add_timer(&acct->timer);
@@ -206,9 +204,10 @@ static void acct_file_reopen(struct bsd_acct_struct *acct, struct file *file)
 	}
 }
 
-static int acct_on(char *name)
+static int acct_on(struct ve_struct *ve, char *name)
 {
 	struct file *file;
+	struct bsd_acct_struct *acct = NULL;
 	int error;
 
 	/* Difference from BSD - they don't do O_APPEND */
@@ -232,12 +231,26 @@ static int acct_on(char *name)
 		return error;
 	}
 
+	if (!ve->bacct) {
+		/* try pre alloc */
+		acct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);
+		if (!acct) {
+			filp_close(file, NULL);
+			return -ENOMEM;
+		}
+	}
+
 	spin_lock(&acct_lock);
+	if (!ve->bacct) {
+		ve->bacct = acct;
+		acct = NULL;
+	}
 	mnt_pin(file->f_vfsmnt);
-	acct_file_reopen(&acct_globals, file);
+	acct_file_reopen(ve->bacct, file);
 	spin_unlock(&acct_lock);
 
 	mntput(file->f_vfsmnt);	/* it's pinned, now give up active reference */
+	kfree(acct);
 
 	return 0;
 }
@@ -256,6 +269,7 @@ static int acct_on(char *name)
 asmlinkage long sys_acct(const char __user *name)
 {
 	int error;
+	struct ve_struct *ve = get_exec_env();
 
 	if (!capable(CAP_SYS_PACCT))
 		return -EPERM;
@@ -264,13 +278,19 @@ asmlinkage long sys_acct(const char __user *name)
 		char *tmp = getname(name);
 		if (IS_ERR(tmp))
 			return (PTR_ERR(tmp));
-		error = acct_on(tmp);
+		error = acct_on(ve, tmp);
 		putname(tmp);
 	} else {
+		struct bsd_acct_struct *acct;
+
+		acct = ve->bacct;
+		if (!acct)
+			return 0;
+
 		error = security_acct(NULL);
 		if (!error) {
 			spin_lock(&acct_lock);
-			acct_file_reopen(&acct_globals, NULL);
+			acct_file_reopen(acct, NULL);
 			spin_unlock(&acct_lock);
 		}
 	}
@@ -286,9 +306,14 @@ asmlinkage long sys_acct(const char __user *name)
  */
 void acct_auto_close_mnt(struct vfsmount *m)
 {
+	struct bsd_acct_struct *acct = get_exec_env()->bacct;
+
+	if (!acct)
+		return;
+
 	spin_lock(&acct_lock);
-	if (acct_globals.file && acct_globals.file->f_vfsmnt == m)
-		acct_file_reopen(&acct_globals, NULL);
+	if (acct->file && acct->file->f_vfsmnt == m)
+		acct_file_reopen(acct, NULL);
 	spin_unlock(&acct_lock);
 }
 
@@ -301,10 +326,14 @@ void acct_auto_close_mnt(struct vfsmount *m)
  */
 void acct_auto_close(struct super_block *sb)
 {
+	struct bsd_acct_struct *acct = get_exec_env()->bacct;
+
+	if (!acct)
+		return;
+
 	spin_lock(&acct_lock);
-	if (acct_globals.file &&
-	    acct_globals.file->f_vfsmnt->mnt_sb == sb) {
-		acct_file_reopen(&acct_globals, NULL);
+	if (acct->file && acct->file->f_vfsmnt->mnt_sb == sb) {
+		acct_file_reopen(acct, NULL);
 	}
 	spin_unlock(&acct_lock);
 }
@@ -537,6 +566,20 @@ void acct_init_pacct(struct pacct_struct *pacct)
 	pacct->ac_utime = pacct->ac_stime = cputime_zero;
 }
 
+void acct_exit_ve(struct bsd_acct_struct *acct)
+{
+	if (!acct)
+		return;
+
+	spin_lock(&acct_lock);
+	if (acct->file) {
+		acct_file_reopen(acct, NULL);
+		kfree(acct);
+	}
+	spin_unlock(&acct_lock);
+}
+EXPORT_SYMBOL(acct_exit_ve);
+
 /**
  * acct_collect - collect accounting information into pacct_struct
  * @exitcode: task exit code
@@ -588,15 +631,16 @@ void acct_collect(long exitcode, int group_dead)
 void acct_process(void)
 {
 	struct file *file = NULL;
+	struct bsd_acct_struct *acct = get_exec_env()->bacct;
 
 	/*
 	 * accelerate the common fastpath:
 	 */
-	if (!acct_globals.file)
+	if (!acct || !acct->file)
 		return;
 
 	spin_lock(&acct_lock);
-	file = acct_globals.file;
+	file = acct->file;
 	if (unlikely(!file)) {
 		spin_unlock(&acct_lock);
 		return;
@@ -604,7 +648,7 @@ void acct_process(void)
 	get_file(file);
 	spin_unlock(&acct_lock);
 
-	do_acct_process(&acct_globals, file);
+	do_acct_process(acct, acct->file);
 	fput(file);
 }
 
diff --git a/kernel/ve/vecalls.c b/kernel/ve/vecalls.c
index 628d50a..935f3b7 100644
--- a/kernel/ve/vecalls.c
+++ b/kernel/ve/vecalls.c
@@ -51,6 +51,7 @@
 #include <ub/beancounter.h>
 #include <linux/nsproxy.h>
 #include <linux/kobject.h>
+#include <linux/acct.h>
 
 #include <net/route.h>
 #include <net/ip_fib.h>
@@ -1889,6 +1890,8 @@ static void env_cleanup(struct ve_struct *ve)
 
 	VZTRACE("real_do_env_cleanup\n");
 
+	acct_exit_ve(ve->bacct);
+
 	down_read(&ve->op_sem);
 	old_ve = set_exec_env(ve);
 
-- 
1.6.0.2


