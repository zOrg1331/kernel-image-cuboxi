From: Prarit Bhargava <prarit@redhat.com>
Date: Wed, 26 May 2010 13:40:57 -0400
Subject: [net] move compat header file contents to proper includes
Message-id: <4BFD24E9.7020109@redhat.com>
Patchwork-id: 25818
O-Subject: Re: [RHEL5 PATCH 20/27] compat.h cleanup: include files changes
Bugzilla: 546740
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Move drivers/net/*/*-compat.h file contents into include/linux where it
belongs.

Resolves 546740.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index f48079c..60250fa 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -166,4 +166,7 @@ extern void __chk_io_ptr(void __iomem *);
 # define uninitialized_var(x) x = x
 #endif
 
+#ifndef __maybe_unused
+# define __maybe_unused		/* unimplemented */
+#endif
 #endif /* __LINUX_COMPILER_H */
diff --git a/include/linux/etherdevice.h b/include/linux/etherdevice.h
index d3c6c94..d25adf9 100644
--- a/include/linux/etherdevice.h
+++ b/include/linux/etherdevice.h
@@ -40,6 +40,14 @@ extern int		eth_header_cache(struct neighbour *neigh,
 					 struct hh_cache *hh);
 
 extern struct net_device *alloc_etherdev(int sizeof_priv);
+
+static inline struct net_device *alloc_etherdev_mq(int sizeof_priv,
+				     unsigned int queue_count)
+{
+	BUG_ON(queue_count != 1);
+	return alloc_etherdev(sizeof_priv);
+}
+
 static inline void eth_copy_and_sum (struct sk_buff *dest, 
 				     const unsigned char *src, 
 				     int len, int base)
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 4dcabf3..3e94e3c 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -185,6 +185,48 @@ static inline void i2c_set_clientdata (struct i2c_client *dev, void *data)
 	dev_set_drvdata (&dev->dev, data);
 }
 
+/**
+ * struct i2c_board_info - template for device creation
+ * @type: chip type, to initialize i2c_client.name
+ * @flags: to initialize i2c_client.flags
+ * @addr: stored in i2c_client.addr
+ * @platform_data: stored in i2c_client.dev.platform_data
+ * @archdata: copied into i2c_client.dev.archdata
+ * @irq: stored in i2c_client.irq
+ *
+ * I2C doesn't actually support hardware probing, although controllers and
+ * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there's
+ * a device at a given address.  Drivers commonly need more information than
+ * that, such as chip type, configuration, associated IRQ, and so on.
+ *
+ * i2c_board_info is used to build tables of information listing I2C devices
+ * that are present.  This information is used to grow the driver model tree.
+ * For mainboards this is done statically using i2c_register_board_info();
+ * bus numbers identify adapters that aren't yet available.  For add-on boards,
+ * i2c_new_device() does this dynamically with the adapter already known.
+ */
+struct i2c_board_info {
+	char		type[I2C_NAME_SIZE];
+	unsigned short	flags;
+	unsigned short	addr;
+	void		*platform_data;
+	struct dev_archdata	*archdata;
+	int		irq;
+};
+
+/**
+ * I2C_BOARD_INFO - macro used to list an i2c device and its address
+ * @dev_type: identifies the device type
+ * @dev_addr: the device's address on the bus.
+ *
+ * This macro initializes essential fields of a struct i2c_board_info,
+ * declaring what has been provided on a particular board.  Optional
+ * fields (such as associated irq, or device-specific platform_data)
+ * are provided using conventional syntax.
+ */
+#define I2C_BOARD_INFO(dev_type, dev_addr) \
+	.type = dev_type, .addr = (dev_addr)
+
 /*
  * The following structs are for those who like to implement new bus drivers:
  * i2c_algorithm is the interface to a class of hardware solutions which can
@@ -651,5 +693,10 @@ static unsigned short *forces[] = { force, force_##chip1,		\
 				    force_##chip6, force_##chip7,	\
 				    force_##chip8, NULL };		\
 I2C_CLIENT_INSMOD_COMMON
+
+#ifndef __GENKSYMS__
+struct i2c_client * i2c_new_dummy(struct i2c_adapter *adap, u16 address);
+void i2c_unregister_device(struct i2c_client *c);
+#endif
 #endif /* __KERNEL__ */
 #endif /* _LINUX_I2C_H */
diff --git a/include/linux/if_ether.h b/include/linux/if_ether.h
index 6f3a4fa..dd78ccf 100644
--- a/include/linux/if_ether.h
+++ b/include/linux/if_ether.h
@@ -33,6 +33,7 @@
 #define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
 #define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
 #define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+#define ETH_FCS_LEN	4		/* Octets in the FCS		 */
 
 /*
  *	These are the defined Ethernet Protocol ID's.
@@ -120,6 +121,11 @@ static inline struct ethhdr *eth_hdr(const struct sk_buff *skb)
 #ifdef CONFIG_SYSCTL
 extern struct ctl_table ether_table[];
 #endif
-#endif
 
+extern char *print_mac(char *buf, const unsigned char *addr);
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_BUF_SIZE 18
+#define DECLARE_MAC_BUF(var) char var[MAC_BUF_SIZE]
+
+#endif
 #endif	/* _LINUX_IF_ETHER_H */
diff --git a/include/linux/if_vlan.h b/include/linux/if_vlan.h
index 65f954a..6b14921 100644
--- a/include/linux/if_vlan.h
+++ b/include/linux/if_vlan.h
@@ -143,6 +143,20 @@ struct vlan_skb_tx_cookie {
 	u32	vlan_tag;
 };
 
+static inline struct net_device *vlan_group_get_device(struct vlan_group *vg,
+						       int vlan_id)
+{
+	return vg->vlan_devices[vlan_id];
+}
+
+static inline void vlan_group_set_device(struct vlan_group *vg,
+					 u16 vid,
+					 struct net_device *dev)
+{
+	if (vg)
+		vg->vlan_devices[vid] = dev;
+}
+
 #define VLAN_TX_COOKIE_MAGIC	0x564c414e	/* "VLAN" in ascii. */
 #define VLAN_TX_SKB_CB(__skb)	((struct vlan_skb_tx_cookie *)&((__skb)->cb[0]))
 #define vlan_tx_tag_present(__skb) \
diff --git a/include/linux/inet_lro.h b/include/linux/inet_lro.h
index 96e516a..80335b7 100644
--- a/include/linux/inet_lro.h
+++ b/include/linux/inet_lro.h
@@ -32,12 +32,6 @@
 #include <net/tcp.h>
 
 /*
- * backport csum_unfold and datatypes from 2.6.25
- */
-typedef __u16 __bitwise __sum16;
-typedef __u32 __bitwise __wsum;
-
-/*
  * LRO statistics
  */
 
diff --git a/include/linux/libata-compat.h b/include/linux/libata-compat.h
index 705be61..e3fe199 100644
--- a/include/linux/libata-compat.h
+++ b/include/linux/libata-compat.h
@@ -8,8 +8,6 @@
 #define for_each_sg(sgl, sg, n_elem, i) \
 	for ((sg) = (sgl), (i) = 0; (i) < (n_elem); (i)++, (sg)++)
 
-typedef void (*work_func_t)(void *);
-
 static inline void sg_init_table(struct scatterlist *sg, unsigned int count)
 {
 }
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 56e085f..bb56266 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -347,6 +347,7 @@ struct net_device
 #define NETIF_F_GSO		2048	/* Enable software GSO. */
 #define NETIF_F_LLTX		4096	/* LockLess TX */
 #define NETIF_F_GRO		16384	/* Generic receive offload */
+#define NETIF_F_LRO		32768	/* large receive offload */
 
 /* Go to the end of the bit field and count backwards when adding new entries
  * so we don't cause the calculated fields below to shift.  Also don't forget
@@ -847,7 +848,6 @@ static inline int netif_running(const struct net_device *dev)
 	return test_bit(__LINK_STATE_START, &dev->state);
 }
 
-
 /* Use this variant when it is known for sure that it
  * is executing from interrupt context.
  */
@@ -1289,6 +1289,8 @@ static inline int skb_bond_should_drop(struct sk_buff *skb)
 	return 0;
 }
 
+#define to_net_dev(class) container_of(class, struct net_device, class_dev)
+
 #endif /* __KERNEL__ */
 
 #endif	/* _LINUX_DEV_H */
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 4963e53..13c266b 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -426,6 +426,16 @@ struct pci_driver {
 #define	to_pci_driver(drv) container_of(drv,struct pci_driver, driver)
 
 /**
+ * DEFINE_PCI_DEVICE_TABLE - macro used to describe a pci device table
+ * @_table: device table name
+ *
+ * This macro is used to create a struct pci_device_id array (a device table)
+ * in a generic manner.
+ */
+#define DEFINE_PCI_DEVICE_TABLE(_table) \
+	const struct pci_device_id _table[] __devinitdata
+
+/**
  * PCI_DEVICE - macro used to describe a specific pci device
  * @vend: the 16 bit PCI Vendor ID
  * @dev: the 16 bit PCI Device ID
@@ -632,6 +642,7 @@ int pci_restore_state(struct pci_dev *dev);
 int pci_set_power_state(struct pci_dev *dev, pci_power_t state);
 pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state);
 int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable);
+int pci_wake_from_d3(struct pci_dev *dev, bool enable);
 
 /* Helper functions for low-level code (drivers/pci/setup-[bus,res].c) */
 void pci_bus_assign_resources(struct pci_bus *bus);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 6f9f699..0854c2c 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -1919,6 +1919,8 @@
 
 #define PCI_VENDOR_ID_SAMSUNG		0x144d
 
+#define PCI_VENDOR_ID_GIGABYTE		0x1458
+
 #define PCI_VENDOR_ID_AMBIT		0x1468
 
 #define PCI_VENDOR_ID_MYRICOM		0x14c1
diff --git a/include/linux/pci_regs.h b/include/linux/pci_regs.h
index 2092b3e..cc4d0d9 100644
--- a/include/linux/pci_regs.h
+++ b/include/linux/pci_regs.h
@@ -328,6 +328,7 @@
 #define PCI_X_CMD		2	/* Modes & Features */
 #define  PCI_X_CMD_DPERR_E	0x0001	/* Data Parity Error Recovery Enable */
 #define  PCI_X_CMD_ERO		0x0002	/* Enable Relaxed Ordering */
+#define PCI_X_CMD_READ_2K	0x0008  /* 2Kbyte maximum read byte count */
 #define  PCI_X_CMD_MAX_READ	0x000c	/* Max Memory Read Byte Count */
 #define  PCI_X_CMD_MAX_SPLIT	0x0070	/* Max Outstanding Split Transactions */
 #define  PCI_X_CMD_VERSION(x) 	(((x) >> 12) & 3) /* Version */
diff --git a/include/linux/pcieport_if.h b/include/linux/pcieport_if.h
index 22e6d2c..5a259d2 100644
--- a/include/linux/pcieport_if.h
+++ b/include/linux/pcieport_if.h
@@ -79,4 +79,9 @@ struct pcie_port_service_driver {
 extern int pcie_port_service_register(struct pcie_port_service_driver *new);
 extern void pcie_port_service_unregister(struct pcie_port_service_driver *new);
 
+/* upstream this is defined in include/linux/pci-aspm.h */
+#define PCIE_LINK_STATE_L0S	1
+#define PCIE_LINK_STATE_L1	2
+#define PCIE_LINK_STATE_CLKPM	4
+
 #endif /* _PCIEPORT_IF_H_ */
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 547e568..104ef33 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1788,5 +1788,15 @@ static inline int skb_is_gso(const struct sk_buff *skb)
 	return skb_shinfo(skb)->gso_size;
 }
 
+/*
+ * These are only used with TX_MULTIQ_STEERING,
+ * and so should never be called in RHEL5.
+ */
+
+static inline u16 skb_get_queue_mapping(const struct sk_buff *skb)
+{
+	WARN_ON(1);
+	return 0;
+}
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_SKBUFF_H */
diff --git a/include/linux/types.h b/include/linux/types.h
index c76a4ec..dc890b2 100644
--- a/include/linux/types.h
+++ b/include/linux/types.h
@@ -177,6 +177,9 @@ typedef __u64 __bitwise __le64;
 typedef __u64 __bitwise __be64;
 #endif
 
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+
 #ifdef __KERNEL__
 typedef unsigned __bitwise__ gfp_t;
 typedef unsigned __bitwise__ fmode_t;
