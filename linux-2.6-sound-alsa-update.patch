From: Brian Maly <bmaly@redhat.com>
Subject: [RHEL5.1 patch]  ALSA update (1.0.14)   [1/2]
Date: Wed, 06 Jun 2007 14:10:19 -0400
Bugzilla: 227671 240713 223133 238004 223142 244672
Message-Id: <4666F88B.6090405@redhat.com>
Changelog: [sound]  ALSA update (1.0.14)


Resolves BZ's:     227671, 240713, 223133, 238004, 223142,   possible 
others though.

This is an ALSA driver update from 1.0.12 to 1.0.14.  Its been tested by 
several people and some vendors with excellent results, but has not been 
tested thoroughly with each and every sound card/driver in the tree. 
Testing went well on all the hardware we were able to round up though. 
This will require more intensive testing, and I will post updates to fix 
specific drivers if problems are found with specific sound cards.

Martin Stransky will be taking care of the RHEL5 alsa-lib and alsa-util 
(userspace) updates that go along with this kernel update.

Brian

# CONFIG_SND_SOC is not set
# CONFIG_SND_AC97_POWER_SAVE is not set
# CONFIG_SND_PORTMAN2X4 is not set
# CONFIG_SND_MTS64 is not set



 include/sound/ac97_codec.h                |   29 
 include/sound/ad1848.h                    |   22 
 include/sound/ak4114.h                    |    2 
 include/sound/ak4117.h                    |    2 
 include/sound/ak4xxx-adda.h               |   39 
 include/sound/asound.h                    |   19 
 include/sound/control.h                   |   14 
 include/sound/core.h                      |   55 
 include/sound/cs4231.h                    |    2 
 include/sound/emu10k1.h                   |  414 +-
 include/sound/gus.h                       |    2 
 include/sound/info.h                      |    7 
 include/sound/initval.h                   |    2 
 include/sound/pcm.h                       |   12 
 include/sound/pcm_oss.h                   |    1 
 include/sound/pt2258.h                    |   37 
 include/sound/sb.h                        |    3 
 include/sound/sb16_csp.h                  |   14 
 include/sound/snd_wavefront.h             |    2 
 include/sound/soc-dapm.h                  |  286 +
 include/sound/soc.h                       |  461 ++
 include/sound/timer.h                     |    1 
 include/sound/tlv.h                       |   60 
 include/sound/typedefs.h                  |  173 
 include/sound/version.h                   |    6 
 include/sound/vx_core.h                   |    1 
 include/sound/ymfpci.h                    |   11 
 sound/Kconfig                             |   10 
 sound/Makefile                            |    8 
 sound/ac97_bus.c                          |   76 
 sound/aoa/Kconfig                         |    2 
 sound/aoa/aoa-gpio.h                      |    2 
 sound/aoa/aoa.h                           |    2 
 sound/aoa/codecs/Kconfig                  |    4 
 sound/aoa/codecs/snd-aoa-codec-onyx.c     |   11 
 sound/aoa/codecs/snd-aoa-codec-onyx.h     |    1 
 sound/aoa/codecs/snd-aoa-codec-tas.c      |  110 
 sound/aoa/core/snd-aoa-alsa.c             |    5 
 sound/aoa/core/snd-aoa-alsa.h             |    2 
 sound/aoa/core/snd-aoa-core.c             |    4 
 sound/aoa/core/snd-aoa-gpio-feature.c     |   22 
 sound/aoa/core/snd-aoa-gpio-pmf.c         |   16 
 sound/aoa/fabrics/snd-aoa-fabric-layout.c |   13 
 sound/aoa/soundbus/i2sbus/i2sbus-core.c   |   33 
 sound/aoa/soundbus/i2sbus/i2sbus-pcm.c    |  413 +-
 sound/aoa/soundbus/i2sbus/i2sbus.h        |   10 
 sound/arm/aaci.c                          |  317 +
 sound/arm/aaci.h                          |   43 
 sound/arm/pxa2xx-ac97.c                   |    2 
 sound/arm/pxa2xx-pcm.c                    |    2 
 sound/arm/sa11xx-uda1341.c                |    2 
 sound/core/control.c                      |  209 -
 sound/core/control_compat.c               |    9 
 sound/core/device.c                       |   44 
 sound/core/hwdep.c                        |   33 
 sound/core/hwdep_compat.c                 |    2 
 sound/core/info.c                         |  110 
 sound/core/info_oss.c                     |    6 
 sound/core/init.c                         |  234 -
 sound/core/memalloc.c                     |   10 
 sound/core/misc.c                         |   29 
 sound/core/oss/mixer_oss.c                |   26 
 sound/core/oss/pcm_oss.c                  |   88 
 sound/core/pcm.c                          |  144 
 sound/core/pcm_compat.c                   |    2 
 sound/core/pcm_lib.c                      |   13 
 sound/core/pcm_memory.c                   |   25 
 sound/core/pcm_native.c                   |   68 
 sound/core/rawmidi.c                      |   73 
 sound/core/rtctimer.c                     |    5 
 sound/core/seq/instr/ainstr_fm.c          |    1 
 sound/core/seq/instr/ainstr_gf1.c         |    1 
 sound/core/seq/instr/ainstr_iw.c          |    1 
 sound/core/seq/instr/ainstr_simple.c      |    1 
 sound/core/seq/oss/seq_oss.c              |    5 
 sound/core/seq/seq_clientmgr.c            |   16 
 sound/core/seq/seq_device.c               |   38 
 sound/core/seq/seq_info.c                 |    6 
 sound/core/seq/seq_memory.c               |    2 
 sound/core/seq/seq_ports.c                |   51 
 sound/core/seq/seq_virmidi.c              |    5 
 sound/core/sgbuf.c                        |    2 
 sound/core/sound.c                        |    9 
 sound/core/sound_oss.c                    |    7 
 sound/core/timer.c                        |  144 
 sound/drivers/Kconfig                     |   30 
 sound/drivers/Makefile                    |    4 
 sound/drivers/dummy.c                     |   23 
 sound/drivers/mpu401/mpu401.c             |    2 
 sound/drivers/mpu401/mpu401_uart.c        |    2 
 sound/drivers/mts64.c                     | 1091 +++++
 sound/drivers/opl4/opl4_proc.c            |    9 
 sound/drivers/portman2x4.c                |  876 ++++
 sound/drivers/serial-u16550.c             |  221 -
 sound/drivers/virmidi.c                   |    1 
 sound/drivers/vx/vx_mixer.c               |   17 
 sound/i2c/Makefile                        |    1 
 sound/i2c/other/Makefile                  |    4 
 sound/i2c/other/ak4114.c                  |   31 
 sound/i2c/other/ak4117.c                  |    2 
 sound/i2c/other/ak4xxx-adda.c             |  595 +-
 sound/i2c/other/pt2258.c                  |  233 +
 sound/isa/Kconfig                         |    3 
 sound/isa/ad1816a/ad1816a.c               |    2 
 sound/isa/ad1816a/ad1816a_lib.c           |   57 
 sound/isa/ad1848/ad1848.c                 |    2 
 sound/isa/ad1848/ad1848_lib.c             |   51 
 sound/isa/cmi8330.c                       |    2 
 sound/isa/cs423x/cs4231_lib.c             |    2 
 sound/isa/dt019x.c                        |    1 
 sound/isa/es1688/es1688_lib.c             |    2 
 sound/isa/es18xx.c                        |  224 -
 sound/isa/gus/gus_irq.c                   |    2 
 sound/isa/gus/gus_main.c                  |    6 
 sound/isa/gus/gus_mem.c                   |    7 
 sound/isa/gus/gus_mem_proc.c              |    6 
 sound/isa/gus/gusclassic.c                |    4 
 sound/isa/gus/gusmax.c                    |   11 
 sound/isa/gus/interwave.c                 |   10 
 sound/isa/opl3sa2.c                       |   32 
 sound/isa/opti9xx/opti92x-ad1848.c        |    4 
 sound/isa/sb/es968.c                      |    3 
 sound/isa/sb/sb16_csp.c                   |   61 
 sound/isa/sb/sb16_main.c                  |    4 
 sound/isa/sb/sb8.c                        |    2 
 sound/isa/sb/sb_common.c                  |    2 
 sound/isa/sgalaxy.c                       |    2 
 sound/isa/wavefront/wavefront.c           |    5 
 sound/isa/wavefront/wavefront_fx.c        |  812 ---
 sound/isa/wavefront/wavefront_synth.c     |    2 
 sound/isa/wavefront/yss225.c              | 2739 +++++++++++++
 sound/mips/au1x00.c                       |    4 
 sound/oss/COPYING                         |  339 -
 sound/oss/Kconfig                         |  123 
 sound/oss/Makefile                        |   58 
 sound/oss/ac97.c                          |   20 
 sound/oss/ac97.h                          |    3 
 sound/oss/ac97_codec.c                    |   92 
 sound/oss/ac97_plugin_ad1980.c            |  126 
 sound/oss/ad1816.c                        |    2 
 sound/oss/ad1848.c                        |    8 
 sound/oss/ad1848.h                        |    1 
 sound/oss/ad1848_mixer.h                  |    2 
 sound/oss/ad1889.c                        |    9 
 sound/oss/adlib_card.c                    |    2 
 sound/oss/ali5455.c                       | 3735 ------------------
 sound/oss/au1000.c                        | 2216 ----------
 sound/oss/au1550_ac97.c                   |   10 
 sound/oss/audio.c                         |    2 
 sound/oss/audio_syms.c                    |   16 
 sound/oss/awe_hw.h                        |   99 
 sound/oss/awe_wave.c                      | 6149 ------------------------------
 sound/oss/awe_wave.h                      |   77 
 sound/oss/btaudio.c                       |   13 
 sound/oss/cmpci.c                         | 3381 ----------------
 sound/oss/cs4232.c                        |    2 
 sound/oss/cs4281/Makefile                 |    6 
 sound/oss/cs4281/cs4281_hwdefs.h          | 1234 ------
 sound/oss/cs4281/cs4281_wrapper-24.c      |   41 
 sound/oss/cs4281/cs4281m.c                | 4487 ---------------------
 sound/oss/cs4281/cs4281pm-24.c            |   45 
 sound/oss/cs4281/cs4281pm.h               |   74 
 sound/oss/cs46xx.c                        |   33 
 sound/oss/cs46xxpm-24.h                   |   48 
 sound/oss/dev_table.c                     |   46 
 sound/oss/dev_table.h                     |   17 
 sound/oss/dm.h                            |   79 
 sound/oss/dmabuf.c                        |   43 
 sound/oss/dmasound/Kconfig                |    2 
 sound/oss/dmasound/dac3550a.c             |    3 
 sound/oss/dmasound/dmasound_atari.c       |    4 
 sound/oss/dmasound/dmasound_awacs.c       |   29 
 sound/oss/dmasound/dmasound_core.c        |   30 
 sound/oss/dmasound/dmasound_paula.c       |    4 
 sound/oss/dmasound/dmasound_q40.c         |    8 
 sound/oss/dmasound/tas3001c.c             |   17 
 sound/oss/dmasound/tas3004.c              |   18 
 sound/oss/dmasound/tas_common.c           |    3 
 sound/oss/emu10k1/audio.c                 |   17 
 sound/oss/emu10k1/cardmi.c                |    2 
 sound/oss/emu10k1/cardmo.c                |    2 
 sound/oss/emu10k1/cardwi.c                |   31 
 sound/oss/emu10k1/cardwi.h                |    2 
 sound/oss/emu10k1/irqmgr.c                |    2 
 sound/oss/emu10k1/main.c                  |   13 
 sound/oss/emu10k1/midi.c                  |   12 
 sound/oss/emu10k1/mixer.c                 |    4 
 sound/oss/emu10k1/passthrough.c           |   13 
 sound/oss/es1370.c                        | 2819 -------------
 sound/oss/es1371.c                        |   11 
 sound/oss/esssolo1.c                      | 2516 ------------
 sound/oss/forte.c                         | 2139 ----------
 sound/oss/gus.h                           |   24 
 sound/oss/gus_card.c                      |  293 -
 sound/oss/gus_hw.h                        |   50 
 sound/oss/gus_linearvol.h                 |   18 
 sound/oss/gus_midi.c                      |  256 -
 sound/oss/gus_vol.c                       |  153 
 sound/oss/gus_wave.c                      | 3464 ----------------
 sound/oss/hal2.c                          |   11 
 sound/oss/harmony.c                       | 1330 ------
 sound/oss/i810_audio.c                    |   14 
 sound/oss/ics2101.c                       |  247 -
 sound/oss/ite8172.c                       | 2261 -----------
 sound/oss/iwmem.h                         |   36 
 sound/oss/kahlua.c                        |    3 
 sound/oss/mad16.c                         | 1113 -----
 sound/oss/maestro.c                       | 3686 -----------------
 sound/oss/maestro.h                       |   60 
 sound/oss/maestro3.c                      | 2969 --------------
 sound/oss/maestro3.h                      |  821 ----
 sound/oss/maui.c                          |  478 --
 sound/oss/midi_syms.c                     |   29 
 sound/oss/midi_synth.c                    |   23 
 sound/oss/midibuf.c                       |   13 
 sound/oss/mpu401.c                        |   19 
 sound/oss/mpu401.h                        |    5 
 sound/oss/msnd_pinnacle.c                 |    8 
 sound/oss/nec_vrc5477.c                   |    9 
 sound/oss/nm256.h                         |    2 
 sound/oss/nm256_audio.c                   |   12 
 sound/oss/opl3.c                          |    5 
 sound/oss/opl3sa.c                        |  329 -
 sound/oss/opl3sa2.c                       |    2 
 sound/oss/os.h                            |    2 
 sound/oss/pas2_card.c                     |    4 
 sound/oss/pas2_midi.c                     |    2 
 sound/oss/pas2_mixer.c                    |    2 
 sound/oss/pss.c                           |    2 
 sound/oss/rme96xx.c                       | 1857 ---------
 sound/oss/rme96xx.h                       |   78 
 sound/oss/sb_audio.c                      |    2 
 sound/oss/sb_card.c                       |   12 
 sound/oss/sb_common.c                     |    8 
 sound/oss/sb_midi.c                       |    6 
 sound/oss/sb_mixer.c                      |    4 
 sound/oss/sb_mixer.h                      |    2 
 sound/oss/sequencer.c                     |   17 
 sound/oss/sequencer_syms.c                |   29 
 sound/oss/sgalaxy.c                       |  207 -
 sound/oss/sh_dac_audio.c                  |   66 
 sound/oss/sonicvibes.c                    | 2792 -------------
 sound/oss/sound_calls.h                   |    3 
 sound/oss/sound_syms.c                    |   50 
 sound/oss/sound_timer.c                   |    6 
 sound/oss/soundcard.c                     |   50 
 sound/oss/sscape.c                        |    3 
 sound/oss/swarm_cs4297a.c                 |   20 
 sound/oss/sys_timer.c                     |    2 
 sound/oss/trident.c                       |   82 
 sound/oss/trix.c                          |    2 
 sound/oss/tuning.h                        |   10 
 sound/oss/uart401.c                       |    4 
 sound/oss/uart6850.c                      |    4 
 sound/oss/v_midi.c                        |    4 
 sound/oss/via82cxxx_audio.c               |   20 
 sound/oss/vidc.c                          |    2 
 sound/oss/vidc.h                          |    2 
 sound/oss/vwsnd.c                         |   10 
 sound/oss/waveartist.c                    |    8 
 sound/oss/waveartist.h                    |    2 
 sound/oss/wavfront.c                      | 3554 -----------------
 sound/oss/wf_midi.c                       |  880 ----
 sound/oss/ymfpci.c                        | 2692 -------------
 sound/oss/ymfpci.h                        |  361 -
 sound/oss/ymfpci_image.h                  | 1565 -------
 sound/oss/yss225.c                        |  319 -
 sound/oss/yss225.h                        |   24 
 sound/parisc/harmony.c                    |    8 
 sound/pci/Kconfig                         |   44 
 sound/pci/ac97/Makefile                   |    2 
 sound/pci/ac97/ac97_bus.c                 |   72 
 sound/pci/ac97/ac97_codec.c               |  350 +
 sound/pci/ac97/ac97_patch.c               |  668 +++
 sound/pci/ac97/ac97_patch.h               |    3 
 sound/pci/ac97/ac97_pcm.c                 |   18 
 sound/pci/ac97/ac97_proc.c                |   18 
 sound/pci/ac97/ak4531_codec.c             |   49 
 sound/pci/ad1889.c                        |    2 
 sound/pci/ali5451/ali5451.c               |   15 
 sound/pci/als300.c                        |   29 
 sound/pci/als4000.c                       |   11 
 sound/pci/atiixp.c                        |   42 
 sound/pci/atiixp_modem.c                  |   13 
 sound/pci/azt3328.c                       |   13 
 sound/pci/bt87x.c                         |    3 
 sound/pci/ca0106/ca0106.h                 |    2 
 sound/pci/ca0106/ca0106_main.c            |   55 
 sound/pci/ca0106/ca0106_mixer.c           |   50 
 sound/pci/cmipci.c                        |   34 
 sound/pci/cs4281.c                        |   14 
 sound/pci/cs46xx/cs46xx_lib.c             |   11 
 sound/pci/cs46xx/dsp_spos.c               |   52 
 sound/pci/cs46xx/dsp_spos_scb_lib.c       |    2 
 sound/pci/cs5535audio/Makefile            |    2 
 sound/pci/cs5535audio/cs5535audio.c       |    5 
 sound/pci/cs5535audio/cs5535audio_pm.c    |   11 
 sound/pci/echoaudio/darla20.c             |    1 
 sound/pci/echoaudio/darla24.c             |    1 
 sound/pci/echoaudio/echo3g.c              |    1 
 sound/pci/echoaudio/echo3g_dsp.c          |    2 
 sound/pci/echoaudio/echoaudio.c           |   22 
 sound/pci/echoaudio/gina20.c              |    1 
 sound/pci/echoaudio/gina24.c              |    1 
 sound/pci/echoaudio/indigo.c              |    1 
 sound/pci/echoaudio/indigodj.c            |    1 
 sound/pci/echoaudio/indigoio.c            |    1 
 sound/pci/echoaudio/layla20.c             |    1 
 sound/pci/echoaudio/layla24.c             |    1 
 sound/pci/echoaudio/mia.c                 |    1 
 sound/pci/echoaudio/midi.c                |    6 
 sound/pci/echoaudio/mona.c                |    1 
 sound/pci/emu10k1/emu10k1.c               |   15 
 sound/pci/emu10k1/emu10k1_main.c          |  626 ++-
 sound/pci/emu10k1/emu10k1x.c              |   19 
 sound/pci/emu10k1/emufx.c                 |  204 
 sound/pci/emu10k1/emumixer.c              |  745 +++
 sound/pci/emu10k1/emupcm.c                |  147 
 sound/pci/emu10k1/emuproc.c               |   34 
 sound/pci/emu10k1/io.c                    |  104 
 sound/pci/emu10k1/p16v.c                  |   17 
 sound/pci/emu10k1/p17v.h                  |   47 
 sound/pci/emu10k1/voice.c                 |    2 
 sound/pci/ens1370.c                       |  166 
 sound/pci/es1938.c                        |  116 
 sound/pci/es1968.c                        |  115 
 sound/pci/fm801.c                         |   60 
 sound/pci/hda/Makefile                    |   11 
 sound/pci/hda/hda_codec.c                 |  160 
 sound/pci/hda/hda_codec.h                 |    2 
 sound/pci/hda/hda_generic.c               |  198 
 sound/pci/hda/hda_intel.c                 |  238 -
 sound/pci/hda/hda_local.h                 |   21 
 sound/pci/hda/hda_patch.h                 |    6 
 sound/pci/hda/hda_proc.c                  |   65 
 sound/pci/hda/patch_analog.c              |  212 -
 sound/pci/hda/patch_atihdmi.c             |    1 
 sound/pci/hda/patch_cmedia.c              |   24 
 sound/pci/hda/patch_conexant.c            | 1414 ++++++
 sound/pci/hda/patch_realtek.c             | 2723 +++++++++++--
 sound/pci/hda/patch_si3054.c              |    9 
 sound/pci/hda/patch_sigmatel.c            | 1288 ++++--
 sound/pci/hda/patch_via.c                 | 1396 ++++++
 sound/pci/ice1712/Makefile                |    2 
 sound/pci/ice1712/amp.c                   |    4 
 sound/pci/ice1712/amp.h                   |    2 
 sound/pci/ice1712/aureon.c                |  278 -
 sound/pci/ice1712/aureon.h                |    6 
 sound/pci/ice1712/delta.c                 |   34 
 sound/pci/ice1712/delta.h                 |    2 
 sound/pci/ice1712/ews.c                   |   24 
 sound/pci/ice1712/ews.h                   |    2 
 sound/pci/ice1712/hoontech.c              |    7 
 sound/pci/ice1712/hoontech.h              |    2 
 sound/pci/ice1712/ice1712.c               |   86 
 sound/pci/ice1712/ice1712.h               |   18 
 sound/pci/ice1712/ice1724.c               |   78 
 sound/pci/ice1712/juli.c                  |   36 
 sound/pci/ice1712/juli.h                  |    2 
 sound/pci/ice1712/phase.c                 |  111 
 sound/pci/ice1712/phase.h                 |    2 
 sound/pci/ice1712/pontis.c                |   49 
 sound/pci/ice1712/pontis.h                |    2 
 sound/pci/ice1712/prodigy192.c            |   50 
 sound/pci/ice1712/prodigy192.h            |    2 
 sound/pci/ice1712/revo.c                  |  416 +-
 sound/pci/ice1712/revo.h                  |   13 
 sound/pci/ice1712/vt1720_mobo.c           |   59 
 sound/pci/ice1712/vt1720_mobo.h           |    2 
 sound/pci/ice1712/wtm.c                   |  542 ++
 sound/pci/ice1712/wtm.h                   |   20 
 sound/pci/intel8x0.c                      |  248 -
 sound/pci/intel8x0m.c                     |  142 
 sound/pci/korg1212/korg1212.c             |   49 
 sound/pci/maestro3.c                      |  388 +
 sound/pci/mixart/mixart.c                 |   16 
 sound/pci/mixart/mixart_mixer.c           |   14 
 sound/pci/nm256/nm256.c                   |   66 
 sound/pci/pcxhr/pcxhr_mixer.c             |   16 
 sound/pci/riptide/riptide.c               |   23 
 sound/pci/rme9652/hdsp.c                  |   92 
 sound/pci/rme9652/hdspm.c                 | 1330 +++++-
 sound/pci/rme9652/rme9652.c               |    4 
 sound/pci/sonicvibes.c                    |    2 
 sound/pci/trident/trident_main.c          |   32 
 sound/pci/via82xx.c                       |  165 
 sound/pci/via82xx_modem.c                 |   14 
 sound/pci/vx222/vx222.c                   |   18 
 sound/pci/vx222/vx222_ops.c               |    9 
 sound/pci/ymfpci/ymfpci.c                 |    5 
 sound/pci/ymfpci/ymfpci_image.h           |    6 
 sound/pci/ymfpci/ymfpci_main.c            |  221 -
 sound/pcmcia/pdaudiocf/pdaudiocf.c        |   32 
 sound/pcmcia/pdaudiocf/pdaudiocf.h        |    2 
 sound/pcmcia/pdaudiocf/pdaudiocf_irq.c    |    5 
 sound/pcmcia/vx/vxp_mixer.c               |    6 
 sound/pcmcia/vx/vxpocket.c                |   41 
 sound/ppc/beep.c                          |   34 
 sound/ppc/pmac.c                          |    6 
 sound/ppc/tumbler.c                       |   30 
 sound/soc/Kconfig                         |   34 
 sound/soc/Makefile                        |    4 
 sound/soc/at91/Kconfig                    |   31 
 sound/soc/at91/Makefile                   |   11 
 sound/soc/at91/at91-i2s.c                 |  721 +++
 sound/soc/at91/at91-i2s.h                 |   27 
 sound/soc/at91/at91-pcm.c                 |  432 ++
 sound/soc/at91/at91-pcm.h                 |   72 
 sound/soc/at91/eti_b1_wm8731.c            |  375 +
 sound/soc/at91/soc-core.c                 | 1587 +++++++
 sound/soc/at91/soc-dapm.c                 | 1323 ++++++
 sound/soc/codecs/Kconfig                  |   15 
 sound/soc/codecs/Makefile                 |    9 
 sound/soc/codecs/ac97.c                   |  156 
 sound/soc/codecs/ac97.h                   |   18 
 sound/soc/codecs/wm8731.c                 |  758 +++
 sound/soc/codecs/wm8731.h                 |   44 
 sound/soc/codecs/wm8750.c                 | 1049 +++++
 sound/soc/codecs/wm8750.h                 |   67 
 sound/soc/codecs/wm9712.c                 |  772 +++
 sound/soc/codecs/wm9712.h                 |   14 
 sound/soc/pxa/Kconfig                     |   59 
 sound/soc/pxa/Makefile                    |   20 
 sound/soc/pxa/corgi.c                     |  383 +
 sound/soc/pxa/poodle.c                    |  352 +
 sound/soc/pxa/pxa2xx-ac97.c               |  431 ++
 sound/soc/pxa/pxa2xx-ac97.h               |   22 
 sound/soc/pxa/pxa2xx-i2s.c                |  318 +
 sound/soc/pxa/pxa2xx-i2s.h                |   20 
 sound/soc/pxa/pxa2xx-pcm.c                |  372 +
 sound/soc/pxa/pxa2xx-pcm.h                |   34 
 sound/soc/pxa/spitz.c                     |  394 +
 sound/soc/pxa/tosa.c                      |  289 +
 sound/soc/soc-core.c                      | 1587 +++++++
 sound/soc/soc-dapm.c                      | 1323 ++++++
 sound/sound_core.c                        |   46 
 sound/sound_firmware.c                    |    8 
 sound/sparc/amd7930.c                     |   22 
 sound/sparc/cs4231.c                      |   28 
 sound/sparc/dbri.c                        |  826 +---
 sound/synth/emux/emux.c                   |    1 
 sound/synth/emux/emux_proc.c              |    7 
 sound/usb/usbaudio.c                      |  236 -
 sound/usb/usbaudio.h                      |    1 
 sound/usb/usbmidi.c                       |   10 
 sound/usb/usbmixer.c                      |   43 
 sound/usb/usbmixer_maps.c                 |   24 
 sound/usb/usbquirks.h                     |   60 
 sound/usb/usx2y/usX2Yhwdep.c              |    2 
 sound/usb/usx2y/usbusx2yaudio.c           |    2 
 sound/usb/usx2y/usx2yhwdeppcm.c           |    2 
 451 files changed, 36890 insertions(+), 68508 deletions(-)


--- linux-2.6.18.noarch/include/sound/ymfpci.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/ymfpci.h	2007-06-05 17:35:15.000000000 -0400
@@ -270,6 +270,7 @@
 	struct snd_pcm_substream *substream;
 	struct snd_ymfpci_voice *voices[2];	/* playback only */
 	unsigned int running: 1,
+		     use_441_slot: 1,
 	             output_front: 1,
 	             output_rear: 1,
 	             swap_rear: 1;
@@ -286,7 +287,7 @@
 	int irq;
 
 	unsigned int device_id;	/* PCI device ID */
-	unsigned int rev;	/* PCI revision */
+	unsigned char rev;	/* PCI revision */
 	unsigned long reg_area_phys;
 	void __iomem *reg_area_virt;
 	struct resource *res_reg_area;
@@ -324,6 +325,7 @@
 
 	u32 active_bank;
 	struct snd_ymfpci_voice voices[64];
+	int src441_used;
 
 	struct snd_ac97_bus *ac97_bus;
 	struct snd_ac97 *ac97;
@@ -345,9 +347,8 @@
 	struct snd_kcontrol *spdif_pcm_ctl;
 	int mode_dup4ch;
 	int rear_opened;
-	int rear_swap;
 	int spdif_opened;
-	struct {
+	struct snd_ymfpci_pcm_mixer {
 		u16 left;
 		u16 right;
 		struct snd_kcontrol *ctl;
@@ -358,6 +359,8 @@
 	wait_queue_head_t interrupt_sleep;
 	atomic_t interrupt_sleep_count;
 	struct snd_info_entry *proc_entry;
+	const struct firmware *dsp_microcode;
+	const struct firmware *controller_microcode;
 
 #ifdef CONFIG_PM
 	u32 *saved_regs;
@@ -378,7 +381,7 @@
 int snd_ymfpci_pcm2(struct snd_ymfpci *chip, int device, struct snd_pcm **rpcm);
 int snd_ymfpci_pcm_spdif(struct snd_ymfpci *chip, int device, struct snd_pcm **rpcm);
 int snd_ymfpci_pcm_4ch(struct snd_ymfpci *chip, int device, struct snd_pcm **rpcm);
-int snd_ymfpci_mixer(struct snd_ymfpci *chip, int rear_switch, int rear_swap);
+int snd_ymfpci_mixer(struct snd_ymfpci *chip, int rear_switch);
 int snd_ymfpci_timer(struct snd_ymfpci *chip, int device);
 
 #endif /* __SOUND_YMFPCI_H */
--- linux-2.6.18.noarch/include/sound/tlv.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/tlv.h	2007-06-05 17:35:15.000000000 -0400
@@ -0,0 +1,60 @@
+#ifndef __SOUND_TLV_H
+#define __SOUND_TLV_H
+
+/*
+ *  Advanced Linux Sound Architecture - ALSA - Driver
+ *  Copyright (c) 2006 by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * TLV structure is right behind the struct snd_ctl_tlv:
+ *   unsigned int type  	- see SNDRV_CTL_TLVT_*
+ *   unsigned int length
+ *   .... data aligned to sizeof(unsigned int), use
+ *        block_length = (length + (sizeof(unsigned int) - 1)) &
+ *                       ~(sizeof(unsigned int) - 1)) ....
+ */
+
+#define SNDRV_CTL_TLVT_CONTAINER 0	/* one level down - group of TLVs */
+#define SNDRV_CTL_TLVT_DB_SCALE	1       /* dB scale */
+#define SNDRV_CTL_TLVT_DB_LINEAR 2	/* linear volume */
+#define SNDRV_CTL_TLVT_DB_RANGE 3	/* dB range container */
+
+#define TLV_DB_SCALE_ITEM(min, step, mute)			\
+	SNDRV_CTL_TLVT_DB_SCALE, 2 * sizeof(unsigned int),	\
+	(min), ((step) & 0xffff) | ((mute) ? 0x10000 : 0)
+#define DECLARE_TLV_DB_SCALE(name, min, step, mute) \
+	unsigned int name[] = { TLV_DB_SCALE_ITEM(min, step, mute) }
+
+/* linear volume between min_dB and max_dB (.01dB unit) */
+#define TLV_DB_LINEAR_ITEM(min_dB, max_dB)		    \
+	SNDRV_CTL_TLVT_DB_LINEAR, 2 * sizeof(unsigned int), \
+	(min_dB), (max_dB)
+#define DECLARE_TLV_DB_LINEAR(name, min_dB, max_dB)	\
+	unsigned int name[] = { TLV_DB_LINEAR_ITEM(min_dB, max_dB) }
+
+/* dB range container */
+/* Each item is: <min> <max> <TLV> */
+/* The below assumes that each item TLV is 4 words like DB_SCALE or LINEAR */
+#define TLV_DB_RANGE_HEAD(num)			\
+	SNDRV_CTL_TLVT_DB_RANGE, 6 * (num) * sizeof(unsigned int)
+
+#define TLV_DB_GAIN_MUTE	-9999999
+
+#endif /* __SOUND_TLV_H */
--- linux-2.6.18.noarch/include/sound/pcm_oss.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/pcm_oss.h	2007-06-05 17:35:15.000000000 -0400
@@ -56,6 +56,7 @@
 	size_t mmap_bytes;
 	char *buffer;				/* vmallocated period */
 	size_t buffer_used;			/* used length from period buffer */
+	struct mutex params_lock;
 #ifdef CONFIG_SND_PCM_OSS_PLUGINS
 	struct snd_pcm_plugin *plugin_first;
 	struct snd_pcm_plugin *plugin_last;
--- linux-2.6.18.noarch/include/sound/soc-dapm.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/soc-dapm.h	2007-06-05 17:35:15.000000000 -0400
@@ -0,0 +1,286 @@
+/*
+ * linux/sound/soc-dapm.h -- ALSA SoC Dynamic Audio Power Management
+ *
+ * Author:		Liam Girdwood
+ * Created:		Aug 11th 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_DAPM_H
+#define __LINUX_SND_SOC_DAPM_H
+
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+
+/* widget has no PM register bit */
+#define SND_SOC_NOPM	-1
+
+/*
+ * SoC dynamic audio power managment
+ *
+ * We can have upto 4 power domains
+ * 	1. Codec domain - VREF, VMID
+ *     Usually controlled at codec probe/remove, although can be set
+ *     at stream time if power is not needed for sidetone, etc.
+ *  2. Platform/Machine domain - physically connected inputs and outputs
+ *     Is platform/machine and user action specific, is set in the machine
+ *     driver and by userspace e.g when HP are inserted
+ *  3. Path domain - Internal codec path mixers
+ *     Are automatically set when mixer and mux settings are
+ *     changed by the user.
+ *  4. Stream domain - DAC's and ADC's.
+ *     Enabled when stream playback/capture is started.
+ */
+
+/* codec domain */
+#define SND_SOC_DAPM_VMID(wname) \
+{	.id = snd_soc_dapm_vmid, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0}
+
+/* platform domain */
+#define SND_SOC_DAPM_INPUT(wname) \
+{	.id = snd_soc_dapm_input, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0}
+#define SND_SOC_DAPM_OUTPUT(wname) \
+{	.id = snd_soc_dapm_output, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0}
+#define SND_SOC_DAPM_MIC(wname, wevent) \
+{	.id = snd_soc_dapm_mic, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD}
+#define SND_SOC_DAPM_HP(wname, wevent) \
+{	.id = snd_soc_dapm_hp, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
+#define SND_SOC_DAPM_SPK(wname, wevent) \
+{	.id = snd_soc_dapm_spk, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
+#define SND_SOC_DAPM_LINE(wname, wevent) \
+{	.id = snd_soc_dapm_line, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD}
+
+/* path domain */
+#define SND_SOC_DAPM_PGA(wname, wreg, wshift, winvert,\
+	 wcontrols, wncontrols) \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols}
+#define SND_SOC_DAPM_MIXER(wname, wreg, wshift, winvert, \
+	 wcontrols, wncontrols)\
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols}
+#define SND_SOC_DAPM_MICBIAS(wname, wreg, wshift, winvert) \
+{	.id = snd_soc_dapm_micbias, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = NULL, .num_kcontrols = 0}
+#define SND_SOC_DAPM_SWITCH(wname, wreg, wshift, winvert, wcontrols) \
+{	.id = snd_soc_dapm_switch, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1}
+#define SND_SOC_DAPM_MUX(wname, wreg, wshift, winvert, wcontrols) \
+{	.id = snd_soc_dapm_mux, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1}
+
+/* path domain with event - event handler must return 0 for success */
+#define SND_SOC_DAPM_PGA_E(wname, wreg, wshift, winvert, wcontrols, \
+	wncontrols, wevent, wflags) \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols, \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_MIXER_E(wname, wreg, wshift, winvert, wcontrols, \
+	wncontrols, wevent, wflags) \
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = wncontrols, \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_MICBIAS_E(wname, wreg, wshift, winvert, wevent, wflags) \
+{	.id = snd_soc_dapm_micbias, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = NULL, .num_kcontrols = 0, \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_SWITCH_E(wname, wreg, wshift, winvert, wcontrols, \
+	wevent, wflags) \
+{	.id = snd_soc_dapm_switch, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1 \
+	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_MUX_E(wname, wreg, wshift, winvert, wcontrols, \
+	wevent, wflags) \
+{	.id = snd_soc_dapm_mux, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = 1, \
+	.event = wevent, .event_flags = wflags}
+
+/* events that are pre and post DAPM */
+#define SND_SOC_DAPM_PRE(wname, wevent) \
+{	.id = snd_soc_dapm_pre, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD}
+#define SND_SOC_DAPM_POST(wname, wevent) \
+{	.id = snd_soc_dapm_post, .name = wname, .kcontrols = NULL, \
+	.num_kcontrols = 0, .event = wevent, \
+	.event_flags = SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD}
+
+/* stream domain */
+#define SND_SOC_DAPM_DAC(wname, stname, wreg, wshift, winvert) \
+{	.id = snd_soc_dapm_dac, .name = wname, .sname = stname, .reg = wreg, \
+	.shift = wshift, .invert = winvert}
+#define SND_SOC_DAPM_ADC(wname, stname, wreg, wshift, winvert) \
+{	.id = snd_soc_dapm_adc, .name = wname, .sname = stname, .reg = wreg, \
+	.shift = wshift, .invert = winvert}
+
+/* dapm kcontrol types */
+#define SOC_DAPM_SINGLE(xname, reg, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, mask, invert) }
+#define SOC_DAPM_DOUBLE(xname, reg, shift_left, shift_right, mask, invert, \
+	power) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.info = snd_soc_info_volsw, \
+ 	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
+ 	.private_value = (reg) | ((shift_left) << 8) | ((shift_right) << 12) |\
+ 		 ((mask) << 16) | ((invert) << 24) }
+#define SOC_DAPM_ENUM(xname, xenum) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_enum_double, \
+ 	.get = snd_soc_dapm_get_enum_double, \
+ 	.put = snd_soc_dapm_put_enum_double, \
+  	.private_value = (unsigned long)&xenum }
+
+/* dapm stream operations */
+#define SND_SOC_DAPM_STREAM_NOP			0x0
+#define SND_SOC_DAPM_STREAM_START		0x1
+#define SND_SOC_DAPM_STREAM_STOP		0x2
+#define SND_SOC_DAPM_STREAM_SUSPEND		0x4
+#define SND_SOC_DAPM_STREAM_RESUME		0x8
+#define SND_SOC_DAPM_STREAM_PAUSE_PUSH	0x10
+#define SND_SOC_DAPM_STREAM_PAUSE_RELEASE	0x20
+
+/* dapm event types */
+#define SND_SOC_DAPM_PRE_PMU	0x1 	/* before widget power up */
+#define SND_SOC_DAPM_POST_PMU	0x2		/* after widget power up */
+#define SND_SOC_DAPM_PRE_PMD	0x4 	/* before widget power down */
+#define SND_SOC_DAPM_POST_PMD	0x8		/* after widget power down */
+#define SND_SOC_DAPM_PRE_REG	0x10	/* before audio path setup */
+#define SND_SOC_DAPM_POST_REG	0x20	/* after audio path setup */
+
+/* convenience event type detection */
+#define SND_SOC_DAPM_EVENT_ON(e)	\
+	(e & (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU))
+#define SND_SOC_DAPM_EVENT_OFF(e)	\
+	(e & (SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD))
+
+struct snd_soc_dapm_widget;
+enum snd_soc_dapm_type;
+struct snd_soc_dapm_path;
+struct snd_soc_dapm_pin;
+
+/* dapm controls */
+int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_new_control(struct snd_soc_codec *codec,
+	const struct snd_soc_dapm_widget *widget);
+
+/* dapm path setup */
+int snd_soc_dapm_connect_input(struct snd_soc_codec *codec,
+	const char *sink_name, const char *control_name, const char *src_name);
+int snd_soc_dapm_new_widgets(struct snd_soc_codec *codec);
+void snd_soc_dapm_free(struct snd_soc_device *socdev);
+
+/* dapm events */
+int snd_soc_dapm_stream_event(struct snd_soc_codec *codec, char *stream,
+	int event);
+
+/* dapm sys fs - used by the core */
+int snd_soc_dapm_sys_add(struct device *dev);
+
+/* dapm audio endpoint control */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *pin, int status);
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec);
+
+/* dapm widget types */
+enum snd_soc_dapm_type {
+	snd_soc_dapm_input = 0,		/* input pin */
+	snd_soc_dapm_output,		/* output pin */
+	snd_soc_dapm_mux,			/* selects 1 analog signal from many inputs */
+	snd_soc_dapm_mixer,			/* mixes several analog signals together */
+	snd_soc_dapm_pga,			/* programmable gain/attenuation (volume) */
+	snd_soc_dapm_adc,			/* analog to digital converter */
+	snd_soc_dapm_dac,			/* digital to analog converter */
+	snd_soc_dapm_micbias,		/* microphone bias (power) */
+	snd_soc_dapm_mic,			/* microphone */
+	snd_soc_dapm_hp,			/* headphones */
+	snd_soc_dapm_spk,			/* speaker */
+	snd_soc_dapm_line,			/* line input/output */
+	snd_soc_dapm_switch,		/* analog switch */
+	snd_soc_dapm_vmid,			/* codec bias/vmid - to minimise pops */
+	snd_soc_dapm_pre,			/* machine specific pre widget - exec first */
+	snd_soc_dapm_post,			/* machine specific post widget - exec last */
+};
+
+/* dapm audio path between two widgets */
+struct snd_soc_dapm_path {
+	char *name;
+	char *long_name;
+
+	/* source (input) and sink (output) widgets */
+	struct snd_soc_dapm_widget *source;
+	struct snd_soc_dapm_widget *sink;
+	struct snd_kcontrol *kcontrol;
+
+	/* status */
+	u32 connect:1;	/* source and sink widgets are connected */
+	u32 walked:1;	/* path has been walked */
+
+	struct list_head list_source;
+	struct list_head list_sink;
+	struct list_head list;
+};
+
+/* dapm widget */
+struct snd_soc_dapm_widget {
+	enum snd_soc_dapm_type id;
+	char *name;		/* widget name */
+	char *sname;	/* stream name */
+	struct snd_soc_codec *codec;
+	struct list_head list;
+
+	/* dapm control */
+	short reg;						/* negative reg = no direct dapm */
+	unsigned char shift;			/* bits to shift */
+	unsigned int saved_value;		/* widget saved value */
+	unsigned int value;				/* widget current value */
+	unsigned char power:1;			/* block power status */
+	unsigned char invert:1;			/* invert the power bit */
+	unsigned char active:1;			/* active stream on DAC, ADC's */
+	unsigned char connected:1;		/* connected codec pin */
+	unsigned char new:1;			/* cnew complete */
+	unsigned char ext:1;			/* has external widgets */
+	unsigned char muted:1;			/* muted for pop reduction */
+	unsigned char suspend:1;		/* was active before suspend */
+	unsigned char pmdown:1;			/* waiting for timeout */
+
+	/* external events */
+	unsigned short event_flags;		/* flags to specify event types */
+	int (*event)(struct snd_soc_dapm_widget*, int);
+
+	/* kcontrols that relate to this widget */
+	int num_kcontrols;
+	const struct snd_kcontrol_new *kcontrols;
+
+	/* widget input and outputs */
+	struct list_head sources;
+	struct list_head sinks;
+};
+
+#endif
--- linux-2.6.18.noarch/include/sound/timer.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/timer.h	2007-06-05 17:35:15.000000000 -0400
@@ -129,7 +129,6 @@
 int snd_timer_global_new(char *id, int device, struct snd_timer **rtimer);
 int snd_timer_global_free(struct snd_timer *timer);
 int snd_timer_global_register(struct snd_timer *timer);
-int snd_timer_global_unregister(struct snd_timer *timer);
 
 int snd_timer_open(struct snd_timer_instance **ti, char *owner, struct snd_timer_id *tid, unsigned int slave_id);
 int snd_timer_close(struct snd_timer_instance *timeri);
--- linux-2.6.18.noarch/include/sound/control.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/control.h	2007-06-05 17:35:15.000000000 -0400
@@ -30,6 +30,11 @@
 typedef int (snd_kcontrol_info_t) (struct snd_kcontrol * kcontrol, struct snd_ctl_elem_info * uinfo);
 typedef int (snd_kcontrol_get_t) (struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol);
 typedef int (snd_kcontrol_put_t) (struct snd_kcontrol * kcontrol, struct snd_ctl_elem_value * ucontrol);
+typedef int (snd_kcontrol_tlv_rw_t)(struct snd_kcontrol *kcontrol,
+				    int op_flag, /* 0=read,1=write,-1=command */
+				    unsigned int size,
+				    unsigned int __user *tlv);
+
 
 struct snd_kcontrol_new {
 	snd_ctl_elem_iface_t iface;	/* interface identifier */
@@ -42,6 +47,10 @@
 	snd_kcontrol_info_t *info;
 	snd_kcontrol_get_t *get;
 	snd_kcontrol_put_t *put;
+	union {
+		snd_kcontrol_tlv_rw_t *c;
+		const unsigned int *p;
+	} tlv;
 	unsigned long private_value;
 };
 
@@ -58,6 +67,10 @@
 	snd_kcontrol_info_t *info;
 	snd_kcontrol_get_t *get;
 	snd_kcontrol_put_t *put;
+	union {
+		snd_kcontrol_tlv_rw_t *c;
+		const unsigned int *p;
+	} tlv;
 	unsigned long private_value;
 	void *private_data;
 	void (*private_free)(struct snd_kcontrol *kcontrol);
@@ -95,7 +108,6 @@
 
 void snd_ctl_notify(struct snd_card * card, unsigned int mask, struct snd_ctl_elem_id * id);
 
-struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol * kcontrol, unsigned int access);
 struct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new * kcontrolnew, void * private_data);
 void snd_ctl_free_one(struct snd_kcontrol * kcontrol);
 int snd_ctl_add(struct snd_card * card, struct snd_kcontrol * kcontrol);
--- linux-2.6.18.noarch/include/sound/ak4117.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/ak4117.h	2007-06-05 17:35:15.000000000 -0400
@@ -178,7 +178,7 @@
 };
 
 int snd_ak4117_create(struct snd_card *card, ak4117_read_t *read, ak4117_write_t *write,
-		      unsigned char pgm[5], void *private_data, struct ak4117 **r_ak4117);
+		      const unsigned char pgm[5], void *private_data, struct ak4117 **r_ak4117);
 void snd_ak4117_reg_write(struct ak4117 *ak4117, unsigned char reg, unsigned char mask, unsigned char val);
 void snd_ak4117_reinit(struct ak4117 *ak4117);
 int snd_ak4117_build(struct ak4117 *ak4117, struct snd_pcm_substream *capture_substream);
--- linux-2.6.18.noarch/include/sound/typedefs.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/typedefs.h	2007-06-05 17:35:15.000000000 -0400
@@ -1,173 +0,0 @@
-/*
- * Typedef's for backward compatibility (for out-of-kernel drivers)
- *
- * This file will be removed soon in future
- */
-
-/* core stuff */
-typedef struct snd_card snd_card_t;
-typedef struct snd_device snd_device_t;
-typedef struct snd_device_ops snd_device_ops_t;
-typedef enum snd_card_type snd_card_type_t;
-typedef struct snd_minor snd_minor_t;
-
-/* info */
-typedef struct snd_info_entry snd_info_entry_t;
-typedef struct snd_info_buffer snd_info_buffer_t;
-
-/* control */
-typedef struct snd_ctl_file snd_ctl_file_t;
-typedef struct snd_kcontrol snd_kcontrol_t;
-typedef struct snd_kcontrol_new snd_kcontrol_new_t;
-typedef struct snd_kcontrol_volatile snd_kcontrol_volatile_t;
-typedef struct snd_kctl_event snd_kctl_event_t;
-typedef struct snd_aes_iec958 snd_aes_iec958_t;
-typedef struct snd_ctl_card_info snd_ctl_card_info_t;
-typedef struct snd_ctl_elem_id snd_ctl_elem_id_t;
-typedef struct snd_ctl_elem_list snd_ctl_elem_list_t;
-typedef struct snd_ctl_elem_info snd_ctl_elem_info_t;
-typedef struct snd_ctl_elem_value snd_ctl_elem_value_t;
-typedef struct snd_ctl_event snd_ctl_event_t;
-#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
-typedef struct snd_mixer_oss snd_mixer_oss_t;
-#endif
-
-/* timer */
-typedef struct snd_timer snd_timer_t;
-typedef struct snd_timer_instance snd_timer_instance_t;
-typedef struct snd_timer_id snd_timer_id_t;
-typedef struct snd_timer_ginfo snd_timer_ginfo_t;
-typedef struct snd_timer_gparams snd_timer_gparams_t;
-typedef struct snd_timer_gstatus snd_timer_gstatus_t;
-typedef struct snd_timer_select snd_timer_select_t;
-typedef struct snd_timer_info snd_timer_info_t;
-typedef struct snd_timer_params snd_timer_params_t;
-typedef struct snd_timer_status snd_timer_status_t;
-typedef struct snd_timer_read snd_timer_read_t;
-typedef struct snd_timer_tread snd_timer_tread_t;
-
-/* PCM */
-typedef struct snd_pcm snd_pcm_t;
-typedef struct snd_pcm_str snd_pcm_str_t;
-typedef struct snd_pcm_substream snd_pcm_substream_t;
-typedef struct snd_pcm_info snd_pcm_info_t;
-typedef struct snd_pcm_hw_params snd_pcm_hw_params_t;
-typedef struct snd_pcm_sw_params snd_pcm_sw_params_t;
-typedef struct snd_pcm_channel_info snd_pcm_channel_info_t;
-typedef struct snd_pcm_status snd_pcm_status_t;
-typedef struct snd_pcm_mmap_status snd_pcm_mmap_status_t;
-typedef struct snd_pcm_mmap_control snd_pcm_mmap_control_t;
-typedef struct snd_mask snd_mask_t;
-typedef struct snd_sg_buf snd_pcm_sgbuf_t;
-
-typedef struct snd_interval snd_interval_t;
-typedef struct snd_xferi snd_xferi_t;
-typedef struct snd_xfern snd_xfern_t;
-typedef struct snd_xferv snd_xferv_t;
-
-typedef struct snd_pcm_file snd_pcm_file_t;
-typedef struct snd_pcm_runtime snd_pcm_runtime_t;
-typedef struct snd_pcm_hardware snd_pcm_hardware_t;
-typedef struct snd_pcm_ops snd_pcm_ops_t;
-typedef struct snd_pcm_hw_rule snd_pcm_hw_rule_t;
-typedef struct snd_pcm_hw_constraints snd_pcm_hw_constraints_t;
-typedef struct snd_ratnum ratnum_t;
-typedef struct snd_ratden ratden_t;
-typedef struct snd_pcm_hw_constraint_ratnums snd_pcm_hw_constraint_ratnums_t;
-typedef struct snd_pcm_hw_constraint_ratdens snd_pcm_hw_constraint_ratdens_t;
-typedef struct snd_pcm_hw_constraint_list snd_pcm_hw_constraint_list_t;
-typedef struct snd_pcm_group snd_pcm_group_t;
-typedef struct snd_pcm_notify snd_pcm_notify_t;
-
-/* rawmidi */
-typedef struct snd_rawmidi snd_rawmidi_t;
-typedef struct snd_rawmidi_info snd_rawmidi_info_t;
-typedef struct snd_rawmidi_params snd_rawmidi_params_t;
-typedef struct snd_rawmidi_status snd_rawmidi_status_t;
-typedef struct snd_rawmidi_runtime snd_rawmidi_runtime_t;
-typedef struct snd_rawmidi_substream snd_rawmidi_substream_t;
-typedef struct snd_rawmidi_str snd_rawmidi_str_t;
-typedef struct snd_rawmidi_ops snd_rawmidi_ops_t;
-typedef struct snd_rawmidi_global_ops snd_rawmidi_global_ops_t;
-typedef struct snd_rawmidi_file snd_rawmidi_file_t;
-
-/* hwdep */
-typedef struct snd_hwdep snd_hwdep_t;
-typedef struct snd_hwdep_info snd_hwdep_info_t;
-typedef struct snd_hwdep_dsp_status snd_hwdep_dsp_status_t;
-typedef struct snd_hwdep_dsp_image snd_hwdep_dsp_image_t;
-typedef struct snd_hwdep_ops snd_hwdep_ops_t;
-
-/* sequencer */
-typedef struct snd_seq_port_info snd_seq_port_info_t;
-typedef struct snd_seq_port_subscribe snd_seq_port_subscribe_t;
-typedef struct snd_seq_event snd_seq_event_t;
-typedef struct snd_seq_addr snd_seq_addr_t;
-typedef struct snd_seq_ev_volume snd_seq_ev_volume_t;
-typedef struct snd_seq_ev_loop snd_seq_ev_loop_t;
-typedef struct snd_seq_remove_events snd_seq_remove_events_t;
-typedef struct snd_seq_query_subs snd_seq_query_subs_t;
-typedef struct snd_seq_system_info snd_seq_system_info_t;
-typedef struct snd_seq_client_info snd_seq_client_info_t;
-typedef struct snd_seq_queue_info snd_seq_queue_info_t;
-typedef struct snd_seq_queue_status snd_seq_queue_status_t;
-typedef struct snd_seq_queue_tempo snd_seq_queue_tempo_t;
-typedef struct snd_seq_queue_owner snd_seq_queue_owner_t;
-typedef struct snd_seq_queue_timer snd_seq_queue_timer_t;
-typedef struct snd_seq_queue_client snd_seq_queue_client_t;
-typedef struct snd_seq_client_pool snd_seq_client_pool_t;
-typedef struct snd_seq_instr snd_seq_instr_t;
-typedef struct snd_seq_instr_data snd_seq_instr_data_t;
-typedef struct snd_seq_instr_header snd_seq_instr_header_t;
-
-typedef struct snd_seq_user_client user_client_t;
-typedef struct snd_seq_kernel_client kernel_client_t;
-typedef struct snd_seq_client client_t;
-typedef struct snd_seq_queue queue_t;
-
-/* seq_device */
-typedef struct snd_seq_device snd_seq_device_t;
-typedef struct snd_seq_dev_ops snd_seq_dev_ops_t;
-
-/* seq_midi */
-typedef struct snd_midi_event snd_midi_event_t;
-
-/* seq_midi_emul */
-typedef struct snd_midi_channel snd_midi_channel_t;
-typedef struct snd_midi_channel_set snd_midi_channel_set_t;
-typedef struct snd_midi_op snd_midi_op_t;
-
-/* seq_oss */
-typedef struct snd_seq_oss_arg snd_seq_oss_arg_t;
-typedef struct snd_seq_oss_callback snd_seq_oss_callback_t;
-typedef struct snd_seq_oss_reg snd_seq_oss_reg_t;
-
-/* virmidi */
-typedef struct snd_virmidi_dev snd_virmidi_dev_t;
-typedef struct snd_virmidi snd_virmidi_t;
-
-/* seq_instr */
-typedef struct snd_seq_kcluster snd_seq_kcluster_t;
-typedef struct snd_seq_kinstr_ops snd_seq_kinstr_ops_t;
-typedef struct snd_seq_kinstr snd_seq_kinstr_t;
-typedef struct snd_seq_kinstr_list snd_seq_kinstr_list_t;
-
-/* ac97 */
-typedef struct snd_ac97_bus ac97_bus_t;
-typedef struct snd_ac97_bus_ops ac97_bus_ops_t;
-typedef struct snd_ac97_template ac97_template_t;
-typedef struct snd_ac97 ac97_t;
-
-/* opl3/4 */
-typedef struct snd_opl3 opl3_t;
-typedef struct snd_opl4 opl4_t;
-
-/* mpu401 */
-typedef struct snd_mpu401 mpu401_t;
-
-/* i2c */
-typedef struct snd_i2c_device snd_i2c_device_t;
-typedef struct snd_i2c_bus snd_i2c_bus_t;
-
-typedef struct snd_ak4531 ak4531_t;
-
--- linux-2.6.18.noarch/include/sound/asound.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/asound.h	2007-06-05 17:35:15.000000000 -0400
@@ -688,7 +688,7 @@
  *                                                                          *
  ****************************************************************************/
 
-#define SNDRV_CTL_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 3)
+#define SNDRV_CTL_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 4)
 
 struct snd_ctl_card_info {
 	int card;			/* card number */
@@ -727,10 +727,15 @@
 #define SNDRV_CTL_ELEM_ACCESS_WRITE		(1<<1)
 #define SNDRV_CTL_ELEM_ACCESS_READWRITE		(SNDRV_CTL_ELEM_ACCESS_READ|SNDRV_CTL_ELEM_ACCESS_WRITE)
 #define SNDRV_CTL_ELEM_ACCESS_VOLATILE		(1<<2)	/* control value may be changed without a notification */
-#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP		(1<<2)	/* when was control changed */
+#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP		(1<<3)	/* when was control changed */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READ		(1<<4)	/* TLV read is possible */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE		(1<<5)	/* TLV write is possible */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE	(SNDRV_CTL_ELEM_ACCESS_TLV_READ|SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)
+#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND	(1<<6)	/* TLV command is possible */
 #define SNDRV_CTL_ELEM_ACCESS_INACTIVE		(1<<8)	/* control does actually nothing, but may be updated */
 #define SNDRV_CTL_ELEM_ACCESS_LOCK		(1<<9)	/* write lock */
 #define SNDRV_CTL_ELEM_ACCESS_OWNER		(1<<10)	/* write lock owner */
+#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK	(1<<28)	/* kernel use a TLV callback */ 
 #define SNDRV_CTL_ELEM_ACCESS_USER		(1<<29) /* user space element */
 #define SNDRV_CTL_ELEM_ACCESS_DINDIRECT		(1<<30)	/* indirect access for matrix dimensions in the info structure */
 #define SNDRV_CTL_ELEM_ACCESS_INDIRECT		(1<<31)	/* indirect access for element value in the value structure */
@@ -818,6 +823,12 @@
         unsigned char reserved[128-sizeof(struct timespec)];
 };
 
+struct snd_ctl_tlv {
+        unsigned int numid;	/* control element numeric identification */
+        unsigned int length;	/* in bytes aligned to 4 */
+        unsigned int tlv[0];	/* first TLV */
+};
+
 enum {
 	SNDRV_CTL_IOCTL_PVERSION = _IOR('U', 0x00, int),
 	SNDRV_CTL_IOCTL_CARD_INFO = _IOR('U', 0x01, struct snd_ctl_card_info),
@@ -831,6 +842,9 @@
 	SNDRV_CTL_IOCTL_ELEM_ADD = _IOWR('U', 0x17, struct snd_ctl_elem_info),
 	SNDRV_CTL_IOCTL_ELEM_REPLACE = _IOWR('U', 0x18, struct snd_ctl_elem_info),
 	SNDRV_CTL_IOCTL_ELEM_REMOVE = _IOWR('U', 0x19, struct snd_ctl_elem_id),
+	SNDRV_CTL_IOCTL_TLV_READ = _IOWR('U', 0x1a, struct snd_ctl_tlv),
+	SNDRV_CTL_IOCTL_TLV_WRITE = _IOWR('U', 0x1b, struct snd_ctl_tlv),
+	SNDRV_CTL_IOCTL_TLV_COMMAND = _IOWR('U', 0x1c, struct snd_ctl_tlv),
 	SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE = _IOWR('U', 0x20, int),
 	SNDRV_CTL_IOCTL_HWDEP_INFO = _IOR('U', 0x21, struct snd_hwdep_info),
 	SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE = _IOR('U', 0x30, int),
@@ -855,6 +869,7 @@
 #define SNDRV_CTL_EVENT_MASK_VALUE	(1<<0)	/* element value was changed */
 #define SNDRV_CTL_EVENT_MASK_INFO	(1<<1)	/* element info was changed */
 #define SNDRV_CTL_EVENT_MASK_ADD	(1<<2)	/* element was added */
+#define SNDRV_CTL_EVENT_MASK_TLV	(1<<3)	/* element TLV tree was changed */
 #define SNDRV_CTL_EVENT_MASK_REMOVE	(~0U)	/* element was removed */
 
 struct snd_ctl_event {
--- linux-2.6.18.noarch/include/sound/ad1848.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/ad1848.h	2007-06-05 17:35:15.000000000 -0400
@@ -179,14 +179,13 @@
 #define AD1848_MIXVAL_DOUBLE(left_reg, right_reg, shift_left, shift_right, mask, invert) \
 	((left_reg) | ((right_reg) << 8) | ((shift_left) << 16) | ((shift_right) << 19) | ((mask) << 24) | ((invert) << 22))
 
-int snd_ad1848_add_ctl(struct snd_ad1848 *chip, const char *name, int index, int type, unsigned long value);
-
 /* for ease of use */
 struct ad1848_mix_elem {
 	const char *name;
 	int index;
 	int type;
 	unsigned long private_value;
+	const unsigned int *tlv;
 };
 
 #define AD1848_SINGLE(xname, xindex, reg, shift, mask, invert) \
@@ -195,15 +194,26 @@
   .type = AD1848_MIX_SINGLE, \
   .private_value = AD1848_MIXVAL_SINGLE(reg, shift, mask, invert) }
 
+#define AD1848_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv) \
+{ .name = xname, \
+  .index = xindex, \
+  .type = AD1848_MIX_SINGLE, \
+  .private_value = AD1848_MIXVAL_SINGLE(reg, shift, mask, invert), \
+  .tlv = xtlv }
+
 #define AD1848_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
 { .name = xname, \
   .index = xindex, \
   .type = AD1848_MIX_DOUBLE, \
   .private_value = AD1848_MIXVAL_DOUBLE(left_reg, right_reg, shift_left, shift_right, mask, invert) }
 
-static inline int snd_ad1848_add_ctl_elem(struct snd_ad1848 *chip, const struct ad1848_mix_elem *c)
-{
-	return snd_ad1848_add_ctl(chip, c->name, c->index, c->type, c->private_value);
-}
+#define AD1848_DOUBLE_TLV(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert, xtlv) \
+{ .name = xname, \
+  .index = xindex, \
+  .type = AD1848_MIX_DOUBLE, \
+  .private_value = AD1848_MIXVAL_DOUBLE(left_reg, right_reg, shift_left, shift_right, mask, invert), \
+  .tlv = xtlv }
+
+int snd_ad1848_add_ctl_elem(struct snd_ad1848 *chip, const struct ad1848_mix_elem *c);
 
 #endif /* __SOUND_AD1848_H */
--- linux-2.6.18.noarch/include/sound/ac97_codec.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/ac97_codec.h	2007-06-05 17:35:15.000000000 -0400
@@ -27,6 +27,7 @@
 
 #include <linux/bitops.h>
 #include <linux/device.h>
+#include <linux/workqueue.h>
 #include "pcm.h"
 #include "control.h"
 #include "info.h"
@@ -140,6 +141,20 @@
 #define AC97_GP_DRSS_1011	0x0000	/* LR(C) 10+11(+12) */
 #define AC97_GP_DRSS_78		0x0400	/* LR 7+8 */
 
+/* powerdown bits */
+#define AC97_PD_ADC_STATUS	0x0001	/* ADC status (RO) */
+#define AC97_PD_DAC_STATUS	0x0002	/* DAC status (RO) */
+#define AC97_PD_MIXER_STATUS	0x0004	/* Analog mixer status (RO) */
+#define AC97_PD_VREF_STATUS	0x0008	/* Vref status (RO) */
+#define AC97_PD_PR0		0x0100	/* Power down PCM ADCs and input MUX */
+#define AC97_PD_PR1		0x0200	/* Power down PCM front DAC */
+#define AC97_PD_PR2		0x0400	/* Power down Mixer (Vref still on) */
+#define AC97_PD_PR3		0x0800	/* Power down Mixer (Vref off) */
+#define AC97_PD_PR4		0x1000	/* Power down AC-Link */
+#define AC97_PD_PR5		0x2000	/* Disable internal clock usage */
+#define AC97_PD_PR6		0x4000	/* Headphone amplifier */
+#define AC97_PD_EAPD		0x8000	/* External Amplifer Power Down (EAPD) */
+
 /* extended audio ID bit defines */
 #define AC97_EI_VRA		0x0001	/* Variable bit rate supported */
 #define AC97_EI_DRA		0x0002	/* Double rate supported */
@@ -359,6 +374,8 @@
 #define AC97_SCAP_INV_EAPD	(1<<7)	/* inverted EAPD */
 #define AC97_SCAP_DETECT_BY_VENDOR (1<<8) /* use vendor registers for read tests */
 #define AC97_SCAP_NO_SPDIF	(1<<9)	/* don't build SPDIF controls */
+#define AC97_SCAP_EAPD_LED	(1<<10)	/* EAPD as mute LED */
+#define AC97_SCAP_POWER_SAVE	(1<<11)	/* capable for aggresive power-saving */
 
 /* ac97->flags */
 #define AC97_HAS_PC_BEEP	(1<<0)	/* force PC Speaker usage */
@@ -409,6 +426,7 @@
 
 struct snd_ac97_bus_ops {
 	void (*reset) (struct snd_ac97 *ac97);
+	void (*warm_reset)(struct snd_ac97 *ac97);
 	void (*write) (struct snd_ac97 *ac97, unsigned short reg, unsigned short val);
 	unsigned short (*read) (struct snd_ac97 *ac97, unsigned short reg);
 	void (*wait) (struct snd_ac97 *ac97);
@@ -485,6 +503,7 @@
 			unsigned short id[3];		// codec IDs (lower 16-bit word)
 			unsigned short pcmreg[3];	// PCM registers
 			unsigned short codec_cfg[3];	// CODEC_CFG bits
+			unsigned char swap_mic_linein;	// AD1986/AD1986A only
 		} ad18xx;
 		unsigned int dev_flags;		/* device specific */
 	} spec;
@@ -532,6 +551,15 @@
 void snd_ac97_write_cache(struct snd_ac97 *ac97, unsigned short reg, unsigned short value);
 int snd_ac97_update(struct snd_ac97 *ac97, unsigned short reg, unsigned short value);
 int snd_ac97_update_bits(struct snd_ac97 *ac97, unsigned short reg, unsigned short mask, unsigned short value);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+int snd_ac97_update_power(struct snd_ac97 *ac97, int reg, int powerup);
+#else
+static inline int snd_ac97_update_power(struct snd_ac97 *ac97, int reg,
+					int powerup)
+{
+	return 0;
+}
+#endif
 #ifdef CONFIG_PM
 void snd_ac97_suspend(struct snd_ac97 *ac97);
 void snd_ac97_resume(struct snd_ac97 *ac97);
@@ -583,6 +611,7 @@
 		     copy_flag: 1,	   /* lowlevel driver must fill all entries */
 		     spdif: 1;		   /* spdif pcm */
 	unsigned short aslots;		   /* active slots */
+	unsigned short cur_dbl;		   /* current double-rate state */
 	unsigned int rates;		   /* available rates */
 	struct {
 		unsigned short slots;	   /* driver input: requested AC97 slot numbers */
--- linux-2.6.18.noarch/include/sound/version.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/version.h	2007-06-05 17:35:15.000000000 -0400
@@ -1,3 +1,3 @@
-/* include/version.h.  Generated by configure.  */
-#define CONFIG_SND_VERSION "1.0.12rc1"
-#define CONFIG_SND_DATE " (Thu Jun 22 13:55:50 2006 UTC)"
+/* include/version.h.  Generated by alsa/ksync script.  */
+#define CONFIG_SND_VERSION "1.0.14rc3"
+#define CONFIG_SND_DATE " (Wed Mar 14 07:25:50 2007 UTC)"
--- linux-2.6.18.noarch/include/sound/info.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/info.h	2007-06-05 17:35:15.000000000 -0400
@@ -71,7 +71,6 @@
 	mode_t mode;
 	long size;
 	unsigned short content;
-	unsigned short disconnected: 1;
 	union {
 		struct snd_info_entry_text text;
 		struct snd_info_entry_ops *ops;
@@ -83,6 +82,8 @@
 	void (*private_free)(struct snd_info_entry *entry);
 	struct proc_dir_entry *p;
 	struct mutex access;
+	struct list_head children;
+	struct list_head list;
 };
 
 #if defined(CONFIG_SND_OSSEMUL) && defined(CONFIG_PROC_FS)
@@ -122,8 +123,8 @@
 int snd_info_card_create(struct snd_card * card);
 int snd_info_card_register(struct snd_card * card);
 int snd_info_card_free(struct snd_card * card);
+void snd_info_card_disconnect(struct snd_card * card);
 int snd_info_register(struct snd_info_entry * entry);
-int snd_info_unregister(struct snd_info_entry * entry);
 
 /* for card drivers */
 int snd_card_proc_new(struct snd_card *card, const char *name, struct snd_info_entry **entryp);
@@ -156,8 +157,8 @@
 static inline int snd_info_card_create(struct snd_card * card) { return 0; }
 static inline int snd_info_card_register(struct snd_card * card) { return 0; }
 static inline int snd_info_card_free(struct snd_card * card) { return 0; }
+static inline void snd_info_card_disconnect(struct snd_card * card) { }
 static inline int snd_info_register(struct snd_info_entry * entry) { return 0; }
-static inline int snd_info_unregister(struct snd_info_entry * entry) { return 0; }
 
 static inline int snd_card_proc_new(struct snd_card *card, const char *name,
 				    struct snd_info_entry **entryp) { return -EINVAL; }
--- linux-2.6.18.noarch/include/sound/emu10k1.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/emu10k1.h	2007-06-05 23:20:27.000000000 -0400
@@ -188,7 +188,35 @@
 #define HCFG_LEGACYINT		0x00200000	/* 1 = legacy event captured. Write 1 to clear.	*/
 						/* NOTE: The rest of the bits in this register	*/
 						/* _are_ relevant under Linux.			*/
-#define HCFG_CODECFORMAT_MASK	0x00070000	/* CODEC format					*/
+#define HCFG_PUSH_BUTTON_ENABLE 0x00100000	/* Enables Volume Inc/Dec and Mute functions    */
+#define HCFG_BAUD_RATE		0x00080000	/* 0 = 48kHz, 1 = 44.1kHz			*/
+#define HCFG_EXPANDED_MEM	0x00040000	/* 1 = any 16M of 4G addr, 0 = 32M of 2G addr	*/
+#define HCFG_CODECFORMAT_MASK	0x00030000	/* CODEC format					*/
+
+/* Specific to Alice2, CA0102 */
+#define HCFG_CODECFORMAT_AC97_1	0x00000000	/* AC97 CODEC format -- Ver 1.03		*/
+#define HCFG_CODECFORMAT_AC97_2	0x00010000	/* AC97 CODEC format -- Ver 2.1			*/
+#define HCFG_AUTOMUTE_ASYNC	0x00008000	/* When set, the async sample rate convertors	*/
+						/* will automatically mute their output when	*/
+						/* they are not rate-locked to the external	*/
+						/* async audio source  				*/
+#define HCFG_AUTOMUTE_SPDIF	0x00004000	/* When set, the async sample rate convertors	*/
+						/* will automatically mute their output when	*/
+						/* the SPDIF V-bit indicates invalid audio	*/
+#define HCFG_EMU32_SLAVE	0x00002000	/* 0 = Master, 1 = Slave. Slave for EMU1010	*/
+#define HCFG_SLOW_RAMP		0x00001000	/* Increases Send Smoothing time constant	*/
+/* 0x00000800 not used on Alice2 */
+#define HCFG_PHASE_TRACK_MASK	0x00000700	/* When set, forces corresponding input to	*/
+						/* phase track the previous input.		*/
+						/* I2S0 can phase track the last S/PDIF input	*/
+#define HCFG_I2S_ASRC_ENABLE	0x00000070	/* When set, enables asynchronous sample rate   */
+						/* conversion for the corresponding		*/
+ 						/* I2S format input				*/
+/* Rest of HCFG 0x0000000f same as below. LOCKSOUNDCACHE etc.  */
+
+
+
+/* Older chips */
 #define HCFG_CODECFORMAT_AC97	0x00000000	/* AC97 CODEC format -- Primary Output		*/
 #define HCFG_CODECFORMAT_I2S	0x00010000	/* I2S CODEC format -- Secondary (Rear) Output	*/
 #define HCFG_GPINPUT0		0x00004000	/* External pin112				*/
@@ -432,6 +460,7 @@
 #define FXRT_CHANNELC		0x0f000000	/* Effects send bus number for channel's effects send C	*/
 #define FXRT_CHANNELD		0xf0000000	/* Effects send bus number for channel's effects send D	*/
 
+#define A_HR			0x0b	/* High Resolution. 24bit playback from host to DSP. */
 #define MAPA			0x0c		/* Cache map A						*/
 
 #define MAPB			0x0d		/* Cache map B						*/
@@ -439,6 +468,8 @@
 #define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/
 #define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/
 
+/* 0x0e, 0x0f: Not used */
+
 #define ENVVOL			0x10		/* Volume envelope register				*/
 #define ENVVOL_MASK		0x0000ffff	/* Current value of volume envelope state variable	*/  
 						/* 0x8000-n == 666*n usec delay	       			*/
@@ -527,7 +558,7 @@
 						/* NOTE: All channels contain internal variables; do	*/
 						/* not write to these locations.			*/
 
-/* 1f something */
+/* 0x1f: not used */
 
 #define CD0			0x20		/* Cache data 0 register				*/
 #define CD1			0x21		/* Cache data 1 register				*/
@@ -597,6 +628,8 @@
 #define FXWC_SPDIFLEFT          (1<<22)		/* 0x00400000 */
 #define FXWC_SPDIFRIGHT         (1<<23)		/* 0x00800000 */
 
+#define A_TBLSZ			0x43	/* Effects Tank Internal Table Size. Only low byte or register used */
+
 #define TCBS			0x44		/* Tank cache buffer size register			*/
 #define TCBS_MASK		0x00000007	/* Tank cache buffer size field				*/
 #define TCBS_BUFFSIZE_16K	0x00000000
@@ -617,7 +650,7 @@
 #define FXBA			0x47		/* FX Buffer Address */
 #define FXBA_MASK		0xfffff000	/* 20 bit base address					*/
 
-/* 0x48 something - word access, defaults to 3f */
+#define A_HWM			0x48	/* High PCI Water Mark - word access, defaults to 3f */
 
 #define MICBS			0x49		/* Microphone buffer size register			*/
 
@@ -661,6 +694,18 @@
 #define ADCBS_BUFSIZE_57344	0x0000001e
 #define ADCBS_BUFSIZE_65536	0x0000001f
 
+/* Current Send B, A Amounts */
+#define A_CSBA			0x4c
+
+/* Current Send D, C Amounts */
+#define A_CSDC			0x4d
+
+/* Current Send F, E Amounts */
+#define A_CSFE			0x4e
+
+/* Current Send H, G Amounts */
+#define A_CSHG			0x4f
+
 
 #define CDCS			0x50		/* CD-ROM digital channel status register	*/
 
@@ -668,6 +713,9 @@
 
 #define DBG			0x52		/* DO NOT PROGRAM THIS REGISTER!!! MAY DESTROY CHIP */
 
+/* S/PDIF Input C Channel Status */
+#define A_SPSC			0x52
+
 #define REG53			0x53		/* DO NOT PROGRAM THIS REGISTER!!! MAY DESTROY CHIP */
 
 #define A_DBG			 0x53
@@ -708,6 +756,8 @@
 #define SPCS_NOTAUDIODATA	0x00000002	/* 0 = Digital audio, 1 = not audio		*/
 #define SPCS_PROFESSIONAL	0x00000001	/* 0 = Consumer (IEC-958), 1 = pro (AES3-1992)	*/
 
+/* 0x57: Not used */
+
 /* The 32-bit CLIx and SOLx registers all have one bit per channel control/status      		*/
 #define CLIEL			0x58		/* Channel loop interrupt enable low register	*/
 
@@ -733,6 +783,9 @@
 #define AC97SLOT_CNTR		0x10            /* Center enable */
 #define AC97SLOT_LFE		0x20            /* LFE enable */
 
+/* PCB Revision */
+#define A_PCB			0x5f
+
 // NOTE: 0x60,61,62: 64-bit
 #define CDSRCS			0x60		/* CD-ROM Sample Rate Converter status register	*/
 
@@ -780,9 +833,18 @@
 
 #define HLIPH			0x69		/* Channel half loop interrupt pending high register	*/
 
-// 0x6a,6b,6c used for some recording
-// 0x6d unused
-// 0x6e,6f - tanktable base / offset
+/* S/PDIF Host Record Index (bypasses SRC) */
+#define A_SPRI			0x6a
+/* S/PDIF Host Record Address */
+#define A_SPRA			0x6b
+/* S/PDIF Host Record Control */
+#define A_SPRC			0x6c
+/* Delayed Interrupt Counter & Enable */
+#define A_DICE			0x6d
+/* Tank Table Base */
+#define A_TTB			0x6e
+/* Tank Delay Offset */
+#define A_TDOF			0x6f
 
 /* This is the MPU port on the card (via the game port)						*/
 #define A_MUDATA1		0x70
@@ -800,6 +862,7 @@
 #define A_FXWC1			0x74            /* Selects 0x7f-0x60 for FX recording           */
 #define A_FXWC2			0x75		/* Selects 0x9f-0x80 for FX recording           */
 
+/* Extended Hardware Control */
 #define A_SPDIF_SAMPLERATE	0x76		/* Set the sample rate of SPDIF output		*/
 #define A_SAMPLE_RATE		0x76		/* Various sample rate settings. */
 #define A_SAMPLE_RATE_NOT_USED  0x0ffc111e	/* Bits that are not used and cannot be set. 	*/
@@ -822,8 +885,20 @@
 #define A_PCM_96000		0x00004000
 #define A_PCM_44100		0x00008000
 
-/* 0x77,0x78,0x79 "something i2s-related" - default to 0x01080000 on my audigy 2 ZS --rlrevell	*/
-/* 0x7a, 0x7b - lookup tables */
+/* I2S0 Sample Rate Tracker Status */
+#define A_SRT3			0x77
+
+/* I2S1 Sample Rate Tracker Status */
+#define A_SRT4			0x78
+
+/* I2S2 Sample Rate Tracker Status */
+#define A_SRT5			0x79
+/* - default to 0x01080000 on my audigy 2 ZS --rlrevell	*/
+
+/* Tank Table DMA Address */
+#define A_TTDA			0x7a
+/* Tank Table DMA Data */
+#define A_TTDD			0x7b
 
 #define A_FXRT2			0x7c
 #define A_FXRT_CHANNELE		0x0000003f	/* Effects send bus number for channel's effects send E	*/
@@ -845,7 +920,7 @@
 #define A_FXRT_CHANNELC		0x003f0000
 #define A_FXRT_CHANNELD		0x3f000000
 
-
+/* 0x7f: Not used */
 /* Each FX general purpose register is 32 bits in length, all bits are used			*/
 #define FXGPREGBASE		0x100		/* FX general purpose registers base       	*/
 #define A_FXGPREGBASE		0x400		/* Audigy GPRs, 0x400 to 0x5ff			*/
@@ -886,6 +961,293 @@
 #define A_HIWORD_RESULT_MASK	0x007ff000
 #define A_HIWORD_OPA_MASK	0x000007ff
 
+/************************************************************************************************/
+/* EMU1010m HANA FPGA registers									*/
+/************************************************************************************************/
+#define EMU_HANA_DESTHI		0x00	/* 0000xxx  3 bits Link Destination */
+#define EMU_HANA_DESTLO		0x01	/* 00xxxxx  5 bits */
+#define EMU_HANA_SRCHI		0x02	/* 0000xxx  3 bits Link Source */
+#define EMU_HANA_SRCLO		0x03	/* 00xxxxx  5 bits */
+#define EMU_HANA_DOCK_PWR	0x04	/* 000000x  1 bits Audio Dock power */
+#define EMU_HANA_DOCK_PWR_ON		0x01 /* Audio Dock power on */
+#define EMU_HANA_WCLOCK		0x05	/* 0000xxx  3 bits Word Clock source select  */
+					/* Must be written after power on to reset DLL */
+					/* One is unable to detect the Audio dock without this */
+#define EMU_HANA_WCLOCK_SRC_MASK	0x07
+#define EMU_HANA_WCLOCK_INT_48K		0x00
+#define EMU_HANA_WCLOCK_INT_44_1K	0x01
+#define EMU_HANA_WCLOCK_HANA_SPDIF_IN	0x02
+#define EMU_HANA_WCLOCK_HANA_ADAT_IN	0x03
+#define EMU_HANA_WCLOCK_SYNC_BNCN	0x04
+#define EMU_HANA_WCLOCK_2ND_HANA	0x05
+#define EMU_HANA_WCLOCK_SRC_RESERVED	0x06
+#define EMU_HANA_WCLOCK_OFF		0x07 /* For testing, forces fallback to DEFCLOCK */
+#define EMU_HANA_WCLOCK_MULT_MASK	0x18
+#define EMU_HANA_WCLOCK_1X		0x00
+#define EMU_HANA_WCLOCK_2X		0x08
+#define EMU_HANA_WCLOCK_4X		0x10
+#define EMU_HANA_WCLOCK_MULT_RESERVED	0x18
+
+#define EMU_HANA_DEFCLOCK	0x06	/* 000000x  1 bits Default Word Clock  */
+#define EMU_HANA_DEFCLOCK_48K		0x00
+#define EMU_HANA_DEFCLOCK_44_1K		0x01
+
+#define EMU_HANA_UNMUTE		0x07	/* 000000x  1 bits Mute all audio outputs  */
+#define EMU_MUTE			0x00
+#define EMU_UNMUTE			0x01
+
+#define EMU_HANA_FPGA_CONFIG	0x08	/* 00000xx  2 bits Config control of FPGAs  */
+#define EMU_HANA_FPGA_CONFIG_AUDIODOCK	0x01 /* Set in order to program FPGA on Audio Dock */
+#define EMU_HANA_FPGA_CONFIG_HANA	0x02 /* Set in order to program FPGA on Hana */
+
+#define EMU_HANA_IRQ_ENABLE	0x09	/* 000xxxx  4 bits IRQ Enable  */
+#define EMU_HANA_IRQ_WCLK_CHANGED	0x01
+#define EMU_HANA_IRQ_ADAT		0x02
+#define EMU_HANA_IRQ_DOCK		0x04
+#define EMU_HANA_IRQ_DOCK_LOST		0x08
+
+#define EMU_HANA_SPDIF_MODE	0x0a	/* 00xxxxx  5 bits SPDIF MODE  */
+#define EMU_HANA_SPDIF_MODE_TX_COMSUMER	0x00
+#define EMU_HANA_SPDIF_MODE_TX_PRO	0x01
+#define EMU_HANA_SPDIF_MODE_TX_NOCOPY	0x02
+#define EMU_HANA_SPDIF_MODE_RX_COMSUMER	0x00
+#define EMU_HANA_SPDIF_MODE_RX_PRO	0x04
+#define EMU_HANA_SPDIF_MODE_RX_NOCOPY	0x08
+#define EMU_HANA_SPDIF_MODE_RX_INVALID	0x10
+
+#define EMU_HANA_OPTICAL_TYPE	0x0b	/* 00000xx  2 bits ADAT or SPDIF in/out  */
+#define EMU_HANA_OPTICAL_IN_SPDIF	0x00
+#define EMU_HANA_OPTICAL_IN_ADAT	0x01
+#define EMU_HANA_OPTICAL_OUT_SPDIF	0x00
+#define EMU_HANA_OPTICAL_OUT_ADAT	0x02
+
+#define EMU_HANA_MIDI_IN		0x0c	/* 000000x  1 bit  Control MIDI  */
+#define EMU_HANA_MIDI_IN_FROM_HAMOA	0x00 /* HAMOA MIDI in to Alice 2 MIDI B */
+#define EMU_HANA_MIDI_IN_FROM_DOCK	0x01 /* Audio Dock MIDI in to Alice 2 MIDI B */
+
+#define EMU_HANA_DOCK_LEDS_1	0x0d	/* 000xxxx  4 bit  Audio Dock LEDs  */
+#define EMU_HANA_DOCK_LEDS_1_MIDI1	0x01	/* MIDI 1 LED on */
+#define EMU_HANA_DOCK_LEDS_1_MIDI2	0x02	/* MIDI 2 LED on */
+#define EMU_HANA_DOCK_LEDS_1_SMPTE_IN	0x04	/* SMPTE IN LED on */
+#define EMU_HANA_DOCK_LEDS_1_SMPTE_OUT	0x08	/* SMPTE OUT LED on */
+
+#define EMU_HANA_DOCK_LEDS_2	0x0e	/* 0xxxxxx  6 bit  Audio Dock LEDs  */
+#define EMU_HANA_DOCK_LEDS_2_44K	0x01	/* 44.1 kHz LED on */
+#define EMU_HANA_DOCK_LEDS_2_48K	0x02	/* 48 kHz LED on */
+#define EMU_HANA_DOCK_LEDS_2_96K	0x04	/* 96 kHz LED on */
+#define EMU_HANA_DOCK_LEDS_2_192K	0x08	/* 192 kHz LED on */
+#define EMU_HANA_DOCK_LEDS_2_LOCK	0x10	/* LOCK LED on */
+#define EMU_HANA_DOCK_LEDS_2_EXT	0x20	/* EXT LED on */
+
+#define EMU_HANA_DOCK_LEDS_3	0x0f	/* 0xxxxxx  6 bit  Audio Dock LEDs  */
+#define EMU_HANA_DOCK_LEDS_3_CLIP_A	0x01	/* Mic A Clip LED on */
+#define EMU_HANA_DOCK_LEDS_3_CLIP_B	0x02	/* Mic B Clip LED on */
+#define EMU_HANA_DOCK_LEDS_3_SIGNAL_A	0x04	/* Signal A Clip LED on */
+#define EMU_HANA_DOCK_LEDS_3_SIGNAL_B	0x08	/* Signal B Clip LED on */
+#define EMU_HANA_DOCK_LEDS_3_MANUAL_CLIP	0x10	/* Manual Clip detection */
+#define EMU_HANA_DOCK_LEDS_3_MANUAL_SIGNAL	0x20	/* Manual Signal detection */
+
+#define EMU_HANA_ADC_PADS	0x10	/* 0000xxx  3 bit  Audio Dock ADC 14dB pads */
+#define EMU_HANA_DOCK_ADC_PAD1	0x01	/* 14dB Attenuation on Audio Dock ADC 1 */
+#define EMU_HANA_DOCK_ADC_PAD2	0x02	/* 14dB Attenuation on Audio Dock ADC 2 */
+#define EMU_HANA_DOCK_ADC_PAD3	0x04	/* 14dB Attenuation on Audio Dock ADC 3 */
+#define EMU_HANA_0202_ADC_PAD1	0x08	/* 14dB Attenuation on 0202 ADC 1 */
+
+#define EMU_HANA_DOCK_MISC	0x11	/* 0xxxxxx  6 bit  Audio Dock misc bits */
+#define EMU_HANA_DOCK_DAC1_MUTE	0x01	/* DAC 1 Mute */
+#define EMU_HANA_DOCK_DAC2_MUTE	0x02	/* DAC 2 Mute */
+#define EMU_HANA_DOCK_DAC3_MUTE	0x04	/* DAC 3 Mute */
+#define EMU_HANA_DOCK_DAC4_MUTE	0x08	/* DAC 4 Mute */
+#define EMU_HANA_DOCK_PHONES_192_DAC1	0x00	/* DAC 1 Headphones source at 192kHz */
+#define EMU_HANA_DOCK_PHONES_192_DAC2	0x10	/* DAC 2 Headphones source at 192kHz */
+#define EMU_HANA_DOCK_PHONES_192_DAC3	0x20	/* DAC 3 Headphones source at 192kHz */
+#define EMU_HANA_DOCK_PHONES_192_DAC4	0x30	/* DAC 4 Headphones source at 192kHz */
+
+#define EMU_HANA_MIDI_OUT	0x12	/* 00xxxxx  5 bit  Source for each MIDI out port */
+#define EMU_HANA_MIDI_OUT_0202	0x01 /* 0202 MIDI from Alice 2. 0 = A, 1 = B */
+#define EMU_HANA_MIDI_OUT_DOCK1	0x02 /* Audio Dock MIDI1 front, from Alice 2. 0 = A, 1 = B */
+#define EMU_HANA_MIDI_OUT_DOCK2	0x04 /* Audio Dock MIDI2 rear, from Alice 2. 0 = A, 1 = B */
+#define EMU_HANA_MIDI_OUT_SYNC2	0x08 /* Sync card. Not the actual MIDI out jack. 0 = A, 1 = B */
+#define EMU_HANA_MIDI_OUT_LOOP	0x10 /* 0 = bits (3:0) normal. 1 = MIDI loopback enabled. */
+
+#define EMU_HANA_DAC_PADS	0x13	/* 00xxxxx  5 bit  DAC 14dB attenuation pads */
+#define EMU_HANA_DOCK_DAC_PAD1	0x01	/* 14dB Attenuation on AudioDock DAC 1. Left and Right */
+#define EMU_HANA_DOCK_DAC_PAD2	0x02	/* 14dB Attenuation on AudioDock DAC 2. Left and Right */
+#define EMU_HANA_DOCK_DAC_PAD3	0x04	/* 14dB Attenuation on AudioDock DAC 3. Left and Right */
+#define EMU_HANA_DOCK_DAC_PAD4	0x08	/* 14dB Attenuation on AudioDock DAC 4. Left and Right */
+#define EMU_HANA_0202_DAC_PAD1	0x10	/* 14dB Attenuation on 0202 DAC 1. Left and Right */
+
+/* 0x14 - 0x1f Unused R/W registers */
+#define EMU_HANA_IRQ_STATUS	0x20	/* 000xxxx  4 bits IRQ Status  */
+#if 0  /* Already defined for reg 0x09 IRQ_ENABLE */
+#define EMU_HANA_IRQ_WCLK_CHANGED	0x01
+#define EMU_HANA_IRQ_ADAT		0x02
+#define EMU_HANA_IRQ_DOCK		0x04
+#define EMU_HANA_IRQ_DOCK_LOST		0x08
+#endif
+
+#define EMU_HANA_OPTION_CARDS	0x21	/* 000xxxx  4 bits Presence of option cards */
+#define EMU_HANA_OPTION_HAMOA	0x01	/* HAMOA card present */
+#define EMU_HANA_OPTION_SYNC	0x02	/* Sync card present */
+#define EMU_HANA_OPTION_DOCK_ONLINE	0x04	/* Audio Dock online and FPGA configured */
+#define EMU_HANA_OPTION_DOCK_OFFLINE	0x08	/* Audio Dock online and FPGA not configured */
+
+#define EMU_HANA_ID		0x22	/* 1010101  7 bits ID byte & 0x7f = 0x55 */
+
+#define EMU_HANA_MAJOR_REV	0x23	/* 0000xxx  3 bit  Hana FPGA Major rev */
+#define EMU_HANA_MINOR_REV	0x24	/* 0000xxx  3 bit  Hana FPGA Minor rev */
+
+#define EMU_DOCK_MAJOR_REV	0x25	/* 0000xxx  3 bit  Audio Dock FPGA Major rev */
+#define EMU_DOCK_MINOR_REV	0x26	/* 0000xxx  3 bit  Audio Dock FPGA Minor rev */
+
+#define EMU_DOCK_BOARD_ID	0x27	/* 00000xx  2 bits Audio Dock ID pins */
+#define EMU_DOCK_BOARD_ID0	0x00	/* ID bit 0 */
+#define EMU_DOCK_BOARD_ID1	0x03	/* ID bit 1 */
+
+#define EMU_HANA_WC_SPDIF_HI	0x28	/* 0xxxxxx  6 bit  SPDIF IN Word clock, upper 6 bits */
+#define EMU_HANA_WC_SPDIF_LO	0x29	/* 0xxxxxx  6 bit  SPDIF IN Word clock, lower 6 bits */
+
+#define EMU_HANA_WC_ADAT_HI	0x2a	/* 0xxxxxx  6 bit  ADAT IN Word clock, upper 6 bits */
+#define EMU_HANA_WC_ADAT_LO	0x2b	/* 0xxxxxx  6 bit  ADAT IN Word clock, lower 6 bits */
+
+#define EMU_HANA_WC_BNC_LO	0x2c	/* 0xxxxxx  6 bit  BNC IN Word clock, lower 6 bits */
+#define EMU_HANA_WC_BNC_HI	0x2d	/* 0xxxxxx  6 bit  BNC IN Word clock, upper 6 bits */
+
+#define EMU_HANA2_WC_SPDIF_HI	0x2e	/* 0xxxxxx  6 bit  HANA2 SPDIF IN Word clock, upper 6 bits */
+#define EMU_HANA2_WC_SPDIF_LO	0x2f	/* 0xxxxxx  6 bit  HANA2 SPDIF IN Word clock, lower 6 bits */
+/* 0x30 - 0x3f Unused Read only registers */
+
+/************************************************************************************************/
+/* EMU1010m HANA Destinations									*/
+/************************************************************************************************/
+#define EMU_DST_ALICE2_EMU32_0	0x000f	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_1	0x0000	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_2	0x0001	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_3	0x0002	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_4	0x0003	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_5	0x0004	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_6	0x0005	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_7	0x0006	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_8	0x0007	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_9	0x0008	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_A	0x0009	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_B	0x000a	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_C	0x000b	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_D	0x000c	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_E	0x000d	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_ALICE2_EMU32_F	0x000e	/* 16 EMU32 channels to Alice2 +0 to +0xf */
+#define EMU_DST_DOCK_DAC1_LEFT1	0x0100	/* Audio Dock DAC1 Left, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC1_LEFT2	0x0101	/* Audio Dock DAC1 Left, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC1_LEFT3	0x0102	/* Audio Dock DAC1 Left, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC1_LEFT4	0x0103	/* Audio Dock DAC1 Left, 4th or 192kHz */
+#define EMU_DST_DOCK_DAC1_RIGHT1	0x0104	/* Audio Dock DAC1 Right, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC1_RIGHT2	0x0105	/* Audio Dock DAC1 Right, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC1_RIGHT3	0x0106	/* Audio Dock DAC1 Right, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC1_RIGHT4	0x0107	/* Audio Dock DAC1 Right, 4th or 192kHz */
+#define EMU_DST_DOCK_DAC2_LEFT1	0x0108	/* Audio Dock DAC2 Left, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC2_LEFT2	0x0109	/* Audio Dock DAC2 Left, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC2_LEFT3	0x010a	/* Audio Dock DAC2 Left, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC2_LEFT4	0x010b	/* Audio Dock DAC2 Left, 4th or 192kHz */
+#define EMU_DST_DOCK_DAC2_RIGHT1	0x010c	/* Audio Dock DAC2 Right, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC2_RIGHT2	0x010d	/* Audio Dock DAC2 Right, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC2_RIGHT3	0x010e	/* Audio Dock DAC2 Right, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC2_RIGHT4	0x010f	/* Audio Dock DAC2 Right, 4th or 192kHz */
+#define EMU_DST_DOCK_DAC3_LEFT1	0x0110	/* Audio Dock DAC1 Left, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC3_LEFT2	0x0111	/* Audio Dock DAC1 Left, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC3_LEFT3	0x0112	/* Audio Dock DAC1 Left, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC3_LEFT4	0x0113	/* Audio Dock DAC1 Left, 4th or 192kHz */
+#define EMU_DST_DOCK_PHONES_LEFT1	0x0112	/* Audio Dock PHONES Left, 1st or 48kHz only */
+#define EMU_DST_DOCK_PHONES_LEFT2	0x0113	/* Audio Dock PHONES Left, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC3_RIGHT1	0x0114	/* Audio Dock DAC1 Right, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC3_RIGHT2	0x0115	/* Audio Dock DAC1 Right, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC3_RIGHT3	0x0116	/* Audio Dock DAC1 Right, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC3_RIGHT4	0x0117	/* Audio Dock DAC1 Right, 4th or 192kHz */
+#define EMU_DST_DOCK_PHONES_RIGHT1	0x0116	/* Audio Dock PHONES Right, 1st or 48kHz only */
+#define EMU_DST_DOCK_PHONES_RIGHT2	0x0117	/* Audio Dock PHONES Right, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC4_LEFT1	0x0118	/* Audio Dock DAC2 Left, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC4_LEFT2	0x0119	/* Audio Dock DAC2 Left, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC4_LEFT3	0x011a	/* Audio Dock DAC2 Left, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC4_LEFT4	0x011b	/* Audio Dock DAC2 Left, 4th or 192kHz */
+#define EMU_DST_DOCK_SPDIF_LEFT1	0x011a	/* Audio Dock SPDIF Left, 1st or 48kHz only */
+#define EMU_DST_DOCK_SPDIF_LEFT2	0x011b	/* Audio Dock SPDIF Left, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC4_RIGHT1	0x011c	/* Audio Dock DAC2 Right, 1st or 48kHz only */
+#define EMU_DST_DOCK_DAC4_RIGHT2	0x011d	/* Audio Dock DAC2 Right, 2nd or 96kHz */
+#define EMU_DST_DOCK_DAC4_RIGHT3	0x011e	/* Audio Dock DAC2 Right, 3rd or 192kHz */
+#define EMU_DST_DOCK_DAC4_RIGHT4	0x011f	/* Audio Dock DAC2 Right, 4th or 192kHz */
+#define EMU_DST_DOCK_SPDIF_RIGHT1	0x011e	/* Audio Dock SPDIF Right, 1st or 48kHz only */
+#define EMU_DST_DOCK_SPDIF_RIGHT2	0x011f	/* Audio Dock SPDIF Right, 2nd or 96kHz */
+#define EMU_DST_HANA_SPDIF_LEFT1	0x0200	/* Hana SPDIF Left, 1st or 48kHz only */
+#define EMU_DST_HANA_SPDIF_LEFT2	0x0202	/* Hana SPDIF Left, 2nd or 96kHz */
+#define EMU_DST_HANA_SPDIF_RIGHT1	0x0201	/* Hana SPDIF Right, 1st or 48kHz only */
+#define EMU_DST_HANA_SPDIF_RIGHT2	0x0203	/* Hana SPDIF Right, 2nd or 96kHz */
+#define EMU_DST_HAMOA_DAC_LEFT1	0x0300	/* Hamoa DAC Left, 1st or 48kHz only */
+#define EMU_DST_HAMOA_DAC_LEFT2	0x0302	/* Hamoa DAC Left, 2nd or 96kHz */
+#define EMU_DST_HAMOA_DAC_LEFT3	0x0304	/* Hamoa DAC Left, 3rd or 192kHz */
+#define EMU_DST_HAMOA_DAC_LEFT4	0x0306	/* Hamoa DAC Left, 4th or 192kHz */
+#define EMU_DST_HAMOA_DAC_RIGHT1	0x0301	/* Hamoa DAC Right, 1st or 48kHz only */
+#define EMU_DST_HAMOA_DAC_RIGHT2	0x0303	/* Hamoa DAC Right, 2nd or 96kHz */
+#define EMU_DST_HAMOA_DAC_RIGHT3	0x0305	/* Hamoa DAC Right, 3rd or 192kHz */
+#define EMU_DST_HAMOA_DAC_RIGHT4	0x0307	/* Hamoa DAC Right, 4th or 192kHz */
+#define EMU_DST_HANA_ADAT	0x0400	/* Hana ADAT 8 channel out +0 to +7 */
+#define EMU_DST_ALICE_I2S0_LEFT		0x0500	/* Alice2 I2S0 Left */
+#define EMU_DST_ALICE_I2S0_RIGHT	0x0501	/* Alice2 I2S0 Right */
+#define EMU_DST_ALICE_I2S1_LEFT		0x0600	/* Alice2 I2S1 Left */
+#define EMU_DST_ALICE_I2S1_RIGHT	0x0601	/* Alice2 I2S1 Right */
+#define EMU_DST_ALICE_I2S2_LEFT		0x0700	/* Alice2 I2S2 Left */
+#define EMU_DST_ALICE_I2S2_RIGHT	0x0701	/* Alice2 I2S2 Right */
+
+/************************************************************************************************/
+/* EMU1010m HANA Sources									*/
+/************************************************************************************************/
+#define EMU_SRC_SILENCE		0x0000	/* Silence */
+#define EMU_SRC_DOCK_MIC_A1	0x0100	/* Audio Dock Mic A, 1st or 48kHz only */
+#define EMU_SRC_DOCK_MIC_A2	0x0101	/* Audio Dock Mic A, 2nd or 96kHz */
+#define EMU_SRC_DOCK_MIC_A3	0x0102	/* Audio Dock Mic A, 3rd or 192kHz */
+#define EMU_SRC_DOCK_MIC_A4	0x0103	/* Audio Dock Mic A, 4th or 192kHz */
+#define EMU_SRC_DOCK_MIC_B1	0x0104	/* Audio Dock Mic B, 1st or 48kHz only */
+#define EMU_SRC_DOCK_MIC_B2	0x0105	/* Audio Dock Mic B, 2nd or 96kHz */
+#define EMU_SRC_DOCK_MIC_B3	0x0106	/* Audio Dock Mic B, 3rd or 192kHz */
+#define EMU_SRC_DOCK_MIC_B4	0x0107	/* Audio Dock Mic B, 4th or 192kHz */
+#define EMU_SRC_DOCK_ADC1_LEFT1	0x0108	/* Audio Dock ADC1 Left, 1st or 48kHz only */
+#define EMU_SRC_DOCK_ADC1_LEFT2	0x0109	/* Audio Dock ADC1 Left, 2nd or 96kHz */
+#define EMU_SRC_DOCK_ADC1_LEFT3	0x010a	/* Audio Dock ADC1 Left, 3rd or 192kHz */
+#define EMU_SRC_DOCK_ADC1_LEFT4	0x010b	/* Audio Dock ADC1 Left, 4th or 192kHz */
+#define EMU_SRC_DOCK_ADC1_RIGHT1	0x010c	/* Audio Dock ADC1 Right, 1st or 48kHz only */
+#define EMU_SRC_DOCK_ADC1_RIGHT2	0x010d	/* Audio Dock ADC1 Right, 2nd or 96kHz */
+#define EMU_SRC_DOCK_ADC1_RIGHT3	0x010e	/* Audio Dock ADC1 Right, 3rd or 192kHz */
+#define EMU_SRC_DOCK_ADC1_RIGHT4	0x010f	/* Audio Dock ADC1 Right, 4th or 192kHz */
+#define EMU_SRC_DOCK_ADC2_LEFT1	0x0110	/* Audio Dock ADC2 Left, 1st or 48kHz only */
+#define EMU_SRC_DOCK_ADC2_LEFT2	0x0111	/* Audio Dock ADC2 Left, 2nd or 96kHz */
+#define EMU_SRC_DOCK_ADC2_LEFT3	0x0112	/* Audio Dock ADC2 Left, 3rd or 192kHz */
+#define EMU_SRC_DOCK_ADC2_LEFT4	0x0113	/* Audio Dock ADC2 Left, 4th or 192kHz */
+#define EMU_SRC_DOCK_ADC2_RIGHT1	0x0114	/* Audio Dock ADC2 Right, 1st or 48kHz only */
+#define EMU_SRC_DOCK_ADC2_RIGHT2	0x0115	/* Audio Dock ADC2 Right, 2nd or 96kHz */
+#define EMU_SRC_DOCK_ADC2_RIGHT3	0x0116	/* Audio Dock ADC2 Right, 3rd or 192kHz */
+#define EMU_SRC_DOCK_ADC2_RIGHT4	0x0117	/* Audio Dock ADC2 Right, 4th or 192kHz */
+#define EMU_SRC_DOCK_ADC3_LEFT1	0x0118	/* Audio Dock ADC3 Left, 1st or 48kHz only */
+#define EMU_SRC_DOCK_ADC3_LEFT2	0x0119	/* Audio Dock ADC3 Left, 2nd or 96kHz */
+#define EMU_SRC_DOCK_ADC3_LEFT3	0x011a	/* Audio Dock ADC3 Left, 3rd or 192kHz */
+#define EMU_SRC_DOCK_ADC3_LEFT4	0x011b	/* Audio Dock ADC3 Left, 4th or 192kHz */
+#define EMU_SRC_DOCK_ADC3_RIGHT1	0x011c	/* Audio Dock ADC3 Right, 1st or 48kHz only */
+#define EMU_SRC_DOCK_ADC3_RIGHT2	0x011d	/* Audio Dock ADC3 Right, 2nd or 96kHz */
+#define EMU_SRC_DOCK_ADC3_RIGHT3	0x011e	/* Audio Dock ADC3 Right, 3rd or 192kHz */
+#define EMU_SRC_DOCK_ADC3_RIGHT4	0x011f	/* Audio Dock ADC3 Right, 4th or 192kHz */
+#define EMU_SRC_HAMOA_ADC_LEFT1	0x0200	/* Hamoa ADC Left, 1st or 48kHz only */
+#define EMU_SRC_HAMOA_ADC_LEFT2	0x0202	/* Hamoa ADC Left, 2nd or 96kHz */
+#define EMU_SRC_HAMOA_ADC_LEFT3	0x0204	/* Hamoa ADC Left, 3rd or 192kHz */
+#define EMU_SRC_HAMOA_ADC_LEFT4	0x0206	/* Hamoa ADC Left, 4th or 192kHz */
+#define EMU_SRC_HAMOA_ADC_RIGHT1	0x0201	/* Hamoa ADC Right, 1st or 48kHz only */
+#define EMU_SRC_HAMOA_ADC_RIGHT2	0x0203	/* Hamoa ADC Right, 2nd or 96kHz */
+#define EMU_SRC_HAMOA_ADC_RIGHT3	0x0205	/* Hamoa ADC Right, 3rd or 192kHz */
+#define EMU_SRC_HAMOA_ADC_RIGHT4	0x0207	/* Hamoa ADC Right, 4th or 192kHz */
+#define EMU_SRC_ALICE_EMU32A		0x0300	/* Alice2 EMU32a 16 outputs. +0 to +0xf */
+#define EMU_SRC_ALICE_EMU32B		0x0310	/* Alice2 EMU32b 16 outputs. +0 to +0xf */
+#define EMU_SRC_HANA_ADAT	0x0400	/* Hana ADAT 8 channel in +0 to +7 */
+#define EMU_SRC_HANA_SPDIF_LEFT1	0x0500	/* Hana SPDIF Left, 1st or 48kHz only */
+#define EMU_SRC_HANA_SPDIF_LEFT2	0x0502	/* Hana SPDIF Left, 2nd or 96kHz */
+#define EMU_SRC_HANA_SPDIF_RIGHT1	0x0501	/* Hana SPDIF Right, 1st or 48kHz only */
+#define EMU_SRC_HANA_SPDIF_RIGHT2	0x0503	/* Hana SPDIF Right, 2nd or 96kHz */
+/* 0x600 and 0x700 no used */
 
 /* ------------------- STRUCTURES -------------------- */
 
@@ -1063,7 +1425,7 @@
 	unsigned char spdif_bug;    /* Has Spdif phasing bug */
 	unsigned char ac97_chip;    /* Has an AC97 chip: 1 = mandatory, 2 = optional */
 	unsigned char ecard;        /* APS EEPROM */
-	unsigned char emu1212m;     /* EMU 1212m card */
+	unsigned char emu1010;     /* EMU 1010m card */
 	unsigned char spi_dac;      /* SPI interface for DAC */
 	unsigned char i2c_adc;      /* I2C interface for ADC */
 	unsigned char adc_1361t;    /* Use Philips 1361T ADC */
@@ -1072,6 +1434,14 @@
 	const char *id;		/* for backward compatibility - can be NULL if not needed */
 };
 
+struct snd_emu1010 {
+	unsigned int output_source[64];
+	unsigned int input_source[64];
+	unsigned int adc_pads; /* bit mask */
+	unsigned int dac_pads; /* bit mask */
+	unsigned int internal_clock; /* 44100 or 48000 */
+};
+
 struct snd_emu10k1 {
 	int irq;
 
@@ -1079,6 +1449,7 @@
 	unsigned int tos_link: 1,		/* tos link detected */
 		rear_ac97: 1,			/* rear channels are on AC'97 */
 		enable_ir: 1;
+	unsigned int support_tlv :1;
 	/* Contains profile of card capabilities */
 	const struct snd_emu_chip_details *card_capabilities;
 	unsigned int audigy;			/* is Audigy? */
@@ -1104,6 +1475,8 @@
 	spinlock_t memblk_lock;
 
 	unsigned int spdif_bits[3];		/* s/pdif out setup */
+	unsigned int i2c_capture_source;
+	u8 i2c_capture_volume[4][2];
 
 	struct snd_emu10k1_fx8010 fx8010;		/* FX8010 info */
 	int gpr_base;
@@ -1132,6 +1505,7 @@
 	int p16v_device_offset;
 	u32 p16v_capture_source;
 	u32 p16v_capture_channel;
+        struct snd_emu1010 emu1010;
 	struct snd_emu10k1_pcm_mixer pcm_mixer[32];
 	struct snd_emu10k1_pcm_mixer efx_pcm_mixer[NUM_EFX_PLAYBACK];
 	struct snd_kcontrol *ctl_send_routing;
@@ -1208,6 +1582,10 @@
 unsigned int snd_emu10k1_ptr20_read(struct snd_emu10k1 * emu, unsigned int reg, unsigned int chn);
 void snd_emu10k1_ptr20_write(struct snd_emu10k1 *emu, unsigned int reg, unsigned int chn, unsigned int data);
 int snd_emu10k1_spi_write(struct snd_emu10k1 * emu, unsigned int data);
+int snd_emu10k1_i2c_write(struct snd_emu10k1 *emu, u32 reg, u32 value);
+int snd_emu1010_fpga_write(struct snd_emu10k1 * emu, int reg, int value);
+int snd_emu1010_fpga_read(struct snd_emu10k1 * emu, int reg, int *value);
+int snd_emu1010_fpga_link_dst_src_write(struct snd_emu10k1 * emu, int dst, int src);
 unsigned int snd_emu10k1_efx_read(struct snd_emu10k1 *emu, unsigned int pc);
 void snd_emu10k1_intr_enable(struct snd_emu10k1 *emu, unsigned int intrenb);
 void snd_emu10k1_intr_disable(struct snd_emu10k1 *emu, unsigned int intrenb);
@@ -1525,6 +1903,19 @@
 	unsigned int min;		/* minimum range */
 	unsigned int max;		/* maximum range */
 	unsigned int translation;	/* translation type (EMU10K1_GPR_TRANSLATION*) */
+	const unsigned int *tlv;
+};
+
+/* old ABI without TLV support */
+struct snd_emu10k1_fx8010_control_old_gpr {
+	struct snd_ctl_elem_id id;
+	unsigned int vcount;
+	unsigned int count;
+	unsigned short gpr[32];
+	unsigned int value[32];
+	unsigned int min;
+	unsigned int max;
+	unsigned int translation;
 };
 
 struct snd_emu10k1_fx8010_code {
@@ -1575,6 +1966,8 @@
 	unsigned int res2;		/* reserved */
 };
 
+#define SNDRV_EMU10K1_VERSION		SNDRV_PROTOCOL_VERSION(1, 0, 1)
+
 #define SNDRV_EMU10K1_IOCTL_INFO	_IOR ('H', 0x10, struct snd_emu10k1_fx8010_info)
 #define SNDRV_EMU10K1_IOCTL_CODE_POKE	_IOW ('H', 0x11, struct snd_emu10k1_fx8010_code)
 #define SNDRV_EMU10K1_IOCTL_CODE_PEEK	_IOWR('H', 0x12, struct snd_emu10k1_fx8010_code)
@@ -1583,6 +1976,7 @@
 #define SNDRV_EMU10K1_IOCTL_TRAM_PEEK	_IOWR('H', 0x22, struct snd_emu10k1_fx8010_tram)
 #define SNDRV_EMU10K1_IOCTL_PCM_POKE	_IOW ('H', 0x30, struct snd_emu10k1_fx8010_pcm_rec)
 #define SNDRV_EMU10K1_IOCTL_PCM_PEEK	_IOWR('H', 0x31, struct snd_emu10k1_fx8010_pcm_rec)
+#define SNDRV_EMU10K1_IOCTL_PVERSION	_IOR ('H', 0x40, int)
 #define SNDRV_EMU10K1_IOCTL_STOP	_IO  ('H', 0x80)
 #define SNDRV_EMU10K1_IOCTL_CONTINUE	_IO  ('H', 0x81)
 #define SNDRV_EMU10K1_IOCTL_ZERO_TRAM_COUNTER _IO ('H', 0x82)
--- linux-2.6.18.noarch/include/sound/cs4231.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/cs4231.h	2007-06-05 17:35:15.000000000 -0400
@@ -273,7 +273,7 @@
 void snd_cs4231_mce_up(struct snd_cs4231 *chip);
 void snd_cs4231_mce_down(struct snd_cs4231 *chip);
 
-irqreturn_t snd_cs4231_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t snd_cs4231_interrupt(int irq, void *dev_id);
 
 const char *snd_cs4231_chip_id(struct snd_cs4231 *chip);
 
--- linux-2.6.18.noarch/include/sound/sb16_csp.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/sb16_csp.h	2007-06-05 17:35:15.000000000 -0400
@@ -114,9 +114,21 @@
 #ifdef __KERNEL__
 #include "sb.h"
 #include "hwdep.h"
+#include <linux/firmware.h>
 
 struct snd_sb_csp;
 
+/* indices for the known CSP programs */
+enum {
+	CSP_PROGRAM_MULAW,
+	CSP_PROGRAM_ALAW,
+	CSP_PROGRAM_ADPCM_INIT,
+	CSP_PROGRAM_ADPCM_PLAYBACK,
+	CSP_PROGRAM_ADPCM_CAPTURE,
+
+	CSP_PROGRAM_COUNT
+};
+
 /*
  * CSP operators
  */
@@ -159,6 +171,8 @@
 	struct snd_kcontrol *qsound_space;
 
 	struct mutex access_mutex;	/* locking */
+
+	const struct firmware *csp_programs[CSP_PROGRAM_COUNT];
 };
 
 int snd_sb_csp_new(struct snd_sb *chip, int device, struct snd_hwdep ** rhwdep);
--- linux-2.6.18.noarch/include/sound/vx_core.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/vx_core.h	2007-06-06 00:01:50.000000000 -0400
@@ -128,6 +128,7 @@
 	unsigned int num_ins;
 	unsigned int num_outs;
 	unsigned int output_level_max;
+	const unsigned int *output_level_db_scale;
 };
 
 /* hwdep id string */
--- linux-2.6.18.noarch/include/sound/soc.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/soc.h	2007-06-05 17:35:15.000000000 -0400
@@ -0,0 +1,461 @@
+/*
+ * linux/sound/soc.h -- ALSA SoC Layer
+ *
+ * Author:		Liam Girdwood
+ * Created:		Aug 11th 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_H
+#define __LINUX_SND_SOC_H
+
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/ac97_codec.h>
+
+#define SND_SOC_VERSION "0.13.0"
+
+/*
+ * Convenience kcontrol builders
+ */
+#define SOC_SINGLE_VALUE(reg,shift,mask,invert) ((reg) | ((shift) << 8) |\
+	((shift) << 12) | ((mask) << 16) | ((invert) << 24))
+#define SOC_SINGLE_VALUE_EXT(reg,mask,invert) ((reg) | ((mask) << 16) |\
+	((invert) << 31))
+#define SOC_SINGLE(xname, reg, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
+	.put = snd_soc_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, mask, invert) }
+#define SOC_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
+	.put = snd_soc_put_volsw, \
+	.private_value = (reg) | ((shift_left) << 8) | \
+		((shift_right) << 12) | ((mask) << 16) | ((invert) << 24) }
+#define SOC_DOUBLE_R(xname, reg_left, reg_right, shift, mask, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_volsw_2r, \
+	.private_value = (reg_left) | ((shift) << 8)  | \
+		((mask) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xtexts) \
+{	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
+	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM_SINGLE(xreg, xshift, xmask, xtexts) \
+	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xtexts)
+#define SOC_ENUM_SINGLE_EXT(xmask, xtexts) \
+{	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM(xname, xenum) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info = snd_soc_info_enum_double, \
+	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
+	.private_value = (unsigned long)&xenum }
+#define SOC_SINGLE_EXT(xname, xreg, xshift, xmask, xinvert,\
+	 xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmask, xinvert) }
+#define SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bool_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = xdata }
+#define SOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_enum_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&xenum }
+
+/*
+ * Digital Audio Interface (DAI) types
+ */
+#define SND_SOC_DAI_AC97	0x1
+#define SND_SOC_DAI_I2S		0x2
+#define SND_SOC_DAI_PCM		0x4
+
+/*
+ * DAI hardware audio formats
+ */
+#define SND_SOC_DAIFMT_I2S		0	/* I2S mode */
+#define SND_SOC_DAIFMT_RIGHT_J	1	/* Right justified mode */
+#define SND_SOC_DAIFMT_LEFT_J	2	/* Left Justified mode */
+#define SND_SOC_DAIFMT_DSP_A	3	/* L data msb after FRM or LRC */
+#define SND_SOC_DAIFMT_DSP_B	4	/* L data msb during FRM or LRC */
+#define SND_SOC_DAIFMT_AC97		5	/* AC97 */
+
+#define SND_SOC_DAIFMT_MSB 	SND_SOC_DAIFMT_LEFT_J
+#define SND_SOC_DAIFMT_LSB	SND_SOC_DAIFMT_RIGHT_J
+
+/*
+ * DAI Gating
+ */
+#define SND_SOC_DAIFMT_CONT			(0 << 4)	/* continuous clock */
+#define SND_SOC_DAIFMT_GATED		(1 << 4)	/* clock is gated when not Tx/Rx */
+
+/*
+ * DAI hardware signal inversions
+ */
+#define SND_SOC_DAIFMT_NB_NF		(0 << 8)	/* normal bit clock + frame */
+#define SND_SOC_DAIFMT_NB_IF		(1 << 8)	/* normal bclk + inv frm */
+#define SND_SOC_DAIFMT_IB_NF		(2 << 8)	/* invert bclk + nor frm */
+#define SND_SOC_DAIFMT_IB_IF		(3 << 8)	/* invert bclk + frm */
+
+/*
+ * DAI hardware clock masters
+ * This is wrt the codec, the inverse is true for the interface
+ * i.e. if the codec is clk and frm master then the interface is
+ * clk and frame slave.
+ */
+#define SND_SOC_DAIFMT_CBM_CFM	(0 << 12) /* codec clk & frm master */
+#define SND_SOC_DAIFMT_CBS_CFM	(1 << 12) /* codec clk slave & frm master */
+#define SND_SOC_DAIFMT_CBM_CFS	(2 << 12) /* codec clk master & frame slave */
+#define SND_SOC_DAIFMT_CBS_CFS	(3 << 12) /* codec clk & frm slave */
+
+#define SND_SOC_DAIFMT_FORMAT_MASK		0x000f
+#define SND_SOC_DAIFMT_CLOCK_MASK		0x00f0
+#define SND_SOC_DAIFMT_INV_MASK			0x0f00
+#define SND_SOC_DAIFMT_MASTER_MASK		0xf000
+
+
+/*
+ * Master Clock Directions
+ */
+#define SND_SOC_CLOCK_IN	0
+#define SND_SOC_CLOCK_OUT	1
+
+/*
+ * AC97 codec ID's bitmask
+ */
+#define SND_SOC_DAI_AC97_ID0	(1 << 0)
+#define SND_SOC_DAI_AC97_ID1	(1 << 1)
+#define SND_SOC_DAI_AC97_ID2	(1 << 2)
+#define SND_SOC_DAI_AC97_ID3	(1 << 3)
+
+struct snd_soc_device;
+struct snd_soc_pcm_stream;
+struct snd_soc_ops;
+struct snd_soc_dai_mode;
+struct snd_soc_pcm_runtime;
+struct snd_soc_codec_dai;
+struct snd_soc_cpu_dai;
+struct snd_soc_codec;
+struct snd_soc_machine_config;
+struct soc_enum;
+struct snd_soc_ac97_ops;
+struct snd_soc_clock_info;
+
+typedef int (*hw_write_t)(void *,const char* ,int);
+typedef int (*hw_read_t)(void *,char* ,int);
+
+extern struct snd_ac97_bus_ops soc_ac97_ops;
+
+/* pcm <-> DAI connect */
+void snd_soc_free_pcms(struct snd_soc_device *socdev);
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid);
+int snd_soc_register_card(struct snd_soc_device *socdev);
+
+/* set runtime hw params */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw);
+
+/* codec IO */
+#define snd_soc_read(codec, reg) codec->read(codec, reg)
+#define snd_soc_write(codec, reg, value) codec->write(codec, reg, value)
+
+/* codec register bit access */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value);
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value);
+
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num);
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec);
+
+/*
+ *Controls
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name);
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+
+/* SoC PCM stream information */
+struct snd_soc_pcm_stream {
+	char *stream_name;
+	u64 formats;			/* SNDRV_PCM_FMTBIT_* */
+	unsigned int rates;		/* SNDRV_PCM_RATE_* */
+	unsigned int rate_min;		/* min rate */
+	unsigned int rate_max;		/* max rate */
+	unsigned int channels_min;	/* min channels */
+	unsigned int channels_max;	/* max channels */
+	unsigned int active:1;		/* stream is in use */
+};
+
+/* SoC audio ops */
+struct snd_soc_ops {
+	int (*startup)(struct snd_pcm_substream *);
+	void (*shutdown)(struct snd_pcm_substream *);
+	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
+	int (*hw_free)(struct snd_pcm_substream *);
+	int (*prepare)(struct snd_pcm_substream *);
+	int (*trigger)(struct snd_pcm_substream *, int);
+};
+
+/* ASoC codec DAI ops */
+struct snd_soc_codec_ops {
+	/* codec DAI clocking configuration */
+	int (*set_sysclk)(struct snd_soc_codec_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir);
+	int (*set_pll)(struct snd_soc_codec_dai *codec_dai,
+		int pll_id, unsigned int freq_in, unsigned int freq_out);
+	int (*set_clkdiv)(struct snd_soc_codec_dai *codec_dai,
+		int div_id, int div);
+
+	/* CPU DAI format configuration */
+	int (*set_fmt)(struct snd_soc_codec_dai *codec_dai,
+		unsigned int fmt);
+	int (*set_tdm_slot)(struct snd_soc_codec_dai *codec_dai,
+		unsigned int mask, int slots);
+	int (*set_tristate)(struct snd_soc_codec_dai *, int tristate);
+
+	/* digital mute */
+	int (*digital_mute)(struct snd_soc_codec_dai *, int mute);
+};
+
+/* ASoC cpu DAI ops */
+struct snd_soc_cpu_ops {
+	/* CPU DAI clocking configuration */
+	int (*set_sysclk)(struct snd_soc_cpu_dai *cpu_dai,
+		int clk_id, unsigned int freq, int dir);
+	int (*set_clkdiv)(struct snd_soc_cpu_dai *cpu_dai,
+		int div_id, int div);
+	int (*set_pll)(struct snd_soc_cpu_dai *cpu_dai,
+		int pll_id, unsigned int freq_in, unsigned int freq_out);
+
+	/* CPU DAI format configuration */
+	int (*set_fmt)(struct snd_soc_cpu_dai *cpu_dai,
+		unsigned int fmt);
+	int (*set_tdm_slot)(struct snd_soc_cpu_dai *cpu_dai,
+		unsigned int mask, int slots);
+	int (*set_tristate)(struct snd_soc_cpu_dai *, int tristate);
+};
+
+/* SoC Codec DAI */
+struct snd_soc_codec_dai {
+	char *name;
+	int id;
+
+	/* DAI capabilities */
+	struct snd_soc_pcm_stream playback;
+	struct snd_soc_pcm_stream capture;
+
+	/* DAI runtime info */
+	struct snd_soc_codec *codec;
+	unsigned int active;
+	unsigned char pop_wait:1;
+
+	/* ops */
+	struct snd_soc_ops ops;
+	struct snd_soc_codec_ops dai_ops;
+
+	/* DAI private data */
+	void *private_data;
+};
+
+/* SoC CPU DAI */
+struct snd_soc_cpu_dai {
+
+	/* DAI description */
+	char *name;
+	unsigned int id;
+	unsigned char type;
+
+	/* DAI callbacks */
+	int (*probe)(struct platform_device *pdev);
+	void (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+
+	/* ops */
+	struct snd_soc_ops ops;
+	struct snd_soc_cpu_ops dai_ops;
+
+	/* DAI capabilities */
+	struct snd_soc_pcm_stream capture;
+	struct snd_soc_pcm_stream playback;
+
+	/* DAI runtime info */
+	struct snd_pcm_runtime *runtime;
+	unsigned char active:1;
+	void *dma_data;
+
+	/* DAI private data */
+	void *private_data;
+};
+
+/* SoC Audio Codec */
+struct snd_soc_codec {
+	char *name;
+	struct module *owner;
+	struct mutex mutex;
+
+	/* callbacks */
+	int (*dapm_event)(struct snd_soc_codec *codec, int event);
+
+	/* runtime */
+	struct snd_card *card;
+	struct snd_ac97 *ac97;  /* for ad-hoc ac97 devices */
+	unsigned int active;
+	unsigned int pcm_devs;
+	void *private_data;
+
+	/* codec IO */
+	void *control_data; /* codec control (i2c/3wire) data */
+	unsigned int (*read)(struct snd_soc_codec *, unsigned int);
+	int (*write)(struct snd_soc_codec *, unsigned int, unsigned int);
+	hw_write_t hw_write;
+	hw_read_t hw_read;
+	void *reg_cache;
+	short reg_cache_size;
+	short reg_cache_step;
+
+	/* dapm */
+	struct list_head dapm_widgets;
+	struct list_head dapm_paths;
+	unsigned int dapm_state;
+	unsigned int suspend_dapm_state;
+	struct delayed_work delayed_work;
+
+	/* codec DAI's */
+	struct snd_soc_codec_dai *dai;
+	unsigned int num_dai;
+};
+
+/* codec device */
+struct snd_soc_codec_device {
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev, pm_message_t state);
+	int (*resume)(struct platform_device *pdev);
+};
+
+/* SoC platform interface */
+struct snd_soc_platform {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_cpu_dai *cpu_dai);
+
+	/* pcm creation and destruction */
+	int (*pcm_new)(struct snd_card *, struct snd_soc_codec_dai *,
+		struct snd_pcm *);
+	void (*pcm_free)(struct snd_pcm *);
+
+	/* platform stream ops */
+	struct snd_pcm_ops *pcm_ops;
+};
+
+/* SoC machine DAI configuration, glues a codec and cpu DAI together */
+struct snd_soc_dai_link  {
+	char *name;			/* Codec name */
+	char *stream_name;		/* Stream name */
+
+	/* DAI */
+	struct snd_soc_codec_dai *codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai;
+
+	/* machine stream operations */
+	struct snd_soc_ops *ops;
+
+	/* codec/machine specific init - e.g. add machine controls */
+	int (*init)(struct snd_soc_codec *codec);
+};
+
+/* SoC machine */
+struct snd_soc_machine {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+
+	/* the pre and post PM functions are used to do any PM work before and
+	 * after the codec and DAI's do any PM work. */
+	int (*suspend_pre)(struct platform_device *pdev, pm_message_t state);
+	int (*suspend_post)(struct platform_device *pdev, pm_message_t state);
+	int (*resume_pre)(struct platform_device *pdev);
+	int (*resume_post)(struct platform_device *pdev);
+
+	/* CPU <--> Codec DAI links  */
+	struct snd_soc_dai_link *dai_link;
+	int num_links;
+};
+
+/* SoC Device - the audio subsystem */
+struct snd_soc_device {
+	struct device *dev;
+	struct snd_soc_machine *machine;
+	struct snd_soc_platform *platform;
+	struct snd_soc_codec *codec;
+	struct snd_soc_codec_device *codec_dev;
+	struct delayed_work delayed_work;
+	void *codec_data;
+};
+
+/* runtime channel data */
+struct snd_soc_pcm_runtime {
+	struct snd_soc_dai_link *dai;
+	struct snd_soc_device *socdev;
+};
+
+/* enumerated kcontrol */
+struct soc_enum {
+	unsigned short reg;
+	unsigned short reg2;
+	unsigned char shift_l;
+	unsigned char shift_r;
+	unsigned int mask;
+	const char **texts;
+	void *dapm;
+};
+
+#endif
--- linux-2.6.18.noarch/include/sound/initval.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/initval.h	2007-06-05 17:35:15.000000000 -0400
@@ -53,7 +53,7 @@
 #ifdef SNDRV_LEGACY_FIND_FREE_IRQ
 #include <linux/interrupt.h>
 
-static irqreturn_t snd_legacy_empty_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_legacy_empty_irq_handler(int irq, void *dev_id)
 {
 	return IRQ_HANDLED;
 }
--- linux-2.6.18.noarch/include/sound/snd_wavefront.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/snd_wavefront.h	2007-06-05 17:35:15.000000000 -0400
@@ -85,6 +85,7 @@
 	char hw_version[2];                /* major = [0], minor = [1] */
 	char israw;                        /* needs Motorola microcode */
 	char has_fx;                       /* has FX processor (Tropez+) */
+	char fx_initialized;               /* FX's register pages initialized */
 	char prog_status[WF_MAX_PROGRAM];  /* WF_SLOT_* */
 	char patch_status[WF_MAX_PATCH];   /* WF_SLOT_* */
 	char sample_status[WF_MAX_SAMPLE]; /* WF_ST_* | WF_SLOT_* */
@@ -94,6 +95,7 @@
 	spinlock_t irq_lock;
 	wait_queue_head_t interrupt_sleeper; 
 	snd_wavefront_midi_t midi;         /* ICS2115 MIDI interface */
+	struct snd_card *card;
 };
 
 struct _snd_wavefront_card {
--- linux-2.6.18.noarch/include/sound/ak4114.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/ak4114.h	2007-06-05 17:35:15.000000000 -0400
@@ -189,7 +189,7 @@
 
 int snd_ak4114_create(struct snd_card *card,
 		      ak4114_read_t *read, ak4114_write_t *write,
-		      unsigned char pgm[7], unsigned char txcsb[5],
+		      const unsigned char pgm[7], const unsigned char txcsb[5],
 		      void *private_data, struct ak4114 **r_ak4114);
 void snd_ak4114_reg_write(struct ak4114 *ak4114, unsigned char reg, unsigned char mask, unsigned char val);
 void snd_ak4114_reinit(struct ak4114 *ak4114);
--- linux-2.6.18.noarch/include/sound/ak4xxx-adda.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/ak4xxx-adda.h	2007-06-05 17:35:15.000000000 -0400
@@ -39,26 +39,41 @@
 
 #define AK4XXX_IMAGE_SIZE	(AK4XXX_MAX_CHIPS * 16)	/* 64 bytes */
 
+/* DAC label and channels */
+struct snd_akm4xxx_dac_channel {
+	char *name;		/* mixer volume name */
+	unsigned int num_channels;
+};
+
+/* ADC labels and channels */
+struct snd_akm4xxx_adc_channel {
+	char *name;		/* capture gain volume label */
+	char *switch_name;	/* capture switch */
+	unsigned int num_channels;
+	char *selector_name;	/* capture source select label */
+	const char **input_names; /* capture source names (NULL terminated) */
+};
+
 struct snd_akm4xxx {
 	struct snd_card *card;
 	unsigned int num_adcs;			/* AK4524 or AK4528 ADCs */
 	unsigned int num_dacs;			/* AK4524 or AK4528 DACs */
 	unsigned char images[AK4XXX_IMAGE_SIZE]; /* saved register image */
-	unsigned char ipga_gain[AK4XXX_MAX_CHIPS][2]; /* saved register image
-						       * for IPGA (AK4528)
-						       */
+	unsigned char volumes[AK4XXX_IMAGE_SIZE]; /* saved volume values */
 	unsigned long private_value[AK4XXX_MAX_CHIPS];	/* helper for driver */
 	void *private_data[AK4XXX_MAX_CHIPS];		/* helper for driver */
 	/* template should fill the following fields */
 	unsigned int idx_offset;		/* control index offset */
 	enum {
 		SND_AK4524, SND_AK4528, SND_AK4529,
-		SND_AK4355, SND_AK4358, SND_AK4381
+		SND_AK4355, SND_AK4358, SND_AK4381,
+		SND_AK5365
 	} type;
-	unsigned int *num_stereo;	/* array of combined counts
-					 * for the mixer
-					 */
-	char **channel_names;		/* array of mixer channel names */
+
+	/* (array) information of combined codecs */
+	const struct snd_akm4xxx_dac_channel *dac_info;
+	const struct snd_akm4xxx_adc_channel *adc_info;
+
 	struct snd_ak4xxx_ops ops;
 };
 
@@ -72,9 +87,9 @@
 	(ak)->images[(chip) * 16 + (reg)]
 #define snd_akm4xxx_set(ak,chip,reg,val) \
 	((ak)->images[(chip) * 16 + (reg)] = (val))
-#define snd_akm4xxx_get_ipga(ak,chip,reg) \
-	(ak)->ipga_gain[chip][(reg)-4]
-#define snd_akm4xxx_set_ipga(ak,chip,reg,val) \
-	((ak)->ipga_gain[chip][(reg)-4] = (val))
+#define snd_akm4xxx_get_vol(ak,chip,reg) \
+	(ak)->volumes[(chip) * 16 + (reg)]
+#define snd_akm4xxx_set_vol(ak,chip,reg,val) \
+	((ak)->volumes[(chip) * 16 + (reg)] = (val))
 
 #endif /* __SOUND_AK4XXX_ADDA_H */
--- linux-2.6.18.noarch/include/sound/gus.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/gus.h	2007-06-05 17:35:15.000000000 -0400
@@ -638,7 +638,7 @@
 
 /* gus_irq.c */
 
-irqreturn_t snd_gus_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t snd_gus_interrupt(int irq, void *dev_id);
 #ifdef CONFIG_SND_DEBUG
 void snd_gus_irq_profile_init(struct snd_gus_card *gus);
 #endif
--- linux-2.6.18.noarch/include/sound/core.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/core.h	2007-06-05 17:35:15.000000000 -0400
@@ -25,8 +25,8 @@
 #include <linux/sched.h>		/* wake_up() */
 #include <linux/mutex.h>		/* struct mutex */
 #include <linux/rwsem.h>		/* struct rw_semaphore */
-#include <linux/workqueue.h>		/* struct workqueue_struct */
 #include <linux/pm.h>			/* pm_message_t */
+#include <linux/device.h>
 
 /* forward declarations */
 #ifdef CONFIG_PCI
@@ -71,7 +71,6 @@
 	int (*dev_free)(struct snd_device *dev);
 	int (*dev_register)(struct snd_device *dev);
 	int (*dev_disconnect)(struct snd_device *dev);
-	int (*dev_unregister)(struct snd_device *dev);
 };
 
 struct snd_device {
@@ -90,10 +89,10 @@
 struct snd_monitor_file {
 	struct file *file;
 	struct snd_monitor_file *next;
+	const struct file_operations *disconnected_f_op;
+	struct list_head shutdown_list;
 };
 
-struct snd_shutdown_f_ops;	/* define it later in init.c */
-
 /* main structure for soundcard */
 
 struct snd_card {
@@ -131,9 +130,12 @@
 								state */
 	spinlock_t files_lock;		/* lock the files for this card */
 	int shutdown;			/* this card is going down */
+	int free_on_last_close;		/* free in context of file_release */
 	wait_queue_head_t shutdown_sleep;
-	struct work_struct free_workq;	/* for free in workqueue */
-	struct device *dev;
+	struct device *dev;		/* device assigned to this card */
+#ifndef CONFIG_SYSFS_DEPRECATED
+	struct device *card_dev;	/* cardX object for sysfs */
+#endif
 
 #ifdef CONFIG_PM
 	unsigned int power_state;	/* power state */
@@ -188,12 +190,24 @@
 	int device;			/* device number */
 	const struct file_operations *f_ops;	/* file operations */
 	void *private_data;		/* private data for f_ops->open */
+	struct device *dev;		/* device for sysfs */
 };
 
+/* return a device pointer linked to each sound device as a parent */
+static inline struct device *snd_card_get_device_link(struct snd_card *card)
+{
+#ifdef CONFIG_SYSFS_DEPRECATED
+	return card ? card->dev : NULL;
+#else
+	return card ? card->card_dev : NULL;
+#endif
+}
+
 /* sound.c */
 
 extern int snd_major;
 extern int snd_ecards_limit;
+extern struct class *sound_class;
 
 void snd_request_card(int card);
 
@@ -202,6 +216,8 @@
 			const char *name);
 int snd_unregister_device(int type, struct snd_card *card, int dev);
 void *snd_lookup_minor_data(unsigned int minor, int type);
+int snd_add_device_sysfs_file(int type, struct snd_card *card, int dev,
+			      struct device_attribute *attr);
 
 #ifdef CONFIG_SND_OSSEMUL
 int snd_register_oss_device(int type, struct snd_card *card, int dev,
@@ -244,7 +260,7 @@
 			 struct module *module, int extra_size);
 int snd_card_disconnect(struct snd_card *card);
 int snd_card_free(struct snd_card *card);
-int snd_card_free_in_thread(struct snd_card *card);
+int snd_card_free_when_closed(struct snd_card *card);
 int snd_card_register(struct snd_card *card);
 int snd_card_info_init(void);
 int snd_card_info_done(void);
@@ -380,6 +396,29 @@
 #endif
 #endif
 
-#include "typedefs.h"
+/* PCI quirk list helper */
+struct snd_pci_quirk {
+	unsigned short subvendor;	/* PCI subvendor ID */
+	unsigned short subdevice;	/* PCI subdevice ID */
+	int value;			/* value */
+#ifdef CONFIG_SND_DEBUG_DETECT
+	const char *name;		/* name of the device (optional) */
+#endif
+};
+
+#define _SND_PCI_QUIRK_ID(vend,dev) \
+	.subvendor = (vend), .subdevice = (dev)
+#define SND_PCI_QUIRK_ID(vend,dev) {_SND_PCI_QUIRK_ID(vend, dev)}
+#ifdef CONFIG_SND_DEBUG_DETECT
+#define SND_PCI_QUIRK(vend,dev,xname,val) \
+	{_SND_PCI_QUIRK_ID(vend, dev), .value = (val), .name = (xname)}
+#else
+#define SND_PCI_QUIRK(vend,dev,xname,val) \
+	{_SND_PCI_QUIRK_ID(vend, dev), .value = (val)}
+#endif
+
+const struct snd_pci_quirk *
+snd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list);
+
 
 #endif /* __SOUND_CORE_H */
--- linux-2.6.18.noarch/include/sound/pcm.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/pcm.h	2007-06-05 17:35:15.000000000 -0400
@@ -26,6 +26,7 @@
 #include <sound/asound.h>
 #include <sound/memalloc.h>
 #include <linux/poll.h>
+#include <linux/mm.h>
 #include <linux/bitops.h>
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
@@ -55,6 +56,8 @@
 	size_t fifo_size;		/* fifo size in bytes */
 };
 
+struct snd_pcm_substream;
+
 struct snd_pcm_ops {
 	int (*open)(struct snd_pcm_substream *substream);
 	int (*close)(struct snd_pcm_substream *substream);
@@ -190,7 +193,7 @@
 
 struct snd_pcm_file {
 	struct snd_pcm_substream *substream;
-	struct snd_pcm_file *next;
+	int no_compat_mmap;
 };
 
 struct snd_pcm_hw_rule;
@@ -347,6 +350,7 @@
 	int number;
 	char name[32];			/* substream name */
 	int stream;			/* stream (direction) */
+	char latency_id[20];		/* latency identifier */
 	size_t buffer_bytes_max;	/* limit ring buffer size */
 	struct snd_dma_buffer dma_buffer;
 	unsigned int dma_buf_id;
@@ -382,9 +386,9 @@
 	struct snd_info_entry *proc_sw_params_entry;
 	struct snd_info_entry *proc_status_entry;
 	struct snd_info_entry *proc_prealloc_entry;
+	struct snd_info_entry *proc_prealloc_max_entry;
 #endif
 	/* misc flags */
-	unsigned int no_mmap_ctrl: 1;
 	unsigned int hw_opened: 1;
 };
 
@@ -402,7 +406,6 @@
 	/* -- OSS things -- */
 	struct snd_pcm_oss_stream oss;
 #endif
-	struct snd_pcm_file *files;
 #ifdef CONFIG_SND_VERBOSE_PROCFS
 	struct snd_info_entry *proc_root;
 	struct snd_info_entry *proc_info_entry;
@@ -427,6 +430,7 @@
 	wait_queue_head_t open_wait;
 	void *private_data;
 	void (*private_free) (struct snd_pcm *pcm);
+	struct device *dev; /* actual hw device this belongs to */
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	struct snd_pcm_oss oss;
 #endif
@@ -443,7 +447,7 @@
  *  Registering
  */
 
-extern struct file_operations snd_pcm_f_ops[2];
+extern const struct file_operations snd_pcm_f_ops[2];
 
 int snd_pcm_new(struct snd_card *card, char *id, int device,
 		int playback_count, int capture_count,
--- linux-2.6.18.noarch/include/sound/sb.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/sb.h	2007-06-05 23:13:46.000000000 -0400
@@ -100,7 +100,6 @@
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_substream *midi_substream_input;
 	struct snd_rawmidi_substream *midi_substream_output;
-	irqreturn_t (*rmidi_callback)(int irq, void *dev_id, struct pt_regs *regs);
 
 	spinlock_t reg_lock;
 	spinlock_t open_lock;
@@ -316,7 +315,7 @@
 const struct snd_pcm_ops *snd_sb16dsp_get_pcm_ops(int direction);
 int snd_sb16dsp_configure(struct snd_sb *chip);
 /* sb16.c */
-irqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id);
 
 /* exported mixer stuffs */
 enum {
--- linux-2.6.18.noarch/include/sound/pt2258.h.orig	2007-06-05 16:47:54.000000000 -0400
+++ linux-2.6.18.noarch/include/sound/pt2258.h	2007-06-05 17:35:15.000000000 -0400
@@ -0,0 +1,37 @@
+/*
+ *   ALSA Driver for the PT2258 volume controller.
+ *
+ *	Copyright (c) 2006  Jochen Voss <voss@seehuhn.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */      
+
+#ifndef __SOUND_PT2258_H
+#define __SOUND_PT2258_H
+
+struct snd_pt2258 {
+	struct snd_card *card;
+	struct snd_i2c_bus *i2c_bus;
+	struct snd_i2c_device *i2c_dev;
+
+	unsigned char volume[6];
+	int mute;
+};
+
+extern int snd_pt2258_reset(struct snd_pt2258 *pt);
+extern int snd_pt2258_build_controls(struct snd_pt2258 *pt);
+
+#endif /* __SOUND_PT2258_H */
--- linux-2.6.18.noarch/sound/synth/emux/emux_proc.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/synth/emux/emux_proc.c	2007-06-05 17:49:20.000000000 -0400
@@ -20,7 +20,6 @@
 
 #include <sound/driver.h>
 #include <linux/wait.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/emux_synth.h>
@@ -128,10 +127,8 @@
 
 void snd_emux_proc_free(struct snd_emux *emu)
 {
-	if (emu->proc) {
-		snd_info_unregister(emu->proc);
-		emu->proc = NULL;
-	}
+	snd_info_free_entry(emu->proc);
+	emu->proc = NULL;
 }
 
 #endif /* CONFIG_PROC_FS */
--- linux-2.6.18.noarch/sound/synth/emux/emux.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/synth/emux/emux.c	2007-06-05 17:49:20.000000000 -0400
@@ -20,7 +20,6 @@
 
 #include <sound/driver.h>
 #include <linux/wait.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <sound/core.h>
--- linux-2.6.18.noarch/sound/pcmcia/pdaudiocf/pdaudiocf.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/pcmcia/pdaudiocf/pdaudiocf.c	2007-06-05 17:48:36.000000000 -0400
@@ -90,7 +90,7 @@
 /*
  * snd_pdacf_attach - attach callback for cs
  */
-static int __devinit snd_pdacf_probe(struct pcmcia_device *link)
+static int snd_pdacf_probe(struct pcmcia_device *link)
 {
 	int i;
 	struct snd_pdacf *pdacf;
@@ -196,7 +196,7 @@
 /*
  * snd_pdacf_detach - detach callback for cs
  */
-static void __devexit snd_pdacf_detach(struct pcmcia_device *link)
+static void snd_pdacf_detach(struct pcmcia_device *link)
 {
 	struct snd_pdacf *chip = link->priv;
 
@@ -206,7 +206,7 @@
 		snd_pdacf_powerdown(chip);
 	chip->chip_status |= PDAUDIOCF_STAT_IS_STALE; /* to be sure */
 	snd_card_disconnect(chip->card);
-	snd_card_free_in_thread(chip->card);
+	snd_card_free_when_closed(chip->card);
 }
 
 /*
@@ -219,35 +219,15 @@
 static int pdacf_config(struct pcmcia_device *link)
 {
 	struct snd_pdacf *pdacf = link->priv;
-	tuple_t tuple;
-	cisparse_t *parse = NULL;
-	u_short buf[32];
 	int last_fn, last_ret;
 
 	snd_printdd(KERN_DEBUG "pdacf_config called\n");
-	parse = kmalloc(sizeof(*parse), GFP_KERNEL);
-	if (! parse) {
-		snd_printk(KERN_ERR "pdacf_config: cannot allocate\n");
-		return -ENOMEM;
-	}
-	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	tuple.Attributes = 0;
-	tuple.TupleData = (cisdata_t *)buf;
-	tuple.TupleDataMax = sizeof(buf);
-	tuple.TupleOffset = 0;
-	tuple.DesiredTuple = CISTPL_CONFIG;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-	CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, parse));
-	link->conf.ConfigBase = parse->config.base;
 	link->conf.ConfigIndex = 0x5;
 
 	CS_CHECK(RequestIO, pcmcia_request_io(link, &link->io));
 	CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
 	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
 
-	kfree(parse);
-
 	if (snd_pdacf_assign_resources(pdacf, link->io.BasePort1, link->irq.AssignedIRQ) < 0)
 		goto failed;
 
@@ -255,7 +235,6 @@
 	return 0;
 
 cs_failed:
-	kfree(parse);
 	cs_error(link, last_fn, last_ret);
 failed:
 	pcmcia_disable_device(link);
@@ -299,7 +278,8 @@
  * Module entry points
  */
 static struct pcmcia_device_id snd_pdacf_ids[] = {
-	PCMCIA_DEVICE_MANF_CARD(0x015d, 0x4c45),
+	/* this is too general PCMCIA_DEVICE_MANF_CARD(0x015d, 0x4c45), */
+	PCMCIA_DEVICE_PROD_ID12("Core Sound","PDAudio-CF",0x396d19d2,0x71717b49),
 	PCMCIA_DEVICE_NULL
 };
 MODULE_DEVICE_TABLE(pcmcia, snd_pdacf_ids);
@@ -310,7 +290,7 @@
 		.name	= "snd-pdaudiocf",
 	},
 	.probe		= snd_pdacf_probe,
-	.remove		= __devexit_p(snd_pdacf_detach),
+	.remove		= snd_pdacf_detach,
 	.id_table	= snd_pdacf_ids,
 #ifdef CONFIG_PM
 	.suspend	= pdacf_suspend,
--- linux-2.6.18.noarch/sound/pcmcia/pdaudiocf/pdaudiocf_irq.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/pcmcia/pdaudiocf/pdaudiocf_irq.c	2007-06-05 17:48:36.000000000 -0400
@@ -22,11 +22,12 @@
 #include <sound/core.h>
 #include "pdaudiocf.h"
 #include <sound/initval.h>
+#include <asm/irq_regs.h>
 
 /*
  *
  */
-irqreturn_t pdacf_interrupt(int irq, void *dev, struct pt_regs *regs)
+irqreturn_t pdacf_interrupt(int irq, void *dev)
 {
 	struct snd_pdacf *chip = dev;
 	unsigned short stat;
@@ -45,7 +46,7 @@
 		if (!(stat & PDAUDIOCF_IRQAKM))
 			stat |= PDAUDIOCF_IRQAKM;	/* check rate */
 	}
-	if (regs != NULL)
+	if (get_irq_regs() != NULL)
 		snd_ak4117_check_rate_and_errors(chip->ak4117, 0);
 	return IRQ_HANDLED;
 }
--- linux-2.6.18.noarch/sound/pcmcia/pdaudiocf/pdaudiocf.h.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pcmcia/pdaudiocf/pdaudiocf.h	2007-06-05 17:48:36.000000000 -0400
@@ -138,7 +138,7 @@
 int snd_pdacf_resume(struct snd_pdacf *chip);
 #endif
 int snd_pdacf_pcm_new(struct snd_pdacf *chip);
-irqreturn_t pdacf_interrupt(int irq, void *dev, struct pt_regs *regs);
+irqreturn_t pdacf_interrupt(int irq, void *dev);
 void pdacf_tasklet(unsigned long private_data);
 void pdacf_reinit(struct snd_pdacf *chip, int resume);
 
--- linux-2.6.18.noarch/sound/pcmcia/vx/vxpocket.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/pcmcia/vx/vxpocket.c	2007-06-05 17:48:42.000000000 -0400
@@ -27,6 +27,7 @@
 #include <pcmcia/ciscode.h>
 #include <pcmcia/cisreg.h>
 #include <sound/initval.h>
+#include <sound/tlv.h>
 
 /*
  */
@@ -65,7 +66,7 @@
 }
 
 /*
- * destructor, called from snd_card_free_in_thread()
+ * destructor, called from snd_card_free_when_closed()
  */
 static int snd_vxpocket_dev_free(struct snd_device *device)
 {
@@ -90,6 +91,8 @@
  * Only output levels can be modified
  */
 
+static const DECLARE_TLV_DB_SCALE(db_scale_old_vol, -11350, 50, 0);
+
 static struct snd_vx_hardware vxpocket_hw = {
 	.name = "VXPocket",
 	.type = VX_TYPE_VXPOCKET,
@@ -99,6 +102,7 @@
 	.num_ins = 1,
 	.num_outs = 1,
 	.output_level_max = VX_ANALOG_OUT_LEVEL_MAX,
+	.output_level_db_scale = db_scale_old_vol,
 };	
 
 /* VX-pocket 440
@@ -120,6 +124,7 @@
 	.num_ins = 2,
 	.num_outs = 2,
 	.output_level_max = VX_ANALOG_OUT_LEVEL_MAX,
+	.output_level_db_scale = db_scale_old_vol,
 };	
 
 
@@ -212,34 +217,12 @@
 {
 	struct vx_core *chip = link->priv;
 	struct snd_vxpocket *vxp = (struct snd_vxpocket *)chip;
-	tuple_t tuple;
-	cisparse_t *parse;
-	u_short buf[32];
 	int last_fn, last_ret;
 
 	snd_printdd(KERN_DEBUG "vxpocket_config called\n");
-	parse = kmalloc(sizeof(*parse), GFP_KERNEL);
-	if (! parse) {
-		snd_printk(KERN_ERR "vx: cannot allocate\n");
-		return -ENOMEM;
-	}
-	tuple.Attributes = 0;
-	tuple.TupleData = (cisdata_t *)buf;
-	tuple.TupleDataMax = sizeof(buf);
-	tuple.TupleOffset = 0;
-	tuple.DesiredTuple = CISTPL_CONFIG;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-	CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, parse));
-	link->conf.ConfigBase = parse->config.base;
-	link->conf.Present = parse->config.rmask[0];
 
 	/* redefine hardware record according to the VERSION1 string */
-	tuple.DesiredTuple = CISTPL_VERS_1;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-	CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, parse));
-	if (! strcmp(parse->version_1.str + parse->version_1.ofs[1], "VX-POCKET")) {
+	if (!strcmp(link->prod_id[1], "VX-POCKET")) {
 		snd_printdd("VX-pocket is detected\n");
 	} else {
 		snd_printdd("VX-pocket 440 is detected\n");
@@ -260,14 +243,12 @@
 		goto failed;
 
 	link->dev_node = &vxp->node;
-	kfree(parse);
 	return 0;
 
 cs_failed:
 	cs_error(link, last_fn, last_ret);
 failed:
 	pcmcia_disable_device(link);
-	kfree(parse);
 	return -ENODEV;
 }
 
@@ -308,7 +289,7 @@
 
 /*
  */
-static int __devinit vxpocket_probe(struct pcmcia_device *p_dev)
+static int vxpocket_probe(struct pcmcia_device *p_dev)
 {
 	struct snd_card *card;
 	struct snd_vxpocket *vxp;
@@ -348,7 +329,7 @@
 	return vxpocket_config(p_dev);
 }
 
-static void __devexit vxpocket_detach(struct pcmcia_device *link)
+static void vxpocket_detach(struct pcmcia_device *link)
 {
 	struct snd_vxpocket *vxp;
 	struct vx_core *chip;
@@ -363,7 +344,7 @@
 	chip->chip_status |= VX_STAT_IS_STALE; /* to be sure */
 	snd_card_disconnect(chip->card);
 	vxpocket_release(link);
-	snd_card_free_in_thread(chip->card);
+	snd_card_free_when_closed(chip->card);
 }
 
 /*
@@ -382,7 +363,7 @@
 		.name	= "snd-vxpocket",
 	},
 	.probe		= vxpocket_probe,
-	.remove		= __devexit_p(vxpocket_detach),
+	.remove		= vxpocket_detach,
 	.id_table	= vxp_ids,
 #ifdef CONFIG_PM
 	.suspend	= vxp_suspend,
--- linux-2.6.18.noarch/sound/pcmcia/vx/vxp_mixer.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/pcmcia/vx/vxp_mixer.c	2007-06-05 17:48:42.000000000 -0400
@@ -23,6 +23,7 @@
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include "vxpocket.h"
 
 #define MIC_LEVEL_MIN	0
@@ -63,12 +64,17 @@
 	return 0;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_mic, -21, 3, 0);
+
 static struct snd_kcontrol_new vx_control_mic_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Mic Capture Volume",
 	.info =		vx_mic_level_info,
 	.get =		vx_mic_level_get,
 	.put =		vx_mic_level_put,
+	.tlv = { .p = db_scale_mic },
 };
 
 /*
--- linux-2.6.18.noarch/sound/arm/aaci.h.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/arm/aaci.h	2007-06-05 17:40:13.000000000 -0400
@@ -49,27 +49,27 @@
 #define AACI_DR4	0x0f0	/* data read/written fifo 4 */
 
 /*
- * transmit fifo control register. P48
+ * TX/RX fifo control register (CR). P48
  */
-#define TXCR_FEN	(1 << 16)	/* fifo enable */
-#define TXCR_COMPACT	(1 << 15)	/* compact mode */
-#define TXCR_TSZ16	(0 << 13)	/* 16 bits */
-#define TXCR_TSZ18	(1 << 13)	/* 18 bits */
-#define TXCR_TSZ20	(2 << 13)	/* 20 bits */
-#define TXCR_TSZ12	(3 << 13)	/* 12 bits */
-#define TXCR_TX12	(1 << 12)	/* transmits slot 12 */
-#define TXCR_TX11	(1 << 11)	/* transmits slot 12 */
-#define TXCR_TX10	(1 << 10)	/* transmits slot 12 */
-#define TXCR_TX9	(1 << 9)	/* transmits slot 12 */
-#define TXCR_TX8	(1 << 8)	/* transmits slot 12 */
-#define TXCR_TX7	(1 << 7)	/* transmits slot 12 */
-#define TXCR_TX6	(1 << 6)	/* transmits slot 12 */
-#define TXCR_TX5	(1 << 5)	/* transmits slot 12 */
-#define TXCR_TX4	(1 << 4)	/* transmits slot 12 */
-#define TXCR_TX3	(1 << 3)	/* transmits slot 12 */
-#define TXCR_TX2	(1 << 2)	/* transmits slot 12 */
-#define TXCR_TX1	(1 << 1)	/* transmits slot 12 */
-#define TXCR_TXEN	(1 << 0)	/* transmit enable */
+#define CR_FEN		(1 << 16)	/* fifo enable */
+#define CR_COMPACT	(1 << 15)	/* compact mode */
+#define CR_SZ16		(0 << 13)	/* 16 bits */
+#define CR_SZ18		(1 << 13)	/* 18 bits */
+#define CR_SZ20		(2 << 13)	/* 20 bits */
+#define CR_SZ12		(3 << 13)	/* 12 bits */
+#define CR_SL12		(1 << 12)
+#define CR_SL11		(1 << 11)
+#define CR_SL10		(1 << 10)
+#define CR_SL9		(1 << 9)
+#define CR_SL8		(1 << 8)
+#define CR_SL7		(1 << 7)
+#define CR_SL6		(1 << 6)
+#define CR_SL5		(1 << 5)
+#define CR_SL4		(1 << 4)
+#define CR_SL3		(1 << 3)
+#define CR_SL2		(1 << 2)
+#define CR_SL1		(1 << 1)
+#define CR_EN		(1 << 0)	/* transmit enable */
 
 /*
  * status register bits. P49
@@ -228,7 +228,8 @@
 
 	/* AC'97 */
 	struct mutex		ac97_sem;
-	ac97_bus_t		*ac97_bus;
+	struct snd_ac97_bus	*ac97_bus;
+	struct snd_ac97		*ac97;
 
 	u32			maincr;
 	spinlock_t		lock;
--- linux-2.6.18.noarch/sound/arm/pxa2xx-ac97.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/arm/pxa2xx-ac97.c	2007-06-05 17:40:13.000000000 -0400
@@ -152,7 +152,7 @@
 	GCR |= GCR_SDONE_IE|GCR_CDONE_IE;
 }
 
-static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id)
 {
 	long status;
 
--- linux-2.6.18.noarch/sound/arm/pxa2xx-pcm.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/arm/pxa2xx-pcm.c	2007-06-05 17:40:13.000000000 -0400
@@ -137,7 +137,7 @@
 	return ret;
 }
 
-static void pxa2xx_pcm_dma_irq(int dma_ch, void *dev_id, struct pt_regs *regs)
+static void pxa2xx_pcm_dma_irq(int dma_ch, void *dev_id)
 {
 	struct snd_pcm_substream *substream = dev_id;
 	struct pxa2xx_runtime_data *rtd = substream->runtime->private_data;
--- linux-2.6.18.noarch/sound/arm/aaci.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/arm/aaci.c	2007-06-05 17:40:13.000000000 -0400
@@ -65,10 +65,12 @@
  *  SI1TxEn, SI2TxEn and SI12TxEn bits are set in the AACI_MAINCR
  *  register.
  */
-static void aaci_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
+static void aaci_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+			    unsigned short val)
 {
 	struct aaci *aaci = ac97->private_data;
 	u32 v;
+	int timeout = 5000;
 
 	if (ac97->num >= 4)
 		return;
@@ -89,7 +91,11 @@
 	 */
 	do {
 		v = readl(aaci->base + AACI_SLFR);
-	} while (v & (SLFR_1TXB|SLFR_2TXB));
+	} while ((v & (SLFR_1TXB|SLFR_2TXB)) && timeout--);
+
+	if (!timeout)
+		dev_err(&aaci->dev->dev,
+			"timeout waiting for write to complete\n");
 
 	mutex_unlock(&aaci->ac97_sem);
 }
@@ -101,6 +107,8 @@
 {
 	struct aaci *aaci = ac97->private_data;
 	u32 v;
+	int timeout = 5000;
+	int retries = 10;
 
 	if (ac97->num >= 4)
 		return ~0;
@@ -119,7 +127,13 @@
 	 */
 	do {
 		v = readl(aaci->base + AACI_SLFR);
-	} while (v & SLFR_1TXB);
+	} while ((v & SLFR_1TXB) && timeout--);
+
+	if (!timeout) {
+		dev_err(&aaci->dev->dev, "timeout on slot 1 TX busy\n");
+		v = ~0;
+		goto out;
+	}
 
 	/*
 	 * Give the AC'97 codec more than enough time
@@ -130,21 +144,35 @@
 	/*
 	 * Wait for slot 2 to indicate data.
 	 */
+	timeout = 5000;
 	do {
 		cond_resched();
 		v = readl(aaci->base + AACI_SLFR) & (SLFR_1RXV|SLFR_2RXV);
-	} while (v != (SLFR_1RXV|SLFR_2RXV));
+	} while ((v != (SLFR_1RXV|SLFR_2RXV)) && timeout--);
 
-	v = readl(aaci->base + AACI_SL1RX) >> 12;
-	if (v == reg) {
-		v = readl(aaci->base + AACI_SL2RX) >> 4;
-	} else {
-		dev_err(&aaci->dev->dev,
-			"wrong ac97 register read back (%x != %x)\n",
-			v, reg);
+	if (!timeout) {
+		dev_err(&aaci->dev->dev, "timeout on RX valid\n");
 		v = ~0;
+		goto out;
 	}
 
+	do {
+		v = readl(aaci->base + AACI_SL1RX) >> 12;
+		if (v == reg) {
+			v = readl(aaci->base + AACI_SL2RX) >> 4;
+			break;
+		} else if (--retries) {
+			dev_warn(&aaci->dev->dev,
+				 "ac97 read back fail.  retry\n");
+			continue;
+		} else {
+			dev_warn(&aaci->dev->dev,
+				"wrong ac97 register read back (%x != %x)\n",
+				v, reg);
+			v = ~0;
+		}
+	} while (retries);
+ out:
 	mutex_unlock(&aaci->ac97_sem);
 	return v;
 }
@@ -164,10 +192,70 @@
 /*
  * Interrupt support.
  */
-static void aaci_fifo_irq(struct aaci *aaci, u32 mask)
+static void aaci_fifo_irq(struct aaci *aaci, int channel, u32 mask)
 {
+	if (mask & ISR_ORINTR) {
+		dev_warn(&aaci->dev->dev, "RX overrun on chan %d\n", channel);
+		writel(ICLR_RXOEC1 << channel, aaci->base + AACI_INTCLR);
+	}
+
+	if (mask & ISR_RXTOINTR) {
+		dev_warn(&aaci->dev->dev, "RX timeout on chan %d\n", channel);
+		writel(ICLR_RXTOFEC1 << channel, aaci->base + AACI_INTCLR);
+	}
+
+	if (mask & ISR_RXINTR) {
+		struct aaci_runtime *aacirun = &aaci->capture;
+		void *ptr;
+
+		if (!aacirun->substream || !aacirun->start) {
+			dev_warn(&aaci->dev->dev, "RX interrupt???");
+			writel(0, aacirun->base + AACI_IE);
+			return;
+		}
+		ptr = aacirun->ptr;
+
+		do {
+			unsigned int len = aacirun->fifosz;
+			u32 val;
+
+			if (aacirun->bytes <= 0) {
+				aacirun->bytes += aacirun->period;
+				aacirun->ptr = ptr;
+				spin_unlock(&aaci->lock);
+				snd_pcm_period_elapsed(aacirun->substream);
+				spin_lock(&aaci->lock);
+			}
+			if (!(aacirun->cr & CR_EN))
+				break;
+
+			val = readl(aacirun->base + AACI_SR);
+			if (!(val & SR_RXHF))
+				break;
+			if (!(val & SR_RXFF))
+				len >>= 1;
+
+			aacirun->bytes -= len;
+
+			/* reading 16 bytes at a time */
+			for( ; len > 0; len -= 16) {
+				asm(
+					"ldmia	%1, {r0, r1, r2, r3}\n\t"
+					"stmia	%0!, {r0, r1, r2, r3}"
+					: "+r" (ptr)
+					: "r" (aacirun->fifo)
+					: "r0", "r1", "r2", "r3", "cc");
+
+				if (ptr >= aacirun->end)
+					ptr = aacirun->start;
+			}
+		} while(1);
+		aacirun->ptr = ptr;
+	}
+
 	if (mask & ISR_URINTR) {
-		writel(ICLR_TXUEC1, aaci->base + AACI_INTCLR);
+		dev_dbg(&aaci->dev->dev, "TX underrun on chan %d\n", channel);
+		writel(ICLR_TXUEC1 << channel, aaci->base + AACI_INTCLR);
 	}
 
 	if (mask & ISR_TXINTR) {
@@ -192,7 +280,7 @@
 				snd_pcm_period_elapsed(aacirun->substream);
 				spin_lock(&aaci->lock);
 			}
-			if (!(aacirun->cr & TXCR_TXEN))
+			if (!(aacirun->cr & CR_EN))
 				break;
 
 			val = readl(aacirun->base + AACI_SR);
@@ -221,7 +309,7 @@
 	}
 }
 
-static irqreturn_t aaci_irq(int irq, void *devid, struct pt_regs *regs)
+static irqreturn_t aaci_irq(int irq, void *devid)
 {
 	struct aaci *aaci = devid;
 	u32 mask;
@@ -233,7 +321,7 @@
 		u32 m = mask;
 		for (i = 0; i < 4; i++, m >>= 7) {
 			if (m & 0x7f) {
-				aaci_fifo_irq(aaci, m);
+				aaci_fifo_irq(aaci, i, m);
 			}
 		}
 	}
@@ -330,8 +418,9 @@
 	.periods_max		= PAGE_SIZE / 16,
 };
 
-static int aaci_pcm_open(struct aaci *aaci, struct snd_pcm_substream *substream,
-			 struct aaci_runtime *aacirun)
+static int __aaci_pcm_open(struct aaci *aaci,
+			   struct snd_pcm_substream *substream,
+			   struct aaci_runtime *aacirun)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
@@ -380,7 +469,7 @@
 	struct aaci *aaci = substream->private_data;
 	struct aaci_runtime *aacirun = substream->runtime->private_data;
 
-	WARN_ON(aacirun->cr & TXCR_TXEN);
+	WARN_ON(aacirun->cr & CR_EN);
 
 	aacirun->substream = NULL;
 	free_irq(aaci->dev->irq[0], aaci);
@@ -395,7 +484,7 @@
 	/*
 	 * This must not be called with the device enabled.
 	 */
-	WARN_ON(aacirun->cr & TXCR_TXEN);
+	WARN_ON(aacirun->cr & CR_EN);
 
 	if (aacirun->pcm_open)
 		snd_ac97_pcm_close(aacirun->pcm);
@@ -422,9 +511,15 @@
 	if (err < 0)
 		goto out;
 
-	err = snd_ac97_pcm_open(aacirun->pcm, params_rate(params),
-				params_channels(params),
-				aacirun->pcm->r[0].slots);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		err = snd_ac97_pcm_open(aacirun->pcm, params_rate(params),
+					params_channels(params),
+					aacirun->pcm->r[0].slots);
+	else
+		err = snd_ac97_pcm_open(aacirun->pcm, params_rate(params),
+					params_channels(params),
+					aacirun->pcm->r[1].slots);
+
 	if (err)
 		goto out;
 
@@ -467,9 +562,9 @@
  * Playback specific ALSA stuff
  */
 static const u32 channels_to_txmask[] = {
-	[2] = TXCR_TX3 | TXCR_TX4,
-	[4] = TXCR_TX3 | TXCR_TX4 | TXCR_TX7 | TXCR_TX8,
-	[6] = TXCR_TX3 | TXCR_TX4 | TXCR_TX7 | TXCR_TX8 | TXCR_TX6 | TXCR_TX9,
+	[2] = CR_SL3 | CR_SL4,
+	[4] = CR_SL3 | CR_SL4 | CR_SL7 | CR_SL8,
+	[6] = CR_SL3 | CR_SL4 | CR_SL7 | CR_SL8 | CR_SL6 | CR_SL9,
 };
 
 /*
@@ -504,7 +599,7 @@
 				 chan_mask);
 }
 
-static int aaci_pcm_playback_open(struct snd_pcm_substream *substream)
+static int aaci_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct aaci *aaci = substream->private_data;
 	int ret;
@@ -519,7 +614,12 @@
 	if (ret)
 		return ret;
 
-	return aaci_pcm_open(aaci, substream, &aaci->playback);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		ret = __aaci_pcm_open(aaci, substream, &aaci->playback);
+	} else {
+		ret = __aaci_pcm_open(aaci, substream, &aaci->capture);
+	}
+	return ret;
 }
 
 static int aaci_pcm_playback_hw_params(struct snd_pcm_substream *substream,
@@ -540,11 +640,11 @@
 	 * FIXME: double rate slots?
 	 */
 	if (ret >= 0) {
-		aacirun->cr = TXCR_FEN | TXCR_COMPACT | TXCR_TSZ16;
+		aacirun->cr = CR_FEN | CR_COMPACT | CR_SZ16;
 		aacirun->cr |= channels_to_txmask[channels];
 
 		aacirun->fifosz	= aaci->fifosize * 4;
-		if (aacirun->cr & TXCR_COMPACT)
+		if (aacirun->cr & CR_COMPACT)
 			aacirun->fifosz >>= 1;
 	}
 	return ret;
@@ -557,7 +657,7 @@
 	ie = readl(aacirun->base + AACI_IE);
 	ie &= ~(IE_URIE|IE_TXIE);
 	writel(ie, aacirun->base + AACI_IE);
-	aacirun->cr &= ~TXCR_TXEN;
+	aacirun->cr &= ~CR_EN;
 	aaci_chan_wait_ready(aacirun);
 	writel(aacirun->cr, aacirun->base + AACI_TXCR);
 }
@@ -567,7 +667,7 @@
 	u32 ie;
 
 	aaci_chan_wait_ready(aacirun);
-	aacirun->cr |= TXCR_TXEN;
+	aacirun->cr |= CR_EN;
 
 	ie = readl(aacirun->base + AACI_IE);
 	ie |= IE_URIE | IE_TXIE;
@@ -615,7 +715,7 @@
 }
 
 static struct snd_pcm_ops aaci_playback_ops = {
-	.open		= aaci_pcm_playback_open,
+	.open		= aaci_pcm_open,
 	.close		= aaci_pcm_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= aaci_pcm_playback_hw_params,
@@ -626,7 +726,133 @@
 	.mmap		= aaci_pcm_mmap,
 };
 
+static int aaci_pcm_capture_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct aaci *aaci = substream->private_data;
+	struct aaci_runtime *aacirun = substream->runtime->private_data;
+	int ret;
+
+	ret = aaci_pcm_hw_params(substream, aacirun, params);
+
+	if (ret >= 0) {
+		aacirun->cr = CR_FEN | CR_COMPACT | CR_SZ16;
+
+		/* Line in record: slot 3 and 4 */
+		aacirun->cr |= CR_SL3 | CR_SL4;
+
+		aacirun->fifosz = aaci->fifosize * 4;
+
+		if (aacirun->cr & CR_COMPACT)
+			aacirun->fifosz >>= 1;
+	}
+	return ret;
+}
+
+static void aaci_pcm_capture_stop(struct aaci_runtime *aacirun)
+{
+	u32 ie;
+
+	aaci_chan_wait_ready(aacirun);
+
+	ie = readl(aacirun->base + AACI_IE);
+	ie &= ~(IE_ORIE | IE_RXIE);
+	writel(ie, aacirun->base+AACI_IE);
+
+	aacirun->cr &= ~CR_EN;
+
+	writel(aacirun->cr, aacirun->base + AACI_RXCR);
+}
+
+static void aaci_pcm_capture_start(struct aaci_runtime *aacirun)
+{
+	u32 ie;
+
+	aaci_chan_wait_ready(aacirun);
+
+#ifdef DEBUG
+	/* RX Timeout value: bits 28:17 in RXCR */
+	aacirun->cr |= 0xf << 17;
+#endif
+
+	aacirun->cr |= CR_EN;
+	writel(aacirun->cr, aacirun->base + AACI_RXCR);
+
+	ie = readl(aacirun->base + AACI_IE);
+	ie |= IE_ORIE |IE_RXIE; // overrun and rx interrupt -- half full
+	writel(ie, aacirun->base + AACI_IE);
+}
+
+static int aaci_pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct aaci *aaci = substream->private_data;
+	struct aaci_runtime *aacirun = substream->runtime->private_data;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&aaci->lock, flags);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		aaci_pcm_capture_start(aacirun);
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		aaci_pcm_capture_start(aacirun);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		aaci_pcm_capture_stop(aacirun);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		aaci_pcm_capture_stop(aacirun);
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&aaci->lock, flags);
+
+	return ret;
+}
 
+static int aaci_pcm_capture_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct aaci *aaci = substream->private_data;
+
+	aaci_pcm_prepare(substream);
+
+	/* allow changing of sample rate */
+	aaci_ac97_write(aaci->ac97, AC97_EXTENDED_STATUS, 0x0001); /* VRA */
+	aaci_ac97_write(aaci->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);
+	aaci_ac97_write(aaci->ac97, AC97_PCM_MIC_ADC_RATE, runtime->rate);
+
+	/* Record select: Mic: 0, Aux: 3, Line: 4 */
+	aaci_ac97_write(aaci->ac97, AC97_REC_SEL, 0x0404);
+
+	return 0;
+}
+
+static struct snd_pcm_ops aaci_capture_ops = {
+	.open		= aaci_pcm_open,
+	.close		= aaci_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= aaci_pcm_capture_hw_params,
+	.hw_free	= aaci_pcm_hw_free,
+	.prepare	= aaci_pcm_capture_prepare,
+	.trigger	= aaci_pcm_capture_trigger,
+	.pointer	= aaci_pcm_pointer,
+	.mmap		= aaci_pcm_mmap,
+};
 
 /*
  * Power Management.
@@ -666,7 +892,7 @@
 
 
 static struct ac97_pcm ac97_defs[] __devinitdata = {
-	[0] = {		/* Front PCM */
+	[0] = {	/* Front PCM */
 		.exclusive = 1,
 		.r = {
 			[0] = {
@@ -740,6 +966,7 @@
 	ret = snd_ac97_mixer(ac97_bus, &ac97_template, &ac97);
 	if (ret)
 		goto out;
+	aaci->ac97 = ac97;
 
 	/*
 	 * Disable AC97 PC Beep input on audio codecs.
@@ -752,6 +979,7 @@
 		goto out;
 
 	aaci->playback.pcm = &ac97_bus->pcms[0];
+	aaci->capture.pcm  = &ac97_bus->pcms[1];
 
  out:
 	return ret;
@@ -801,7 +1029,7 @@
 	struct snd_pcm *pcm;
 	int ret;
 
-	ret = snd_pcm_new(aaci->card, "AACI AC'97", 0, 1, 0, &pcm);
+	ret = snd_pcm_new(aaci->card, "AACI AC'97", 0, 1, 1, &pcm);
 	if (ret == 0) {
 		aaci->pcm = pcm;
 		pcm->private_data = aaci;
@@ -810,6 +1038,7 @@
 		strlcpy(pcm->name, DRIVER_NAME, sizeof(pcm->name));
 
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &aaci_playback_ops);
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &aaci_capture_ops);
 	}
 
 	return ret;
@@ -817,15 +1046,15 @@
 
 static unsigned int __devinit aaci_size_fifo(struct aaci *aaci)
 {
-	void __iomem *base = aaci->base + AACI_CSCH1;
+	struct aaci_runtime *aacirun = &aaci->playback;
 	int i;
 
-	writel(TXCR_FEN | TXCR_TSZ16 | TXCR_TXEN, base + AACI_TXCR);
+	writel(CR_FEN | CR_SZ16 | CR_EN, aacirun->base + AACI_TXCR);
 
-	for (i = 0; !(readl(base + AACI_SR) & SR_TXFF) && i < 4096; i++)
-		writel(0, aaci->base + AACI_DR1);
+	for (i = 0; !(readl(aacirun->base + AACI_SR) & SR_TXFF) && i < 4096; i++)
+		writel(0, aacirun->fifo);
 
-	writel(0, base + AACI_TXCR);
+	writel(0, aacirun->base + AACI_TXCR);
 
 	/*
 	 * Re-initialise the AACI after the FIFO depth test, to
@@ -872,6 +1101,12 @@
 	aaci->playback.base = aaci->base + AACI_CSCH1;
 	aaci->playback.fifo = aaci->base + AACI_DR1;
 
+	/*
+	 * Capture uses AACI channel 0
+	 */
+	aaci->capture.base = aaci->base + AACI_CSCH1;
+	aaci->capture.fifo = aaci->base + AACI_DR1;
+
 	for (i = 0; i < 4; i++) {
 		void __iomem *base = aaci->base + i * 0x14;
 
@@ -907,7 +1142,7 @@
 	ret = snd_card_register(aaci->card);
 	if (ret == 0) {
 		dev_info(&dev->dev, "%s, fifo %d\n", aaci->card->longname,
-			aaci->fifosize);
+			 aaci->fifosize);
 		amba_set_drvdata(dev, aaci->card);
 		return ret;
 	}
--- linux-2.6.18.noarch/sound/arm/sa11xx-uda1341.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/arm/sa11xx-uda1341.c	2007-06-05 17:40:13.000000000 -0400
@@ -125,7 +125,7 @@
 #else
 	dma_regs_t *dma_regs;	/* points to our DMA registers */
 #endif
-	int active:1;		/* we are using this stream for transfer now */
+	unsigned int active:1;	/* we are using this stream for transfer now */
 	int period;		/* current transfer period */
 	int periods;		/* current count of periods registerd in the DMA engine */
 	int tx_spin;		/* are we recoding - flag used to do DMA trans. for sync */
--- linux-2.6.18.noarch/sound/drivers/virmidi.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/virmidi.c	2007-06-05 17:41:32.000000000 -0400
@@ -44,7 +44,6 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/wait.h>
-#include <linux/sched.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
 #include <linux/moduleparam.h>
--- linux-2.6.18.noarch/sound/drivers/dummy.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/dummy.c	2007-06-05 17:41:32.000000000 -0400
@@ -29,6 +29,7 @@
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/initval.h>
@@ -285,7 +286,7 @@
 	.channels_max =		USE_CHANNELS_MAX,
 	.buffer_bytes_max =	MAX_BUFFER_SIZE,
 	.period_bytes_min =	64,
-	.period_bytes_max =	MAX_BUFFER_SIZE,
+	.period_bytes_max =	MAX_PERIOD_SIZE,
 	.periods_min =		USE_PERIODS_MIN,
 	.periods_max =		USE_PERIODS_MAX,
 	.fifo_size =		0,
@@ -422,7 +423,8 @@
 	.pointer =		snd_card_dummy_pcm_pointer,
 };
 
-static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device, int substreams)
+static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
+					int substreams)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -443,10 +445,13 @@
 }
 
 #define DUMMY_VOLUME(xname, xindex, addr) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .index = xindex, \
   .info = snd_dummy_volume_info, \
   .get = snd_dummy_volume_get, .put = snd_dummy_volume_put, \
-  .private_value = addr }
+  .private_value = addr, \
+  .tlv = { .p = db_scale_dummy } }
 
 static int snd_dummy_volume_info(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_info *uinfo)
@@ -497,6 +502,8 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_dummy, -4500, 30, 0);
+
 #define DUMMY_CAPSRC(xname, xindex, addr) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_dummy_capsrc_info, \
@@ -547,13 +554,13 @@
 DUMMY_VOLUME("Master Volume", 0, MIXER_ADDR_MASTER),
 DUMMY_CAPSRC("Master Capture Switch", 0, MIXER_ADDR_MASTER),
 DUMMY_VOLUME("Synth Volume", 0, MIXER_ADDR_SYNTH),
-DUMMY_CAPSRC("Synth Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Synth Capture Switch", 0, MIXER_ADDR_SYNTH),
 DUMMY_VOLUME("Line Volume", 0, MIXER_ADDR_LINE),
-DUMMY_CAPSRC("Line Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Line Capture Switch", 0, MIXER_ADDR_LINE),
 DUMMY_VOLUME("Mic Volume", 0, MIXER_ADDR_MIC),
-DUMMY_CAPSRC("Mic Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Mic Capture Switch", 0, MIXER_ADDR_MIC),
 DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_CD),
-DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_MASTER)
+DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_CD)
 };
 
 static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
--- linux-2.6.18.noarch/sound/drivers/Makefile.orig	2007-06-05 16:07:46.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/Makefile	2007-06-05 17:41:32.000000000 -0400
@@ -5,6 +5,8 @@
 
 snd-dummy-objs := dummy.o
 snd-mtpav-objs := mtpav.o
+snd-mts64-objs := mts64.o
+snd-portman2x4-objs := portman2x4.o
 snd-serial-u16550-objs := serial-u16550.o
 snd-virmidi-objs := virmidi.o
 
@@ -13,5 +15,7 @@
 obj-$(CONFIG_SND_VIRMIDI) += snd-virmidi.o
 obj-$(CONFIG_SND_SERIAL_U16550) += snd-serial-u16550.o
 obj-$(CONFIG_SND_MTPAV) += snd-mtpav.o
+obj-$(CONFIG_SND_MTS64) += snd-mts64.o
+obj-$(CONFIG_SND_PORTMAN2X4) += snd-portman2x4.o
 
 obj-$(CONFIG_SND) += opl3/ opl4/ mpu401/ vx/
--- linux-2.6.18.noarch/sound/drivers/mts64.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/mts64.c	2007-06-05 17:41:32.000000000 -0400
@@ -0,0 +1,1091 @@
+/*     
+ *   ALSA Driver for Ego Systems Inc. (ESI) Miditerminal 4140
+ *   Copyright (c) 2006 by Matthias Knig <mk@phasorlab.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of the GNU General Public License as published by 
+ *   the Free Software Foundation; either version 2 of the License, or 
+ *   (at your option) any later version. 
+ *
+ *   This program is distributed in the hope that it will be useful, 
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/parport.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/rawmidi.h>
+#include <sound/control.h>
+
+#define CARD_NAME "Miditerminal 4140"
+#define DRIVER_NAME "MTS64"
+#define PLATFORM_DRIVER "snd_mts64"
+
+static int index[SNDRV_CARDS]  = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS]   = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+static struct platform_device *platform_devices[SNDRV_CARDS]; 
+static int device_count;
+
+module_param_array(index, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
+module_param_array(id, charp, NULL, S_IRUGO);
+MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
+module_param_array(enable, bool, NULL, S_IRUGO);
+MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
+
+MODULE_AUTHOR("Matthias Koenig <mk@phasorlab.de>");
+MODULE_DESCRIPTION("ESI Miditerminal 4140");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{ESI,Miditerminal 4140}}");
+
+/*********************************************************************
+ * Chip specific
+ *********************************************************************/
+#define MTS64_NUM_INPUT_PORTS 5
+#define MTS64_NUM_OUTPUT_PORTS 4
+#define MTS64_SMPTE_SUBSTREAM 4
+
+struct mts64 {
+	spinlock_t lock;
+	struct snd_card *card;
+	struct snd_rawmidi *rmidi;
+	struct pardevice *pardev;
+	int pardev_claimed;
+
+	int open_count;
+	int current_midi_output_port;
+	int current_midi_input_port;
+	u8 mode[MTS64_NUM_INPUT_PORTS];
+	struct snd_rawmidi_substream *midi_input_substream[MTS64_NUM_INPUT_PORTS];
+	int smpte_switch;
+	u8 time[4]; /* [0]=hh, [1]=mm, [2]=ss, [3]=ff */
+	u8 fps;
+};
+
+static int snd_mts64_free(struct mts64 *mts)
+{
+	kfree(mts);
+	return 0;
+}
+
+static int __devinit snd_mts64_create(struct snd_card *card, 
+				      struct pardevice *pardev, 
+				      struct mts64 **rchip)
+{
+	struct mts64 *mts;
+
+	*rchip = NULL;
+
+	mts = kzalloc(sizeof(struct mts64), GFP_KERNEL);
+	if (mts == NULL) 
+		return -ENOMEM;
+
+	/* Init chip specific data */
+	spin_lock_init(&mts->lock);
+	mts->card = card;
+	mts->pardev = pardev;
+	mts->current_midi_output_port = -1;
+	mts->current_midi_input_port = -1;
+
+	*rchip = mts;
+
+	return 0;
+}
+
+/*********************************************************************
+ * HW register related constants
+ *********************************************************************/
+
+/* Status Bits */
+#define MTS64_STAT_BSY             0x80
+#define MTS64_STAT_BIT_SET         0x20  /* readout process, bit is set */
+#define MTS64_STAT_PORT            0x10  /* read byte is a port number */
+
+/* Control Bits */
+#define MTS64_CTL_READOUT          0x08  /* enable readout */
+#define MTS64_CTL_WRITE_CMD        0x06  
+#define MTS64_CTL_WRITE_DATA       0x02  
+#define MTS64_CTL_STROBE           0x01  
+
+/* Command */
+#define MTS64_CMD_RESET            0xfe
+#define MTS64_CMD_PROBE            0x8f  /* Used in probing procedure */
+#define MTS64_CMD_SMPTE_SET_TIME   0xe8
+#define MTS64_CMD_SMPTE_SET_FPS    0xee
+#define MTS64_CMD_SMPTE_STOP       0xef
+#define MTS64_CMD_SMPTE_FPS_24     0xe3
+#define MTS64_CMD_SMPTE_FPS_25     0xe2
+#define MTS64_CMD_SMPTE_FPS_2997   0xe4 
+#define MTS64_CMD_SMPTE_FPS_30D    0xe1
+#define MTS64_CMD_SMPTE_FPS_30     0xe0
+#define MTS64_CMD_COM_OPEN         0xf8  /* setting the communication mode */
+#define MTS64_CMD_COM_CLOSE1       0xff  /* clearing communication mode */
+#define MTS64_CMD_COM_CLOSE2       0xf5
+
+/*********************************************************************
+ * Hardware specific functions
+ *********************************************************************/
+static void mts64_enable_readout(struct parport *p);
+static void mts64_disable_readout(struct parport *p);
+static int mts64_device_ready(struct parport *p);
+static int mts64_device_init(struct parport *p);
+static int mts64_device_open(struct mts64 *mts);
+static int mts64_device_close(struct mts64 *mts);
+static u8 mts64_map_midi_input(u8 c);
+static int mts64_probe(struct parport *p);
+static u16 mts64_read(struct parport *p);
+static u8 mts64_read_char(struct parport *p);
+static void mts64_smpte_start(struct parport *p,
+			      u8 hours, u8 minutes,
+			      u8 seconds, u8 frames,
+			      u8 idx);
+static void mts64_smpte_stop(struct parport *p);
+static void mts64_write_command(struct parport *p, u8 c);
+static void mts64_write_data(struct parport *p, u8 c);
+static void mts64_write_midi(struct mts64 *mts, u8 c, int midiport);
+
+
+/*  Enables the readout procedure
+ *
+ *  Before we can read a midi byte from the device, we have to set
+ *  bit 3 of control port.
+ */
+static void mts64_enable_readout(struct parport *p)
+{
+	u8 c;
+
+	c = parport_read_control(p);
+	c |= MTS64_CTL_READOUT;
+	parport_write_control(p, c); 
+}
+
+/*  Disables readout 
+ *
+ *  Readout is disabled by clearing bit 3 of control
+ */
+static void mts64_disable_readout(struct parport *p)
+{
+	u8 c;
+
+	c = parport_read_control(p);
+	c &= ~MTS64_CTL_READOUT;
+	parport_write_control(p, c);
+}
+
+/*  waits for device ready
+ *
+ *  Checks if BUSY (Bit 7 of status) is clear
+ *  1 device ready
+ *  0 failure
+ */
+static int mts64_device_ready(struct parport *p)
+{
+	int i;
+	u8 c;
+
+	for (i = 0; i < 0xffff; ++i) {
+		c = parport_read_status(p);
+		c &= MTS64_STAT_BSY;
+		if (c != 0) 
+			return 1;
+	} 
+
+	return 0;
+}
+
+/*  Init device (LED blinking startup magic)
+ *
+ *  Returns:
+ *  0 init ok
+ *  -EIO failure
+ */
+static int __devinit mts64_device_init(struct parport *p)
+{
+	int i;
+
+	mts64_write_command(p, MTS64_CMD_RESET);
+
+	for (i = 0; i < 64; ++i) {
+		msleep(100);
+
+		if (mts64_probe(p) == 0) {
+			/* success */
+			mts64_disable_readout(p);
+			return 0;
+		}
+	}
+	mts64_disable_readout(p);
+
+	return -EIO;
+}
+
+/* 
+ *  Opens the device (set communication mode)
+ */
+static int mts64_device_open(struct mts64 *mts)
+{
+	int i;
+	struct parport *p = mts->pardev->port;
+
+	for (i = 0; i < 5; ++i)
+		mts64_write_command(p, MTS64_CMD_COM_OPEN);
+
+	return 0;
+}
+
+/*  
+ *  Close device (clear communication mode)
+ */
+static int mts64_device_close(struct mts64 *mts)
+{
+	int i;
+	struct parport *p = mts->pardev->port;
+
+	for (i = 0; i < 5; ++i) {
+		mts64_write_command(p, MTS64_CMD_COM_CLOSE1);
+		mts64_write_command(p, MTS64_CMD_COM_CLOSE2);
+	}
+
+	return 0;
+}
+
+/*  map hardware port to substream number
+ * 
+ *  When reading a byte from the device, the device tells us
+ *  on what port the byte is. This HW port has to be mapped to
+ *  the midiport (substream number).
+ *  substream 0-3 are Midiports 1-4
+ *  substream 4 is SMPTE Timecode
+ *  The mapping is done by the table:
+ *  HW | 0 | 1 | 2 | 3 | 4 
+ *  SW | 0 | 1 | 4 | 2 | 3
+ */
+static u8 mts64_map_midi_input(u8 c)
+{
+	static u8 map[] = { 0, 1, 4, 2, 3 };
+
+	return map[c];
+}
+
+
+/*  Probe parport for device
+ *
+ *  Do we have a Miditerminal 4140 on parport? 
+ *  Returns:
+ *  0       device found
+ *  -ENODEV no device
+ */
+static int __devinit mts64_probe(struct parport *p)
+{
+	u8 c;
+
+	mts64_smpte_stop(p);
+	mts64_write_command(p, MTS64_CMD_PROBE);
+
+	msleep(50);
+	
+	c = mts64_read(p);
+
+	c &= 0x00ff;
+	if (c != MTS64_CMD_PROBE) 
+		return -ENODEV;
+	else 
+		return 0;
+
+}
+
+/*  Read byte incl. status from device
+ *
+ *  Returns:
+ *  data in lower 8 bits and status in upper 8 bits
+ */
+static u16 mts64_read(struct parport *p)
+{
+	u8 data, status;
+
+	mts64_device_ready(p);
+	mts64_enable_readout(p);
+	status = parport_read_status(p);
+	data = mts64_read_char(p);
+	mts64_disable_readout(p);
+
+	return (status << 8) | data;
+}
+
+/*  Read a byte from device
+ *
+ *  Note, that readout mode has to be enabled.
+ *  readout procedure is as follows: 
+ *  - Write number of the Bit to read to DATA
+ *  - Read STATUS
+ *  - Bit 5 of STATUS indicates if Bit is set
+ *
+ *  Returns:
+ *  Byte read from device
+ */
+static u8 mts64_read_char(struct parport *p)
+{
+	u8 c = 0;
+	u8 status;
+	u8 i;
+
+	for (i = 0; i < 8; ++i) {
+		parport_write_data(p, i);
+		c >>= 1;
+		status = parport_read_status(p);
+		if (status & MTS64_STAT_BIT_SET) 
+			c |= 0x80;
+	}
+	
+	return c;
+}
+
+/*  Starts SMPTE Timecode generation
+ *
+ *  The device creates SMPTE Timecode by hardware.
+ *  0 24 fps
+ *  1 25 fps
+ *  2 29.97 fps
+ *  3 30 fps (Drop-frame)
+ *  4 30 fps
+ */
+static void mts64_smpte_start(struct parport *p,
+			      u8 hours, u8 minutes,
+			      u8 seconds, u8 frames,
+			      u8 idx)
+{
+	static u8 fps[5] = { MTS64_CMD_SMPTE_FPS_24, 
+			     MTS64_CMD_SMPTE_FPS_25,
+			     MTS64_CMD_SMPTE_FPS_2997, 
+			     MTS64_CMD_SMPTE_FPS_30D,
+			     MTS64_CMD_SMPTE_FPS_30    };
+
+	mts64_write_command(p, MTS64_CMD_SMPTE_SET_TIME);
+	mts64_write_command(p, frames);
+	mts64_write_command(p, seconds);
+	mts64_write_command(p, minutes);
+	mts64_write_command(p, hours);
+
+	mts64_write_command(p, MTS64_CMD_SMPTE_SET_FPS);
+	mts64_write_command(p, fps[idx]);
+}
+
+/*  Stops SMPTE Timecode generation
+ */
+static void mts64_smpte_stop(struct parport *p)
+{
+	mts64_write_command(p, MTS64_CMD_SMPTE_STOP);
+}
+
+/*  Write a command byte to device
+ */
+static void mts64_write_command(struct parport *p, u8 c)
+{
+	mts64_device_ready(p);
+
+	parport_write_data(p, c);
+
+	parport_write_control(p, MTS64_CTL_WRITE_CMD);
+	parport_write_control(p, MTS64_CTL_WRITE_CMD | MTS64_CTL_STROBE);
+	parport_write_control(p, MTS64_CTL_WRITE_CMD);
+}
+
+/*  Write a data byte to device 
+ */
+static void mts64_write_data(struct parport *p, u8 c)
+{
+	mts64_device_ready(p);
+
+	parport_write_data(p, c);
+
+	parport_write_control(p, MTS64_CTL_WRITE_DATA);
+	parport_write_control(p, MTS64_CTL_WRITE_DATA | MTS64_CTL_STROBE);
+	parport_write_control(p, MTS64_CTL_WRITE_DATA);
+}
+
+/*  Write a MIDI byte to midiport
+ *
+ *  midiport ranges from 0-3 and maps to Ports 1-4
+ *  assumptions: communication mode is on
+ */
+static void mts64_write_midi(struct mts64 *mts, u8 c,
+			     int midiport)
+{
+	struct parport *p = mts->pardev->port;
+
+	/* check current midiport */
+	if (mts->current_midi_output_port != midiport)
+		mts64_write_command(p, midiport);
+
+	/* write midi byte */
+	mts64_write_data(p, c);
+}
+
+/*********************************************************************
+ * Control elements
+ *********************************************************************/
+
+/* SMPTE Switch */
+static int snd_mts64_ctl_smpte_switch_info(struct snd_kcontrol *kctl,
+					   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_switch_get(struct snd_kcontrol* kctl,
+					  struct snd_ctl_elem_value *uctl)
+{
+	struct mts64 *mts = snd_kcontrol_chip(kctl);
+
+	spin_lock_irq(&mts->lock);
+	uctl->value.integer.value[0] = mts->smpte_switch;
+	spin_unlock_irq(&mts->lock);
+
+	return 0;
+}
+
+/* smpte_switch is not accessed from IRQ handler, so we just need
+   to protect the HW access */
+static int snd_mts64_ctl_smpte_switch_put(struct snd_kcontrol* kctl,
+					  struct snd_ctl_elem_value *uctl)
+{
+	struct mts64 *mts = snd_kcontrol_chip(kctl);
+	int changed = 0;
+
+	spin_lock_irq(&mts->lock);
+	if (mts->smpte_switch == uctl->value.integer.value[0])
+		goto __out;
+
+	changed = 1;
+	mts->smpte_switch = uctl->value.integer.value[0];
+	if (mts->smpte_switch) {
+		mts64_smpte_start(mts->pardev->port,
+				  mts->time[0], mts->time[1],
+				  mts->time[2], mts->time[3],
+				  mts->fps);
+	} else {
+		mts64_smpte_stop(mts->pardev->port);
+	}
+__out:
+	spin_unlock_irq(&mts->lock);
+	return changed;
+}
+
+static struct snd_kcontrol_new mts64_ctl_smpte_switch __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,
+	.name  = "SMPTE Playback Switch",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 0,
+	.info = snd_mts64_ctl_smpte_switch_info,
+	.get  = snd_mts64_ctl_smpte_switch_get,
+	.put  = snd_mts64_ctl_smpte_switch_put
+};
+
+/* Time */
+static int snd_mts64_ctl_smpte_time_h_info(struct snd_kcontrol *kctl,
+					   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 23;
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_time_f_info(struct snd_kcontrol *kctl,
+					   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 99;
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_time_info(struct snd_kcontrol *kctl,
+					 struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 59;
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_time_get(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_value *uctl)
+{
+	struct mts64 *mts = snd_kcontrol_chip(kctl);
+	int idx = kctl->private_value;
+
+	spin_lock_irq(&mts->lock);
+	uctl->value.integer.value[0] = mts->time[idx];
+	spin_unlock_irq(&mts->lock);
+
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_time_put(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_value *uctl)
+{
+	struct mts64 *mts = snd_kcontrol_chip(kctl);
+	int idx = kctl->private_value;
+	int changed = 0;
+
+	spin_lock_irq(&mts->lock);
+	if (mts->time[idx] != uctl->value.integer.value[0]) {
+		changed = 1;
+		mts->time[idx] = uctl->value.integer.value[0];
+	}
+	spin_unlock_irq(&mts->lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new mts64_ctl_smpte_time_hours __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,
+	.name  = "SMPTE Time Hours",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 0,
+	.info = snd_mts64_ctl_smpte_time_h_info,
+	.get  = snd_mts64_ctl_smpte_time_get,
+	.put  = snd_mts64_ctl_smpte_time_put
+};
+
+static struct snd_kcontrol_new mts64_ctl_smpte_time_minutes __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,
+	.name  = "SMPTE Time Minutes",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 1,
+	.info = snd_mts64_ctl_smpte_time_info,
+	.get  = snd_mts64_ctl_smpte_time_get,
+	.put  = snd_mts64_ctl_smpte_time_put
+};
+
+static struct snd_kcontrol_new mts64_ctl_smpte_time_seconds __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,
+	.name  = "SMPTE Time Seconds",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 2,
+	.info = snd_mts64_ctl_smpte_time_info,
+	.get  = snd_mts64_ctl_smpte_time_get,
+	.put  = snd_mts64_ctl_smpte_time_put
+};
+
+static struct snd_kcontrol_new mts64_ctl_smpte_time_frames __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,
+	.name  = "SMPTE Time Frames",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 3,
+	.info = snd_mts64_ctl_smpte_time_f_info,
+	.get  = snd_mts64_ctl_smpte_time_get,
+	.put  = snd_mts64_ctl_smpte_time_put
+};
+
+/* FPS */
+static int snd_mts64_ctl_smpte_fps_info(struct snd_kcontrol *kctl,
+					struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[5] = { "24",
+				  "25",
+				  "29.97",
+				  "30D",
+				  "30"    };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 5;
+	if (uinfo->value.enumerated.item > 4)
+		uinfo->value.enumerated.item = 4;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_fps_get(struct snd_kcontrol *kctl,
+				       struct snd_ctl_elem_value *uctl)
+{
+	struct mts64 *mts = snd_kcontrol_chip(kctl);
+
+	spin_lock_irq(&mts->lock);
+	uctl->value.enumerated.item[0] = mts->fps;
+	spin_unlock_irq(&mts->lock);
+
+	return 0;
+}
+
+static int snd_mts64_ctl_smpte_fps_put(struct snd_kcontrol *kctl,
+				       struct snd_ctl_elem_value *uctl)
+{
+	struct mts64 *mts = snd_kcontrol_chip(kctl);
+	int changed = 0;
+
+	spin_lock_irq(&mts->lock);
+	if (mts->fps != uctl->value.enumerated.item[0]) {
+		changed = 1;
+		mts->fps = uctl->value.enumerated.item[0];
+	}
+	spin_unlock_irq(&mts->lock);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new mts64_ctl_smpte_fps __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,
+	.name  = "SMPTE Fps",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 0,
+	.info  = snd_mts64_ctl_smpte_fps_info,
+	.get   = snd_mts64_ctl_smpte_fps_get,
+	.put   = snd_mts64_ctl_smpte_fps_put
+};
+
+
+static int __devinit snd_mts64_ctl_create(struct snd_card *card, 
+					  struct mts64 *mts) 
+{
+	int err, i;
+	static struct snd_kcontrol_new *control[] = {
+		&mts64_ctl_smpte_switch,
+		&mts64_ctl_smpte_time_hours,
+		&mts64_ctl_smpte_time_minutes,
+		&mts64_ctl_smpte_time_seconds,
+		&mts64_ctl_smpte_time_frames,
+		&mts64_ctl_smpte_fps,
+	        NULL  };
+
+	for (i = 0; control[i]; ++i) {
+		err = snd_ctl_add(card, snd_ctl_new1(control[i], mts));
+		if (err < 0) {
+			snd_printd("Cannot create control: %s\n", 
+				   control[i]->name);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+/*********************************************************************
+ * Rawmidi
+ *********************************************************************/
+#define MTS64_MODE_INPUT_TRIGGERED 0x01
+
+static int snd_mts64_rawmidi_open(struct snd_rawmidi_substream *substream)
+{
+	struct mts64 *mts = substream->rmidi->private_data;
+
+	if (mts->open_count == 0) {
+		/* We don't need a spinlock here, because this is just called 
+		   if the device has not been opened before. 
+		   So there aren't any IRQs from the device */
+		mts64_device_open(mts);
+
+		msleep(50);
+	}
+	++(mts->open_count);
+
+	return 0;
+}
+
+static int snd_mts64_rawmidi_close(struct snd_rawmidi_substream *substream)
+{
+	struct mts64 *mts = substream->rmidi->private_data;
+	unsigned long flags;
+
+	--(mts->open_count);
+	if (mts->open_count == 0) {
+		/* We need the spinlock_irqsave here because we can still
+		   have IRQs at this point */
+		spin_lock_irqsave(&mts->lock, flags);
+		mts64_device_close(mts);
+		spin_unlock_irqrestore(&mts->lock, flags);
+
+		msleep(500);
+
+	} else if (mts->open_count < 0)
+		mts->open_count = 0;
+
+	return 0;
+}
+
+static void snd_mts64_rawmidi_output_trigger(struct snd_rawmidi_substream *substream,
+					     int up)
+{
+	struct mts64 *mts = substream->rmidi->private_data;
+	u8 data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mts->lock, flags);
+	while (snd_rawmidi_transmit_peek(substream, &data, 1) == 1) {
+		mts64_write_midi(mts, data, substream->number+1);
+		snd_rawmidi_transmit_ack(substream, 1);
+	}
+	spin_unlock_irqrestore(&mts->lock, flags);
+}
+
+static void snd_mts64_rawmidi_input_trigger(struct snd_rawmidi_substream *substream,
+					    int up)
+{
+	struct mts64 *mts = substream->rmidi->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mts->lock, flags);
+	if (up)
+		mts->mode[substream->number] |= MTS64_MODE_INPUT_TRIGGERED;
+	else
+ 		mts->mode[substream->number] &= ~MTS64_MODE_INPUT_TRIGGERED;
+	
+	spin_unlock_irqrestore(&mts->lock, flags);
+}
+
+static struct snd_rawmidi_ops snd_mts64_rawmidi_output_ops = {
+	.open    = snd_mts64_rawmidi_open,
+	.close   = snd_mts64_rawmidi_close,
+	.trigger = snd_mts64_rawmidi_output_trigger
+};
+
+static struct snd_rawmidi_ops snd_mts64_rawmidi_input_ops = {
+	.open    = snd_mts64_rawmidi_open,
+	.close   = snd_mts64_rawmidi_close,
+	.trigger = snd_mts64_rawmidi_input_trigger
+};
+
+/* Create and initialize the rawmidi component */
+static int __devinit snd_mts64_rawmidi_create(struct snd_card *card)
+{
+	struct mts64 *mts = card->private_data;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *substream;
+	struct list_head *list;
+	int err;
+	
+	err = snd_rawmidi_new(card, CARD_NAME, 0, 
+			      MTS64_NUM_OUTPUT_PORTS, 
+			      MTS64_NUM_INPUT_PORTS, 
+			      &rmidi);
+	if (err < 0) 
+		return err;
+
+	rmidi->private_data = mts;
+	strcpy(rmidi->name, CARD_NAME);
+	rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+		            SNDRV_RAWMIDI_INFO_INPUT |
+                            SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	mts->rmidi = rmidi;
+
+	/* register rawmidi ops */
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, 
+			    &snd_mts64_rawmidi_output_ops);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, 
+			    &snd_mts64_rawmidi_input_ops);
+
+	/* name substreams */
+	/* output */
+	list_for_each(list, 
+		      &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {
+		substream = list_entry(list, struct snd_rawmidi_substream, list);
+		sprintf(substream->name,
+			"Miditerminal %d", substream->number+1);
+	}
+	/* input */
+	list_for_each(list, 
+		      &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {
+		substream = list_entry(list, struct snd_rawmidi_substream, list);
+		mts->midi_input_substream[substream->number] = substream;
+		switch(substream->number) {
+		case MTS64_SMPTE_SUBSTREAM:
+			strcpy(substream->name, "Miditerminal SMPTE");
+			break;
+		default:
+			sprintf(substream->name,
+				"Miditerminal %d", substream->number+1);
+		}
+	}
+
+	/* controls */
+	err = snd_mts64_ctl_create(card, mts);
+
+	return err;
+}
+
+/*********************************************************************
+ * parport stuff
+ *********************************************************************/
+static void snd_mts64_interrupt(int irq, void *private)
+{
+	struct mts64 *mts = ((struct snd_card*)private)->private_data;
+	u16 ret;
+	u8 status, data;
+	struct snd_rawmidi_substream *substream;
+
+	spin_lock(&mts->lock);
+	ret = mts64_read(mts->pardev->port);
+	data = ret & 0x00ff;
+	status = ret >> 8;
+
+	if (status & MTS64_STAT_PORT) {
+		mts->current_midi_input_port = mts64_map_midi_input(data);
+	} else {
+		if (mts->current_midi_input_port == -1) 
+			goto __out;
+		substream = mts->midi_input_substream[mts->current_midi_input_port];
+		if (mts->mode[substream->number] & MTS64_MODE_INPUT_TRIGGERED)
+			snd_rawmidi_receive(substream, &data, 1);
+	}
+__out:
+	spin_unlock(&mts->lock);
+}
+
+static int __devinit snd_mts64_probe_port(struct parport *p)
+{
+	struct pardevice *pardev;
+	int res;
+
+	pardev = parport_register_device(p, DRIVER_NAME,
+					 NULL, NULL, NULL,
+					 0, NULL);
+	if (!pardev)
+		return -EIO;
+	
+	if (parport_claim(pardev)) {
+		parport_unregister_device(pardev);
+		return -EIO;
+	}
+
+	res = mts64_probe(p);
+
+	parport_release(pardev);
+	parport_unregister_device(pardev);
+
+	return res;
+}
+
+static void __devinit snd_mts64_attach(struct parport *p)
+{
+	struct platform_device *device;
+
+	device = platform_device_alloc(PLATFORM_DRIVER, device_count);
+	if (!device) 
+		return;
+
+	/* Temporary assignment to forward the parport */
+	platform_set_drvdata(device, p);
+
+	if (platform_device_register(device) < 0) {
+		platform_device_put(device);
+		return;
+	}
+
+	/* Since we dont get the return value of probe
+	 * We need to check if device probing succeeded or not */
+	if (!platform_get_drvdata(device)) {
+		platform_device_unregister(device);
+		return;
+	}
+
+	/* register device in global table */
+	platform_devices[device_count] = device;
+	device_count++;
+}
+
+static void snd_mts64_detach(struct parport *p)
+{
+	/* nothing to do here */
+}
+
+static struct parport_driver mts64_parport_driver = {
+	.name   = "mts64",
+	.attach = snd_mts64_attach,
+	.detach = snd_mts64_detach
+};
+
+/*********************************************************************
+ * platform stuff
+ *********************************************************************/
+static void snd_mts64_card_private_free(struct snd_card *card)
+{
+	struct mts64 *mts = card->private_data;
+	struct pardevice *pardev = mts->pardev;
+
+	if (pardev) {
+		if (mts->pardev_claimed)
+			parport_release(pardev);
+		parport_unregister_device(pardev);
+	}
+
+	snd_mts64_free(mts);
+}
+
+static int __devinit snd_mts64_probe(struct platform_device *pdev)
+{
+	struct pardevice *pardev;
+	struct parport *p;
+	int dev = pdev->id;
+	struct snd_card *card = NULL;
+	struct mts64 *mts = NULL;
+	int err;
+
+	p = platform_get_drvdata(pdev);
+	platform_set_drvdata(pdev, NULL);
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) 
+		return -ENOENT;
+	if ((err = snd_mts64_probe_port(p)) < 0)
+		return err;
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL) {
+		snd_printd("Cannot create card\n");
+		return -ENOMEM;
+	}
+	strcpy(card->driver, DRIVER_NAME);
+	strcpy(card->shortname, "ESI " CARD_NAME);
+	sprintf(card->longname,  "%s at 0x%lx, irq %i", 
+		card->shortname, p->base, p->irq);
+
+	pardev = parport_register_device(p,                   /* port */
+					 DRIVER_NAME,         /* name */
+					 NULL,                /* preempt */
+					 NULL,                /* wakeup */
+					 snd_mts64_interrupt, /* ISR */
+					 PARPORT_DEV_EXCL,    /* flags */
+					 (void *)card);       /* private */
+	if (pardev == NULL) {
+		snd_printd("Cannot register pardevice\n");
+		err = -EIO;
+		goto __err;
+	}
+
+	if ((err = snd_mts64_create(card, pardev, &mts)) < 0) {
+		snd_printd("Cannot create main component\n");
+		parport_unregister_device(pardev);
+		goto __err;
+	}
+	card->private_data = mts;
+	card->private_free = snd_mts64_card_private_free;
+	
+	if ((err = snd_mts64_rawmidi_create(card)) < 0) {
+		snd_printd("Creating Rawmidi component failed\n");
+		goto __err;
+	}
+
+	/* claim parport */
+	if (parport_claim(pardev)) {
+		snd_printd("Cannot claim parport 0x%lx\n", pardev->port->base);
+		err = -EIO;
+		goto __err;
+	}
+	mts->pardev_claimed = 1;
+
+	/* init device */
+	if ((err = mts64_device_init(p)) < 0)
+		goto __err;
+
+	platform_set_drvdata(pdev, card);
+
+	/* At this point card will be usable */
+	if ((err = snd_card_register(card)) < 0) {
+		snd_printd("Cannot register card\n");
+		goto __err;
+	}
+
+	snd_printk("ESI Miditerminal 4140 on 0x%lx\n", p->base);
+	return 0;
+
+__err:
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit snd_mts64_remove(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	if (card)
+		snd_card_free(card);
+
+	return 0;
+}
+
+
+static struct platform_driver snd_mts64_driver = {
+	.probe  = snd_mts64_probe,
+	.remove = __devexit_p(snd_mts64_remove),
+	.driver = {
+		.name = PLATFORM_DRIVER
+	}
+};
+
+/*********************************************************************
+ * module init stuff
+ *********************************************************************/
+static void __init_or_module snd_mts64_unregister_all(void)
+{
+	int i;
+
+	for (i = 0; i < SNDRV_CARDS; ++i) {
+		if (platform_devices[i]) {
+			platform_device_unregister(platform_devices[i]);
+			platform_devices[i] = NULL;
+		}
+	}		
+	platform_driver_unregister(&snd_mts64_driver);
+	parport_unregister_driver(&mts64_parport_driver);
+}
+
+static int __init snd_mts64_module_init(void)
+{
+	int err;
+
+	if ((err = platform_driver_register(&snd_mts64_driver)) < 0)
+		return err;
+
+	if (parport_register_driver(&mts64_parport_driver) != 0) {
+		platform_driver_unregister(&snd_mts64_driver);
+		return -EIO;
+	}
+
+	if (device_count == 0) {
+		snd_mts64_unregister_all();
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit snd_mts64_module_exit(void)
+{
+	snd_mts64_unregister_all();
+}
+
+module_init(snd_mts64_module_init);
+module_exit(snd_mts64_module_exit);
--- linux-2.6.18.noarch/sound/drivers/serial-u16550.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/serial-u16550.c	2007-06-05 17:41:32.000000000 -0400
@@ -117,13 +117,13 @@
 #define SERIAL_MODE_INPUT_TRIGGERED	(1 << 2)
 #define SERIAL_MODE_OUTPUT_TRIGGERED	(1 << 3)
 
-typedef struct _snd_uart16550 {
+struct snd_uart16550 {
 	struct snd_card *card;
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_substream *midi_output[SNDRV_SERIAL_MAX_OUTS];
 	struct snd_rawmidi_substream *midi_input[SNDRV_SERIAL_MAX_INS];
 
-	int filemode;		//open status of file
+	int filemode;		/* open status of file */
 
 	spinlock_t open_lock;
 
@@ -140,39 +140,39 @@
 	unsigned char old_divisor_msb;
 	unsigned char old_line_ctrl_reg;
 
-	// parameter for using of write loop
-	short int fifo_limit;	//used in uart16550
-        short int fifo_count;	//used in uart16550
+	/* parameter for using of write loop */
+	short int fifo_limit;	/* used in uart16550 */
+        short int fifo_count;	/* used in uart16550 */
 
-	// type of adaptor
+	/* type of adaptor */
 	int adaptor;
 
-	// inputs
+	/* inputs */
 	int prev_in;
 	unsigned char rstatus;
 
-	// outputs
+	/* outputs */
 	int prev_out;
 	unsigned char prev_status[SNDRV_SERIAL_MAX_OUTS];
 
-	// write buffer and its writing/reading position
+	/* write buffer and its writing/reading position */
 	unsigned char tx_buff[TX_BUFF_SIZE];
 	int buff_in_count;
         int buff_in;
         int buff_out;
         int drop_on_full;
 
-	// wait timer
+	/* wait timer */
 	unsigned int timer_running:1;
 	struct timer_list buffer_timer;
 
-} snd_uart16550_t;
+};
 
 static struct platform_device *devices[SNDRV_CARDS];
 
-static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
+static inline void snd_uart16550_add_timer(struct snd_uart16550 *uart)
 {
-	if (! uart->timer_running) {
+	if (!uart->timer_running) {
 		/* timer 38600bps * 10bit * 16byte */
 		uart->buffer_timer.expires = jiffies + (HZ+255)/256;
 		uart->timer_running = 1;
@@ -180,7 +180,7 @@
 	}
 }
 
-static inline void snd_uart16550_del_timer(snd_uart16550_t *uart)
+static inline void snd_uart16550_del_timer(struct snd_uart16550 *uart)
 {
 	if (uart->timer_running) {
 		del_timer(&uart->buffer_timer);
@@ -189,10 +189,10 @@
 }
 
 /* This macro is only used in snd_uart16550_io_loop */
-static inline void snd_uart16550_buffer_output(snd_uart16550_t *uart)
+static inline void snd_uart16550_buffer_output(struct snd_uart16550 *uart)
 {
 	unsigned short buff_out = uart->buff_out;
-	if( uart->buff_in_count > 0 ) {
+	if (uart->buff_in_count > 0) {
 		outb(uart->tx_buff[buff_out], uart->base + UART_TX);
 		uart->fifo_count++;
 		buff_out++;
@@ -206,7 +206,7 @@
  * We don't want to interrupt this, 
  * as we're already handling an interrupt 
  */
-static void snd_uart16550_io_loop(snd_uart16550_t * uart)
+static void snd_uart16550_io_loop(struct snd_uart16550 * uart)
 {
 	unsigned char c, status;
 	int substream;
@@ -220,9 +220,8 @@
 		c = inb(uart->base + UART_RX);
 
 		/* keep track of last status byte */
-		if (c & 0x80) {
+		if (c & 0x80)
 			uart->rstatus = c;
-		}
 
 		/* handle stream switch */
 		if (uart->adaptor == SNDRV_SERIAL_GENERIC) {
@@ -230,14 +229,16 @@
 				if (c <= SNDRV_SERIAL_MAX_INS && c > 0)
 					substream = c - 1;
 				if (c != 0xf5)
-					uart->rstatus = 0; /* prevent future bytes from being interpreted as streams */
-			}
-			else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) && (uart->midi_input[substream] != NULL)) {
-				snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
-			}
-		} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) && (uart->midi_input[substream] != NULL)) {
+					/* prevent future bytes from being
+					   interpreted as streams */
+					uart->rstatus = 0;
+			} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN)
+				   && uart->midi_input[substream])
+				snd_rawmidi_receive(uart->midi_input[substream],
+						    &c, 1);
+		} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) &&
+			   uart->midi_input[substream])
 			snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
-		}
 
 		if (status & UART_LSR_OE)
 			snd_printk("%s: Overrun on device at 0x%lx\n",
@@ -250,21 +251,20 @@
 	/* no need of check SERIAL_MODE_OUTPUT_OPEN because if not,
 	   buffer is never filled. */
 	/* Check write status */
-	if (status & UART_LSR_THRE) {
+	if (status & UART_LSR_THRE)
 		uart->fifo_count = 0;
-	}
 	if (uart->adaptor == SNDRV_SERIAL_MS124W_SA
 	   || uart->adaptor == SNDRV_SERIAL_GENERIC) {
 		/* Can't use FIFO, must send only when CTS is true */
 		status = inb(uart->base + UART_MSR);
-		while( (uart->fifo_count == 0) && (status & UART_MSR_CTS) &&
-		      (uart->buff_in_count > 0) ) {
+		while (uart->fifo_count == 0 && (status & UART_MSR_CTS) &&
+		       uart->buff_in_count > 0) {
 		       snd_uart16550_buffer_output(uart);
-		       status = inb( uart->base + UART_MSR );
+		       status = inb(uart->base + UART_MSR);
 		}
 	} else {
 		/* Write loop */
-		while (uart->fifo_count < uart->fifo_limit	/* Can we write ? */
+		while (uart->fifo_count < uart->fifo_limit /* Can we write ? */
 		       && uart->buff_in_count > 0)	/* Do we want to? */
 			snd_uart16550_buffer_output(uart);
 	}
@@ -292,17 +292,18 @@
  * Note that some devices need OUT2 to be set before they will generate
  * interrupts at all. (Possibly tied to an internal pull-up on CTS?)
  */
-static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)
 {
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 
-	uart = (snd_uart16550_t *) dev_id;
+	uart = dev_id;
 	spin_lock(&uart->open_lock);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED) {
 		spin_unlock(&uart->open_lock);
 		return IRQ_NONE;
 	}
-	inb(uart->base + UART_IIR);		/* indicate to the UART that the interrupt has been serviced */
+	/* indicate to the UART that the interrupt has been serviced */
+	inb(uart->base + UART_IIR);
 	snd_uart16550_io_loop(uart);
 	spin_unlock(&uart->open_lock);
 	return IRQ_HANDLED;
@@ -312,9 +313,9 @@
 static void snd_uart16550_buffer_timer(unsigned long data)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 
-	uart = (snd_uart16550_t *)data;
+	uart = (struct snd_uart16550 *)data;
 	spin_lock_irqsave(&uart->open_lock, flags);
 	snd_uart16550_del_timer(uart);
 	snd_uart16550_io_loop(uart);
@@ -326,7 +327,7 @@
  *  return 0 if found
  *  return negative error if not found
  */
-static int __devinit snd_uart16550_detect(snd_uart16550_t *uart)
+static int __devinit snd_uart16550_detect(struct snd_uart16550 *uart)
 {
 	unsigned long io_base = uart->base;
 	int ok;
@@ -343,7 +344,8 @@
 		return -EBUSY;
 	}
 
-	ok = 1;			/* uart detected unless one of the following tests should fail */
+	/* uart detected unless one of the following tests should fail */
+	ok = 1;
 	/* 8 data-bits, 1 stop-bit, parity off, DLAB = 0 */
 	outb(UART_LCR_WLEN8, io_base + UART_LCR); /* Line Control Register */
 	c = inb(io_base + UART_IER);
@@ -368,7 +370,7 @@
 	return ok;
 }
 
-static void snd_uart16550_do_open(snd_uart16550_t * uart)
+static void snd_uart16550_do_open(struct snd_uart16550 * uart)
 {
 	char byte;
 
@@ -460,7 +462,7 @@
 	inb(uart->base + UART_RX);	/* Clear any pre-existing receive interrupt */
 }
 
-static void snd_uart16550_do_close(snd_uart16550_t * uart)
+static void snd_uart16550_do_close(struct snd_uart16550 * uart)
 {
 	if (uart->irq < 0)
 		snd_uart16550_del_timer(uart);
@@ -514,7 +516,7 @@
 static int snd_uart16550_input_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
@@ -528,7 +530,7 @@
 static int snd_uart16550_input_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	uart->filemode &= ~SERIAL_MODE_INPUT_OPEN;
@@ -539,24 +541,24 @@
 	return 0;
 }
 
-static void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream, int up)
+static void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream,
+					int up)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
-	if (up) {
+	if (up)
 		uart->filemode |= SERIAL_MODE_INPUT_TRIGGERED;
-	} else {
+	else
 		uart->filemode &= ~SERIAL_MODE_INPUT_TRIGGERED;
-	}
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
 static int snd_uart16550_output_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
@@ -570,7 +572,7 @@
 static int snd_uart16550_output_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	uart->filemode &= ~SERIAL_MODE_OUTPUT_OPEN;
@@ -581,18 +583,20 @@
 	return 0;
 };
 
-static inline int snd_uart16550_buffer_can_write( snd_uart16550_t *uart, int Num )
+static inline int snd_uart16550_buffer_can_write(struct snd_uart16550 *uart,
+						 int Num)
 {
-	if( uart->buff_in_count + Num < TX_BUFF_SIZE )
+	if (uart->buff_in_count + Num < TX_BUFF_SIZE)
 		return 1;
 	else
 		return 0;
 }
 
-static inline int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned char byte)
+static inline int snd_uart16550_write_buffer(struct snd_uart16550 *uart,
+					     unsigned char byte)
 {
 	unsigned short buff_in = uart->buff_in;
-	if( uart->buff_in_count < TX_BUFF_SIZE ) {
+	if (uart->buff_in_count < TX_BUFF_SIZE) {
 		uart->tx_buff[buff_in] = byte;
 		buff_in++;
 		buff_in &= TX_BUFF_MASK;
@@ -605,12 +609,14 @@
 		return 0;
 }
 
-static int snd_uart16550_output_byte(snd_uart16550_t *uart, struct snd_rawmidi_substream *substream, unsigned char midi_byte)
+static int snd_uart16550_output_byte(struct snd_uart16550 *uart,
+				     struct snd_rawmidi_substream *substream,
+				     unsigned char midi_byte)
 {
-	if (uart->buff_in_count == 0                            /* Buffer empty? */
+	if (uart->buff_in_count == 0                    /* Buffer empty? */
 	    && ((uart->adaptor != SNDRV_SERIAL_MS124W_SA &&
 	    uart->adaptor != SNDRV_SERIAL_GENERIC) ||
-		(uart->fifo_count == 0                               /* FIFO empty? */
+		(uart->fifo_count == 0                  /* FIFO empty? */
 		 && (inb(uart->base + UART_MSR) & UART_MSR_CTS)))) { /* CTS? */
 
 	        /* Tx Buffer Empty - try to write immediately */
@@ -623,12 +629,13 @@
 			        uart->fifo_count++;
 				outb(midi_byte, uart->base + UART_TX);
 			} else {
-			        /* Cannot write (buffer empty) - put char in buffer */
+			        /* Cannot write (buffer empty) -
+				 * put char in buffer */
 				snd_uart16550_write_buffer(uart, midi_byte);
 			}
 		}
 	} else {
-		if( !snd_uart16550_write_buffer(uart, midi_byte) ) {
+		if (!snd_uart16550_write_buffer(uart, midi_byte)) {
 			snd_printk("%s: Buffer overrun on device at 0x%lx\n",
 				   uart->rmidi->name, uart->base);
 			return 0;
@@ -642,9 +649,9 @@
 {
 	unsigned long flags;
 	unsigned char midi_byte, addr_byte;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 	char first;
-	static unsigned long lasttime=0;
+	static unsigned long lasttime = 0;
 	
 	/* Interupts are disabled during the updating of the tx_buff,
 	 * since it is 'bad' to have two processes updating the same
@@ -653,7 +660,7 @@
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 
-	if (uart->irq < 0)	//polling
+	if (uart->irq < 0)	/* polling */
 		snd_uart16550_io_loop(uart);
 
 	if (uart->adaptor == SNDRV_SERIAL_MS124W_MB) {
@@ -671,7 +678,8 @@
 			/* select any combination of the four ports */
 			addr_byte = (substream->number << 4) | 0x08;
 			/* ...except none */
-			if (addr_byte == 0x08) addr_byte = 0xf8;
+			if (addr_byte == 0x08)
+				addr_byte = 0xf8;
 #endif
 			snd_uart16550_output_byte(uart, substream, addr_byte);
 			/* send midi byte */
@@ -679,31 +687,42 @@
 		}
 	} else {
 		first = 0;
-		while( 1 == snd_rawmidi_transmit_peek(substream, &midi_byte, 1) ) {
-			/* Also send F5 after 3 seconds with no data to handle device disconnect */
-			if (first == 0 && (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||
-				uart->adaptor == SNDRV_SERIAL_GENERIC) &&
-			   (uart->prev_out != substream->number || jiffies-lasttime > 3*HZ)) {
+		while (snd_rawmidi_transmit_peek(substream, &midi_byte, 1) == 1) {
+			/* Also send F5 after 3 seconds with no data
+			 * to handle device disconnect */
+			if (first == 0 &&
+			    (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||
+			     uart->adaptor == SNDRV_SERIAL_GENERIC) &&
+			    (uart->prev_out != substream->number ||
+			     jiffies-lasttime > 3*HZ)) {
 
-				if( snd_uart16550_buffer_can_write( uart, 3 ) ) {
+				if (snd_uart16550_buffer_can_write(uart, 3)) {
 					/* Roland Soundcanvas part selection */
-					/* If this substream of the data is different previous
-					   substream in this uart, send the change part event */
+					/* If this substream of the data is
+					 * different previous substream
+					 * in this uart, send the change part
+					 * event
+					 */
 					uart->prev_out = substream->number;
 					/* change part */
-					snd_uart16550_output_byte(uart, substream, 0xf5);
+					snd_uart16550_output_byte(uart, substream,
+								  0xf5);
 					/* data */
-					snd_uart16550_output_byte(uart, substream, uart->prev_out + 1);
-					/* If midi_byte is a data byte, send the previous status byte */
-					if ((midi_byte < 0x80) && (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS))
+					snd_uart16550_output_byte(uart, substream,
+								  uart->prev_out + 1);
+					/* If midi_byte is a data byte,
+					 * send the previous status byte */
+					if (midi_byte < 0x80 &&
+					    uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS)
 						snd_uart16550_output_byte(uart, substream, uart->prev_status[uart->prev_out]);
-				} else if( !uart->drop_on_full )
+				} else if (!uart->drop_on_full)
 					break;
 
 			}
 
 			/* send midi byte */
-			if( !snd_uart16550_output_byte(uart, substream, midi_byte) && !uart->drop_on_full )
+			if (!snd_uart16550_output_byte(uart, substream, midi_byte) &&
+			    !uart->drop_on_full )
 				break;
 
 			if (midi_byte >= 0x80 && midi_byte < 0xf0)
@@ -717,17 +736,17 @@
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
-static void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream, int up)
+static void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream,
+					 int up)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
-	if (up) {
+	if (up)
 		uart->filemode |= SERIAL_MODE_OUTPUT_TRIGGERED;
-	} else {
+	else
 		uart->filemode &= ~SERIAL_MODE_OUTPUT_TRIGGERED;
-	}
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 	if (up)
 		snd_uart16550_output_write(substream);
@@ -747,10 +766,10 @@
 	.trigger =	snd_uart16550_input_trigger,
 };
 
-static int snd_uart16550_free(snd_uart16550_t *uart)
+static int snd_uart16550_free(struct snd_uart16550 *uart)
 {
 	if (uart->irq >= 0)
-		free_irq(uart->irq, (void *)uart);
+		free_irq(uart->irq, uart);
 	release_and_free_resource(uart->res_base);
 	kfree(uart);
 	return 0;
@@ -758,7 +777,7 @@
 
 static int snd_uart16550_dev_free(struct snd_device *device)
 {
-	snd_uart16550_t *uart = device->device_data;
+	struct snd_uart16550 *uart = device->device_data;
 	return snd_uart16550_free(uart);
 }
 
@@ -769,12 +788,12 @@
 				       unsigned int base,
 				       int adaptor,
 				       int droponfull,
-				       snd_uart16550_t **ruart)
+				       struct snd_uart16550 **ruart)
 {
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_uart16550_dev_free,
 	};
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 	int err;
 
 
@@ -795,7 +814,7 @@
 
 	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
 		if (request_irq(irq, snd_uart16550_interrupt,
-				IRQF_DISABLED, "Serial MIDI", (void *) uart)) {
+				IRQF_DISABLED, "Serial MIDI", uart)) {
 			snd_printk("irq %d busy. Using Polling.\n", irq);
 		} else {
 			uart->irq = irq;
@@ -843,23 +862,28 @@
 
 static void __devinit snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 {
-	struct list_head *list;
+	struct snd_rawmidi_substream *substream;
 
-	list_for_each(list, &stream->substreams) {
-		struct snd_rawmidi_substream *substream = list_entry(list, struct snd_rawmidi_substream, list);
+	list_for_each_entry(substream, &stream->substreams, list) {
 		sprintf(substream->name, "Serial MIDI %d", substream->number + 1);
 	}
 }
 
-static int __devinit snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int outs, int ins, struct snd_rawmidi **rmidi)
+static int __devinit snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
+				      int outs, int ins,
+				      struct snd_rawmidi **rmidi)
 {
 	struct snd_rawmidi *rrawmidi;
 	int err;
 
-	if ((err = snd_rawmidi_new(uart->card, "UART Serial MIDI", device, outs, ins, &rrawmidi)) < 0)
+	err = snd_rawmidi_new(uart->card, "UART Serial MIDI", device,
+			      outs, ins, &rrawmidi);
+	if (err < 0)
 		return err;
-	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_uart16550_input);
-	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_uart16550_output);
+	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+			    &snd_uart16550_input);
+	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &snd_uart16550_output);
 	strcpy(rrawmidi->name, "Serial MIDI");
 	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);
 	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);
@@ -875,7 +899,7 @@
 static int __devinit snd_serial_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 	int err;
 	int dev = devptr->id;
 
@@ -929,7 +953,8 @@
 					&uart)) < 0)
 		goto _err;
 
-	if ((err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi)) < 0)
+	err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi);
+	if (err < 0)
 		goto _err;
 
 	sprintf(card->longname, "%s at 0x%lx, irq %d speed %d div %d outs %d ins %d adaptor %s droponfull %d",
--- linux-2.6.18.noarch/sound/drivers/portman2x4.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/portman2x4.c	2007-06-05 17:41:32.000000000 -0400
@@ -0,0 +1,876 @@
+/*
+ *   Driver for Midiman Portman2x4 parallel port midi interface
+ *
+ *   Copyright (c) by Levent Guendogdu <levon@feature-it.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * ChangeLog
+ * Jan 24 2007 Matthias Koenig <mkoenig@suse.de>
+ *      - cleanup and rewrite
+ * Sep 30 2004 Tobias Gehrig <tobias@gehrig.tk>
+ *      - source code cleanup
+ * Sep 03 2004 Tobias Gehrig <tobias@gehrig.tk>
+ *      - fixed compilation problem with alsa 1.0.6a (removed MODULE_CLASSES,
+ *        MODULE_PARM_SYNTAX and changed MODULE_DEVICES to
+ *        MODULE_SUPPORTED_DEVICE)
+ * Mar 24 2004 Tobias Gehrig <tobias@gehrig.tk>
+ *      - added 2.6 kernel support
+ * Mar 18 2004 Tobias Gehrig <tobias@gehrig.tk>
+ *      - added parport_unregister_driver to the startup routine if the driver fails to detect a portman
+ *      - added support for all 4 output ports in portman_putmidi
+ * Mar 17 2004 Tobias Gehrig <tobias@gehrig.tk>
+ *      - added checks for opened input device in interrupt handler
+ * Feb 20 2004 Tobias Gehrig <tobias@gehrig.tk>
+ *      - ported from alsa 0.5 to 1.0
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/parport.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/rawmidi.h>
+#include <sound/control.h>
+
+#define CARD_NAME "Portman 2x4"
+#define DRIVER_NAME "portman"
+#define PLATFORM_DRIVER "snd_portman2x4"
+
+static int index[SNDRV_CARDS]  = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS]   = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+static struct platform_device *platform_devices[SNDRV_CARDS]; 
+static int device_count;
+
+module_param_array(index, int, NULL, S_IRUGO);
+MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
+module_param_array(id, charp, NULL, S_IRUGO);
+MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
+module_param_array(enable, bool, NULL, S_IRUGO);
+MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
+
+MODULE_AUTHOR("Levent Guendogdu, Tobias Gehrig, Matthias Koenig");
+MODULE_DESCRIPTION("Midiman Portman2x4");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Midiman,Portman2x4}}");
+
+/*********************************************************************
+ * Chip specific
+ *********************************************************************/
+#define PORTMAN_NUM_INPUT_PORTS 2
+#define PORTMAN_NUM_OUTPUT_PORTS 4
+
+struct portman {
+	spinlock_t reg_lock;
+	struct snd_card *card;
+	struct snd_rawmidi *rmidi;
+	struct pardevice *pardev;
+	int pardev_claimed;
+
+	int open_count;
+	int mode[PORTMAN_NUM_INPUT_PORTS];
+	struct snd_rawmidi_substream *midi_input[PORTMAN_NUM_INPUT_PORTS];
+};
+
+static int portman_free(struct portman *pm)
+{
+	kfree(pm);
+	return 0;
+}
+
+static int __devinit portman_create(struct snd_card *card, 
+				    struct pardevice *pardev, 
+				    struct portman **rchip)
+{
+	struct portman *pm;
+
+	*rchip = NULL;
+
+	pm = kzalloc(sizeof(struct portman), GFP_KERNEL);
+	if (pm == NULL) 
+		return -ENOMEM;
+
+	/* Init chip specific data */
+	spin_lock_init(&pm->reg_lock);
+	pm->card = card;
+	pm->pardev = pardev;
+
+	*rchip = pm;
+
+	return 0;
+}
+
+/*********************************************************************
+ * HW related constants
+ *********************************************************************/
+
+/* Standard PC parallel port status register equates. */
+#define	PP_STAT_BSY   	0x80	/* Busy status.  Inverted. */
+#define	PP_STAT_ACK   	0x40	/* Acknowledge.  Non-Inverted. */
+#define	PP_STAT_POUT  	0x20	/* Paper Out.    Non-Inverted. */
+#define	PP_STAT_SEL   	0x10	/* Select.       Non-Inverted. */
+#define	PP_STAT_ERR   	0x08	/* Error.        Non-Inverted. */
+
+/* Standard PC parallel port command register equates. */
+#define	PP_CMD_IEN  	0x10	/* IRQ Enable.   Non-Inverted. */
+#define	PP_CMD_SELI 	0x08	/* Select Input. Inverted. */
+#define	PP_CMD_INIT 	0x04	/* Init Printer. Non-Inverted. */
+#define	PP_CMD_FEED 	0x02	/* Auto Feed.    Inverted. */
+#define	PP_CMD_STB      0x01	/* Strobe.       Inverted. */
+
+/* Parallel Port Command Register as implemented by PCP2x4. */
+#define	INT_EN	 	PP_CMD_IEN	/* Interrupt enable. */
+#define	STROBE	        PP_CMD_STB	/* Command strobe. */
+
+/* The parallel port command register field (b1..b3) selects the 
+ * various "registers" within the PC/P 2x4.  These are the internal
+ * address of these "registers" that must be written to the parallel
+ * port command register.
+ */
+#define	RXDATA0		(0 << 1)	/* PCP RxData channel 0. */
+#define	RXDATA1		(1 << 1)	/* PCP RxData channel 1. */
+#define	GEN_CTL		(2 << 1)	/* PCP General Control Register. */
+#define	SYNC_CTL 	(3 << 1)	/* PCP Sync Control Register. */
+#define	TXDATA0		(4 << 1)	/* PCP TxData channel 0. */
+#define	TXDATA1		(5 << 1)	/* PCP TxData channel 1. */
+#define	TXDATA2		(6 << 1)	/* PCP TxData channel 2. */
+#define	TXDATA3		(7 << 1)	/* PCP TxData channel 3. */
+
+/* Parallel Port Status Register as implemented by PCP2x4. */
+#define	ESTB		PP_STAT_POUT	/* Echoed strobe. */
+#define	INT_REQ         PP_STAT_ACK	/* Input data int request. */
+#define	BUSY            PP_STAT_ERR	/* Interface Busy. */
+
+/* Parallel Port Status Register BUSY and SELECT lines are multiplexed
+ * between several functions.  Depending on which 2x4 "register" is
+ * currently selected (b1..b3), the BUSY and SELECT lines are
+ * assigned as follows:
+ *
+ *   SELECT LINE:                                                    A3 A2 A1
+ *                                                                   --------
+ */
+#define	RXAVAIL		PP_STAT_SEL	/* Rx Available, channel 0.   0 0 0 */
+//  RXAVAIL1    PP_STAT_SEL             /* Rx Available, channel 1.   0 0 1 */
+#define	SYNC_STAT	PP_STAT_SEL	/* Reserved - Sync Status.    0 1 0 */
+//                                      /* Reserved.                  0 1 1 */
+#define	TXEMPTY		PP_STAT_SEL	/* Tx Empty, channel 0.       1 0 0 */
+//      TXEMPTY1        PP_STAT_SEL     /* Tx Empty, channel 1.       1 0 1 */
+//  TXEMPTY2    PP_STAT_SEL             /* Tx Empty, channel 2.       1 1 0 */
+//  TXEMPTY3    PP_STAT_SEL             /* Tx Empty, channel 3.       1 1 1 */
+
+/*   BUSY LINE:                                                      A3 A2 A1
+ *                                                                   --------
+ */
+#define	RXDATA		PP_STAT_BSY	/* Rx Input Data, channel 0.  0 0 0 */
+//      RXDATA1         PP_STAT_BSY     /* Rx Input Data, channel 1.  0 0 1 */
+#define	SYNC_DATA       PP_STAT_BSY	/* Reserved - Sync Data.      0 1 0 */
+					/* Reserved.                  0 1 1 */
+#define	DATA_ECHO       PP_STAT_BSY	/* Parallel Port Data Echo.   1 0 0 */
+#define	A0_ECHO         PP_STAT_BSY	/* Address 0 Echo.            1 0 1 */
+#define	A1_ECHO         PP_STAT_BSY	/* Address 1 Echo.            1 1 0 */
+#define	A2_ECHO         PP_STAT_BSY	/* Address 2 Echo.            1 1 1 */
+
+#define PORTMAN2X4_MODE_INPUT_TRIGGERED	 0x01
+
+/*********************************************************************
+ * Hardware specific functions
+ *********************************************************************/
+static inline void portman_write_command(struct portman *pm, u8 value)
+{
+	parport_write_control(pm->pardev->port, value);
+}
+
+static inline u8 portman_read_command(struct portman *pm)
+{
+	return parport_read_control(pm->pardev->port);
+}
+
+static inline u8 portman_read_status(struct portman *pm)
+{
+	return parport_read_status(pm->pardev->port);
+}
+
+static inline u8 portman_read_data(struct portman *pm)
+{
+	return parport_read_data(pm->pardev->port);
+}
+
+static inline void portman_write_data(struct portman *pm, u8 value)
+{
+	parport_write_data(pm->pardev->port, value);
+}
+
+static void portman_write_midi(struct portman *pm, 
+			       int port, u8 mididata)
+{
+	int command = ((port + 4) << 1);
+
+	/* Get entering data byte and port number in BL and BH respectively.
+	 * Set up Tx Channel address field for use with PP Cmd Register.
+	 * Store address field in BH register.
+	 * Inputs:      AH = Output port number (0..3).
+	 *              AL = Data byte.
+	 *    command = TXDATA0 | INT_EN;
+	 * Align port num with address field (b1...b3),
+	 * set address for TXDatax, Strobe=0
+	 */
+	command |= INT_EN;
+
+	/* Disable interrupts so that the process is not interrupted, then 
+	 * write the address associated with the current Tx channel to the 
+	 * PP Command Reg.  Do not set the Strobe signal yet.
+	 */
+
+	do {
+		portman_write_command(pm, command);
+
+		/* While the address lines settle, write parallel output data to 
+		 * PP Data Reg.  This has no effect until Strobe signal is asserted.
+		 */
+
+		portman_write_data(pm, mididata);
+		
+		/* If PCP channel's TxEmpty is set (TxEmpty is read through the PP
+		 * Status Register), then go write data.  Else go back and wait.
+		 */
+	} while ((portman_read_status(pm) & TXEMPTY) != TXEMPTY);
+
+	/* TxEmpty is set.  Maintain PC/P destination address and assert
+	 * Strobe through the PP Command Reg.  This will Strobe data into
+	 * the PC/P transmitter and set the PC/P BUSY signal.
+	 */
+
+	portman_write_command(pm, command | STROBE);
+
+	/* Wait for strobe line to settle and echo back through hardware.
+	 * Once it has echoed back, assume that the address and data lines
+	 * have settled!
+	 */
+
+	while ((portman_read_status(pm) & ESTB) == 0)
+		cpu_relax();
+
+	/* Release strobe and immediately re-allow interrupts. */
+	portman_write_command(pm, command);
+
+	while ((portman_read_status(pm) & ESTB) == ESTB)
+		cpu_relax();
+
+	/* PC/P BUSY is now set.  We must wait until BUSY resets itself.
+	 * We'll reenable ints while we're waiting.
+	 */
+
+	while ((portman_read_status(pm) & BUSY) == BUSY)
+		cpu_relax();
+
+	/* Data sent. */
+}
+
+
+/*
+ *  Read MIDI byte from port
+ *  Attempt to read input byte from specified hardware input port (0..).
+ *  Return -1 if no data
+ */
+static int portman_read_midi(struct portman *pm, int port)
+{
+	unsigned char midi_data = 0;
+	unsigned char cmdout;	/* Saved address+IE bit. */
+
+	/* Make sure clocking edge is down before starting... */
+	portman_write_data(pm, 0);	/* Make sure edge is down. */
+
+	/* Set destination address to PCP. */
+	cmdout = (port << 1) | INT_EN;	/* Address + IE + No Strobe. */
+	portman_write_command(pm, cmdout);
+
+	while ((portman_read_status(pm) & ESTB) == ESTB)
+		cpu_relax();	/* Wait for strobe echo. */
+
+	/* After the address lines settle, check multiplexed RxAvail signal.
+	 * If data is available, read it.
+	 */
+	if ((portman_read_status(pm) & RXAVAIL) == 0)
+		return -1;	/* No data. */
+
+	/* Set the Strobe signal to enable the Rx clocking circuitry. */
+	portman_write_command(pm, cmdout | STROBE);	/* Write address+IE+Strobe. */
+
+	while ((portman_read_status(pm) & ESTB) == 0)
+		cpu_relax(); /* Wait for strobe echo. */
+
+	/* The first data bit (msb) is already sitting on the input line. */
+	midi_data = (portman_read_status(pm) & 128);
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 6. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 1) & 64;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 5. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 2) & 32;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 4. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 3) & 16;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 3. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 4) & 8;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 2. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 5) & 4;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 1. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 6) & 2;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+
+	/* Data bit 0. */
+	portman_write_data(pm, 0);	/* Cause falling edge while data settles. */
+	midi_data |= (portman_read_status(pm) >> 7) & 1;
+	portman_write_data(pm, 1);	/* Cause rising edge, which shifts data. */
+	portman_write_data(pm, 0);	/* Return data clock low. */
+
+
+	/* De-assert Strobe and return data. */
+	portman_write_command(pm, cmdout);	/* Output saved address+IE. */
+
+	/* Wait for strobe echo. */
+	while ((portman_read_status(pm) & ESTB) == ESTB)
+		cpu_relax();
+
+	return (midi_data & 255);	/* Shift back and return value. */
+}
+
+/*
+ *  Checks if any input data on the given channel is available
+ *  Checks RxAvail 
+ */
+static int portman_data_avail(struct portman *pm, int channel)
+{
+	int command = INT_EN;
+	switch (channel) {
+	case 0:
+		command |= RXDATA0;
+		break;
+	case 1:
+		command |= RXDATA1;
+		break;
+	}
+	/* Write hardware (assumme STROBE=0) */
+	portman_write_command(pm, command);
+	/* Check multiplexed RxAvail signal */
+	if ((portman_read_status(pm) & RXAVAIL) == RXAVAIL)
+		return 1;	/* Data available */
+
+	/* No Data available */
+	return 0;
+}
+
+
+/*
+ *  Flushes any input
+ */
+static void portman_flush_input(struct portman *pm, unsigned char port)
+{
+	/* Local variable for counting things */
+	unsigned int i = 0;
+	unsigned char command = 0;
+
+	switch (port) {
+	case 0:
+		command = RXDATA0;
+		break;
+	case 1:
+		command = RXDATA1;
+		break;
+	default:
+		snd_printk(KERN_WARNING
+			   "portman_flush_input() Won't flush port %i\n",
+			   port);
+		return;
+	}
+
+	/* Set address for specified channel in port and allow to settle. */
+	portman_write_command(pm, command);
+
+	/* Assert the Strobe and wait for echo back. */
+	portman_write_command(pm, command | STROBE);
+
+	/* Wait for ESTB */
+	while ((portman_read_status(pm) & ESTB) == 0)
+		cpu_relax();
+
+	/* Output clock cycles to the Rx circuitry. */
+	portman_write_data(pm, 0);
+
+	/* Flush 250 bits... */
+	for (i = 0; i < 250; i++) {
+		portman_write_data(pm, 1);
+		portman_write_data(pm, 0);
+	}
+
+	/* Deassert the Strobe signal of the port and wait for it to settle. */
+	portman_write_command(pm, command | INT_EN);
+
+	/* Wait for settling */
+	while ((portman_read_status(pm) & ESTB) == ESTB)
+		cpu_relax();
+}
+
+static int portman_probe(struct parport *p)
+{
+	/* Initialize the parallel port data register.  Will set Rx clocks
+	 * low in case we happen to be addressing the Rx ports at this time.
+	 */
+	/* 1 */
+	parport_write_data(p, 0);
+
+	/* Initialize the parallel port command register, thus initializing
+	 * hardware handshake lines to midi box:
+	 *
+	 *                                  Strobe = 0
+	 *                                  Interrupt Enable = 0            
+	 */
+	/* 2 */
+	parport_write_control(p, 0);
+
+	/* Check if Portman PC/P 2x4 is out there. */
+	/* 3 */
+	parport_write_control(p, RXDATA0);	/* Write Strobe=0 to command reg. */
+
+	/* Check for ESTB to be clear */
+	/* 4 */
+	if ((parport_read_status(p) & ESTB) == ESTB)
+		return 1;	/* CODE 1 - Strobe Failure. */
+
+	/* Set for RXDATA0 where no damage will be done. */
+	/* 5 */
+	parport_write_control(p, RXDATA0 + STROBE);	/* Write Strobe=1 to command reg. */
+
+	/* 6 */
+	if ((parport_read_status(p) & ESTB) != ESTB)
+		return 1;	/* CODE 1 - Strobe Failure. */
+
+	/* 7 */
+	parport_write_control(p, 0);	/* Reset Strobe=0. */
+
+	/* Check if Tx circuitry is functioning properly.  If initialized 
+	 * unit TxEmpty is false, send out char and see if if goes true.
+	 */
+	/* 8 */
+	parport_write_control(p, TXDATA0);	/* Tx channel 0, strobe off. */
+
+	/* If PCP channel's TxEmpty is set (TxEmpty is read through the PP
+	 * Status Register), then go write data.  Else go back and wait.
+	 */
+	/* 9 */
+	if ((parport_read_status(p) & TXEMPTY) == 0)
+		return 2;
+
+	/* Return OK status. */
+	return 0;
+}
+
+static int portman_device_init(struct portman *pm)
+{
+	portman_flush_input(pm, 0);
+	portman_flush_input(pm, 1);
+
+	return 0;
+}
+
+/*********************************************************************
+ * Rawmidi
+ *********************************************************************/
+static int snd_portman_midi_open(struct snd_rawmidi_substream *substream)
+{
+	return 0;
+}
+
+static int snd_portman_midi_close(struct snd_rawmidi_substream *substream)
+{
+	return 0;
+}
+
+static void snd_portman_midi_input_trigger(struct snd_rawmidi_substream *substream,
+					   int up)
+{
+	struct portman *pm = substream->rmidi->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm->reg_lock, flags);
+	if (up)
+		pm->mode[substream->number] |= PORTMAN2X4_MODE_INPUT_TRIGGERED;
+	else
+		pm->mode[substream->number] &= ~PORTMAN2X4_MODE_INPUT_TRIGGERED;
+	spin_unlock_irqrestore(&pm->reg_lock, flags);
+}
+
+static void snd_portman_midi_output_trigger(struct snd_rawmidi_substream *substream,
+					    int up)
+{
+	struct portman *pm = substream->rmidi->private_data;
+	unsigned long flags;
+	unsigned char byte;
+
+	spin_lock_irqsave(&pm->reg_lock, flags);
+	if (up) {
+		while ((snd_rawmidi_transmit(substream, &byte, 1) == 1))
+			portman_write_midi(pm, substream->number, byte);
+	}
+	spin_unlock_irqrestore(&pm->reg_lock, flags);
+}
+
+static struct snd_rawmidi_ops snd_portman_midi_output = {
+	.open =		snd_portman_midi_open,
+	.close =	snd_portman_midi_close,
+	.trigger =	snd_portman_midi_output_trigger,
+};
+
+static struct snd_rawmidi_ops snd_portman_midi_input = {
+	.open =		snd_portman_midi_open,
+	.close =	snd_portman_midi_close,
+	.trigger =	snd_portman_midi_input_trigger,
+};
+
+/* Create and initialize the rawmidi component */
+static int __devinit snd_portman_rawmidi_create(struct snd_card *card)
+{
+	struct portman *pm = card->private_data;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *substream;
+	int err;
+	
+	err = snd_rawmidi_new(card, CARD_NAME, 0, 
+			      PORTMAN_NUM_OUTPUT_PORTS, 
+			      PORTMAN_NUM_INPUT_PORTS, 
+			      &rmidi);
+	if (err < 0) 
+		return err;
+
+	rmidi->private_data = pm;
+	strcpy(rmidi->name, CARD_NAME);
+	rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+		            SNDRV_RAWMIDI_INFO_INPUT |
+                            SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	pm->rmidi = rmidi;
+
+	/* register rawmidi ops */
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, 
+			    &snd_portman_midi_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, 
+			    &snd_portman_midi_input);
+
+	/* name substreams */
+	/* output */
+	list_for_each_entry(substream,
+			    &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,
+			    list) {
+		sprintf(substream->name,
+			"Portman2x4 %d", substream->number+1);
+	}
+	/* input */
+	list_for_each_entry(substream,
+			    &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams,
+			    list) {
+		pm->midi_input[substream->number] = substream;
+		sprintf(substream->name,
+			"Portman2x4 %d", substream->number+1);
+	}
+
+	return err;
+}
+
+/*********************************************************************
+ * parport stuff
+ *********************************************************************/
+static void snd_portman_interrupt(int irq, void *userdata)
+{
+	unsigned char midivalue = 0;
+	struct portman *pm = ((struct snd_card*)userdata)->private_data;
+
+	spin_lock(&pm->reg_lock);
+
+	/* While any input data is waiting */
+	while ((portman_read_status(pm) & INT_REQ) == INT_REQ) {
+		/* If data available on channel 0, 
+		   read it and stuff it into the queue. */
+		if (portman_data_avail(pm, 0)) {
+			/* Read Midi */
+			midivalue = portman_read_midi(pm, 0);
+			/* put midi into queue... */
+			if (pm->mode[0] & PORTMAN2X4_MODE_INPUT_TRIGGERED)
+				snd_rawmidi_receive(pm->midi_input[0],
+						    &midivalue, 1);
+
+		}
+		/* If data available on channel 1, 
+		   read it and stuff it into the queue. */
+		if (portman_data_avail(pm, 1)) {
+			/* Read Midi */
+			midivalue = portman_read_midi(pm, 1);
+			/* put midi into queue... */
+			if (pm->mode[1] & PORTMAN2X4_MODE_INPUT_TRIGGERED)
+				snd_rawmidi_receive(pm->midi_input[1],
+						    &midivalue, 1);
+		}
+
+	}
+
+	spin_unlock(&pm->reg_lock);
+}
+
+static int __devinit snd_portman_probe_port(struct parport *p)
+{
+	struct pardevice *pardev;
+	int res;
+
+	pardev = parport_register_device(p, DRIVER_NAME,
+					 NULL, NULL, NULL,
+					 0, NULL);
+	if (!pardev)
+		return -EIO;
+	
+	if (parport_claim(pardev)) {
+		parport_unregister_device(pardev);
+		return -EIO;
+	}
+
+	res = portman_probe(p);
+
+	parport_release(pardev);
+	parport_unregister_device(pardev);
+
+	return res;
+}
+
+static void __devinit snd_portman_attach(struct parport *p)
+{
+	struct platform_device *device;
+
+	device = platform_device_alloc(PLATFORM_DRIVER, device_count);
+	if (!device) 
+		return;
+
+	/* Temporary assignment to forward the parport */
+	platform_set_drvdata(device, p);
+
+	if (platform_device_register(device) < 0) {
+		platform_device_put(device);
+		return;
+	}
+
+	/* Since we dont get the return value of probe
+	 * We need to check if device probing succeeded or not */
+	if (!platform_get_drvdata(device)) {
+		platform_device_unregister(device);
+		return;
+	}
+
+	/* register device in global table */
+	platform_devices[device_count] = device;
+	device_count++;
+}
+
+static void snd_portman_detach(struct parport *p)
+{
+	/* nothing to do here */
+}
+
+static struct parport_driver portman_parport_driver = {
+	.name   = "portman2x4",
+	.attach = snd_portman_attach,
+	.detach = snd_portman_detach
+};
+
+/*********************************************************************
+ * platform stuff
+ *********************************************************************/
+static void snd_portman_card_private_free(struct snd_card *card)
+{
+	struct portman *pm = card->private_data;
+	struct pardevice *pardev = pm->pardev;
+
+	if (pardev) {
+		if (pm->pardev_claimed)
+			parport_release(pardev);
+		parport_unregister_device(pardev);
+	}
+
+	portman_free(pm);
+}
+
+static int __devinit snd_portman_probe(struct platform_device *pdev)
+{
+	struct pardevice *pardev;
+	struct parport *p;
+	int dev = pdev->id;
+	struct snd_card *card = NULL;
+	struct portman *pm = NULL;
+	int err;
+
+	p = platform_get_drvdata(pdev);
+	platform_set_drvdata(pdev, NULL);
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) 
+		return -ENOENT;
+
+	if ((err = snd_portman_probe_port(p)) < 0)
+		return err;
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL) {
+		snd_printd("Cannot create card\n");
+		return -ENOMEM;
+	}
+	strcpy(card->driver, DRIVER_NAME);
+	strcpy(card->shortname, CARD_NAME);
+	sprintf(card->longname,  "%s at 0x%lx, irq %i", 
+		card->shortname, p->base, p->irq);
+
+	pardev = parport_register_device(p,                     /* port */
+					 DRIVER_NAME,           /* name */
+					 NULL,                  /* preempt */
+					 NULL,                  /* wakeup */
+					 snd_portman_interrupt, /* ISR */
+					 PARPORT_DEV_EXCL,      /* flags */
+					 (void *)card);         /* private */
+	if (pardev == NULL) {
+		snd_printd("Cannot register pardevice\n");
+		err = -EIO;
+		goto __err;
+	}
+
+	if ((err = portman_create(card, pardev, &pm)) < 0) {
+		snd_printd("Cannot create main component\n");
+		parport_unregister_device(pardev);
+		goto __err;
+	}
+	card->private_data = pm;
+	card->private_free = snd_portman_card_private_free;
+	
+	if ((err = snd_portman_rawmidi_create(card)) < 0) {
+		snd_printd("Creating Rawmidi component failed\n");
+		goto __err;
+	}
+
+	/* claim parport */
+	if (parport_claim(pardev)) {
+		snd_printd("Cannot claim parport 0x%lx\n", pardev->port->base);
+		err = -EIO;
+		goto __err;
+	}
+	pm->pardev_claimed = 1;
+
+	/* init device */
+	if ((err = portman_device_init(pm)) < 0)
+		goto __err;
+
+	platform_set_drvdata(pdev, card);
+
+	/* At this point card will be usable */
+	if ((err = snd_card_register(card)) < 0) {
+		snd_printd("Cannot register card\n");
+		goto __err;
+	}
+
+	snd_printk(KERN_INFO "Portman 2x4 on 0x%lx\n", p->base);
+	return 0;
+
+__err:
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit snd_portman_remove(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	if (card)
+		snd_card_free(card);
+
+	return 0;
+}
+
+
+static struct platform_driver snd_portman_driver = {
+	.probe  = snd_portman_probe,
+	.remove = __devexit_p(snd_portman_remove),
+	.driver = {
+		.name = PLATFORM_DRIVER
+	}
+};
+
+/*********************************************************************
+ * module init stuff
+ *********************************************************************/
+static void __init_or_module snd_portman_unregister_all(void)
+{
+	int i;
+
+	for (i = 0; i < SNDRV_CARDS; ++i) {
+		if (platform_devices[i]) {
+			platform_device_unregister(platform_devices[i]);
+			platform_devices[i] = NULL;
+		}
+	}		
+	platform_driver_unregister(&snd_portman_driver);
+	parport_unregister_driver(&portman_parport_driver);
+}
+
+static int __init snd_portman_module_init(void)
+{
+	int err;
+
+	if ((err = platform_driver_register(&snd_portman_driver)) < 0)
+		return err;
+
+	if (parport_register_driver(&portman_parport_driver) != 0) {
+		platform_driver_unregister(&snd_portman_driver);
+		return -EIO;
+	}
+
+	if (device_count == 0) {
+		snd_portman_unregister_all();
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit snd_portman_module_exit(void)
+{
+	snd_portman_unregister_all();
+}
+
+module_init(snd_portman_module_init);
+module_exit(snd_portman_module_exit);
--- linux-2.6.18.noarch/sound/drivers/opl4/opl4_proc.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/opl4/opl4_proc.c	2007-06-05 17:41:53.000000000 -0400
@@ -105,13 +105,13 @@
 					  struct file *file, long long offset, int orig)
 {
 	switch (orig) {
-	case 0: /* SEEK_SET */
+	case SEEK_SET:
 		file->f_pos = offset;
 		break;
-	case 1: /* SEEK_CUR */
+	case SEEK_CUR:
 		file->f_pos += offset;
 		break;
-	case 2: /* SEEK_END, offset is negative */
+	case SEEK_END: /* offset is negative */
 		file->f_pos = entry->size + offset;
 		break;
 	default:
@@ -159,8 +159,7 @@
 
 void snd_opl4_free_proc(struct snd_opl4 *opl4)
 {
-	if (opl4->proc_entry)
-		snd_info_unregister(opl4->proc_entry);
+	snd_info_free_entry(opl4->proc_entry);
 }
 
 #endif /* CONFIG_PROC_FS */
--- linux-2.6.18.noarch/sound/drivers/mpu401/mpu401.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/mpu401/mpu401.c	2007-06-05 17:41:36.000000000 -0400
@@ -211,7 +211,7 @@
 	struct snd_card *card = (struct snd_card *) pnp_get_drvdata(dev);
 
 	snd_card_disconnect(card);
-	snd_card_free_in_thread(card);
+	snd_card_free_when_closed(card);
 }
 
 static struct pnp_driver snd_mpu401_pnp_driver = {
--- linux-2.6.18.noarch/sound/drivers/mpu401/mpu401_uart.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/mpu401/mpu401_uart.c	2007-06-05 17:41:36.000000000 -0400
@@ -125,7 +125,6 @@
  * snd_mpu401_uart_interrupt - generic MPU401-UART interrupt handler
  * @irq: the irq number
  * @dev_id: mpu401 instance
- * @regs: the reigster
  *
  * Processes the interrupt for MPU401-UART i/o.
  */
@@ -146,7 +145,6 @@
  * snd_mpu401_uart_interrupt_tx - generic MPU401-UART transmit irq handler
  * @irq: the irq number
  * @dev_id: mpu401 instance
- * @regs: the reigster
  *
  * Processes the interrupt for MPU401-UART output.
  */
--- linux-2.6.18.noarch/sound/drivers/Kconfig.orig	2007-06-05 16:07:46.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/Kconfig	2007-06-05 17:41:32.000000000 -0400
@@ -26,11 +26,7 @@
 config SND_AC97_CODEC
 	tristate
 	select SND_PCM
-	select SND_AC97_BUS
-
-config SND_AC97_BUS
-	tristate
-
+	select AC97_BUS
 
 config SND_DUMMY
 	tristate "Dummy (/dev/null) soundcard"
@@ -73,6 +69,19 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-mtpav.
 
+config SND_MTS64
+	tristate "ESI Miditerminal 4140 driver"
+	depends on SND && PARPORT
+	select SND_RAWMIDI
+	help
+	  The ESI Miditerminal 4140 is a 4 In 4 Out MIDI Interface with 
+          additional SMPTE Timecode capabilities for the parallel port.
+
+	  Say 'Y' to include support for this device.
+
+	  To compile this driver as a module, chose 'M' here: the module 
+          will be called snd-mts64.
+
 config SND_SERIAL_U16550
 	tristate "UART16550 serial MIDI driver"
 	depends on SND
@@ -100,4 +109,15 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-mpu401.
 
+config SND_PORTMAN2X4
+	tristate "Portman 2x4 driver"
+	depends on SND && PARPORT
+	select SND_RAWMIDI
+	help
+	  Say Y here to include support for Midiman Portman 2x4 parallel
+	  port MIDI device.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd-portman2x4.
+
 endmenu
--- linux-2.6.18.noarch/sound/drivers/vx/vx_mixer.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/drivers/vx/vx_mixer.c	2007-06-05 17:41:59.000000000 -0400
@@ -23,6 +23,7 @@
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/vx_core.h>
 #include "vx_cmd.h"
 
@@ -455,10 +456,13 @@
 
 static struct snd_kcontrol_new vx_control_output_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Master Playback Volume",
 	.info =		vx_output_level_info,
 	.get =		vx_output_level_get,
 	.put =		vx_output_level_put,
+	/* tlv will be filled later */
 };
 
 /*
@@ -712,12 +716,17 @@
 	return 0;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_audio_gain, -10975, 25, 0);
+
 static struct snd_kcontrol_new vx_control_audio_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	/* name will be filled later */
 	.info =         vx_audio_gain_info,
 	.get =          vx_audio_gain_get,
-	.put =          vx_audio_gain_put
+	.put =          vx_audio_gain_put,
+	.tlv = { .p = db_scale_audio_gain },
 };
 static struct snd_kcontrol_new vx_control_output_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -729,9 +738,12 @@
 static struct snd_kcontrol_new vx_control_monitor_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitoring Volume",
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.info =         vx_audio_gain_info,	/* shared */
 	.get =          vx_audio_monitor_get,
-	.put =          vx_audio_monitor_put
+	.put =          vx_audio_monitor_put,
+	.tlv = { .p = db_scale_audio_gain },
 };
 static struct snd_kcontrol_new vx_control_monitor_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -918,6 +930,7 @@
 	for (i = 0; i < chip->hw->num_outs; i++) {
 		temp = vx_control_output_level;
 		temp.index = i;
+		temp.tlv.p = chip->hw->output_level_db_scale;
 		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
 			return err;
 	}
--- linux-2.6.18.noarch/sound/usb/usbmixer_maps.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usbmixer_maps.c	2007-06-05 17:49:34.000000000 -0400
@@ -234,6 +234,26 @@
 	{ 0 } /* terminator */
 };
 
+/* TerraTec Aureon 5.1 MkII USB */
+static struct usbmix_name_map aureon_51_2_map[] = {
+	/* 1: IT USB */
+	/* 2: IT Mic */
+	/* 3: IT Line */
+	/* 4: IT SPDIF */
+	/* 5: OT SPDIF */
+	/* 6: OT Speaker */
+	/* 7: OT USB */
+	{ 8, "Capture Source" }, /* SU */
+	{ 9, "Master Playback" }, /* FU */
+	{ 10, "Mic Capture" }, /* FU */
+	{ 11, "Line Capture" }, /* FU */
+	{ 12, "IEC958 In Capture" }, /* FU */
+	{ 13, "Mic Playback" }, /* FU */
+	{ 14, "Line Playback" }, /* FU */
+	/* 15: MU */
+	{} /* terminator */
+};
+
 /*
  * Control map entries
  */
@@ -276,6 +296,10 @@
 		.id = USB_ID(0x0c45, 0x1158),
 		.map = justlink_map,
 	},
+	{
+		.id = USB_ID(0x0ccd, 0x0028),
+		.map = aureon_51_2_map,
+	},
 	{ 0 } /* terminator */
 };
 
--- linux-2.6.18.noarch/sound/usb/usbquirks.h.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usbquirks.h	2007-06-05 17:49:34.000000000 -0400
@@ -123,6 +123,10 @@
 YAMAHA_DEVICE(0x103f, NULL),
 YAMAHA_DEVICE(0x1040, NULL),
 YAMAHA_DEVICE(0x1041, NULL),
+YAMAHA_DEVICE(0x1042, NULL),
+YAMAHA_DEVICE(0x1043, NULL),
+YAMAHA_DEVICE(0x1044, NULL),
+YAMAHA_DEVICE(0x1045, NULL),
 YAMAHA_DEVICE(0x2000, "DGP-7"),
 YAMAHA_DEVICE(0x2001, "DGP-5"),
 YAMAHA_DEVICE(0x2002, NULL),
@@ -141,6 +145,7 @@
 YAMAHA_DEVICE(0x500c, "DME24N"),
 YAMAHA_DEVICE(0x500d, NULL),
 YAMAHA_DEVICE(0x500e, NULL),
+YAMAHA_DEVICE(0x500f, NULL),
 YAMAHA_DEVICE(0x7000, "DTX"),
 YAMAHA_DEVICE(0x7010, "UB99"),
 #undef YAMAHA_DEVICE
@@ -943,6 +948,29 @@
 },
 	/* TODO: add Edirol M-100FX support */
 {
+	/* has ID 0x004e when not in "Advanced Driver" mode */
+	USB_DEVICE(0x0582, 0x004c),
+	.driver_info = (unsigned long) & (const struct snd_usb_audio_quirk) {
+		.vendor_name = "EDIROL",
+		.product_name = "PCR-A",
+		.ifnum = QUIRK_ANY_INTERFACE,
+		.type = QUIRK_COMPOSITE,
+		.data = (const struct snd_usb_audio_quirk[]) {
+			{
+				.ifnum = 1,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 2,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = -1
+			}
+		}
+	}
+},
+{
 	/* has ID 0x004f when not in "Advanced Driver" mode */
 	USB_DEVICE(0x0582, 0x004d),
 	.driver_info = (unsigned long) & (const struct snd_usb_audio_quirk) {
@@ -1093,7 +1121,37 @@
 		}
 	}
 },
-	/* TODO: add Edirol UA-101 support */
+/* Roland UA-101 in High-Speed Mode only */
+{
+	USB_DEVICE(0x0582, 0x007d),
+	.driver_info = (unsigned long) & (const struct snd_usb_audio_quirk) {
+		.vendor_name = "Roland",
+		.product_name = "UA-101",
+		.ifnum = QUIRK_ANY_INTERFACE,
+		.type = QUIRK_COMPOSITE,
+		.data = (const struct snd_usb_audio_quirk[]) {
+			{
+				.ifnum = 0,
+				.type = QUIRK_AUDIO_EDIROL_UA101
+			},
+			{
+				.ifnum = 1,
+				.type = QUIRK_AUDIO_EDIROL_UA101
+			},
+			{
+				.ifnum = 2,
+				.type = QUIRK_MIDI_FIXED_ENDPOINT,
+				.data = & (const struct snd_usb_midi_endpoint_info) {
+					.out_cables = 0x0001,
+					.in_cables  = 0x0001
+				}
+			},
+			{
+				.ifnum = -1
+			}
+		}
+	}
+},
 {
 	/* has ID 0x0081 when not in "Advanced Driver" mode */
 	USB_DEVICE(0x0582, 0x0080),
--- linux-2.6.18.noarch/sound/usb/usbaudio.h.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usbaudio.h	2007-06-05 17:49:34.000000000 -0400
@@ -159,6 +159,7 @@
 	QUIRK_AUDIO_FIXED_ENDPOINT,
 	QUIRK_AUDIO_EDIROL_UA700_UA25,
 	QUIRK_AUDIO_EDIROL_UA1000,
+	QUIRK_AUDIO_EDIROL_UA101,
 
 	QUIRK_TYPE_COUNT
 };
--- linux-2.6.18.noarch/sound/usb/usbaudio.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usbaudio.c	2007-06-05 17:49:34.000000000 -0400
@@ -68,7 +68,7 @@
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 }; /* Vendor ID for this card */
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 }; /* Product ID for this card */
-static int nrpacks = 4;		/* max. number of packets per urb */
+static int nrpacks = 8;		/* max. number of packets per urb */
 static int async_unlink = 1;
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card*/
 
@@ -100,7 +100,7 @@
  *
  */
 
-#define MAX_PACKS	10
+#define MAX_PACKS	20
 #define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
 #define MAX_URBS	8
 #define SYNC_URBS	4	/* always four urbs for sync */
@@ -123,6 +123,7 @@
 	unsigned int rate_min, rate_max;	/* min/max rates */
 	unsigned int nr_rates;		/* number of rate table entries */
 	unsigned int *rate_table;	/* rate table */
+	unsigned int needs_knot;	/* any unusual rates? */
 };
 
 struct snd_usb_substream;
@@ -185,6 +186,7 @@
 	u64 formats;			/* format bitmasks (all or'ed) */
 	unsigned int num_formats;		/* number of supported audio formats (list) */
 	struct list_head fmt_list;	/* format list */
+	struct snd_pcm_hw_constraint_list rate_list;	/* limited rates */
 	spinlock_t lock;
 
 	struct snd_urb_ops ops;		/* callbacks (must be filled at init) */
@@ -252,7 +254,7 @@
 				    struct urb *urb)
 {
 	unsigned char *cp = urb->transfer_buffer;
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
 	urb->iso_frame_desc[0].length = 3;
@@ -274,7 +276,7 @@
 				       struct urb *urb)
 {
 	unsigned char *cp = urb->transfer_buffer;
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
 	urb->iso_frame_desc[0].length = 4;
@@ -312,7 +314,7 @@
 			       struct urb *urb)
 {
 	int i, offs;
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 
 	offs = 0;
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
@@ -323,16 +325,6 @@
 	}
 	urb->transfer_buffer_length = offs;
 	urb->number_of_packets = ctx->packets;
-#if 0 // for check
-	if (! urb->bandwidth) {
-		int bustime;
-		bustime = usb_check_bandwidth(urb->dev, urb);
-		if (bustime < 0)
-			return bustime;
-		printk("urb %d: bandwidth = %d (packets = %d)\n", ctx->index, bustime, urb->number_of_packets);
-		usb_claim_bandwidth(urb->dev, urb, bustime, 1);
-	}
-#endif // for check
 	return 0;
 }
 
@@ -390,6 +382,16 @@
 	return 0;
 }
 
+/*
+ * Process after capture complete when paused.  Nothing to do.
+ */
+static int retire_paused_capture_urb(struct snd_usb_substream *subs,
+				     struct snd_pcm_runtime *runtime,
+				     struct urb *urb)
+{
+	return 0;
+}
+
 
 /*
  * prepare urb for full speed playback sync pipe
@@ -401,7 +403,7 @@
 				     struct snd_pcm_runtime *runtime,
 				     struct urb *urb)
 {
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
 	urb->iso_frame_desc[0].length = 3;
@@ -419,7 +421,7 @@
 					struct snd_pcm_runtime *runtime,
 					struct urb *urb)
 {
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
 	urb->iso_frame_desc[0].length = 4;
@@ -492,13 +494,13 @@
 }
 
 /*
- * Prepare urb for streaming before playback starts.
+ * Prepare urb for streaming before playback starts or when paused.
  *
- * We don't yet have data, so we send a frame of silence.
+ * We don't have any data, so we send a frame of silence.
  */
-static int prepare_startup_playback_urb(struct snd_usb_substream *subs,
-					struct snd_pcm_runtime *runtime,
-					struct urb *urb)
+static int prepare_nodata_playback_urb(struct snd_usb_substream *subs,
+				       struct snd_pcm_runtime *runtime,
+				       struct urb *urb)
 {
 	unsigned int i, offs, counts;
 	struct snd_urb_ctx *ctx = urb->context;
@@ -536,7 +538,7 @@
 	unsigned int counts;
 	unsigned long flags;
 	int period_elapsed = 0;
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 
 	stride = runtime->frame_bits >> 3;
 
@@ -621,7 +623,7 @@
  */
 static struct snd_urb_ops audio_urb_ops[2] = {
 	{
-		.prepare =	prepare_startup_playback_urb,
+		.prepare =	prepare_nodata_playback_urb,
 		.retire =	retire_playback_urb,
 		.prepare_sync =	prepare_playback_sync_urb,
 		.retire_sync =	retire_playback_sync_urb,
@@ -636,7 +638,7 @@
 
 static struct snd_urb_ops audio_urb_ops_high_speed[2] = {
 	{
-		.prepare =	prepare_startup_playback_urb,
+		.prepare =	prepare_nodata_playback_urb,
 		.retire =	retire_playback_urb,
 		.prepare_sync =	prepare_playback_sync_urb_hs,
 		.retire_sync =	retire_playback_sync_urb_hs,
@@ -652,9 +654,9 @@
 /*
  * complete callback from data urb
  */
-static void snd_complete_urb(struct urb *urb, struct pt_regs *regs)
+static void snd_complete_urb(struct urb *urb)
 {
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 	struct snd_usb_substream *subs = ctx->subs;
 	struct snd_pcm_substream *substream = ctx->subs->pcm_substream;
 	int err = 0;
@@ -675,9 +677,9 @@
 /*
  * complete callback from sync urb
  */
-static void snd_complete_sync_urb(struct urb *urb, struct pt_regs *regs)
+static void snd_complete_sync_urb(struct urb *urb)
 {
-	struct snd_urb_ctx *ctx = (struct snd_urb_ctx *)urb->context;
+	struct snd_urb_ctx *ctx = urb->context;
 	struct snd_usb_substream *subs = ctx->subs;
 	struct snd_pcm_substream *substream = ctx->subs->pcm_substream;
 	int err = 0;
@@ -924,10 +926,14 @@
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		subs->ops.prepare = prepare_playback_urb;
 		return 0;
 	case SNDRV_PCM_TRIGGER_STOP:
 		return deactivate_urbs(subs, 0, 0);
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		subs->ops.prepare = prepare_nodata_playback_urb;
+		return 0;
 	default:
 		return -EINVAL;
 	}
@@ -943,9 +949,16 @@
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+		subs->ops.retire = retire_capture_urb;
 		return start_urbs(subs, substream->runtime);
 	case SNDRV_PCM_TRIGGER_STOP:
 		return deactivate_urbs(subs, 0, 0);
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		subs->ops.retire = retire_paused_capture_urb;
+		return 0;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		subs->ops.retire = retire_capture_urb;
+		return 0;
 	default:
 		return -EINVAL;
 	}
@@ -1407,7 +1420,7 @@
 static int snd_usb_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_pcm_hw_params *hw_params)
 {
-	struct snd_usb_substream *subs = (struct snd_usb_substream *)substream->runtime->private_data;
+	struct snd_usb_substream *subs = substream->runtime->private_data;
 	struct audioformat *fmt;
 	unsigned int channels, rate, format;
 	int ret, changed;
@@ -1463,12 +1476,13 @@
  */
 static int snd_usb_hw_free(struct snd_pcm_substream *substream)
 {
-	struct snd_usb_substream *subs = (struct snd_usb_substream *)substream->runtime->private_data;
+	struct snd_usb_substream *subs = substream->runtime->private_data;
 
 	subs->cur_audiofmt = NULL;
 	subs->cur_rate = 0;
 	subs->period_bytes = 0;
-	release_substream_urbs(subs, 0);
+	if (!subs->stream->chip->shutdown)
+		release_substream_urbs(subs, 0);
 	return snd_pcm_free_vmalloc_buffer(substream);
 }
 
@@ -1503,33 +1517,20 @@
 	/* for playback, submit the URBs now; otherwise, the first hwptr_done
 	 * updates for all URBs would happen at the same time when starting */
 	if (subs->direction == SNDRV_PCM_STREAM_PLAYBACK) {
-		subs->ops.prepare = prepare_startup_playback_urb;
+		subs->ops.prepare = prepare_nodata_playback_urb;
 		return start_urbs(subs, runtime);
 	} else
 		return 0;
 }
 
-static struct snd_pcm_hardware snd_usb_playback =
-{
-	.info =			SNDRV_PCM_INFO_MMAP |
-				SNDRV_PCM_INFO_MMAP_VALID |
-				SNDRV_PCM_INFO_BATCH |
-				SNDRV_PCM_INFO_INTERLEAVED |
-				SNDRV_PCM_INFO_BLOCK_TRANSFER,
-	.buffer_bytes_max =	1024 * 1024,
-	.period_bytes_min =	64,
-	.period_bytes_max =	512 * 1024,
-	.periods_min =		2,
-	.periods_max =		1024,
-};
-
-static struct snd_pcm_hardware snd_usb_capture =
+static struct snd_pcm_hardware snd_usb_hardware =
 {
 	.info =			SNDRV_PCM_INFO_MMAP |
 				SNDRV_PCM_INFO_MMAP_VALID |
 				SNDRV_PCM_INFO_BATCH |
 				SNDRV_PCM_INFO_INTERLEAVED |
-				SNDRV_PCM_INFO_BLOCK_TRANSFER,
+				SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				SNDRV_PCM_INFO_PAUSE,
 	.buffer_bytes_max =	1024 * 1024,
 	.period_bytes_min =	64,
 	.period_bytes_max =	512 * 1024,
@@ -1759,6 +1760,9 @@
 		}
 		channels[f->format] |= (1 << f->channels);
 		rates[f->format] |= f->rates;
+		/* needs knot? */
+		if (f->needs_knot)
+			goto __out;
 	}
 	/* check whether channels and rates match for all formats */
 	cmaster = rmaster = 0;
@@ -1799,6 +1803,43 @@
 	return err;
 }
 
+/*
+ *  If the device supports unusual bit rates, does the request meet these?
+ */
+static int snd_usb_pcm_check_knot(struct snd_pcm_runtime *runtime,
+				  struct snd_usb_substream *subs)
+{
+	struct audioformat *fp;
+	int count = 0, needs_knot = 0;
+	int err;
+
+	list_for_each_entry(fp, &subs->fmt_list, list) {
+		if (fp->rates & SNDRV_PCM_RATE_CONTINUOUS)
+			return 0;
+		count += fp->nr_rates;
+		if (fp->needs_knot)
+			needs_knot = 1;
+	}
+	if (!needs_knot)
+		return 0;
+
+	subs->rate_list.count = count;
+	subs->rate_list.list = kmalloc(sizeof(int) * count, GFP_KERNEL);
+	subs->rate_list.mask = 0;
+	count = 0;
+	list_for_each_entry(fp, &subs->fmt_list, list) {
+		int i;
+		for (i = 0; i < fp->nr_rates; i++)
+			subs->rate_list.list[count++] = fp->rate_table[i];
+	}
+	err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+					 &subs->rate_list);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
 
 /*
  * set up the runtime hardware information.
@@ -1861,12 +1902,13 @@
 					       SNDRV_PCM_HW_PARAM_CHANNELS,
 					       -1)) < 0)
 			return err;
+		if ((err = snd_usb_pcm_check_knot(runtime, subs)) < 0)
+			return err;
 	}
 	return 0;
 }
 
-static int snd_usb_pcm_open(struct snd_pcm_substream *substream, int direction,
-			    struct snd_pcm_hardware *hw)
+static int snd_usb_pcm_open(struct snd_pcm_substream *substream, int direction)
 {
 	struct snd_usb_stream *as = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -1874,7 +1916,7 @@
 
 	subs->interface = -1;
 	subs->format = 0;
-	runtime->hw = *hw;
+	runtime->hw = snd_usb_hardware;
 	runtime->private_data = subs;
 	subs->pcm_substream = substream;
 	return setup_hw_info(runtime, subs);
@@ -1895,7 +1937,7 @@
 
 static int snd_usb_playback_open(struct snd_pcm_substream *substream)
 {
-	return snd_usb_pcm_open(substream, SNDRV_PCM_STREAM_PLAYBACK, &snd_usb_playback);
+	return snd_usb_pcm_open(substream, SNDRV_PCM_STREAM_PLAYBACK);
 }
 
 static int snd_usb_playback_close(struct snd_pcm_substream *substream)
@@ -1905,7 +1947,7 @@
 
 static int snd_usb_capture_open(struct snd_pcm_substream *substream)
 {
-	return snd_usb_pcm_open(substream, SNDRV_PCM_STREAM_CAPTURE, &snd_usb_capture);
+	return snd_usb_pcm_open(substream, SNDRV_PCM_STREAM_CAPTURE);
 }
 
 static int snd_usb_capture_close(struct snd_pcm_substream *substream)
@@ -2049,7 +2091,7 @@
 };
 
 
-#if defined(CONFIG_PROCFS) && defined(CONFIG_SND_VERBOSE_PROCFS)
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_SND_VERBOSE_PROCFS)
 
 /*
  * proc interface for list the supported pcm formats
@@ -2193,6 +2235,7 @@
 		kfree(fp->rate_table);
 		kfree(fp);
 	}
+	kfree(subs->rate_list.list);
 }
 
 
@@ -2406,6 +2449,7 @@
 				    unsigned char *fmt, int offset)
 {
 	int nr_rates = fmt[offset];
+	int found;
 	if (fmt[0] < offset + 1 + 3 * (nr_rates ? nr_rates : 2)) {
 		snd_printk(KERN_ERR "%d:%u:%d : invalid FORMAT_TYPE desc\n",
 				   chip->dev->devnum, fp->iface, fp->altsetting);
@@ -2417,6 +2461,7 @@
 		 * build the rate table and bitmap flags
 		 */
 		int r, idx, c;
+		unsigned int nonzero_rates = 0;
 		/* this table corresponds to the SNDRV_PCM_RATE_XXX bit */
 		static unsigned int conv_rates[] = {
 			5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000,
@@ -2428,21 +2473,39 @@
 			return -1;
 		}
 
+		fp->needs_knot = 0;
 		fp->nr_rates = nr_rates;
 		fp->rate_min = fp->rate_max = combine_triple(&fmt[8]);
 		for (r = 0, idx = offset + 1; r < nr_rates; r++, idx += 3) {
-			unsigned int rate = fp->rate_table[r] = combine_triple(&fmt[idx]);
+			unsigned int rate = combine_triple(&fmt[idx]);
+			/* C-Media CM6501 mislabels its 96 kHz altsetting */
+			if (rate == 48000 && nr_rates == 1 &&
+			    chip->usb_id == USB_ID(0x0d8c, 0x0201) &&
+			    fp->altsetting == 5 && fp->maxpacksize == 392)
+				rate = 96000;
+			fp->rate_table[r] = rate;
+			nonzero_rates |= rate;
 			if (rate < fp->rate_min)
 				fp->rate_min = rate;
 			else if (rate > fp->rate_max)
 				fp->rate_max = rate;
+			found = 0;
 			for (c = 0; c < (int)ARRAY_SIZE(conv_rates); c++) {
 				if (rate == conv_rates[c]) {
+					found = 1;
 					fp->rates |= (1 << c);
 					break;
 				}
 			}
+			if (!found)
+				fp->needs_knot = 1;
+		}
+		if (!nonzero_rates) {
+			hwc_debug("All rates were zero. Skipping format!\n");
+			return -1;
 		}
+		if (fp->needs_knot)
+			fp->rates |= SNDRV_PCM_RATE_KNOT;
 	} else {
 		/* continuous rates */
 		fp->rates = SNDRV_PCM_RATE_CONTINUOUS;
@@ -3007,6 +3070,59 @@
 	return 0;
 }
 
+/*
+ * Create a stream for an Edirol UA-101 interface.
+ * Copy, paste and modify from Edirol UA-1000
+ */
+static int create_ua101_quirk(struct snd_usb_audio *chip,
+			       struct usb_interface *iface,
+			       const struct snd_usb_audio_quirk *quirk)
+{
+	static const struct audioformat ua101_format = {
+		.format = SNDRV_PCM_FORMAT_S32_LE,
+		.fmt_type = USB_FORMAT_TYPE_I,
+		.altsetting = 1,
+		.altset_idx = 1,
+		.attributes = 0,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS,
+	};
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	struct audioformat *fp;
+	int stream, err;
+
+	if (iface->num_altsetting != 2)
+		return -ENXIO;
+	alts = &iface->altsetting[1];
+	altsd = get_iface_desc(alts);
+	if (alts->extralen != 18 || alts->extra[1] != USB_DT_CS_INTERFACE ||
+	    altsd->bNumEndpoints != 1)
+		return -ENXIO;
+
+	fp = kmalloc(sizeof(*fp), GFP_KERNEL);
+	if (!fp)
+		return -ENOMEM;
+	memcpy(fp, &ua101_format, sizeof(*fp));
+
+	fp->channels = alts->extra[11];
+	fp->iface = altsd->bInterfaceNumber;
+	fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
+	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
+	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+	fp->rate_max = fp->rate_min = combine_triple(&alts->extra[15]);
+
+	stream = (fp->endpoint & USB_DIR_IN)
+		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
+	err = add_audio_endpoint(chip, stream, fp);
+	if (err < 0) {
+		kfree(fp);
+		return err;
+	}
+	/* FIXME: playback must be synchronized to capture */
+	usb_set_interface(chip->dev, fp->iface, 0);
+	return 0;
+}
+
 static int snd_usb_create_quirk(struct snd_usb_audio *chip,
 				struct usb_interface *iface,
 				const struct snd_usb_audio_quirk *quirk);
@@ -3188,6 +3304,7 @@
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UA700_UA25] = create_ua700_ua25_quirk,
 		[QUIRK_AUDIO_EDIROL_UA1000] = create_ua1000_quirk,
+		[QUIRK_AUDIO_EDIROL_UA101] = create_ua101_quirk,
 	};
 
 	if (quirk->type < QUIRK_TYPE_COUNT) {
@@ -3236,6 +3353,7 @@
 
 static int snd_usb_audio_free(struct snd_usb_audio *chip)
 {
+	usb_chip[chip->index] = NULL;
 	kfree(chip);
 	return 0;
 }
@@ -3497,9 +3615,8 @@
 		list_for_each(p, &chip->mixer_list) {
 			snd_usb_mixer_disconnect(p);
 		}
-		usb_chip[chip->index] = NULL;
 		mutex_unlock(&register_mutex);
-		snd_card_free(card);
+		snd_card_free_when_closed(card);
 	} else {
 		mutex_unlock(&register_mutex);
 	}
@@ -3533,8 +3650,7 @@
 		printk(KERN_WARNING "invalid nrpacks value.\n");
 		return -EINVAL;
 	}
-	usb_register(&usb_audio_driver);
-	return 0;
+	return usb_register(&usb_audio_driver);
 }
 
 
--- linux-2.6.18.noarch/sound/usb/usx2y/usX2Yhwdep.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usx2y/usX2Yhwdep.c	2007-06-05 17:49:42.000000000 -0400
@@ -48,7 +48,7 @@
 	
 	offset = area->vm_pgoff << PAGE_SHIFT;
 	offset += address - area->vm_start;
-	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
+	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_SIGBUS);
 	vaddr = (char*)((struct usX2Ydev *)area->vm_private_data)->us428ctls_sharedmem + offset;
 	page = virt_to_page(vaddr);
 	get_page(page);
--- linux-2.6.18.noarch/sound/usb/usx2y/usx2yhwdeppcm.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usx2y/usx2yhwdeppcm.c	2007-06-06 00:14:40.000000000 -0400
@@ -243,7 +243,7 @@
 		usX2Y_error_urb_status(usX2Y, subs, urb);
 		return;
 	}
-	if (likely(urb->start_frame == usX2Y->wait_iso_frame))
+	if (likely((urb->start_frame & 0xFFFF) == (usX2Y->wait_iso_frame & 0xFFFF)))
 		subs->completed_urb = urb;
 	else {
 		usX2Y_error_sequence(usX2Y, subs, urb);
--- linux-2.6.18.noarch/sound/usb/usx2y/usbusx2yaudio.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usx2y/usbusx2yaudio.c	2007-06-06 00:13:21.000000000 -0400
@@ -322,7 +322,7 @@
 		usX2Y_error_urb_status(usX2Y, subs, urb);
 		return;
 	}
-	if (likely(urb->start_frame == usX2Y->wait_iso_frame))
+	if (likely((urb->start_frame & 0xFFFF) == (usX2Y->wait_iso_frame & 0xFFFF)))
 		subs->completed_urb = urb;
 	else {
 		usX2Y_error_sequence(usX2Y, subs, urb);
--- linux-2.6.18.noarch/sound/usb/usbmidi.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usbmidi.c	2007-06-06 00:07:10.000000000 -0400
@@ -181,9 +181,9 @@
 	case -ENODEV:
 		return -ENODEV;
 	/* errors that might occur during unplugging */
-	case -EPROTO:    /* EHCI */
-	case -ETIMEDOUT: /* OHCI */
-	case -EILSEQ:    /* UHCI */
+	case -EPROTO:
+	case -ETIME:
+	case -EILSEQ:
 		return -EIO;
 	default:
 		snd_printk(KERN_ERR "urb status %d\n", status);
@@ -247,7 +247,7 @@
 	snd_usbmidi_submit_urb(urb, GFP_ATOMIC);
 }
 
-static void snd_usbmidi_out_urb_complete(struct urb* urb, struct pt_regs *regs)
+static void snd_usbmidi_out_urb_complete(struct urb* urb)
 {
 	struct snd_usb_midi_out_endpoint* ep = urb->context;
 
@@ -982,7 +982,7 @@
 			if (umidi->usb_protocol_ops->finish_out_endpoint)
 				umidi->usb_protocol_ops->finish_out_endpoint(ep->out);
 		}
-		if (ep->in && ep->in->urb)
+		if (ep->in)
 			usb_kill_urb(ep->in->urb);
 	}
 }
--- linux-2.6.18.noarch/sound/usb/usbmixer.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/usb/usbmixer.c	2007-06-05 17:49:34.000000000 -0400
@@ -37,6 +37,7 @@
 #include <sound/control.h>
 #include <sound/hwdep.h>
 #include <sound/info.h>
+#include <sound/tlv.h>
 
 #include "usbaudio.h"
 
@@ -416,6 +417,26 @@
 	return set_ctl_value(cval, SET_CUR, (cval->control << 8) | channel, value);
 }
 
+/*
+ * TLV callback for mixer volume controls
+ */
+static int mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+			 unsigned int size, unsigned int __user *_tlv)
+{
+	struct usb_mixer_elem_info *cval = kcontrol->private_data;
+	DECLARE_TLV_DB_SCALE(scale, 0, 0, 0);
+
+	if (size < sizeof(scale))
+		return -ENOMEM;
+	/* USB descriptions contain the dB scale in 1/256 dB unit
+	 * while ALSA TLV contains in 1/100 dB unit
+	 */
+	scale[2] = (convert_signed_value(cval, cval->min) * 100) / 256;
+	scale[3] = (convert_signed_value(cval, cval->res) * 100) / 256;
+	if (copy_to_user(_tlv, scale, sizeof(scale)))
+		return -EFAULT;
+	return 0;
+}
 
 /*
  * parser routines begin here...
@@ -933,6 +954,12 @@
 		}
 		strlcat(kctl->id.name + len, control == USB_FEATURE_MUTE ? " Switch" : " Volume",
 			sizeof(kctl->id.name));
+		if (control == USB_FEATURE_VOLUME) {
+			kctl->tlv.c = mixer_vol_tlv;
+			kctl->vd[0].access |= 
+				SNDRV_CTL_ELEM_ACCESS_TLV_READ |
+				SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;
+		}
 		break;
 
 	default:
@@ -1499,7 +1526,7 @@
 		namelist[i] = kmalloc(MAX_ITEM_NAME_LEN, GFP_KERNEL);
 		if (! namelist[i]) {
 			snd_printk(KERN_ERR "cannot malloc\n");
-			while (--i > 0)
+			while (i--)
 				kfree(namelist[i]);
 			kfree(namelist);
 			kfree(cval);
@@ -1593,8 +1620,7 @@
 		kfree(mixer->urb->transfer_buffer);
 		usb_free_urb(mixer->urb);
 	}
-	if (mixer->rc_urb)
-		usb_free_urb(mixer->rc_urb);
+	usb_free_urb(mixer->rc_urb);
 	kfree(mixer->rc_setup_packet);
 	kfree(mixer);
 }
@@ -1683,7 +1709,7 @@
 	}
 }
 
-static void snd_usb_mixer_status_complete(struct urb *urb, struct pt_regs *regs)
+static void snd_usb_mixer_status_complete(struct urb *urb)
 {
 	struct usb_mixer_interface *mixer = urb->context;
 
@@ -1745,8 +1771,7 @@
 	return 0;
 }
 
-static void snd_usb_soundblaster_remote_complete(struct urb *urb,
-						 struct pt_regs *regs)
+static void snd_usb_soundblaster_remote_complete(struct urb *urb)
 {
 	struct usb_mixer_interface *mixer = urb->context;
 	const struct rc_config *rc = mixer->rc_cfg;
@@ -2030,8 +2055,6 @@
 	struct usb_mixer_interface *mixer;
 	
 	mixer = list_entry(p, struct usb_mixer_interface, list);
-	if (mixer->urb)
-		usb_kill_urb(mixer->urb);
-	if (mixer->rc_urb)
-		usb_kill_urb(mixer->rc_urb);
+	usb_kill_urb(mixer->urb);
+	usb_kill_urb(mixer->rc_urb);
 }
--- linux-2.6.18.noarch/sound/i2c/Makefile.orig	2007-06-05 16:07:49.000000000 -0400
+++ linux-2.6.18.noarch/sound/i2c/Makefile	2007-06-05 17:42:21.000000000 -0400
@@ -16,3 +16,4 @@
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_INTERWAVE_STB) += snd-tea6330t.o snd-i2c.o
 obj-$(CONFIG_SND_ICE1712) += snd-cs8427.o snd-i2c.o
+obj-$(CONFIG_SND_ICE1724) += snd-i2c.o
--- linux-2.6.18.noarch/sound/i2c/other/ak4xxx-adda.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/i2c/other/ak4xxx-adda.c	2007-06-05 17:42:31.000000000 -0400
@@ -28,12 +28,14 @@
 #include <linux/init.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/ak4xxx-adda.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("Routines for control of AK452x / AK43xx  AD/DA converters");
 MODULE_LICENSE("GPL");
 
+/* write the given register and save the data to the cache */
 void snd_akm4xxx_write(struct snd_akm4xxx *ak, int chip, unsigned char reg,
 		       unsigned char val)
 {
@@ -41,15 +43,7 @@
 	ak->ops.write(ak, chip, reg, val);
 
 	/* save the data */
-	if (ak->type == SND_AK4524 || ak->type == SND_AK4528) {
-		if ((reg != 0x04 && reg != 0x05) || (val & 0x80) == 0)
-			snd_akm4xxx_set(ak, chip, reg, val);
-		else
-			snd_akm4xxx_set_ipga(ak, chip, reg, val);
-	} else {
-		/* AK4529, or else */
-		snd_akm4xxx_set(ak, chip, reg, val);
-	}
+	snd_akm4xxx_set(ak, chip, reg, val);
 	ak->ops.unlock(ak, chip);
 }
 
@@ -73,12 +67,6 @@
 		for (reg = 0x04; reg < maxreg; reg++)
 			snd_akm4xxx_write(ak, chip, reg,
 					  snd_akm4xxx_get(ak, chip, reg));
-		if (ak->type == SND_AK4528)
-			continue;
-		/* IPGA */
-		for (reg = 0x04; reg < 0x06; reg++)
-			snd_akm4xxx_write(ak, chip, reg,
-					  snd_akm4xxx_get_ipga(ak, chip, reg));
 	}
 }
 
@@ -137,17 +125,54 @@
 	case SND_AK4381:
 		ak4381_reset(ak, state);
 		break;
+	default:
+		break;
 	}
 }
 
 EXPORT_SYMBOL(snd_akm4xxx_reset);
 
+
+/*
+ * Volume conversion table for non-linear volumes
+ * from -63.5dB (mute) to 0dB step 0.5dB
+ *
+ * Used for AK4524 input/ouput attenuation, AK4528, and
+ * AK5365 input attenuation
+ */
+static const unsigned char vol_cvt_datt[128] = {
+	0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04,
+	0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06,
+	0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x0a,
+	0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x0f,
+	0x10, 0x10, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14,
+	0x15, 0x16, 0x17, 0x17, 0x18, 0x19, 0x1a, 0x1c,
+	0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x23,
+	0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x2b, 0x2d,
+	0x2e, 0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
+	0x37, 0x38, 0x39, 0x3b, 0x3c, 0x3e, 0x3f, 0x40,
+	0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x48, 0x4a,
+	0x4b, 0x4d, 0x4e, 0x50, 0x51, 0x52, 0x53, 0x54,
+	0x55, 0x56, 0x58, 0x59, 0x5b, 0x5c, 0x5e, 0x5f,
+	0x60, 0x61, 0x62, 0x64, 0x65, 0x66, 0x67, 0x69,
+	0x6a, 0x6c, 0x6d, 0x6f, 0x70, 0x71, 0x72, 0x73,
+	0x75, 0x76, 0x77, 0x79, 0x7a, 0x7c, 0x7d, 0x7f,
+};
+
+/*
+ * dB tables
+ */
+static const DECLARE_TLV_DB_SCALE(db_scale_vol_datt, -6350, 50, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_8bit, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_7bit, -6350, 50, 1);
+static const DECLARE_TLV_DB_LINEAR(db_scale_linear, TLV_DB_GAIN_MUTE, 0);
+
 /*
  * initialize all the ak4xxx chips
  */
 void snd_akm4xxx_init(struct snd_akm4xxx *ak)
 {
-	static unsigned char inits_ak4524[] = {
+	static const unsigned char inits_ak4524[] = {
 		0x00, 0x07, /* 0: all power up */
 		0x01, 0x00, /* 1: ADC/DAC reset */
 		0x02, 0x60, /* 2: 24bit I2S */
@@ -155,13 +180,11 @@
 		0x01, 0x03, /* 1: ADC/DAC enable */
 		0x04, 0x00, /* 4: ADC left muted */
 		0x05, 0x00, /* 5: ADC right muted */
-		0x04, 0x80, /* 4: ADC IPGA gain 0dB */
-		0x05, 0x80, /* 5: ADC IPGA gain 0dB */
 		0x06, 0x00, /* 6: DAC left muted */
 		0x07, 0x00, /* 7: DAC right muted */
 		0xff, 0xff
 	};
-	static unsigned char inits_ak4528[] = {
+	static const unsigned char inits_ak4528[] = {
 		0x00, 0x07, /* 0: all power up */
 		0x01, 0x00, /* 1: ADC/DAC reset */
 		0x02, 0x60, /* 2: 24bit I2S */
@@ -171,7 +194,7 @@
 		0x05, 0x00, /* 5: ADC right muted */
 		0xff, 0xff
 	};
-	static unsigned char inits_ak4529[] = {
+	static const unsigned char inits_ak4529[] = {
 		0x09, 0x01, /* 9: ATS=0, RSTN=1 */
 		0x0a, 0x3f, /* A: all power up, no zero/overflow detection */
 		0x00, 0x0c, /* 0: TDM=0, 24bit I2S, SMUTE=0 */
@@ -187,7 +210,7 @@
 		0x08, 0x55, /* 8: deemphasis all off */
 		0xff, 0xff
 	};
-	static unsigned char inits_ak4355[] = {
+	static const unsigned char inits_ak4355[] = {
 		0x01, 0x02, /* 1: reset and soft-mute */
 		0x00, 0x06, /* 0: mode3(i2s), disable auto-clock detect,
 			     * disable DZF, sharp roll-off, RSTN#=0 */
@@ -204,7 +227,7 @@
 		0x01, 0x01, /* 1: un-reset, unmute */
 		0xff, 0xff
 	};
-	static unsigned char inits_ak4358[] = {
+	static const unsigned char inits_ak4358[] = {
 		0x01, 0x02, /* 1: reset and soft-mute */
 		0x00, 0x06, /* 0: mode3(i2s), disable auto-clock detect,
 			     * disable DZF, sharp roll-off, RSTN#=0 */
@@ -223,7 +246,7 @@
 		0x01, 0x01, /* 1: un-reset, unmute */
 		0xff, 0xff
 	};
-	static unsigned char inits_ak4381[] = {
+	static const unsigned char inits_ak4381[] = {
 		0x00, 0x0c, /* 0: mode3(i2s), disable auto-clock detect */
 		0x01, 0x02, /* 1: de-emphasis off, normal speed,
 			     * sharp roll-off, DZF off */
@@ -236,7 +259,11 @@
 	};
 
 	int chip, num_chips;
-	unsigned char *ptr, reg, data, *inits;
+	const unsigned char *ptr, *inits;
+	unsigned char reg, data;
+
+	memset(ak->images, 0, sizeof(ak->images));
+	memset(ak->volumes, 0, sizeof(ak->volumes));
 
 	switch (ak->type) {
 	case SND_AK4524:
@@ -263,6 +290,9 @@
 		inits = inits_ak4381;
 		num_chips = ak->num_dacs / 2;
 		break;
+	case SND_AK5365:
+		/* FIXME: any init sequence? */
+		return;
 	default:
 		snd_BUG();
 		return;
@@ -280,14 +310,23 @@
 
 EXPORT_SYMBOL(snd_akm4xxx_init);
 
+/*
+ * Mixer callbacks
+ */
+#define AK_IPGA 			(1<<20)	/* including IPGA */
+#define AK_VOL_CVT 			(1<<21)	/* need dB conversion */
+#define AK_NEEDSMSB 			(1<<22)	/* need MSB update bit */
+#define AK_INVERT 			(1<<23)	/* data is inverted */
 #define AK_GET_CHIP(val)		(((val) >> 8) & 0xff)
 #define AK_GET_ADDR(val)		((val) & 0xff)
-#define AK_GET_SHIFT(val)		(((val) >> 16) & 0x7f)
+#define AK_GET_SHIFT(val)		(((val) >> 16) & 0x0f)
+#define AK_GET_VOL_CVT(val)		(((val) >> 21) & 1)
+#define AK_GET_IPGA(val)		(((val) >> 20) & 1)
+#define AK_GET_NEEDSMSB(val)		(((val) >> 22) & 1)
 #define AK_GET_INVERT(val)		(((val) >> 23) & 1)
 #define AK_GET_MASK(val)		(((val) >> 24) & 0xff)
 #define AK_COMPOSE(chip,addr,shift,mask) \
 	(((chip) << 8) | (addr) | ((shift) << 16) | ((mask) << 24))
-#define AK_INVERT 			(1<<23)
 
 static int snd_akm4xxx_volume_info(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_info *uinfo)
@@ -307,31 +346,39 @@
 	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
 	int chip = AK_GET_CHIP(kcontrol->private_value);
 	int addr = AK_GET_ADDR(kcontrol->private_value);
-	int invert = AK_GET_INVERT(kcontrol->private_value);
-	unsigned int mask = AK_GET_MASK(kcontrol->private_value);
-	unsigned char val = snd_akm4xxx_get(ak, chip, addr);
-	
-	ucontrol->value.integer.value[0] = invert ? mask - val : val;
+
+	ucontrol->value.integer.value[0] = snd_akm4xxx_get_vol(ak, chip, addr);
 	return 0;
 }
 
-static int snd_akm4xxx_volume_put(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
+static int put_ak_reg(struct snd_kcontrol *kcontrol, int addr,
+		      unsigned char nval)
 {
 	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
-	int chip = AK_GET_CHIP(kcontrol->private_value);
-	int addr = AK_GET_ADDR(kcontrol->private_value);
-	int invert = AK_GET_INVERT(kcontrol->private_value);
 	unsigned int mask = AK_GET_MASK(kcontrol->private_value);
-	unsigned char nval = ucontrol->value.integer.value[0] % (mask+1);
-	int change;
+	int chip = AK_GET_CHIP(kcontrol->private_value);
 
-	if (invert)
+	if (snd_akm4xxx_get_vol(ak, chip, addr) == nval)
+		return 0;
+
+	snd_akm4xxx_set_vol(ak, chip, addr, nval);
+	if (AK_GET_VOL_CVT(kcontrol->private_value) && nval < 128)
+		nval = vol_cvt_datt[nval];
+	if (AK_GET_IPGA(kcontrol->private_value) && nval >= 128)
+		nval++; /* need to correct + 1 since both 127 and 128 are 0dB */
+	if (AK_GET_INVERT(kcontrol->private_value))
 		nval = mask - nval;
-	change = snd_akm4xxx_get(ak, chip, addr) != nval;
-	if (change)
-		snd_akm4xxx_write(ak, chip, addr, nval);
-	return change;
+	if (AK_GET_NEEDSMSB(kcontrol->private_value))
+		nval |= 0x80;
+	snd_akm4xxx_write(ak, chip, addr, nval);
+	return 1;
+}
+
+static int snd_akm4xxx_volume_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return put_ak_reg(kcontrol, AK_GET_ADDR(kcontrol->private_value),
+			  ucontrol->value.integer.value[0]);
 }
 
 static int snd_akm4xxx_stereo_volume_info(struct snd_kcontrol *kcontrol,
@@ -352,77 +399,21 @@
 	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
 	int chip = AK_GET_CHIP(kcontrol->private_value);
 	int addr = AK_GET_ADDR(kcontrol->private_value);
-	int invert = AK_GET_INVERT(kcontrol->private_value);
-	unsigned int mask = AK_GET_MASK(kcontrol->private_value);
-	unsigned char val = snd_akm4xxx_get(ak, chip, addr);
-	
-	ucontrol->value.integer.value[0] = invert ? mask - val : val;
-
-	val = snd_akm4xxx_get(ak, chip, addr+1);
-	ucontrol->value.integer.value[1] = invert ? mask - val : val;
 
+	ucontrol->value.integer.value[0] = snd_akm4xxx_get_vol(ak, chip, addr);
+	ucontrol->value.integer.value[1] = snd_akm4xxx_get_vol(ak, chip, addr+1);
 	return 0;
 }
 
 static int snd_akm4xxx_stereo_volume_put(struct snd_kcontrol *kcontrol,
 					 struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
-	int chip = AK_GET_CHIP(kcontrol->private_value);
 	int addr = AK_GET_ADDR(kcontrol->private_value);
-	int invert = AK_GET_INVERT(kcontrol->private_value);
-	unsigned int mask = AK_GET_MASK(kcontrol->private_value);
-	unsigned char nval = ucontrol->value.integer.value[0] % (mask+1);
-	int change0, change1;
-
-	if (invert)
-		nval = mask - nval;
-	change0 = snd_akm4xxx_get(ak, chip, addr) != nval;
-	if (change0)
-		snd_akm4xxx_write(ak, chip, addr, nval);
-
-	nval = ucontrol->value.integer.value[1] % (mask+1);
-	if (invert)
-		nval = mask - nval;
-	change1 = snd_akm4xxx_get(ak, chip, addr+1) != nval;
-	if (change1)
-		snd_akm4xxx_write(ak, chip, addr+1, nval);
-
-
-	return change0 || change1;
-}
-
-static int snd_akm4xxx_ipga_gain_info(struct snd_kcontrol *kcontrol,
-				      struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 36;
-	return 0;
-}
-
-static int snd_akm4xxx_ipga_gain_get(struct snd_kcontrol *kcontrol,
-				     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
-	int chip = AK_GET_CHIP(kcontrol->private_value);
-	int addr = AK_GET_ADDR(kcontrol->private_value);
-	ucontrol->value.integer.value[0] =
-		snd_akm4xxx_get_ipga(ak, chip, addr) & 0x7f;
-	return 0;
-}
+	int change;
 
-static int snd_akm4xxx_ipga_gain_put(struct snd_kcontrol *kcontrol,
-				     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
-	int chip = AK_GET_CHIP(kcontrol->private_value);
-	int addr = AK_GET_ADDR(kcontrol->private_value);
-	unsigned char nval = (ucontrol->value.integer.value[0] % 37) | 0x80;
-	int change = snd_akm4xxx_get_ipga(ak, chip, addr) != nval;
-	if (change)
-		snd_akm4xxx_write(ak, chip, addr, nval);
+	change = put_ak_reg(kcontrol, addr, ucontrol->value.integer.value[0]);
+	change |= put_ak_reg(kcontrol, addr + 1,
+			     ucontrol->value.integer.value[1]);
 	return change;
 }
 
@@ -472,179 +463,361 @@
 	return change;
 }
 
+static int ak4xxx_switch_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int ak4xxx_switch_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
+	int chip = AK_GET_CHIP(kcontrol->private_value);
+	int addr = AK_GET_ADDR(kcontrol->private_value);
+	int shift = AK_GET_SHIFT(kcontrol->private_value);
+	int invert = AK_GET_INVERT(kcontrol->private_value);
+	unsigned char val = snd_akm4xxx_get(ak, chip, addr);
+
+	if (invert)
+		val = ! val;
+	ucontrol->value.integer.value[0] = (val & (1<<shift)) != 0;
+	return 0;
+}
+
+static int ak4xxx_switch_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
+	int chip = AK_GET_CHIP(kcontrol->private_value);
+	int addr = AK_GET_ADDR(kcontrol->private_value);
+	int shift = AK_GET_SHIFT(kcontrol->private_value);
+	int invert = AK_GET_INVERT(kcontrol->private_value);
+	long flag = ucontrol->value.integer.value[0];
+	unsigned char val, oval;
+	int change;
+
+	if (invert)
+		flag = ! flag;
+	oval = snd_akm4xxx_get(ak, chip, addr);
+	if (flag)
+		val = oval | (1<<shift);
+	else
+		val = oval & ~(1<<shift);
+	change = (oval != val);
+	if (change)
+		snd_akm4xxx_write(ak, chip, addr, val);
+	return change;
+}
+
+#define AK5365_NUM_INPUTS 5
+
+static int ak4xxx_capture_source_info(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
+	int mixer_ch = AK_GET_SHIFT(kcontrol->private_value);
+	const char **input_names;
+	int  num_names, idx;
+
+	input_names = ak->adc_info[mixer_ch].input_names;
+
+	num_names = 0;
+	while (num_names < AK5365_NUM_INPUTS && input_names[num_names])
+		++num_names;
+	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = num_names;
+	idx = uinfo->value.enumerated.item;
+	if (idx >= num_names)
+		return -EINVAL;
+	strncpy(uinfo->value.enumerated.name, input_names[idx],
+		sizeof(uinfo->value.enumerated.name));
+	return 0;
+}
+
+static int ak4xxx_capture_source_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
+	int chip = AK_GET_CHIP(kcontrol->private_value);
+	int addr = AK_GET_ADDR(kcontrol->private_value);
+	int mask = AK_GET_MASK(kcontrol->private_value);
+	unsigned char val;
+
+	val = snd_akm4xxx_get(ak, chip, addr) & mask;
+	ucontrol->value.enumerated.item[0] = val;
+	return 0;
+}
+
+static int ak4xxx_capture_source_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_akm4xxx *ak = snd_kcontrol_chip(kcontrol);
+	int chip = AK_GET_CHIP(kcontrol->private_value);
+	int addr = AK_GET_ADDR(kcontrol->private_value);
+	int mask = AK_GET_MASK(kcontrol->private_value);
+	unsigned char oval, val;
+
+	oval = snd_akm4xxx_get(ak, chip, addr);
+	val = oval & ~mask;
+	val |= ucontrol->value.enumerated.item[0] & mask;
+	if (val != oval) {
+		snd_akm4xxx_write(ak, chip, addr, val);
+		return 1;
+	}
+	return 0;
+}
+
 /*
  * build AK4xxx controls
  */
 
-int snd_akm4xxx_build_controls(struct snd_akm4xxx *ak)
+static int build_dac_controls(struct snd_akm4xxx *ak)
 {
-	unsigned int idx, num_emphs;
-	struct snd_kcontrol *ctl;
-	int err;
-	int mixer_ch = 0;
-	int num_stereo;
-
-	ctl = kmalloc(sizeof(*ctl), GFP_KERNEL);
-	if (! ctl)
-		return -ENOMEM;
+	int idx, err, mixer_ch, num_stereo;
+	struct snd_kcontrol_new knew;
 
+	mixer_ch = 0;
 	for (idx = 0; idx < ak->num_dacs; ) {
-		memset(ctl, 0, sizeof(*ctl));
-		if (ak->channel_names == NULL) {
-			strcpy(ctl->id.name, "DAC Volume");
+		memset(&knew, 0, sizeof(knew));
+		if (! ak->dac_info || ! ak->dac_info[mixer_ch].name) {
+			knew.name = "DAC Volume";
+			knew.index = mixer_ch + ak->idx_offset * 2;
 			num_stereo = 1;
-			ctl->id.index = mixer_ch + ak->idx_offset * 2;
 		} else {
-			strcpy(ctl->id.name, ak->channel_names[mixer_ch]);
-			num_stereo = ak->num_stereo[mixer_ch];
-			ctl->id.index = 0;
+			knew.name = ak->dac_info[mixer_ch].name;
+			num_stereo = ak->dac_info[mixer_ch].num_channels;
 		}
-		ctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-		ctl->count = 1;
+		knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		knew.count = 1;
+		knew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			SNDRV_CTL_ELEM_ACCESS_TLV_READ;
 		if (num_stereo == 2) {
-			ctl->info = snd_akm4xxx_stereo_volume_info;
-			ctl->get = snd_akm4xxx_stereo_volume_get;
-			ctl->put = snd_akm4xxx_stereo_volume_put;
+			knew.info = snd_akm4xxx_stereo_volume_info;
+			knew.get = snd_akm4xxx_stereo_volume_get;
+			knew.put = snd_akm4xxx_stereo_volume_put;
 		} else {
-			ctl->info = snd_akm4xxx_volume_info;
-			ctl->get = snd_akm4xxx_volume_get;
-			ctl->put = snd_akm4xxx_volume_put;
+			knew.info = snd_akm4xxx_volume_info;
+			knew.get = snd_akm4xxx_volume_get;
+			knew.put = snd_akm4xxx_volume_put;
 		}
 		switch (ak->type) {
 		case SND_AK4524:
 			/* register 6 & 7 */
-			ctl->private_value =
-				AK_COMPOSE(idx/2, (idx%2) + 6, 0, 127);
+			knew.private_value =
+				AK_COMPOSE(idx/2, (idx%2) + 6, 0, 127) |
+				AK_VOL_CVT;
+			knew.tlv.p = db_scale_vol_datt;
 			break;
 		case SND_AK4528:
 			/* register 4 & 5 */
-			ctl->private_value =
-				AK_COMPOSE(idx/2, (idx%2) + 4, 0, 127);
+			knew.private_value =
+				AK_COMPOSE(idx/2, (idx%2) + 4, 0, 127) |
+				AK_VOL_CVT;
+			knew.tlv.p = db_scale_vol_datt;
 			break;
 		case SND_AK4529: {
 			/* registers 2-7 and b,c */
 			int val = idx < 6 ? idx + 2 : (idx - 6) + 0xb;
-			ctl->private_value =
+			knew.private_value =
 				AK_COMPOSE(0, val, 0, 255) | AK_INVERT;
+			knew.tlv.p = db_scale_8bit;
 			break;
 		}
 		case SND_AK4355:
 			/* register 4-9, chip #0 only */
-			ctl->private_value = AK_COMPOSE(0, idx + 4, 0, 255);
+			knew.private_value = AK_COMPOSE(0, idx + 4, 0, 255);
+			knew.tlv.p = db_scale_8bit;
 			break;
-		case SND_AK4358:
-			if (idx >= 6)
-				/* register 4-9, chip #0 only */
-				ctl->private_value =
-					AK_COMPOSE(0, idx + 5, 0, 255);
-			else
-				/* register 4-9, chip #0 only */
-				ctl->private_value =
-					AK_COMPOSE(0, idx + 4, 0, 255);
+		case SND_AK4358: {
+			/* register 4-9 and 11-12, chip #0 only */
+			int  addr = idx < 6 ? idx + 4 : idx + 5;
+			knew.private_value =
+				AK_COMPOSE(0, addr, 0, 127) | AK_NEEDSMSB;
+			knew.tlv.p = db_scale_7bit;
 			break;
+		}
 		case SND_AK4381:
 			/* register 3 & 4 */
-			ctl->private_value =
+			knew.private_value =
 				AK_COMPOSE(idx/2, (idx%2) + 3, 0, 255);
+			knew.tlv.p = db_scale_linear;
 			break;
 		default:
-			err = -EINVAL;
-			goto __error;
+			return -EINVAL;
 		}
 
-		ctl->private_data = ak;
-		err = snd_ctl_add(ak->card,
-				  snd_ctl_new(ctl, SNDRV_CTL_ELEM_ACCESS_READ|
-					      SNDRV_CTL_ELEM_ACCESS_WRITE));
+		err = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));
 		if (err < 0)
-			goto __error;
+			return err;
 
 		idx += num_stereo;
 		mixer_ch++;
 	}
-	for (idx = 0; idx < ak->num_adcs && ak->type == SND_AK4524; ++idx) {
-		memset(ctl, 0, sizeof(*ctl));
-		strcpy(ctl->id.name, "ADC Volume");
-		ctl->id.index = idx + ak->idx_offset * 2;
-		ctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-		ctl->count = 1;
-		ctl->info = snd_akm4xxx_volume_info;
-		ctl->get = snd_akm4xxx_volume_get;
-		ctl->put = snd_akm4xxx_volume_put;
-		/* register 4 & 5 */
-		ctl->private_value =
-			AK_COMPOSE(idx/2, (idx%2) + 4, 0, 127);
-		ctl->private_data = ak;
-		err = snd_ctl_add(ak->card,
-				  snd_ctl_new(ctl, SNDRV_CTL_ELEM_ACCESS_READ|
-					      SNDRV_CTL_ELEM_ACCESS_WRITE));
-		if (err < 0)
-			goto __error;
+	return 0;
+}
 
-		memset(ctl, 0, sizeof(*ctl));
-		strcpy(ctl->id.name, "IPGA Analog Capture Volume");
-		ctl->id.index = idx + ak->idx_offset * 2;
-		ctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-		ctl->count = 1;
-		ctl->info = snd_akm4xxx_ipga_gain_info;
-		ctl->get = snd_akm4xxx_ipga_gain_get;
-		ctl->put = snd_akm4xxx_ipga_gain_put;
+static int build_adc_controls(struct snd_akm4xxx *ak)
+{
+	int idx, err, mixer_ch, num_stereo;
+	struct snd_kcontrol_new knew;
+
+	mixer_ch = 0;
+	for (idx = 0; idx < ak->num_adcs;) {
+		memset(&knew, 0, sizeof(knew));
+		if (! ak->adc_info || ! ak->adc_info[mixer_ch].name) {
+			knew.name = "ADC Volume";
+			knew.index = mixer_ch + ak->idx_offset * 2;
+			num_stereo = 1;
+		} else {
+			knew.name = ak->adc_info[mixer_ch].name;
+			num_stereo = ak->adc_info[mixer_ch].num_channels;
+		}
+		knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		knew.count = 1;
+		knew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			SNDRV_CTL_ELEM_ACCESS_TLV_READ;
+		if (num_stereo == 2) {
+			knew.info = snd_akm4xxx_stereo_volume_info;
+			knew.get = snd_akm4xxx_stereo_volume_get;
+			knew.put = snd_akm4xxx_stereo_volume_put;
+		} else {
+			knew.info = snd_akm4xxx_volume_info;
+			knew.get = snd_akm4xxx_volume_get;
+			knew.put = snd_akm4xxx_volume_put;
+		}
 		/* register 4 & 5 */
-		ctl->private_value = AK_COMPOSE(idx/2, (idx%2) + 4, 0, 0);
-		ctl->private_data = ak;
-		err = snd_ctl_add(ak->card,
-				  snd_ctl_new(ctl, SNDRV_CTL_ELEM_ACCESS_READ|
-					      SNDRV_CTL_ELEM_ACCESS_WRITE));
+		if (ak->type == SND_AK5365)
+			knew.private_value =
+				AK_COMPOSE(idx/2, (idx%2) + 4, 0, 151) |
+				AK_VOL_CVT | AK_IPGA;
+		else
+			knew.private_value =
+				AK_COMPOSE(idx/2, (idx%2) + 4, 0, 163) |
+				AK_VOL_CVT | AK_IPGA;
+		knew.tlv.p = db_scale_vol_datt;
+		err = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));
 		if (err < 0)
-			goto __error;
+			return err;
+
+		if (ak->type == SND_AK5365 && (idx % 2) == 0) {
+			if (! ak->adc_info || 
+			    ! ak->adc_info[mixer_ch].switch_name) {
+				knew.name = "Capture Switch";
+				knew.index = mixer_ch + ak->idx_offset * 2;
+			} else
+				knew.name = ak->adc_info[mixer_ch].switch_name;
+			knew.info = ak4xxx_switch_info;
+			knew.get = ak4xxx_switch_get;
+			knew.put = ak4xxx_switch_put;
+			knew.access = 0;
+			/* register 2, bit 0 (SMUTE): 0 = normal operation,
+			   1 = mute */
+			knew.private_value =
+				AK_COMPOSE(idx/2, 2, 0, 0) | AK_INVERT;
+			err = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));
+			if (err < 0)
+				return err;
+
+			memset(&knew, 0, sizeof(knew));
+			knew.name = ak->adc_info[mixer_ch].selector_name;
+			if (!knew.name) {
+				knew.name = "Capture Channel";
+				knew.index = mixer_ch + ak->idx_offset * 2;
+			}
+
+			knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+			knew.info = ak4xxx_capture_source_info;
+			knew.get = ak4xxx_capture_source_get;
+			knew.put = ak4xxx_capture_source_put;
+			knew.access = 0;
+			/* input selector control: reg. 1, bits 0-2.
+			 * mis-use 'shift' to pass mixer_ch */
+			knew.private_value
+				= AK_COMPOSE(idx/2, 1, mixer_ch, 0x07);
+			err = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));
+			if (err < 0)
+				return err;
+		}
+
+		idx += num_stereo;
+		mixer_ch++;
 	}
-	if (ak->type == SND_AK4355 || ak->type == SND_AK4358)
-		num_emphs = 1;
-	else
-		num_emphs = ak->num_dacs / 2;
+	return 0;
+}
+
+static int build_deemphasis(struct snd_akm4xxx *ak, int num_emphs)
+{
+	int idx, err;
+	struct snd_kcontrol_new knew;
+
 	for (idx = 0; idx < num_emphs; idx++) {
-		memset(ctl, 0, sizeof(*ctl));
-		strcpy(ctl->id.name, "Deemphasis");
-		ctl->id.index = idx + ak->idx_offset;
-		ctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-		ctl->count = 1;
-		ctl->info = snd_akm4xxx_deemphasis_info;
-		ctl->get = snd_akm4xxx_deemphasis_get;
-		ctl->put = snd_akm4xxx_deemphasis_put;
+		memset(&knew, 0, sizeof(knew));
+		knew.name = "Deemphasis";
+		knew.index = idx + ak->idx_offset;
+		knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		knew.count = 1;
+		knew.info = snd_akm4xxx_deemphasis_info;
+		knew.get = snd_akm4xxx_deemphasis_get;
+		knew.put = snd_akm4xxx_deemphasis_put;
 		switch (ak->type) {
 		case SND_AK4524:
 		case SND_AK4528:
 			/* register 3 */
-			ctl->private_value = AK_COMPOSE(idx, 3, 0, 0);
+			knew.private_value = AK_COMPOSE(idx, 3, 0, 0);
 			break;
 		case SND_AK4529: {
 			int shift = idx == 3 ? 6 : (2 - idx) * 2;
 			/* register 8 with shift */
-			ctl->private_value = AK_COMPOSE(0, 8, shift, 0);
+			knew.private_value = AK_COMPOSE(0, 8, shift, 0);
 			break;
 		}
 		case SND_AK4355:
 		case SND_AK4358:
-			ctl->private_value = AK_COMPOSE(idx, 3, 0, 0);
+			knew.private_value = AK_COMPOSE(idx, 3, 0, 0);
 			break;
 		case SND_AK4381:
-			ctl->private_value = AK_COMPOSE(idx, 1, 1, 0);
+			knew.private_value = AK_COMPOSE(idx, 1, 1, 0);
 			break;
+		default:
+			return -EINVAL;
 		}
-		ctl->private_data = ak;
-		err = snd_ctl_add(ak->card,
-				  snd_ctl_new(ctl, SNDRV_CTL_ELEM_ACCESS_READ|
-					      SNDRV_CTL_ELEM_ACCESS_WRITE));
+		err = snd_ctl_add(ak->card, snd_ctl_new1(&knew, ak));
 		if (err < 0)
-			goto __error;
+			return err;
 	}
-	err = 0;
-
- __error:
-	kfree(ctl);
-	return err;
+	return 0;
 }
 
+int snd_akm4xxx_build_controls(struct snd_akm4xxx *ak)
+{
+	int err, num_emphs;
+
+	err = build_dac_controls(ak);
+	if (err < 0)
+		return err;
+
+	err = build_adc_controls(ak);
+	if (err < 0)
+		return err;
+
+	if (ak->type == SND_AK4355 || ak->type == SND_AK4358)
+		num_emphs = 1;
+	else
+		num_emphs = ak->num_dacs / 2;
+	err = build_deemphasis(ak, num_emphs);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+	
 EXPORT_SYMBOL(snd_akm4xxx_build_controls);
 
 static int __init alsa_akm4xxx_module_init(void)
--- linux-2.6.18.noarch/sound/i2c/other/Makefile.orig	2007-06-05 16:07:49.000000000 -0400
+++ linux-2.6.18.noarch/sound/i2c/other/Makefile	2007-06-05 17:42:31.000000000 -0400
@@ -6,11 +6,11 @@
 snd-ak4114-objs := ak4114.o
 snd-ak4117-objs := ak4117.o
 snd-ak4xxx-adda-objs := ak4xxx-adda.o
+snd-pt2258-objs := pt2258.o
 snd-tea575x-tuner-objs := tea575x-tuner.o
 
 # Module Dependency
 obj-$(CONFIG_SND_PDAUDIOCF) += snd-ak4117.o
 obj-$(CONFIG_SND_ICE1712) += snd-ak4xxx-adda.o
-obj-$(CONFIG_SND_ICE1724) += snd-ak4xxx-adda.o
-obj-$(CONFIG_SND_ICE1724) += snd-ak4114.o
+obj-$(CONFIG_SND_ICE1724) += snd-ak4114.o snd-ak4xxx-adda.o snd-pt2258.o
 obj-$(CONFIG_SND_FM801_TEA575X) += snd-tea575x-tuner.o
--- linux-2.6.18.noarch/sound/i2c/other/pt2258.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/i2c/other/pt2258.c	2007-06-05 17:42:31.000000000 -0400
@@ -0,0 +1,233 @@
+/*
+ *   ALSA Driver for the PT2258 volume controller.
+ *
+ *	Copyright (c) 2006  Jochen Voss <voss@seehuhn.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */      
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/tlv.h>
+#include <sound/i2c.h>
+#include <sound/pt2258.h>
+
+MODULE_AUTHOR("Jochen Voss <voss@seehuhn.de>");
+MODULE_DESCRIPTION("PT2258 volume controller (Princeton Technology Corp.)");
+MODULE_LICENSE("GPL");
+
+#define PT2258_CMD_RESET 0xc0
+#define PT2258_CMD_UNMUTE 0xf8
+#define PT2258_CMD_MUTE 0xf9
+
+static const unsigned char pt2258_channel_code[12] = {
+	0x80, 0x90,		/* channel 1: -10dB, -1dB */
+	0x40, 0x50,		/* channel 2: -10dB, -1dB */
+	0x00, 0x10,		/* channel 3: -10dB, -1dB */
+	0x20, 0x30,		/* channel 4: -10dB, -1dB */
+	0x60, 0x70,		/* channel 5: -10dB, -1dB */
+	0xa0, 0xb0		/* channel 6: -10dB, -1dB */
+};
+
+int snd_pt2258_reset(struct snd_pt2258 *pt)
+{
+	unsigned char bytes[2];
+	int i;
+
+	/* reset chip */
+	bytes[0] = PT2258_CMD_RESET;
+	snd_i2c_lock(pt->i2c_bus);
+	if (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)
+		goto __error;
+	snd_i2c_unlock(pt->i2c_bus);
+
+	/* mute all channels */
+	pt->mute = 1;
+	bytes[0] = PT2258_CMD_MUTE;
+	snd_i2c_lock(pt->i2c_bus);
+	if (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)
+		goto __error;
+	snd_i2c_unlock(pt->i2c_bus);
+
+	/* set all channels to 0dB */
+	for (i = 0; i < 6; ++i)
+		pt->volume[i] = 0;
+	bytes[0] = 0xd0;
+	bytes[1] = 0xe0;
+	snd_i2c_lock(pt->i2c_bus);
+	if (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)
+		goto __error;
+	snd_i2c_unlock(pt->i2c_bus);
+
+	return 0;
+
+      __error:
+	snd_i2c_unlock(pt->i2c_bus);
+	snd_printk(KERN_ERR "PT2258 reset failed\n");
+	return -EIO;
+}
+
+static int pt2258_stereo_volume_info(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 79;
+	return 0;
+}
+
+static int pt2258_stereo_volume_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pt2258 *pt = kcontrol->private_data;
+	int base = kcontrol->private_value;
+
+	/* chip does not support register reads */
+	ucontrol->value.integer.value[0] = 79 - pt->volume[base];
+	ucontrol->value.integer.value[1] = 79 - pt->volume[base + 1];
+	return 0;
+}
+
+static int pt2258_stereo_volume_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pt2258 *pt = kcontrol->private_data;
+	int base = kcontrol->private_value;
+	unsigned char bytes[2];
+	int val0, val1;
+
+	val0 = 79 - ucontrol->value.integer.value[0];
+	val1 = 79 - ucontrol->value.integer.value[1];
+	if (val0 == pt->volume[base] && val1 == pt->volume[base + 1])
+		return 0;
+
+	pt->volume[base] = val0;
+	bytes[0] = pt2258_channel_code[2 * base] | (val0 / 10);
+	bytes[1] = pt2258_channel_code[2 * base + 1] | (val0 % 10);
+	snd_i2c_lock(pt->i2c_bus);
+	if (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)
+		goto __error;
+	snd_i2c_unlock(pt->i2c_bus);
+
+	pt->volume[base + 1] = val1;
+	bytes[0] = pt2258_channel_code[2 * base + 2] | (val1 / 10);
+	bytes[1] = pt2258_channel_code[2 * base + 3] | (val1 % 10);
+	snd_i2c_lock(pt->i2c_bus);
+	if (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)
+		goto __error;
+	snd_i2c_unlock(pt->i2c_bus);
+
+	return 1;
+
+      __error:
+	snd_i2c_unlock(pt->i2c_bus);
+	snd_printk(KERN_ERR "PT2258 access failed\n");
+	return -EIO;
+}
+
+static int pt2258_switch_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int pt2258_switch_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pt2258 *pt = kcontrol->private_data;
+
+	ucontrol->value.integer.value[0] = !pt->mute;
+	return 0;
+}
+
+static int pt2258_switch_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_pt2258 *pt = kcontrol->private_data;
+	unsigned char bytes[2];
+	int val;
+
+	val = !ucontrol->value.integer.value[0];
+	if (pt->mute == val)
+		return 0;
+
+	pt->mute = val;
+	bytes[0] = val ? PT2258_CMD_MUTE : PT2258_CMD_UNMUTE;
+	snd_i2c_lock(pt->i2c_bus);
+	if (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)
+		goto __error;
+	snd_i2c_unlock(pt->i2c_bus);
+
+	return 1;
+
+      __error:
+	snd_i2c_unlock(pt->i2c_bus);
+	snd_printk(KERN_ERR "PT2258 access failed 2\n");
+	return -EIO;
+}
+
+static const DECLARE_TLV_DB_SCALE(pt2258_db_scale, -7900, 100, 0);
+
+int snd_pt2258_build_controls(struct snd_pt2258 *pt)
+{
+	struct snd_kcontrol_new knew;
+	char *names[3] = {
+		"Mic Loopback Playback Volume",
+		"Line Loopback Playback Volume",
+		"CD Loopback Playback Volume"
+	};
+	int i, err;
+
+	for (i = 0; i < 3; ++i) {
+		memset(&knew, 0, sizeof(knew));
+		knew.name = names[i];
+		knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		knew.count = 1;
+		knew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		    SNDRV_CTL_ELEM_ACCESS_TLV_READ;
+		knew.private_value = 2 * i;
+		knew.info = pt2258_stereo_volume_info;
+		knew.get = pt2258_stereo_volume_get;
+		knew.put = pt2258_stereo_volume_put;
+		knew.tlv.p = pt2258_db_scale;
+
+		err = snd_ctl_add(pt->card, snd_ctl_new1(&knew, pt));
+		if (err < 0)
+			return err;
+	}
+
+	memset(&knew, 0, sizeof(knew));
+	knew.name = "Loopback Switch";
+	knew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	knew.info = pt2258_switch_info;
+	knew.get = pt2258_switch_get;
+	knew.put = pt2258_switch_put;
+	knew.access = 0;
+	err = snd_ctl_add(pt->card, snd_ctl_new1(&knew, pt));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_pt2258_reset);
+EXPORT_SYMBOL(snd_pt2258_build_controls);
--- linux-2.6.18.noarch/sound/i2c/other/ak4114.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/i2c/other/ak4114.c	2007-06-05 23:38:45.000000000 -0400
@@ -23,6 +23,7 @@
 #include <sound/driver.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/workqueue.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
@@ -35,15 +36,14 @@
 
 #define AK4114_ADDR			0x00 /* fixed address */
 
-static void ak4114_stats(void *);
 
 static void reg_write(struct ak4114 *ak4114, unsigned char reg, unsigned char val)
 {
 	ak4114->write(ak4114->private_data, reg, val);
 	if (reg <= AK4114_REG_INT1_MASK)
 		ak4114->regmap[reg] = val;
-	else if (reg >= AK4114_REG_RXCSB0 && reg <= AK4114_REG_TXCSB4)
-		ak4114->txcsb[reg-AK4114_REG_RXCSB0] = val;
+	else if (reg >= AK4114_REG_TXCSB0 && reg <= AK4114_REG_TXCSB4)
+		ak4114->txcsb[reg-AK4114_REG_TXCSB0] = val;
 }
 
 static inline unsigned char reg_read(struct ak4114 *ak4114, unsigned char reg)
@@ -66,10 +66,8 @@
 {
 	chip->init = 1;	/* don't schedule new work */
 	mb();
-	if (chip->workqueue != NULL) {
-		flush_workqueue(chip->workqueue);
-		destroy_workqueue(chip->workqueue);
-	}
+	cancel_delayed_work(&chip->work);
+	flush_scheduled_work();
 	kfree(chip);
 }
 
@@ -82,7 +80,7 @@
 
 int snd_ak4114_create(struct snd_card *card,
 		      ak4114_read_t *read, ak4114_write_t *write,
-		      unsigned char pgm[7], unsigned char txcsb[5],
+		      const unsigned char pgm[7], const unsigned char txcsb[5],
 		      void *private_data, struct ak4114 **r_ak4114)
 {
 	struct ak4114 *chip;
@@ -134,7 +132,8 @@
 	if (reg <= AK4114_REG_INT1_MASK)
 		reg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);
 	else if (reg >= AK4114_REG_TXCSB0 && reg <= AK4114_REG_TXCSB4)
-		reg_write(chip, reg, (chip->txcsb[reg] & ~mask) | val);
+		reg_write(chip, reg,
+			  (chip->txcsb[reg-AK4114_REG_TXCSB0] & ~mask) | val);
 }
 
 void snd_ak4114_reinit(struct ak4114 *chip)
@@ -143,7 +142,7 @@
 
 	chip->init = 1;
 	mb();
-	flush_workqueue(chip->workqueue);
+	flush_scheduled_work();
 	/* bring the chip to reset state and powerdown state */
 	reg_write(chip, AK4114_REG_PWRDN, old & ~(AK4114_RST|AK4114_PWN));
 	udelay(200);
@@ -158,8 +157,7 @@
 	reg_write(chip, AK4114_REG_PWRDN, old | AK4114_RST | AK4114_PWN);
 	/* bring up statistics / event queing */
 	chip->init = 0;
-	INIT_WORK(&chip->work, ak4114_stats, chip);
-	queue_delayed_work(chip->workqueue, &chip->work, HZ / 10);
+	schedule_delayed_work(&chip->work, HZ / 10);
 }
 
 static unsigned int external_rate(unsigned char rcs1)
@@ -561,15 +559,6 @@
 	return res;
 }
 
-static void ak4114_stats(void *data)
-{
-	struct ak4114 *chip = (struct ak4114 *)data;
-
-	if (chip->init)
-		return;
-	snd_ak4114_check_rate_and_errors(chip, 0);
-	queue_delayed_work(chip->workqueue, &chip->work, HZ / 10);
-}
 
 EXPORT_SYMBOL(snd_ak4114_create);
 EXPORT_SYMBOL(snd_ak4114_reg_write);
--- linux-2.6.18.noarch/sound/i2c/other/ak4117.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/i2c/other/ak4117.c	2007-06-05 17:42:31.000000000 -0400
@@ -74,7 +74,7 @@
 }
 
 int snd_ak4117_create(struct snd_card *card, ak4117_read_t *read, ak4117_write_t *write,
-		      unsigned char pgm[5], void *private_data, struct ak4117 **r_ak4117)
+		      const unsigned char pgm[5], void *private_data, struct ak4117 **r_ak4117)
 {
 	struct ak4117 *chip;
 	int err = 0;
--- linux-2.6.18.noarch/sound/sound_core.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/sound_core.c	2007-06-05 17:39:02.000000000 -0400
@@ -170,8 +170,8 @@
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
-	class_device_create(sound_class, NULL, MKDEV(SOUND_MAJOR, s->unit_minor),
-			    dev, s->name+6);
+	device_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),
+		      s->name+6);
 	return r;
 
  fail:
@@ -193,7 +193,7 @@
 	p = __sound_remove_unit(list, unit);
 	spin_unlock(&sound_loader_lock);
 	if (p) {
-		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
+		device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
 		kfree(p);
 	}
 }
@@ -366,25 +366,6 @@
 EXPORT_SYMBOL(register_sound_dsp);
 
 /**
- *	register_sound_synth - register a synth device
- *	@fops: File operations for the driver
- *	@dev: Unit number to allocate
- *
- *	Allocate a synth device. Unit is the number of the synth device requested.
- *	Pass -1 to request the next free synth unit. On success the allocated
- *	number is returned, on failure a negative error code is returned.
- */
-
-
-int register_sound_synth(const struct file_operations *fops, int dev)
-{
-	return sound_insert_unit(&chains[9], fops, dev, 9, 137,
-				 "synth", S_IRUSR | S_IWUSR, NULL);
-}
-
-EXPORT_SYMBOL(register_sound_synth);
-
-/**
  *	unregister_sound_special - unregister a special sound device
  *	@unit: unit number to allocate
  *
@@ -449,28 +430,13 @@
 
 EXPORT_SYMBOL(unregister_sound_dsp);
 
-/**
- *	unregister_sound_synth - unregister a synth device
- *	@unit: unit number to allocate
- *
- *	Release a sound device that was allocated with register_sound_synth().
- *	The unit passed is the return value from the register function.
- */
-
-void unregister_sound_synth(int unit)
-{
-	return sound_remove_unit(&chains[9], unit);
-}
-
-EXPORT_SYMBOL(unregister_sound_synth);
-
 /*
  *	Now our file operations
  */
 
 static int soundcore_open(struct inode *, struct file *);
 
-static struct file_operations soundcore_fops=
+static const struct file_operations soundcore_fops=
 {
 	/* We must have an owner or the module locking fails */
 	.owner	= THIS_MODULE,
@@ -551,10 +517,6 @@
 	return -ENODEV;
 }
 
-extern int mod_firmware_load(const char *, char **);
-EXPORT_SYMBOL(mod_firmware_load);
-
-
 MODULE_DESCRIPTION("Core sound module");
 MODULE_AUTHOR("Alan Cox");
 MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/core/hwdep.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/hwdep.c	2007-06-05 17:41:11.000000000 -0400
@@ -42,19 +42,16 @@
 static int snd_hwdep_free(struct snd_hwdep *hwdep);
 static int snd_hwdep_dev_free(struct snd_device *device);
 static int snd_hwdep_dev_register(struct snd_device *device);
-static int snd_hwdep_dev_unregister(struct snd_device *device);
+static int snd_hwdep_dev_disconnect(struct snd_device *device);
 
 
 static struct snd_hwdep *snd_hwdep_search(struct snd_card *card, int device)
 {
-	struct list_head *p;
 	struct snd_hwdep *hwdep;
 
-	list_for_each(p, &snd_hwdep_devices) {
-		hwdep = list_entry(p, struct snd_hwdep, list);
+	list_for_each_entry(hwdep, &snd_hwdep_devices, list)
 		if (hwdep->card == card && hwdep->device == device)
 			return hwdep;
-	}
 	return NULL;
 }
 
@@ -159,15 +156,16 @@
 	int err = -ENXIO;
 	struct snd_hwdep *hw = file->private_data;
 	struct module *mod = hw->card->module;
+
 	mutex_lock(&hw->open_mutex);
-	if (hw->ops.release) {
+	if (hw->ops.release)
 		err = hw->ops.release(hw, file);
-		wake_up(&hw->open_wait);
-	}
 	if (hw->used > 0)
 		hw->used--;
-	snd_card_file_remove(hw->card, file);
 	mutex_unlock(&hw->open_mutex);
+	wake_up(&hw->open_wait);
+
+	snd_card_file_remove(hw->card, file);
 	module_put(mod);
 	return err;
 }
@@ -319,7 +317,7 @@
 
  */
 
-static struct file_operations snd_hwdep_f_ops =
+static const struct file_operations snd_hwdep_f_ops =
 {
 	.owner = 	THIS_MODULE,
 	.llseek =	snd_hwdep_llseek,
@@ -354,7 +352,7 @@
 	static struct snd_device_ops ops = {
 		.dev_free = snd_hwdep_dev_free,
 		.dev_register = snd_hwdep_dev_register,
-		.dev_unregister = snd_hwdep_dev_unregister
+		.dev_disconnect = snd_hwdep_dev_disconnect,
 	};
 
 	snd_assert(rhwdep != NULL, return -EINVAL);
@@ -440,7 +438,7 @@
 	return 0;
 }
 
-static int snd_hwdep_dev_unregister(struct snd_device *device)
+static int snd_hwdep_dev_disconnect(struct snd_device *device)
 {
 	struct snd_hwdep *hwdep = device->device_data;
 
@@ -455,9 +453,9 @@
 		snd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);
 #endif
 	snd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);
-	list_del(&hwdep->list);
+	list_del_init(&hwdep->list);
 	mutex_unlock(&register_mutex);
-	return snd_hwdep_free(hwdep);
+	return 0;
 }
 
 #ifdef CONFIG_PROC_FS
@@ -468,15 +466,12 @@
 static void snd_hwdep_proc_read(struct snd_info_entry *entry,
 				struct snd_info_buffer *buffer)
 {
-	struct list_head *p;
 	struct snd_hwdep *hwdep;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_hwdep_devices) {
-		hwdep = list_entry(p, struct snd_hwdep, list);
+	list_for_each_entry(hwdep, &snd_hwdep_devices, list)
 		snd_iprintf(buffer, "%02i-%02i: %s\n",
 			    hwdep->card->number, hwdep->device, hwdep->name);
-	}
 	mutex_unlock(&register_mutex);
 }
 
@@ -498,7 +493,7 @@
 
 static void __exit snd_hwdep_proc_done(void)
 {
-	snd_info_unregister(snd_hwdep_proc_entry);
+	snd_info_free_entry(snd_hwdep_proc_entry);
 }
 #else /* !CONFIG_PROC_FS */
 #define snd_hwdep_proc_init()
--- linux-2.6.18.noarch/sound/core/rtctimer.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/rtctimer.c	2007-06-05 17:41:11.000000000 -0400
@@ -22,13 +22,10 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/time.h>
-#include <linux/threads.h>
 #include <linux/interrupt.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/timer.h>
-#include <sound/info.h>
 
 #if defined(CONFIG_RTC) || defined(CONFIG_RTC_MODULE)
 
@@ -167,7 +164,7 @@
 static void __exit rtctimer_exit(void)
 {
 	if (rtctimer) {
-		snd_timer_global_unregister(rtctimer);
+		snd_timer_global_free(rtctimer);
 		rtctimer = NULL;
 	}
 }
--- linux-2.6.18.noarch/sound/core/pcm_compat.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/pcm_compat.c	2007-06-05 17:41:11.000000000 -0400
@@ -478,7 +478,7 @@
 	 * mmap of PCM status/control records because of the size
 	 * incompatibility.
 	 */
-	substream->no_mmap_ctrl = 1;
+	pcm_file->no_compat_mmap = 1;
 
 	switch (cmd) {
 	case SNDRV_PCM_IOCTL_PVERSION:
--- linux-2.6.18.noarch/sound/core/pcm.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/pcm.c	2007-06-05 23:33:30.000000000 -0400
@@ -42,15 +42,12 @@
 static int snd_pcm_dev_free(struct snd_device *device);
 static int snd_pcm_dev_register(struct snd_device *device);
 static int snd_pcm_dev_disconnect(struct snd_device *device);
-static int snd_pcm_dev_unregister(struct snd_device *device);
 
 static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
 {
-	struct list_head *p;
 	struct snd_pcm *pcm;
 
-	list_for_each(p, &snd_pcm_devices) {
-		pcm = list_entry(p, struct snd_pcm, list);
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
 		if (pcm->card == card && pcm->device == device)
 			return pcm;
 	}
@@ -494,19 +491,13 @@
 static int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)
 {
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	if (pstr->proc_xrun_debug_entry) {
-		snd_info_unregister(pstr->proc_xrun_debug_entry);
-		pstr->proc_xrun_debug_entry = NULL;
-	}
+	snd_info_free_entry(pstr->proc_xrun_debug_entry);
+	pstr->proc_xrun_debug_entry = NULL;
 #endif
-	if (pstr->proc_info_entry) {
-		snd_info_unregister(pstr->proc_info_entry);
-		pstr->proc_info_entry = NULL;
-	}
-	if (pstr->proc_root) {
-		snd_info_unregister(pstr->proc_root);
-		pstr->proc_root = NULL;
-	}
+	snd_info_free_entry(pstr->proc_info_entry);
+	pstr->proc_info_entry = NULL;
+	snd_info_free_entry(pstr->proc_root);
+	pstr->proc_root = NULL;
 	return 0;
 }
 
@@ -570,29 +561,19 @@
 
 	return 0;
 }
-		
+
 static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
 {
-	if (substream->proc_info_entry) {
-		snd_info_unregister(substream->proc_info_entry);
-		substream->proc_info_entry = NULL;
-	}
-	if (substream->proc_hw_params_entry) {
-		snd_info_unregister(substream->proc_hw_params_entry);
-		substream->proc_hw_params_entry = NULL;
-	}
-	if (substream->proc_sw_params_entry) {
-		snd_info_unregister(substream->proc_sw_params_entry);
-		substream->proc_sw_params_entry = NULL;
-	}
-	if (substream->proc_status_entry) {
-		snd_info_unregister(substream->proc_status_entry);
-		substream->proc_status_entry = NULL;
-	}
-	if (substream->proc_root) {
-		snd_info_unregister(substream->proc_root);
-		substream->proc_root = NULL;
-	}
+	snd_info_free_entry(substream->proc_info_entry);
+	substream->proc_info_entry = NULL;
+	snd_info_free_entry(substream->proc_hw_params_entry);
+	substream->proc_hw_params_entry = NULL;
+	snd_info_free_entry(substream->proc_sw_params_entry);
+	substream->proc_sw_params_entry = NULL;
+	snd_info_free_entry(substream->proc_status_entry);
+	substream->proc_status_entry = NULL;
+	snd_info_free_entry(substream->proc_root);
+	substream->proc_root = NULL;
 	return 0;
 }
 #else /* !CONFIG_SND_VERBOSE_PROCFS */
@@ -646,6 +627,9 @@
 		substream->number = idx;
 		substream->stream = stream;
 		sprintf(substream->name, "subdevice #%i", idx);
+		snprintf(substream->latency_id, sizeof(substream->latency_id),
+			 "ALSA-PCM%d-%d%c%d", pcm->card->number, pcm->device,
+			 (stream ? 'c' : 'p'), idx);
 		substream->buffer_bytes_max = UINT_MAX;
 		if (prev == NULL)
 			pstr->substream = substream;
@@ -654,6 +638,10 @@
 		err = snd_pcm_substream_proc_init(substream);
 		if (err < 0) {
 			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
+			if (prev == NULL)
+				pstr->substream = NULL;
+			else
+				prev->next = NULL;
 			kfree(substream);
 			return err;
 		}
@@ -696,7 +684,6 @@
 		.dev_free = snd_pcm_dev_free,
 		.dev_register =	snd_pcm_dev_register,
 		.dev_disconnect = snd_pcm_dev_disconnect,
-		.dev_unregister = snd_pcm_dev_unregister
 	};
 
 	snd_assert(rpcm != NULL, return -EINVAL);
@@ -740,6 +727,7 @@
 	substream = pstr->substream;
 	while (substream) {
 		substream_next = substream->next;
+		snd_pcm_timer_done(substream);
 		snd_pcm_substream_proc_done(substream);
 		kfree(substream);
 		substream = substream_next;
@@ -756,7 +744,12 @@
 
 static int snd_pcm_free(struct snd_pcm *pcm)
 {
+	struct snd_pcm_notify *notify;
+
 	snd_assert(pcm != NULL, return -ENXIO);
+	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
+		notify->n_unregister(pcm);
+	}
 	if (pcm->private_free)
 		pcm->private_free(pcm);
 	snd_pcm_lib_preallocate_free_for_all(pcm);
@@ -787,7 +780,6 @@
 	struct snd_pcm_runtime *runtime;
 	struct snd_ctl_file *kctl;
 	struct snd_card *card;
-	struct list_head *list;
 	int prefer_subdevice = -1;
 	size_t size;
 
@@ -800,11 +792,11 @@
 
 	card = pcm->card;
 	down_read(&card->controls_rwsem);
-	list_for_each(list, &card->ctl_files) {
-		kctl = snd_ctl_file(list);
+	list_for_each_entry(kctl, &card->ctl_files, list) {
 		if (kctl->pid == current->pid) {
 			prefer_subdevice = kctl->prefer_pcm_subdevice;
-			break;
+			if (prefer_subdevice != -1)
+				break;
 		}
 	}
 	up_read(&card->controls_rwsem);
@@ -918,11 +910,12 @@
 	substream->pstr->substream_opened--;
 }
 
+
 static int snd_pcm_dev_register(struct snd_device *device)
 {
 	int cidx, err;
 	struct snd_pcm_substream *substream;
-	struct list_head *list;
+	struct snd_pcm_notify *notify;
 	char str[16];
 	struct snd_pcm *pcm = device->device_data;
 
@@ -959,11 +952,10 @@
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			snd_pcm_timer_init(substream);
 	}
-	list_for_each(list, &snd_pcm_notify_list) {
-		struct snd_pcm_notify *notify;
-		notify = list_entry(list, struct snd_pcm_notify, list);
+
+	list_for_each_entry(notify, &snd_pcm_notify_list, list)
 		notify->n_register(pcm);
-	}
+
 	mutex_unlock(&register_mutex);
 	return 0;
 }
@@ -971,35 +963,22 @@
 static int snd_pcm_dev_disconnect(struct snd_device *device)
 {
 	struct snd_pcm *pcm = device->device_data;
-	struct list_head *list;
+	struct snd_pcm_notify *notify;
 	struct snd_pcm_substream *substream;
-	int cidx;
+	int cidx, devtype;
 
 	mutex_lock(&register_mutex);
+	if (list_empty(&pcm->list))
+		goto unlock;
+
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			if (substream->runtime)
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
-	list_for_each(list, &snd_pcm_notify_list) {
-		struct snd_pcm_notify *notify;
-		notify = list_entry(list, struct snd_pcm_notify, list);
+	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
 		notify->n_disconnect(pcm);
 	}
-	mutex_unlock(&register_mutex);
-	return 0;
-}
-
-static int snd_pcm_dev_unregister(struct snd_device *device)
-{
-	int cidx, devtype;
-	struct snd_pcm_substream *substream;
-	struct list_head *list;
-	struct snd_pcm *pcm = device->device_data;
-
-	snd_assert(pcm != NULL, return -ENXIO);
-	mutex_lock(&register_mutex);
-	list_del(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++) {
 		devtype = -1;
 		switch (cidx) {
@@ -1011,33 +990,29 @@
 			break;
 		}
 		snd_unregister_device(devtype, pcm->card, pcm->device);
-		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
-			snd_pcm_timer_done(substream);
-	}
-	list_for_each(list, &snd_pcm_notify_list) {
-		struct snd_pcm_notify *notify;
-		notify = list_entry(list, struct snd_pcm_notify, list);
-		notify->n_unregister(pcm);
 	}
+ unlock:
 	mutex_unlock(&register_mutex);
-	return snd_pcm_free(pcm);
+	return 0;
 }
 
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
-	struct list_head *p;
+	struct snd_pcm *pcm;
 
-	snd_assert(notify != NULL && notify->n_register != NULL && notify->n_unregister != NULL, return -EINVAL);
+	snd_assert(notify != NULL &&
+		   notify->n_register != NULL &&
+		   notify->n_unregister != NULL &&
+		   notify->n_disconnect, return -EINVAL);
 	mutex_lock(&register_mutex);
 	if (nfree) {
 		list_del(&notify->list);
-		list_for_each(p, &snd_pcm_devices)
-			notify->n_unregister(list_entry(p,
-							struct snd_pcm, list));
+		list_for_each_entry(pcm, &snd_pcm_devices, list)
+			notify->n_unregister(pcm);
 	} else {
 		list_add_tail(&notify->list, &snd_pcm_notify_list);
-		list_for_each(p, &snd_pcm_devices)
-			notify->n_register(list_entry(p, struct snd_pcm, list));
+		list_for_each_entry(pcm, &snd_pcm_devices, list)
+			notify->n_register(pcm);
 	}
 	mutex_unlock(&register_mutex);
 	return 0;
@@ -1053,12 +1028,10 @@
 static void snd_pcm_proc_read(struct snd_info_entry *entry,
 			      struct snd_info_buffer *buffer)
 {
-	struct list_head *p;
 	struct snd_pcm *pcm;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_pcm_devices) {
-		pcm = list_entry(p, struct snd_pcm, list);
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
 		snd_iprintf(buffer, "%02i-%02i: %s : %s",
 			    pcm->card->number, pcm->device, pcm->id, pcm->name);
 		if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)
@@ -1090,8 +1063,7 @@
 
 static void snd_pcm_proc_done(void)
 {
-	if (snd_pcm_proc_entry)
-		snd_info_unregister(snd_pcm_proc_entry);
+	snd_info_free_entry(snd_pcm_proc_entry);
 }
 
 #else /* !CONFIG_PROC_FS */
--- linux-2.6.18.noarch/sound/core/control_compat.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/control_compat.c	2007-06-05 17:41:11.000000000 -0400
@@ -392,7 +392,7 @@
 static inline long snd_ctl_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct snd_ctl_file *ctl;
-	struct list_head *list;
+	struct snd_kctl_ioctl *p;
 	void __user *argp = compat_ptr(arg);
 	int err;
 
@@ -407,6 +407,10 @@
 	case SNDRV_CTL_IOCTL_POWER_STATE:
 	case SNDRV_CTL_IOCTL_ELEM_LOCK:
 	case SNDRV_CTL_IOCTL_ELEM_UNLOCK:
+	case SNDRV_CTL_IOCTL_ELEM_REMOVE:
+	case SNDRV_CTL_IOCTL_TLV_READ:
+	case SNDRV_CTL_IOCTL_TLV_WRITE:
+	case SNDRV_CTL_IOCTL_TLV_COMMAND:
 		return snd_ctl_ioctl(file, cmd, (unsigned long)argp);
 	case SNDRV_CTL_IOCTL_ELEM_LIST32:
 		return snd_ctl_elem_list_compat(ctl->card, argp);
@@ -423,8 +427,7 @@
 	}
 
 	down_read(&snd_ioctl_rwsem);
-	list_for_each(list, &snd_control_compat_ioctls) {
-		struct snd_kctl_ioctl *p = list_entry(list, struct snd_kctl_ioctl, list);
+	list_for_each_entry(p, &snd_control_compat_ioctls, list) {
 		if (p->fioctl) {
 			err = p->fioctl(ctl->card, ctl, cmd, arg);
 			if (err != -ENOIOCTLCMD) {
--- linux-2.6.18.noarch/sound/core/seq/instr/ainstr_iw.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/instr/ainstr_iw.c	2007-06-05 17:40:51.000000000 -0400
@@ -20,7 +20,6 @@
  
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/ainstr_iw.h>
--- linux-2.6.18.noarch/sound/core/seq/instr/ainstr_fm.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/instr/ainstr_fm.c	2007-06-05 17:40:51.000000000 -0400
@@ -20,7 +20,6 @@
  
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <sound/core.h>
 #include <sound/ainstr_fm.h>
 #include <sound/initval.h>
--- linux-2.6.18.noarch/sound/core/seq/instr/ainstr_simple.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/instr/ainstr_simple.c	2007-06-05 17:40:51.000000000 -0400
@@ -20,7 +20,6 @@
  
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/ainstr_simple.h>
--- linux-2.6.18.noarch/sound/core/seq/instr/ainstr_gf1.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/instr/ainstr_gf1.c	2007-06-05 17:40:51.000000000 -0400
@@ -20,7 +20,6 @@
  
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/ainstr_gf1.h>
--- linux-2.6.18.noarch/sound/core/seq/seq_clientmgr.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/seq_clientmgr.c	2007-06-05 17:41:07.000000000 -0400
@@ -659,7 +659,6 @@
 	int err = 0, num_ev = 0;
 	struct snd_seq_event event_saved;
 	struct snd_seq_client_port *src_port;
-	struct list_head *p;
 	struct snd_seq_port_subs_info *grp;
 
 	src_port = snd_seq_port_use_ptr(client, event->source.port);
@@ -674,8 +673,7 @@
 		read_lock(&grp->list_lock);
 	else
 		down_read(&grp->list_mutex);
-	list_for_each(p, &grp->list_head) {
-		subs = list_entry(p, struct snd_seq_subscribers, src_list);
+	list_for_each_entry(subs, &grp->list_head, src_list) {
 		event->dest = subs->info.dest;
 		if (subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)
 			/* convert time according to flag with subscription */
@@ -709,15 +707,14 @@
 {
 	int num_ev = 0, err = 0;
 	struct snd_seq_client *dest_client;
-	struct list_head *p;
+	struct snd_seq_client_port *port;
 
 	dest_client = get_event_dest_client(event, SNDRV_SEQ_FILTER_BROADCAST);
 	if (dest_client == NULL)
 		return 0; /* no matching destination */
 
 	read_lock(&dest_client->ports_lock);
-	list_for_each(p, &dest_client->ports_list_head) {
-		struct snd_seq_client_port *port = list_entry(p, struct snd_seq_client_port, list);
+	list_for_each_entry(port, &dest_client->ports_list_head, list) {
 		event->dest.port = port->addr.port;
 		/* pass NULL as source client to avoid error bounce */
 		err = snd_seq_deliver_single_event(NULL, event,
@@ -2473,11 +2470,10 @@
 static void snd_seq_info_dump_ports(struct snd_info_buffer *buffer,
 				    struct snd_seq_client *client)
 {
-	struct list_head *l;
+	struct snd_seq_client_port *p;
 
 	mutex_lock(&client->ports_mutex);
-	list_for_each(l, &client->ports_list_head) {
-		struct snd_seq_client_port *p = list_entry(l, struct snd_seq_client_port, list);
+	list_for_each_entry(p, &client->ports_list_head, list) {
 		snd_iprintf(buffer, "  Port %3d : \"%s\" (%c%c%c%c)\n",
 			    p->addr.port, p->name,
 			    FLAG_PERM_RD(p->capability),
@@ -2542,7 +2538,7 @@
  *  REGISTRATION PART
  */
 
-static struct file_operations snd_seq_f_ops =
+static const struct file_operations snd_seq_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.read =		snd_seq_read,
--- linux-2.6.18.noarch/sound/core/seq/seq_device.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/seq_device.c	2007-06-05 17:41:07.000000000 -0400
@@ -90,7 +90,6 @@
 static int snd_seq_device_dev_free(struct snd_device *device);
 static int snd_seq_device_dev_register(struct snd_device *device);
 static int snd_seq_device_dev_disconnect(struct snd_device *device);
-static int snd_seq_device_dev_unregister(struct snd_device *device);
 
 static int init_device(struct snd_seq_device *dev, struct ops_list *ops);
 static int free_device(struct snd_seq_device *dev, struct ops_list *ops);
@@ -107,11 +106,10 @@
 static void snd_seq_device_info(struct snd_info_entry *entry,
 				struct snd_info_buffer *buffer)
 {
-	struct list_head *head;
+	struct ops_list *ops;
 
 	mutex_lock(&ops_mutex);
-	list_for_each(head, &opslist) {
-		struct ops_list *ops = list_entry(head, struct ops_list, list);
+	list_for_each_entry(ops, &opslist, list) {
 		snd_iprintf(buffer, "snd-%s%s%s%s,%d\n",
 				ops->id,
 				ops->driver & DRIVER_LOADED ? ",loaded" : (ops->driver == DRIVER_EMPTY ? ",empty" : ""),
@@ -144,7 +142,7 @@
 void snd_seq_device_load_drivers(void)
 {
 #ifdef CONFIG_KMOD
-	struct list_head *head;
+	struct ops_list *ops;
 
 	/* Calling request_module during module_init()
 	 * may cause blocking.
@@ -156,8 +154,7 @@
 		return;
 
 	mutex_lock(&ops_mutex);
-	list_for_each(head, &opslist) {
-		struct ops_list *ops = list_entry(head, struct ops_list, list);
+	list_for_each_entry(ops, &opslist, list) {
 		if (! (ops->driver & DRIVER_LOADED) &&
 		    ! (ops->driver & DRIVER_REQUESTED)) {
 			ops->used++;
@@ -189,7 +186,6 @@
 		.dev_free = snd_seq_device_dev_free,
 		.dev_register = snd_seq_device_dev_register,
 		.dev_disconnect = snd_seq_device_dev_disconnect,
-		.dev_unregister = snd_seq_device_dev_unregister
 	};
 
 	if (result)
@@ -309,15 +305,6 @@
 }
 
 /*
- * unregister the existing device
- */
-static int snd_seq_device_dev_unregister(struct snd_device *device)
-{
-	struct snd_seq_device *dev = device->device_data;
-	return snd_seq_device_free(dev);
-}
-
-/*
  * register device driver
  * id = driver id
  * entry = driver operators - duplicated to each instance
@@ -325,8 +312,8 @@
 int snd_seq_device_register_driver(char *id, struct snd_seq_dev_ops *entry,
 				   int argsize)
 {
-	struct list_head *head;
 	struct ops_list *ops;
+	struct snd_seq_device *dev;
 
 	if (id == NULL || entry == NULL ||
 	    entry->init_device == NULL || entry->free_device == NULL)
@@ -352,8 +339,7 @@
 	ops->argsize = argsize;
 
 	/* initialize existing devices if necessary */
-	list_for_each(head, &ops->dev_list) {
-		struct snd_seq_device *dev = list_entry(head, struct snd_seq_device, list);
+	list_for_each_entry(dev, &ops->dev_list, list) {
 		init_device(dev, ops);
 	}
 	mutex_unlock(&ops->reg_mutex);
@@ -405,8 +391,8 @@
  */
 int snd_seq_device_unregister_driver(char *id)
 {
-	struct list_head *head;
 	struct ops_list *ops;
+	struct snd_seq_device *dev;
 
 	ops = find_driver(id, 0);
 	if (ops == NULL)
@@ -422,8 +408,7 @@
 	/* close and release all devices associated with this driver */
 	mutex_lock(&ops->reg_mutex);
 	ops->driver |= DRIVER_LOCKED; /* do not remove this driver recursively */
-	list_for_each(head, &ops->dev_list) {
-		struct snd_seq_device *dev = list_entry(head, struct snd_seq_device, list);
+	list_for_each_entry(dev, &ops->dev_list, list) {
 		free_device(dev, ops);
 	}
 
@@ -523,11 +508,10 @@
  */
 static struct ops_list * find_driver(char *id, int create_if_empty)
 {
-	struct list_head *head;
+	struct ops_list *ops;
 
 	mutex_lock(&ops_mutex);
-	list_for_each(head, &opslist) {
-		struct ops_list *ops = list_entry(head, struct ops_list, list);
+	list_for_each_entry(ops, &opslist, list) {
 		if (strcmp(ops->id, id) == 0) {
 			ops->used++;
 			mutex_unlock(&ops_mutex);
@@ -573,7 +557,7 @@
 {
 	remove_drivers();
 #ifdef CONFIG_PROC_FS
-	snd_info_unregister(info_entry);
+	snd_info_free_entry(info_entry);
 #endif
 	if (num_ops)
 		snd_printk(KERN_ERR "drivers not released (%d)\n", num_ops);
--- linux-2.6.18.noarch/sound/core/seq/seq_memory.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/seq_memory.c	2007-06-05 17:41:07.000000000 -0400
@@ -151,7 +151,7 @@
 		return len;
 	newlen = len;
 	if (size_aligned > 0)
-		newlen = ((len + size_aligned - 1) / size_aligned) * size_aligned;
+		newlen = roundup(len, size_aligned);
 	if (count < newlen)
 		return -EAGAIN;
 
--- linux-2.6.18.noarch/sound/core/seq/seq_ports.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/seq_ports.c	2007-06-05 17:41:07.000000000 -0400
@@ -59,14 +59,12 @@
 struct snd_seq_client_port *snd_seq_port_use_ptr(struct snd_seq_client *client,
 						 int num)
 {
-	struct list_head *p;
 	struct snd_seq_client_port *port;
 
 	if (client == NULL)
 		return NULL;
 	read_lock(&client->ports_lock);
-	list_for_each(p, &client->ports_list_head) {
-		port = list_entry(p, struct snd_seq_client_port, list);
+	list_for_each_entry(port, &client->ports_list_head, list) {
 		if (port->addr.port == num) {
 			if (port->closing)
 				break; /* deleting now */
@@ -85,14 +83,12 @@
 						       struct snd_seq_port_info *pinfo)
 {
 	int num;
-	struct list_head *p;
 	struct snd_seq_client_port *port, *found;
 
 	num = pinfo->addr.port;
 	found = NULL;
 	read_lock(&client->ports_lock);
-	list_for_each(p, &client->ports_list_head) {
-		port = list_entry(p, struct snd_seq_client_port, list);
+	list_for_each_entry(port, &client->ports_list_head, list) {
 		if (port->addr.port < num)
 			continue;
 		if (port->addr.port == num) {
@@ -131,8 +127,7 @@
 						int port)
 {
 	unsigned long flags;
-	struct snd_seq_client_port *new_port;
-	struct list_head *l;
+	struct snd_seq_client_port *new_port, *p;
 	int num = -1;
 	
 	/* sanity check */
@@ -161,15 +156,14 @@
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
 	write_lock_irqsave(&client->ports_lock, flags);
-	list_for_each(l, &client->ports_list_head) {
-		struct snd_seq_client_port *p = list_entry(l, struct snd_seq_client_port, list);
+	list_for_each_entry(p, &client->ports_list_head, list) {
 		if (p->addr.port > num)
 			break;
 		if (port < 0) /* auto-probe mode */
 			num = p->addr.port + 1;
 	}
 	/* insert the new port */
-	list_add_tail(&new_port->list, l);
+	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
 	write_unlock_irqrestore(&client->ports_lock, flags);
@@ -251,9 +245,9 @@
 				list_del(&subs->dest_list);
 			else
 				list_del(&subs->src_list);
+			up_write(&agrp->list_mutex);
 			unsubscribe_port(c, aport, agrp, &subs->info, 1);
 			kfree(subs);
-			up_write(&agrp->list_mutex);
 			snd_seq_port_unlock(aport);
 			snd_seq_client_unlock(c);
 		}
@@ -287,16 +281,14 @@
 int snd_seq_delete_port(struct snd_seq_client *client, int port)
 {
 	unsigned long flags;
-	struct list_head *l;
-	struct snd_seq_client_port *found = NULL;
+	struct snd_seq_client_port *found = NULL, *p;
 
 	mutex_lock(&client->ports_mutex);
 	write_lock_irqsave(&client->ports_lock, flags);
-	list_for_each(l, &client->ports_list_head) {
-		struct snd_seq_client_port *p = list_entry(l, struct snd_seq_client_port, list);
+	list_for_each_entry(p, &client->ports_list_head, list) {
 		if (p->addr.port == port) {
 			/* ok found.  delete from the list at first */
-			list_del(l);
+			list_del(&p->list);
 			client->num_ports--;
 			found = p;
 			break;
@@ -314,7 +306,8 @@
 int snd_seq_delete_all_ports(struct snd_seq_client *client)
 {
 	unsigned long flags;
-	struct list_head deleted_list, *p, *n;
+	struct list_head deleted_list;
+	struct snd_seq_client_port *port, *tmp;
 	
 	/* move the port list to deleted_list, and
 	 * clear the port list in the client data.
@@ -331,9 +324,8 @@
 	write_unlock_irqrestore(&client->ports_lock, flags);
 
 	/* remove each port in deleted_list */
-	list_for_each_safe(p, n, &deleted_list) {
-		struct snd_seq_client_port *port = list_entry(p, struct snd_seq_client_port, list);
-		list_del(p);
+	list_for_each_entry_safe(port, tmp, &deleted_list, list) {
+		list_del(&port->list);
 		snd_seq_system_client_ev_port_exit(port->addr.client, port->addr.port);
 		port_delete(client, port);
 	}
@@ -500,8 +492,7 @@
 {
 	struct snd_seq_port_subs_info *src = &src_port->c_src;
 	struct snd_seq_port_subs_info *dest = &dest_port->c_dest;
-	struct snd_seq_subscribers *subs;
-	struct list_head *p;
+	struct snd_seq_subscribers *subs, *s;
 	int err, src_called = 0;
 	unsigned long flags;
 	int exclusive;
@@ -525,13 +516,11 @@
 		if (src->exclusive || dest->exclusive)
 			goto __error;
 		/* check whether already exists */
-		list_for_each(p, &src->list_head) {
-			struct snd_seq_subscribers *s = list_entry(p, struct snd_seq_subscribers, src_list);
+		list_for_each_entry(s, &src->list_head, src_list) {
 			if (match_subs_info(info, &s->info))
 				goto __error;
 		}
-		list_for_each(p, &dest->list_head) {
-			struct snd_seq_subscribers *s = list_entry(p, struct snd_seq_subscribers, dest_list);
+		list_for_each_entry(s, &dest->list_head, dest_list) {
 			if (match_subs_info(info, &s->info))
 				goto __error;
 		}
@@ -582,7 +571,6 @@
 	struct snd_seq_port_subs_info *src = &src_port->c_src;
 	struct snd_seq_port_subs_info *dest = &dest_port->c_dest;
 	struct snd_seq_subscribers *subs;
-	struct list_head *p;
 	int err = -ENOENT;
 	unsigned long flags;
 
@@ -590,8 +578,7 @@
 	down_write_nested(&dest->list_mutex, SINGLE_DEPTH_NESTING);
 
 	/* look for the connection */
-	list_for_each(p, &src->list_head) {
-		subs = list_entry(p, struct snd_seq_subscribers, src_list);
+	list_for_each_entry(subs, &src->list_head, src_list) {
 		if (match_subs_info(info, &subs->info)) {
 			write_lock_irqsave(&src->list_lock, flags);
 			// write_lock(&dest->list_lock);  // no lock yet
@@ -620,12 +607,10 @@
 struct snd_seq_subscribers *snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,
 							  struct snd_seq_addr *dest_addr)
 {
-	struct list_head *p;
 	struct snd_seq_subscribers *s, *found = NULL;
 
 	down_read(&src_grp->list_mutex);
-	list_for_each(p, &src_grp->list_head) {
-		s = list_entry(p, struct snd_seq_subscribers, src_list);
+	list_for_each_entry(s, &src_grp->list_head, src_list) {
 		if (addr_match(dest_addr, &s->info.dest)) {
 			found = s;
 			break;
--- linux-2.6.18.noarch/sound/core/seq/seq_info.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/seq_info.c	2007-06-05 17:41:07.000000000 -0400
@@ -64,9 +64,9 @@
 
 int __exit snd_seq_info_done(void)
 {
-	snd_info_unregister(queues_entry);
-	snd_info_unregister(clients_entry);
-	snd_info_unregister(timer_entry);
+	snd_info_free_entry(queues_entry);
+	snd_info_free_entry(clients_entry);
+	snd_info_free_entry(timer_entry);
 	return 0;
 }
 #endif
--- linux-2.6.18.noarch/sound/core/seq/seq_virmidi.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/seq_virmidi.c	2007-06-05 17:41:07.000000000 -0400
@@ -38,7 +38,6 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/wait.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/rawmidi.h>
@@ -81,13 +80,11 @@
 					 struct snd_seq_event *ev)
 {
 	struct snd_virmidi *vmidi;
-	struct list_head *list;
 	unsigned char msg[4];
 	int len;
 
 	read_lock(&rdev->filelist_lock);
-	list_for_each(list, &rdev->filelist) {
-		vmidi = list_entry(list, struct snd_virmidi, list);
+	list_for_each_entry(vmidi, &rdev->filelist, list) {
 		if (!vmidi->trigger)
 			continue;
 		if (ev->type == SNDRV_SEQ_EVENT_SYSEX) {
--- linux-2.6.18.noarch/sound/core/seq/oss/seq_oss.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/seq/oss/seq_oss.c	2007-06-05 17:40:58.000000000 -0400
@@ -208,7 +208,7 @@
  * registration of sequencer minor device
  */
 
-static struct file_operations seq_oss_f_ops =
+static const struct file_operations seq_oss_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.read =		odev_read,
@@ -303,8 +303,7 @@
 static void
 unregister_proc(void)
 {
-	if (info_entry)
-		snd_info_unregister(info_entry);
+	snd_info_free_entry(info_entry);
 	info_entry = NULL;
 }
 #endif /* CONFIG_PROC_FS */
--- linux-2.6.18.noarch/sound/core/timer.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/timer.c	2007-06-05 17:41:11.000000000 -0400
@@ -35,9 +35,6 @@
 #include <sound/minors.h>
 #include <sound/initval.h>
 #include <linux/kmod.h>
-#ifdef CONFIG_KERNELD
-#include <linux/kerneld.h>
-#endif
 
 #if defined(CONFIG_SND_HPET) || defined(CONFIG_SND_HPET_MODULE)
 #define DEFAULT_TIMER_LIMIT 3
@@ -88,7 +85,7 @@
 static int snd_timer_free(struct snd_timer *timer);
 static int snd_timer_dev_free(struct snd_device *device);
 static int snd_timer_dev_register(struct snd_device *device);
-static int snd_timer_dev_unregister(struct snd_device *device);
+static int snd_timer_dev_disconnect(struct snd_device *device);
 
 static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);
 
@@ -130,11 +127,8 @@
 static struct snd_timer *snd_timer_find(struct snd_timer_id *tid)
 {
 	struct snd_timer *timer = NULL;
-	struct list_head *p;
-
-	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, struct snd_timer, device_list);
 
+	list_for_each_entry(timer, &snd_timer_list, device_list) {
 		if (timer->tmr_class != tid->dev_class)
 			continue;
 		if ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||
@@ -184,13 +178,10 @@
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *master;
-	struct list_head *p, *q;
 
 	/* FIXME: it's really dumb to look up all entries.. */
-	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, struct snd_timer, device_list);
-		list_for_each(q, &timer->open_list_head) {
-			master = list_entry(q, struct snd_timer_instance, open_list);
+	list_for_each_entry(timer, &snd_timer_list, device_list) {
+		list_for_each_entry(master, &timer->open_list_head, open_list) {
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
 				list_del(&slave->open_list);
@@ -214,16 +205,13 @@
  */
 static void snd_timer_check_master(struct snd_timer_instance *master)
 {
-	struct snd_timer_instance *slave;
-	struct list_head *p, *n;
+	struct snd_timer_instance *slave, *tmp;
 
 	/* check all pending slaves */
-	list_for_each_safe(p, n, &snd_timer_slave_list) {
-		slave = list_entry(p, struct snd_timer_instance, open_list);
+	list_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {
 		if (slave->slave_class == master->slave_class &&
 		    slave->slave_id == master->slave_id) {
-			list_del(p);
-			list_add_tail(p, &master->slave_list_head);
+			list_move_tail(&slave->open_list, &master->slave_list_head);
 			spin_lock_irq(&slave_active_lock);
 			slave->master = master;
 			slave->timer = master->timer;
@@ -317,8 +305,7 @@
 int snd_timer_close(struct snd_timer_instance *timeri)
 {
 	struct snd_timer *timer = NULL;
-	struct list_head *p, *n;
-	struct snd_timer_instance *slave;
+	struct snd_timer_instance *slave, *tmp;
 
 	snd_assert(timeri != NULL, return -ENXIO);
 
@@ -353,12 +340,11 @@
 		    timer->hw.close)
 			timer->hw.close(timer);
 		/* remove slave links */
-		list_for_each_safe(p, n, &timeri->slave_list_head) {
-			slave = list_entry(p, struct snd_timer_instance, open_list);
+		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
+					 open_list) {
 			spin_lock_irq(&slave_active_lock);
 			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
-			list_del(p);
-			list_add_tail(p, &snd_timer_slave_list);
+			list_move_tail(&slave->open_list, &snd_timer_slave_list);
 			slave->master = NULL;
 			slave->timer = NULL;
 			spin_unlock_irq(&slave_active_lock);
@@ -394,7 +380,6 @@
 	unsigned long flags;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ts;
-	struct list_head *n;
 	struct timespec tstamp;
 
 	getnstimeofday(&tstamp);
@@ -413,11 +398,9 @@
 	if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 		return;
 	spin_lock_irqsave(&timer->lock, flags);
-	list_for_each(n, &ti->slave_active_head) {
-		ts = list_entry(n, struct snd_timer_instance, active_list);
+	list_for_each_entry(ts, &ti->slave_active_head, active_list)
 		if (ts->ccallback)
 			ts->ccallback(ti, event + 100, &tstamp, resolution);
-	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
@@ -593,10 +576,8 @@
 {
 	struct snd_timer_instance *ti;
 	unsigned long ticks = ~0UL;
-	struct list_head *p;
 
-	list_for_each(p, &timer->active_list_head) {
-		ti = list_entry(p, struct snd_timer_instance, active_list);
+	list_for_each_entry(ti, &timer->active_list_head, active_list) {
 		if (ti->flags & SNDRV_TIMER_IFLG_START) {
 			ti->flags &= ~SNDRV_TIMER_IFLG_START;
 			ti->flags |= SNDRV_TIMER_IFLG_RUNNING;
@@ -661,9 +642,9 @@
  */
 void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 {
-	struct snd_timer_instance *ti, *ts;
+	struct snd_timer_instance *ti, *ts, *tmp;
 	unsigned long resolution, ticks;
-	struct list_head *p, *q, *n, *ack_list_head;
+	struct list_head *p, *ack_list_head;
 	unsigned long flags;
 	int use_tasklet = 0;
 
@@ -679,12 +660,12 @@
 		resolution = timer->hw.resolution;
 
 	/* loop for all active instances
-	 * Here we cannot use list_for_each because the active_list of a
+	 * Here we cannot use list_for_each_entry because the active_list of a
 	 * processed instance is relinked to done_list_head before the callback
 	 * is called.
 	 */
-	list_for_each_safe(p, n, &timer->active_list_head) {
-		ti = list_entry(p, struct snd_timer_instance, active_list);
+	list_for_each_entry_safe(ti, tmp, &timer->active_list_head,
+				 active_list) {
 		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
 			continue;
 		ti->pticks += ticks_left;
@@ -700,7 +681,7 @@
 		} else {
 			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer->running)
-				list_del(p);
+				list_del(&ti->active_list);
 		}
 		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
 		    (ti->flags & SNDRV_TIMER_IFLG_FAST))
@@ -709,8 +690,7 @@
 			ack_list_head = &timer->sack_list_head;
 		if (list_empty(&ti->ack_list))
 			list_add_tail(&ti->ack_list, ack_list_head);
-		list_for_each(q, &ti->slave_active_head) {
-			ts = list_entry(q, struct snd_timer_instance, active_list);
+		list_for_each_entry(ts, &ti->slave_active_head, active_list) {
 			ts->pticks = ti->pticks;
 			ts->resolution = resolution;
 			if (list_empty(&ts->ack_list))
@@ -718,7 +698,7 @@
 		}
 	}
 	if (timer->flags & SNDRV_TIMER_FLG_RESCHED)
-		snd_timer_reschedule(timer, ticks_left);
+		snd_timer_reschedule(timer, timer->sticks);
 	if (timer->running) {
 		if (timer->hw.flags & SNDRV_TIMER_HW_STOP) {
 			timer->hw.stop(timer);
@@ -773,7 +753,7 @@
 	static struct snd_device_ops ops = {
 		.dev_free = snd_timer_dev_free,
 		.dev_register = snd_timer_dev_register,
-		.dev_unregister = snd_timer_dev_unregister
+		.dev_disconnect = snd_timer_dev_disconnect,
 	};
 
 	snd_assert(tid != NULL, return -EINVAL);
@@ -813,6 +793,21 @@
 static int snd_timer_free(struct snd_timer *timer)
 {
 	snd_assert(timer != NULL, return -ENXIO);
+
+	mutex_lock(&register_mutex);
+	if (! list_empty(&timer->open_list_head)) {
+		struct list_head *p, *n;
+		struct snd_timer_instance *ti;
+		snd_printk(KERN_WARNING "timer %p is busy?\n", timer);
+		list_for_each_safe(p, n, &timer->open_list_head) {
+			list_del_init(p);
+			ti = list_entry(p, struct snd_timer_instance, open_list);
+			ti->timer = NULL;
+		}
+	}
+	list_del(&timer->device_list);
+	mutex_unlock(&register_mutex);
+
 	if (timer->private_free)
 		timer->private_free(timer);
 	kfree(timer);
@@ -829,7 +824,6 @@
 {
 	struct snd_timer *timer = dev->device_data;
 	struct snd_timer *timer1;
-	struct list_head *p;
 
 	snd_assert(timer != NULL && timer->hw.start != NULL &&
 		   timer->hw.stop != NULL, return -ENXIO);
@@ -838,8 +832,7 @@
 	    	return -EINVAL;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_timer_list) {
-		timer1 = list_entry(p, struct snd_timer, device_list);
+	list_for_each_entry(timer1, &snd_timer_list, device_list) {
 		if (timer1->tmr_class > timer->tmr_class)
 			break;
 		if (timer1->tmr_class < timer->tmr_class)
@@ -862,35 +855,18 @@
 		mutex_unlock(&register_mutex);
 		return -EBUSY;
 	}
-	list_add_tail(&timer->device_list, p);
+	list_add_tail(&timer->device_list, &timer1->device_list);
 	mutex_unlock(&register_mutex);
 	return 0;
 }
 
-static int snd_timer_unregister(struct snd_timer *timer)
+static int snd_timer_dev_disconnect(struct snd_device *device)
 {
-	struct list_head *p, *n;
-	struct snd_timer_instance *ti;
-
-	snd_assert(timer != NULL, return -ENXIO);
+	struct snd_timer *timer = device->device_data;
 	mutex_lock(&register_mutex);
-	if (! list_empty(&timer->open_list_head)) {
-		snd_printk(KERN_WARNING "timer 0x%lx is busy?\n", (long)timer);
-		list_for_each_safe(p, n, &timer->open_list_head) {
-			list_del_init(p);
-			ti = list_entry(p, struct snd_timer_instance, open_list);
-			ti->timer = NULL;
-		}
-	}
-	list_del(&timer->device_list);
+	list_del_init(&timer->device_list);
 	mutex_unlock(&register_mutex);
-	return snd_timer_free(timer);
-}
-
-static int snd_timer_dev_unregister(struct snd_device *device)
-{
-	struct snd_timer *timer = device->device_data;
-	return snd_timer_unregister(timer);
+	return 0;
 }
 
 void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)
@@ -898,7 +874,6 @@
 	unsigned long flags;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ti, *ts;
-	struct list_head *p, *n;
 
 	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
 		return;
@@ -913,15 +888,12 @@
 		else
 			resolution = timer->hw.resolution;
 	}
-	list_for_each(p, &timer->active_list_head) {
-		ti = list_entry(p, struct snd_timer_instance, active_list);
+	list_for_each_entry(ti, &timer->active_list_head, active_list) {
 		if (ti->ccallback)
 			ti->ccallback(ti, event, tstamp, resolution);
-		list_for_each(n, &ti->slave_active_head) {
-			ts = list_entry(n, struct snd_timer_instance, active_list);
+		list_for_each_entry(ts, &ti->slave_active_head, active_list)
 			if (ts->ccallback)
 				ts->ccallback(ts, event, tstamp, resolution);
-		}
 	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
@@ -955,18 +927,12 @@
 	return snd_timer_dev_register(&dev);
 }
 
-int snd_timer_global_unregister(struct snd_timer *timer)
-{
-	return snd_timer_unregister(timer);
-}
-
 /*
  *  System timer
  */
 
 struct snd_timer_system_private {
 	struct timer_list tlist;
-	struct timer * timer;
 	unsigned long last_expires;
 	unsigned long last_jiffies;
 	unsigned long correction;
@@ -978,7 +944,7 @@
 	struct snd_timer_system_private *priv = timer->private_data;
 	unsigned long jiff = jiffies;
 	if (time_after(jiff, priv->last_expires))
-		priv->correction = (long)jiff - (long)priv->last_expires;
+		priv->correction += (long)jiff - (long)priv->last_expires;
 	snd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);
 }
 
@@ -994,7 +960,7 @@
 		njiff++;
 	} else {
 		njiff += timer->sticks - priv->correction;
-		priv->correction -= timer->sticks;
+		priv->correction = 0;
 	}
 	priv->last_expires = priv->tlist.expires = njiff;
 	add_timer(&priv->tlist);
@@ -1013,6 +979,7 @@
 		timer->sticks = priv->last_expires - jiff;
 	else
 		timer->sticks = 1;
+	priv->correction = 0;
 	return 0;
 }
 
@@ -1064,11 +1031,9 @@
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *ti;
-	struct list_head *p, *q;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, struct snd_timer, device_list);
+	list_for_each_entry(timer, &snd_timer_list, device_list) {
 		switch (timer->tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
@@ -1095,14 +1060,12 @@
 		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 			snd_iprintf(buffer, " SLAVE");
 		snd_iprintf(buffer, "\n");
-		list_for_each(q, &timer->open_list_head) {
-			ti = list_entry(q, struct snd_timer_instance, open_list);
+		list_for_each_entry(ti, &timer->open_list_head, open_list)
 			snd_iprintf(buffer, "  Client %s : %s\n",
 				    ti->owner ? ti->owner : "unknown",
 				    ti->flags & (SNDRV_TIMER_IFLG_START |
 						 SNDRV_TIMER_IFLG_RUNNING)
 				    ? "running" : "stopped");
-		}
 	}
 	mutex_unlock(&register_mutex);
 }
@@ -1126,7 +1089,7 @@
 
 static void __exit snd_timer_proc_done(void)
 {
-	snd_info_unregister(snd_timer_proc_entry);
+	snd_info_free_entry(snd_timer_proc_entry);
 }
 #else /* !CONFIG_PROC_FS */
 #define snd_timer_proc_init()
@@ -1938,7 +1901,7 @@
 #define snd_timer_user_ioctl_compat	NULL
 #endif
 
-static struct file_operations snd_timer_f_ops =
+static const struct file_operations snd_timer_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.read =		snd_timer_user_read,
@@ -1982,7 +1945,7 @@
 	/* unregister the system timer */
 	list_for_each_safe(p, n, &snd_timer_list) {
 		struct snd_timer *timer = list_entry(p, struct snd_timer, device_list);
-		snd_timer_unregister(timer);
+		snd_timer_free(timer);
 	}
 	snd_timer_proc_done();
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
@@ -2005,5 +1968,4 @@
 EXPORT_SYMBOL(snd_timer_global_new);
 EXPORT_SYMBOL(snd_timer_global_free);
 EXPORT_SYMBOL(snd_timer_global_register);
-EXPORT_SYMBOL(snd_timer_global_unregister);
 EXPORT_SYMBOL(snd_timer_interrupt);
--- linux-2.6.18.noarch/sound/core/control.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/control.c	2007-06-05 17:41:11.000000000 -0400
@@ -75,6 +75,8 @@
 	init_waitqueue_head(&ctl->change_sleep);
 	spin_lock_init(&ctl->read_lock);
 	ctl->card = card;
+	ctl->prefer_pcm_subdevice = -1;
+	ctl->prefer_rawmidi_subdevice = -1;
 	ctl->pid = current->pid;
 	file->private_data = ctl;
 	write_lock_irqsave(&card->ctl_files_rwlock, flags);
@@ -106,7 +108,6 @@
 static int snd_ctl_release(struct inode *inode, struct file *file)
 {
 	unsigned long flags;
-	struct list_head *list;
 	struct snd_card *card;
 	struct snd_ctl_file *ctl;
 	struct snd_kcontrol *control;
@@ -120,12 +121,10 @@
 	list_del(&ctl->list);
 	write_unlock_irqrestore(&card->ctl_files_rwlock, flags);
 	down_write(&card->controls_rwsem);
-	list_for_each(list, &card->controls) {
-		control = snd_kcontrol(list);
+	list_for_each_entry(control, &card->controls, list)
 		for (idx = 0; idx < control->count; idx++)
 			if (control->vd[idx].owner == ctl)
 				control->vd[idx].owner = NULL;
-	}
 	up_write(&card->controls_rwsem);
 	snd_ctl_empty_read_queue(ctl);
 	kfree(ctl);
@@ -138,7 +137,6 @@
 		    struct snd_ctl_elem_id *id)
 {
 	unsigned long flags;
-	struct list_head *flist;
 	struct snd_ctl_file *ctl;
 	struct snd_kctl_event *ev;
 	
@@ -147,14 +145,11 @@
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	card->mixer_oss_change_count++;
 #endif
-	list_for_each(flist, &card->ctl_files) {
-		struct list_head *elist;
-		ctl = snd_ctl_file(flist);
+	list_for_each_entry(ctl, &card->ctl_files, list) {
 		if (!ctl->subscribed)
 			continue;
 		spin_lock_irqsave(&ctl->read_lock, flags);
-		list_for_each(elist, &ctl->events) {
-			ev = snd_kctl_event(elist);
+		list_for_each_entry(ev, &ctl->events, list) {
 			if (ev->id.numid == id->numid) {
 				ev->mask |= mask;
 				goto _found;
@@ -188,7 +183,8 @@
  *
  * Returns the pointer of the new instance, or NULL on failure.
  */
-struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control, unsigned int access)
+static struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,
+					unsigned int access)
 {
 	struct snd_kcontrol *kctl;
 	unsigned int idx;
@@ -206,8 +202,6 @@
 	return kctl;
 }
 
-EXPORT_SYMBOL(snd_ctl_new);
-
 /**
  * snd_ctl_new1 - create a control instance from the template
  * @ncontrol: the initialization record
@@ -236,11 +230,16 @@
 	kctl.id.index = ncontrol->index;
 	kctl.count = ncontrol->count ? ncontrol->count : 1;
 	access = ncontrol->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
-		 (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|SNDRV_CTL_ELEM_ACCESS_INACTIVE|
-		 		      SNDRV_CTL_ELEM_ACCESS_DINDIRECT|SNDRV_CTL_ELEM_ACCESS_INDIRECT));
+		 (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|
+				      SNDRV_CTL_ELEM_ACCESS_INACTIVE|
+		 		      SNDRV_CTL_ELEM_ACCESS_DINDIRECT|
+		 		      SNDRV_CTL_ELEM_ACCESS_INDIRECT|
+		 		      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE|
+		 		      SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK));
 	kctl.info = ncontrol->info;
 	kctl.get = ncontrol->get;
 	kctl.put = ncontrol->put;
+	kctl.tlv.p = ncontrol->tlv.p;
 	kctl.private_value = ncontrol->private_value;
 	kctl.private_data = private_data;
 	return snd_ctl_new(&kctl, access);
@@ -270,11 +269,9 @@
 static unsigned int snd_ctl_hole_check(struct snd_card *card,
 				       unsigned int count)
 {
-	struct list_head *list;
 	struct snd_kcontrol *kctl;
 
-	list_for_each(list, &card->controls) {
-		kctl = snd_kcontrol(list);
+	list_for_each_entry(kctl, &card->controls, list) {
 		if ((kctl->id.numid <= card->last_numid &&
 		     kctl->id.numid + kctl->count > card->last_numid) ||
 		    (kctl->id.numid <= card->last_numid + count - 1 &&
@@ -491,12 +488,10 @@
  */
 struct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)
 {
-	struct list_head *list;
 	struct snd_kcontrol *kctl;
 
 	snd_assert(card != NULL && numid != 0, return NULL);
-	list_for_each(list, &card->controls) {
-		kctl = snd_kcontrol(list);
+	list_for_each_entry(kctl, &card->controls, list) {
 		if (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)
 			return kctl;
 	}
@@ -520,14 +515,12 @@
 struct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,
 				     struct snd_ctl_elem_id *id)
 {
-	struct list_head *list;
 	struct snd_kcontrol *kctl;
 
 	snd_assert(card != NULL && id != NULL, return NULL);
 	if (id->numid != 0)
 		return snd_ctl_find_numid(card, id->numid);
-	list_for_each(list, &card->controls) {
-		kctl = snd_kcontrol(list);
+	list_for_each_entry(kctl, &card->controls, list) {
 		if (kctl->id.iface != id->iface)
 			continue;
 		if (kctl->id.device != id->device)
@@ -882,6 +875,8 @@
 	struct snd_ctl_elem_info info;
 	void *elem_data;		/* element data */
 	unsigned long elem_data_size;	/* size of element data in bytes */
+	void *tlv_data;			/* TLV data */
+	unsigned long tlv_data_size;	/* TLV data size */
 	void *priv_data;		/* private data (like strings for enumerated type) */
 	unsigned long priv_data_size;	/* size of private data in bytes */
 };
@@ -916,9 +911,48 @@
 	return change;
 }
 
+static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,
+				 int op_flag,
+				 unsigned int size,
+				 unsigned int __user *tlv)
+{
+	struct user_element *ue = kcontrol->private_data;
+	int change = 0;
+	void *new_data;
+
+	if (op_flag > 0) {
+		if (size > 1024 * 128)	/* sane value */
+			return -EINVAL;
+		new_data = kmalloc(size, GFP_KERNEL);
+		if (new_data == NULL)
+			return -ENOMEM;
+		if (copy_from_user(new_data, tlv, size)) {
+			kfree(new_data);
+			return -EFAULT;
+		}
+		change = ue->tlv_data_size != size;
+		if (!change)
+			change = memcmp(ue->tlv_data, new_data, size);
+		kfree(ue->tlv_data);
+		ue->tlv_data = new_data;
+		ue->tlv_data_size = size;
+	} else {
+		if (! ue->tlv_data_size || ! ue->tlv_data)
+			return -ENXIO;
+		if (size < ue->tlv_data_size)
+			return -ENOSPC;
+		if (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))
+			return -EFAULT;
+	}
+	return change;
+}
+
 static void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)
 {
-	kfree(kcontrol->private_data);
+	struct user_element *ue = kcontrol->private_data;
+	if (ue->tlv_data)
+		kfree(ue->tlv_data);
+	kfree(ue);
 }
 
 static int snd_ctl_elem_add(struct snd_ctl_file *file,
@@ -937,7 +971,8 @@
 		return -EINVAL;
 	access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
 		(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|
-				 SNDRV_CTL_ELEM_ACCESS_INACTIVE));
+				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
+				 SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
 	info->id.numid = 0;
 	memset(&kctl, 0, sizeof(kctl));
 	down_write(&card->controls_rwsem);
@@ -963,12 +998,12 @@
 		kctl.get = snd_ctl_elem_user_get;
 	if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)
 		kctl.put = snd_ctl_elem_user_put;
+	if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {
+		kctl.tlv.c = snd_ctl_elem_user_tlv;
+		access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;
+	}
 	switch (info->type) {
 	case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
-		private_size = sizeof(char);
-		if (info->count > 128)
-			return -EINVAL;
-		break;
 	case SNDRV_CTL_ELEM_TYPE_INTEGER:
 		private_size = sizeof(long);
 		if (info->count > 128)
@@ -1068,11 +1103,71 @@
 	return 0;
 }
 
+static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,
+                             struct snd_ctl_tlv __user *_tlv,
+                             int op_flag)
+{
+	struct snd_card *card = file->card;
+	struct snd_ctl_tlv tlv;
+	struct snd_kcontrol *kctl;
+	struct snd_kcontrol_volatile *vd;
+	unsigned int len;
+	int err = 0;
+
+	if (copy_from_user(&tlv, _tlv, sizeof(tlv)))
+		return -EFAULT;
+	if (tlv.length < sizeof(unsigned int) * 3)
+		return -EINVAL;
+	down_read(&card->controls_rwsem);
+	kctl = snd_ctl_find_numid(card, tlv.numid);
+	if (kctl == NULL) {
+		err = -ENOENT;
+		goto __kctl_end;
+	}
+	if (kctl->tlv.p == NULL) {
+		err = -ENXIO;
+		goto __kctl_end;
+	}
+	vd = &kctl->vd[tlv.numid - kctl->id.numid];
+	if ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||
+	    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||
+	    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {
+	    	err = -ENXIO;
+	    	goto __kctl_end;
+	}
+	if (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {
+		if (file && vd->owner != NULL && vd->owner != file) {
+			err = -EPERM;
+			goto __kctl_end;
+		}
+		err = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv); 
+		if (err > 0) {
+			up_read(&card->controls_rwsem);
+			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);
+			return 0;
+		}
+	} else {
+		if (op_flag) {
+			err = -ENXIO;
+			goto __kctl_end;
+		}
+		len = kctl->tlv.p[1] + 2 * sizeof(unsigned int);
+		if (tlv.length < len) {
+			err = -ENOMEM;
+			goto __kctl_end;
+		}
+		if (copy_to_user(_tlv->tlv, kctl->tlv.p, len))
+			err = -EFAULT;
+	}
+      __kctl_end:
+	up_read(&card->controls_rwsem);
+	return err;
+}
+
 static long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct snd_ctl_file *ctl;
 	struct snd_card *card;
-	struct list_head *list;
 	struct snd_kctl_ioctl *p;
 	void __user *argp = (void __user *)arg;
 	int __user *ip = argp;
@@ -1087,11 +1182,11 @@
 	case SNDRV_CTL_IOCTL_CARD_INFO:
 		return snd_ctl_card_info(card, ctl, cmd, argp);
 	case SNDRV_CTL_IOCTL_ELEM_LIST:
-		return snd_ctl_elem_list(ctl->card, argp);
+		return snd_ctl_elem_list(card, argp);
 	case SNDRV_CTL_IOCTL_ELEM_INFO:
 		return snd_ctl_elem_info_user(ctl, argp);
 	case SNDRV_CTL_IOCTL_ELEM_READ:
-		return snd_ctl_elem_read_user(ctl->card, argp);
+		return snd_ctl_elem_read_user(card, argp);
 	case SNDRV_CTL_IOCTL_ELEM_WRITE:
 		return snd_ctl_elem_write_user(ctl, argp);
 	case SNDRV_CTL_IOCTL_ELEM_LOCK:
@@ -1106,6 +1201,12 @@
 		return snd_ctl_elem_remove(ctl, argp);
 	case SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:
 		return snd_ctl_subscribe_events(ctl, ip);
+	case SNDRV_CTL_IOCTL_TLV_READ:
+		return snd_ctl_tlv_ioctl(ctl, argp, 0);
+	case SNDRV_CTL_IOCTL_TLV_WRITE:
+		return snd_ctl_tlv_ioctl(ctl, argp, 1);
+	case SNDRV_CTL_IOCTL_TLV_COMMAND:
+		return snd_ctl_tlv_ioctl(ctl, argp, -1);
 	case SNDRV_CTL_IOCTL_POWER:
 		return -ENOPROTOOPT;
 	case SNDRV_CTL_IOCTL_POWER_STATE:
@@ -1116,8 +1217,7 @@
 #endif
 	}
 	down_read(&snd_ioctl_rwsem);
-	list_for_each(list, &snd_control_ioctls) {
-		p = list_entry(list, struct snd_kctl_ioctl, list);
+	list_for_each_entry(p, &snd_control_ioctls, list) {
 		err = p->fioctl(card, ctl, cmd, arg);
 		if (err != -ENOIOCTLCMD) {
 			up_read(&snd_ioctl_rwsem);
@@ -1159,7 +1259,7 @@
 			schedule();
 			remove_wait_queue(&ctl->change_sleep, &wait);
 			if (signal_pending(current))
-				return result > 0 ? result : -ERESTARTSYS;
+				return -ERESTARTSYS;
 			spin_lock_irq(&ctl->read_lock);
 		}
 		kev = snd_kctl_event(ctl->events.next);
@@ -1241,13 +1341,11 @@
 static int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,
 				     struct list_head *lists)
 {
-	struct list_head *list;
 	struct snd_kctl_ioctl *p;
 
 	snd_assert(fcn != NULL, return -EINVAL);
 	down_write(&snd_ioctl_rwsem);
-	list_for_each(list, lists) {
-		p = list_entry(list, struct snd_kctl_ioctl, list);
+	list_for_each_entry(p, lists, list) {
 		if (p->fioctl == fcn) {
 			list_del(&p->list);
 			up_write(&snd_ioctl_rwsem);
@@ -1300,7 +1398,7 @@
  *  INIT PART
  */
 
-static struct file_operations snd_ctl_f_ops =
+static const struct file_operations snd_ctl_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.read =		snd_ctl_read,
@@ -1337,16 +1435,23 @@
 static int snd_ctl_dev_disconnect(struct snd_device *device)
 {
 	struct snd_card *card = device->device_data;
-	struct list_head *flist;
 	struct snd_ctl_file *ctl;
+	int err, cardnum;
+
+	snd_assert(card != NULL, return -ENXIO);
+	cardnum = card->number;
+	snd_assert(cardnum >= 0 && cardnum < SNDRV_CARDS, return -ENXIO);
 
 	down_read(&card->controls_rwsem);
-	list_for_each(flist, &card->ctl_files) {
-		ctl = snd_ctl_file(flist);
+	list_for_each_entry(ctl, &card->ctl_files, list) {
 		wake_up(&ctl->change_sleep);
 		kill_fasync(&ctl->fasync, SIGIO, POLL_ERR);
 	}
 	up_read(&card->controls_rwsem);
+
+	if ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL,
+					 card, -1)) < 0)
+		return err;
 	return 0;
 }
 
@@ -1368,23 +1473,6 @@
 }
 
 /*
- * de-registration of the control device
- */
-static int snd_ctl_dev_unregister(struct snd_device *device)
-{
-	struct snd_card *card = device->device_data;
-	int err, cardnum;
-
-	snd_assert(card != NULL, return -ENXIO);
-	cardnum = card->number;
-	snd_assert(cardnum >= 0 && cardnum < SNDRV_CARDS, return -ENXIO);
-	if ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL,
-					 card, -1)) < 0)
-		return err;
-	return snd_ctl_dev_free(device);
-}
-
-/*
  * create control core:
  * called from init.c
  */
@@ -1394,7 +1482,6 @@
 		.dev_free = snd_ctl_dev_free,
 		.dev_register =	snd_ctl_dev_register,
 		.dev_disconnect = snd_ctl_dev_disconnect,
-		.dev_unregister = snd_ctl_dev_unregister
 	};
 
 	snd_assert(card != NULL, return -ENXIO);
--- linux-2.6.18.noarch/sound/core/sgbuf.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/sgbuf.c	2007-06-05 17:41:11.000000000 -0400
@@ -27,7 +27,7 @@
 
 /* table entries are align to 32 */
 #define SGBUF_TBL_ALIGN		32
-#define sgbuf_align_table(tbl)	((((tbl) + SGBUF_TBL_ALIGN - 1) / SGBUF_TBL_ALIGN) * SGBUF_TBL_ALIGN)
+#define sgbuf_align_table(tbl)	ALIGN((tbl), SGBUF_TBL_ALIGN)
 
 int snd_free_sgbuf_pages(struct snd_dma_buffer *dmab)
 {
--- linux-2.6.18.noarch/sound/core/pcm_native.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/pcm_native.c	2007-06-05 23:35:26.000000000 -0400
@@ -347,6 +347,7 @@
 	return err;
 }
 
+
 static int snd_pcm_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_pcm_hw_params *params)
 {
@@ -1289,7 +1290,8 @@
 			       int f_flags)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN ||
+	    runtime->status->state == SNDRV_PCM_STATE_DISCONNECTED)
 		return -EBADFD;
 	if (snd_pcm_running(substream))
 		return -EBUSY;
@@ -1547,7 +1549,8 @@
 	runtime = substream->runtime;
 	card = substream->pcm->card;
 
-	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN ||
+	    runtime->status->state == SNDRV_PCM_STATE_DISCONNECTED)
 		return -EBADFD;
 
 	snd_power_lock(card);
@@ -1992,35 +1995,9 @@
 	return 0;
 }
 
-static void snd_pcm_add_file(struct snd_pcm_str *str,
-			     struct snd_pcm_file *pcm_file)
-{
-	pcm_file->next = str->files;
-	str->files = pcm_file;
-}
-
-static void snd_pcm_remove_file(struct snd_pcm_str *str,
-				struct snd_pcm_file *pcm_file)
-{
-	struct snd_pcm_file * pcm_file1;
-	if (str->files == pcm_file) {
-		str->files = pcm_file->next;
-	} else {
-		pcm_file1 = str->files;
-		while (pcm_file1 && pcm_file1->next != pcm_file)
-			pcm_file1 = pcm_file1->next;
-		if (pcm_file1 != NULL)
-			pcm_file1->next = pcm_file->next;
-	}
-}
-
 static void pcm_release_private(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_file *pcm_file = substream->file;
-
 	snd_pcm_unlink(substream);
-	snd_pcm_remove_file(substream->pstr, pcm_file);
-	kfree(pcm_file);
 }
 
 void snd_pcm_release_substream(struct snd_pcm_substream *substream)
@@ -2060,7 +2037,6 @@
 		return 0;
 	}
 
-	substream->no_mmap_ctrl = 0;
 	err = snd_pcm_hw_constraints_init(substream);
 	if (err < 0) {
 		snd_printd("snd_pcm_hw_constraints_init failed\n");
@@ -2105,19 +2081,16 @@
 	if (err < 0)
 		return err;
 
-	if (substream->ref_count > 1)
-		pcm_file = substream->file;
-	else {
-		pcm_file = kzalloc(sizeof(*pcm_file), GFP_KERNEL);
-		if (pcm_file == NULL) {
-			snd_pcm_release_substream(substream);
-			return -ENOMEM;
-		}
+	pcm_file = kzalloc(sizeof(*pcm_file), GFP_KERNEL);
+	if (pcm_file == NULL) {
+		snd_pcm_release_substream(substream);
+		return -ENOMEM;
+	}
+	pcm_file->substream = substream;
+	if (substream->ref_count == 1) {
 		str = substream->pstr;
 		substream->file = pcm_file;
 		substream->pcm_release = pcm_release_private;
-		pcm_file->substream = substream;
-		snd_pcm_add_file(str, pcm_file);
 	}
 	file->private_data = pcm_file;
 	*rpcm_file = pcm_file;
@@ -2209,6 +2182,7 @@
 	fasync_helper(-1, file, 0, &substream->runtime->fasync);
 	mutex_lock(&pcm->open_mutex);
 	snd_pcm_release_substream(substream);
+	kfree(pcm_file);
 	mutex_unlock(&pcm->open_mutex);
 	wake_up(&pcm->open_wait);
 	module_put(pcm->card->module);
@@ -3033,7 +3007,7 @@
 	struct page * page;
 	
 	if (substream == NULL)
-		return NOPAGE_OOM;
+		return NOPAGE_SIGBUS;
 	runtime = substream->runtime;
 	page = virt_to_page(runtime->status);
 	get_page(page);
@@ -3076,7 +3050,7 @@
 	struct page * page;
 	
 	if (substream == NULL)
-		return NOPAGE_OOM;
+		return NOPAGE_SIGBUS;
 	runtime = substream->runtime;
 	page = virt_to_page(runtime->control);
 	get_page(page);
@@ -3137,18 +3111,18 @@
 	size_t dma_bytes;
 	
 	if (substream == NULL)
-		return NOPAGE_OOM;
+		return NOPAGE_SIGBUS;
 	runtime = substream->runtime;
 	offset = area->vm_pgoff << PAGE_SHIFT;
 	offset += address - area->vm_start;
-	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
+	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_SIGBUS);
 	dma_bytes = PAGE_ALIGN(runtime->dma_bytes);
 	if (offset > dma_bytes - PAGE_SIZE)
 		return NOPAGE_SIGBUS;
 	if (substream->ops->page) {
 		page = substream->ops->page(substream, offset);
 		if (! page)
-			return NOPAGE_OOM;
+			return NOPAGE_OOM; /* XXX: is this really due to OOM? */
 	} else {
 		vaddr = runtime->dma_area + offset;
 		page = virt_to_page(vaddr);
@@ -3270,11 +3244,11 @@
 	offset = area->vm_pgoff << PAGE_SHIFT;
 	switch (offset) {
 	case SNDRV_PCM_MMAP_OFFSET_STATUS:
-		if (substream->no_mmap_ctrl)
+		if (pcm_file->no_compat_mmap)
 			return -ENXIO;
 		return snd_pcm_mmap_status(substream, file, area);
 	case SNDRV_PCM_MMAP_OFFSET_CONTROL:
-		if (substream->no_mmap_ctrl)
+		if (pcm_file->no_compat_mmap)
 			return -ENXIO;
 		return snd_pcm_mmap_control(substream, file, area);
 	default:
@@ -3430,7 +3404,7 @@
  *  Register section
  */
 
-struct file_operations snd_pcm_f_ops[2] = {
+const struct file_operations snd_pcm_f_ops[2] = {
 	{
 		.owner =		THIS_MODULE,
 		.write =		snd_pcm_write,
--- linux-2.6.18.noarch/sound/core/hwdep_compat.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/hwdep_compat.c	2007-06-05 17:41:11.000000000 -0400
@@ -33,7 +33,7 @@
 static int snd_hwdep_dsp_load_compat(struct snd_hwdep *hw,
 				     struct snd_hwdep_dsp_image32 __user *src)
 {
-	struct snd_hwdep_dsp_image *dst;
+	struct snd_hwdep_dsp_image __user *dst;
 	compat_caddr_t ptr;
 	u32 val;
 
--- linux-2.6.18.noarch/sound/core/misc.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/misc.c	2007-06-05 17:41:11.000000000 -0400
@@ -21,7 +21,6 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <linux/time.h>
 #include <linux/ioport.h>
 #include <sound/core.h>
@@ -78,3 +77,31 @@
 
 EXPORT_SYMBOL(snd_verbose_printd);
 #endif
+
+#ifdef CONFIG_PCI
+#include <linux/pci.h>
+/**
+ * snd_pci_quirk_lookup - look up a PCI SSID quirk list
+ * @pci: pci_dev handle
+ * @list: quirk list, terminated by a null entry
+ *
+ * Look through the given quirk list and finds a matching entry
+ * with the same PCI SSID.  When subdevice is 0, all subdevice
+ * values may match.
+ *
+ * Returns the matched entry pointer, or NULL if nothing matched.
+ */
+const struct snd_pci_quirk *
+snd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list)
+{
+	const struct snd_pci_quirk *q;
+
+	for (q = list; q->subvendor; q++)
+		if (q->subvendor == pci->subsystem_vendor &&
+		    (!q->subdevice || q->subdevice == pci->subsystem_device))
+			return q;
+	return NULL;
+}
+
+EXPORT_SYMBOL(snd_pci_quirk_lookup);
+#endif
--- linux-2.6.18.noarch/sound/core/rawmidi.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/rawmidi.c	2007-06-05 17:41:11.000000000 -0400
@@ -55,21 +55,17 @@
 static int snd_rawmidi_dev_free(struct snd_device *device);
 static int snd_rawmidi_dev_register(struct snd_device *device);
 static int snd_rawmidi_dev_disconnect(struct snd_device *device);
-static int snd_rawmidi_dev_unregister(struct snd_device *device);
 
 static LIST_HEAD(snd_rawmidi_devices);
 static DEFINE_MUTEX(register_mutex);
 
 static struct snd_rawmidi *snd_rawmidi_search(struct snd_card *card, int device)
 {
-	struct list_head *p;
 	struct snd_rawmidi *rawmidi;
 
-	list_for_each(p, &snd_rawmidi_devices) {
-		rawmidi = list_entry(p, struct snd_rawmidi, list);
+	list_for_each_entry(rawmidi, &snd_rawmidi_devices, list)
 		if (rawmidi->card == card && rawmidi->device == device)
 			return rawmidi;
-	}
 	return NULL;
 }
 
@@ -390,7 +386,6 @@
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_file *rawmidi_file;
 	wait_queue_t wait;
-	struct list_head *list;
 	struct snd_ctl_file *kctl;
 
 	if (maj == snd_major) {
@@ -427,11 +422,11 @@
 	while (1) {
 		subdevice = -1;
 		down_read(&card->controls_rwsem);
-		list_for_each(list, &card->ctl_files) {
-			kctl = snd_ctl_file(list);
+		list_for_each_entry(kctl, &card->ctl_files, list) {
 			if (kctl->pid == current->pid) {
 				subdevice = kctl->prefer_rawmidi_subdevice;
-				break;
+				if (subdevice != -1)
+					break;
 			}
 		}
 		up_read(&card->controls_rwsem);
@@ -575,7 +570,6 @@
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_str *pstr;
 	struct snd_rawmidi_substream *substream;
-	struct list_head *list;
 
 	mutex_lock(&register_mutex);
 	rmidi = snd_rawmidi_search(card, info->device);
@@ -589,8 +583,7 @@
 		return -ENOENT;
 	if (info->subdevice >= pstr->substream_count)
 		return -ENXIO;
-	list_for_each(list, &pstr->substreams) {
-		substream = list_entry(list, struct snd_rawmidi_substream, list);
+	list_for_each_entry(substream, &pstr->substreams, list) {
 		if ((unsigned int)substream->number == info->subdevice)
 			return snd_rawmidi_info(substream, info);
 	}
@@ -1313,14 +1306,14 @@
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_substream *substream;
 	struct snd_rawmidi_runtime *runtime;
-	struct list_head *list;
 
 	rmidi = entry->private_data;
 	snd_iprintf(buffer, "%s\n\n", rmidi->name);
 	mutex_lock(&rmidi->open_mutex);
 	if (rmidi->info_flags & SNDRV_RAWMIDI_INFO_OUTPUT) {
-		list_for_each(list, &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {
-			substream = list_entry(list, struct snd_rawmidi_substream, list);
+		list_for_each_entry(substream,
+				    &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,
+				    list) {
 			snd_iprintf(buffer,
 				    "Output %d\n"
 				    "  Tx bytes     : %lu\n",
@@ -1339,8 +1332,9 @@
 		}
 	}
 	if (rmidi->info_flags & SNDRV_RAWMIDI_INFO_INPUT) {
-		list_for_each(list, &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {
-			substream = list_entry(list, struct snd_rawmidi_substream, list);
+		list_for_each_entry(substream,
+				    &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams,
+				    list) {
 			snd_iprintf(buffer,
 				    "Input %d\n"
 				    "  Rx bytes     : %lu\n",
@@ -1365,7 +1359,7 @@
  *  Register functions
  */
 
-static struct file_operations snd_rawmidi_f_ops =
+static const struct file_operations snd_rawmidi_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.read =		snd_rawmidi_read,
@@ -1385,7 +1379,6 @@
 	struct snd_rawmidi_substream *substream;
 	int idx;
 
-	INIT_LIST_HEAD(&stream->substreams);
 	for (idx = 0; idx < count; idx++) {
 		substream = kzalloc(sizeof(*substream), GFP_KERNEL);
 		if (substream == NULL) {
@@ -1426,7 +1419,6 @@
 		.dev_free = snd_rawmidi_dev_free,
 		.dev_register = snd_rawmidi_dev_register,
 		.dev_disconnect = snd_rawmidi_dev_disconnect,
-		.dev_unregister = snd_rawmidi_dev_unregister
 	};
 
 	snd_assert(rrawmidi != NULL, return -EINVAL);
@@ -1441,6 +1433,9 @@
 	rmidi->device = device;
 	mutex_init(&rmidi->open_mutex);
 	init_waitqueue_head(&rmidi->open_wait);
+	INIT_LIST_HEAD(&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams);
+	INIT_LIST_HEAD(&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams);
+
 	if (id != NULL)
 		strlcpy(rmidi->id, id, sizeof(rmidi->id));
 	if ((err = snd_rawmidi_alloc_substreams(rmidi,
@@ -1479,6 +1474,14 @@
 static int snd_rawmidi_free(struct snd_rawmidi *rmidi)
 {
 	snd_assert(rmidi != NULL, return -ENXIO);	
+
+	snd_info_free_entry(rmidi->proc_entry);
+	rmidi->proc_entry = NULL;
+	mutex_lock(&register_mutex);
+	if (rmidi->ops && rmidi->ops->dev_unregister)
+		rmidi->ops->dev_unregister(rmidi);
+	mutex_unlock(&register_mutex);
+
 	snd_rawmidi_free_substreams(&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);
 	snd_rawmidi_free_substreams(&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);
 	if (rmidi->private_free)
@@ -1587,21 +1590,6 @@
 
 	mutex_lock(&register_mutex);
 	list_del_init(&rmidi->list);
-	mutex_unlock(&register_mutex);
-	return 0;
-}
-
-static int snd_rawmidi_dev_unregister(struct snd_device *device)
-{
-	struct snd_rawmidi *rmidi = device->device_data;
-
-	snd_assert(rmidi != NULL, return -ENXIO);
-	mutex_lock(&register_mutex);
-	list_del(&rmidi->list);
-	if (rmidi->proc_entry) {
-		snd_info_unregister(rmidi->proc_entry);
-		rmidi->proc_entry = NULL;
-	}
 #ifdef CONFIG_SND_OSSEMUL
 	if (rmidi->ossreg) {
 		if ((int)rmidi->device == midi_map[rmidi->card->number]) {
@@ -1615,17 +1603,9 @@
 		rmidi->ossreg = 0;
 	}
 #endif /* CONFIG_SND_OSSEMUL */
-	if (rmidi->ops && rmidi->ops->dev_unregister)
-		rmidi->ops->dev_unregister(rmidi);
 	snd_unregister_device(SNDRV_DEVICE_TYPE_RAWMIDI, rmidi->card, rmidi->device);
 	mutex_unlock(&register_mutex);
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
-	if (rmidi->seq_dev) {
-		snd_device_free(rmidi->card, rmidi->seq_dev);
-		rmidi->seq_dev = NULL;
-	}
-#endif
-	return snd_rawmidi_free(rmidi);
+	return 0;
 }
 
 /**
@@ -1639,13 +1619,10 @@
 void snd_rawmidi_set_ops(struct snd_rawmidi *rmidi, int stream,
 			 struct snd_rawmidi_ops *ops)
 {
-	struct list_head *list;
 	struct snd_rawmidi_substream *substream;
 	
-	list_for_each(list, &rmidi->streams[stream].substreams) {
-		substream = list_entry(list, struct snd_rawmidi_substream, list);
+	list_for_each_entry(substream, &rmidi->streams[stream].substreams, list)
 		substream->ops = ops;
-	}
 }
 
 /*
--- linux-2.6.18.noarch/sound/core/pcm_memory.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/pcm_memory.c	2007-06-05 17:41:11.000000000 -0400
@@ -101,7 +101,9 @@
 {
 	snd_pcm_lib_preallocate_dma_free(substream);
 #ifdef CONFIG_SND_VERBOSE_PROCFS
-	snd_info_unregister(substream->proc_prealloc_entry);
+	snd_info_free_entry(substream->proc_prealloc_max_entry);
+	substream->proc_prealloc_max_entry = NULL;
+	snd_info_free_entry(substream->proc_prealloc_entry);
 	substream->proc_prealloc_entry = NULL;
 #endif
 	return 0;
@@ -142,6 +144,18 @@
 }
 
 /*
+ * read callback for prealloc_max proc file
+ *
+ * prints the maximum allowed size in kB.
+ */
+static void snd_pcm_lib_preallocate_max_proc_read(struct snd_info_entry *entry,
+						  struct snd_info_buffer *buffer)
+{
+	struct snd_pcm_substream *substream = entry->private_data;
+	snd_iprintf(buffer, "%lu\n", (unsigned long) substream->dma_max / 1024);
+}
+
+/*
  * write callback for prealloc proc file
  *
  * accepts the preallocation size in kB.
@@ -203,6 +217,15 @@
 		}
 	}
 	substream->proc_prealloc_entry = entry;
+	if ((entry = snd_info_create_card_entry(substream->pcm->card, "prealloc_max", substream->proc_root)) != NULL) {
+		entry->c.text.read = snd_pcm_lib_preallocate_max_proc_read;
+		entry->private_data = substream;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	substream->proc_prealloc_max_entry = entry;
 }
 
 #else /* !CONFIG_SND_VERBOSE_PROCFS */
--- linux-2.6.18.noarch/sound/core/device.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/device.c	2007-06-05 17:41:11.000000000 -0400
@@ -71,7 +71,7 @@
  * @device_data: the data pointer to release
  *
  * Removes the device from the list on the card and invokes the
- * callback, dev_unregister or dev_free, corresponding to the state.
+ * callbacks, dev_disconnect and dev_free, corresponding to the state.
  * Then release the device.
  *
  * Returns zero if successful, or a negative error code on failure or if the
@@ -79,27 +79,23 @@
  */
 int snd_device_free(struct snd_card *card, void *device_data)
 {
-	struct list_head *list;
 	struct snd_device *dev;
 	
 	snd_assert(card != NULL, return -ENXIO);
 	snd_assert(device_data != NULL, return -ENXIO);
-	list_for_each(list, &card->devices) {
-		dev = snd_device(list);
+	list_for_each_entry(dev, &card->devices, list) {
 		if (dev->device_data != device_data)
 			continue;
 		/* unlink */
 		list_del(&dev->list);
-		if ((dev->state == SNDRV_DEV_REGISTERED ||
-		     dev->state == SNDRV_DEV_DISCONNECTED) &&
-		    dev->ops->dev_unregister) {
-			if (dev->ops->dev_unregister(dev))
-				snd_printk(KERN_ERR "device unregister failure\n");
-		} else {
-			if (dev->ops->dev_free) {
-				if (dev->ops->dev_free(dev))
-					snd_printk(KERN_ERR "device free failure\n");
-			}
+		if (dev->state == SNDRV_DEV_REGISTERED &&
+		    dev->ops->dev_disconnect)
+			if (dev->ops->dev_disconnect(dev))
+				snd_printk(KERN_ERR
+					   "device disconnect failure\n");
+		if (dev->ops->dev_free) {
+			if (dev->ops->dev_free(dev))
+				snd_printk(KERN_ERR "device free failure\n");
 		}
 		kfree(dev);
 		return 0;
@@ -126,13 +122,11 @@
  */
 int snd_device_disconnect(struct snd_card *card, void *device_data)
 {
-	struct list_head *list;
 	struct snd_device *dev;
 
 	snd_assert(card != NULL, return -ENXIO);
 	snd_assert(device_data != NULL, return -ENXIO);
-	list_for_each(list, &card->devices) {
-		dev = snd_device(list);
+	list_for_each_entry(dev, &card->devices, list) {
 		if (dev->device_data != device_data)
 			continue;
 		if (dev->state == SNDRV_DEV_REGISTERED &&
@@ -163,14 +157,12 @@
  */
 int snd_device_register(struct snd_card *card, void *device_data)
 {
-	struct list_head *list;
 	struct snd_device *dev;
 	int err;
 
 	snd_assert(card != NULL, return -ENXIO);
 	snd_assert(device_data != NULL, return -ENXIO);
-	list_for_each(list, &card->devices) {
-		dev = snd_device(list);
+	list_for_each_entry(dev, &card->devices, list) {
 		if (dev->device_data != device_data)
 			continue;
 		if (dev->state == SNDRV_DEV_BUILD && dev->ops->dev_register) {
@@ -194,13 +186,11 @@
  */
 int snd_device_register_all(struct snd_card *card)
 {
-	struct list_head *list;
 	struct snd_device *dev;
 	int err;
 	
 	snd_assert(card != NULL, return -ENXIO);
-	list_for_each(list, &card->devices) {
-		dev = snd_device(list);
+	list_for_each_entry(dev, &card->devices, list) {
 		if (dev->state == SNDRV_DEV_BUILD && dev->ops->dev_register) {
 			if ((err = dev->ops->dev_register(dev)) < 0)
 				return err;
@@ -217,12 +207,10 @@
 int snd_device_disconnect_all(struct snd_card *card)
 {
 	struct snd_device *dev;
-	struct list_head *list;
 	int err = 0;
 
 	snd_assert(card != NULL, return -ENXIO);
-	list_for_each(list, &card->devices) {
-		dev = snd_device(list);
+	list_for_each_entry(dev, &card->devices, list) {
 		if (snd_device_disconnect(card, dev->device_data) < 0)
 			err = -ENXIO;
 	}
@@ -236,7 +224,6 @@
 int snd_device_free_all(struct snd_card *card, snd_device_cmd_t cmd)
 {
 	struct snd_device *dev;
-	struct list_head *list;
 	int err;
 	unsigned int range_low, range_high;
 
@@ -244,8 +231,7 @@
 	range_low = cmd * SNDRV_DEV_TYPE_RANGE_SIZE;
 	range_high = range_low + SNDRV_DEV_TYPE_RANGE_SIZE - 1;
       __again:
-	list_for_each(list, &card->devices) {
-		dev = snd_device(list);		
+	list_for_each_entry(dev, &card->devices, list) {
 		if (dev->type >= range_low && dev->type <= range_high) {
 			if ((err = snd_device_free(card, dev->device_data)) < 0)
 				return err;
--- linux-2.6.18.noarch/sound/core/info_oss.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/info_oss.c	2007-06-05 17:41:11.000000000 -0400
@@ -131,10 +131,8 @@
 
 int snd_info_minor_unregister(void)
 {
-	if (snd_sndstat_proc_entry) {
-		snd_info_unregister(snd_sndstat_proc_entry);
-		snd_sndstat_proc_entry = NULL;
-	}
+	snd_info_free_entry(snd_sndstat_proc_entry);
+	snd_sndstat_proc_entry = NULL;
 	return 0;
 }
 
--- linux-2.6.18.noarch/sound/core/memalloc.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/memalloc.c	2007-06-05 17:41:11.000000000 -0400
@@ -406,19 +406,17 @@
  */
 size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)
 {
-	struct list_head *p;
 	struct snd_mem_list *mem;
 
 	snd_assert(dmab, return 0);
 
 	mutex_lock(&list_mutex);
-	list_for_each(p, &mem_list_head) {
-		mem = list_entry(p, struct snd_mem_list, list);
+	list_for_each_entry(mem, &mem_list_head, list) {
 		if (mem->id == id &&
 		    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||
 		     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {
 			struct device *dev = dmab->dev.dev;
-			list_del(p);
+			list_del(&mem->list);
 			*dmab = mem->buffer;
 			if (dmab->dev.dev == NULL)
 				dmab->dev.dev = dev;
@@ -488,7 +486,6 @@
 {
 	int len = 0;
 	long pages = snd_allocated_pages >> (PAGE_SHIFT-12);
-	struct list_head *p;
 	struct snd_mem_list *mem;
 	int devno;
 	static char *types[] = { "UNKNOWN", "CONT", "DEV", "DEV-SG", "SBUS" };
@@ -498,8 +495,7 @@
 			"pages  : %li bytes (%li pages per %likB)\n",
 			pages * PAGE_SIZE, pages, PAGE_SIZE / 1024);
 	devno = 0;
-	list_for_each(p, &mem_list_head) {
-		mem = list_entry(p, struct snd_mem_list, list);
+	list_for_each_entry(mem, &mem_list_head, list) {
 		devno++;
 		len += snprintf(page + len, count - len,
 				"buffer %d : ID %08x : type %s\n",
--- linux-2.6.18.noarch/sound/core/pcm_lib.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/pcm_lib.c	2007-06-05 17:41:11.000000000 -0400
@@ -79,19 +79,17 @@
 			runtime->silence_filled -= frames;
 			if ((snd_pcm_sframes_t)runtime->silence_filled < 0) {
 				runtime->silence_filled = 0;
-				runtime->silence_start = (ofs + frames) - runtime->buffer_size;
+				runtime->silence_start = new_hw_ptr;
 			} else {
-				runtime->silence_start = ofs - runtime->silence_filled;
+				runtime->silence_start = ofs;
 			}
-			if ((snd_pcm_sframes_t)runtime->silence_start < 0)
-				runtime->silence_start += runtime->boundary;
 		}
 		frames = runtime->buffer_size - runtime->silence_filled;
 	}
 	snd_assert(frames <= runtime->buffer_size, return);
 	if (frames == 0)
 		return;
-	ofs = (runtime->silence_start + runtime->silence_filled) % runtime->buffer_size;
+	ofs = runtime->silence_start % runtime->buffer_size;
 	while (frames > 0) {
 		transfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;
 		if (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||
@@ -783,6 +781,11 @@
 {
         unsigned int k;
 	int changed = 0;
+
+	if (!count) {
+		i->empty = 1;
+		return -EINVAL;
+	}
         for (k = 0; k < count; k++) {
 		if (mask && !(mask & (1 << k)))
 			continue;
--- linux-2.6.18.noarch/sound/core/oss/pcm_oss.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/oss/pcm_oss.c	2007-06-05 17:40:31.000000000 -0400
@@ -810,6 +810,8 @@
 	struct snd_mask sformat_mask;
 	struct snd_mask mask;
 
+	if (mutex_lock_interruptible(&runtime->oss.params_lock))
+		return -EINTR;
 	sw_params = kmalloc(sizeof(*sw_params), GFP_KERNEL);
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
 	sparams = kmalloc(sizeof(*sparams), GFP_KERNEL);
@@ -1020,6 +1022,7 @@
 	kfree(sw_params);
 	kfree(params);
 	kfree(sparams);
+	mutex_unlock(&runtime->oss.params_lock);
 	return err;
 }
 
@@ -1307,14 +1310,17 @@
 
 	if ((tmp = snd_pcm_oss_make_ready(substream)) < 0)
 		return tmp;
+	mutex_lock(&runtime->oss.params_lock);
 	while (bytes > 0) {
 		if (bytes < runtime->oss.period_bytes || runtime->oss.buffer_used > 0) {
 			tmp = bytes;
 			if (tmp + runtime->oss.buffer_used > runtime->oss.period_bytes)
 				tmp = runtime->oss.period_bytes - runtime->oss.buffer_used;
 			if (tmp > 0) {
-				if (copy_from_user(runtime->oss.buffer + runtime->oss.buffer_used, buf, tmp))
-					return xfer > 0 ? (snd_pcm_sframes_t)xfer : -EFAULT;
+				if (copy_from_user(runtime->oss.buffer + runtime->oss.buffer_used, buf, tmp)) {
+					tmp = -EFAULT;
+					goto err;
+				}
 			}
 			runtime->oss.buffer_used += tmp;
 			buf += tmp;
@@ -1325,22 +1331,24 @@
 				tmp = snd_pcm_oss_write2(substream, runtime->oss.buffer + runtime->oss.period_ptr, 
 							 runtime->oss.buffer_used - runtime->oss.period_ptr, 1);
 				if (tmp <= 0)
-					return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
+					goto err;
 				runtime->oss.bytes += tmp;
 				runtime->oss.period_ptr += tmp;
 				runtime->oss.period_ptr %= runtime->oss.period_bytes;
 				if (runtime->oss.period_ptr == 0 ||
 				    runtime->oss.period_ptr == runtime->oss.buffer_used)
 					runtime->oss.buffer_used = 0;
-				else if ((substream->f_flags & O_NONBLOCK) != 0)
-					return xfer > 0 ? xfer : -EAGAIN;
+				else if ((substream->f_flags & O_NONBLOCK) != 0) {
+					tmp = -EAGAIN;
+					goto err;
+				}
 			}
 		} else {
 			tmp = snd_pcm_oss_write2(substream,
 						 (const char __force *)buf,
 						 runtime->oss.period_bytes, 0);
 			if (tmp <= 0)
-				return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
+				goto err;
 			runtime->oss.bytes += tmp;
 			buf += tmp;
 			bytes -= tmp;
@@ -1350,7 +1358,12 @@
 				break;
 		}
 	}
+	mutex_unlock(&runtime->oss.params_lock);
 	return xfer;
+
+ err:
+	mutex_unlock(&runtime->oss.params_lock);
+	return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
 }
 
 static ssize_t snd_pcm_oss_read2(struct snd_pcm_substream *substream, char *buf, size_t bytes, int in_kernel)
@@ -1397,12 +1410,13 @@
 
 	if ((tmp = snd_pcm_oss_make_ready(substream)) < 0)
 		return tmp;
+	mutex_lock(&runtime->oss.params_lock);
 	while (bytes > 0) {
 		if (bytes < runtime->oss.period_bytes || runtime->oss.buffer_used > 0) {
 			if (runtime->oss.buffer_used == 0) {
 				tmp = snd_pcm_oss_read2(substream, runtime->oss.buffer, runtime->oss.period_bytes, 1);
 				if (tmp <= 0)
-					return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
+					goto err;
 				runtime->oss.bytes += tmp;
 				runtime->oss.period_ptr = tmp;
 				runtime->oss.buffer_used = tmp;
@@ -1410,8 +1424,10 @@
 			tmp = bytes;
 			if ((size_t) tmp > runtime->oss.buffer_used)
 				tmp = runtime->oss.buffer_used;
-			if (copy_to_user(buf, runtime->oss.buffer + (runtime->oss.period_ptr - runtime->oss.buffer_used), tmp))
-				return xfer > 0 ? (snd_pcm_sframes_t)xfer : -EFAULT;
+			if (copy_to_user(buf, runtime->oss.buffer + (runtime->oss.period_ptr - runtime->oss.buffer_used), tmp)) {
+				tmp = -EFAULT;
+				goto err;
+			}
 			buf += tmp;
 			bytes -= tmp;
 			xfer += tmp;
@@ -1420,14 +1436,19 @@
 			tmp = snd_pcm_oss_read2(substream, (char __force *)buf,
 						runtime->oss.period_bytes, 0);
 			if (tmp <= 0)
-				return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
+				goto err;
 			runtime->oss.bytes += tmp;
 			buf += tmp;
 			bytes -= tmp;
 			xfer += tmp;
 		}
 	}
+	mutex_unlock(&runtime->oss.params_lock);
 	return xfer;
+
+ err:
+	mutex_unlock(&runtime->oss.params_lock);
+	return xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;
 }
 
 static int snd_pcm_oss_reset(struct snd_pcm_oss_file *pcm_oss_file)
@@ -1469,13 +1490,6 @@
 	ssize_t result = 0;
 	long res;
 	wait_queue_t wait;
-	static char printed_comm[16];
-
-	if (strncmp(printed_comm, current->comm, 16)) {
-		printk(KERN_DEBUG "application %s uses obsolete OSS audio interface\n",
-		       current->comm);
-		memcpy(printed_comm, current->comm, 16);
-	}
 
 	runtime = substream->runtime;
 	init_waitqueue_entry(&wait, current);
@@ -1535,6 +1549,7 @@
 			return err;
 		format = snd_pcm_oss_format_from(runtime->oss.format);
 		width = snd_pcm_format_physical_width(format);
+		mutex_lock(&runtime->oss.params_lock);
 		if (runtime->oss.buffer_used > 0) {
 #ifdef OSS_DEBUG
 			printk("sync: buffer_used\n");
@@ -1544,8 +1559,10 @@
 						   runtime->oss.buffer + runtime->oss.buffer_used,
 						   size);
 			err = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);
-			if (err < 0)
+			if (err < 0) {
+				mutex_unlock(&runtime->oss.params_lock);
 				return err;
+			}
 		} else if (runtime->oss.period_ptr > 0) {
 #ifdef OSS_DEBUG
 			printk("sync: period_ptr\n");
@@ -1555,8 +1572,10 @@
 						   runtime->oss.buffer,
 						   size * 8 / width);
 			err = snd_pcm_oss_sync1(substream, size);
-			if (err < 0)
+			if (err < 0) {
+				mutex_unlock(&runtime->oss.params_lock);
 				return err;
+			}
 		}
 		/*
 		 * The ALSA's period might be a bit large than OSS one.
@@ -1586,6 +1605,7 @@
 				snd_pcm_lib_writev(substream, buffers, size);
 			}
 		}
+		mutex_unlock(&runtime->oss.params_lock);
 		/*
 		 * finish sync: drain the buffer
 		 */
@@ -2179,6 +2199,7 @@
 	runtime->oss.params = 1;
 	runtime->oss.trigger = 1;
 	runtime->oss.rate = 8000;
+	mutex_init(&runtime->oss.params_lock);
 	switch (SNDRV_MINOR_OSS_DEVICE(minor)) {
 	case SNDRV_MINOR_OSS_PCM_8:
 		runtime->oss.format = AFMT_U8;
@@ -2366,7 +2387,8 @@
 		substream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];
 	snd_assert(substream != NULL, return -ENXIO);
 	pcm = substream->pcm;
-	snd_pcm_oss_sync(pcm_oss_file);
+	if (!pcm->card->shutdown)
+		snd_pcm_oss_sync(pcm_oss_file);
 	mutex_lock(&pcm->open_mutex);
 	snd_pcm_oss_release_file(pcm_oss_file);
 	mutex_unlock(&pcm->open_mutex);
@@ -2853,11 +2875,9 @@
 	int stream;
 	for (stream = 0; stream < 2; ++stream) {
 		struct snd_pcm_str *pstr = &pcm->streams[stream];
-		if (pstr->oss.proc_entry) {
-			snd_info_unregister(pstr->oss.proc_entry);
-			pstr->oss.proc_entry = NULL;
-			snd_pcm_oss_proc_free_setup_list(pstr);
-		}
+		snd_info_free_entry(pstr->oss.proc_entry);
+		pstr->oss.proc_entry = NULL;
+		snd_pcm_oss_proc_free_setup_list(pstr);
 	}
 }
 #else /* !CONFIG_SND_VERBOSE_PROCFS */
@@ -2869,7 +2889,7 @@
  *  ENTRY functions
  */
 
-static struct file_operations snd_pcm_oss_f_reg =
+static const struct file_operations snd_pcm_oss_f_reg =
 {
 	.owner =	THIS_MODULE,
 	.read =		snd_pcm_oss_read,
@@ -2938,25 +2958,23 @@
 			snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,
 						  pcm->card, 1);
 		}
-	}
-	return 0;
-}
-
-static int snd_pcm_oss_unregister_minor(struct snd_pcm *pcm)
-{
-	snd_pcm_oss_disconnect_minor(pcm);
-	if (pcm->oss.reg) {
 		if (dsp_map[pcm->card->number] == (int)pcm->device) {
 #ifdef SNDRV_OSS_INFO_DEV_AUDIO
 			snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_AUDIO, pcm->card->number);
 #endif
 		}
 		pcm->oss.reg = 0;
-		snd_pcm_oss_proc_done(pcm);
 	}
 	return 0;
 }
 
+static int snd_pcm_oss_unregister_minor(struct snd_pcm *pcm)
+{
+	snd_pcm_oss_disconnect_minor(pcm);
+	snd_pcm_oss_proc_done(pcm);
+	return 0;
+}
+
 static struct snd_pcm_notify snd_pcm_oss_notify =
 {
 	.n_register =	snd_pcm_oss_register_minor,
--- linux-2.6.18.noarch/sound/core/oss/mixer_oss.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/oss/mixer_oss.c	2007-06-05 17:40:31.000000000 -0400
@@ -390,7 +390,7 @@
  *  REGISTRATION PART
  */
 
-static struct file_operations snd_mixer_oss_f_ops =
+static const struct file_operations snd_mixer_oss_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.open =		snd_mixer_oss_open,
@@ -1023,7 +1023,7 @@
 	}
 	up_read(&mixer->card->controls_rwsem);
 	if (slot.present != 0) {
-		pslot = (struct slot *)kmalloc(sizeof(slot), GFP_KERNEL);
+		pslot = kmalloc(sizeof(slot), GFP_KERNEL);
 		if (! pslot)
 			return -ENOMEM;
 		*pslot = slot;
@@ -1193,10 +1193,8 @@
 
 static void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)
 {
-	if (mixer->proc_entry) {
-		snd_info_unregister(mixer->proc_entry);
-		mixer->proc_entry = NULL;
-	}
+	snd_info_free_entry(mixer->proc_entry);
+	mixer->proc_entry = NULL;
 }
 #else /* !CONFIG_PROC_FS */
 #define snd_mixer_oss_proc_init(mix)
@@ -1312,21 +1310,19 @@
 		card->mixer_oss = mixer;
 		snd_mixer_oss_build(mixer);
 		snd_mixer_oss_proc_init(mixer);
-	} else if (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT) {
-		mixer = card->mixer_oss;
-		if (mixer == NULL || !mixer->oss_dev_alloc)
-			return 0;
-		snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);
-		mixer->oss_dev_alloc = 0;
-	} else {		/* free */
+	} else {
 		mixer = card->mixer_oss;
 		if (mixer == NULL)
 			return 0;
+		if (mixer->oss_dev_alloc) {
 #ifdef SNDRV_OSS_INFO_DEV_MIXERS
-		snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);
+			snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);
 #endif
-		if (mixer->oss_dev_alloc)
 			snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);
+			mixer->oss_dev_alloc = 0;
+		}
+		if (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT)
+			return 0;
 		snd_mixer_oss_proc_done(mixer);
 		return snd_mixer_oss_free1(mixer);
 	}
--- linux-2.6.18.noarch/sound/core/init.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/init.c	2007-06-05 17:41:11.000000000 -0400
@@ -33,10 +33,10 @@
 #include <sound/control.h>
 #include <sound/info.h>
 
-struct snd_shutdown_f_ops {
-	struct file_operations f_ops;
-	struct snd_shutdown_f_ops *next;
-};
+static DEFINE_SPINLOCK(shutdown_lock);
+static LIST_HEAD(shutdown_files);
+
+static const struct file_operations snd_shutdown_f_ops;
 
 static unsigned int snd_cards_lock;	/* locked for registering/using */
 struct snd_card *snd_cards[SNDRV_CARDS];
@@ -81,8 +81,6 @@
 #define init_info_for_card(card)
 #endif
 
-static void snd_card_free_thread(void * __card);
-
 /**
  *  snd_card_new - create and initialize a soundcard structure
  *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]
@@ -116,22 +114,28 @@
 	if (idx < 0) {
 		int idx2;
 		for (idx2 = 0; idx2 < SNDRV_CARDS; idx2++)
+			/* idx == -1 == 0xffff means: take any free slot */
 			if (~snd_cards_lock & idx & 1<<idx2) {
 				idx = idx2;
 				if (idx >= snd_ecards_limit)
 					snd_ecards_limit = idx + 1;
 				break;
 			}
-	} else if (idx < snd_ecards_limit) {
-		if (snd_cards_lock & (1 << idx))
-			err = -ENODEV;	/* invalid */
-	} else if (idx < SNDRV_CARDS)
-		snd_ecards_limit = idx + 1; /* increase the limit */
-	else
-		err = -ENODEV;
+	} else {
+		 if (idx < snd_ecards_limit) {
+			if (snd_cards_lock & (1 << idx))
+				err = -EBUSY;	/* invalid */
+		} else {
+			if (idx < SNDRV_CARDS)
+				snd_ecards_limit = idx + 1; /* increase the limit */
+			else
+				err = -ENODEV;
+		}
+	}
 	if (idx < 0 || err < 0) {
 		mutex_unlock(&snd_card_mutex);
-		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i)\n", idx, snd_ecards_limit - 1);
+		snd_printk(KERN_ERR "cannot find the slot for index %d (range 0-%i), error: %d\n",
+			 idx, snd_ecards_limit - 1, err);
 		goto __error;
 	}
 	snd_cards_lock |= 1 << idx;		/* lock it */
@@ -145,7 +149,6 @@
 	INIT_LIST_HEAD(&card->ctl_files);
 	spin_lock_init(&card->files_lock);
 	init_waitqueue_head(&card->shutdown_sleep);
-	INIT_WORK(&card->free_workq, snd_card_free_thread, card);
 #ifdef CONFIG_PM
 	mutex_init(&card->power_lock);
 	init_waitqueue_head(&card->power_sleep);
@@ -201,6 +204,25 @@
 	return -ENODEV;
 }
 
+static int snd_disconnect_release(struct inode *inode, struct file *file)
+{
+	struct snd_monitor_file *df = NULL, *_df;
+
+	spin_lock(&shutdown_lock);
+	list_for_each_entry(_df, &shutdown_files, shutdown_list) {
+		if (_df->file == file) {
+			df = _df;
+			break;
+		}
+	}
+	spin_unlock(&shutdown_lock);
+
+	if (likely(df))
+		return df->disconnected_f_op->release(inode, file);
+
+	panic("%s(%p, %p) failed!", __FUNCTION__, inode, file);
+}
+
 static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
 {
 	return POLLERR | POLLNVAL;
@@ -222,6 +244,22 @@
 	return -ENODEV;
 }
 
+static const struct file_operations snd_shutdown_f_ops =
+{
+	.owner = 	THIS_MODULE,
+	.llseek =	snd_disconnect_llseek,
+	.read = 	snd_disconnect_read,
+	.write =	snd_disconnect_write,
+	.release =	snd_disconnect_release,
+	.poll =		snd_disconnect_poll,
+	.unlocked_ioctl = snd_disconnect_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = snd_disconnect_ioctl,
+#endif
+	.mmap =		snd_disconnect_mmap,
+	.fasync =	snd_disconnect_fasync
+};
+
 /**
  *  snd_card_disconnect - disconnect all APIs from the file-operations (user space)
  *  @card: soundcard structure
@@ -237,9 +275,6 @@
 {
 	struct snd_monitor_file *mfile;
 	struct file *file;
-	struct snd_shutdown_f_ops *s_f_ops;
-	struct file_operations *f_ops;
-	const struct file_operations *old_f_ops;
 	int err;
 
 	spin_lock(&card->files_lock);
@@ -264,34 +299,14 @@
 
 		/* it's critical part, use endless loop */
 		/* we have no room to fail */
-		s_f_ops = kmalloc(sizeof(struct snd_shutdown_f_ops), GFP_ATOMIC);
-		if (s_f_ops == NULL)
-			panic("Atomic allocation failed for snd_shutdown_f_ops!");
-
-		f_ops = &s_f_ops->f_ops;
-
-		memset(f_ops, 0, sizeof(*f_ops));
-		f_ops->owner = file->f_op->owner;
-		f_ops->release = file->f_op->release;
-		f_ops->llseek = snd_disconnect_llseek;
-		f_ops->read = snd_disconnect_read;
-		f_ops->write = snd_disconnect_write;
-		f_ops->poll = snd_disconnect_poll;
-		f_ops->unlocked_ioctl = snd_disconnect_ioctl;
-#ifdef CONFIG_COMPAT
-		f_ops->compat_ioctl = snd_disconnect_ioctl;
-#endif
-		f_ops->mmap = snd_disconnect_mmap;
-		f_ops->fasync = snd_disconnect_fasync;
+		mfile->disconnected_f_op = mfile->file->f_op;
 
-		s_f_ops->next = card->s_f_ops;
-		card->s_f_ops = s_f_ops;
-		
-		f_ops = fops_get(f_ops);
+		spin_lock(&shutdown_lock);
+		list_add(&mfile->shutdown_list, &shutdown_files);
+		spin_unlock(&shutdown_lock);
 
-		old_f_ops = file->f_op;
-		file->f_op = f_ops;	/* must be atomic */
-		fops_put(old_f_ops);
+		fops_get(&snd_shutdown_f_ops);
+		mfile->file->f_op = &snd_shutdown_f_ops;
 		
 		mfile = mfile->next;
 	}
@@ -310,6 +325,7 @@
 	if (err < 0)
 		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
 
+	snd_info_card_disconnect(card);
 	return 0;	
 }
 
@@ -326,22 +342,8 @@
  *  Returns zero. Frees all associated devices and frees the control
  *  interface associated to given soundcard.
  */
-int snd_card_free(struct snd_card *card)
+static int snd_card_do_free(struct snd_card *card)
 {
-	struct snd_shutdown_f_ops *s_f_ops;
-
-	if (card == NULL)
-		return -EINVAL;
-	mutex_lock(&snd_card_mutex);
-	snd_cards[card->number] = NULL;
-	mutex_unlock(&snd_card_mutex);
-
-#ifdef CONFIG_PM
-	wake_up(&card->power_sleep);
-#endif
-	/* wait, until all devices are ready for the free operation */
-	wait_event(card->shutdown_sleep, card->files == NULL);
-
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	if (snd_mixer_oss_notify_callback)
 		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_FREE);
@@ -360,71 +362,68 @@
 	}
 	if (card->private_free)
 		card->private_free(card);
-	snd_info_unregister(card->proc_id);
+	snd_info_free_entry(card->proc_id);
 	if (snd_info_card_free(card) < 0) {
 		snd_printk(KERN_WARNING "unable to free card info\n");
 		/* Not fatal error */
 	}
-	while (card->s_f_ops) {
-		s_f_ops = card->s_f_ops;
-		card->s_f_ops = s_f_ops->next;
-		kfree(s_f_ops);
-	}
+#ifndef CONFIG_SYSFS_DEPRECATED
+	if (card->card_dev)
+		device_unregister(card->card_dev);
+#endif
+	kfree(card);
+	return 0;
+}
+
+static int snd_card_free_prepare(struct snd_card *card)
+{
+	if (card == NULL)
+		return -EINVAL;
+	(void) snd_card_disconnect(card);
 	mutex_lock(&snd_card_mutex);
+	snd_cards[card->number] = NULL;
 	snd_cards_lock &= ~(1 << card->number);
 	mutex_unlock(&snd_card_mutex);
-	kfree(card);
+#ifdef CONFIG_PM
+	wake_up(&card->power_sleep);
+#endif
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_card_free);
-
-static void snd_card_free_thread(void * __card)
+int snd_card_free_when_closed(struct snd_card *card)
 {
-	struct snd_card *card = __card;
-	struct module * module = card->module;
+	int free_now = 0;
+	int ret = snd_card_free_prepare(card);
+	if (ret)
+		return ret;
 
-	if (!try_module_get(module)) {
-		snd_printk(KERN_ERR "unable to lock toplevel module for card %i in free thread\n", card->number);
-		module = NULL;
-	}
-
-	snd_card_free(card);
+	spin_lock(&card->files_lock);
+	if (card->files == NULL)
+		free_now = 1;
+	else
+		card->free_on_last_close = 1;
+	spin_unlock(&card->files_lock);
 
-	module_put(module);
+	if (free_now)
+		snd_card_do_free(card);
+	return 0;
 }
 
-/**
- *  snd_card_free_in_thread - call snd_card_free() in thread
- *  @card: soundcard structure
- *
- *  This function schedules the call of snd_card_free() function in a
- *  work queue.  When all devices are released (non-busy), the work
- *  is woken up and calls snd_card_free().
- *
- *  When a card can be disconnected at any time by hotplug service,
- *  this function should be used in disconnect (or detach) callback
- *  instead of calling snd_card_free() directly.
- *  
- *  Returns - zero otherwise a negative error code if the start of thread failed.
- */
-int snd_card_free_in_thread(struct snd_card *card)
-{
-	if (card->files == NULL) {
-		snd_card_free(card);
-		return 0;
-	}
+EXPORT_SYMBOL(snd_card_free_when_closed);
 
-	if (schedule_work(&card->free_workq))
-		return 0;
+int snd_card_free(struct snd_card *card)
+{
+	int ret = snd_card_free_prepare(card);
+	if (ret)
+		return ret;
 
-	snd_printk(KERN_ERR "schedule_work() failed in snd_card_free_in_thread for card %i\n", card->number);
-	/* try to free the structure immediately */
-	snd_card_free(card);
-	return -EFAULT;
+	/* wait, until all devices are ready for the free operation */
+	wait_event(card->shutdown_sleep, card->files == NULL);
+	snd_card_do_free(card);
+	return 0;
 }
 
-EXPORT_SYMBOL(snd_card_free_in_thread);
+EXPORT_SYMBOL(snd_card_free);
 
 static void choose_default_id(struct snd_card *card)
 {
@@ -625,9 +624,9 @@
 
 int __exit snd_card_info_done(void)
 {
-	snd_info_unregister(snd_card_info_entry);
+	snd_info_free_entry(snd_card_info_entry);
 #ifdef MODULE
-	snd_info_unregister(snd_card_module_info_entry);
+	snd_info_free_entry(snd_card_module_info_entry);
 #endif
 	return 0;
 }
@@ -686,6 +685,7 @@
 	if (mfile == NULL)
 		return -ENOMEM;
 	mfile->file = file;
+	mfile->disconnected_f_op = NULL;
 	mfile->next = NULL;
 	spin_lock(&card->files_lock);
 	if (card->shutdown) {
@@ -708,15 +708,16 @@
  *
  *  This function removes the file formerly added to the card via
  *  snd_card_file_add() function.
- *  If all files are removed and the release of the card is
- *  scheduled, it will wake up the the thread to call snd_card_free()
- *  (see snd_card_free_in_thread() function).
+ *  If all files are removed and snd_card_free_when_closed() was
+ *  called beforehand, it processes the pending release of
+ *  resources.
  *
  *  Returns zero or a negative error code.
  */
 int snd_card_file_remove(struct snd_card *card, struct file *file)
 {
 	struct snd_monitor_file *mfile, *pfile = NULL;
+	int last_close = 0;
 
 	spin_lock(&card->files_lock);
 	mfile = card->files;
@@ -731,9 +732,20 @@
 		pfile = mfile;
 		mfile = mfile->next;
 	}
-	spin_unlock(&card->files_lock);
+	if (mfile && mfile->disconnected_f_op) {
+		fops_put(mfile->disconnected_f_op);
+		spin_lock(&shutdown_lock);
+		list_del(&mfile->shutdown_list);
+		spin_unlock(&shutdown_lock);
+	}
 	if (card->files == NULL)
+		last_close = 1;
+	spin_unlock(&card->files_lock);
+	if (last_close) {
 		wake_up(&card->shutdown_sleep);
+		if (card->free_on_last_close)
+			snd_card_do_free(card);
+	}
 	if (!mfile) {
 		snd_printk(KERN_ERR "ALSA card file remove problem (%p)\n", file);
 		return -ENOENT;
--- linux-2.6.18.noarch/sound/core/sound_oss.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/sound_oss.c	2007-06-05 17:41:11.000000000 -0400
@@ -106,7 +106,7 @@
 	int cidx = SNDRV_MINOR_OSS_CARD(minor);
 	int track2 = -1;
 	int register1 = -1, register2 = -1;
-	struct device *carddev = NULL;
+	struct device *carddev = snd_card_get_device_link(card);
 
 	if (card && card->number >= 8)
 		return 0; /* ignore silently */
@@ -134,8 +134,6 @@
 		track2 = SNDRV_MINOR_OSS(cidx, SNDRV_MINOR_OSS_DMMIDI1);
 		break;
 	}
-	if (card)
-		carddev = card->dev;
 	register1 = register_sound_special_device(f_ops, minor, carddev);
 	if (register1 != minor)
 		goto __end;
@@ -270,8 +268,7 @@
 
 int __exit snd_minor_info_oss_done(void)
 {
-	if (snd_minor_info_oss_entry)
-		snd_info_unregister(snd_minor_info_oss_entry);
+	snd_info_free_entry(snd_minor_info_oss_entry);
 	return 0;
 }
 #endif /* CONFIG_PROC_FS */
--- linux-2.6.18.noarch/sound/core/info.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/info.c	2007-06-05 17:41:11.000000000 -0400
@@ -78,6 +78,7 @@
 
 static int snd_info_version_init(void);
 static int snd_info_version_done(void);
+static void snd_info_disconnect(struct snd_info_entry *entry);
 
 
 /* resize the proc r/w buffer */
@@ -177,15 +178,15 @@
 	switch (entry->content) {
 	case SNDRV_INFO_CONTENT_TEXT:
 		switch (orig) {
-		case 0:	/* SEEK_SET */
+		case SEEK_SET:
 			file->f_pos = offset;
 			ret = file->f_pos;
 			goto out;
-		case 1:	/* SEEK_CUR */
+		case SEEK_CUR:
 			file->f_pos += offset;
 			ret = file->f_pos;
 			goto out;
-		case 2:	/* SEEK_END */
+		case SEEK_END:
 		default:
 			ret = -EINVAL;
 			goto out;
@@ -307,7 +308,7 @@
 	mutex_lock(&info_mutex);
 	p = PDE(inode);
 	entry = p == NULL ? NULL : (struct snd_info_entry *)p->data;
-	if (entry == NULL || entry->disconnected) {
+	if (entry == NULL || ! entry->p) {
 		mutex_unlock(&info_mutex);
 		return -ENODEV;
 	}
@@ -506,7 +507,7 @@
 	return -ENXIO;
 }
 
-static struct file_operations snd_info_entry_operations =
+static const struct file_operations snd_info_entry_operations =
 {
 	.owner =		THIS_MODULE,
 	.llseek =		snd_info_entry_llseek,
@@ -589,10 +590,10 @@
 	snd_info_version_done();
 	if (snd_proc_root) {
 #if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
-		snd_info_unregister(snd_seq_root);
+		snd_info_free_entry(snd_seq_root);
 #endif
 #ifdef CONFIG_SND_OSSEMUL
-		snd_info_unregister(snd_oss_root);
+		snd_info_free_entry(snd_oss_root);
 #endif
 		snd_remove_proc_entry(&proc_root, snd_proc_root);
 	}
@@ -651,17 +652,28 @@
  * de-register the card proc file
  * called from init.c
  */
-int snd_info_card_free(struct snd_card *card)
+void snd_info_card_disconnect(struct snd_card *card)
 {
-	snd_assert(card != NULL, return -ENXIO);
+	snd_assert(card != NULL, return);
+	mutex_lock(&info_mutex);
 	if (card->proc_root_link) {
 		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
 		card->proc_root_link = NULL;
 	}
-	if (card->proc_root) {
-		snd_info_unregister(card->proc_root);
-		card->proc_root = NULL;
-	}
+	if (card->proc_root)
+		snd_info_disconnect(card->proc_root);
+	mutex_unlock(&info_mutex);
+}
+
+/*
+ * release the card proc file resources
+ * called from init.c
+ */
+int snd_info_card_free(struct snd_card *card)
+{
+	snd_assert(card != NULL, return -ENXIO);
+	snd_info_free_entry(card->proc_root);
+	card->proc_root = NULL;
 	return 0;
 }
 
@@ -770,6 +782,8 @@
 	entry->mode = S_IFREG | S_IRUGO;
 	entry->content = SNDRV_INFO_CONTENT_TEXT;
 	mutex_init(&entry->access);
+	INIT_LIST_HEAD(&entry->children);
+	INIT_LIST_HEAD(&entry->list);
 	return entry;
 }
 
@@ -822,30 +836,35 @@
 
 EXPORT_SYMBOL(snd_info_create_card_entry);
 
-static int snd_info_dev_free_entry(struct snd_device *device)
+static void snd_info_disconnect(struct snd_info_entry *entry)
 {
-	struct snd_info_entry *entry = device->device_data;
-	snd_info_free_entry(entry);
-	return 0;
-}
+	struct list_head *p, *n;
+	struct proc_dir_entry *root;
 
-static int snd_info_dev_register_entry(struct snd_device *device)
-{
-	struct snd_info_entry *entry = device->device_data;
-	return snd_info_register(entry);
+	list_for_each_safe(p, n, &entry->children) {
+		snd_info_disconnect(list_entry(p, struct snd_info_entry, list));
+	}
+
+	if (! entry->p)
+		return;
+	list_del_init(&entry->list);
+	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
+	snd_assert(root, return);
+	snd_remove_proc_entry(root, entry->p);
+	entry->p = NULL;
 }
 
-static int snd_info_dev_disconnect_entry(struct snd_device *device)
+static int snd_info_dev_free_entry(struct snd_device *device)
 {
 	struct snd_info_entry *entry = device->device_data;
-	entry->disconnected = 1;
+	snd_info_free_entry(entry);
 	return 0;
 }
 
-static int snd_info_dev_unregister_entry(struct snd_device *device)
+static int snd_info_dev_register_entry(struct snd_device *device)
 {
 	struct snd_info_entry *entry = device->device_data;
-	return snd_info_unregister(entry);
+	return snd_info_register(entry);
 }
 
 /**
@@ -874,8 +893,7 @@
 	static struct snd_device_ops ops = {
 		.dev_free = snd_info_dev_free_entry,
 		.dev_register =	snd_info_dev_register_entry,
-		.dev_disconnect = snd_info_dev_disconnect_entry,
-		.dev_unregister = snd_info_dev_unregister_entry
+		/* disconnect is done via snd_info_card_disconnect() */
 	};
 	struct snd_info_entry *entry;
 	int err;
@@ -904,6 +922,11 @@
 {
 	if (entry == NULL)
 		return;
+	if (entry->p) {
+		mutex_lock(&info_mutex);
+		snd_info_disconnect(entry);
+		mutex_unlock(&info_mutex);
+	}
 	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);
@@ -938,38 +961,14 @@
 	p->size = entry->size;
 	p->data = entry;
 	entry->p = p;
+	if (entry->parent)
+		list_add_tail(&entry->list, &entry->parent->children);
 	mutex_unlock(&info_mutex);
 	return 0;
 }
 
 EXPORT_SYMBOL(snd_info_register);
 
-/**
- * snd_info_unregister - de-register the info entry
- * @entry: the info entry
- *
- * De-registers the info entry and releases the instance.
- *
- * Returns zero if successful, or a negative error code on failure.
- */
-int snd_info_unregister(struct snd_info_entry * entry)
-{
-	struct proc_dir_entry *root;
-
-	if (! entry)
-		return 0;
-	snd_assert(entry->p != NULL, return -ENXIO);
-	root = entry->parent == NULL ? snd_proc_root : entry->parent->p;
-	snd_assert(root, return -ENXIO);
-	mutex_lock(&info_mutex);
-	snd_remove_proc_entry(root, entry->p);
-	mutex_unlock(&info_mutex);
-	snd_info_free_entry(entry);
-	return 0;
-}
-
-EXPORT_SYMBOL(snd_info_unregister);
-
 /*
 
  */
@@ -1002,8 +1001,7 @@
 
 static int __exit snd_info_version_done(void)
 {
-	if (snd_info_version_entry)
-		snd_info_unregister(snd_info_version_entry);
+	snd_info_free_entry(snd_info_version_entry);
 	return 0;
 }
 
--- linux-2.6.18.noarch/sound/core/sound.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/core/sound.c	2007-06-05 17:41:11.000000000 -0400
@@ -61,9 +61,6 @@
 static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
 static DEFINE_MUTEX(sound_mutex);
 
-extern struct class *sound_class;
-
-
 #ifdef CONFIG_KMOD
 
 /**
@@ -171,7 +168,7 @@
 	return err;
 }
 
-static struct file_operations snd_fops =
+static const struct file_operations snd_fops =
 {
 	.owner =	THIS_MODULE,
 	.open =		snd_open
@@ -387,8 +384,8 @@
 
 int __exit snd_minor_info_done(void)
 {
-	if (snd_minor_info_entry)
-		snd_info_unregister(snd_minor_info_entry);
+	//if (snd_minor_info_entry)
+		//snd_info_unregister(snd_minor_info_entry);
 	return 0;
 }
 #endif /* CONFIG_PROC_FS */
--- linux-2.6.18.noarch/sound/ppc/pmac.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/ppc/pmac.c	2007-06-05 17:48:54.000000000 -0400
@@ -713,7 +713,7 @@
  * interrupt handlers
  */
 static irqreturn_t
-snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
+snd_pmac_tx_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->playback);
@@ -722,7 +722,7 @@
 
 
 static irqreturn_t
-snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
+snd_pmac_rx_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->capture);
@@ -731,7 +731,7 @@
 
 
 static irqreturn_t
-snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
+snd_pmac_ctrl_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	int ctrl = in_le32(&chip->awacs->control);
--- linux-2.6.18.noarch/sound/ppc/tumbler.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/ppc/tumbler.c	2007-06-05 17:48:54.000000000 -0400
@@ -190,7 +190,7 @@
 
 	ret = do_gpio_read(gp);
 
-	return (ret & 0xd) == (gp->active_val & 0xd);
+	return (ret & 0x1) == (gp->active_val & 0x1);
 }
 
 static int read_audio_gpio(struct pmac_gpio *gp)
@@ -198,7 +198,8 @@
 	int ret;
 	if (! gp->addr)
 		return 0;
-	ret = ((do_gpio_read(gp) & 0x02) !=0);
+	ret = do_gpio_read(gp);
+	ret = (ret & 0x02) !=0;
 	return ret == gp->active_state;
 }
 
@@ -941,10 +942,11 @@
 }
 
 static struct work_struct device_change;
+static struct snd_pmac *device_change_chip;
 
-static void device_change_handler(void *self)
+static void device_change_handler(struct work_struct *work)
 {
-	struct snd_pmac *chip = self;
+	struct snd_pmac *chip = device_change_chip;
 	struct pmac_tumbler *mix;
 	int headphone, lineout;
 
@@ -1016,7 +1018,7 @@
 
 
 /* interrupt - headphone plug changed */
-static irqreturn_t headphone_intr(int irq, void *devid, struct pt_regs *regs)
+static irqreturn_t headphone_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	if (chip->update_automute && chip->initialized) {
@@ -1035,7 +1037,7 @@
 		return NULL;
   
 	for (np = np->child; np; np = np->sibling) {
-		char *property = get_property(np, "audio-gpio", NULL);
+		const char *property = get_property(np, "audio-gpio", NULL);
 		if (property && strcmp(property, name) == 0)
 			return np;
 	}  
@@ -1062,7 +1064,8 @@
 				struct pmac_gpio *gp, int is_compatible)
 {
 	struct device_node *node;
-	u32 *base, addr;
+	const u32 *base;
+	u32 addr;
 
 	if (is_compatible)
 		node = find_compatible_audio_device(device);
@@ -1074,9 +1077,9 @@
 		return -ENODEV;
 	}
 
-	base = (u32 *)get_property(node, "AAPL,address", NULL);
+	base = get_property(node, "AAPL,address", NULL);
 	if (! base) {
-		base = (u32 *)get_property(node, "reg", NULL);
+		base = get_property(node, "reg", NULL);
 		if (!base) {
 			DBG("(E) cannot find address for device %s !\n", device);
 			snd_printd("cannot find address for device %s\n", device);
@@ -1090,13 +1093,13 @@
 
 	gp->addr = addr & 0x0000ffff;
 	/* Try to find the active state, default to 0 ! */
-	base = (u32 *)get_property(node, "audio-gpio-active-state", NULL);
+	base = get_property(node, "audio-gpio-active-state", NULL);
 	if (base) {
 		gp->active_state = *base;
 		gp->active_val = (*base) ? 0x5 : 0x4;
 		gp->inactive_val = (*base) ? 0x4 : 0x5;
 	} else {
-		u32 *prop = NULL;
+		const u32 *prop = NULL;
 		gp->active_state = 0;
 		gp->active_val = 0x4;
 		gp->inactive_val = 0x5;
@@ -1105,7 +1108,7 @@
 		 * as we don't yet have an interpreter for these things
 		 */
 		if (platform)
-			prop = (u32 *)get_property(node, platform, NULL);
+			prop = get_property(node, platform, NULL);
 		if (prop) {
 			if (prop[3] == 0x9 && prop[4] == 0x9) {
 				gp->active_val = 0xd;
@@ -1415,7 +1418,8 @@
 	chip->resume = tumbler_resume;
 #endif
 
-	INIT_WORK(&device_change, device_change_handler, (void *)chip);
+	INIT_WORK(&device_change, device_change_handler);
+	device_change_chip = chip;
 
 #ifdef PMAC_SUPPORT_AUTOMUTE
 	if ((mix->headphone_irq >=0 || mix->lineout_irq >= 0)
--- linux-2.6.18.noarch/sound/ppc/beep.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/ppc/beep.c	2007-06-05 17:48:54.000000000 -0400
@@ -215,15 +215,18 @@
 {
 	struct pmac_beep *beep;
 	struct input_dev *input_dev;
+	struct snd_kcontrol *beep_ctl;
 	void *dmabuf;
 	int err = -ENOMEM;
 
 	beep = kzalloc(sizeof(*beep), GFP_KERNEL);
+	if (! beep)
+		return -ENOMEM;
 	dmabuf = dma_alloc_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
 				    &beep->addr, GFP_KERNEL);
 	input_dev = input_allocate_device();
-	if (!beep || !dmabuf || !input_dev)
-		goto fail;
+	if (! dmabuf || ! input_dev)
+		goto fail1;
 
 	/* FIXME: set more better values */
 	input_dev->name = "PowerMac Beep";
@@ -244,17 +247,24 @@
 	beep->volume = BEEP_VOLUME;
 	beep->running = 0;
 
-	err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_pmac_beep_mixer, chip));
+	beep_ctl = snd_ctl_new1(&snd_pmac_beep_mixer, chip);
+	err = snd_ctl_add(chip->card, beep_ctl);
 	if (err < 0)
-		goto fail;
-
-	chip->beep = beep;
-	input_register_device(beep->dev);
-
-	return 0;
-
- fail:	input_free_device(input_dev);
-	kfree(dmabuf);
+		goto fail1;
+ 
+ 	chip->beep = beep;
+
+	err = input_register_device(beep->dev);
+	if (err)
+		goto fail2;
+ 
+ 	return 0;
+ 
+ fail2:	snd_ctl_remove(chip->card, beep_ctl);
+ fail1:	input_free_device(input_dev);
+	if (dmabuf)
+		dma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
+				  dmabuf, beep->addr);
 	kfree(beep);
 	return err;
 }
--- linux-2.6.18.noarch/sound/Makefile.orig	2007-06-05 16:07:46.000000000 -0400
+++ linux-2.6.18.noarch/sound/Makefile	2007-06-05 17:39:02.000000000 -0400
@@ -2,13 +2,17 @@
 #
 
 obj-$(CONFIG_SOUND) += soundcore.o
+obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ synth/ usb/ sparc/ parisc/ pcmcia/ mips/ soc/
 obj-$(CONFIG_SND_AOA) += aoa/
 
+# This one must be compilable even if sound is configured out
+obj-$(CONFIG_AC97_BUS) += ac97_bus.o
+
 ifeq ($(CONFIG_SND),y)
   obj-y += last.o
 endif
 
-soundcore-objs  := sound_core.o sound_firmware.o
+soundcore-objs  := sound_core.o
--- linux-2.6.18.noarch/sound/sound_firmware.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/sound_firmware.c	2007-06-05 17:39:02.000000000 -0400
@@ -4,6 +4,7 @@
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
+#include "oss/sound_firmware.h"
 
 static int do_mod_firmware_load(const char *fn, char **fp)
 {
@@ -18,7 +19,7 @@
 		printk(KERN_INFO "Unable to load '%s'.\n", fn);
 		return 0;
 	}
-	l = filp->f_dentry->d_inode->i_size;
+	l = filp->f_path.dentry->d_inode->i_size;
 	if (l <= 0 || l > 131072)
 	{
 		printk(KERN_INFO "Invalid firmware '%s'\n", fn);
@@ -59,8 +60,7 @@
  *	value zero on a failure.
  *
  *	Caution: This API is not recommended. Firmware should be loaded via
- *	an ioctl call and a setup application. This function may disappear
- *	in future.
+ *	request_firmware.
  */
  
 int mod_firmware_load(const char *fn, char **fp)
@@ -73,4 +73,6 @@
 	set_fs(fs);
 	return r;
 }
+EXPORT_SYMBOL(mod_firmware_load);
 
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-pcm.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-pcm.c	2007-06-05 17:39:43.000000000 -0400
@@ -125,7 +125,8 @@
 	}
 	/* bus dependent stuff */
 	hw->info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
-		   SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_RESUME;
+		   SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_RESUME |
+		   SNDRV_PCM_INFO_JOINT_DUPLEX;
 
 	CHECK_RATE(5512);
 	CHECK_RATE(8000);
@@ -245,18 +246,78 @@
 	return err;
 }
 
+static void i2sbus_wait_for_stop(struct i2sbus_dev *i2sdev,
+				 struct pcm_info *pi)
+{
+	unsigned long flags;
+	struct completion done;
+	long timeout;
+
+	spin_lock_irqsave(&i2sdev->low_lock, flags);
+	if (pi->dbdma_ring.stopping) {
+		init_completion(&done);
+		pi->stop_completion = &done;
+		spin_unlock_irqrestore(&i2sdev->low_lock, flags);
+		timeout = wait_for_completion_timeout(&done, HZ);
+		spin_lock_irqsave(&i2sdev->low_lock, flags);
+		pi->stop_completion = NULL;
+		if (timeout == 0) {
+			/* timeout expired, stop dbdma forcefully */
+			printk(KERN_ERR "i2sbus_wait_for_stop: timed out\n");
+			/* make sure RUN, PAUSE and S0 bits are cleared */
+			out_le32(&pi->dbdma->control, (RUN | PAUSE | 1) << 16);
+			pi->dbdma_ring.stopping = 0;
+			timeout = 10;
+			while (in_le32(&pi->dbdma->status) & ACTIVE) {
+				if (--timeout <= 0)
+					break;
+				udelay(1);
+			}
+		}
+	}
+	spin_unlock_irqrestore(&i2sdev->low_lock, flags);
+}
+
+#ifdef CONFIG_PM
+void i2sbus_wait_for_stop_both(struct i2sbus_dev *i2sdev)
+{
+	struct pcm_info *pi;
+
+	get_pcm_info(i2sdev, 0, &pi, NULL);
+	i2sbus_wait_for_stop(i2sdev, pi);
+	get_pcm_info(i2sdev, 1, &pi, NULL);
+	i2sbus_wait_for_stop(i2sdev, pi);
+}
+#endif
+
 static int i2sbus_hw_params(struct snd_pcm_substream *substream,
 			    struct snd_pcm_hw_params *params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 }
 
-static int i2sbus_hw_free(struct snd_pcm_substream *substream)
+static inline int i2sbus_hw_free(struct snd_pcm_substream *substream, int in)
 {
+	struct i2sbus_dev *i2sdev = snd_pcm_substream_chip(substream);
+	struct pcm_info *pi;
+
+	get_pcm_info(i2sdev, in, &pi, NULL);
+	if (pi->dbdma_ring.stopping)
+		i2sbus_wait_for_stop(i2sdev, pi);
 	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
+static int i2sbus_playback_hw_free(struct snd_pcm_substream *substream)
+{
+	return i2sbus_hw_free(substream, 0);
+}
+
+static int i2sbus_record_hw_free(struct snd_pcm_substream *substream)
+{
+	return i2sbus_hw_free(substream, 1);
+}
+
 static int i2sbus_pcm_prepare(struct i2sbus_dev *i2sdev, int in)
 {
 	/* whee. Hard work now. The user has selected a bitrate
@@ -264,7 +325,7 @@
 	 * I2S controller appropriately. */
 	struct snd_pcm_runtime *runtime;
 	struct dbdma_cmd *command;
-	int i, periodsize;
+	int i, periodsize, nperiods;
 	dma_addr_t offset;
 	struct bus_info bi;
 	struct codec_info_item *cii;
@@ -274,6 +335,7 @@
 	struct pcm_info *pi, *other;
 	int cnt;
 	int result = 0;
+	unsigned int cmd, stopaddr;
 
 	mutex_lock(&i2sdev->lock);
 
@@ -283,6 +345,13 @@
 		result = -EBUSY;
 		goto out_unlock;
 	}
+	if (pi->dbdma_ring.stopping)
+		i2sbus_wait_for_stop(i2sdev, pi);
+
+	if (!pi->substream || !pi->substream->runtime) {
+		result = -EINVAL;
+		goto out_unlock;
+	}
 
 	runtime = pi->substream->runtime;
 	pi->active = 1;
@@ -297,24 +366,43 @@
 	i2sdev->rate = runtime->rate;
 
 	periodsize = snd_pcm_lib_period_bytes(pi->substream);
+	nperiods = pi->substream->runtime->periods;
 	pi->current_period = 0;
 
 	/* generate dbdma command ring first */
 	command = pi->dbdma_ring.cmds;
+	memset(command, 0, (nperiods + 2) * sizeof(struct dbdma_cmd));
+
+	/* commands to DMA to/from the ring */
+	/*
+	 * For input, we need to do a graceful stop; if we abort
+	 * the DMA, we end up with leftover bytes that corrupt
+	 * the next recording.  To do this we set the S0 status
+	 * bit and wait for the DMA controller to stop.  Each
+	 * command has a branch condition to
+	 * make it branch to a stop command if S0 is set.
+	 * On input we also need to wait for the S7 bit to be
+	 * set before turning off the DMA controller.
+	 * In fact we do the graceful stop for output as well.
+	 */
 	offset = runtime->dma_addr;
-	for (i = 0; i < pi->substream->runtime->periods;
-	     i++, command++, offset += periodsize) {
-		memset(command, 0, sizeof(struct dbdma_cmd));
-		command->command =
-		    cpu_to_le16((in ? INPUT_MORE : OUTPUT_MORE) | INTR_ALWAYS);
+	cmd = (in? INPUT_MORE: OUTPUT_MORE) | BR_IFSET | INTR_ALWAYS;
+	stopaddr = pi->dbdma_ring.bus_cmd_start +
+		(nperiods + 1) * sizeof(struct dbdma_cmd);
+	for (i = 0; i < nperiods; i++, command++, offset += periodsize) {
+		command->command = cpu_to_le16(cmd);
+		command->cmd_dep = cpu_to_le32(stopaddr);
 		command->phy_addr = cpu_to_le32(offset);
 		command->req_count = cpu_to_le16(periodsize);
-		command->xfer_status = cpu_to_le16(0);
 	}
-	/* last one branches back to first */
-	command--;
-	command->command |= cpu_to_le16(BR_ALWAYS);
+
+	/* branch back to beginning of ring */
+	command->command = cpu_to_le16(DBDMA_NOP | BR_ALWAYS);
 	command->cmd_dep = cpu_to_le32(pi->dbdma_ring.bus_cmd_start);
+	command++;
+
+	/* set stop command */
+	command->command = cpu_to_le16(DBDMA_STOP);
 
 	/* ok, let's set the serial format and stuff */
 	switch (runtime->format) {
@@ -435,16 +523,18 @@
 	return result;
 }
 
-static struct dbdma_cmd STOP_CMD = {
-	.command = __constant_cpu_to_le16(DBDMA_STOP),
-};
+#ifdef CONFIG_PM
+void i2sbus_pcm_prepare_both(struct i2sbus_dev *i2sdev)
+{
+	i2sbus_pcm_prepare(i2sdev, 0);
+	i2sbus_pcm_prepare(i2sdev, 1);
+}
+#endif
 
 static int i2sbus_pcm_trigger(struct i2sbus_dev *i2sdev, int in, int cmd)
 {
 	struct codec_info_item *cii;
 	struct pcm_info *pi;
-	int timeout;
-	struct dbdma_cmd tmp;
 	int result = 0;
 	unsigned long flags;
 
@@ -464,92 +554,50 @@
 				cii->codec->start(cii, pi->substream);
 		pi->dbdma_ring.running = 1;
 
-		/* reset dma engine */
-		out_le32(&pi->dbdma->control,
-			 0 | (RUN | PAUSE | FLUSH | WAKE) << 16);
-		timeout = 100;
-		while (in_le32(&pi->dbdma->status) & RUN && timeout--)
-			udelay(1);
-		if (timeout <= 0) {
-			printk(KERN_ERR
-			       "i2sbus: error waiting for dma reset\n");
-			result = -ENXIO;
-			goto out_unlock;
+		if (pi->dbdma_ring.stopping) {
+			/* Clear the S0 bit, then see if we stopped yet */
+			out_le32(&pi->dbdma->control, 1 << 16);
+			if (in_le32(&pi->dbdma->status) & ACTIVE) {
+				/* possible race here? */
+				udelay(10);
+				if (in_le32(&pi->dbdma->status) & ACTIVE) {
+					pi->dbdma_ring.stopping = 0;
+					goto out_unlock; /* keep running */
+				}
+			}
 		}
 
+		/* make sure RUN, PAUSE and S0 bits are cleared */
+		out_le32(&pi->dbdma->control, (RUN | PAUSE | 1) << 16);
+
+		/* set branch condition select register */
+		out_le32(&pi->dbdma->br_sel, (1 << 16) | 1);
+
 		/* write dma command buffer address to the dbdma chip */
 		out_le32(&pi->dbdma->cmdptr, pi->dbdma_ring.bus_cmd_start);
-		/* post PCI write */
-		mb();
-		(void)in_le32(&pi->dbdma->status);
-
-		/* change first command to STOP */
-		tmp = *pi->dbdma_ring.cmds;
-		*pi->dbdma_ring.cmds = STOP_CMD;
-
-		/* set running state, remember that the first command is STOP */
-		out_le32(&pi->dbdma->control, RUN | (RUN << 16));
-		timeout = 100;
-		/* wait for STOP to be executed */
-		while (in_le32(&pi->dbdma->status) & ACTIVE && timeout--)
-			udelay(1);
-		if (timeout <= 0) {
-			printk(KERN_ERR "i2sbus: error waiting for dma stop\n");
-			result = -ENXIO;
-			goto out_unlock;
-		}
-		/* again, write dma command buffer address to the dbdma chip,
-		 * this time of the first real command */
-		*pi->dbdma_ring.cmds = tmp;
-		out_le32(&pi->dbdma->cmdptr, pi->dbdma_ring.bus_cmd_start);
-		/* post write */
-		mb();
-		(void)in_le32(&pi->dbdma->status);
-
-		/* reset dma engine again */
-		out_le32(&pi->dbdma->control,
-			 0 | (RUN | PAUSE | FLUSH | WAKE) << 16);
-		timeout = 100;
-		while (in_le32(&pi->dbdma->status) & RUN && timeout--)
-			udelay(1);
-		if (timeout <= 0) {
-			printk(KERN_ERR
-			       "i2sbus: error waiting for dma reset\n");
-			result = -ENXIO;
-			goto out_unlock;
-		}
 
-		/* wake up the chip with the next descriptor */
-		out_le32(&pi->dbdma->control,
-			 (RUN | WAKE) | ((RUN | WAKE) << 16));
-		/* get the frame count  */
+		/* initialize the frame count and current period */
+		pi->current_period = 0;
 		pi->frame_count = in_le32(&i2sdev->intfregs->frame_count);
 
+		/* set the DMA controller running */
+		out_le32(&pi->dbdma->control, (RUN << 16) | RUN);
+
 		/* off you go! */
 		break;
+
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		if (!pi->dbdma_ring.running) {
 			result = -EALREADY;
 			goto out_unlock;
 		}
+		pi->dbdma_ring.running = 0;
 
-		/* turn off all relevant bits */
-		out_le32(&pi->dbdma->control,
-			 (RUN | WAKE | FLUSH | PAUSE) << 16);
-		{
-			/* FIXME: move to own function */
-			int timeout = 5000;
-			while ((in_le32(&pi->dbdma->status) & RUN)
-			       && --timeout > 0)
-				udelay(1);
-			if (!timeout)
-				printk(KERN_ERR
-				       "i2sbus: timed out turning "
-				       "off dbdma engine!\n");
-		}
+		/* Set the S0 bit to make the DMA branch to the stop cmd */
+		out_le32(&pi->dbdma->control, (1 << 16) | 1);
+		pi->dbdma_ring.stopping = 1;
 
-		pi->dbdma_ring.running = 0;
 		list_for_each_entry(cii, &i2sdev->sound.codec_list, list)
 			if (cii->codec->stop)
 				cii->codec->stop(cii, pi->substream);
@@ -574,81 +622,93 @@
 	fc = in_le32(&i2sdev->intfregs->frame_count);
 	fc = fc - pi->frame_count;
 
-	return (bytes_to_frames(pi->substream->runtime,
-			pi->current_period *
-			snd_pcm_lib_period_bytes(pi->substream))
-		+ fc) % pi->substream->runtime->buffer_size;
+	if (fc >= pi->substream->runtime->buffer_size)
+		fc %= pi->substream->runtime->buffer_size;
+	return fc;
 }
 
 static inline void handle_interrupt(struct i2sbus_dev *i2sdev, int in)
 {
 	struct pcm_info *pi;
-	u32 fc;
-	u32 delta;
+	u32 fc, nframes;
+	u32 status;
+	int timeout, i;
+	int dma_stopped = 0;
+	struct snd_pcm_runtime *runtime;
 
 	spin_lock(&i2sdev->low_lock);
 	get_pcm_info(i2sdev, in, &pi, NULL);
-
-	if (!pi->dbdma_ring.running) {
-		/* there was still an interrupt pending
-		 * while we stopped. or maybe another
-		 * processor (not the one that was stopping
-		 * the DMA engine) was spinning above
-		 * waiting for the lock. */
+	if (!pi->dbdma_ring.running && !pi->dbdma_ring.stopping)
 		goto out_unlock;
-	}
 
-	fc = in_le32(&i2sdev->intfregs->frame_count);
-	/* a counter overflow does not change the calculation. */
-	delta = fc - pi->frame_count;
-
-	/* update current_period */
-	while (delta >= pi->substream->runtime->period_size) {
-		pi->current_period++;
-		delta = delta - pi->substream->runtime->period_size;
-	}
-
-	if (unlikely(delta)) {
-		/* Some interrupt came late, so check the dbdma.
-		 * This special case exists to syncronize the frame_count with
-		 * the dbdma transfer, but is hit every once in a while. */
-		int period;
-
-		period = (in_le32(&pi->dbdma->cmdptr)
-		        - pi->dbdma_ring.bus_cmd_start)
-				/ sizeof(struct dbdma_cmd);
-		pi->current_period = pi->current_period
-					% pi->substream->runtime->periods;
-
-		while (pi->current_period != period) {
-			pi->current_period++;
-			pi->current_period %= pi->substream->runtime->periods;
-			/* Set delta to zero, as the frame_count value is too
-			 * high (otherwise the code path will not be executed).
-			 * This corrects the fact that the frame_count is too
-			 * low at the beginning due to buffering. */
-			delta = 0;
+	i = pi->current_period;
+	runtime = pi->substream->runtime;
+	while (pi->dbdma_ring.cmds[i].xfer_status) {
+		if (le16_to_cpu(pi->dbdma_ring.cmds[i].xfer_status) & BT)
+			/*
+			 * BT is the branch taken bit.  If it took a branch
+			 * it is because we set the S0 bit to make it
+			 * branch to the stop command.
+			 */
+			dma_stopped = 1;
+		pi->dbdma_ring.cmds[i].xfer_status = 0;
+
+		if (++i >= runtime->periods) {
+			i = 0;
+			pi->frame_count += runtime->buffer_size;
+		}
+		pi->current_period = i;
+
+		/*
+		 * Check the frame count.  The DMA tends to get a bit
+		 * ahead of the frame counter, which confuses the core.
+		 */
+		fc = in_le32(&i2sdev->intfregs->frame_count);
+		nframes = i * runtime->period_size;
+		if (fc < pi->frame_count + nframes)
+			pi->frame_count = fc - nframes;
+	}
+
+	if (dma_stopped) {
+		timeout = 1000;
+		for (;;) {
+			status = in_le32(&pi->dbdma->status);
+			if (!(status & ACTIVE) && (!in || (status & 0x80)))
+				break;
+			if (--timeout <= 0) {
+				printk(KERN_ERR "i2sbus: timed out "
+				       "waiting for DMA to stop!\n");
+				break;
+			}
+			udelay(1);
 		}
-	}
 
-	pi->frame_count = fc - delta;
-	pi->current_period %= pi->substream->runtime->periods;
+		/* Turn off DMA controller, clear S0 bit */
+		out_le32(&pi->dbdma->control, (RUN | PAUSE | 1) << 16);
+
+		pi->dbdma_ring.stopping = 0;
+		if (pi->stop_completion)
+			complete(pi->stop_completion);
+	}
 
+	if (!pi->dbdma_ring.running)
+		goto out_unlock;
 	spin_unlock(&i2sdev->low_lock);
 	/* may call _trigger again, hence needs to be unlocked */
 	snd_pcm_period_elapsed(pi->substream);
 	return;
+
  out_unlock:
 	spin_unlock(&i2sdev->low_lock);
 }
 
-irqreturn_t i2sbus_tx_intr(int irq, void *devid, struct pt_regs *regs)
+irqreturn_t i2sbus_tx_intr(int irq, void *devid)
 {
 	handle_interrupt((struct i2sbus_dev *)devid, 0);
 	return IRQ_HANDLED;
 }
 
-irqreturn_t i2sbus_rx_intr(int irq, void *devid, struct pt_regs * regs)
+irqreturn_t i2sbus_rx_intr(int irq, void *devid)
 {
 	handle_interrupt((struct i2sbus_dev *)devid, 1);
 	return IRQ_HANDLED;
@@ -718,7 +778,7 @@
 	.close =	i2sbus_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	i2sbus_hw_params,
-	.hw_free =	i2sbus_hw_free,
+	.hw_free =	i2sbus_playback_hw_free,
 	.prepare =	i2sbus_playback_prepare,
 	.trigger =	i2sbus_playback_trigger,
 	.pointer =	i2sbus_playback_pointer,
@@ -788,7 +848,7 @@
 	.close =	i2sbus_record_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	i2sbus_hw_params,
-	.hw_free =	i2sbus_hw_free,
+	.hw_free =	i2sbus_record_hw_free,
 	.prepare =	i2sbus_record_prepare,
 	.trigger =	i2sbus_record_trigger,
 	.pointer =	i2sbus_record_pointer,
@@ -812,7 +872,6 @@
 	module_put(THIS_MODULE);
 }
 
-/* FIXME: this function needs an error handling strategy with labels */
 int
 i2sbus_attach_codec(struct soundbus_dev *dev, struct snd_card *card,
 		    struct codec_info *ci, void *data)
@@ -880,41 +939,31 @@
 	if (!cii->sdev) {
 		printk(KERN_DEBUG
 		       "i2sbus: failed to get soundbus dev reference\n");
-		kfree(cii);
-		return -ENODEV;
+		err = -ENODEV;
+		goto out_free_cii;
 	}
 
 	if (!try_module_get(THIS_MODULE)) {
 		printk(KERN_DEBUG "i2sbus: failed to get module reference!\n");
-		soundbus_dev_put(dev);
-		kfree(cii);
-		return -EBUSY;
+		err = -EBUSY;
+		goto out_put_sdev;
 	}
 
 	if (!try_module_get(ci->owner)) {
 		printk(KERN_DEBUG
 		       "i2sbus: failed to get module reference to codec owner!\n");
-		module_put(THIS_MODULE);
-		soundbus_dev_put(dev);
-		kfree(cii);
-		return -EBUSY;
+		err = -EBUSY;
+		goto out_put_this_module;
 	}
 
 	if (!dev->pcm) {
-		err = snd_pcm_new(card,
-				  dev->pcmname,
-				  dev->pcmid,
-				  0,
-				  0,
+		err = snd_pcm_new(card, dev->pcmname, dev->pcmid, 0, 0,
 				  &dev->pcm);
 		if (err) {
 			printk(KERN_DEBUG "i2sbus: failed to create pcm\n");
-			kfree(cii);
-			module_put(ci->owner);
-			soundbus_dev_put(dev);
-			module_put(THIS_MODULE);
-			return err;
+			goto out_put_ci_module;
 		}
+		dev->pcm->dev = &dev->ofdev.dev;
 	}
 
 	/* ALSA yet again sucks.
@@ -926,20 +975,12 @@
 			/* eh? */
 			printk(KERN_ERR
 			       "Can't attach same bus to different cards!\n");
-			module_put(ci->owner);
-			kfree(cii);
-			soundbus_dev_put(dev);
-			module_put(THIS_MODULE);
-			return -EINVAL;
-		}
-		if ((err =
-		     snd_pcm_new_stream(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK, 1))) {
-			module_put(ci->owner);
-			kfree(cii);
-			soundbus_dev_put(dev);
-			module_put(THIS_MODULE);
-			return err;
+			err = -EINVAL;
+			goto out_put_ci_module;
 		}
+		err = snd_pcm_new_stream(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK, 1);
+		if (err)
+			goto out_put_ci_module;
 		snd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				&i2sbus_playback_ops);
 		i2sdev->out.created = 1;
@@ -949,20 +990,11 @@
 		if (dev->pcm->card != card) {
 			printk(KERN_ERR
 			       "Can't attach same bus to different cards!\n");
-			module_put(ci->owner);
-			kfree(cii);
-			soundbus_dev_put(dev);
-			module_put(THIS_MODULE);
-			return -EINVAL;
-		}
-		if ((err =
-		     snd_pcm_new_stream(dev->pcm, SNDRV_PCM_STREAM_CAPTURE, 1))) {
-			module_put(ci->owner);
-			kfree(cii);
-			soundbus_dev_put(dev);
-			module_put(THIS_MODULE);
-			return err;
+			goto out_put_ci_module;
 		}
+		err = snd_pcm_new_stream(dev->pcm, SNDRV_PCM_STREAM_CAPTURE, 1);
+		if (err)
+			goto out_put_ci_module;
 		snd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_CAPTURE,
 				&i2sbus_record_ops);
 		i2sdev->in.created = 1;
@@ -977,11 +1009,7 @@
 	err = snd_device_register(card, dev->pcm);
 	if (err) {
 		printk(KERN_ERR "i2sbus: error registering new pcm\n");
-		module_put(ci->owner);
-		kfree(cii);
-		soundbus_dev_put(dev);
-		module_put(THIS_MODULE);
-		return err;
+		goto out_put_ci_module;
 	}
 	/* no errors any more, so let's add this to our list */
 	list_add(&cii->list, &dev->codec_list);
@@ -996,6 +1024,15 @@
 		64 * 1024, 64 * 1024);
 
 	return 0;
+ out_put_ci_module:
+	module_put(ci->owner);
+ out_put_this_module:
+	module_put(THIS_MODULE);
+ out_put_sdev:
+	soundbus_dev_put(dev);
+ out_free_cii:
+	kfree(cii);
+	return err;
 }
 
 void i2sbus_detach_codec(struct soundbus_dev *dev, void *data)
--- linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-core.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-core.c	2007-06-05 17:39:43.000000000 -0400
@@ -41,8 +41,8 @@
 				       struct dbdma_command_mem *r,
 				       int numcmds)
 {
-	/* one more for rounding */
-	r->size = (numcmds+1) * sizeof(struct dbdma_cmd);
+	/* one more for rounding, one for branch back, one for stop command */
+	r->size = (numcmds + 3) * sizeof(struct dbdma_cmd);
 	/* We use the PCI APIs for now until the generic one gets fixed
 	 * enough or until we get some macio-specific versions
 	 */
@@ -93,7 +93,7 @@
 	kfree(i2sdev);
 }
 
-static irqreturn_t i2sbus_bus_intr(int irq, void *devid, struct pt_regs *regs)
+static irqreturn_t i2sbus_bus_intr(int irq, void *devid)
 {
 	struct i2sbus_dev *dev = devid;
 	u32 intreg;
@@ -165,8 +165,7 @@
 	static const char *rnames[] = { "i2sbus: %s (control)",
 					"i2sbus: %s (tx)",
 					"i2sbus: %s (rx)" };
-	static irqreturn_t (*ints[])(int irq, void *devid,
-				     struct pt_regs *regs) = {
+	static irq_handler_t ints[] = {
 		i2sbus_bus_intr,
 		i2sbus_tx_intr,
 		i2sbus_rx_intr
@@ -322,7 +321,7 @@
 	return 0;
 }
 
-static int __devinit i2sbus_probe(struct macio_dev* dev, const struct of_device_id *match)
+static int i2sbus_probe(struct macio_dev* dev, const struct of_device_id *match)
 {
 	struct device_node *np = NULL;
 	int got = 0, err;
@@ -354,7 +353,7 @@
 	return 0;
 }
 
-static int __devexit i2sbus_remove(struct macio_dev* dev)
+static int i2sbus_remove(struct macio_dev* dev)
 {
 	struct i2sbus_control *control = dev->ofdev.dev.driver_data;
 	struct i2sbus_dev *i2sdev, *tmp;
@@ -378,11 +377,8 @@
 		if (i2sdev->sound.pcm) {
 			/* Suspend PCM streams */
 			snd_pcm_suspend_all(i2sdev->sound.pcm);
-			/* Probably useless as we handle
-			 * power transitions ourselves */
-			snd_power_change_state(i2sdev->sound.pcm->card,
-					       SNDRV_CTL_POWER_D3hot);
 		}
+
 		/* Notify codecs */
 		list_for_each_entry(cii, &i2sdev->sound.codec_list, list) {
 			err = 0;
@@ -391,7 +387,11 @@
 			if (err)
 				ret = err;
 		}
+
+		/* wait until streams are stopped */
+		i2sbus_wait_for_stop_both(i2sdev);
 	}
+
 	return ret;
 }
 
@@ -403,6 +403,9 @@
 	int err, ret = 0;
 
 	list_for_each_entry(i2sdev, &control->list, item) {
+		/* reset i2s bus format etc. */
+		i2sbus_pcm_prepare_both(i2sdev);
+
 		/* Notify codecs so they can re-initialize */
 		list_for_each_entry(cii, &i2sdev->sound.codec_list, list) {
 			err = 0;
@@ -411,12 +414,6 @@
 			if (err)
 				ret = err;
 		}
-		/* Notify Alsa */
-		if (i2sdev->sound.pcm) {
-			/* Same comment as above, probably useless */
-			snd_power_change_state(i2sdev->sound.pcm->card,
-					       SNDRV_CTL_POWER_D0);
-		}
 	}
 
 	return ret;
@@ -433,7 +430,7 @@
 	.owner = THIS_MODULE,
 	.match_table = i2sbus_match,
 	.probe = i2sbus_probe,
-	.remove = __devexit_p(i2sbus_remove),
+	.remove = i2sbus_remove,
 #ifdef CONFIG_PM
 	.suspend = i2sbus_suspend,
 	.resume = i2sbus_resume,
--- linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus.h	2007-06-05 17:39:43.000000000 -0400
@@ -10,6 +10,7 @@
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
+#include <linux/completion.h>
 
 #include <sound/pcm.h>
 
@@ -34,6 +35,7 @@
 	void *space;
 	int size;
 	u32 running:1;
+	u32 stopping:1;
 };
 
 struct pcm_info {
@@ -45,6 +47,7 @@
 	u32 frame_count;
 	struct dbdma_command_mem dbdma_ring;
 	volatile struct dbdma_regs __iomem *dbdma;
+	struct completion *stop_completion;
 };
 
 enum {
@@ -97,9 +100,12 @@
 extern void
 i2sbus_detach_codec(struct soundbus_dev *dev, void *data);
 extern irqreturn_t
-i2sbus_tx_intr(int irq, void *devid, struct pt_regs *regs);
+i2sbus_tx_intr(int irq, void *devid);
 extern irqreturn_t
-i2sbus_rx_intr(int irq, void *devid, struct pt_regs *regs);
+i2sbus_rx_intr(int irq, void *devid);
+
+extern void i2sbus_wait_for_stop_both(struct i2sbus_dev *i2sdev);
+extern void i2sbus_pcm_prepare_both(struct i2sbus_dev *i2sdev);
 
 /* control specific functions */
 extern int i2sbus_control_init(struct macio_dev* dev,
--- linux-2.6.18.noarch/sound/aoa/aoa.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/aoa.h	2007-06-05 17:39:10.000000000 -0400
@@ -99,7 +99,7 @@
  * that are not assigned yet are passed to the fabric
  * again for reconsideration. */
 extern int
-aoa_fabric_register(struct aoa_fabric *fabric);
+aoa_fabric_register(struct aoa_fabric *fabric, struct device *dev);
 
 /* it is vital to call this when the fabric exits!
  * When calling, the remove_codec will be called
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-feature.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-feature.c	2007-06-05 17:39:27.000000000 -0400
@@ -56,7 +56,7 @@
 {
 	struct device_node *np, *gpio;
 	u32 *reg;
-	char *audio_gpio;
+	const char *audio_gpio;
 
 	*gpioptr = -1;
 
@@ -195,9 +195,10 @@
 	ftr_gpio_set_lineout(rt, (s>>2)&1);
 }
 
-static void ftr_handle_notify(void *data)
+static void ftr_handle_notify(struct work_struct *work)
 {
-	struct gpio_notification *notif = data;
+	struct gpio_notification *notif =
+		container_of(work, struct gpio_notification, work.work);
 
 	mutex_lock(&notif->mutex);
 	if (notif->notify)
@@ -253,12 +254,9 @@
 
 	ftr_gpio_all_amps_off(rt);
 	rt->implementation_private = 0;
-	INIT_WORK(&rt->headphone_notify.work, ftr_handle_notify,
-		  &rt->headphone_notify);
-	INIT_WORK(&rt->line_in_notify.work, ftr_handle_notify,
-		  &rt->line_in_notify);
-	INIT_WORK(&rt->line_out_notify.work, ftr_handle_notify,
-		  &rt->line_out_notify);
+	INIT_DELAYED_WORK(&rt->headphone_notify.work, ftr_handle_notify);
+	INIT_DELAYED_WORK(&rt->line_in_notify.work, ftr_handle_notify);
+	INIT_DELAYED_WORK(&rt->line_out_notify.work, ftr_handle_notify);
 	mutex_init(&rt->headphone_notify.mutex);
 	mutex_init(&rt->line_in_notify.mutex);
 	mutex_init(&rt->line_out_notify.mutex);
@@ -283,13 +281,11 @@
 	mutex_destroy(&rt->line_out_notify.mutex);
 }
 
-static irqreturn_t ftr_handle_notify_irq(int xx,
-					 void *data,
-					 struct pt_regs *regs)
+static irqreturn_t ftr_handle_notify_irq(int xx, void *data)
 {
 	struct gpio_notification *notif = data;
 
-	schedule_work(&notif->work);
+	schedule_delayed_work(&notif->work, 0);
 
 	return IRQ_HANDLED;
 }
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-pmf.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-pmf.c	2007-06-05 17:39:27.000000000 -0400
@@ -69,9 +69,10 @@
 	pmf_gpio_set_lineout(rt, (s>>2)&1);
 }
 
-static void pmf_handle_notify(void *data)
+static void pmf_handle_notify(struct work_struct *work)
 {
-	struct gpio_notification *notif = data;
+	struct gpio_notification *notif =
+		container_of(work, struct gpio_notification, work.work);
 
 	mutex_lock(&notif->mutex);
 	if (notif->notify)
@@ -83,12 +84,9 @@
 {
 	pmf_gpio_all_amps_off(rt);
 	rt->implementation_private = 0;
-	INIT_WORK(&rt->headphone_notify.work, pmf_handle_notify,
-		  &rt->headphone_notify);
-	INIT_WORK(&rt->line_in_notify.work, pmf_handle_notify,
-		  &rt->line_in_notify);
-	INIT_WORK(&rt->line_out_notify.work, pmf_handle_notify,
-		  &rt->line_out_notify);
+	INIT_DELAYED_WORK(&rt->headphone_notify.work, pmf_handle_notify);
+	INIT_DELAYED_WORK(&rt->line_in_notify.work, pmf_handle_notify);
+	INIT_DELAYED_WORK(&rt->line_out_notify.work, pmf_handle_notify);
 	mutex_init(&rt->headphone_notify.mutex);
 	mutex_init(&rt->line_in_notify.mutex);
 	mutex_init(&rt->line_out_notify.mutex);
@@ -129,7 +127,7 @@
 {
 	struct gpio_notification *notif = data;
 
-	schedule_work(&notif->work);
+	schedule_delayed_work(&notif->work, 0);
 }
 
 static int pmf_set_notify(struct gpio_runtime *rt,
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-alsa.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-alsa.c	2007-06-05 17:39:27.000000000 -0400
@@ -14,7 +14,7 @@
 
 static struct aoa_card *aoa_card;
 
-int aoa_alsa_init(char *name, struct module *mod)
+int aoa_alsa_init(char *name, struct module *mod, struct device *dev)
 {
 	struct snd_card *alsa_card;
 	int err;
@@ -28,6 +28,7 @@
 		return -ENOMEM;
 	aoa_card = alsa_card->private_data;
 	aoa_card->alsa_card = alsa_card;
+	alsa_card->dev = dev;
 	strlcpy(alsa_card->driver, "AppleOnbdAudio", sizeof(alsa_card->driver));
 	strlcpy(alsa_card->shortname, name, sizeof(alsa_card->shortname));
 	strlcpy(alsa_card->longname, name, sizeof(alsa_card->longname));
@@ -59,7 +60,7 @@
 }
 
 int aoa_snd_device_new(snd_device_type_t type,
-        void * device_data, struct snd_device_ops * ops)
+		       void * device_data, struct snd_device_ops * ops)
 {
 	struct snd_card *card = aoa_get_card();
 	int err;
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-core.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-core.c	2007-06-05 17:39:27.000000000 -0400
@@ -82,7 +82,7 @@
 }
 EXPORT_SYMBOL_GPL(aoa_codec_unregister);
 
-int aoa_fabric_register(struct aoa_fabric *new_fabric)
+int aoa_fabric_register(struct aoa_fabric *new_fabric, struct device *dev)
 {
 	struct aoa_codec *c;
 	int err;
@@ -98,7 +98,7 @@
 	if (!new_fabric)
 		return -EINVAL;
 
-	err = aoa_alsa_init(new_fabric->name, new_fabric->owner);
+	err = aoa_alsa_init(new_fabric->name, new_fabric->owner, dev);
 	if (err)
 		return err;
 
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-alsa.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-alsa.h	2007-06-05 17:39:27.000000000 -0400
@@ -10,7 +10,7 @@
 #define __SND_AOA_ALSA_H
 #include "../aoa.h"
 
-extern int aoa_alsa_init(char *name, struct module *mod);
+extern int aoa_alsa_init(char *name, struct module *mod, struct device *dev);
 extern void aoa_alsa_cleanup(void);
 
 #endif /* __SND_AOA_ALSA_H */
--- linux-2.6.18.noarch/sound/aoa/fabrics/snd-aoa-fabric-layout.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/fabrics/snd-aoa-fabric-layout.c	2007-06-05 17:39:33.000000000 -0400
@@ -1014,7 +1014,7 @@
 
 	ldev->gpio.methods->init(&ldev->gpio);
 
-	err = aoa_fabric_register(&layout_fabric);
+	err = aoa_fabric_register(&layout_fabric, &sdev->ofdev.dev);
 	if (err && err != -EALREADY) {
 		printk(KERN_INFO "snd-aoa-fabric-layout: can't use,"
 				 " another fabric is active!\n");
@@ -1034,9 +1034,9 @@
 	list_del(&ldev->list);
 	layouts_list_items--;
  outnodev:
- 	if (sound) of_node_put(sound);
+ 	of_node_put(sound);
  	layout_device = NULL;
- 	if (ldev) kfree(ldev);
+ 	kfree(ldev);
 	return -ENODEV;
 }
 
@@ -1077,8 +1077,6 @@
 {
 	struct layout_dev *ldev = sdev->ofdev.dev.driver_data;
 
-	printk("aoa_fabric_layout_suspend()\n");
-
 	if (ldev->gpio.methods && ldev->gpio.methods->all_amps_off)
 		ldev->gpio.methods->all_amps_off(&ldev->gpio);
 
@@ -1089,8 +1087,6 @@
 {
 	struct layout_dev *ldev = sdev->ofdev.dev.driver_data;
 
-	printk("aoa_fabric_layout_resume()\n");
-
 	if (ldev->gpio.methods && ldev->gpio.methods->all_amps_off)
 		ldev->gpio.methods->all_amps_restore(&ldev->gpio);
 
@@ -1107,6 +1103,9 @@
 	.suspend = aoa_fabric_layout_suspend,
 	.resume = aoa_fabric_layout_resume,
 #endif
+	.driver = {
+		.owner = THIS_MODULE,
+	}
 };
 
 static int __init aoa_fabric_layout_init(void)
--- linux-2.6.18.noarch/sound/aoa/aoa-gpio.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/aoa-gpio.h	2007-06-05 17:39:10.000000000 -0400
@@ -59,10 +59,10 @@
 };
 
 struct gpio_notification {
+	struct delayed_work work;
 	notify_func_t notify;
 	void *data;
 	void *gpio_private;
-	struct work_struct work;
 	struct mutex mutex;
 };
 
--- linux-2.6.18.noarch/sound/aoa/Kconfig.orig	2007-06-05 16:07:52.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/Kconfig	2007-06-05 17:39:10.000000000 -0400
@@ -1,5 +1,5 @@
 menu "Apple Onboard Audio driver"
-	depends on SND!=n && PPC
+	depends on SND!=n && PPC_PMAC
 
 config SND_AOA
 	tristate "Apple Onboard Audio driver"
--- linux-2.6.18.noarch/sound/aoa/codecs/snd-aoa-codec-onyx.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/codecs/snd-aoa-codec-onyx.c	2007-06-05 17:39:21.000000000 -0400
@@ -825,7 +825,16 @@
 	int err = -ENXIO;
 
 	mutex_lock(&onyx->mutex);
-	/* take codec out of suspend */
+
+	/* reset codec */
+	onyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);
+	msleep(1);
+	onyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 1);
+	msleep(1);
+	onyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);
+	msleep(1);
+
+	/* take codec out of suspend (if it still is after reset) */
 	if (onyx_read_register(onyx, ONYX_REG_CONTROL, &v))
 		goto out_unlock;
 	onyx_write_register(onyx, ONYX_REG_CONTROL, v & ~(ONYX_ADPSV | ONYX_DAPSV));
--- linux-2.6.18.noarch/sound/aoa/codecs/snd-aoa-codec-onyx.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/codecs/snd-aoa-codec-onyx.h	2007-06-05 17:39:21.000000000 -0400
@@ -9,7 +9,6 @@
 #define __SND_AOA_CODEC_ONYX_H
 #include <stddef.h>
 #include <linux/i2c.h>
-#include <linux/i2c-dev.h>
 #include <asm/pmac_low_i2c.h>
 #include <asm/prom.h>
 
--- linux-2.6.18.noarch/sound/aoa/codecs/Kconfig.orig	2007-06-05 16:07:52.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/codecs/Kconfig	2007-06-05 17:39:21.000000000 -0400
@@ -1,6 +1,8 @@
 config SND_AOA_ONYX
 	tristate "support Onyx chip"
 	depends on SND_AOA
+	select I2C
+	select I2C_POWERMAC
 	---help---
 	This option enables support for the Onyx (pcm3052)
 	codec chip found in the latest Apple machines
@@ -18,6 +20,8 @@
 config SND_AOA_TAS
 	tristate "support TAS chips"
 	depends on SND_AOA
+	select I2C
+	select I2C_POWERMAC
 	---help---
 	This option enables support for the tas chips
 	found in a lot of Apple Machines, especially
--- linux-2.6.18.noarch/sound/aoa/codecs/snd-aoa-codec-tas.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/codecs/snd-aoa-codec-tas.c	2007-06-05 17:39:21.000000000 -0400
@@ -61,11 +61,12 @@
  */
 #include <stddef.h>
 #include <linux/i2c.h>
-#include <linux/i2c-dev.h>
 #include <asm/pmac_low_i2c.h>
 #include <asm/prom.h>
 #include <linux/delay.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
+
 MODULE_AUTHOR("Johannes Berg <johannes@sipsolutions.net>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("tas codec driver for snd-aoa");
@@ -91,6 +92,10 @@
 	u8			bass, treble;
 	u8			acr;
 	int			drc_range;
+	/* protects hardware access against concurrency from
+	 * userspace when hitting controls and during
+	 * codec init/suspend/resume */
+	struct mutex		mtx;
 };
 
 static int tas_reset_init(struct tas *tas);
@@ -231,8 +236,10 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = tas->cached_volume_l;
 	ucontrol->value.integer.value[1] = tas->cached_volume_r;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -241,14 +248,18 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	if (tas->cached_volume_l == ucontrol->value.integer.value[0]
-	 && tas->cached_volume_r == ucontrol->value.integer.value[1])
+	 && tas->cached_volume_r == ucontrol->value.integer.value[1]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->cached_volume_l = ucontrol->value.integer.value[0];
 	tas->cached_volume_r = ucontrol->value.integer.value[1];
 	if (tas->hw_enabled)
 		tas_set_volume(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -276,8 +287,10 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = !tas->mute_l;
 	ucontrol->value.integer.value[1] = !tas->mute_r;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -286,14 +299,18 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	if (tas->mute_l == !ucontrol->value.integer.value[0]
-	 && tas->mute_r == !ucontrol->value.integer.value[1])
+	 && tas->mute_r == !ucontrol->value.integer.value[1]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->mute_l = !ucontrol->value.integer.value[0];
 	tas->mute_r = !ucontrol->value.integer.value[1];
 	if (tas->hw_enabled)
 		tas_set_volume(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -322,8 +339,10 @@
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 	int idx = kcontrol->private_value;
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = tas->mixer_l[idx];
 	ucontrol->value.integer.value[1] = tas->mixer_r[idx];
+	mutex_unlock(&tas->mtx);
 
 	return 0;
 }
@@ -334,15 +353,19 @@
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 	int idx = kcontrol->private_value;
 
+	mutex_lock(&tas->mtx);
 	if (tas->mixer_l[idx] == ucontrol->value.integer.value[0]
-	 && tas->mixer_r[idx] == ucontrol->value.integer.value[1])
+	 && tas->mixer_r[idx] == ucontrol->value.integer.value[1]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->mixer_l[idx] = ucontrol->value.integer.value[0];
 	tas->mixer_r[idx] = ucontrol->value.integer.value[1];
 
 	if (tas->hw_enabled)
 		tas_set_mixer(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -375,7 +398,9 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = tas->drc_range;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -384,12 +409,16 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
-	if (tas->drc_range == ucontrol->value.integer.value[0])
+	mutex_lock(&tas->mtx);
+	if (tas->drc_range == ucontrol->value.integer.value[0]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->drc_range = ucontrol->value.integer.value[0];
 	if (tas->hw_enabled)
 		tas3004_set_drc(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -417,7 +446,9 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = tas->drc_enabled;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -426,12 +457,16 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
-	if (tas->drc_enabled == ucontrol->value.integer.value[0])
+	mutex_lock(&tas->mtx);
+	if (tas->drc_enabled == ucontrol->value.integer.value[0]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->drc_enabled = ucontrol->value.integer.value[0];
 	if (tas->hw_enabled)
 		tas3004_set_drc(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -463,7 +498,9 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.enumerated.item[0] = !!(tas->acr & TAS_ACR_INPUT_B);
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -471,15 +508,27 @@
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
-	int oldacr = tas->acr;
+	int oldacr;
+
+	mutex_lock(&tas->mtx);
+	oldacr = tas->acr;
 
-	tas->acr &= ~TAS_ACR_INPUT_B;
+	/*
+	 * Despite what the data sheet says in one place, the
+	 * TAS_ACR_B_MONAUREAL bit forces mono output even when
+	 * input A (line in) is selected.
+	 */
+	tas->acr &= ~(TAS_ACR_INPUT_B | TAS_ACR_B_MONAUREAL);
 	if (ucontrol->value.enumerated.item[0])
-		tas->acr |= TAS_ACR_INPUT_B;
-	if (oldacr == tas->acr)
+		tas->acr |= TAS_ACR_INPUT_B | TAS_ACR_B_MONAUREAL |
+		      TAS_ACR_B_MON_SEL_RIGHT;
+	if (oldacr == tas->acr) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 	if (tas->hw_enabled)
 		tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -518,7 +567,9 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = tas->treble;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -527,12 +578,16 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
-	if (tas->treble == ucontrol->value.integer.value[0])
+	mutex_lock(&tas->mtx);
+	if (tas->treble == ucontrol->value.integer.value[0]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->treble = ucontrol->value.integer.value[0];
 	if (tas->hw_enabled)
 		tas_set_treble(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -560,7 +615,9 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
+	mutex_lock(&tas->mtx);
 	ucontrol->value.integer.value[0] = tas->bass;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -569,12 +626,16 @@
 {
 	struct tas *tas = snd_kcontrol_chip(kcontrol);
 
-	if (tas->bass == ucontrol->value.integer.value[0])
+	mutex_lock(&tas->mtx);
+	if (tas->bass == ucontrol->value.integer.value[0]) {
+		mutex_unlock(&tas->mtx);
 		return 0;
+	}
 
 	tas->bass = ucontrol->value.integer.value[0];
 	if (tas->hw_enabled)
 		tas_set_bass(tas);
+	mutex_unlock(&tas->mtx);
 	return 1;
 }
 
@@ -628,16 +689,15 @@
 
 	tmp = TAS_MCS_SCLK64 | TAS_MCS_SPORT_MODE_I2S | TAS_MCS_SPORT_WL_24BIT;
 	if (tas_write_reg(tas, TAS_REG_MCS, 1, &tmp))
-		return -ENODEV;
+		goto outerr;
 
-	tas->acr |= TAS_ACR_ANALOG_PDOWN | TAS_ACR_B_MONAUREAL |
-		TAS_ACR_B_MON_SEL_RIGHT;
+	tas->acr |= TAS_ACR_ANALOG_PDOWN;
 	if (tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr))
-		return -ENODEV;
+		goto outerr;
 
 	tmp = 0;
 	if (tas_write_reg(tas, TAS_REG_MCS2, 1, &tmp))
-		return -ENODEV;
+		goto outerr;
 
 	tas3004_set_drc(tas);
 
@@ -649,9 +709,11 @@
 
 	tas->acr &= ~TAS_ACR_ANALOG_PDOWN;
 	if (tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr))
-		return -ENODEV;
+		goto outerr;
 
 	return 0;
+ outerr:
+	return -ENODEV;
 }
 
 static int tas_switch_clock(struct codec_info_item *cii, enum clock_switch clock)
@@ -666,11 +728,13 @@
 		break;
 	case CLOCK_SWITCH_SLAVE:
 		/* Clocks are back, re-init the codec */
+		mutex_lock(&tas->mtx);
 		tas_reset_init(tas);
 		tas_set_volume(tas);
 		tas_set_mixer(tas);
 		tas->hw_enabled = 1;
 		tas->codec.gpio->methods->all_amps_restore(tas->codec.gpio);
+		mutex_unlock(&tas->mtx);
 		break;
 	default:
 		/* doesn't happen as of now */
@@ -684,19 +748,23 @@
  * our i2c device is suspended, and then take note of that! */
 static int tas_suspend(struct tas *tas)
 {
+	mutex_lock(&tas->mtx);
 	tas->hw_enabled = 0;
 	tas->acr |= TAS_ACR_ANALOG_PDOWN;
 	tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr);
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
 static int tas_resume(struct tas *tas)
 {
 	/* reset codec */
+	mutex_lock(&tas->mtx);
 	tas_reset_init(tas);
 	tas_set_volume(tas);
 	tas_set_mixer(tas);
 	tas->hw_enabled = 1;
+	mutex_unlock(&tas->mtx);
 	return 0;
 }
 
@@ -739,11 +807,14 @@
 		return -EINVAL;
 	}
 
+	mutex_lock(&tas->mtx);
 	if (tas_reset_init(tas)) {
 		printk(KERN_ERR PFX "tas failed to initialise\n");
+		mutex_unlock(&tas->mtx);
 		return -ENXIO;
 	}
 	tas->hw_enabled = 1;
+	mutex_unlock(&tas->mtx);
 
 	if (tas->codec.soundbus_dev->attach_codec(tas->codec.soundbus_dev,
 						   aoa_get_card(),
@@ -822,6 +893,7 @@
 	if (!tas)
 		return -ENOMEM;
 
+	mutex_init(&tas->mtx);
 	tas->i2c.driver = &tas_driver;
 	tas->i2c.adapter = adapter;
 	tas->i2c.addr = addr;
@@ -850,6 +922,7 @@
  detach:
 	i2c_detach_client(&tas->i2c);
  fail:
+	mutex_destroy(&tas->mtx);
 	kfree(tas);
 	return -EINVAL;
 }
@@ -908,6 +981,7 @@
 	/* power down codec chip */
 	tas_write_reg(tas, TAS_REG_ACR, 1, &tmp);
 
+	mutex_destroy(&tas->mtx);
 	kfree(tas);
 	return 0;
 }
--- linux-2.6.18.noarch/sound/soc/soc-core.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/soc-core.c	2007-06-05 19:53:36.000000000 -0400
@@ -0,0 +1,1587 @@
+/*
+ * soc-core.c  --  ALSA SoC Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *         with code, comments and ideas from :-
+ *         Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Working Codec, Interface and Platform registration.
+ *
+ *  TODO:
+ *   o Add hw rules to enforce rates, etc.
+ *   o More testing with other codecs/machines.
+ *   o Add more codecs and platforms to ensure good API coverage.
+ *   o Support TDM on PCM and I2S
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define SOC_DEBUG 0
+#if SOC_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+static DEFINE_MUTEX(pcm_mutex);
+static DEFINE_MUTEX(io_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
+
+/*
+ * This is a timeout to do a DAPM powerdown after a stream is closed().
+ * It can be used to eliminate pops between different playback streams, e.g.
+ * between two audio tracks.
+ */
+static int pmdown_time = 5000;
+module_param(pmdown_time, int, 0);
+MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
+
+/*
+ * This function forces any delayed work to be queued and run.
+ */
+static int run_delayed_work(struct delayed_work *dwork)
+{
+	int ret;
+
+	/* cancel any work waiting to be queued. */
+	ret = cancel_delayed_work(dwork);
+
+	/* if there was any work waiting then we run it now and
+	 * wait for it's completion */
+	if (ret) {
+		schedule_delayed_work(dwork, 0);
+		flush_scheduled_work();
+	}
+	return ret;
+}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_unregister(&codec->ac97->dev);
+	return 0;
+}
+
+/* stop no dev release warning */
+static void soc_ac97_device_release(struct device *dev){}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = NULL;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	snprintf(codec->ac97->dev.bus_id, BUS_ID_SIZE, "%d-%d:%s",
+		 codec->card->number, 0, codec->name);
+	err = device_register(&codec->ac97->dev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+#endif
+
+static inline const char* get_dai_name(int type)
+{
+	switch(type) {
+	case SND_SOC_DAI_AC97:
+		return "AC97";
+	case SND_SOC_DAI_I2S:
+		return "I2S";
+	case SND_SOC_DAI_PCM:
+		return "PCM";
+	}
+	return NULL;
+}
+
+/*
+ * Called by ALSA when a PCM substream is opened, the runtime->hw record is
+ * then initialized and any private data can be allocated. This also calls
+ * startup for the cpu DAI, platform, machine and codec DAI.
+ */
+static int soc_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	/* startup the audio subsystem */
+	if (cpu_dai->ops.startup) {
+		ret = cpu_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open interface %s\n",
+				cpu_dai->name);
+			goto out;
+		}
+	}
+
+	if (platform->pcm_ops->open) {
+		ret = platform->pcm_ops->open(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
+			goto platform_err;
+		}
+	}
+
+	if (codec_dai->ops.startup) {
+		ret = codec_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open codec %s\n",
+				codec_dai->name);
+			goto codec_dai_err;
+		}
+	}
+
+	if (machine->ops && machine->ops->startup) {
+		ret = machine->ops->startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
+			goto machine_err;
+		}
+	}
+
+	/* Check that the codec and cpu DAI's are compatible */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		runtime->hw.rate_min =
+			max(codec_dai->playback.rate_min, cpu_dai->playback.rate_min);
+		runtime->hw.rate_max =
+			min(codec_dai->playback.rate_max, cpu_dai->playback.rate_max);
+		runtime->hw.channels_min =
+			max(codec_dai->playback.channels_min,
+				cpu_dai->playback.channels_min);
+		runtime->hw.channels_max =
+			min(codec_dai->playback.channels_max,
+				cpu_dai->playback.channels_max);
+		runtime->hw.formats =
+			codec_dai->playback.formats & cpu_dai->playback.formats;
+		runtime->hw.rates =
+			codec_dai->playback.rates & cpu_dai->playback.rates;
+	} else {
+		runtime->hw.rate_min =
+			max(codec_dai->capture.rate_min, cpu_dai->capture.rate_min);
+		runtime->hw.rate_max =
+			min(codec_dai->capture.rate_max, cpu_dai->capture.rate_max);
+		runtime->hw.channels_min =
+			max(codec_dai->capture.channels_min,
+				cpu_dai->capture.channels_min);
+		runtime->hw.channels_max =
+			min(codec_dai->capture.channels_max,
+				cpu_dai->capture.channels_max);
+		runtime->hw.formats =
+			codec_dai->capture.formats & cpu_dai->capture.formats;
+		runtime->hw.rates =
+			codec_dai->capture.rates & cpu_dai->capture.rates;
+	}
+
+	snd_pcm_limit_hw_rates(runtime);
+	if (!runtime->hw.rates) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
+	}
+	if (!runtime->hw.formats) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
+	}
+	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
+	}
+
+	dbg("asoc: %s <-> %s info:\n",codec_dai->name, cpu_dai->name);
+	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
+	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
+		runtime->hw.channels_max);
+	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
+		runtime->hw.rate_max);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->playback.active = codec_dai->playback.active = 1;
+	else
+		cpu_dai->capture.active = codec_dai->capture.active = 1;
+	cpu_dai->active = codec_dai->active = 1;
+	cpu_dai->runtime = runtime;
+	socdev->codec->active++;
+	mutex_unlock(&pcm_mutex);
+	return 0;
+
+machine_err:
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+codec_dai_err:
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+
+platform_err:
+	if (cpu_dai->ops.shutdown)
+		cpu_dai->ops.shutdown(substream);
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Power down the audio subsytem pmdown_time msecs after close is called.
+ * This is to ensure there are no pops or clicks in between any music tracks
+ * due to DAPM power cycling.
+ */
+static void close_delayed_work(struct work_struct *work)
+{
+	struct snd_soc_device *socdev =
+		container_of(work, struct snd_soc_device, delayed_work.work);
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai;
+	int i;
+
+	mutex_lock(&pcm_mutex);
+	for(i = 0; i < codec->num_dai; i++) {
+		codec_dai = &codec->dai[i];
+
+		dbg("pop wq checking: %s status: %s waiting: %s\n",
+			codec_dai->playback.stream_name,
+			codec_dai->playback.active ? "active" : "inactive",
+			codec_dai->pop_wait ? "yes" : "no");
+
+		/* are we waiting on this codec DAI stream */
+		if (codec_dai->pop_wait == 1) {
+
+			codec_dai->pop_wait = 0;
+			snd_soc_dapm_stream_event(codec, codec_dai->playback.stream_name,
+				SND_SOC_DAPM_STREAM_STOP);
+
+			/* power down the codec power domain if no longer active */
+			if (codec->active == 0) {
+				dbg("pop wq D3 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
+		 		if (codec->dapm_event)
+					codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+			}
+		}
+	}
+	mutex_unlock(&pcm_mutex);
+}
+
+/*
+ * Called by ALSA when a PCM substream is closed. Private data can be
+ * freed here. The cpu DAI, codec DAI, machine and platform are also
+ * shutdown.
+ */
+static int soc_codec_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&pcm_mutex);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->playback.active = codec_dai->playback.active = 0;
+	else
+		cpu_dai->capture.active = codec_dai->capture.active = 0;
+
+	if (codec_dai->playback.active == 0 &&
+		codec_dai->capture.active == 0) {
+		cpu_dai->active = codec_dai->active = 0;
+	}
+	codec->active--;
+
+	if (cpu_dai->ops.shutdown)
+		cpu_dai->ops.shutdown(substream);
+
+	if (codec_dai->ops.shutdown)
+		codec_dai->ops.shutdown(substream);
+
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+	cpu_dai->runtime = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* start delayed pop wq here for playback streams */
+		codec_dai->pop_wait = 1;
+		schedule_delayed_work(&socdev->delayed_work,
+			msecs_to_jiffies(pmdown_time));
+	} else {
+		/* capture streams can be powered down now */
+		snd_soc_dapm_stream_event(codec,
+			codec_dai->capture.stream_name, SND_SOC_DAPM_STREAM_STOP);
+
+		if (codec->active == 0 && codec_dai->pop_wait == 0){
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+		}
+	}
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+/*
+ * Called by ALSA when the PCM substream is prepared, can set format, sample
+ * rate, etc.  This function is non atomic and can be called multiple times,
+ * it can refer to the runtime info.
+ */
+static int soc_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	if (machine->ops && machine->ops->prepare) {
+		ret = machine->ops->prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine prepare error\n");
+			goto out;
+		}
+	}
+
+	if (platform->pcm_ops->prepare) {
+		ret = platform->pcm_ops->prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: platform prepare error\n");
+			goto out;
+		}
+	}
+
+	if (codec_dai->ops.prepare) {
+		ret = codec_dai->ops.prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: codec DAI prepare error\n");
+			goto out;
+		}
+	}
+
+	if (cpu_dai->ops.prepare) {
+		ret = cpu_dai->ops.prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
+			goto out;
+		}
+	}
+
+	/* we only want to start a DAPM playback stream if we are not waiting
+	 * on an existing one stopping */
+	if (codec_dai->pop_wait) {
+		/* we are waiting for the delayed work to start */
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				snd_soc_dapm_stream_event(socdev->codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+		else {
+			codec_dai->pop_wait = 0;
+			cancel_delayed_work(&socdev->delayed_work);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+		}
+	} else {
+		/* no delayed work - do we need to power up codec */
+		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D1);
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D0);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+
+		} else {
+			/* codec already powered - power on widgets */
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Called by ALSA when the hardware params are set by application. This
+ * function can also be called multiple times and can allocate buffers
+ * (using snd_pcm_lib_* ). It's non-atomic.
+ */
+static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	if (machine->ops && machine->ops->hw_params) {
+		ret = machine->ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine hw_params failed\n");
+			goto out;
+		}
+	}
+
+	if (codec_dai->ops.hw_params) {
+		ret = codec_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
+				codec_dai->name);
+			goto codec_err;
+		}
+	}
+
+	if (cpu_dai->ops.hw_params) {
+		ret = cpu_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set interface %s hw params\n",
+				cpu_dai->name);
+			goto interface_err;
+		}
+	}
+
+	if (platform->pcm_ops->hw_params) {
+		ret = platform->pcm_ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set platform %s hw params\n",
+				platform->name);
+			goto platform_err;
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+
+platform_err:
+	if (cpu_dai->ops.hw_free)
+		cpu_dai->ops.hw_free(substream);
+
+interface_err:
+	if (codec_dai->ops.hw_free)
+		codec_dai->ops.hw_free(substream);
+
+codec_err:
+	if(machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Free's resources allocated by hw_params, can be called multiple times
+ */
+static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&pcm_mutex);
+
+	/* apply codec digital mute */
+	if (!codec->active && codec_dai->dai_ops.digital_mute)
+		codec_dai->dai_ops.digital_mute(codec_dai, 1);
+
+	/* free any machine hw params */
+	if (machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
+
+	/* free any DMA resources */
+	if (platform->pcm_ops->hw_free)
+		platform->pcm_ops->hw_free(substream);
+
+	/* now free hw params for the DAI's  */
+	if (codec_dai->ops.hw_free)
+		codec_dai->ops.hw_free(substream);
+
+	if (cpu_dai->ops.hw_free)
+		cpu_dai->ops.hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	int ret;
+
+	if (codec_dai->ops.trigger) {
+		ret = codec_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (platform->pcm_ops->trigger) {
+		ret = platform->pcm_ops->trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->ops.trigger) {
+		ret = cpu_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+/* ASoC PCM operations */
+static struct snd_pcm_ops soc_pcm_ops = {
+	.open		= soc_pcm_open,
+	.close		= soc_codec_close,
+	.hw_params	= soc_pcm_hw_params,
+	.hw_free	= soc_pcm_hw_free,
+	.prepare	= soc_pcm_prepare,
+	.trigger	= soc_pcm_trigger,
+};
+
+#ifdef CONFIG_PM
+/* powers down audio subsystem for suspend */
+static int soc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	/* mute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 1);
+	}
+
+	if (machine->suspend_pre)
+		machine->suspend_pre(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+		if (platform->suspend)
+			platform->suspend(pdev, cpu_dai);
+	}
+
+	/* close any waiting streams and save state */
+	run_delayed_work(&socdev->delayed_work);
+	codec->suspend_dapm_state = codec->dapm_state;
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char *stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+	}
+
+	if (codec_dev->suspend)
+		codec_dev->suspend(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+	}
+
+	if (machine->suspend_post)
+		machine->suspend_post(pdev, state);
+
+	return 0;
+}
+
+/* powers up audio subsystem after a suspend */
+static int soc_resume(struct platform_device *pdev)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	if (machine->resume_pre)
+		machine->resume_pre(pdev);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+	}
+
+	if (codec_dev->resume)
+		codec_dev->resume(pdev);
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char* stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+	}
+
+	/* unmute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 0);
+	}
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+		if (platform->resume)
+			platform->resume(pdev, cpu_dai);
+	}
+
+	if (machine->resume_post)
+		machine->resume_post(pdev);
+
+	return 0;
+}
+
+#else
+#define soc_suspend	NULL
+#define soc_resume	NULL
+#endif
+
+/* probes a new socdev */
+static int soc_probe(struct platform_device *pdev)
+{
+	int ret = 0, i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (machine->probe) {
+		ret = machine->probe(pdev);
+		if(ret < 0)
+			return ret;
+	}
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->probe) {
+			ret = cpu_dai->probe(pdev);
+			if(ret < 0)
+				goto cpu_dai_err;
+		}
+	}
+
+	if (codec_dev->probe) {
+		ret = codec_dev->probe(pdev);
+		if(ret < 0)
+			goto cpu_dai_err;
+	}
+
+	if (platform->probe) {
+		ret = platform->probe(pdev);
+		if(ret < 0)
+			goto platform_err;
+	}
+
+	/* DAPM stream work */
+	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
+	return 0;
+
+platform_err:
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+cpu_dai_err:
+	for (i--; i >= 0; i--) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return ret;
+}
+
+/* removes a socdev */
+static int soc_remove(struct platform_device *pdev)
+{
+	int i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	run_delayed_work(&socdev->delayed_work);
+
+	if (platform->remove)
+		platform->remove(pdev);
+
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return 0;
+}
+
+/* ASoC platform driver */
+static struct platform_driver soc_driver = {
+	.driver		= {
+		.name		= "soc-audio",
+	},
+	.probe		= soc_probe,
+	.remove		= soc_remove,
+	.suspend	= soc_suspend,
+	.resume		= soc_resume,
+};
+
+/* create a new pcm */
+static int soc_new_pcm(struct snd_soc_device *socdev,
+	struct snd_soc_dai_link *dai_link, int num)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai = dai_link->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = dai_link->cpu_dai;
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_pcm *pcm;
+	char new_name[64];
+	int ret = 0, playback = 0, capture = 0;
+
+	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
+	if (rtd == NULL)
+		return -ENOMEM;
+
+	rtd->dai = dai_link;
+	rtd->socdev = socdev;
+	codec_dai->codec = socdev->codec;
+
+	/* check client and interface hw capabilities */
+	sprintf(new_name, "%s %s-%s-%d",dai_link->stream_name, codec_dai->name,
+		get_dai_name(cpu_dai->type), num);
+
+	if (codec_dai->playback.channels_min)
+		playback = 1;
+	if (codec_dai->capture.channels_min)
+		capture = 1;
+
+	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
+		capture, &pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_data = rtd;
+	soc_pcm_ops.mmap = socdev->platform->pcm_ops->mmap;
+	soc_pcm_ops.pointer = socdev->platform->pcm_ops->pointer;
+	soc_pcm_ops.ioctl = socdev->platform->pcm_ops->ioctl;
+	soc_pcm_ops.copy = socdev->platform->pcm_ops->copy;
+	soc_pcm_ops.silence = socdev->platform->pcm_ops->silence;
+	soc_pcm_ops.ack = socdev->platform->pcm_ops->ack;
+	soc_pcm_ops.page = socdev->platform->pcm_ops->page;
+
+	if (playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
+
+	if (capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
+
+	ret = socdev->platform->pcm_new(codec->card, codec_dai, pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_free = socdev->platform->pcm_free;
+	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
+		cpu_dai->name);
+	return ret;
+}
+
+/* codec register dump */
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	int i, step = 1, count = 0;
+
+	if (!codec->reg_cache_size)
+		return 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	count += sprintf(buf, "%s registers\n", codec->name);
+	for(i = 0; i < codec->reg_cache_size; i += step)
+		count += sprintf(buf + count, "%2x: %4x\n", i, codec->read(codec, i));
+
+	return count;
+}
+static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
+
+/**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
+{
+	mutex_lock(&codec->mutex);
+
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL) {
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&codec->mutex);
+	kfree(codec->ac97->bus);
+	kfree(codec->ac97);
+	codec->ac97 = NULL;
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+/**
+ * snd_soc_update_bits - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	if (change)
+		snd_soc_write(codec, reg, new);
+
+	mutex_unlock(&io_mutex);
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_update_bits);
+
+/**
+ * snd_soc_test_bits - test register for change
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Tests a register with a new value and checks if the new value is
+ * different from the old value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	mutex_unlock(&io_mutex);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_test_bits);
+
+/**
+ * snd_soc_new_pcms - create new sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Create a new sound card based upon the codec and interface pcms.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i;
+
+	mutex_lock(&codec->mutex);
+
+	/* register a sound card */
+	codec->card = snd_card_new(idx, xid, codec->owner, 0);
+	if (!codec->card) {
+		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
+			codec->name);
+		mutex_unlock(&codec->mutex);
+		return -ENODEV;
+	}
+
+	codec->card->dev = socdev->dev;
+	codec->card->private_data = codec;
+	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
+
+	/* create the pcms */
+	for(i = 0; i < machine->num_links; i++) {
+		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't create pcm %s\n",
+				machine->dai_link[i].stream_name);
+			mutex_unlock(&codec->mutex);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
+
+/**
+ * snd_soc_register_card - register sound card
+ * @socdev: the SoC audio device
+ *
+ * Register a SoC sound card. Also registers an AC97 device if the
+ * codec is AC97 for ad hoc devices.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_register_card(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i, ac97 = 0, err = 0;
+
+	mutex_lock(&codec->mutex);
+	for(i = 0; i < machine->num_links; i++) {
+		if (socdev->machine->dai_link[i].init) {
+			err = socdev->machine->dai_link[i].init(codec);
+			if (err < 0) {
+				printk(KERN_ERR "asoc: failed to init %s\n",
+					socdev->machine->dai_link[i].stream_name);
+				continue;
+			}
+		}
+		if (socdev->machine->dai_link[i].cpu_dai->type == SND_SOC_DAI_AC97)
+			ac97 = 1;
+	}
+	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
+		 "%s", machine->name);
+	snprintf(codec->card->longname, sizeof(codec->card->longname),
+		 "%s (%s)", machine->name, codec->name);
+
+	ret = snd_card_register(codec->card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to register soundcard for codec %s\n",
+				codec->name);
+		goto out;
+	}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (ac97) {
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: AC97 device register failed\n");
+			snd_card_free(codec->card);
+			goto out;
+		}
+	}
+#endif
+
+	err = snd_soc_dapm_sys_add(socdev->dev);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
+
+	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add codec sysfs entries\n");
+out:
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_card);
+
+/**
+ * snd_soc_free_pcms - free sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Frees sound card and pcms associated with the socdev.
+ * Also unregister the codec if it is an AC97 device.
+ */
+void snd_soc_free_pcms(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (codec->ac97)
+		soc_ac97_dev_unregister(codec);
+#endif
+
+	if (codec->card)
+		snd_card_free(codec->card);
+	device_remove_file(socdev->dev, &dev_attr_codec_reg);
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_pcms);
+
+/**
+ * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
+ * @substream: the pcm substream
+ * @hw: the hardware parameters
+ *
+ * Sets the substream runtime hardware parameters.
+ */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	runtime->hw.info = hw->info;
+	runtime->hw.formats = hw->formats;
+	runtime->hw.period_bytes_min = hw->period_bytes_min;
+	runtime->hw.period_bytes_max = hw->period_bytes_max;
+	runtime->hw.periods_min = hw->periods_min;
+	runtime->hw.periods_max = hw->periods_max;
+	runtime->hw.buffer_bytes_max = hw->buffer_bytes_max;
+	runtime->hw.fifo_size = hw->fifo_size;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
+
+/**
+ * snd_soc_cnew - create new control
+ * @_template: control template
+ * @data: control private data
+ * @lnng_name: control long name
+ *
+ * Create a new mixer control from a template control.
+ *
+ * Returns 0 for success, else error.
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name)
+{
+	struct snd_kcontrol_new template;
+
+	memcpy(&template, _template, sizeof(template));
+	if (long_name)
+		template.name = long_name;
+	template.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+	template.index = 0;
+
+	return snd_ctl_new1(&template, data);
+}
+EXPORT_SYMBOL_GPL(snd_soc_cnew);
+
+/**
+ * snd_soc_info_enum_double - enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double enumerated
+ * mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
+
+/**
+ * snd_soc_get_enum_double - enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
+
+/**
+ * snd_soc_put_enum_double - enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val;
+	unsigned short mask, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	val = ucontrol->value.enumerated.item[0] << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	return snd_soc_update_bits(codec, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
+
+/**
+ * snd_soc_info_enum_ext - external enumerated single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about an external enumerated
+ * single mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
+
+/**
+ * snd_soc_info_volsw_ext - external single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = kcontrol->private_value;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
+
+/**
+ * snd_soc_info_bool_ext - external single boolean mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single boolean external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_bool_ext);
+
+/**
+ * snd_soc_info_volsw - single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = shift == rshift ? 1 : 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
+
+/**
+ * snd_soc_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
+
+/**
+ * snd_soc_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+	err = snd_soc_update_bits(codec, reg, val_mask, val);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
+
+/**
+ * snd_soc_info_volsw_2r - double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double mixer control that
+ * spans 2 codec registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
+
+/**
+ * snd_soc_get_volsw_2r - double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	ucontrol->value.integer.value[1] =
+		(snd_soc_read(codec, reg2) >> shift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] =
+			mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
+
+/**
+ * snd_soc_put_volsw_2r - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] & mask);
+	val2 = (ucontrol->value.integer.value[1] & mask);
+
+	if (invert) {
+		val = mask - val;
+		val2 = mask - val2;
+	}
+
+	val = val << shift;
+	val2 = val2 << shift;
+
+	if ((err = snd_soc_update_bits(codec, reg, val_mask, val)) < 0)
+		return err;
+
+	err = snd_soc_update_bits(codec, reg2, val_mask, val2);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
+
+static int __devinit snd_soc_init(void)
+{
+	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);
+	return platform_driver_register(&soc_driver);
+}
+
+static void snd_soc_exit(void)
+{
+ 	platform_driver_unregister(&soc_driver);
+}
+
+module_init(snd_soc_init);
+module_exit(snd_soc_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC Core");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/Makefile.orig	2007-06-05 17:29:10.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/Makefile	2007-06-05 19:53:36.000000000 -0400
@@ -0,0 +1,4 @@
+snd-soc-core-objs := soc-core.o soc-dapm.o
+
+obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
+obj-$(CONFIG_SND_SOC)	+= codecs/ at91/ pxa/
--- linux-2.6.18.noarch/sound/soc/soc-dapm.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/soc-dapm.c	2007-06-05 19:53:36.000000000 -0400
@@ -0,0 +1,1323 @@
+/*
+ * soc-dapm.c  --  ALSA SoC Dynamic Audio Power Management
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Implemented path power domain.
+ *    18th Dec 2005   Implemented machine and stream level power domain.
+ *
+ *  Features:
+ *    o Changes power status of internal codec blocks depending on the
+ *      dynamic configuration of codec internal audio paths and active
+ *      DAC's/ADC's.
+ *    o Platform power domain - can support external components i.e. amps and
+ *      mic/meadphone insertion events.
+ *    o Automatic Mic Bias support
+ *    o Jack insertion power event initiation - e.g. hp insertion will enable
+ *      sinks, dacs, etc
+ *    o Delayed powerdown of audio susbsytem to reduce pops between a quick
+ *      device reopen.
+ *
+ *  Todo:
+ *    o DAPM power change sequencing - allow for configurable per
+ *      codec sequences.
+ *    o Support for analogue bias optimisation.
+ *    o Support for reduced codec oversampling rates.
+ *    o Support for reduced codec bias currents.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/jiffies.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define DAPM_DEBUG 0
+#if DAPM_DEBUG
+#define dump_dapm(codec, action) dbg_dump_dapm(codec, action)
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dump_dapm(codec, action)
+#define dbg(format, arg...)
+#endif
+
+#define POP_DEBUG 0
+#if POP_DEBUG
+#define POP_TIME 500 /* 500 msecs - change if pop debug is too fast */
+#define pop_wait(time) schedule_timeout_interruptible(msecs_to_jiffies(time))
+#define pop_dbg(format, arg...) printk(format, ## arg); pop_wait(POP_TIME)
+#else
+#define pop_dbg(format, arg...)
+#define pop_wait(time)
+#endif
+
+/* dapm power sequences - make this per codec in the future */
+static int dapm_up_seq[] = {
+	snd_soc_dapm_pre, snd_soc_dapm_micbias, snd_soc_dapm_mic,
+	snd_soc_dapm_mux, snd_soc_dapm_dac, snd_soc_dapm_mixer, snd_soc_dapm_pga,
+	snd_soc_dapm_adc, snd_soc_dapm_hp, snd_soc_dapm_spk, snd_soc_dapm_post
+};
+static int dapm_down_seq[] = {
+	snd_soc_dapm_pre, snd_soc_dapm_adc, snd_soc_dapm_hp, snd_soc_dapm_spk,
+	snd_soc_dapm_pga, snd_soc_dapm_mixer, snd_soc_dapm_dac, snd_soc_dapm_mic,
+	snd_soc_dapm_micbias, snd_soc_dapm_mux, snd_soc_dapm_post
+};
+
+static int dapm_status = 1;
+module_param(dapm_status, int, 0);
+MODULE_PARM_DESC(dapm_status, "enable DPM sysfs entries");
+
+/* create a new dapm widget */
+static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
+	const struct snd_soc_dapm_widget *_widget)
+{
+	return kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);
+}
+
+/* set up initial codec paths */
+static void dapm_set_path_status(struct snd_soc_dapm_widget *w,
+	struct snd_soc_dapm_path *p, int i)
+{
+	switch (w->id) {
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer: {
+		int val;
+		int reg = w->kcontrols[i].private_value & 0xff;
+		int shift = (w->kcontrols[i].private_value >> 8) & 0x0f;
+		int mask = (w->kcontrols[i].private_value >> 16) & 0xff;
+		int invert = (w->kcontrols[i].private_value >> 24) & 0x01;
+
+		val = snd_soc_read(w->codec, reg);
+		val = (val >> shift) & mask;
+
+		if ((invert && !val) || (!invert && val))
+			p->connect = 1;
+		else
+			p->connect = 0;
+	}
+	break;
+	case snd_soc_dapm_mux: {
+		struct soc_enum *e = (struct soc_enum *)w->kcontrols[i].private_value;
+		int val, item, bitmask;
+
+		for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+		val = snd_soc_read(w->codec, e->reg);
+		item = (val >> e->shift_l) & (bitmask - 1);
+
+		p->connect = 0;
+		for (i = 0; i < e->mask; i++) {
+			if (!(strcmp(p->name, e->texts[i])) && item == i)
+				p->connect = 1;
+		}
+	}
+	break;
+	/* does not effect routing - always connected */
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+		p->connect = 1;
+	break;
+	/* does effect routing - dynamically connected */
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+		p->connect = 0;
+	break;
+	}
+}
+
+/* connect mux widget to it's interconnecting audio paths */
+static int dapm_connect_mux(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name,
+	const struct snd_kcontrol_new *kcontrol)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	int i;
+
+	for (i = 0; i < e->mask; i++) {
+		if (!(strcmp(control_name, e->texts[i]))) {
+			list_add(&path->list, &codec->dapm_paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = (char*)e->texts[i];
+			dapm_set_path_status(dest, path, 0);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+/* connect mixer widget to it's interconnecting audio paths */
+static int dapm_connect_mixer(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name)
+{
+	int i;
+
+	/* search for mixer kcontrol */
+	for (i = 0; i < dest->num_kcontrols; i++) {
+		if (!strcmp(control_name, dest->kcontrols[i].name)) {
+			list_add(&path->list, &codec->dapm_paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = dest->kcontrols[i].name;
+			dapm_set_path_status(dest, path, i);
+			return 0;
+		}
+	}
+	return -ENODEV;
+}
+
+/* update dapm codec register bits */
+static int dapm_update_bits(struct snd_soc_dapm_widget *widget)
+{
+	int change, power;
+	unsigned short old, new;
+	struct snd_soc_codec *codec = widget->codec;
+
+	/* check for valid widgets */
+	if (widget->reg < 0 || widget->id == snd_soc_dapm_input ||
+		widget->id == snd_soc_dapm_output ||
+		widget->id == snd_soc_dapm_hp ||
+		widget->id == snd_soc_dapm_mic ||
+		widget->id == snd_soc_dapm_line ||
+		widget->id == snd_soc_dapm_spk)
+		return 0;
+
+	power = widget->power;
+	if (widget->invert)
+		power = (power ? 0:1);
+
+	old = snd_soc_read(codec, widget->reg);
+	new = (old & ~(0x1 << widget->shift)) | (power << widget->shift);
+
+	change = old != new;
+	if (change) {
+		pop_dbg("pop test %s : %s in %d ms\n", widget->name,
+			widget->power ? "on" : "off", POP_TIME);
+		snd_soc_write(codec, widget->reg, new);
+		pop_wait(POP_TIME);
+	}
+	dbg("reg old %x new %x change %d\n", old, new, change);
+	return change;
+}
+
+/* ramps the volume up or down to minimise pops before or after a
+ * DAPM power event */
+static int dapm_set_pga(struct snd_soc_dapm_widget *widget, int power)
+{
+	const struct snd_kcontrol_new *k = widget->kcontrols;
+
+	if (widget->muted && !power)
+		return 0;
+	if (!widget->muted && power)
+		return 0;
+
+	if (widget->num_kcontrols && k) {
+		int reg = k->private_value & 0xff;
+		int shift = (k->private_value >> 8) & 0x0f;
+		int mask = (k->private_value >> 16) & 0xff;
+		int invert = (k->private_value >> 24) & 0x01;
+
+		if (power) {
+			int i;
+			/* power up has happended, increase volume to last level */
+			if (invert) {
+				for (i = mask; i > widget->saved_value; i--)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			} else {
+				for (i = 0; i < widget->saved_value; i++)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			}
+			widget->muted = 0;
+		} else {
+			/* power down is about to occur, decrease volume to mute */
+			int val = snd_soc_read(widget->codec, reg);
+			int i = widget->saved_value = (val >> shift) & mask;
+			if (invert) {
+				for (; i < mask; i++)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			} else {
+				for (; i > 0; i--)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			}
+			widget->muted = 1;
+		}
+	}
+	return 0;
+}
+
+/* create new dapm mixer control */
+static int dapm_new_mixer(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	int i, ret = 0;
+	char name[32];
+	struct snd_soc_dapm_path *path;
+
+	/* add kcontrol */
+	for (i = 0; i < w->num_kcontrols; i++) {
+
+		/* match name */
+		list_for_each_entry(path, &w->sources, list_sink) {
+
+			/* mixer/mux paths name must match control name */
+			if (path->name != (char*)w->kcontrols[i].name)
+				continue;
+
+			/* add dapm control with long name */
+			snprintf(name, 32, "%s %s", w->name, w->kcontrols[i].name);
+			path->long_name = kstrdup (name, GFP_KERNEL);
+			if (path->long_name == NULL)
+				return -ENOMEM;
+
+			path->kcontrol = snd_soc_cnew(&w->kcontrols[i], w,
+				path->long_name);
+			ret = snd_ctl_add(codec->card, path->kcontrol);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to add dapm kcontrol %s\n",
+						path->long_name);
+				kfree(path->long_name);
+				path->long_name = NULL;
+				return ret;
+			}
+		}
+	}
+	return ret;
+}
+
+/* create new dapm mux control */
+static int dapm_new_mux(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_path *path = NULL;
+	struct snd_kcontrol *kcontrol;
+	int ret = 0;
+
+	if (!w->num_kcontrols) {
+		printk(KERN_ERR "asoc: mux %s has no controls\n", w->name);
+		return -EINVAL;
+	}
+
+	kcontrol = snd_soc_cnew(&w->kcontrols[0], w, w->name);
+	ret = snd_ctl_add(codec->card, kcontrol);
+	if (ret < 0)
+		goto err;
+
+	list_for_each_entry(path, &w->sources, list_sink)
+		path->kcontrol = kcontrol;
+
+	return ret;
+
+err:
+	printk(KERN_ERR "asoc: failed to add kcontrol %s\n", w->name);
+	return ret;
+}
+
+/* create new dapm volume control */
+static int dapm_new_pga(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_kcontrol *kcontrol;
+	int ret = 0;
+
+	if (!w->num_kcontrols)
+		return -EINVAL;
+
+	kcontrol = snd_soc_cnew(&w->kcontrols[0], w, w->name);
+	ret = snd_ctl_add(codec->card, kcontrol);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to add kcontrol %s\n", w->name);
+		return ret;
+	}
+
+	return ret;
+}
+
+/* reset 'walked' bit for each dapm path */
+static inline void dapm_clear_walk(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, &codec->dapm_paths, list)
+		p->walked = 0;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * output widget. Returns number of complete paths.
+ */
+static int is_connected_output_ep(struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	if (widget->id == snd_soc_dapm_adc && widget->active)
+		return 1;
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_output && !widget->ext)
+			return 1;
+
+		/* connected jack or spk ? */
+		if (widget->id == snd_soc_dapm_hp || widget->id == snd_soc_dapm_spk ||
+			widget->id == snd_soc_dapm_line)
+			return 1;
+	}
+
+	list_for_each_entry(path, &widget->sinks, list_source) {
+		if (path->walked)
+			continue;
+
+		if (path->sink && path->connect) {
+			path->walked = 1;
+			con += is_connected_output_ep(path->sink);
+		}
+	}
+
+	return con;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * input widget. Returns number of complete paths.
+ */
+static int is_connected_input_ep(struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	/* active stream ? */
+	if (widget->id == snd_soc_dapm_dac && widget->active)
+		return 1;
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_input && !widget->ext)
+			return 1;
+
+		/* connected VMID/Bias for lower pops */
+		if (widget->id == snd_soc_dapm_vmid)
+			return 1;
+
+		/* connected jack ? */
+		if (widget->id == snd_soc_dapm_mic || widget->id == snd_soc_dapm_line)
+			return 1;
+	}
+
+	list_for_each_entry(path, &widget->sources, list_sink) {
+		if (path->walked)
+			continue;
+
+		if (path->source && path->connect) {
+			path->walked = 1;
+			con += is_connected_input_ep(path->source);
+		}
+	}
+
+	return con;
+}
+
+/*
+ * Scan each dapm widget for complete audio path.
+ * A complete path is a route that has valid endpoints i.e.:-
+ *
+ *  o DAC to output pin.
+ *  o Input Pin to ADC.
+ *  o Input pin to Output pin (bypass, sidetone)
+ *  o DAC to ADC (loopback).
+ */
+static int dapm_power_widgets(struct snd_soc_codec *codec, int event)
+{
+	struct snd_soc_dapm_widget *w;
+	int in, out, i, c = 1, *seq = NULL, ret = 0, power_change, power;
+
+	/* do we have a sequenced stream event */
+	if (event == SND_SOC_DAPM_STREAM_START) {
+		c = ARRAY_SIZE(dapm_up_seq);
+		seq = dapm_up_seq;
+	} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+		c = ARRAY_SIZE(dapm_down_seq);
+		seq = dapm_down_seq;
+	}
+
+	for(i = 0; i < c; i++) {
+		list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+			/* is widget in stream order */
+			if (seq && seq[i] && w->id != seq[i])
+				continue;
+
+			/* vmid - no action */
+			if (w->id == snd_soc_dapm_vmid)
+				continue;
+
+			/* active ADC */
+			if (w->id == snd_soc_dapm_adc && w->active) {
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = (in != 0) ? 1 : 0;
+				dapm_update_bits(w);
+				continue;
+			}
+
+			/* active DAC */
+			if (w->id == snd_soc_dapm_dac && w->active) {
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = (out != 0) ? 1 : 0;
+				dapm_update_bits(w);
+				continue;
+			}
+
+			/* programmable gain/attenuation */
+			if (w->id == snd_soc_dapm_pga) {
+				int on;
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = on = (out != 0 && in != 0) ? 1 : 0;
+
+				if (!on)
+					dapm_set_pga(w, on); /* lower volume to reduce pops */
+				dapm_update_bits(w);
+				if (on)
+					dapm_set_pga(w, on); /* restore volume from zero */
+
+				continue;
+			}
+
+			/* pre and post event widgets */
+			if (w->id == snd_soc_dapm_pre) {
+				if (!w->event)
+					continue;
+
+				if (event == SND_SOC_DAPM_STREAM_START) {
+					ret = w->event(w, SND_SOC_DAPM_PRE_PMU);
+					if (ret < 0)
+						return ret;
+				} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+					ret = w->event(w, SND_SOC_DAPM_PRE_PMD);
+					if (ret < 0)
+						return ret;
+				}
+				continue;
+			}
+			if (w->id == snd_soc_dapm_post) {
+				if (!w->event)
+					continue;
+
+				if (event == SND_SOC_DAPM_STREAM_START) {
+					ret = w->event(w, SND_SOC_DAPM_POST_PMU);
+					if (ret < 0)
+						return ret;
+				} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+					ret = w->event(w, SND_SOC_DAPM_POST_PMD);
+					if (ret < 0)
+						return ret;
+				}
+				continue;
+			}
+
+			/* all other widgets */
+			in = is_connected_input_ep(w);
+			dapm_clear_walk(w->codec);
+			out = is_connected_output_ep(w);
+			dapm_clear_walk(w->codec);
+			power = (out != 0 && in != 0) ? 1 : 0;
+			power_change = (w->power == power) ? 0: 1;
+			w->power = power;
+
+			/* call any power change event handlers */
+			if (power_change) {
+				if (w->event) {
+					dbg("power %s event for %s flags %x\n",
+						w->power ? "on" : "off", w->name, w->event_flags);
+					if (power) {
+						/* power up event */
+						if (w->event_flags & SND_SOC_DAPM_PRE_PMU) {
+							ret = w->event(w, SND_SOC_DAPM_PRE_PMU);
+							if (ret < 0)
+								return ret;
+						}
+						dapm_update_bits(w);
+						if (w->event_flags & SND_SOC_DAPM_POST_PMU){
+							ret = w->event(w, SND_SOC_DAPM_POST_PMU);
+							if (ret < 0)
+								return ret;
+						}
+					} else {
+						/* power down event */
+						if (w->event_flags & SND_SOC_DAPM_PRE_PMD) {
+							ret = w->event(w, SND_SOC_DAPM_PRE_PMD);
+							if (ret < 0)
+								return ret;
+						}
+						dapm_update_bits(w);
+						if (w->event_flags & SND_SOC_DAPM_POST_PMD) {
+							ret = w->event(w, SND_SOC_DAPM_POST_PMD);
+							if (ret < 0)
+								return ret;
+						}
+					}
+				} else
+					/* no event handler */
+					dapm_update_bits(w);
+			}
+		}
+	}
+
+	return ret;
+}
+
+#if DAPM_DEBUG
+static void dbg_dump_dapm(struct snd_soc_codec* codec, const char *action)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_path *p = NULL;
+	int in, out;
+
+	printk("DAPM %s %s\n", codec->name, action);
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		/* only display widgets that effect routing */
+		switch (w->id) {
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+		case snd_soc_dapm_vmid:
+			continue;
+		case snd_soc_dapm_mux:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_mixer:
+			if (w->name) {
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				printk("%s: %s  in %d out %d\n", w->name,
+					w->power ? "On":"Off",in, out);
+
+				list_for_each_entry(p, &w->sources, list_sink) {
+					if (p->connect)
+						printk(" in  %s %s\n", p->name ? p->name : "static",
+							p->source->name);
+				}
+				list_for_each_entry(p, &w->sinks, list_source) {
+					if (p->connect)
+						printk(" out %s %s\n", p->name ? p->name : "static",
+							p->sink->name);
+				}
+			}
+		break;
+		}
+	}
+}
+#endif
+
+/* test and update the power status of a mux widget */
+static int dapm_mux_update_power(struct snd_soc_dapm_widget *widget,
+				 struct snd_kcontrol *kcontrol, int mask,
+				 int val, struct soc_enum* e)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	if (widget->id != snd_soc_dapm_mux)
+		return -ENODEV;
+
+	if (!snd_soc_test_bits(widget->codec, e->reg, mask, val))
+		return 0;
+
+	/* find dapm widget path assoc with kcontrol */
+	list_for_each_entry(path, &widget->codec->dapm_paths, list) {
+		if (path->kcontrol != kcontrol)
+			continue;
+
+		if (!path->name || ! e->texts[val])
+			continue;
+
+		found = 1;
+		/* we now need to match the string in the enum to the path */
+		if (!(strcmp(path->name, e->texts[val])))
+			path->connect = 1; /* new connection */
+		else
+			path->connect = 0; /* old connection must be powered down */
+	}
+
+	if (found)
+		dapm_power_widgets(widget->codec, SND_SOC_DAPM_STREAM_NOP);
+
+	return 0;
+}
+
+/* test and update the power status of a mixer widget */
+static int dapm_mixer_update_power(struct snd_soc_dapm_widget *widget,
+				   struct snd_kcontrol *kcontrol, int reg,
+				   int val_mask, int val, int invert)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	if (widget->id != snd_soc_dapm_mixer)
+		return -ENODEV;
+
+	if (!snd_soc_test_bits(widget->codec, reg, val_mask, val))
+		return 0;
+
+	/* find dapm widget path assoc with kcontrol */
+	list_for_each_entry(path, &widget->codec->dapm_paths, list) {
+		if (path->kcontrol != kcontrol)
+			continue;
+
+		/* found, now check type */
+		found = 1;
+		if (val)
+			/* new connection */
+			path->connect = invert ? 0:1;
+		else
+			/* old connection must be powered down */
+			path->connect = invert ? 1:0;
+		break;
+	}
+
+	if (found)
+		dapm_power_widgets(widget->codec, SND_SOC_DAPM_STREAM_NOP);
+
+	return 0;
+}
+
+/* show dapm widget status in sys fs */
+static ssize_t dapm_widget_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	struct snd_soc_dapm_widget *w;
+	int count = 0;
+	char *state = "not set";
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		/* only display widgets that burnm power */
+		switch (w->id) {
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_mixer:
+			if (w->name)
+				count += sprintf(buf + count, "%s: %s\n",
+					w->name, w->power ? "On":"Off");
+		break;
+		default:
+		break;
+		}
+	}
+
+	switch(codec->dapm_state){
+	case SNDRV_CTL_POWER_D0:
+		state = "D0";
+		break;
+	case SNDRV_CTL_POWER_D1:
+		state = "D1";
+		break;
+	case SNDRV_CTL_POWER_D2:
+		state = "D2";
+		break;
+	case SNDRV_CTL_POWER_D3hot:
+		state = "D3hot";
+		break;
+	case SNDRV_CTL_POWER_D3cold:
+		state = "D3cold";
+		break;
+	}
+	count += sprintf(buf + count, "PM State: %s\n", state);
+
+	return count;
+}
+
+static DEVICE_ATTR(dapm_widget, 0444, dapm_widget_show, NULL);
+
+int snd_soc_dapm_sys_add(struct device *dev)
+{
+	int ret = 0;
+
+	if (dapm_status)
+		ret = device_create_file(dev, &dev_attr_dapm_widget);
+
+	return ret;
+}
+
+static void snd_soc_dapm_sys_remove(struct device *dev)
+{
+	if (dapm_status)
+		device_remove_file(dev, &dev_attr_dapm_widget);
+}
+
+/* free all dapm widgets and resources */
+static void dapm_free_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_widget *w, *next_w;
+	struct snd_soc_dapm_path *p, *next_p;
+
+	list_for_each_entry_safe(w, next_w, &codec->dapm_widgets, list) {
+		list_del(&w->list);
+		kfree(w);
+	}
+
+	list_for_each_entry_safe(p, next_p, &codec->dapm_paths, list) {
+		list_del(&p->list);
+		kfree(p->long_name);
+		kfree(p);
+	}
+}
+
+/**
+ * snd_soc_dapm_sync_endpoints - scan and power dapm paths
+ * @codec: audio codec
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec)
+{
+	return dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync_endpoints);
+
+/**
+ * snd_soc_dapm_connect_input - connect dapm widgets
+ * @codec: audio codec
+ * @sink: name of target widget
+ * @control: mixer control name
+ * @source: name of source name
+ *
+ * Connects 2 dapm widgets together via a named audio path. The sink is
+ * the widget receiving the audio signal, whilst the source is the sender
+ * of the audio signal.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_connect_input(struct snd_soc_codec *codec, const char *sink,
+	const char * control, const char *source)
+{
+	struct snd_soc_dapm_path *path;
+	struct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w;
+	int ret = 0;
+
+	/* find src and dest widgets */
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		if (!wsink && !(strcmp(w->name, sink))) {
+			wsink = w;
+			continue;
+		}
+		if (!wsource && !(strcmp(w->name, source))) {
+			wsource = w;
+		}
+	}
+
+	if (wsource == NULL || wsink == NULL)
+		return -ENODEV;
+
+	path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);
+	if (!path)
+		return -ENOMEM;
+
+	path->source = wsource;
+	path->sink = wsink;
+	INIT_LIST_HEAD(&path->list);
+	INIT_LIST_HEAD(&path->list_source);
+	INIT_LIST_HEAD(&path->list_sink);
+
+	/* check for external widgets */
+	if (wsink->id == snd_soc_dapm_input) {
+		if (wsource->id == snd_soc_dapm_micbias ||
+			wsource->id == snd_soc_dapm_mic ||
+			wsink->id == snd_soc_dapm_line)
+			wsink->ext = 1;
+	}
+	if (wsource->id == snd_soc_dapm_output) {
+		if (wsink->id == snd_soc_dapm_spk ||
+			wsink->id == snd_soc_dapm_hp ||
+			wsink->id == snd_soc_dapm_line)
+			wsource->ext = 1;
+	}
+
+	/* connect static paths */
+	if (control == NULL) {
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	}
+
+	/* connect dynamic paths */
+	switch(wsink->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	case snd_soc_dapm_mux:
+		ret = dapm_connect_mux(codec, wsource, wsink, path, control,
+			&wsink->kcontrols[0]);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+		ret = dapm_connect_mixer(codec, wsource, wsink, path, control);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_spk:
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 0;
+		return 0;
+	}
+	return 0;
+
+err:
+	printk(KERN_WARNING "asoc: no dapm match for %s --> %s --> %s\n", source,
+		control, sink);
+	kfree(path);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_connect_input);
+
+/**
+ * snd_soc_dapm_new_widgets - add new dapm widgets
+ * @codec: audio codec
+ *
+ * Checks the codec for any new dapm widgets and creates them if found.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_new_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_widget *w;
+
+	mutex_lock(&codec->mutex);
+	list_for_each_entry(w, &codec->dapm_widgets, list)
+	{
+		if (w->new)
+			continue;
+
+		switch(w->id) {
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_mixer:
+			dapm_new_mixer(codec, w);
+			break;
+		case snd_soc_dapm_mux:
+			dapm_new_mux(codec, w);
+			break;
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_pga:
+			dapm_new_pga(codec, w);
+			break;
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_vmid:
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+			break;
+		}
+		w->new = 1;
+	}
+
+	dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_widgets);
+
+/**
+ * snd_soc_dapm_get_volsw - dapm mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	/* return the saved value if we are powered down */
+	if (widget->id == snd_soc_dapm_pga && !widget->power) {
+		ucontrol->value.integer.value[0] = widget->saved_value;
+		return 0;
+	}
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(widget->codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(widget->codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_volsw);
+
+/**
+ * snd_soc_dapm_put_volsw - dapm mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	unsigned short val, val2, val_mask;
+	int ret;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+
+	mutex_lock(&widget->codec->mutex);
+	widget->value = val;
+
+	/* save volume value if the widget is powered down */
+	if (widget->id == snd_soc_dapm_pga && !widget->power) {
+		widget->saved_value = val;
+		mutex_unlock(&widget->codec->mutex);
+		return 1;
+	}
+
+	dapm_mixer_update_power(widget, kcontrol, reg, val_mask, val, invert);
+	if (widget->event) {
+		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
+			ret = widget->event(widget, SND_SOC_DAPM_PRE_REG);
+			if (ret < 0)
+				goto out;
+		}
+		ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+		if (widget->event_flags & SND_SOC_DAPM_POST_REG)
+			ret = widget->event(widget, SND_SOC_DAPM_POST_REG);
+	} else
+		ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+
+out:
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw);
+
+/**
+ * snd_soc_dapm_get_enum_double - dapm enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(widget->codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);
+
+/**
+ * snd_soc_dapm_put_enum_double - dapm enumerated double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, mux;
+	unsigned short mask, bitmask;
+	int ret = 0;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	mux = ucontrol->value.enumerated.item[0];
+	val = mux << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	mutex_lock(&widget->codec->mutex);
+	widget->value = val;
+	dapm_mux_update_power(widget, kcontrol, mask, mux, e);
+	if (widget->event) {
+		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
+			ret = widget->event(widget, SND_SOC_DAPM_PRE_REG);
+			if (ret < 0)
+				goto out;
+		}
+		ret = snd_soc_update_bits(widget->codec, e->reg, mask, val);
+		if (widget->event_flags & SND_SOC_DAPM_POST_REG)
+			ret = widget->event(widget, SND_SOC_DAPM_POST_REG);
+	} else
+		ret = snd_soc_update_bits(widget->codec, e->reg, mask, val);
+
+out:
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_enum_double);
+
+/**
+ * snd_soc_dapm_new_control - create new dapm control
+ * @codec: audio codec
+ * @widget: widget template
+ *
+ * Creates a new dapm control based upon the template.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_new_control(struct snd_soc_codec *codec,
+	const struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_widget *w;
+
+	if ((w = dapm_cnew_widget(widget)) == NULL)
+		return -ENOMEM;
+
+	w->codec = codec;
+	INIT_LIST_HEAD(&w->sources);
+	INIT_LIST_HEAD(&w->sinks);
+	INIT_LIST_HEAD(&w->list);
+	list_add(&w->list, &codec->dapm_widgets);
+
+	/* machine layer set ups unconnected pins and insertions */
+	w->connected = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_control);
+
+/**
+ * snd_soc_dapm_stream_event - send a stream event to the dapm core
+ * @codec: audio codec
+ * @stream: stream name
+ * @event: stream event
+ *
+ * Sends a stream event to the dapm core. The core then makes any
+ * necessary widget power changes.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_stream_event(struct snd_soc_codec *codec,
+	char *stream, int event)
+{
+	struct snd_soc_dapm_widget *w;
+
+	if (stream == NULL)
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	list_for_each_entry(w, &codec->dapm_widgets, list)
+	{
+		if (!w->sname)
+			continue;
+		dbg("widget %s\n %s stream %s event %d\n", w->name, w->sname,
+			stream, event);
+		if (strstr(w->sname, stream)) {
+			switch(event) {
+			case SND_SOC_DAPM_STREAM_START:
+				w->active = 1;
+				break;
+			case SND_SOC_DAPM_STREAM_STOP:
+				w->active = 0;
+				break;
+			case SND_SOC_DAPM_STREAM_SUSPEND:
+				if (w->active)
+					w->suspend = 1;
+				w->active = 0;
+				break;
+			case SND_SOC_DAPM_STREAM_RESUME:
+				if (w->suspend) {
+					w->active = 1;
+					w->suspend = 0;
+				}
+				break;
+			case SND_SOC_DAPM_STREAM_PAUSE_PUSH:
+				break;
+			case SND_SOC_DAPM_STREAM_PAUSE_RELEASE:
+				break;
+			}
+		}
+	}
+	mutex_unlock(&codec->mutex);
+
+	dapm_power_widgets(codec, event);
+	dump_dapm(codec, __FUNCTION__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_stream_event);
+
+/**
+ * snd_soc_dapm_set_endpoint - set audio endpoint status
+ * @codec: audio codec
+ * @endpoint: audio signal endpoint (or start point)
+ * @status: point status
+ *
+ * Set audio endpoint status - connected or disconnected.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *endpoint, int status)
+{
+	struct snd_soc_dapm_widget *w;
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+		if (!strcmp(w->name, endpoint)) {
+			w->connected = status;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_set_endpoint);
+
+/**
+ * snd_soc_dapm_free - free dapm resources
+ * @socdev: SoC device
+ *
+ * Free all dapm widgets and resources.
+ */
+void snd_soc_dapm_free(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	snd_soc_dapm_sys_remove(socdev->dev);
+	dapm_free_widgets(codec);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_free);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("Dynamic Audio Power Management core for ALSA SoC");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/Kconfig.orig	2007-06-05 19:47:23.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/Kconfig	2007-06-05 19:53:36.000000000 -0400
@@ -0,0 +1,34 @@
+#
+# SoC audio configuration
+#
+
+menu "SoC audio support"
+	depends on SND!=n
+
+config SND_SOC_AC97_BUS
+	bool
+
+config SND_SOC
+	tristate "SoC audio support"
+	depends on SND
+	select SND_PCM
+	---help---
+
+	  If you want SoC support, you should say Y here and also to the
+	  specific driver for your SoC below. You will also need to select the
+	  specific codec(s) attached to the SoC
+
+	  This SoC audio support can also be built as a module.  If so, the module
+	  will be called snd-soc-core.
+
+# All the supported Soc's
+menu "SoC Platforms"
+depends on SND_SOC
+source "sound/soc/at91/Kconfig"
+source "sound/soc/pxa/Kconfig"
+endmenu
+
+# Supported codecs
+source "sound/soc/codecs/Kconfig"
+
+endmenu
--- linux-2.6.18.noarch/sound/soc/at91/soc-core.c.orig	2007-06-05 19:57:27.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/soc-core.c	2007-06-05 19:52:44.000000000 -0400
@@ -0,0 +1,1587 @@
+/*
+ * soc-core.c  --  ALSA SoC Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *         with code, comments and ideas from :-
+ *         Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Working Codec, Interface and Platform registration.
+ *
+ *  TODO:
+ *   o Add hw rules to enforce rates, etc.
+ *   o More testing with other codecs/machines.
+ *   o Add more codecs and platforms to ensure good API coverage.
+ *   o Support TDM on PCM and I2S
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define SOC_DEBUG 0
+#if SOC_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+static DEFINE_MUTEX(pcm_mutex);
+static DEFINE_MUTEX(io_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
+
+/*
+ * This is a timeout to do a DAPM powerdown after a stream is closed().
+ * It can be used to eliminate pops between different playback streams, e.g.
+ * between two audio tracks.
+ */
+static int pmdown_time = 5000;
+module_param(pmdown_time, int, 0);
+MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
+
+/*
+ * This function forces any delayed work to be queued and run.
+ */
+static int run_delayed_work(struct delayed_work *dwork)
+{
+	int ret;
+
+	/* cancel any work waiting to be queued. */
+	ret = cancel_delayed_work(dwork);
+
+	/* if there was any work waiting then we run it now and
+	 * wait for it's completion */
+	if (ret) {
+		schedule_delayed_work(dwork, 0);
+		flush_scheduled_work();
+	}
+	return ret;
+}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_unregister(&codec->ac97->dev);
+	return 0;
+}
+
+/* stop no dev release warning */
+static void soc_ac97_device_release(struct device *dev){}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = NULL;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	snprintf(codec->ac97->dev.bus_id, BUS_ID_SIZE, "%d-%d:%s",
+		 codec->card->number, 0, codec->name);
+	err = device_register(&codec->ac97->dev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+#endif
+
+static inline const char* get_dai_name(int type)
+{
+	switch(type) {
+	case SND_SOC_DAI_AC97:
+		return "AC97";
+	case SND_SOC_DAI_I2S:
+		return "I2S";
+	case SND_SOC_DAI_PCM:
+		return "PCM";
+	}
+	return NULL;
+}
+
+/*
+ * Called by ALSA when a PCM substream is opened, the runtime->hw record is
+ * then initialized and any private data can be allocated. This also calls
+ * startup for the cpu DAI, platform, machine and codec DAI.
+ */
+static int soc_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	/* startup the audio subsystem */
+	if (cpu_dai->ops.startup) {
+		ret = cpu_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open interface %s\n",
+				cpu_dai->name);
+			goto out;
+		}
+	}
+
+	if (platform->pcm_ops->open) {
+		ret = platform->pcm_ops->open(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
+			goto platform_err;
+		}
+	}
+
+	if (codec_dai->ops.startup) {
+		ret = codec_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open codec %s\n",
+				codec_dai->name);
+			goto codec_dai_err;
+		}
+	}
+
+	if (machine->ops && machine->ops->startup) {
+		ret = machine->ops->startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
+			goto machine_err;
+		}
+	}
+
+	/* Check that the codec and cpu DAI's are compatible */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		runtime->hw.rate_min =
+			max(codec_dai->playback.rate_min, cpu_dai->playback.rate_min);
+		runtime->hw.rate_max =
+			min(codec_dai->playback.rate_max, cpu_dai->playback.rate_max);
+		runtime->hw.channels_min =
+			max(codec_dai->playback.channels_min,
+				cpu_dai->playback.channels_min);
+		runtime->hw.channels_max =
+			min(codec_dai->playback.channels_max,
+				cpu_dai->playback.channels_max);
+		runtime->hw.formats =
+			codec_dai->playback.formats & cpu_dai->playback.formats;
+		runtime->hw.rates =
+			codec_dai->playback.rates & cpu_dai->playback.rates;
+	} else {
+		runtime->hw.rate_min =
+			max(codec_dai->capture.rate_min, cpu_dai->capture.rate_min);
+		runtime->hw.rate_max =
+			min(codec_dai->capture.rate_max, cpu_dai->capture.rate_max);
+		runtime->hw.channels_min =
+			max(codec_dai->capture.channels_min,
+				cpu_dai->capture.channels_min);
+		runtime->hw.channels_max =
+			min(codec_dai->capture.channels_max,
+				cpu_dai->capture.channels_max);
+		runtime->hw.formats =
+			codec_dai->capture.formats & cpu_dai->capture.formats;
+		runtime->hw.rates =
+			codec_dai->capture.rates & cpu_dai->capture.rates;
+	}
+
+	snd_pcm_limit_hw_rates(runtime);
+	if (!runtime->hw.rates) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
+	}
+	if (!runtime->hw.formats) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
+	}
+	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
+	}
+
+	dbg("asoc: %s <-> %s info:\n",codec_dai->name, cpu_dai->name);
+	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
+	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
+		runtime->hw.channels_max);
+	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
+		runtime->hw.rate_max);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->playback.active = codec_dai->playback.active = 1;
+	else
+		cpu_dai->capture.active = codec_dai->capture.active = 1;
+	cpu_dai->active = codec_dai->active = 1;
+	cpu_dai->runtime = runtime;
+	socdev->codec->active++;
+	mutex_unlock(&pcm_mutex);
+	return 0;
+
+machine_err:
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+codec_dai_err:
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+
+platform_err:
+	if (cpu_dai->ops.shutdown)
+		cpu_dai->ops.shutdown(substream);
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Power down the audio subsytem pmdown_time msecs after close is called.
+ * This is to ensure there are no pops or clicks in between any music tracks
+ * due to DAPM power cycling.
+ */
+static void close_delayed_work(struct work_struct *work)
+{
+	struct snd_soc_device *socdev =
+		container_of(work, struct snd_soc_device, delayed_work.work);
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai;
+	int i;
+
+	mutex_lock(&pcm_mutex);
+	for(i = 0; i < codec->num_dai; i++) {
+		codec_dai = &codec->dai[i];
+
+		dbg("pop wq checking: %s status: %s waiting: %s\n",
+			codec_dai->playback.stream_name,
+			codec_dai->playback.active ? "active" : "inactive",
+			codec_dai->pop_wait ? "yes" : "no");
+
+		/* are we waiting on this codec DAI stream */
+		if (codec_dai->pop_wait == 1) {
+
+			codec_dai->pop_wait = 0;
+			snd_soc_dapm_stream_event(codec, codec_dai->playback.stream_name,
+				SND_SOC_DAPM_STREAM_STOP);
+
+			/* power down the codec power domain if no longer active */
+			if (codec->active == 0) {
+				dbg("pop wq D3 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
+		 		if (codec->dapm_event)
+					codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+			}
+		}
+	}
+	mutex_unlock(&pcm_mutex);
+}
+
+/*
+ * Called by ALSA when a PCM substream is closed. Private data can be
+ * freed here. The cpu DAI, codec DAI, machine and platform are also
+ * shutdown.
+ */
+static int soc_codec_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&pcm_mutex);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->playback.active = codec_dai->playback.active = 0;
+	else
+		cpu_dai->capture.active = codec_dai->capture.active = 0;
+
+	if (codec_dai->playback.active == 0 &&
+		codec_dai->capture.active == 0) {
+		cpu_dai->active = codec_dai->active = 0;
+	}
+	codec->active--;
+
+	if (cpu_dai->ops.shutdown)
+		cpu_dai->ops.shutdown(substream);
+
+	if (codec_dai->ops.shutdown)
+		codec_dai->ops.shutdown(substream);
+
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+	cpu_dai->runtime = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* start delayed pop wq here for playback streams */
+		codec_dai->pop_wait = 1;
+		schedule_delayed_work(&socdev->delayed_work,
+			msecs_to_jiffies(pmdown_time));
+	} else {
+		/* capture streams can be powered down now */
+		snd_soc_dapm_stream_event(codec,
+			codec_dai->capture.stream_name, SND_SOC_DAPM_STREAM_STOP);
+
+		if (codec->active == 0 && codec_dai->pop_wait == 0){
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+		}
+	}
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+/*
+ * Called by ALSA when the PCM substream is prepared, can set format, sample
+ * rate, etc.  This function is non atomic and can be called multiple times,
+ * it can refer to the runtime info.
+ */
+static int soc_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	if (machine->ops && machine->ops->prepare) {
+		ret = machine->ops->prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine prepare error\n");
+			goto out;
+		}
+	}
+
+	if (platform->pcm_ops->prepare) {
+		ret = platform->pcm_ops->prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: platform prepare error\n");
+			goto out;
+		}
+	}
+
+	if (codec_dai->ops.prepare) {
+		ret = codec_dai->ops.prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: codec DAI prepare error\n");
+			goto out;
+		}
+	}
+
+	if (cpu_dai->ops.prepare) {
+		ret = cpu_dai->ops.prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
+			goto out;
+		}
+	}
+
+	/* we only want to start a DAPM playback stream if we are not waiting
+	 * on an existing one stopping */
+	if (codec_dai->pop_wait) {
+		/* we are waiting for the delayed work to start */
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				snd_soc_dapm_stream_event(socdev->codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+		else {
+			codec_dai->pop_wait = 0;
+			cancel_delayed_work(&socdev->delayed_work);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+		}
+	} else {
+		/* no delayed work - do we need to power up codec */
+		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D1);
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D0);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+
+		} else {
+			/* codec already powered - power on widgets */
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Called by ALSA when the hardware params are set by application. This
+ * function can also be called multiple times and can allocate buffers
+ * (using snd_pcm_lib_* ). It's non-atomic.
+ */
+static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	if (machine->ops && machine->ops->hw_params) {
+		ret = machine->ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine hw_params failed\n");
+			goto out;
+		}
+	}
+
+	if (codec_dai->ops.hw_params) {
+		ret = codec_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
+				codec_dai->name);
+			goto codec_err;
+		}
+	}
+
+	if (cpu_dai->ops.hw_params) {
+		ret = cpu_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set interface %s hw params\n",
+				cpu_dai->name);
+			goto interface_err;
+		}
+	}
+
+	if (platform->pcm_ops->hw_params) {
+		ret = platform->pcm_ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set platform %s hw params\n",
+				platform->name);
+			goto platform_err;
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+
+platform_err:
+	if (cpu_dai->ops.hw_free)
+		cpu_dai->ops.hw_free(substream);
+
+interface_err:
+	if (codec_dai->ops.hw_free)
+		codec_dai->ops.hw_free(substream);
+
+codec_err:
+	if(machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Free's resources allocated by hw_params, can be called multiple times
+ */
+static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&pcm_mutex);
+
+	/* apply codec digital mute */
+	if (!codec->active && codec_dai->dai_ops.digital_mute)
+		codec_dai->dai_ops.digital_mute(codec_dai, 1);
+
+	/* free any machine hw params */
+	if (machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
+
+	/* free any DMA resources */
+	if (platform->pcm_ops->hw_free)
+		platform->pcm_ops->hw_free(substream);
+
+	/* now free hw params for the DAI's  */
+	if (codec_dai->ops.hw_free)
+		codec_dai->ops.hw_free(substream);
+
+	if (cpu_dai->ops.hw_free)
+		cpu_dai->ops.hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	int ret;
+
+	if (codec_dai->ops.trigger) {
+		ret = codec_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (platform->pcm_ops->trigger) {
+		ret = platform->pcm_ops->trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->ops.trigger) {
+		ret = cpu_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+/* ASoC PCM operations */
+static struct snd_pcm_ops soc_pcm_ops = {
+	.open		= soc_pcm_open,
+	.close		= soc_codec_close,
+	.hw_params	= soc_pcm_hw_params,
+	.hw_free	= soc_pcm_hw_free,
+	.prepare	= soc_pcm_prepare,
+	.trigger	= soc_pcm_trigger,
+};
+
+#ifdef CONFIG_PM
+/* powers down audio subsystem for suspend */
+static int soc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	/* mute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 1);
+	}
+
+	if (machine->suspend_pre)
+		machine->suspend_pre(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+		if (platform->suspend)
+			platform->suspend(pdev, cpu_dai);
+	}
+
+	/* close any waiting streams and save state */
+	run_delayed_work(&socdev->delayed_work);
+	codec->suspend_dapm_state = codec->dapm_state;
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char *stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+	}
+
+	if (codec_dev->suspend)
+		codec_dev->suspend(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+	}
+
+	if (machine->suspend_post)
+		machine->suspend_post(pdev, state);
+
+	return 0;
+}
+
+/* powers up audio subsystem after a suspend */
+static int soc_resume(struct platform_device *pdev)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	if (machine->resume_pre)
+		machine->resume_pre(pdev);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+	}
+
+	if (codec_dev->resume)
+		codec_dev->resume(pdev);
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char* stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+	}
+
+	/* unmute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 0);
+	}
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+		if (platform->resume)
+			platform->resume(pdev, cpu_dai);
+	}
+
+	if (machine->resume_post)
+		machine->resume_post(pdev);
+
+	return 0;
+}
+
+#else
+#define soc_suspend	NULL
+#define soc_resume	NULL
+#endif
+
+/* probes a new socdev */
+static int soc_probe(struct platform_device *pdev)
+{
+	int ret = 0, i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (machine->probe) {
+		ret = machine->probe(pdev);
+		if(ret < 0)
+			return ret;
+	}
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->probe) {
+			ret = cpu_dai->probe(pdev);
+			if(ret < 0)
+				goto cpu_dai_err;
+		}
+	}
+
+	if (codec_dev->probe) {
+		ret = codec_dev->probe(pdev);
+		if(ret < 0)
+			goto cpu_dai_err;
+	}
+
+	if (platform->probe) {
+		ret = platform->probe(pdev);
+		if(ret < 0)
+			goto platform_err;
+	}
+
+	/* DAPM stream work */
+	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
+	return 0;
+
+platform_err:
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+cpu_dai_err:
+	for (i--; i >= 0; i--) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return ret;
+}
+
+/* removes a socdev */
+static int soc_remove(struct platform_device *pdev)
+{
+	int i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	run_delayed_work(&socdev->delayed_work);
+
+	if (platform->remove)
+		platform->remove(pdev);
+
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return 0;
+}
+
+/* ASoC platform driver */
+static struct platform_driver soc_driver = {
+	.driver		= {
+		.name		= "soc-audio",
+	},
+	.probe		= soc_probe,
+	.remove		= soc_remove,
+	.suspend	= soc_suspend,
+	.resume		= soc_resume,
+};
+
+/* create a new pcm */
+static int soc_new_pcm(struct snd_soc_device *socdev,
+	struct snd_soc_dai_link *dai_link, int num)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai = dai_link->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = dai_link->cpu_dai;
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_pcm *pcm;
+	char new_name[64];
+	int ret = 0, playback = 0, capture = 0;
+
+	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
+	if (rtd == NULL)
+		return -ENOMEM;
+
+	rtd->dai = dai_link;
+	rtd->socdev = socdev;
+	codec_dai->codec = socdev->codec;
+
+	/* check client and interface hw capabilities */
+	sprintf(new_name, "%s %s-%s-%d",dai_link->stream_name, codec_dai->name,
+		get_dai_name(cpu_dai->type), num);
+
+	if (codec_dai->playback.channels_min)
+		playback = 1;
+	if (codec_dai->capture.channels_min)
+		capture = 1;
+
+	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
+		capture, &pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_data = rtd;
+	soc_pcm_ops.mmap = socdev->platform->pcm_ops->mmap;
+	soc_pcm_ops.pointer = socdev->platform->pcm_ops->pointer;
+	soc_pcm_ops.ioctl = socdev->platform->pcm_ops->ioctl;
+	soc_pcm_ops.copy = socdev->platform->pcm_ops->copy;
+	soc_pcm_ops.silence = socdev->platform->pcm_ops->silence;
+	soc_pcm_ops.ack = socdev->platform->pcm_ops->ack;
+	soc_pcm_ops.page = socdev->platform->pcm_ops->page;
+
+	if (playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
+
+	if (capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
+
+	ret = socdev->platform->pcm_new(codec->card, codec_dai, pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_free = socdev->platform->pcm_free;
+	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
+		cpu_dai->name);
+	return ret;
+}
+
+/* codec register dump */
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	int i, step = 1, count = 0;
+
+	if (!codec->reg_cache_size)
+		return 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	count += sprintf(buf, "%s registers\n", codec->name);
+	for(i = 0; i < codec->reg_cache_size; i += step)
+		count += sprintf(buf + count, "%2x: %4x\n", i, codec->read(codec, i));
+
+	return count;
+}
+static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
+
+/**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
+{
+	mutex_lock(&codec->mutex);
+
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL) {
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&codec->mutex);
+	kfree(codec->ac97->bus);
+	kfree(codec->ac97);
+	codec->ac97 = NULL;
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+/**
+ * snd_soc_update_bits - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	if (change)
+		snd_soc_write(codec, reg, new);
+
+	mutex_unlock(&io_mutex);
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_update_bits);
+
+/**
+ * snd_soc_test_bits - test register for change
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Tests a register with a new value and checks if the new value is
+ * different from the old value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	mutex_unlock(&io_mutex);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_test_bits);
+
+/**
+ * snd_soc_new_pcms - create new sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Create a new sound card based upon the codec and interface pcms.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i;
+
+	mutex_lock(&codec->mutex);
+
+	/* register a sound card */
+	codec->card = snd_card_new(idx, xid, codec->owner, 0);
+	if (!codec->card) {
+		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
+			codec->name);
+		mutex_unlock(&codec->mutex);
+		return -ENODEV;
+	}
+
+	codec->card->dev = socdev->dev;
+	codec->card->private_data = codec;
+	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
+
+	/* create the pcms */
+	for(i = 0; i < machine->num_links; i++) {
+		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't create pcm %s\n",
+				machine->dai_link[i].stream_name);
+			mutex_unlock(&codec->mutex);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
+
+/**
+ * snd_soc_register_card - register sound card
+ * @socdev: the SoC audio device
+ *
+ * Register a SoC sound card. Also registers an AC97 device if the
+ * codec is AC97 for ad hoc devices.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_register_card(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i, ac97 = 0, err = 0;
+
+	mutex_lock(&codec->mutex);
+	for(i = 0; i < machine->num_links; i++) {
+		if (socdev->machine->dai_link[i].init) {
+			err = socdev->machine->dai_link[i].init(codec);
+			if (err < 0) {
+				printk(KERN_ERR "asoc: failed to init %s\n",
+					socdev->machine->dai_link[i].stream_name);
+				continue;
+			}
+		}
+		if (socdev->machine->dai_link[i].cpu_dai->type == SND_SOC_DAI_AC97)
+			ac97 = 1;
+	}
+	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
+		 "%s", machine->name);
+	snprintf(codec->card->longname, sizeof(codec->card->longname),
+		 "%s (%s)", machine->name, codec->name);
+
+	ret = snd_card_register(codec->card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to register soundcard for codec %s\n",
+				codec->name);
+		goto out;
+	}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (ac97) {
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: AC97 device register failed\n");
+			snd_card_free(codec->card);
+			goto out;
+		}
+	}
+#endif
+
+	err = snd_soc_dapm_sys_add(socdev->dev);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
+
+	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add codec sysfs entries\n");
+out:
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_card);
+
+/**
+ * snd_soc_free_pcms - free sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Frees sound card and pcms associated with the socdev.
+ * Also unregister the codec if it is an AC97 device.
+ */
+void snd_soc_free_pcms(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (codec->ac97)
+		soc_ac97_dev_unregister(codec);
+#endif
+
+	if (codec->card)
+		snd_card_free(codec->card);
+	device_remove_file(socdev->dev, &dev_attr_codec_reg);
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_pcms);
+
+/**
+ * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
+ * @substream: the pcm substream
+ * @hw: the hardware parameters
+ *
+ * Sets the substream runtime hardware parameters.
+ */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	runtime->hw.info = hw->info;
+	runtime->hw.formats = hw->formats;
+	runtime->hw.period_bytes_min = hw->period_bytes_min;
+	runtime->hw.period_bytes_max = hw->period_bytes_max;
+	runtime->hw.periods_min = hw->periods_min;
+	runtime->hw.periods_max = hw->periods_max;
+	runtime->hw.buffer_bytes_max = hw->buffer_bytes_max;
+	runtime->hw.fifo_size = hw->fifo_size;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
+
+/**
+ * snd_soc_cnew - create new control
+ * @_template: control template
+ * @data: control private data
+ * @lnng_name: control long name
+ *
+ * Create a new mixer control from a template control.
+ *
+ * Returns 0 for success, else error.
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name)
+{
+	struct snd_kcontrol_new template;
+
+	memcpy(&template, _template, sizeof(template));
+	if (long_name)
+		template.name = long_name;
+	template.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+	template.index = 0;
+
+	return snd_ctl_new1(&template, data);
+}
+EXPORT_SYMBOL_GPL(snd_soc_cnew);
+
+/**
+ * snd_soc_info_enum_double - enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double enumerated
+ * mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
+
+/**
+ * snd_soc_get_enum_double - enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
+
+/**
+ * snd_soc_put_enum_double - enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val;
+	unsigned short mask, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	val = ucontrol->value.enumerated.item[0] << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	return snd_soc_update_bits(codec, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
+
+/**
+ * snd_soc_info_enum_ext - external enumerated single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about an external enumerated
+ * single mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
+
+/**
+ * snd_soc_info_volsw_ext - external single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = kcontrol->private_value;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
+
+/**
+ * snd_soc_info_bool_ext - external single boolean mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single boolean external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_bool_ext);
+
+/**
+ * snd_soc_info_volsw - single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = shift == rshift ? 1 : 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
+
+/**
+ * snd_soc_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
+
+/**
+ * snd_soc_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+	err = snd_soc_update_bits(codec, reg, val_mask, val);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
+
+/**
+ * snd_soc_info_volsw_2r - double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double mixer control that
+ * spans 2 codec registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
+
+/**
+ * snd_soc_get_volsw_2r - double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	ucontrol->value.integer.value[1] =
+		(snd_soc_read(codec, reg2) >> shift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] =
+			mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
+
+/**
+ * snd_soc_put_volsw_2r - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] & mask);
+	val2 = (ucontrol->value.integer.value[1] & mask);
+
+	if (invert) {
+		val = mask - val;
+		val2 = mask - val2;
+	}
+
+	val = val << shift;
+	val2 = val2 << shift;
+
+	if ((err = snd_soc_update_bits(codec, reg, val_mask, val)) < 0)
+		return err;
+
+	err = snd_soc_update_bits(codec, reg2, val_mask, val2);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
+
+static int __devinit snd_soc_init(void)
+{
+	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);
+	return platform_driver_register(&soc_driver);
+}
+
+static void snd_soc_exit(void)
+{
+ 	platform_driver_unregister(&soc_driver);
+}
+
+module_init(snd_soc_init);
+module_exit(snd_soc_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC Core");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/at91/at91-i2s.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/at91-i2s.h	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,27 @@
+/*
+ * at91-i2s.h - ALSA I2S interface for the Atmel AT91 SoC
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Jan 9, 2007
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _AT91_I2S_H
+#define _AT91_I2S_H
+
+/* I2S system clock ids */
+#define AT91_SYSCLK_MCK		0 /* SSC uses AT91 MCK as system clock */
+
+/* I2S divider ids */
+#define AT91SSC_CMR_DIV		0 /* MCK divider for BCLK */
+#define AT91SSC_TCMR_PERIOD	1 /* BCLK divider for transmit FS */
+#define AT91SSC_RCMR_PERIOD	2 /* BCLK divider for receive FS */
+
+extern struct snd_soc_cpu_dai at91_i2s_dai[];
+
+#endif /* _AT91_I2S_H */
+
--- linux-2.6.18.noarch/sound/soc/at91/Makefile.orig	2007-06-05 17:29:22.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/Makefile	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,11 @@
+# AT91 Platform Support
+snd-soc-at91-objs := at91-pcm.o
+snd-soc-at91-i2s-objs := at91-i2s.o
+
+obj-$(CONFIG_SND_AT91_SOC) += snd-soc-at91.o
+obj-$(CONFIG_SND_AT91_SOC_I2S) += snd-soc-at91-i2s.o
+
+# AT91 Machine Support
+snd-soc-eti-b1-wm8731-objs := eti_b1_wm8731.o
+
+obj-$(CONFIG_SND_AT91_SOC_ETI_B1_WM8731) += snd-soc-eti-b1-wm8731.o
--- linux-2.6.18.noarch/sound/soc/at91/at91-pcm.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/at91-pcm.h	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,72 @@
+/*
+ * at91-pcm.h - ALSA PCM interface for the Atmel AT91 SoC
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Mar 3, 2006
+ *
+ * Based on pxa2xx-pcm.h by:
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _AT91_PCM_H
+#define _AT91_PCM_H
+
+#include <asm/arch/hardware.h>
+
+struct at91_ssc_periph {
+	void __iomem	*base;
+	u32		pid;
+};
+
+/*
+ * Registers and status bits that are required by the PCM driver.
+ */
+struct at91_pdc_regs {
+	unsigned int	xpr;		/* PDC recv/trans pointer */
+	unsigned int	xcr;		/* PDC recv/trans counter */
+	unsigned int	xnpr;		/* PDC next recv/trans pointer */
+	unsigned int	xncr;		/* PDC next recv/trans counter */
+	unsigned int	ptcr;		/* PDC transfer control */
+};
+
+struct at91_ssc_mask {
+	u32	ssc_enable;		/* SSC recv/trans enable */
+	u32	ssc_disable;		/* SSC recv/trans disable */
+	u32	ssc_endx;		/* SSC ENDTX or ENDRX */
+	u32	ssc_endbuf;		/* SSC TXBUFE or RXBUFF */
+	u32	pdc_enable;		/* PDC recv/trans enable */
+	u32	pdc_disable;		/* PDC recv/trans disable */
+};
+
+/*
+ * This structure, shared between the PCM driver and the interface,
+ * contains all information required by the PCM driver to perform the
+ * PDC DMA operation.  All fields except dma_intr_handler() are initialized
+ * by the interface.  The dms_intr_handler() pointer is set by the PCM
+ * driver and called by the interface SSC interrupt handler if it is
+ * non-NULL.
+ */
+struct at91_pcm_dma_params {
+	char *name;			/* stream identifier */
+	int pdc_xfer_size;		/* PDC counter increment in bytes */
+	void __iomem *ssc_base;		/* SSC base address */
+	struct at91_pdc_regs *pdc; /* PDC receive or transmit registers */
+	struct at91_ssc_mask *mask;/* SSC & PDC status bits */
+	struct snd_pcm_substream *substream;
+	void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
+};
+
+extern struct snd_soc_platform at91_soc_platform;
+
+#define at91_ssc_read(a)	((unsigned long) __raw_readl(a))
+#define at91_ssc_write(a,v)	__raw_writel((v),(a))
+
+#endif /* _AT91_PCM_H */
--- linux-2.6.18.noarch/sound/soc/at91/soc-dapm.c.orig	2007-06-05 19:57:34.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/soc-dapm.c	2007-06-05 19:52:44.000000000 -0400
@@ -0,0 +1,1323 @@
+/*
+ * soc-dapm.c  --  ALSA SoC Dynamic Audio Power Management
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Implemented path power domain.
+ *    18th Dec 2005   Implemented machine and stream level power domain.
+ *
+ *  Features:
+ *    o Changes power status of internal codec blocks depending on the
+ *      dynamic configuration of codec internal audio paths and active
+ *      DAC's/ADC's.
+ *    o Platform power domain - can support external components i.e. amps and
+ *      mic/meadphone insertion events.
+ *    o Automatic Mic Bias support
+ *    o Jack insertion power event initiation - e.g. hp insertion will enable
+ *      sinks, dacs, etc
+ *    o Delayed powerdown of audio susbsytem to reduce pops between a quick
+ *      device reopen.
+ *
+ *  Todo:
+ *    o DAPM power change sequencing - allow for configurable per
+ *      codec sequences.
+ *    o Support for analogue bias optimisation.
+ *    o Support for reduced codec oversampling rates.
+ *    o Support for reduced codec bias currents.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/jiffies.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define DAPM_DEBUG 0
+#if DAPM_DEBUG
+#define dump_dapm(codec, action) dbg_dump_dapm(codec, action)
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dump_dapm(codec, action)
+#define dbg(format, arg...)
+#endif
+
+#define POP_DEBUG 0
+#if POP_DEBUG
+#define POP_TIME 500 /* 500 msecs - change if pop debug is too fast */
+#define pop_wait(time) schedule_timeout_interruptible(msecs_to_jiffies(time))
+#define pop_dbg(format, arg...) printk(format, ## arg); pop_wait(POP_TIME)
+#else
+#define pop_dbg(format, arg...)
+#define pop_wait(time)
+#endif
+
+/* dapm power sequences - make this per codec in the future */
+static int dapm_up_seq[] = {
+	snd_soc_dapm_pre, snd_soc_dapm_micbias, snd_soc_dapm_mic,
+	snd_soc_dapm_mux, snd_soc_dapm_dac, snd_soc_dapm_mixer, snd_soc_dapm_pga,
+	snd_soc_dapm_adc, snd_soc_dapm_hp, snd_soc_dapm_spk, snd_soc_dapm_post
+};
+static int dapm_down_seq[] = {
+	snd_soc_dapm_pre, snd_soc_dapm_adc, snd_soc_dapm_hp, snd_soc_dapm_spk,
+	snd_soc_dapm_pga, snd_soc_dapm_mixer, snd_soc_dapm_dac, snd_soc_dapm_mic,
+	snd_soc_dapm_micbias, snd_soc_dapm_mux, snd_soc_dapm_post
+};
+
+static int dapm_status = 1;
+module_param(dapm_status, int, 0);
+MODULE_PARM_DESC(dapm_status, "enable DPM sysfs entries");
+
+/* create a new dapm widget */
+static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
+	const struct snd_soc_dapm_widget *_widget)
+{
+	return kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);
+}
+
+/* set up initial codec paths */
+static void dapm_set_path_status(struct snd_soc_dapm_widget *w,
+	struct snd_soc_dapm_path *p, int i)
+{
+	switch (w->id) {
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer: {
+		int val;
+		int reg = w->kcontrols[i].private_value & 0xff;
+		int shift = (w->kcontrols[i].private_value >> 8) & 0x0f;
+		int mask = (w->kcontrols[i].private_value >> 16) & 0xff;
+		int invert = (w->kcontrols[i].private_value >> 24) & 0x01;
+
+		val = snd_soc_read(w->codec, reg);
+		val = (val >> shift) & mask;
+
+		if ((invert && !val) || (!invert && val))
+			p->connect = 1;
+		else
+			p->connect = 0;
+	}
+	break;
+	case snd_soc_dapm_mux: {
+		struct soc_enum *e = (struct soc_enum *)w->kcontrols[i].private_value;
+		int val, item, bitmask;
+
+		for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+		val = snd_soc_read(w->codec, e->reg);
+		item = (val >> e->shift_l) & (bitmask - 1);
+
+		p->connect = 0;
+		for (i = 0; i < e->mask; i++) {
+			if (!(strcmp(p->name, e->texts[i])) && item == i)
+				p->connect = 1;
+		}
+	}
+	break;
+	/* does not effect routing - always connected */
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+		p->connect = 1;
+	break;
+	/* does effect routing - dynamically connected */
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+		p->connect = 0;
+	break;
+	}
+}
+
+/* connect mux widget to it's interconnecting audio paths */
+static int dapm_connect_mux(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name,
+	const struct snd_kcontrol_new *kcontrol)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	int i;
+
+	for (i = 0; i < e->mask; i++) {
+		if (!(strcmp(control_name, e->texts[i]))) {
+			list_add(&path->list, &codec->dapm_paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = (char*)e->texts[i];
+			dapm_set_path_status(dest, path, 0);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+/* connect mixer widget to it's interconnecting audio paths */
+static int dapm_connect_mixer(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name)
+{
+	int i;
+
+	/* search for mixer kcontrol */
+	for (i = 0; i < dest->num_kcontrols; i++) {
+		if (!strcmp(control_name, dest->kcontrols[i].name)) {
+			list_add(&path->list, &codec->dapm_paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = dest->kcontrols[i].name;
+			dapm_set_path_status(dest, path, i);
+			return 0;
+		}
+	}
+	return -ENODEV;
+}
+
+/* update dapm codec register bits */
+static int dapm_update_bits(struct snd_soc_dapm_widget *widget)
+{
+	int change, power;
+	unsigned short old, new;
+	struct snd_soc_codec *codec = widget->codec;
+
+	/* check for valid widgets */
+	if (widget->reg < 0 || widget->id == snd_soc_dapm_input ||
+		widget->id == snd_soc_dapm_output ||
+		widget->id == snd_soc_dapm_hp ||
+		widget->id == snd_soc_dapm_mic ||
+		widget->id == snd_soc_dapm_line ||
+		widget->id == snd_soc_dapm_spk)
+		return 0;
+
+	power = widget->power;
+	if (widget->invert)
+		power = (power ? 0:1);
+
+	old = snd_soc_read(codec, widget->reg);
+	new = (old & ~(0x1 << widget->shift)) | (power << widget->shift);
+
+	change = old != new;
+	if (change) {
+		pop_dbg("pop test %s : %s in %d ms\n", widget->name,
+			widget->power ? "on" : "off", POP_TIME);
+		snd_soc_write(codec, widget->reg, new);
+		pop_wait(POP_TIME);
+	}
+	dbg("reg old %x new %x change %d\n", old, new, change);
+	return change;
+}
+
+/* ramps the volume up or down to minimise pops before or after a
+ * DAPM power event */
+static int dapm_set_pga(struct snd_soc_dapm_widget *widget, int power)
+{
+	const struct snd_kcontrol_new *k = widget->kcontrols;
+
+	if (widget->muted && !power)
+		return 0;
+	if (!widget->muted && power)
+		return 0;
+
+	if (widget->num_kcontrols && k) {
+		int reg = k->private_value & 0xff;
+		int shift = (k->private_value >> 8) & 0x0f;
+		int mask = (k->private_value >> 16) & 0xff;
+		int invert = (k->private_value >> 24) & 0x01;
+
+		if (power) {
+			int i;
+			/* power up has happended, increase volume to last level */
+			if (invert) {
+				for (i = mask; i > widget->saved_value; i--)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			} else {
+				for (i = 0; i < widget->saved_value; i++)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			}
+			widget->muted = 0;
+		} else {
+			/* power down is about to occur, decrease volume to mute */
+			int val = snd_soc_read(widget->codec, reg);
+			int i = widget->saved_value = (val >> shift) & mask;
+			if (invert) {
+				for (; i < mask; i++)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			} else {
+				for (; i > 0; i--)
+					snd_soc_update_bits(widget->codec, reg, mask, i);
+			}
+			widget->muted = 1;
+		}
+	}
+	return 0;
+}
+
+/* create new dapm mixer control */
+static int dapm_new_mixer(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	int i, ret = 0;
+	char name[32];
+	struct snd_soc_dapm_path *path;
+
+	/* add kcontrol */
+	for (i = 0; i < w->num_kcontrols; i++) {
+
+		/* match name */
+		list_for_each_entry(path, &w->sources, list_sink) {
+
+			/* mixer/mux paths name must match control name */
+			if (path->name != (char*)w->kcontrols[i].name)
+				continue;
+
+			/* add dapm control with long name */
+			snprintf(name, 32, "%s %s", w->name, w->kcontrols[i].name);
+			path->long_name = kstrdup (name, GFP_KERNEL);
+			if (path->long_name == NULL)
+				return -ENOMEM;
+
+			path->kcontrol = snd_soc_cnew(&w->kcontrols[i], w,
+				path->long_name);
+			ret = snd_ctl_add(codec->card, path->kcontrol);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to add dapm kcontrol %s\n",
+						path->long_name);
+				kfree(path->long_name);
+				path->long_name = NULL;
+				return ret;
+			}
+		}
+	}
+	return ret;
+}
+
+/* create new dapm mux control */
+static int dapm_new_mux(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_soc_dapm_path *path = NULL;
+	struct snd_kcontrol *kcontrol;
+	int ret = 0;
+
+	if (!w->num_kcontrols) {
+		printk(KERN_ERR "asoc: mux %s has no controls\n", w->name);
+		return -EINVAL;
+	}
+
+	kcontrol = snd_soc_cnew(&w->kcontrols[0], w, w->name);
+	ret = snd_ctl_add(codec->card, kcontrol);
+	if (ret < 0)
+		goto err;
+
+	list_for_each_entry(path, &w->sources, list_sink)
+		path->kcontrol = kcontrol;
+
+	return ret;
+
+err:
+	printk(KERN_ERR "asoc: failed to add kcontrol %s\n", w->name);
+	return ret;
+}
+
+/* create new dapm volume control */
+static int dapm_new_pga(struct snd_soc_codec *codec,
+	struct snd_soc_dapm_widget *w)
+{
+	struct snd_kcontrol *kcontrol;
+	int ret = 0;
+
+	if (!w->num_kcontrols)
+		return -EINVAL;
+
+	kcontrol = snd_soc_cnew(&w->kcontrols[0], w, w->name);
+	ret = snd_ctl_add(codec->card, kcontrol);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to add kcontrol %s\n", w->name);
+		return ret;
+	}
+
+	return ret;
+}
+
+/* reset 'walked' bit for each dapm path */
+static inline void dapm_clear_walk(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, &codec->dapm_paths, list)
+		p->walked = 0;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * output widget. Returns number of complete paths.
+ */
+static int is_connected_output_ep(struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	if (widget->id == snd_soc_dapm_adc && widget->active)
+		return 1;
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_output && !widget->ext)
+			return 1;
+
+		/* connected jack or spk ? */
+		if (widget->id == snd_soc_dapm_hp || widget->id == snd_soc_dapm_spk ||
+			widget->id == snd_soc_dapm_line)
+			return 1;
+	}
+
+	list_for_each_entry(path, &widget->sinks, list_source) {
+		if (path->walked)
+			continue;
+
+		if (path->sink && path->connect) {
+			path->walked = 1;
+			con += is_connected_output_ep(path->sink);
+		}
+	}
+
+	return con;
+}
+
+/*
+ * Recursively check for a completed path to an active or physically connected
+ * input widget. Returns number of complete paths.
+ */
+static int is_connected_input_ep(struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_path *path;
+	int con = 0;
+
+	/* active stream ? */
+	if (widget->id == snd_soc_dapm_dac && widget->active)
+		return 1;
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_input && !widget->ext)
+			return 1;
+
+		/* connected VMID/Bias for lower pops */
+		if (widget->id == snd_soc_dapm_vmid)
+			return 1;
+
+		/* connected jack ? */
+		if (widget->id == snd_soc_dapm_mic || widget->id == snd_soc_dapm_line)
+			return 1;
+	}
+
+	list_for_each_entry(path, &widget->sources, list_sink) {
+		if (path->walked)
+			continue;
+
+		if (path->source && path->connect) {
+			path->walked = 1;
+			con += is_connected_input_ep(path->source);
+		}
+	}
+
+	return con;
+}
+
+/*
+ * Scan each dapm widget for complete audio path.
+ * A complete path is a route that has valid endpoints i.e.:-
+ *
+ *  o DAC to output pin.
+ *  o Input Pin to ADC.
+ *  o Input pin to Output pin (bypass, sidetone)
+ *  o DAC to ADC (loopback).
+ */
+static int dapm_power_widgets(struct snd_soc_codec *codec, int event)
+{
+	struct snd_soc_dapm_widget *w;
+	int in, out, i, c = 1, *seq = NULL, ret = 0, power_change, power;
+
+	/* do we have a sequenced stream event */
+	if (event == SND_SOC_DAPM_STREAM_START) {
+		c = ARRAY_SIZE(dapm_up_seq);
+		seq = dapm_up_seq;
+	} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+		c = ARRAY_SIZE(dapm_down_seq);
+		seq = dapm_down_seq;
+	}
+
+	for(i = 0; i < c; i++) {
+		list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+			/* is widget in stream order */
+			if (seq && seq[i] && w->id != seq[i])
+				continue;
+
+			/* vmid - no action */
+			if (w->id == snd_soc_dapm_vmid)
+				continue;
+
+			/* active ADC */
+			if (w->id == snd_soc_dapm_adc && w->active) {
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = (in != 0) ? 1 : 0;
+				dapm_update_bits(w);
+				continue;
+			}
+
+			/* active DAC */
+			if (w->id == snd_soc_dapm_dac && w->active) {
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = (out != 0) ? 1 : 0;
+				dapm_update_bits(w);
+				continue;
+			}
+
+			/* programmable gain/attenuation */
+			if (w->id == snd_soc_dapm_pga) {
+				int on;
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				w->power = on = (out != 0 && in != 0) ? 1 : 0;
+
+				if (!on)
+					dapm_set_pga(w, on); /* lower volume to reduce pops */
+				dapm_update_bits(w);
+				if (on)
+					dapm_set_pga(w, on); /* restore volume from zero */
+
+				continue;
+			}
+
+			/* pre and post event widgets */
+			if (w->id == snd_soc_dapm_pre) {
+				if (!w->event)
+					continue;
+
+				if (event == SND_SOC_DAPM_STREAM_START) {
+					ret = w->event(w, SND_SOC_DAPM_PRE_PMU);
+					if (ret < 0)
+						return ret;
+				} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+					ret = w->event(w, SND_SOC_DAPM_PRE_PMD);
+					if (ret < 0)
+						return ret;
+				}
+				continue;
+			}
+			if (w->id == snd_soc_dapm_post) {
+				if (!w->event)
+					continue;
+
+				if (event == SND_SOC_DAPM_STREAM_START) {
+					ret = w->event(w, SND_SOC_DAPM_POST_PMU);
+					if (ret < 0)
+						return ret;
+				} else if (event == SND_SOC_DAPM_STREAM_STOP) {
+					ret = w->event(w, SND_SOC_DAPM_POST_PMD);
+					if (ret < 0)
+						return ret;
+				}
+				continue;
+			}
+
+			/* all other widgets */
+			in = is_connected_input_ep(w);
+			dapm_clear_walk(w->codec);
+			out = is_connected_output_ep(w);
+			dapm_clear_walk(w->codec);
+			power = (out != 0 && in != 0) ? 1 : 0;
+			power_change = (w->power == power) ? 0: 1;
+			w->power = power;
+
+			/* call any power change event handlers */
+			if (power_change) {
+				if (w->event) {
+					dbg("power %s event for %s flags %x\n",
+						w->power ? "on" : "off", w->name, w->event_flags);
+					if (power) {
+						/* power up event */
+						if (w->event_flags & SND_SOC_DAPM_PRE_PMU) {
+							ret = w->event(w, SND_SOC_DAPM_PRE_PMU);
+							if (ret < 0)
+								return ret;
+						}
+						dapm_update_bits(w);
+						if (w->event_flags & SND_SOC_DAPM_POST_PMU){
+							ret = w->event(w, SND_SOC_DAPM_POST_PMU);
+							if (ret < 0)
+								return ret;
+						}
+					} else {
+						/* power down event */
+						if (w->event_flags & SND_SOC_DAPM_PRE_PMD) {
+							ret = w->event(w, SND_SOC_DAPM_PRE_PMD);
+							if (ret < 0)
+								return ret;
+						}
+						dapm_update_bits(w);
+						if (w->event_flags & SND_SOC_DAPM_POST_PMD) {
+							ret = w->event(w, SND_SOC_DAPM_POST_PMD);
+							if (ret < 0)
+								return ret;
+						}
+					}
+				} else
+					/* no event handler */
+					dapm_update_bits(w);
+			}
+		}
+	}
+
+	return ret;
+}
+
+#if DAPM_DEBUG
+static void dbg_dump_dapm(struct snd_soc_codec* codec, const char *action)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_path *p = NULL;
+	int in, out;
+
+	printk("DAPM %s %s\n", codec->name, action);
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		/* only display widgets that effect routing */
+		switch (w->id) {
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+		case snd_soc_dapm_vmid:
+			continue;
+		case snd_soc_dapm_mux:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_mixer:
+			if (w->name) {
+				in = is_connected_input_ep(w);
+				dapm_clear_walk(w->codec);
+				out = is_connected_output_ep(w);
+				dapm_clear_walk(w->codec);
+				printk("%s: %s  in %d out %d\n", w->name,
+					w->power ? "On":"Off",in, out);
+
+				list_for_each_entry(p, &w->sources, list_sink) {
+					if (p->connect)
+						printk(" in  %s %s\n", p->name ? p->name : "static",
+							p->source->name);
+				}
+				list_for_each_entry(p, &w->sinks, list_source) {
+					if (p->connect)
+						printk(" out %s %s\n", p->name ? p->name : "static",
+							p->sink->name);
+				}
+			}
+		break;
+		}
+	}
+}
+#endif
+
+/* test and update the power status of a mux widget */
+static int dapm_mux_update_power(struct snd_soc_dapm_widget *widget,
+				 struct snd_kcontrol *kcontrol, int mask,
+				 int val, struct soc_enum* e)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	if (widget->id != snd_soc_dapm_mux)
+		return -ENODEV;
+
+	if (!snd_soc_test_bits(widget->codec, e->reg, mask, val))
+		return 0;
+
+	/* find dapm widget path assoc with kcontrol */
+	list_for_each_entry(path, &widget->codec->dapm_paths, list) {
+		if (path->kcontrol != kcontrol)
+			continue;
+
+		if (!path->name || ! e->texts[val])
+			continue;
+
+		found = 1;
+		/* we now need to match the string in the enum to the path */
+		if (!(strcmp(path->name, e->texts[val])))
+			path->connect = 1; /* new connection */
+		else
+			path->connect = 0; /* old connection must be powered down */
+	}
+
+	if (found)
+		dapm_power_widgets(widget->codec, SND_SOC_DAPM_STREAM_NOP);
+
+	return 0;
+}
+
+/* test and update the power status of a mixer widget */
+static int dapm_mixer_update_power(struct snd_soc_dapm_widget *widget,
+				   struct snd_kcontrol *kcontrol, int reg,
+				   int val_mask, int val, int invert)
+{
+	struct snd_soc_dapm_path *path;
+	int found = 0;
+
+	if (widget->id != snd_soc_dapm_mixer)
+		return -ENODEV;
+
+	if (!snd_soc_test_bits(widget->codec, reg, val_mask, val))
+		return 0;
+
+	/* find dapm widget path assoc with kcontrol */
+	list_for_each_entry(path, &widget->codec->dapm_paths, list) {
+		if (path->kcontrol != kcontrol)
+			continue;
+
+		/* found, now check type */
+		found = 1;
+		if (val)
+			/* new connection */
+			path->connect = invert ? 0:1;
+		else
+			/* old connection must be powered down */
+			path->connect = invert ? 1:0;
+		break;
+	}
+
+	if (found)
+		dapm_power_widgets(widget->codec, SND_SOC_DAPM_STREAM_NOP);
+
+	return 0;
+}
+
+/* show dapm widget status in sys fs */
+static ssize_t dapm_widget_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	struct snd_soc_dapm_widget *w;
+	int count = 0;
+	char *state = "not set";
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		/* only display widgets that burnm power */
+		switch (w->id) {
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_pga:
+		case snd_soc_dapm_mixer:
+			if (w->name)
+				count += sprintf(buf + count, "%s: %s\n",
+					w->name, w->power ? "On":"Off");
+		break;
+		default:
+		break;
+		}
+	}
+
+	switch(codec->dapm_state){
+	case SNDRV_CTL_POWER_D0:
+		state = "D0";
+		break;
+	case SNDRV_CTL_POWER_D1:
+		state = "D1";
+		break;
+	case SNDRV_CTL_POWER_D2:
+		state = "D2";
+		break;
+	case SNDRV_CTL_POWER_D3hot:
+		state = "D3hot";
+		break;
+	case SNDRV_CTL_POWER_D3cold:
+		state = "D3cold";
+		break;
+	}
+	count += sprintf(buf + count, "PM State: %s\n", state);
+
+	return count;
+}
+
+static DEVICE_ATTR(dapm_widget, 0444, dapm_widget_show, NULL);
+
+int snd_soc_dapm_sys_add(struct device *dev)
+{
+	int ret = 0;
+
+	if (dapm_status)
+		ret = device_create_file(dev, &dev_attr_dapm_widget);
+
+	return ret;
+}
+
+static void snd_soc_dapm_sys_remove(struct device *dev)
+{
+	if (dapm_status)
+		device_remove_file(dev, &dev_attr_dapm_widget);
+}
+
+/* free all dapm widgets and resources */
+static void dapm_free_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_widget *w, *next_w;
+	struct snd_soc_dapm_path *p, *next_p;
+
+	list_for_each_entry_safe(w, next_w, &codec->dapm_widgets, list) {
+		list_del(&w->list);
+		kfree(w);
+	}
+
+	list_for_each_entry_safe(p, next_p, &codec->dapm_paths, list) {
+		list_del(&p->list);
+		kfree(p->long_name);
+		kfree(p);
+	}
+}
+
+/**
+ * snd_soc_dapm_sync_endpoints - scan and power dapm paths
+ * @codec: audio codec
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec)
+{
+	return dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync_endpoints);
+
+/**
+ * snd_soc_dapm_connect_input - connect dapm widgets
+ * @codec: audio codec
+ * @sink: name of target widget
+ * @control: mixer control name
+ * @source: name of source name
+ *
+ * Connects 2 dapm widgets together via a named audio path. The sink is
+ * the widget receiving the audio signal, whilst the source is the sender
+ * of the audio signal.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_connect_input(struct snd_soc_codec *codec, const char *sink,
+	const char * control, const char *source)
+{
+	struct snd_soc_dapm_path *path;
+	struct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w;
+	int ret = 0;
+
+	/* find src and dest widgets */
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+
+		if (!wsink && !(strcmp(w->name, sink))) {
+			wsink = w;
+			continue;
+		}
+		if (!wsource && !(strcmp(w->name, source))) {
+			wsource = w;
+		}
+	}
+
+	if (wsource == NULL || wsink == NULL)
+		return -ENODEV;
+
+	path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);
+	if (!path)
+		return -ENOMEM;
+
+	path->source = wsource;
+	path->sink = wsink;
+	INIT_LIST_HEAD(&path->list);
+	INIT_LIST_HEAD(&path->list_source);
+	INIT_LIST_HEAD(&path->list_sink);
+
+	/* check for external widgets */
+	if (wsink->id == snd_soc_dapm_input) {
+		if (wsource->id == snd_soc_dapm_micbias ||
+			wsource->id == snd_soc_dapm_mic ||
+			wsink->id == snd_soc_dapm_line)
+			wsink->ext = 1;
+	}
+	if (wsource->id == snd_soc_dapm_output) {
+		if (wsink->id == snd_soc_dapm_spk ||
+			wsink->id == snd_soc_dapm_hp ||
+			wsink->id == snd_soc_dapm_line)
+			wsource->ext = 1;
+	}
+
+	/* connect static paths */
+	if (control == NULL) {
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	}
+
+	/* connect dynamic paths */
+	switch(wsink->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	case snd_soc_dapm_mux:
+		ret = dapm_connect_mux(codec, wsource, wsink, path, control,
+			&wsink->kcontrols[0]);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+		ret = dapm_connect_mixer(codec, wsource, wsink, path, control);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_spk:
+		list_add(&path->list, &codec->dapm_paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 0;
+		return 0;
+	}
+	return 0;
+
+err:
+	printk(KERN_WARNING "asoc: no dapm match for %s --> %s --> %s\n", source,
+		control, sink);
+	kfree(path);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_connect_input);
+
+/**
+ * snd_soc_dapm_new_widgets - add new dapm widgets
+ * @codec: audio codec
+ *
+ * Checks the codec for any new dapm widgets and creates them if found.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_new_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_widget *w;
+
+	mutex_lock(&codec->mutex);
+	list_for_each_entry(w, &codec->dapm_widgets, list)
+	{
+		if (w->new)
+			continue;
+
+		switch(w->id) {
+		case snd_soc_dapm_switch:
+		case snd_soc_dapm_mixer:
+			dapm_new_mixer(codec, w);
+			break;
+		case snd_soc_dapm_mux:
+			dapm_new_mux(codec, w);
+			break;
+		case snd_soc_dapm_adc:
+		case snd_soc_dapm_dac:
+		case snd_soc_dapm_pga:
+			dapm_new_pga(codec, w);
+			break;
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_output:
+		case snd_soc_dapm_micbias:
+		case snd_soc_dapm_spk:
+		case snd_soc_dapm_hp:
+		case snd_soc_dapm_mic:
+		case snd_soc_dapm_line:
+		case snd_soc_dapm_vmid:
+		case snd_soc_dapm_pre:
+		case snd_soc_dapm_post:
+			break;
+		}
+		w->new = 1;
+	}
+
+	dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_widgets);
+
+/**
+ * snd_soc_dapm_get_volsw - dapm mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	/* return the saved value if we are powered down */
+	if (widget->id == snd_soc_dapm_pga && !widget->power) {
+		ucontrol->value.integer.value[0] = widget->saved_value;
+		return 0;
+	}
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(widget->codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(widget->codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_volsw);
+
+/**
+ * snd_soc_dapm_put_volsw - dapm mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a dapm mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	unsigned short val, val2, val_mask;
+	int ret;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+
+	mutex_lock(&widget->codec->mutex);
+	widget->value = val;
+
+	/* save volume value if the widget is powered down */
+	if (widget->id == snd_soc_dapm_pga && !widget->power) {
+		widget->saved_value = val;
+		mutex_unlock(&widget->codec->mutex);
+		return 1;
+	}
+
+	dapm_mixer_update_power(widget, kcontrol, reg, val_mask, val, invert);
+	if (widget->event) {
+		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
+			ret = widget->event(widget, SND_SOC_DAPM_PRE_REG);
+			if (ret < 0)
+				goto out;
+		}
+		ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+		if (widget->event_flags & SND_SOC_DAPM_POST_REG)
+			ret = widget->event(widget, SND_SOC_DAPM_POST_REG);
+	} else
+		ret = snd_soc_update_bits(widget->codec, reg, val_mask, val);
+
+out:
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw);
+
+/**
+ * snd_soc_dapm_get_enum_double - dapm enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(widget->codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);
+
+/**
+ * snd_soc_dapm_put_enum_double - dapm enumerated double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a dapm enumerated double mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, mux;
+	unsigned short mask, bitmask;
+	int ret = 0;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	mux = ucontrol->value.enumerated.item[0];
+	val = mux << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	mutex_lock(&widget->codec->mutex);
+	widget->value = val;
+	dapm_mux_update_power(widget, kcontrol, mask, mux, e);
+	if (widget->event) {
+		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
+			ret = widget->event(widget, SND_SOC_DAPM_PRE_REG);
+			if (ret < 0)
+				goto out;
+		}
+		ret = snd_soc_update_bits(widget->codec, e->reg, mask, val);
+		if (widget->event_flags & SND_SOC_DAPM_POST_REG)
+			ret = widget->event(widget, SND_SOC_DAPM_POST_REG);
+	} else
+		ret = snd_soc_update_bits(widget->codec, e->reg, mask, val);
+
+out:
+	mutex_unlock(&widget->codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_enum_double);
+
+/**
+ * snd_soc_dapm_new_control - create new dapm control
+ * @codec: audio codec
+ * @widget: widget template
+ *
+ * Creates a new dapm control based upon the template.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_new_control(struct snd_soc_codec *codec,
+	const struct snd_soc_dapm_widget *widget)
+{
+	struct snd_soc_dapm_widget *w;
+
+	if ((w = dapm_cnew_widget(widget)) == NULL)
+		return -ENOMEM;
+
+	w->codec = codec;
+	INIT_LIST_HEAD(&w->sources);
+	INIT_LIST_HEAD(&w->sinks);
+	INIT_LIST_HEAD(&w->list);
+	list_add(&w->list, &codec->dapm_widgets);
+
+	/* machine layer set ups unconnected pins and insertions */
+	w->connected = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_new_control);
+
+/**
+ * snd_soc_dapm_stream_event - send a stream event to the dapm core
+ * @codec: audio codec
+ * @stream: stream name
+ * @event: stream event
+ *
+ * Sends a stream event to the dapm core. The core then makes any
+ * necessary widget power changes.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_stream_event(struct snd_soc_codec *codec,
+	char *stream, int event)
+{
+	struct snd_soc_dapm_widget *w;
+
+	if (stream == NULL)
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	list_for_each_entry(w, &codec->dapm_widgets, list)
+	{
+		if (!w->sname)
+			continue;
+		dbg("widget %s\n %s stream %s event %d\n", w->name, w->sname,
+			stream, event);
+		if (strstr(w->sname, stream)) {
+			switch(event) {
+			case SND_SOC_DAPM_STREAM_START:
+				w->active = 1;
+				break;
+			case SND_SOC_DAPM_STREAM_STOP:
+				w->active = 0;
+				break;
+			case SND_SOC_DAPM_STREAM_SUSPEND:
+				if (w->active)
+					w->suspend = 1;
+				w->active = 0;
+				break;
+			case SND_SOC_DAPM_STREAM_RESUME:
+				if (w->suspend) {
+					w->active = 1;
+					w->suspend = 0;
+				}
+				break;
+			case SND_SOC_DAPM_STREAM_PAUSE_PUSH:
+				break;
+			case SND_SOC_DAPM_STREAM_PAUSE_RELEASE:
+				break;
+			}
+		}
+	}
+	mutex_unlock(&codec->mutex);
+
+	dapm_power_widgets(codec, event);
+	dump_dapm(codec, __FUNCTION__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_stream_event);
+
+/**
+ * snd_soc_dapm_set_endpoint - set audio endpoint status
+ * @codec: audio codec
+ * @endpoint: audio signal endpoint (or start point)
+ * @status: point status
+ *
+ * Set audio endpoint status - connected or disconnected.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *endpoint, int status)
+{
+	struct snd_soc_dapm_widget *w;
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+		if (!strcmp(w->name, endpoint)) {
+			w->connected = status;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_set_endpoint);
+
+/**
+ * snd_soc_dapm_free - free dapm resources
+ * @socdev: SoC device
+ *
+ * Free all dapm widgets and resources.
+ */
+void snd_soc_dapm_free(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	snd_soc_dapm_sys_remove(socdev->dev);
+	dapm_free_widgets(codec);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_free);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("Dynamic Audio Power Management core for ALSA SoC");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/at91/at91-i2s.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/at91-i2s.c	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,721 @@
+/*
+ * at91-i2s.c  --  ALSA SoC I2S Audio Layer Platform driver
+ *
+ * Author: Frank Mandarino <fmandarino@endrelia.com>
+ *         Endrelia Technologies Inc.
+ *
+ * Based on pxa2xx Platform drivers by
+ * Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/atmel_pdc.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_ssc.h>
+
+#include "at91-pcm.h"
+#include "at91-i2s.h"
+
+#if 0
+#define	DBG(x...)	printk(KERN_DEBUG "at91-i2s:" x)
+#else
+#define	DBG(x...)
+#endif
+
+#if defined(CONFIG_ARCH_AT91SAM9260)
+#define NUM_SSC_DEVICES		1
+#else
+#define NUM_SSC_DEVICES		3
+#endif
+
+
+/*
+ * SSC PDC registers required by the PCM DMA engine.
+ */
+static struct at91_pdc_regs pdc_tx_reg = {
+	.xpr		= ATMEL_PDC_TPR,
+	.xcr		= ATMEL_PDC_TCR,
+	.xnpr		= ATMEL_PDC_TNPR,
+	.xncr		= ATMEL_PDC_TNCR,
+};
+
+static struct at91_pdc_regs pdc_rx_reg = {
+	.xpr		= ATMEL_PDC_RPR,
+	.xcr		= ATMEL_PDC_RCR,
+	.xnpr		= ATMEL_PDC_RNPR,
+	.xncr		= ATMEL_PDC_RNCR,
+};
+
+/*
+ * SSC & PDC status bits for transmit and receive.
+ */
+static struct at91_ssc_mask ssc_tx_mask = {
+	.ssc_enable	= AT91_SSC_TXEN,
+	.ssc_disable	= AT91_SSC_TXDIS,
+	.ssc_endx	= AT91_SSC_ENDTX,
+	.ssc_endbuf	= AT91_SSC_TXBUFE,
+	.pdc_enable	= ATMEL_PDC_TXTEN,
+	.pdc_disable	= ATMEL_PDC_TXTDIS,
+};
+
+static struct at91_ssc_mask ssc_rx_mask = {
+	.ssc_enable	= AT91_SSC_RXEN,
+	.ssc_disable	= AT91_SSC_RXDIS,
+	.ssc_endx	= AT91_SSC_ENDRX,
+	.ssc_endbuf	= AT91_SSC_RXBUFF,
+	.pdc_enable	= ATMEL_PDC_RXTEN,
+	.pdc_disable	= ATMEL_PDC_RXTDIS,
+};
+
+
+/*
+ * DMA parameters.
+ */
+static struct at91_pcm_dma_params ssc_dma_params[NUM_SSC_DEVICES][2] = {
+	{{
+	.name		= "SSC0/I2S PCM Stereo out",
+	.pdc		= &pdc_tx_reg,
+	.mask		= &ssc_tx_mask,
+	},
+	{
+	.name		= "SSC0/I2S PCM Stereo in",
+	.pdc		= &pdc_rx_reg,
+	.mask		= &ssc_rx_mask,
+	}},
+#if NUM_SSC_DEVICES == 3
+	{{
+	.name		= "SSC1/I2S PCM Stereo out",
+	.pdc		= &pdc_tx_reg,
+	.mask		= &ssc_tx_mask,
+	},
+	{
+	.name		= "SSC1/I2S PCM Stereo in",
+	.pdc		= &pdc_rx_reg,
+	.mask		= &ssc_rx_mask,
+	}},
+	{{
+	.name		= "SSC2/I2S PCM Stereo out",
+	.pdc		= &pdc_tx_reg,
+	.mask		= &ssc_tx_mask,
+	},
+	{
+	.name		= "SSC1/I2S PCM Stereo in",
+	.pdc		= &pdc_rx_reg,
+	.mask		= &ssc_rx_mask,
+	}},
+#endif
+};
+
+struct at91_ssc_state {
+	u32	ssc_cmr;
+	u32	ssc_rcmr;
+	u32	ssc_rfmr;
+	u32	ssc_tcmr;
+	u32	ssc_tfmr;
+	u32	ssc_sr;
+	u32	ssc_imr;
+};
+
+static struct at91_ssc_info {
+	char		*name;
+	struct at91_ssc_periph ssc;
+	spinlock_t 	lock;		/* lock for dir_mask */
+	unsigned short	dir_mask;	/* 0=unused, 1=playback, 2=capture */
+	unsigned short	initialized;	/* 1=SSC has been initialized */
+	unsigned short	daifmt;
+	unsigned short	cmr_div;
+	unsigned short	tcmr_period;
+	unsigned short	rcmr_period;
+	struct at91_pcm_dma_params *dma_params[2];
+	struct at91_ssc_state ssc_state;
+
+} ssc_info[NUM_SSC_DEVICES] = {
+	{
+	.name		= "ssc0",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.dir_mask	= 0,
+	.initialized	= 0,
+	},
+#if NUM_SSC_DEVICES == 3
+	{
+	.name		= "ssc1",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.dir_mask	= 0,
+	.initialized	= 0,
+	},
+	{
+	.name		= "ssc2",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.dir_mask	= 0,
+	.initialized	= 0,
+	},
+#endif
+};
+
+static unsigned int at91_i2s_sysclk;
+
+/*
+ * SSC interrupt handler.  Passes PDC interrupts to the DMA
+ * interrupt handler in the PCM driver.
+ */
+static irqreturn_t at91_i2s_interrupt(int irq, void *dev_id)
+{
+	struct at91_ssc_info *ssc_p = dev_id;
+	struct at91_pcm_dma_params *dma_params;
+	u32 ssc_sr;
+	int i;
+
+	ssc_sr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_SR)
+			& at91_ssc_read(ssc_p->ssc.base + AT91_SSC_IMR);
+
+	/*
+	 * Loop through the substreams attached to this SSC.  If
+	 * a DMA-related interrupt occurred on that substream, call
+	 * the DMA interrupt handler function, if one has been
+	 * registered in the dma_params structure by the PCM driver.
+	 */
+	for (i = 0; i < ARRAY_SIZE(ssc_p->dma_params); i++) {
+		dma_params = ssc_p->dma_params[i];
+
+		if (dma_params != NULL && dma_params->dma_intr_handler != NULL &&
+			(ssc_sr &
+			(dma_params->mask->ssc_endx | dma_params->mask->ssc_endbuf)))
+
+			dma_params->dma_intr_handler(ssc_sr, dma_params->substream);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Startup.  Only that one substream allowed in each direction.
+ */
+static int at91_i2s_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct at91_ssc_info *ssc_p = &ssc_info[rtd->dai->cpu_dai->id];
+	int dir_mask;
+
+	DBG("i2s_startup: SSC_SR=0x%08lx\n",
+			at91_ssc_read(ssc_p->ssc.base + AT91_SSC_SR));
+	dir_mask = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0x1 : 0x2;
+
+	spin_lock_irq(&ssc_p->lock);
+	if (ssc_p->dir_mask & dir_mask) {
+		spin_unlock_irq(&ssc_p->lock);
+		return -EBUSY;
+	}
+	ssc_p->dir_mask |= dir_mask;
+	spin_unlock_irq(&ssc_p->lock);
+
+	return 0;
+}
+
+/*
+ * Shutdown.  Clear DMA parameters and shutdown the SSC if there
+ * are no other substreams open.
+ */
+static void at91_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct at91_ssc_info *ssc_p = &ssc_info[rtd->dai->cpu_dai->id];
+	struct at91_pcm_dma_params *dma_params;
+	int dir, dir_mask;
+
+	dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1;
+	dma_params = ssc_p->dma_params[dir];
+
+	if (dma_params != NULL) {
+		at91_ssc_write(dma_params->ssc_base + AT91_SSC_CR,
+				dma_params->mask->ssc_disable);
+		DBG("%s disabled SSC_SR=0x%08lx\n", (dir ? "receive" : "transmit"),
+			at91_ssc_read(ssc_p->ssc.base + AT91_SSC_SR));
+
+		dma_params->ssc_base = NULL;
+		dma_params->substream = NULL;
+		ssc_p->dma_params[dir] = NULL;
+	}
+
+	dir_mask = 1 << dir;
+
+	spin_lock_irq(&ssc_p->lock);
+	ssc_p->dir_mask &= ~dir_mask;
+	if (!ssc_p->dir_mask) {
+		/* Shutdown the SSC clock. */
+		DBG("Stopping pid %d clock\n", ssc_p->ssc.pid);
+		at91_sys_write(AT91_PMC_PCDR, 1<<ssc_p->ssc.pid);
+
+		if (ssc_p->initialized) {
+			free_irq(ssc_p->ssc.pid, ssc_p);
+			ssc_p->initialized = 0;
+		}
+
+		/* Reset the SSC */
+		at91_ssc_write(ssc_p->ssc.base + AT91_SSC_CR, AT91_SSC_SWRST);
+
+		/* Clear the SSC dividers */
+		ssc_p->cmr_div = ssc_p->tcmr_period = ssc_p->rcmr_period = 0;
+	}
+	spin_unlock_irq(&ssc_p->lock);
+}
+
+/*
+ * Record the SSC system clock rate.
+ */
+static int at91_i2s_set_dai_sysclk(struct snd_soc_cpu_dai *cpu_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	/*
+	 * The only clock supplied to the SSC is the AT91 master clock,
+	 * which is only used if the SSC is generating BCLK and/or
+	 * LRC clocks.
+	 */
+	switch (clk_id) {
+	case AT91_SYSCLK_MCK:
+		at91_i2s_sysclk = freq;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Record the DAI format for use in hw_params().
+ */
+static int at91_i2s_set_dai_fmt(struct snd_soc_cpu_dai *cpu_dai,
+		unsigned int fmt)
+{
+	struct at91_ssc_info *ssc_p = &ssc_info[cpu_dai->id];
+
+	if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S)
+		return -EINVAL;
+
+	ssc_p->daifmt = fmt;
+	return 0;
+}
+
+/*
+ * Record SSC clock dividers for use in hw_params().
+ */
+static int at91_i2s_set_dai_clkdiv(struct snd_soc_cpu_dai *cpu_dai,
+	int div_id, int div)
+{
+	struct at91_ssc_info *ssc_p = &ssc_info[cpu_dai->id];
+
+	switch (div_id) {
+	case AT91SSC_CMR_DIV:
+		/*
+		 * The same master clock divider is used for both
+		 * transmit and receive, so if a value has already
+		 * been set, it must match this value.
+		 */
+		if (ssc_p->cmr_div == 0)
+			ssc_p->cmr_div = div;
+		else
+			if (div != ssc_p->cmr_div)
+				return -EBUSY;
+		break;
+
+	case AT91SSC_TCMR_PERIOD:
+		ssc_p->tcmr_period = div;
+		break;
+
+	case AT91SSC_RCMR_PERIOD:
+		ssc_p->rcmr_period = div;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Configure the SSC.
+ */
+static int at91_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int id = rtd->dai->cpu_dai->id;
+	struct at91_ssc_info *ssc_p = &ssc_info[id];
+	struct at91_pcm_dma_params *dma_params;
+	int dir, channels, bits;
+	u32 tfmr, rfmr, tcmr, rcmr;
+	int start_event;
+	int ret;
+
+	/*
+	 * Currently, there is only one set of dma params for
+	 * each direction.  If more are added, this code will
+	 * have to be changed to select the proper set.
+	 */
+	dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1;
+
+	dma_params = &ssc_dma_params[id][dir];
+	dma_params->ssc_base = ssc_p->ssc.base;
+	dma_params->substream = substream;
+
+	ssc_p->dma_params[dir] = dma_params;
+
+	/*
+	 * The cpu_dai->dma_data field is only used to communicate the
+	 * appropriate DMA parameters to the pcm driver hw_params()
+	 * function.  It should not be used for other purposes
+	 * as it is common to all substreams.
+	 */
+	rtd->dai->cpu_dai->dma_data = dma_params;
+
+	channels = params_channels(params);
+
+	/*
+	 * The SSC only supports up to 16-bit samples in I2S format, due
+	 * to the size of the Frame Mode Register FSLEN field.  Also, I2S
+	 * implies signed data.
+	 */
+	bits = 16;
+	dma_params->pdc_xfer_size = 2;
+
+	/*
+	 * Compute SSC register settings.
+	 */
+	switch (ssc_p->daifmt) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/*
+		 * SSC provides BCLK and LRC clocks.
+		 *
+		 * The SSC transmit and receive clocks are generated from the
+		 * MCK divider, and the BCLK signal is output on the SSC TK line.
+		 */
+		rcmr =	  (( ssc_p->rcmr_period		<< 24) & AT91_SSC_PERIOD)
+			| (( 1				<< 16) & AT91_SSC_STTDLY)
+			| (( AT91_SSC_START_FALLING_RF	     ) & AT91_SSC_START)
+			| (( AT91_SSC_CK_RISING		     ) & AT91_SSC_CKI)
+			| (( AT91_SSC_CKO_NONE		     ) & AT91_SSC_CKO)
+			| (( AT91_SSC_CKS_DIV		     ) & AT91_SSC_CKS);
+
+		rfmr =	  (( AT91_SSC_FSEDGE_POSITIVE	     ) & AT91_SSC_FSEDGE)
+			| (( AT91_SSC_FSOS_NEGATIVE	     ) & AT91_SSC_FSOS)
+			| (((bits - 1)			<< 16) & AT91_SSC_FSLEN)
+			| (((channels - 1)		<<  8) & AT91_SSC_DATNB)
+			| (( 1				<<  7) & AT91_SSC_MSBF)
+			| (( 0				<<  5) & AT91_SSC_LOOP)
+			| (((bits - 1)			<<  0) & AT91_SSC_DATALEN);
+
+		tcmr =	  (( ssc_p->tcmr_period		<< 24) & AT91_SSC_PERIOD)
+			| (( 1				<< 16) & AT91_SSC_STTDLY)
+			| (( AT91_SSC_START_FALLING_RF       ) & AT91_SSC_START)
+			| (( AT91_SSC_CKI_FALLING	     ) & AT91_SSC_CKI)
+			| (( AT91_SSC_CKO_CONTINUOUS	     ) & AT91_SSC_CKO)
+			| (( AT91_SSC_CKS_DIV		     ) & AT91_SSC_CKS);
+
+		tfmr =	  (( AT91_SSC_FSEDGE_POSITIVE	     ) & AT91_SSC_FSEDGE)
+			| (( 0				<< 23) & AT91_SSC_FSDEN)
+			| (( AT91_SSC_FSOS_NEGATIVE	     ) & AT91_SSC_FSOS)
+			| (((bits - 1)			<< 16) & AT91_SSC_FSLEN)
+			| (((channels - 1)		<<  8) & AT91_SSC_DATNB)
+			| (( 1				<<  7) & AT91_SSC_MSBF)
+			| (( 0				<<  5) & AT91_SSC_DATDEF)
+			| (((bits - 1)			<<  0) & AT91_SSC_DATALEN);
+		break;
+
+	case SND_SOC_DAIFMT_CBM_CFM:
+
+		/*
+		 * CODEC supplies BCLK and LRC clocks.
+		 *
+		 * The SSC transmit clock is obtained from the BCLK signal on
+		 * on the TK line, and the SSC receive clock is generated from the
+		 * transmit clock.
+		 *
+		 * For single channel data, one sample is transferred on the falling
+		 * edge of the LRC clock.  For two channel data, one sample is
+		 * transferred on both edges of the LRC clock.
+		 */
+		start_event = channels == 1
+				? AT91_SSC_START_FALLING_RF
+				: AT91_SSC_START_EDGE_RF;
+
+		rcmr =	  (( 0				<< 24) & AT91_SSC_PERIOD)
+			| (( 1				<< 16) & AT91_SSC_STTDLY)
+			| (( start_event		     ) & AT91_SSC_START)
+			| (( AT91_SSC_CK_RISING		     ) & AT91_SSC_CKI)
+			| (( AT91_SSC_CKO_NONE		     ) & AT91_SSC_CKO)
+			| (( AT91_SSC_CKS_CLOCK		     ) & AT91_SSC_CKS);
+
+		rfmr =	  (( AT91_SSC_FSEDGE_POSITIVE	     ) & AT91_SSC_FSEDGE)
+			| (( AT91_SSC_FSOS_NONE		     ) & AT91_SSC_FSOS)
+			| (( 0				<< 16) & AT91_SSC_FSLEN)
+			| (( 0				<<  8) & AT91_SSC_DATNB)
+			| (( 1				<<  7) & AT91_SSC_MSBF)
+			| (( 0				<<  5) & AT91_SSC_LOOP)
+			| (((bits - 1)			<<  0) & AT91_SSC_DATALEN);
+
+		tcmr =	  (( 0				<< 24) & AT91_SSC_PERIOD)
+			| (( 1				<< 16) & AT91_SSC_STTDLY)
+			| (( start_event		     ) & AT91_SSC_START)
+			| (( AT91_SSC_CKI_FALLING	     ) & AT91_SSC_CKI)
+			| (( AT91_SSC_CKO_NONE		     ) & AT91_SSC_CKO)
+			| (( AT91_SSC_CKS_PIN		     ) & AT91_SSC_CKS);
+
+		tfmr =	  (( AT91_SSC_FSEDGE_POSITIVE	     ) & AT91_SSC_FSEDGE)
+			| (( 0				<< 23) & AT91_SSC_FSDEN)
+			| (( AT91_SSC_FSOS_NONE		     ) & AT91_SSC_FSOS)
+			| (( 0				<< 16) & AT91_SSC_FSLEN)
+			| (( 0				<<  8) & AT91_SSC_DATNB)
+			| (( 1				<<  7) & AT91_SSC_MSBF)
+			| (( 0				<<  5) & AT91_SSC_DATDEF)
+			| (((bits - 1)			<<  0) & AT91_SSC_DATALEN);
+		break;
+
+	case SND_SOC_DAIFMT_CBS_CFM:
+	case SND_SOC_DAIFMT_CBM_CFS:
+	default:
+		printk(KERN_WARNING "at91-i2s: unsupported DAI format 0x%x.\n",
+			ssc_p->daifmt);
+		return -EINVAL;
+		break;
+	}
+	DBG("RCMR=%08x RFMR=%08x TCMR=%08x TFMR=%08x\n", rcmr, rfmr, tcmr, tfmr);
+
+	if (!ssc_p->initialized) {
+
+		/* Enable PMC peripheral clock for this SSC */
+		DBG("Starting pid %d clock\n", ssc_p->ssc.pid);
+		at91_sys_write(AT91_PMC_PCER, 1<<ssc_p->ssc.pid);
+
+		/* Reset the SSC and its PDC registers */
+		at91_ssc_write(ssc_p->ssc.base + AT91_SSC_CR, AT91_SSC_SWRST);
+
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_RPR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_RCR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_RNPR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_RNCR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_TPR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_TCR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_TNPR, 0);
+		at91_ssc_write(ssc_p->ssc.base + ATMEL_PDC_TNCR, 0);
+
+		if ((ret = request_irq(ssc_p->ssc.pid, at91_i2s_interrupt,
+					0, ssc_p->name, ssc_p)) < 0) {
+			printk(KERN_WARNING "at91-i2s: request_irq failure\n");
+
+			DBG("Stopping pid %d clock\n", ssc_p->ssc.pid);
+			at91_sys_write(AT91_PMC_PCER, 1<<ssc_p->ssc.pid);
+			return ret;
+		}
+
+		ssc_p->initialized = 1;
+	}
+
+	/* set SSC clock mode register */
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_CMR, ssc_p->cmr_div);
+
+	/* set receive clock mode and format */
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_RCMR, rcmr);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_RFMR, rfmr);
+
+	/* set transmit clock mode and format */
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_TCMR, tcmr);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_TFMR, tfmr);
+
+	DBG("hw_params: SSC initialized\n");
+	return 0;
+}
+
+
+static int at91_i2s_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct at91_ssc_info *ssc_p = &ssc_info[rtd->dai->cpu_dai->id];
+	struct at91_pcm_dma_params *dma_params;
+	int dir;
+
+	dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1;
+	dma_params = ssc_p->dma_params[dir];
+
+	at91_ssc_write(dma_params->ssc_base + AT91_SSC_CR,
+			dma_params->mask->ssc_enable);
+
+	DBG("%s enabled SSC_SR=0x%08lx\n", dir ? "receive" : "transmit",
+		at91_ssc_read(dma_params->ssc_base + AT91_SSC_SR));
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int at91_i2s_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *cpu_dai)
+{
+	struct at91_ssc_info *ssc_p;
+
+	if(!cpu_dai->active)
+		return 0;
+
+	ssc_p = &ssc_info[cpu_dai->id];
+
+	/* Save the status register before disabling transmit and receive. */
+	ssc_p->ssc_state.ssc_sr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_SR);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_CR,
+			AT91_SSC_TXDIS | AT91_SSC_RXDIS);
+
+	/* Save the current interrupt mask, then disable unmasked interrupts. */
+	ssc_p->ssc_state.ssc_imr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_IMR);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_IDR, ssc_p->ssc_state.ssc_imr);
+
+	ssc_p->ssc_state.ssc_cmr  = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_CMR);
+	ssc_p->ssc_state.ssc_rcmr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_RCMR);
+	ssc_p->ssc_state.ssc_rfmr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_RFMR);
+	ssc_p->ssc_state.ssc_tcmr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_TCMR);
+	ssc_p->ssc_state.ssc_tfmr = at91_ssc_read(ssc_p->ssc.base + AT91_SSC_TFMR);
+
+	return 0;
+}
+
+static int at91_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *cpu_dai)
+{
+	struct at91_ssc_info *ssc_p;
+
+	if(!cpu_dai->active)
+		return 0;
+
+	ssc_p = &ssc_info[cpu_dai->id];
+
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_TFMR, ssc_p->ssc_state.ssc_tfmr);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_TCMR, ssc_p->ssc_state.ssc_tcmr);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_RFMR, ssc_p->ssc_state.ssc_rfmr);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_RCMR, ssc_p->ssc_state.ssc_rcmr);
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_CMR,  ssc_p->ssc_state.ssc_cmr);
+
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_IER,  ssc_p->ssc_state.ssc_imr);
+
+	at91_ssc_write(ssc_p->ssc.base + AT91_SSC_CR,
+		((ssc_p->ssc_state.ssc_sr & AT91_SSC_RXENA) ? AT91_SSC_RXEN : 0) |
+		((ssc_p->ssc_state.ssc_sr & AT91_SSC_TXENA) ? AT91_SSC_TXEN : 0));
+
+	return 0;
+}
+
+#else
+#define at91_i2s_suspend	NULL
+#define at91_i2s_resume		NULL
+#endif
+
+#define AT91_I2S_RATES (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 |\
+			SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+			SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+			SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\
+			SNDRV_PCM_RATE_96000)
+
+struct snd_soc_cpu_dai at91_i2s_dai[NUM_SSC_DEVICES] = {
+	{	.name = "at91_ssc0/i2s",
+		.id = 0,
+		.type = SND_SOC_DAI_I2S,
+		.suspend = at91_i2s_suspend,
+		.resume = at91_i2s_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = AT91_I2S_RATES,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = AT91_I2S_RATES,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+		.ops = {
+			.startup = at91_i2s_startup,
+			.shutdown = at91_i2s_shutdown,
+			.prepare = at91_i2s_prepare,
+			.hw_params = at91_i2s_hw_params,},
+		.dai_ops = {
+			.set_sysclk = at91_i2s_set_dai_sysclk,
+			.set_fmt = at91_i2s_set_dai_fmt,
+			.set_clkdiv = at91_i2s_set_dai_clkdiv,},
+		.private_data = &ssc_info[0].ssc,
+	},
+#if NUM_SSC_DEVICES == 3
+	{	.name = "at91_ssc1/i2s",
+		.id = 1,
+		.type = SND_SOC_DAI_I2S,
+		.suspend = at91_i2s_suspend,
+		.resume = at91_i2s_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = AT91_I2S_RATES,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = AT91_I2S_RATES,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+		.ops = {
+			.startup = at91_i2s_startup,
+			.shutdown = at91_i2s_shutdown,
+			.prepare = at91_i2s_prepare,
+			.hw_params = at91_i2s_hw_params,},
+		.dai_ops = {
+			.set_sysclk = at91_i2s_set_dai_sysclk,
+			.set_fmt = at91_i2s_set_dai_fmt,
+			.set_clkdiv = at91_i2s_set_dai_clkdiv,},
+		.private_data = &ssc_info[1].ssc,
+	},
+	{	.name = "at91_ssc2/i2s",
+		.id = 2,
+		.type = SND_SOC_DAI_I2S,
+		.suspend = at91_i2s_suspend,
+		.resume = at91_i2s_resume,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = AT91_I2S_RATES,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = AT91_I2S_RATES,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+		.ops = {
+			.startup = at91_i2s_startup,
+			.shutdown = at91_i2s_shutdown,
+			.prepare = at91_i2s_prepare,
+			.hw_params = at91_i2s_hw_params,},
+		.dai_ops = {
+			.set_sysclk = at91_i2s_set_dai_sysclk,
+			.set_fmt = at91_i2s_set_dai_fmt,
+			.set_clkdiv = at91_i2s_set_dai_clkdiv,},
+		.private_data = &ssc_info[2].ssc,
+	},
+#endif
+};
+
+EXPORT_SYMBOL_GPL(at91_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Frank Mandarino, fmandarino@endrelia.com, www.endrelia.com");
+MODULE_DESCRIPTION("AT91 I2S ASoC Interface");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/at91/eti_b1_wm8731.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/eti_b1_wm8731.c	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,375 @@
+/*
+ * eti_b1_wm8731  --  SoC audio for AT91RM9200-based Endrelia ETI_B1 board.
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Mar 29, 2006
+ *
+ * Based on corgi.c by:
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91_pio.h>
+#include <asm/arch/gpio.h>
+
+#include "../codecs/wm8731.h"
+#include "at91-pcm.h"
+#include "at91-i2s.h"
+
+#if 0
+#define	DBG(x...)	printk(KERN_INFO "eti_b1_wm8731: " x)
+#else
+#define	DBG(x...)
+#endif
+
+#define AT91_PIO_TF1	(1 << (AT91_PIN_PB6 - PIN_BASE) % 32)
+#define AT91_PIO_TK1	(1 << (AT91_PIN_PB7 - PIN_BASE) % 32)
+#define AT91_PIO_TD1	(1 << (AT91_PIN_PB8 - PIN_BASE) % 32)
+#define AT91_PIO_RD1	(1 << (AT91_PIN_PB9 - PIN_BASE) % 32)
+#define AT91_PIO_RK1	(1 << (AT91_PIN_PB10 - PIN_BASE) % 32)
+#define AT91_PIO_RF1	(1 << (AT91_PIN_PB11 - PIN_BASE) % 32)
+
+static struct clk *pck1_clk;
+static struct clk *pllb_clk;
+
+
+static int eti_b1_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	/* cpu clock is the AT91 master clock sent to the SSC */
+	ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, AT91_SYSCLK_MCK,
+		60000000, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* codec system clock is supplied by PCK1, set to 12MHz */
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8731_SYSCLK,
+		12000000, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* Start PCK1 clock. */
+	clk_enable(pck1_clk);
+	DBG("pck1 started\n");
+
+	return 0;
+}
+
+static void eti_b1_shutdown(struct snd_pcm_substream *substream)
+{
+	/* Stop PCK1 clock. */
+	clk_disable(pck1_clk);
+	DBG("pck1 stopped\n");
+}
+
+static int eti_b1_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+#ifdef CONFIG_SND_AT91_SOC_ETI_SLAVE
+	unsigned int rate;
+	int cmr_div, period;
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * The SSC clock dividers depend on the sample rate.  The CMR.DIV
+	 * field divides the system master clock MCK to drive the SSC TK
+	 * signal which provides the codec BCLK.  The TCMR.PERIOD and
+	 * RCMR.PERIOD fields further divide the BCLK signal to drive
+	 * the SSC TF and RF signals which provide the codec DACLRC and
+	 * ADCLRC clocks.
+	 *
+	 * The dividers were determined through trial and error, where a
+	 * CMR.DIV value is chosen such that the resulting BCLK value is
+	 * divisible, or almost divisible, by (2 * sample rate), and then
+	 * the TCMR.PERIOD or RCMR.PERIOD is BCLK / (2 * sample rate) - 1.
+	 */
+	rate = params_rate(params);
+
+	switch (rate) {
+	case 8000:
+		cmr_div = 25;	/* BCLK = 60MHz/(2*25) = 1.2MHz */
+		period = 74;	/* LRC = BCLK/(2*(74+1)) = 8000Hz */
+		break;
+	case 32000:
+		cmr_div = 7;	/* BCLK = 60MHz/(2*7) ~= 4.28571428MHz */
+		period = 66;	/* LRC = BCLK/(2*(66+1)) = 31982.942Hz */
+		break;
+	case 48000:
+		cmr_div = 13;	/* BCLK = 60MHz/(2*13) ~= 2.3076923MHz */
+		period = 23;	/* LRC = BCLK/(2*(23+1)) = 48076.923Hz */
+		break;
+	default:
+		printk(KERN_WARNING "unsupported rate %d on ETI-B1 board\n", rate);
+		return -EINVAL;
+	}
+
+	/* set the MCK divider for BCLK */
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, AT91SSC_CMR_DIV, cmr_div);
+	if (ret < 0)
+		return ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* set the BCLK divider for DACLRC */
+		ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai,
+						AT91SSC_TCMR_PERIOD, period);
+	} else {
+		/* set the BCLK divider for ADCLRC */
+		ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai,
+						AT91SSC_RCMR_PERIOD, period);
+	}
+	if (ret < 0)
+		return ret;
+
+#else /* CONFIG_SND_AT91_SOC_ETI_SLAVE */
+	/*
+	 * Codec in Master Mode.
+	 */
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+#endif /* CONFIG_SND_AT91_SOC_ETI_SLAVE */
+
+	return 0;
+}
+
+static struct snd_soc_ops eti_b1_ops = {
+	.startup = eti_b1_startup,
+	.hw_params = eti_b1_hw_params,
+	.shutdown = eti_b1_shutdown,
+};
+
+
+static const struct snd_soc_dapm_widget eti_b1_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+};
+
+static const char *intercon[][3] = {
+
+	/* speaker connected to LHPOUT */
+	{"Ext Spk", NULL, "LHPOUT"},
+
+	/* mic is connected to Mic Jack, with WM8731 Mic Bias */
+	{"MICIN", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Int Mic"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+/*
+ * Logic for a wm8731 as connected on a Endrelia ETI-B1 board.
+ */
+static int eti_b1_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	DBG("eti_b1_wm8731_init() called\n");
+
+	/* Add specific widgets */
+	for(i = 0; i < ARRAY_SIZE(eti_b1_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &eti_b1_dapm_widgets[i]);
+	}
+
+	/* Set up specific audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0],
+			intercon[i][1], intercon[i][2]);
+	}
+
+	/* not connected */
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+
+	/* always connected */
+	snd_soc_dapm_set_endpoint(codec, "Int Mic", 1);
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", 1);
+
+	snd_soc_dapm_sync_endpoints(codec);
+
+	return 0;
+}
+
+static struct snd_soc_dai_link eti_b1_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &at91_i2s_dai[1],
+	.codec_dai = &wm8731_dai,
+	.init = eti_b1_wm8731_init,
+	.ops = &eti_b1_ops,
+};
+
+static struct snd_soc_machine snd_soc_machine_eti_b1 = {
+	.name = "ETI_B1",
+	.dai_link = &eti_b1_dai,
+	.num_links = 1,
+};
+
+static struct wm8731_setup_data eti_b1_wm8731_setup = {
+	.i2c_address = 0x1a,
+};
+
+static struct snd_soc_device eti_b1_snd_devdata = {
+	.machine = &snd_soc_machine_eti_b1,
+	.platform = &at91_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &eti_b1_wm8731_setup,
+};
+
+static struct platform_device *eti_b1_snd_device;
+
+static int __init eti_b1_init(void)
+{
+	int ret;
+	u32 ssc_pio_lines;
+	struct at91_ssc_periph *ssc = eti_b1_dai.cpu_dai->private_data;
+
+	if (!request_mem_region(AT91RM9200_BASE_SSC1, SZ_16K, "soc-audio")) {
+		DBG("SSC1 memory region is busy\n");
+		return -EBUSY;
+	}
+
+	ssc->base = ioremap(AT91RM9200_BASE_SSC1, SZ_16K);
+	if (!ssc->base) {
+		DBG("SSC1 memory ioremap failed\n");
+		ret = -ENOMEM;
+		goto fail_release_mem;
+	}
+
+	ssc->pid = AT91RM9200_ID_SSC1;
+
+	eti_b1_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!eti_b1_snd_device) {
+		DBG("platform device allocation failed\n");
+		ret = -ENOMEM;
+		goto fail_io_unmap;
+	}
+
+	platform_set_drvdata(eti_b1_snd_device, &eti_b1_snd_devdata);
+	eti_b1_snd_devdata.dev = &eti_b1_snd_device->dev;
+
+	ret = platform_device_add(eti_b1_snd_device);
+	if (ret) {
+		DBG("platform device add failed\n");
+		platform_device_put(eti_b1_snd_device);
+		goto fail_io_unmap;
+	}
+
+ 	ssc_pio_lines = AT91_PIO_TF1 | AT91_PIO_TK1 | AT91_PIO_TD1
+			| AT91_PIO_RD1 /* | AT91_PIO_RK1 */ | AT91_PIO_RF1;
+
+	/* Reset all PIO registers and assign lines to peripheral A */
+ 	at91_sys_write(AT91_PIOB + PIO_PDR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_ODR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_IFDR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_CODR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_IDR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_MDDR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_PUDR, ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_ASR,  ssc_pio_lines);
+ 	at91_sys_write(AT91_PIOB + PIO_OWDR, ssc_pio_lines);
+
+	/*
+	 * Set PCK1 parent to PLLB and its rate to 12 Mhz.
+	 */
+	pllb_clk = clk_get(NULL, "pllb");
+	pck1_clk = clk_get(NULL, "pck1");
+
+	clk_set_parent(pck1_clk, pllb_clk);
+	clk_set_rate(pck1_clk, 12000000);
+
+	DBG("MCLK rate %luHz\n", clk_get_rate(pck1_clk));
+
+	/* assign the GPIO pin to PCK1 */
+	at91_set_B_periph(AT91_PIN_PA24, 0);
+
+#ifdef CONFIG_SND_AT91_SOC_ETI_SLAVE
+	printk(KERN_INFO "eti_b1_wm8731: Codec in Slave Mode\n");
+#else
+	printk(KERN_INFO "eti_b1_wm8731: Codec in Master Mode\n");
+#endif
+	return ret;
+
+fail_io_unmap:
+	iounmap(ssc->base);
+fail_release_mem:
+	release_mem_region(AT91RM9200_BASE_SSC1, SZ_16K);
+	return ret;
+}
+
+static void __exit eti_b1_exit(void)
+{
+	struct at91_ssc_periph *ssc = eti_b1_dai.cpu_dai->private_data;
+
+	clk_put(pck1_clk);
+	clk_put(pllb_clk);
+
+	platform_device_unregister(eti_b1_snd_device);
+
+	iounmap(ssc->base);
+	release_mem_region(AT91RM9200_BASE_SSC1, SZ_16K);
+}
+
+module_init(eti_b1_init);
+module_exit(eti_b1_exit);
+
+/* Module information */
+MODULE_AUTHOR("Frank Mandarino <fmandarino@endrelia.com>");
+MODULE_DESCRIPTION("ALSA SoC ETI-B1-WM8731");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/at91/Kconfig.orig	2007-06-05 17:29:18.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/Kconfig	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,31 @@
+menu "SoC Audio for the Atmel AT91"
+
+config SND_AT91_SOC
+	tristate "SoC Audio for the Atmel AT91 System-on-Chip"
+	depends on ARCH_AT91 && SND_SOC
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the AT91 SSC interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_AT91_SOC_I2S
+	tristate
+
+config SND_AT91_SOC_ETI_B1_WM8731
+	tristate "SoC I2S Audio support for WM8731-based Endrelia ETI-B1 boards"
+	depends on SND_AT91_SOC && (MACH_ETI_B1 || MACH_ETI_C1)
+	select SND_AT91_SOC_I2S
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for SoC audio on WM8731-based
+	  Endrelia Technologies Inc ETI-B1 or ETI-C1 boards.
+
+config SND_AT91_SOC_ETI_SLAVE
+	bool "Run codec in slave Mode on Endrelia boards"
+	depends on SND_AT91_SOC_ETI_B1_WM8731
+	default n
+	help
+	  Say Y if you want to run with the AT91 SSC generating the BCLK
+	  and LRC signals on Endrelia boards.
+
+endmenu
--- linux-2.6.18.noarch/sound/soc/at91/at91-pcm.c.orig	2007-06-05 16:46:38.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/at91/at91-pcm.c	2007-06-05 19:56:11.000000000 -0400
@@ -0,0 +1,432 @@
+/*
+ * at91-pcm.c -- ALSA PCM interface for the Atmel AT91 SoC
+ *
+ * Author:	Frank Mandarino <fmandarino@endrelia.com>
+ *		Endrelia Technologies Inc.
+ * Created:	Mar 3, 2006
+ *
+ * Based on pxa2xx-pcm.c by:
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/atmel_pdc.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91_ssc.h>
+
+#include "at91-pcm.h"
+
+#if 0
+#define	DBG(x...)	printk(KERN_INFO "at91-pcm: " x)
+#else
+#define	DBG(x...)
+#endif
+
+static const struct snd_pcm_hardware at91_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 2,
+	.periods_max		= 1024,
+	.buffer_bytes_max	= 32 * 1024,
+};
+
+struct at91_runtime_data {
+	struct at91_pcm_dma_params *params;
+	dma_addr_t dma_buffer;			/* physical address of dma buffer */
+	dma_addr_t dma_buffer_end;		/* first address beyond DMA buffer */
+	size_t period_size;
+	dma_addr_t period_ptr;			/* physical address of next period */
+	u32 pdc_xpr_save;			/* PDC register save */
+	u32 pdc_xcr_save;
+	u32 pdc_xnpr_save;
+	u32 pdc_xncr_save;
+};
+
+static void at91_pcm_dma_irq(u32 ssc_sr,
+	struct snd_pcm_substream *substream)
+{
+	struct at91_runtime_data *prtd = substream->runtime->private_data;
+	struct at91_pcm_dma_params *params = prtd->params;
+	static int count = 0;
+
+	count++;
+
+	if (ssc_sr & params->mask->ssc_endbuf) {
+
+		printk(KERN_WARNING
+			"at91-pcm: buffer %s on %s (SSC_SR=%#x, count=%d)\n",
+			substream->stream == SNDRV_PCM_STREAM_PLAYBACK
+				? "underrun" : "overrun",
+			params->name, ssc_sr, count);
+
+		/* re-start the PDC */
+		at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_disable);
+
+		prtd->period_ptr += prtd->period_size;
+		if (prtd->period_ptr >= prtd->dma_buffer_end) {
+			prtd->period_ptr = prtd->dma_buffer;
+		}
+
+		at91_ssc_write(params->ssc_base + params->pdc->xpr, prtd->period_ptr);
+		at91_ssc_write(params->ssc_base + params->pdc->xcr,
+				prtd->period_size / params->pdc_xfer_size);
+
+		at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_enable);
+	}
+
+	if (ssc_sr & params->mask->ssc_endx) {
+
+		/* Load the PDC next pointer and counter registers */
+		prtd->period_ptr += prtd->period_size;
+		if (prtd->period_ptr >= prtd->dma_buffer_end) {
+			prtd->period_ptr = prtd->dma_buffer;
+		}
+		at91_ssc_write(params->ssc_base + params->pdc->xnpr, prtd->period_ptr);
+		at91_ssc_write(params->ssc_base + params->pdc->xncr,
+				prtd->period_size / params->pdc_xfer_size);
+	}
+
+	snd_pcm_period_elapsed(substream);
+}
+
+static int at91_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct at91_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->params = rtd->dai->cpu_dai->dma_data;
+	prtd->params->dma_intr_handler = at91_pcm_dma_irq;
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+
+	DBG("hw_params: DMA for %s initialized (dma_bytes=%d, period_size=%d)\n",
+		prtd->params->name, runtime->dma_bytes, prtd->period_size);
+	return 0;
+}
+
+static int at91_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct at91_runtime_data *prtd = substream->runtime->private_data;
+	struct at91_pcm_dma_params *params = prtd->params;
+
+	if (params != NULL) {
+		at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_disable);
+		prtd->params->dma_intr_handler = NULL;
+	}
+
+	return 0;
+}
+
+static int at91_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct at91_runtime_data *prtd = substream->runtime->private_data;
+	struct at91_pcm_dma_params *params = prtd->params;
+
+	at91_ssc_write(params->ssc_base + AT91_SSC_IDR,
+			params->mask->ssc_endx | params->mask->ssc_endbuf);
+
+	at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_disable);
+	return 0;
+}
+
+static int at91_pcm_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	struct at91_runtime_data *prtd = substream->runtime->private_data;
+	struct at91_pcm_dma_params *params = prtd->params;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->period_ptr = prtd->dma_buffer;
+
+		at91_ssc_write(params->ssc_base + params->pdc->xpr, prtd->period_ptr);
+		at91_ssc_write(params->ssc_base + params->pdc->xcr,
+				prtd->period_size / params->pdc_xfer_size);
+
+		prtd->period_ptr += prtd->period_size;
+		at91_ssc_write(params->ssc_base + params->pdc->xnpr, prtd->period_ptr);
+		at91_ssc_write(params->ssc_base + params->pdc->xncr,
+				prtd->period_size / params->pdc_xfer_size);
+
+		DBG("trigger: period_ptr=%lx, xpr=%lx, xcr=%ld, xnpr=%lx, xncr=%ld\n",
+			(unsigned long) prtd->period_ptr,
+			at91_ssc_read(params->ssc_base + params->pdc->xpr),
+			at91_ssc_read(params->ssc_base + params->pdc->xcr),
+			at91_ssc_read(params->ssc_base + params->pdc->xnpr),
+			at91_ssc_read(params->ssc_base + params->pdc->xncr));
+
+		at91_ssc_write(params->ssc_base + AT91_SSC_IER,
+			params->mask->ssc_endx | params->mask->ssc_endbuf);
+
+		at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_enable);
+
+		DBG("sr=%lx imr=%lx\n", at91_ssc_read(params->ssc_base + AT91_SSC_SR),
+					at91_ssc_read(params->ssc_base + AT91_SSC_IER));
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_disable);
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_enable);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t at91_pcm_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct at91_runtime_data *prtd = runtime->private_data;
+	struct at91_pcm_dma_params *params = prtd->params;
+	dma_addr_t ptr;
+	snd_pcm_uframes_t x;
+
+	ptr = (dma_addr_t) at91_ssc_read(params->ssc_base + params->pdc->xpr);
+	x = bytes_to_frames(runtime, ptr - prtd->dma_buffer);
+
+	if (x == runtime->buffer_size)
+		x = 0;
+	return x;
+}
+
+static int at91_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct at91_runtime_data *prtd;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &at91_pcm_hardware);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(struct at91_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	runtime->private_data = prtd;
+
+ out:
+	return ret;
+}
+
+static int at91_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct at91_runtime_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int at91_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops at91_pcm_ops = {
+	.open		= at91_pcm_open,
+	.close		= at91_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= at91_pcm_hw_params,
+	.hw_free	= at91_pcm_hw_free,
+	.prepare	= at91_pcm_prepare,
+	.trigger	= at91_pcm_trigger,
+	.pointer	= at91_pcm_pointer,
+	.mmap		= at91_pcm_mmap,
+};
+
+static int at91_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
+	int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = at91_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+
+	DBG("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
+		(void *) buf->area,
+		(void *) buf->addr,
+		size);
+
+	if (!buf->area)
+		return -ENOMEM;
+
+	buf->bytes = size;
+	return 0;
+}
+
+static u64 at91_pcm_dmamask = 0xffffffff;
+
+static int at91_pcm_new(struct snd_card *card,
+	struct snd_soc_codec_dai *dai, struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &at91_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = at91_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = at91_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+static void at91_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+#ifdef CONFIG_PM
+static int at91_pcm_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct at91_runtime_data *prtd;
+	struct at91_pcm_dma_params *params;
+
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* disable the PDC and save the PDC registers */
+
+	at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_disable);
+
+	prtd->pdc_xpr_save  = at91_ssc_read(params->ssc_base + params->pdc->xpr);
+	prtd->pdc_xcr_save  = at91_ssc_read(params->ssc_base + params->pdc->xcr);
+	prtd->pdc_xnpr_save = at91_ssc_read(params->ssc_base + params->pdc->xnpr);
+	prtd->pdc_xncr_save = at91_ssc_read(params->ssc_base + params->pdc->xncr);
+
+	return 0;
+}
+
+static int at91_pcm_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct at91_runtime_data *prtd;
+	struct at91_pcm_dma_params *params;
+
+	if (!runtime)
+		return 0;
+
+	prtd = runtime->private_data;
+	params = prtd->params;
+
+	/* restore the PDC registers and enable the PDC */
+	at91_ssc_write(params->ssc_base + params->pdc->xpr,  prtd->pdc_xpr_save);
+	at91_ssc_write(params->ssc_base + params->pdc->xcr,  prtd->pdc_xcr_save);
+	at91_ssc_write(params->ssc_base + params->pdc->xnpr, prtd->pdc_xnpr_save);
+	at91_ssc_write(params->ssc_base + params->pdc->xncr, prtd->pdc_xncr_save);
+
+	at91_ssc_write(params->ssc_base + ATMEL_PDC_PTCR, params->mask->pdc_enable);
+	return 0;
+}
+#else
+#define at91_pcm_suspend	NULL
+#define at91_pcm_resume		NULL
+#endif
+
+struct snd_soc_platform at91_soc_platform = {
+	.name		= "at91-audio",
+	.pcm_ops 	= &at91_pcm_ops,
+	.pcm_new	= at91_pcm_new,
+	.pcm_free	= at91_pcm_free_dma_buffers,
+	.suspend	= at91_pcm_suspend,
+	.resume		= at91_pcm_resume,
+};
+
+EXPORT_SYMBOL_GPL(at91_soc_platform);
+
+MODULE_AUTHOR("Frank Mandarino <fmandarino@endrelia.com>");
+MODULE_DESCRIPTION("Atmel AT91 PCM module");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/codecs/wm9712.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/wm9712.h	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,14 @@
+/*
+ * wm9712.h  --  WM9712 Soc Audio driver
+ */
+
+#ifndef _WM9712_H
+#define _WM9712_H
+
+#define WM9712_DAI_AC97_HIFI	0
+#define WM9712_DAI_AC97_AUX		1
+
+extern struct snd_soc_codec_dai wm9712_dai[2];
+extern struct snd_soc_codec_device soc_codec_dev_wm9712;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/codecs/Makefile.orig	2007-06-05 17:29:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/Makefile	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,9 @@
+snd-soc-ac97-objs := ac97.o
+snd-soc-wm8731-objs := wm8731.o
+snd-soc-wm8750-objs := wm8750.o
+snd-soc-wm9712-objs := wm9712.o
+
+obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
+obj-$(CONFIG_SND_SOC_WM8731)	+= snd-soc-wm8731.o
+obj-$(CONFIG_SND_SOC_WM8750)	+= snd-soc-wm8750.o
+obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
--- linux-2.6.18.noarch/sound/soc/codecs/ac97.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/ac97.c	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,156 @@
+/*
+ * ac97.c  --  ALSA Soc AC97 codec support
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    17th Oct 2005   Initial version.
+ *
+ * Generic AC97 support.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#define AC97_VERSION "0.6"
+
+static int ac97_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	int reg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		  AC97_PCM_FRONT_DAC_RATE : AC97_PCM_LR_ADC_RATE;
+	return snd_ac97_set_rate(codec->ac97, reg, runtime->rate);
+}
+
+#define STD_AC97_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+static struct snd_soc_codec_dai ac97_dai = {
+	.name = "AC97 HiFi",
+	.playback = {
+		.stream_name = "AC97 Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = STD_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.stream_name = "AC97 Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = STD_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.prepare = ac97_prepare,},
+};
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	return soc_ac97_ops.read(codec->ac97, reg);
+}
+
+static int ac97_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int val)
+{
+	soc_ac97_ops.write(codec->ac97, reg, val);
+	return 0;
+}
+
+static int ac97_soc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	struct snd_ac97_bus *ac97_bus;
+	struct snd_ac97_template ac97_template;
+	int ret = 0;
+
+	printk(KERN_INFO "AC97 SoC Audio Codec %s\n", AC97_VERSION);
+
+	socdev->codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (socdev->codec == NULL)
+		return -ENOMEM;
+	codec = socdev->codec;
+	mutex_init(&codec->mutex);
+
+	codec->name = "AC97";
+	codec->owner = THIS_MODULE;
+	codec->dai = &ac97_dai;
+	codec->num_dai = 1;
+	codec->write = ac97_write;
+	codec->read = ac97_read;
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if(ret < 0)
+		goto err;
+
+	/* add codec as bus device for standard ac97 */
+	ret = snd_ac97_bus(codec->card, 0, &soc_ac97_ops, NULL, &ac97_bus);
+	if(ret < 0)
+		goto bus_err;
+
+	memset(&ac97_template, 0, sizeof(struct snd_ac97_template));
+	ret = snd_ac97_mixer(ac97_bus, &ac97_template, &codec->ac97);
+	if(ret < 0)
+		goto bus_err;
+
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0)
+		goto bus_err;
+	return 0;
+
+bus_err:
+	snd_soc_free_pcms(socdev);
+
+err:
+	kfree(socdev->codec->reg_cache);
+	kfree(socdev->codec);
+	socdev->codec = NULL;
+	return ret;
+}
+
+static int ac97_soc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if(codec == NULL)
+		return 0;
+
+	snd_soc_free_pcms(socdev);
+	kfree(socdev->codec->reg_cache);
+	kfree(socdev->codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_ac97= {
+	.probe = 	ac97_soc_probe,
+	.remove = 	ac97_soc_remove,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_ac97);
+
+MODULE_DESCRIPTION("Soc Generic AC97 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/codecs/wm8750.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/wm8750.c	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,1049 @@
+/*
+ * wm8750.c -- WM8750 ALSA SoC audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on WM8753.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8750.h"
+
+#define AUDIO_NAME "WM8750"
+#define WM8750_VERSION "0.12"
+
+/*
+ * Debug
+ */
+
+#define WM8750_DEBUG 0
+
+#ifdef WM8750_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+/* codec private data */
+struct wm8750_priv {
+	unsigned int sysclk;
+};
+
+/*
+ * wm8750 register cache
+ * We can't read the WM8750 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8750_reg[] = {
+	0x0097, 0x0097, 0x0079, 0x0079,  /*  0 */
+	0x0000, 0x0008, 0x0000, 0x000a,  /*  4 */
+	0x0000, 0x0000, 0x00ff, 0x00ff,  /*  8 */
+	0x000f, 0x000f, 0x0000, 0x0000,  /* 12 */
+	0x0000, 0x007b, 0x0000, 0x0032,  /* 16 */
+	0x0000, 0x00c3, 0x00c3, 0x00c0,  /* 20 */
+	0x0000, 0x0000, 0x0000, 0x0000,  /* 24 */
+	0x0000, 0x0000, 0x0000, 0x0000,  /* 28 */
+	0x0000, 0x0000, 0x0050, 0x0050,  /* 32 */
+	0x0050, 0x0050, 0x0050, 0x0050,  /* 36 */
+	0x0079, 0x0079, 0x0079,          /* 40 */
+};
+
+/*
+ * read wm8750 register cache
+ */
+static inline unsigned int wm8750_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg > WM8750_CACHE_REGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8750 register cache
+ */
+static inline void wm8750_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg > WM8750_CACHE_REGNUM)
+		return;
+	cache[reg] = value;
+}
+
+static int wm8750_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8753 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8750_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8750_reset(c)	wm8750_write(c, WM8750_RESET, 0)
+
+/*
+ * WM8750 Controls
+ */
+static const char *wm8750_bass[] = {"Linear Control", "Adaptive Boost"};
+static const char *wm8750_bass_filter[] = { "130Hz @ 48kHz", "200Hz @ 48kHz" };
+static const char *wm8750_treble[] = {"8kHz", "4kHz"};
+static const char *wm8750_3d_lc[] = {"200Hz", "500Hz"};
+static const char *wm8750_3d_uc[] = {"2.2kHz", "1.5kHz"};
+static const char *wm8750_3d_func[] = {"Capture", "Playback"};
+static const char *wm8750_alc_func[] = {"Off", "Right", "Left", "Stereo"};
+static const char *wm8750_ng_type[] = {"Constant PGA Gain",
+	"Mute ADC Output"};
+static const char *wm8750_line_mux[] = {"Line 1", "Line 2", "Line 3", "PGA",
+	"Differential"};
+static const char *wm8750_pga_sel[] = {"Line 1", "Line 2", "Line 3",
+	"Differential"};
+static const char *wm8750_out3[] = {"VREF", "ROUT1 + Vol", "MonoOut",
+	"ROUT1"};
+static const char *wm8750_diff_sel[] = {"Line 1", "Line 2"};
+static const char *wm8750_adcpol[] = {"Normal", "L Invert", "R Invert",
+	"L + R Invert"};
+static const char *wm8750_deemph[] = {"None", "32Khz", "44.1Khz", "48Khz"};
+static const char *wm8750_mono_mux[] = {"Stereo", "Mono (Left)",
+	"Mono (Right)", "Digital Mono"};
+
+static const struct soc_enum wm8750_enum[] = {
+SOC_ENUM_SINGLE(WM8750_BASS, 7, 2, wm8750_bass),
+SOC_ENUM_SINGLE(WM8750_BASS, 6, 2, wm8750_bass_filter),
+SOC_ENUM_SINGLE(WM8750_TREBLE, 6, 2, wm8750_treble),
+SOC_ENUM_SINGLE(WM8750_3D, 5, 2, wm8750_3d_lc),
+SOC_ENUM_SINGLE(WM8750_3D, 6, 2, wm8750_3d_uc),
+SOC_ENUM_SINGLE(WM8750_3D, 7, 2, wm8750_3d_func),
+SOC_ENUM_SINGLE(WM8750_ALC1, 7, 4, wm8750_alc_func),
+SOC_ENUM_SINGLE(WM8750_NGATE, 1, 2, wm8750_ng_type),
+SOC_ENUM_SINGLE(WM8750_LOUTM1, 0, 5, wm8750_line_mux),
+SOC_ENUM_SINGLE(WM8750_ROUTM1, 0, 5, wm8750_line_mux),
+SOC_ENUM_SINGLE(WM8750_LADCIN, 6, 4, wm8750_pga_sel), /* 10 */
+SOC_ENUM_SINGLE(WM8750_RADCIN, 6, 4, wm8750_pga_sel),
+SOC_ENUM_SINGLE(WM8750_ADCTL2, 7, 4, wm8750_out3),
+SOC_ENUM_SINGLE(WM8750_ADCIN, 8, 2, wm8750_diff_sel),
+SOC_ENUM_SINGLE(WM8750_ADCDAC, 5, 4, wm8750_adcpol),
+SOC_ENUM_SINGLE(WM8750_ADCDAC, 1, 4, wm8750_deemph),
+SOC_ENUM_SINGLE(WM8750_ADCIN, 6, 4, wm8750_mono_mux), /* 16 */
+
+};
+
+static const struct snd_kcontrol_new wm8750_snd_controls[] = {
+
+SOC_DOUBLE_R("Capture Volume", WM8750_LINVOL, WM8750_RINVOL, 0, 63, 0),
+SOC_DOUBLE_R("Capture ZC Switch", WM8750_LINVOL, WM8750_RINVOL, 6, 1, 0),
+SOC_DOUBLE_R("Capture Switch", WM8750_LINVOL, WM8750_RINVOL, 7, 1, 1),
+
+SOC_DOUBLE_R("Headphone Playback ZC Switch", WM8750_LOUT1V,
+	WM8750_ROUT1V, 7, 1, 0),
+SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8750_LOUT2V,
+	WM8750_ROUT2V, 7, 1, 0),
+
+SOC_ENUM("Playback De-emphasis", wm8750_enum[15]),
+
+SOC_ENUM("Capture Polarity", wm8750_enum[14]),
+SOC_SINGLE("Playback 6dB Attenuate", WM8750_ADCDAC, 7, 1, 0),
+SOC_SINGLE("Capture 6dB Attenuate", WM8750_ADCDAC, 8, 1, 0),
+
+SOC_DOUBLE_R("PCM Volume", WM8750_LDAC, WM8750_RDAC, 0, 255, 0),
+
+SOC_ENUM("Bass Boost", wm8750_enum[0]),
+SOC_ENUM("Bass Filter", wm8750_enum[1]),
+SOC_SINGLE("Bass Volume", WM8750_BASS, 0, 15, 1),
+
+SOC_SINGLE("Treble Volume", WM8750_TREBLE, 0, 15, 0),
+SOC_ENUM("Treble Cut-off", wm8750_enum[2]),
+
+SOC_SINGLE("3D Switch", WM8750_3D, 0, 1, 0),
+SOC_SINGLE("3D Volume", WM8750_3D, 1, 15, 0),
+SOC_ENUM("3D Lower Cut-off", wm8750_enum[3]),
+SOC_ENUM("3D Upper Cut-off", wm8750_enum[4]),
+SOC_ENUM("3D Mode", wm8750_enum[5]),
+
+SOC_SINGLE("ALC Capture Target Volume", WM8750_ALC1, 0, 7, 0),
+SOC_SINGLE("ALC Capture Max Volume", WM8750_ALC1, 4, 7, 0),
+SOC_ENUM("ALC Capture Function", wm8750_enum[6]),
+SOC_SINGLE("ALC Capture ZC Switch", WM8750_ALC2, 7, 1, 0),
+SOC_SINGLE("ALC Capture Hold Time", WM8750_ALC2, 0, 15, 0),
+SOC_SINGLE("ALC Capture Decay Time", WM8750_ALC3, 4, 15, 0),
+SOC_SINGLE("ALC Capture Attack Time", WM8750_ALC3, 0, 15, 0),
+SOC_SINGLE("ALC Capture NG Threshold", WM8750_NGATE, 3, 31, 0),
+SOC_ENUM("ALC Capture NG Type", wm8750_enum[4]),
+SOC_SINGLE("ALC Capture NG Switch", WM8750_NGATE, 0, 1, 0),
+
+SOC_SINGLE("Left ADC Capture Volume", WM8750_LADC, 0, 255, 0),
+SOC_SINGLE("Right ADC Capture Volume", WM8750_RADC, 0, 255, 0),
+
+SOC_SINGLE("ZC Timeout Switch", WM8750_ADCTL1, 0, 1, 0),
+SOC_SINGLE("Playback Invert Switch", WM8750_ADCTL1, 1, 1, 0),
+
+SOC_SINGLE("Right Speaker Playback Invert Switch", WM8750_ADCTL2, 4, 1, 0),
+
+/* Unimplemented */
+/* ADCDAC Bit 0 - ADCHPD */
+/* ADCDAC Bit 4 - HPOR */
+/* ADCTL1 Bit 2,3 - DATSEL */
+/* ADCTL1 Bit 4,5 - DMONOMIX */
+/* ADCTL1 Bit 6,7 - VSEL */
+/* ADCTL2 Bit 2 - LRCM */
+/* ADCTL2 Bit 3 - TRI */
+/* ADCTL3 Bit 5 - HPFLREN */
+/* ADCTL3 Bit 6 - VROI */
+/* ADCTL3 Bit 7,8 - ADCLRM */
+/* ADCIN Bit 4 - LDCM */
+/* ADCIN Bit 5 - RDCM */
+
+SOC_DOUBLE_R("Mic Boost", WM8750_LADCIN, WM8750_RADCIN, 4, 3, 0),
+
+SOC_DOUBLE_R("Bypass Left Playback Volume", WM8750_LOUTM1,
+	WM8750_LOUTM2, 4, 7, 1),
+SOC_DOUBLE_R("Bypass Right Playback Volume", WM8750_ROUTM1,
+	WM8750_ROUTM2, 4, 7, 1),
+SOC_DOUBLE_R("Bypass Mono Playback Volume", WM8750_MOUTM1,
+	WM8750_MOUTM2, 4, 7, 1),
+
+SOC_SINGLE("Mono Playback ZC Switch", WM8750_MOUTV, 7, 1, 0),
+
+SOC_DOUBLE_R("Headphone Playback Volume", WM8750_LOUT1V, WM8750_ROUT1V,
+	0, 127, 0),
+SOC_DOUBLE_R("Speaker Playback Volume", WM8750_LOUT2V, WM8750_ROUT2V,
+	0, 127, 0),
+
+SOC_SINGLE("Mono Playback Volume", WM8750_MOUTV, 0, 127, 0),
+
+};
+
+/* add non dapm controls */
+static int wm8750_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8750_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8750_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/*
+ * DAPM Controls
+ */
+
+/* Left Mixer */
+static const struct snd_kcontrol_new wm8750_left_mixer_controls[] = {
+SOC_DAPM_SINGLE("Playback Switch", WM8750_LOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8750_LOUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8750_LOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8750_LOUTM2, 7, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new wm8750_right_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8750_ROUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8750_ROUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Playback Switch", WM8750_ROUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8750_ROUTM2, 7, 1, 0),
+};
+
+/* Mono Mixer */
+static const struct snd_kcontrol_new wm8750_mono_mixer_controls[] = {
+SOC_DAPM_SINGLE("Left Playback Switch", WM8750_MOUTM1, 8, 1, 0),
+SOC_DAPM_SINGLE("Left Bypass Switch", WM8750_MOUTM1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Playback Switch", WM8750_MOUTM2, 8, 1, 0),
+SOC_DAPM_SINGLE("Right Bypass Switch", WM8750_MOUTM2, 7, 1, 0),
+};
+
+/* Left Line Mux */
+static const struct snd_kcontrol_new wm8750_left_line_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[8]);
+
+/* Right Line Mux */
+static const struct snd_kcontrol_new wm8750_right_line_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[9]);
+
+/* Left PGA Mux */
+static const struct snd_kcontrol_new wm8750_left_pga_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[10]);
+
+/* Right PGA Mux */
+static const struct snd_kcontrol_new wm8750_right_pga_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[11]);
+
+/* Out 3 Mux */
+static const struct snd_kcontrol_new wm8750_out3_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[12]);
+
+/* Differential Mux */
+static const struct snd_kcontrol_new wm8750_diffmux_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[13]);
+
+/* Mono ADC Mux */
+static const struct snd_kcontrol_new wm8750_monomux_controls =
+SOC_DAPM_ENUM("Route", wm8750_enum[16]);
+
+static const struct snd_soc_dapm_widget wm8750_dapm_widgets[] = {
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+		&wm8750_left_mixer_controls[0],
+		ARRAY_SIZE(wm8750_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+		&wm8750_right_mixer_controls[0],
+		ARRAY_SIZE(wm8750_right_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Mono Mixer", WM8750_PWR2, 2, 0,
+		&wm8750_mono_mixer_controls[0],
+		ARRAY_SIZE(wm8750_mono_mixer_controls)),
+
+	SND_SOC_DAPM_PGA("Right Out 2", WM8750_PWR2, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 2", WM8750_PWR2, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 1", WM8750_PWR2, 5, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 1", WM8750_PWR2, 6, 0, NULL, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8750_PWR2, 7, 0),
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8750_PWR2, 8, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", WM8750_PWR1, 1, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", WM8750_PWR1, 2, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", WM8750_PWR1, 3, 0),
+
+	SND_SOC_DAPM_MUX("Left PGA Mux", WM8750_PWR1, 5, 0,
+		&wm8750_left_pga_controls),
+	SND_SOC_DAPM_MUX("Right PGA Mux", WM8750_PWR1, 4, 0,
+		&wm8750_right_pga_controls),
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_right_line_controls),
+
+	SND_SOC_DAPM_MUX("Out3 Mux", SND_SOC_NOPM, 0, 0, &wm8750_out3_controls),
+	SND_SOC_DAPM_PGA("Out 3", WM8750_PWR2, 1, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mono Out 1", WM8750_PWR2, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_diffmux_controls),
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0,
+		&wm8750_monomux_controls),
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+	SND_SOC_DAPM_OUTPUT("MONO"),
+	SND_SOC_DAPM_OUTPUT("OUT3"),
+
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("LINPUT2"),
+	SND_SOC_DAPM_INPUT("LINPUT3"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT2"),
+	SND_SOC_DAPM_INPUT("RINPUT3"),
+};
+
+static const char *audio_map[][3] = {
+	/* left mixer */
+	{"Left Mixer", "Playback Switch", "Left DAC"},
+	{"Left Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Left Mixer", "Right Playback Switch", "Right DAC"},
+	{"Left Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* right mixer */
+	{"Right Mixer", "Left Playback Switch", "Left DAC"},
+	{"Right Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Right Mixer", "Playback Switch", "Right DAC"},
+	{"Right Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* left out 1 */
+	{"Left Out 1", NULL, "Left Mixer"},
+	{"LOUT1", NULL, "Left Out 1"},
+
+	/* left out 2 */
+	{"Left Out 2", NULL, "Left Mixer"},
+	{"LOUT2", NULL, "Left Out 2"},
+
+	/* right out 1 */
+	{"Right Out 1", NULL, "Right Mixer"},
+	{"ROUT1", NULL, "Right Out 1"},
+
+	/* right out 2 */
+	{"Right Out 2", NULL, "Right Mixer"},
+	{"ROUT2", NULL, "Right Out 2"},
+
+	/* mono mixer */
+	{"Mono Mixer", "Left Playback Switch", "Left DAC"},
+	{"Mono Mixer", "Left Bypass Switch", "Left Line Mux"},
+	{"Mono Mixer", "Right Playback Switch", "Right DAC"},
+	{"Mono Mixer", "Right Bypass Switch", "Right Line Mux"},
+
+	/* mono out */
+	{"Mono Out 1", NULL, "Mono Mixer"},
+	{"MONO1", NULL, "Mono Out 1"},
+
+	/* out 3 */
+	{"Out3 Mux", "VREF", "VREF"},
+	{"Out3 Mux", "ROUT1 + Vol", "ROUT1"},
+	{"Out3 Mux", "ROUT1", "Right Mixer"},
+	{"Out3 Mux", "MonoOut", "MONO1"},
+	{"Out 3", NULL, "Out3 Mux"},
+	{"OUT3", NULL, "Out 3"},
+
+	/* Left Line Mux */
+	{"Left Line Mux", "Line 1", "LINPUT1"},
+	{"Left Line Mux", "Line 2", "LINPUT2"},
+	{"Left Line Mux", "Line 3", "LINPUT3"},
+	{"Left Line Mux", "PGA", "Left PGA Mux"},
+	{"Left Line Mux", "Differential", "Differential Mux"},
+
+	/* Right Line Mux */
+	{"Right Line Mux", "Line 1", "RINPUT1"},
+	{"Right Line Mux", "Line 2", "RINPUT2"},
+	{"Right Line Mux", "Line 3", "RINPUT3"},
+	{"Right Line Mux", "PGA", "Right PGA Mux"},
+	{"Right Line Mux", "Differential", "Differential Mux"},
+
+	/* Left PGA Mux */
+	{"Left PGA Mux", "Line 1", "LINPUT1"},
+	{"Left PGA Mux", "Line 2", "LINPUT2"},
+	{"Left PGA Mux", "Line 3", "LINPUT3"},
+	{"Left PGA Mux", "Differential", "Differential Mux"},
+
+	/* Right PGA Mux */
+	{"Right PGA Mux", "Line 1", "RINPUT1"},
+	{"Right PGA Mux", "Line 2", "RINPUT2"},
+	{"Right PGA Mux", "Line 3", "RINPUT3"},
+	{"Right PGA Mux", "Differential", "Differential Mux"},
+
+	/* Differential Mux */
+	{"Differential Mux", "Line 1", "LINPUT1"},
+	{"Differential Mux", "Line 1", "RINPUT1"},
+	{"Differential Mux", "Line 2", "LINPUT2"},
+	{"Differential Mux", "Line 2", "RINPUT2"},
+
+	/* Left ADC Mux */
+	{"Left ADC Mux", "Stereo", "Left PGA Mux"},
+	{"Left ADC Mux", "Mono (Left)", "Left PGA Mux"},
+	{"Left ADC Mux", "Digital Mono", "Left PGA Mux"},
+
+	/* Right ADC Mux */
+	{"Right ADC Mux", "Stereo", "Right PGA Mux"},
+	{"Right ADC Mux", "Mono (Right)", "Right PGA Mux"},
+	{"Right ADC Mux", "Digital Mono", "Right PGA Mux"},
+
+	/* ADC */
+	{"Left ADC", NULL, "Left ADC Mux"},
+	{"Right ADC", NULL, "Right ADC Mux"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8750_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8750_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8750_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:5;
+	u8 usb:1;
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12288000, 8000, 1536, 0x6, 0x0},
+	{11289600, 8000, 1408, 0x16, 0x0},
+	{18432000, 8000, 2304, 0x7, 0x0},
+	{16934400, 8000, 2112, 0x17, 0x0},
+	{12000000, 8000, 1500, 0x6, 0x1},
+
+	/* 11.025k */
+	{11289600, 11025, 1024, 0x18, 0x0},
+	{16934400, 11025, 1536, 0x19, 0x0},
+	{12000000, 11025, 1088, 0x19, 0x1},
+
+	/* 16k */
+	{12288000, 16000, 768, 0xa, 0x0},
+	{18432000, 16000, 1152, 0xb, 0x0},
+	{12000000, 16000, 750, 0xa, 0x1},
+
+	/* 22.05k */
+	{11289600, 22050, 512, 0x1a, 0x0},
+	{16934400, 22050, 768, 0x1b, 0x0},
+	{12000000, 22050, 544, 0x1b, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0xc, 0x0},
+	{18432000, 32000, 576, 0xd, 0x0},
+	{12000000, 32000, 375, 0xa, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x10, 0x0},
+	{16934400, 44100, 384, 0x11, 0x0},
+	{12000000, 44100, 272, 0x11, 0x1},
+
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0},
+	{18432000, 48000, 384, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0x1e, 0x0},
+	{16934400, 88200, 192, 0x1f, 0x0},
+	{12000000, 88200, 136, 0x1f, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0xe, 0x0},
+	{18432000, 96000, 192, 0xf, 0x0},
+	{12000000, 96000, 125, 0xe, 0x1},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+
+	printk(KERN_ERR "wm8750: could not get coeff for mclk %d @ rate %d\n",
+		mclk, rate);
+	return -EINVAL;
+}
+
+static int wm8750_set_dai_sysclk(struct snd_soc_codec_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8750_priv *wm8750 = codec->private_data;
+
+	switch (freq) {
+	case 11289600:
+	case 12000000:
+	case 12288000:
+	case 16934400:
+	case 18432000:
+		wm8750->sysclk = freq;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int wm8750_set_dai_fmt(struct snd_soc_codec_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 iface = 0;
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface = 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	wm8750_write(codec, WM8750_IFACE, iface);
+	return 0;
+}
+
+static int wm8750_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct wm8750_priv *wm8750 = codec->private_data;
+	u16 iface = wm8750_read_reg_cache(codec, WM8750_IFACE) & 0x1f3;
+	u16 srate = wm8750_read_reg_cache(codec, WM8750_SRATE) & 0x1c0;
+	int coeff = get_coeff(wm8750->sysclk, params_rate(params));
+
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		iface |= 0x0004;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iface |= 0x0008;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		iface |= 0x000c;
+		break;
+	}
+
+	/* set iface & srate */
+	wm8750_write(codec, WM8750_IFACE, iface);
+	if (coeff >= 0)
+		wm8750_write(codec, WM8750_SRATE, srate |
+			(coeff_div[coeff].sr << 1) | coeff_div[coeff].usb);
+
+	return 0;
+}
+
+static int wm8750_mute(struct snd_soc_codec_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 mute_reg = wm8750_read_reg_cache(codec, WM8750_ADCDAC) & 0xfff7;
+
+	if (mute)
+		wm8750_write(codec, WM8750_ADCDAC, mute_reg | 0x8);
+	else
+		wm8750_write(codec, WM8750_ADCDAC, mute_reg);
+	return 0;
+}
+
+static int wm8750_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 pwr_reg = wm8750_read_reg_cache(codec, WM8750_PWR1) & 0xfe3e;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* set vmid to 50k and unmute dac */
+		wm8750_write(codec, WM8750_PWR1, pwr_reg | 0x00c0);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		/* set vmid to 5k for quick power up */
+		wm8750_write(codec, WM8750_PWR1, pwr_reg | 0x01c1);
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* mute dac and set vmid to 500k, enable VREF */
+		wm8750_write(codec, WM8750_PWR1, pwr_reg | 0x0141);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		wm8750_write(codec, WM8750_PWR1, 0x0001);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+#define WM8750_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8750_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+struct snd_soc_codec_dai wm8750_dai = {
+	.name = "WM8750",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM8750_RATES,
+		.formats = WM8750_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM8750_RATES,
+		.formats = WM8750_FORMATS,},
+	.ops = {
+		.hw_params = wm8750_pcm_hw_params,
+	},
+	.dai_ops = {
+		.digital_mute = wm8750_mute,
+		.set_fmt = wm8750_set_dai_fmt,
+		.set_sysclk = wm8750_set_dai_sysclk,
+	},
+};
+EXPORT_SYMBOL_GPL(wm8750_dai);
+
+static void wm8750_work(struct work_struct *work)
+{
+	struct snd_soc_codec *codec =
+		container_of(work, struct snd_soc_codec, delayed_work.work);
+	wm8750_dapm_event(codec, codec->dapm_state);
+}
+
+static int wm8750_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8750_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8750_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8750_reg); i++) {
+		if (i == WM8750_RESET)
+			continue;
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+
+	wm8750_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* charge wm8750 caps */
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0) {
+		wm8750_dapm_event(codec, SNDRV_CTL_POWER_D2);
+		codec->dapm_state = SNDRV_CTL_POWER_D0;
+		schedule_delayed_work(&codec->delayed_work, msecs_to_jiffies(1000));
+	}
+
+	return 0;
+}
+
+/*
+ * initialise the WM8750 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8750_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8750";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8750_read_reg_cache;
+	codec->write = wm8750_write;
+	codec->dapm_event = wm8750_dapm_event;
+	codec->dai = &wm8750_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = sizeof(wm8750_reg);
+	codec->reg_cache = kmemdup(wm8750_reg, sizeof(wm8750_reg), GFP_KRENEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+
+	wm8750_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8750: failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	/* charge output caps */
+	wm8750_dapm_event(codec, SNDRV_CTL_POWER_D2);
+	codec->dapm_state = SNDRV_CTL_POWER_D3hot;
+	schedule_delayed_work(&codec->delayed_work, msecs_to_jiffies(1000));
+
+	/* set the update bits */
+	reg = wm8750_read_reg_cache(codec, WM8750_LDAC);
+	wm8750_write(codec, WM8750_LDAC, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_RDAC);
+	wm8750_write(codec, WM8750_RDAC, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_LOUT1V);
+	wm8750_write(codec, WM8750_LOUT1V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_ROUT1V);
+	wm8750_write(codec, WM8750_ROUT1V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_LOUT2V);
+	wm8750_write(codec, WM8750_LOUT2V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_ROUT2V);
+	wm8750_write(codec, WM8750_ROUT2V, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_LINVOL);
+	wm8750_write(codec, WM8750_LINVOL, reg | 0x0100);
+	reg = wm8750_read_reg_cache(codec, WM8750_RINVOL);
+	wm8750_write(codec, WM8750_RINVOL, reg | 0x0100);
+
+	wm8750_add_controls(codec);
+	wm8750_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8750: failed to register card\n");
+		goto card_err;
+	}
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+pcm_err:
+	kfree(codec->reg_cache);
+	return ret;
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static struct snd_soc_device *wm8750_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8731 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8750_i2c_driver;
+static struct i2c_client client_template;
+
+static int wm8750_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8750_socdev;
+	struct wm8750_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kmemdup(&client_template, sizeof(client_template), GFP_KERNEL);
+	if (i2c == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8750_init(socdev);
+	if (ret < 0) {
+	err("failed to initialise WM8750\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8750_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8750_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8750_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8750_i2c_driver = {
+	.driver = {
+		.name = "WM8750 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8750,
+	.attach_adapter = wm8750_i2c_attach,
+	.detach_client =  wm8750_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8750",
+	.driver = &wm8750_i2c_driver,
+};
+#endif
+
+static int wm8750_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8750_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec;
+	struct wm8750_priv *wm8750;
+	int ret = 0;
+
+	info("WM8750 Audio Codec %s", WM8750_VERSION);
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	wm8750 = kzalloc(sizeof(struct wm8750_priv), GFP_KERNEL);
+	if (wm8750 == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = wm8750;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	wm8750_socdev = socdev;
+	INIT_DELAYED_WORK(&codec->delayed_work, wm8750_work);
+	
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8750_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+		/* Add other interfaces here */
+#endif
+
+	return ret;
+}
+
+/*
+ * This function forces any delayed work to be queued and run.
+ */
+static int run_delayed_work(struct delayed_work *dwork)
+{
+	int ret;
+
+	/* cancel any work waiting to be queued. */
+	ret = cancel_delayed_work(dwork);
+
+	/* if there was any work waiting then we run it now and
+	 * wait for it's completion */
+	if (ret) {
+		schedule_delayed_work(dwork, 0);
+		flush_scheduled_work();
+	}
+	return ret;
+}
+
+/* power down chip */
+static int wm8750_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8750_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	run_delayed_work(&codec->delayed_work);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8750_i2c_driver);
+#endif
+	kfree(codec->private_data);
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8750 = {
+	.probe = 	wm8750_probe,
+	.remove = 	wm8750_remove,
+	.suspend = 	wm8750_suspend,
+	.resume =	wm8750_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8750);
+
+MODULE_DESCRIPTION("ASoC WM8750 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/codecs/wm8731.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/wm8731.c	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,758 @@
+/*
+ * wm8731.c  --  WM8731 ALSA SoC Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.c by Liam Girdwood
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "wm8731.h"
+
+#define AUDIO_NAME "wm8731"
+#define WM8731_VERSION "0.13"
+
+/*
+ * Debug
+ */
+
+#define WM8731_DEBUG 0
+
+#ifdef WM8731_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+struct snd_soc_codec_device soc_codec_dev_wm8731;
+
+/* codec private data */
+struct wm8731_priv {
+	unsigned int sysclk;
+};
+
+/*
+ * wm8731 register cache
+ * We can't read the WM8731 register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ * There is no point in caching the reset register
+ */
+static const u16 wm8731_reg[WM8731_CACHEREGNUM] = {
+    0x0097, 0x0097, 0x0079, 0x0079,
+    0x000a, 0x0008, 0x009f, 0x000a,
+    0x0000, 0x0000
+};
+
+/*
+ * read wm8731 register cache
+ */
+static inline unsigned int wm8731_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg == WM8731_RESET)
+		return 0;
+	if (reg >= WM8731_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8731 register cache
+ */
+static inline void wm8731_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= WM8731_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8731 register space
+ */
+static int wm8731_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D9 WM8731 register offset
+	 *   D8...D0 register data
+	 */
+	data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	data[1] = value & 0x00ff;
+
+	wm8731_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+#define wm8731_reset(c)	wm8731_write(c, WM8731_RESET, 0)
+
+static const char *wm8731_input_select[] = {"Line In", "Mic"};
+static const char *wm8731_deemph[] = {"None", "32Khz", "44.1Khz", "48Khz"};
+
+static const struct soc_enum wm8731_enum[] = {
+	SOC_ENUM_SINGLE(WM8731_APANA, 2, 2, wm8731_input_select),
+	SOC_ENUM_SINGLE(WM8731_APDIGI, 1, 4, wm8731_deemph),
+};
+
+static const struct snd_kcontrol_new wm8731_snd_controls[] = {
+
+SOC_DOUBLE_R("Master Playback Volume", WM8731_LOUT1V, WM8731_ROUT1V,
+	0, 127, 0),
+SOC_DOUBLE_R("Master Playback ZC Switch", WM8731_LOUT1V, WM8731_ROUT1V,
+	7, 1, 0),
+
+SOC_DOUBLE_R("Capture Volume", WM8731_LINVOL, WM8731_RINVOL, 0, 31, 0),
+SOC_DOUBLE_R("Line Capture Switch", WM8731_LINVOL, WM8731_RINVOL, 7, 1, 1),
+
+SOC_SINGLE("Mic Boost (+20dB)", WM8731_APANA, 0, 1, 0),
+SOC_SINGLE("Capture Mic Switch", WM8731_APANA, 1, 1, 1),
+
+SOC_SINGLE("Sidetone Playback Volume", WM8731_APANA, 6, 3, 1),
+
+SOC_SINGLE("ADC High Pass Filter Switch", WM8731_APDIGI, 0, 1, 1),
+SOC_SINGLE("Store DC Offset Switch", WM8731_APDIGI, 4, 1, 0),
+
+SOC_ENUM("Playback De-emphasis", wm8731_enum[1]),
+};
+
+/* add non dapm controls */
+static int wm8731_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8731_snd_controls); i++) {
+		if ((err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8731_snd_controls[i],codec, NULL))) < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/* Output Mixer */
+static const struct snd_kcontrol_new wm8731_output_mixer_controls[] = {
+SOC_DAPM_SINGLE("Line Bypass Switch", WM8731_APANA, 3, 1, 0),
+SOC_DAPM_SINGLE("Mic Sidetone Switch", WM8731_APANA, 5, 1, 0),
+SOC_DAPM_SINGLE("HiFi Playback Switch", WM8731_APANA, 4, 1, 0),
+};
+
+/* Input mux */
+static const struct snd_kcontrol_new wm8731_input_mux_controls =
+SOC_DAPM_ENUM("Input Select", wm8731_enum[0]);
+
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_MIXER("Output Mixer", WM8731_PWR, 4, 1,
+	&wm8731_output_mixer_controls[0],
+	ARRAY_SIZE(wm8731_output_mixer_controls)),
+SND_SOC_DAPM_DAC("DAC", "HiFi Playback", WM8731_PWR, 3, 1),
+SND_SOC_DAPM_OUTPUT("LOUT"),
+SND_SOC_DAPM_OUTPUT("LHPOUT"),
+SND_SOC_DAPM_OUTPUT("ROUT"),
+SND_SOC_DAPM_OUTPUT("RHPOUT"),
+SND_SOC_DAPM_ADC("ADC", "HiFi Capture", WM8731_PWR, 2, 1),
+SND_SOC_DAPM_MUX("Input Mux", SND_SOC_NOPM, 0, 0, &wm8731_input_mux_controls),
+SND_SOC_DAPM_PGA("Line Input", WM8731_PWR, 0, 1, NULL, 0),
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8731_PWR, 1, 1),
+SND_SOC_DAPM_INPUT("MICIN"),
+SND_SOC_DAPM_INPUT("RLINEIN"),
+SND_SOC_DAPM_INPUT("LLINEIN"),
+};
+
+static const char *intercon[][3] = {
+	/* output mixer */
+	{"Output Mixer", "Line Bypass Switch", "Line Input"},
+	{"Output Mixer", "HiFi Playback Switch", "DAC"},
+	{"Output Mixer", "Mic Sidetone Switch", "Mic Bias"},
+
+	/* outputs */
+	{"RHPOUT", NULL, "Output Mixer"},
+	{"ROUT", NULL, "Output Mixer"},
+	{"LHPOUT", NULL, "Output Mixer"},
+	{"LOUT", NULL, "Output Mixer"},
+
+	/* input mux */
+	{"Input Mux", "Line In", "Line Input"},
+	{"Input Mux", "Mic", "Mic Bias"},
+	{"ADC", NULL, "Input Mux"},
+
+	/* inputs */
+	{"Line Input", NULL, "LLINEIN"},
+	{"Line Input", NULL, "RLINEIN"},
+	{"Mic Bias", NULL, "MICIN"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
+};
+
+static int wm8731_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm8731_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8731_dapm_widgets[i]);
+	}
+
+	/* set up audio path interconnects */
+	for(i = 0; intercon[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, intercon[i][0],
+			intercon[i][1], intercon[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:4;
+	u8 bosr:1;
+	u8 usb:1;
+};
+
+/* codec mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 48k */
+	{12288000, 48000, 256, 0x0, 0x0, 0x0},
+	{18432000, 48000, 384, 0x0, 0x1, 0x0},
+	{12000000, 48000, 250, 0x0, 0x0, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0x6, 0x0, 0x0},
+	{18432000, 32000, 576, 0x6, 0x1, 0x0},
+	{12000000, 32000, 375, 0x6, 0x0, 0x1},
+
+	/* 8k */
+	{12288000, 8000, 1536, 0x3, 0x0, 0x0},
+	{18432000, 8000, 2304, 0x3, 0x1, 0x0},
+	{11289600, 8000, 1408, 0xb, 0x0, 0x0},
+	{16934400, 8000, 2112, 0xb, 0x1, 0x0},
+	{12000000, 8000, 1500, 0x3, 0x0, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0x7, 0x0, 0x0},
+	{18432000, 96000, 192, 0x7, 0x1, 0x0},
+	{12000000, 96000, 125, 0x7, 0x0, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x8, 0x0, 0x0},
+	{16934400, 44100, 384, 0x8, 0x1, 0x0},
+	{12000000, 44100, 272, 0x8, 0x1, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0xf, 0x0, 0x0},
+	{16934400, 88200, 192, 0xf, 0x1, 0x0},
+	{12000000, 88200, 136, 0xf, 0x1, 0x1},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+	return 0;
+}
+
+static int wm8731_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct wm8731_priv *wm8731 = codec->private_data;
+	u16 iface = wm8731_read_reg_cache(codec, WM8731_IFACE) & 0xfff3;
+	int i = get_coeff(wm8731->sysclk, params_rate(params));
+	u16 srate = (coeff_div[i].sr << 2) |
+		(coeff_div[i].bosr << 1) | coeff_div[i].usb;
+
+	wm8731_write(codec, WM8731_SRATE, srate);
+
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		iface |= 0x0004;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iface |= 0x0008;
+		break;
+	}
+
+	wm8731_write(codec, WM8731_IFACE, iface);
+	return 0;
+}
+
+static int wm8731_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	/* set active */
+	wm8731_write(codec, WM8731_ACTIVE, 0x0001);
+
+	return 0;
+}
+
+static void wm8731_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	/* deactivate */
+	if (!codec->active) {
+		udelay(50);
+		wm8731_write(codec, WM8731_ACTIVE, 0x0);
+	}
+}
+
+static int wm8731_mute(struct snd_soc_codec_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 mute_reg = wm8731_read_reg_cache(codec, WM8731_APDIGI) & 0xfff7;
+
+	if (mute)
+		wm8731_write(codec, WM8731_APDIGI, mute_reg | 0x8);
+	else
+		wm8731_write(codec, WM8731_APDIGI, mute_reg);
+	return 0;
+}
+
+static int wm8731_set_dai_sysclk(struct snd_soc_codec_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8731_priv *wm8731 = codec->private_data;
+
+	switch (freq) {
+	case 11289600:
+	case 12000000:
+	case 12288000:
+	case 16934400:
+	case 18432000:
+		wm8731->sysclk = freq;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+static int wm8731_set_dai_fmt(struct snd_soc_codec_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 iface = 0;
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface |= 0x0040;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x0002;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x0001;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0013;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x0090;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x0080;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x0010;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set iface */
+	wm8731_write(codec, WM8731_IFACE, iface);
+	return 0;
+}
+
+static int wm8731_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg = wm8731_read_reg_cache(codec, WM8731_PWR) & 0xff7f;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* vref/mid, osc on, dac unmute */
+		wm8731_write(codec, WM8731_PWR, reg);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* everything off except vref/vmid, */
+		wm8731_write(codec, WM8731_PWR, reg | 0x0040);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* everything off, dac mute, inactive */
+		wm8731_write(codec, WM8731_ACTIVE, 0x0);
+		wm8731_write(codec, WM8731_PWR, 0xffff);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+#define WM8731_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+		SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\
+		SNDRV_PCM_RATE_96000)
+
+#define WM8731_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+struct snd_soc_codec_dai wm8731_dai = {
+	.name = "WM8731",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM8731_RATES,
+		.formats = WM8731_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM8731_RATES,
+		.formats = WM8731_FORMATS,},
+	.ops = {
+		.prepare = wm8731_pcm_prepare,
+		.hw_params = wm8731_hw_params,
+		.shutdown = wm8731_shutdown,
+	},
+	.dai_ops = {
+		.digital_mute = wm8731_mute,
+		.set_sysclk = wm8731_set_dai_sysclk,
+		.set_fmt = wm8731_set_dai_fmt,
+	}
+};
+EXPORT_SYMBOL_GPL(wm8731_dai);
+
+static int wm8731_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm8731_write(codec, WM8731_ACTIVE, 0x0);
+	wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm8731_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8731_reg); i++) {
+		data[0] = (i << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+	wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm8731_dapm_event(codec, codec->suspend_dapm_state);
+	return 0;
+}
+
+/*
+ * initialise the WM8731 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8731_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg, ret = 0;
+
+	codec->name = "WM8731";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8731_read_reg_cache;
+	codec->write = wm8731_write;
+	codec->dapm_event = wm8731_dapm_event;
+	codec->dai = &wm8731_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = sizeof(wm8731_reg);
+	codec->reg_cache = kmemdup(wm8731_reg, sizeof(wm8731_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+
+	wm8731_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8731: failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	/* power on device */
+	wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	/* set the update bits */
+	reg = wm8731_read_reg_cache(codec, WM8731_LOUT1V);
+	wm8731_write(codec, WM8731_LOUT1V, reg | 0x0100);
+	reg = wm8731_read_reg_cache(codec, WM8731_ROUT1V);
+	wm8731_write(codec, WM8731_ROUT1V, reg | 0x0100);
+	reg = wm8731_read_reg_cache(codec, WM8731_LINVOL);
+	wm8731_write(codec, WM8731_LINVOL, reg | 0x0100);
+	reg = wm8731_read_reg_cache(codec, WM8731_RINVOL);
+	wm8731_write(codec, WM8731_RINVOL, reg | 0x0100);
+
+	wm8731_add_controls(codec);
+	wm8731_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8731: failed to register card\n");
+		goto card_err;
+	}
+
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+pcm_err:
+	kfree(codec->reg_cache);
+	return ret;
+}
+
+static struct snd_soc_device *wm8731_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+/*
+ * WM8731 2 wire address is determined by GPIO5
+ * state during powerup.
+ *    low  = 0x1a
+ *    high = 0x1b
+ */
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8731_i2c_driver;
+static struct i2c_client client_template;
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+static int wm8731_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = wm8731_socdev;
+	struct wm8731_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kmemdup(&client_template, sizeof(client_template), GFP_KERNEL);
+	if (i2c == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = wm8731_init(socdev);
+	if (ret < 0) {
+		err("failed to initialise WM8731\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	kfree(i2c);
+	return ret;
+}
+
+static int wm8731_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec* codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int wm8731_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8731_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver wm8731_i2c_driver = {
+	.driver = {
+		.name = "WM8731 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8731,
+	.attach_adapter = wm8731_i2c_attach,
+	.detach_client =  wm8731_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "WM8731",
+	.driver = &wm8731_i2c_driver,
+};
+#endif
+
+static int wm8731_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8731_setup_data *setup;
+	struct snd_soc_codec *codec;
+	struct wm8731_priv *wm8731;
+	int ret = 0;
+
+	info("WM8731 Audio Codec %s", WM8731_VERSION);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	wm8731 = kzalloc(sizeof(struct wm8731_priv), GFP_KERNEL);
+	if (wm8731 == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = wm8731;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	wm8731_socdev = socdev;
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		ret = i2c_add_driver(&wm8731_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8731_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		wm8731_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8731_i2c_driver);
+#endif
+	kfree(codec->private_data);
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8731 = {
+	.probe = 	wm8731_probe,
+	.remove = 	wm8731_remove,
+	.suspend = 	wm8731_suspend,
+	.resume =	wm8731_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8731);
+
+MODULE_DESCRIPTION("ASoC WM8731 driver");
+MODULE_AUTHOR("Richard Purdie");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/codecs/wm8750.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/wm8750.h	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on WM8753.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _WM8750_H
+#define _WM8750_H
+
+/* WM8750 register space */
+
+#define WM8750_LINVOL    0x00
+#define WM8750_RINVOL    0x01
+#define WM8750_LOUT1V    0x02
+#define WM8750_ROUT1V    0x03
+#define WM8750_ADCDAC    0x05
+#define WM8750_IFACE     0x07
+#define WM8750_SRATE     0x08
+#define WM8750_LDAC      0x0a
+#define WM8750_RDAC      0x0b
+#define WM8750_BASS      0x0c
+#define WM8750_TREBLE    0x0d
+#define WM8750_RESET     0x0f
+#define WM8750_3D        0x10
+#define WM8750_ALC1      0x11
+#define WM8750_ALC2      0x12
+#define WM8750_ALC3      0x13
+#define WM8750_NGATE     0x14
+#define WM8750_LADC      0x15
+#define WM8750_RADC      0x16
+#define WM8750_ADCTL1    0x17
+#define WM8750_ADCTL2    0x18
+#define WM8750_PWR1      0x19
+#define WM8750_PWR2      0x1a
+#define WM8750_ADCTL3    0x1b
+#define WM8750_ADCIN     0x1f
+#define WM8750_LADCIN    0x20
+#define WM8750_RADCIN    0x21
+#define WM8750_LOUTM1    0x22
+#define WM8750_LOUTM2    0x23
+#define WM8750_ROUTM1    0x24
+#define WM8750_ROUTM2    0x25
+#define WM8750_MOUTM1    0x26
+#define WM8750_MOUTM2    0x27
+#define WM8750_LOUT2V    0x28
+#define WM8750_ROUT2V    0x29
+#define WM8750_MOUTV     0x2a
+
+#define WM8750_CACHE_REGNUM 0x2a
+
+#define WM8750_SYSCLK	0
+
+struct wm8750_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8750_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8750;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/codecs/wm8731.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/wm8731.h	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,44 @@
+/*
+ * wm8731.h  --  WM8731 Soc Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _WM8731_H
+#define _WM8731_H
+
+/* WM8731 register space */
+
+#define WM8731_LINVOL   0x00
+#define WM8731_RINVOL   0x01
+#define WM8731_LOUT1V   0x02
+#define WM8731_ROUT1V   0x03
+#define WM8731_APANA    0x04
+#define WM8731_APDIGI   0x05
+#define WM8731_PWR      0x06
+#define WM8731_IFACE    0x07
+#define WM8731_SRATE    0x08
+#define WM8731_ACTIVE   0x09
+#define WM8731_RESET	0x0f
+
+#define WM8731_CACHEREGNUM 	10
+
+#define WM8731_SYSCLK	0
+#define WM8731_DAI		0
+
+struct wm8731_setup_data {
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_codec_dai wm8731_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8731;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/codecs/Kconfig.orig	2007-06-05 17:29:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/Kconfig	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,15 @@
+config SND_SOC_AC97_CODEC
+	tristate
+	depends on SND_SOC
+
+config SND_SOC_WM8731
+	tristate
+	depends on SND_SOC
+
+config SND_SOC_WM8750
+	tristate
+	depends on SND_SOC
+
+config SND_SOC_WM9712
+	tristate
+	depends on SND_SOC
--- linux-2.6.18.noarch/sound/soc/codecs/wm9712.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/wm9712.c	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,772 @@
+/*
+ * wm9712.c  --  ALSA Soc WM9712 codec support
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    4th Feb 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#define WM9712_VERSION "0.4"
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg);
+static int ac97_write(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int val);
+
+/*
+ * WM9712 register cache
+ */
+static const u16 wm9712_reg[] = {
+	0x6174, 0x8000, 0x8000, 0x8000, // 6
+	0x0f0f, 0xaaa0, 0xc008, 0x6808, // e
+	0xe808, 0xaaa0, 0xad00, 0x8000, // 16
+	0xe808, 0x3000, 0x8000, 0x0000, // 1e
+	0x0000, 0x0000, 0x0000, 0x000f, // 26
+	0x0405, 0x0410, 0xbb80, 0xbb80, // 2e
+	0x0000, 0xbb80, 0x0000, 0x0000, // 36
+	0x0000, 0x2000, 0x0000, 0x0000, // 3e
+	0x0000, 0x0000, 0x0000, 0x0000, // 46
+	0x0000, 0x0000, 0xf83e, 0xffff, // 4e
+	0x0000, 0x0000, 0x0000, 0xf83e, // 56
+	0x0008, 0x0000, 0x0000, 0x0000, // 5e
+	0xb032, 0x3e00, 0x0000, 0x0000, // 66
+	0x0000, 0x0000, 0x0000, 0x0000, // 6e
+	0x0000, 0x0000, 0x0000, 0x0006, // 76
+	0x0001, 0x0000, 0x574d, 0x4c12, // 7e
+	0x0000, 0x0000 // virtual hp mixers
+};
+
+/* virtual HP mixers regs */
+#define HPL_MIXER	0x80
+#define HPR_MIXER	0x82
+
+static const char *wm9712_alc_select[] = {"None", "Left", "Right", "Stereo"};
+static const char *wm9712_alc_mux[] = {"Stereo", "Left", "Right", "None"};
+static const char *wm9712_out3_src[] = {"Left", "VREF", "Left + Right",
+	"Mono"};
+static const char *wm9712_spk_src[] = {"Speaker Mix", "Headphone Mix"};
+static const char *wm9712_rec_adc[] = {"Stereo", "Left", "Right", "Mute"};
+static const char *wm9712_base[] = {"Linear Control", "Adaptive Boost"};
+static const char *wm9712_rec_gain[] = {"+1.5dB Steps", "+0.75dB Steps"};
+static const char *wm9712_mic[] = {"Mic 1", "Differential", "Mic 2",
+	"Stereo"};
+static const char *wm9712_rec_sel[] = {"Mic", "NC", "NC", "Speaker Mixer",
+	"Line", "Headphone Mixer", "Phone Mixer", "Phone"};
+static const char *wm9712_ng_type[] = {"Constant Gain", "Mute"};
+static const char *wm9712_diff_sel[] = {"Mic", "Line"};
+
+static const struct soc_enum wm9712_enum[] = {
+SOC_ENUM_SINGLE(AC97_PCI_SVID, 14, 4, wm9712_alc_select),
+SOC_ENUM_SINGLE(AC97_VIDEO, 12, 4, wm9712_alc_mux),
+SOC_ENUM_SINGLE(AC97_AUX, 9, 4, wm9712_out3_src),
+SOC_ENUM_SINGLE(AC97_AUX, 8, 2, wm9712_spk_src),
+SOC_ENUM_SINGLE(AC97_REC_SEL, 12, 4, wm9712_rec_adc),
+SOC_ENUM_SINGLE(AC97_MASTER_TONE, 15, 2, wm9712_base),
+SOC_ENUM_DOUBLE(AC97_REC_GAIN, 14, 6, 2, wm9712_rec_gain),
+SOC_ENUM_SINGLE(AC97_MIC, 5, 4, wm9712_mic),
+SOC_ENUM_SINGLE(AC97_REC_SEL, 8, 8, wm9712_rec_sel),
+SOC_ENUM_SINGLE(AC97_REC_SEL, 0, 8, wm9712_rec_sel),
+SOC_ENUM_SINGLE(AC97_PCI_SVID, 5, 2, wm9712_ng_type),
+SOC_ENUM_SINGLE(0x5c, 8, 2, wm9712_diff_sel),
+};
+
+static const struct snd_kcontrol_new wm9712_snd_ac97_controls[] = {
+SOC_DOUBLE("Speaker Playback Volume", AC97_MASTER, 8, 0, 31, 1),
+SOC_SINGLE("Speaker Playback Switch", AC97_MASTER, 15, 1, 1),
+SOC_DOUBLE("Headphone Playback Volume", AC97_HEADPHONE, 8, 0, 31, 1),
+SOC_SINGLE("Headphone Playback Switch", AC97_HEADPHONE,15, 1, 1),
+SOC_DOUBLE("PCM Playback Volume", AC97_PCM, 8, 0, 31, 1),
+
+SOC_SINGLE("Speaker Playback ZC Switch", AC97_MASTER, 7, 1, 0),
+SOC_SINGLE("Speaker Playback Invert Switch", AC97_MASTER, 6, 1, 0),
+SOC_SINGLE("Headphone Playback ZC Switch", AC97_HEADPHONE, 7, 1, 0),
+SOC_SINGLE("Mono Playback ZC Switch", AC97_MASTER_MONO, 7, 1, 0),
+SOC_SINGLE("Mono Playback Volume", AC97_MASTER_MONO, 0, 31, 0),
+
+SOC_SINGLE("ALC Target Volume", AC97_CODEC_CLASS_REV, 12, 15, 0),
+SOC_SINGLE("ALC Hold Time", AC97_CODEC_CLASS_REV, 8, 15, 0),
+SOC_SINGLE("ALC Decay Time", AC97_CODEC_CLASS_REV, 4, 15, 0),
+SOC_SINGLE("ALC Attack Time", AC97_CODEC_CLASS_REV, 0, 15, 0),
+SOC_ENUM("ALC Function", wm9712_enum[0]),
+SOC_SINGLE("ALC Max Volume", AC97_PCI_SVID, 11, 7, 0),
+SOC_SINGLE("ALC ZC Timeout", AC97_PCI_SVID, 9, 3, 1),
+SOC_SINGLE("ALC ZC Switch", AC97_PCI_SVID, 8, 1, 0),
+SOC_SINGLE("ALC NG Switch", AC97_PCI_SVID, 7, 1, 0),
+SOC_ENUM("ALC NG Type", wm9712_enum[10]),
+SOC_SINGLE("ALC NG Threshold", AC97_PCI_SVID, 0, 31, 1),
+
+SOC_SINGLE("Mic Headphone  Volume", AC97_VIDEO, 12, 7, 1),
+SOC_SINGLE("ALC Headphone Volume", AC97_VIDEO, 7, 7, 1),
+
+SOC_SINGLE("Out3 Switch", AC97_AUX, 15, 1, 1),
+SOC_SINGLE("Out3 ZC Switch", AC97_AUX, 7, 1, 1),
+SOC_SINGLE("Out3 Volume", AC97_AUX, 0, 31, 1),
+
+SOC_SINGLE("PCBeep Bypass Headphone Volume", AC97_PC_BEEP, 12, 7, 1),
+SOC_SINGLE("PCBeep Bypass Speaker Volume", AC97_PC_BEEP, 8, 7, 1),
+SOC_SINGLE("PCBeep Bypass Phone Volume", AC97_PC_BEEP, 4, 7, 1),
+
+SOC_SINGLE("Aux Playback Headphone Volume", AC97_CD, 12, 7, 1),
+SOC_SINGLE("Aux Playback Speaker Volume", AC97_CD, 8, 7, 1),
+SOC_SINGLE("Aux Playback Phone Volume", AC97_CD, 4, 7, 1),
+
+SOC_SINGLE("Phone Volume", AC97_PHONE, 0, 15, 0),
+SOC_DOUBLE("Line Capture Volume", AC97_LINE, 8, 0, 31, 1),
+
+SOC_SINGLE("Capture 20dB Boost Switch", AC97_REC_SEL, 14, 1, 0),
+SOC_SINGLE("Capture to Phone 20dB Boost Switch", AC97_REC_SEL, 11, 1, 1),
+
+SOC_SINGLE("3D Upper Cut-off Switch", AC97_3D_CONTROL, 5, 1, 1),
+SOC_SINGLE("3D Lower Cut-off Switch", AC97_3D_CONTROL, 4, 1, 1),
+SOC_SINGLE("3D Playback Volume", AC97_3D_CONTROL, 0, 15, 0),
+
+SOC_ENUM("Bass Control", wm9712_enum[5]),
+SOC_SINGLE("Bass Cut-off Switch", AC97_MASTER_TONE, 12, 1, 1),
+SOC_SINGLE("Tone Cut-off Switch", AC97_MASTER_TONE, 4, 1, 1),
+SOC_SINGLE("Playback Attenuate (-6dB) Switch", AC97_MASTER_TONE, 6, 1, 0),
+SOC_SINGLE("Bass Volume", AC97_MASTER_TONE, 8, 15, 0),
+SOC_SINGLE("Treble Volume", AC97_MASTER_TONE, 0, 15, 0),
+
+SOC_SINGLE("Capture ADC Switch", AC97_REC_GAIN, 15, 1, 1),
+SOC_ENUM("Capture Volume Steps", wm9712_enum[6]),
+SOC_DOUBLE("Capture Volume", AC97_REC_GAIN, 8, 0, 63, 1),
+SOC_SINGLE("Capture ZC Switch", AC97_REC_GAIN, 7, 1, 0),
+
+SOC_SINGLE("Mic 1 Volume", AC97_MIC, 8, 31, 1),
+SOC_SINGLE("Mic 2 Volume", AC97_MIC, 0, 31, 1),
+SOC_SINGLE("Mic 20dB Boost Switch", AC97_MIC, 7, 1, 0),
+};
+
+/* add non dapm controls */
+static int wm9712_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm9712_snd_ac97_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm9712_snd_ac97_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/* We have to create a fake left and right HP mixers because
+ * the codec only has a single control that is shared by both channels.
+ * This makes it impossible to determine the audio path.
+ */
+static int mixer_event (struct snd_soc_dapm_widget *w, int event)
+{
+	u16 l, r, beep, line, phone, mic, pcm, aux;
+
+	l = ac97_read(w->codec, HPL_MIXER);
+	r = ac97_read(w->codec, HPR_MIXER);
+	beep = ac97_read(w->codec, AC97_PC_BEEP);
+	mic = ac97_read(w->codec, AC97_VIDEO);
+	phone = ac97_read(w->codec, AC97_PHONE);
+	line = ac97_read(w->codec, AC97_LINE);
+	pcm = ac97_read(w->codec, AC97_PCM);
+	aux = ac97_read(w->codec, AC97_CD);
+
+	if (l & 0x1 || r & 0x1)
+		ac97_write(w->codec, AC97_VIDEO, mic & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_VIDEO, mic | 0x8000);
+
+	if (l & 0x2 || r & 0x2)
+		ac97_write(w->codec, AC97_PCM, pcm & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PCM, pcm | 0x8000);
+
+	if (l & 0x4 || r & 0x4)
+		ac97_write(w->codec, AC97_LINE, line & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_LINE, line | 0x8000);
+
+	if (l & 0x8 || r & 0x8)
+		ac97_write(w->codec, AC97_PHONE, phone & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PHONE, phone | 0x8000);
+
+	if (l & 0x10 || r & 0x10)
+		ac97_write(w->codec, AC97_CD, aux & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_CD, aux | 0x8000);
+
+	if (l & 0x20 || r & 0x20)
+		ac97_write(w->codec, AC97_PC_BEEP, beep & 0x7fff);
+	else
+		ac97_write(w->codec, AC97_PC_BEEP, beep | 0x8000);
+
+	return 0;
+}
+
+/* Left Headphone Mixers */
+static const struct snd_kcontrol_new wm9712_hpl_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", HPL_MIXER, 5, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", HPL_MIXER, 4, 1, 0),
+	SOC_DAPM_SINGLE("Phone Bypass Switch", HPL_MIXER, 3, 1, 0),
+	SOC_DAPM_SINGLE("Line Bypass Switch", HPL_MIXER, 2, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", HPL_MIXER, 1, 1, 0),
+	SOC_DAPM_SINGLE("Mic Sidetone Switch", HPL_MIXER, 0, 1, 0),
+};
+
+/* Right Headphone Mixers */
+static const struct snd_kcontrol_new wm9712_hpr_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", HPR_MIXER, 5, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", HPR_MIXER, 4, 1, 0),
+	SOC_DAPM_SINGLE("Phone Bypass Switch", HPR_MIXER, 3, 1, 0),
+	SOC_DAPM_SINGLE("Line Bypass Switch", HPR_MIXER, 2, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", HPR_MIXER, 1, 1, 0),
+	SOC_DAPM_SINGLE("Mic Sidetone Switch", HPR_MIXER, 0, 1, 0),
+};
+
+/* Speaker Mixer */
+static const struct snd_kcontrol_new wm9712_speaker_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", AC97_PC_BEEP, 11, 1, 1),
+	SOC_DAPM_SINGLE("Aux Playback Switch", AC97_CD, 11, 1, 1),
+	SOC_DAPM_SINGLE("Phone Bypass Switch", AC97_PHONE, 14, 1, 1),
+	SOC_DAPM_SINGLE("Line Bypass Switch", AC97_LINE, 14, 1, 1),
+	SOC_DAPM_SINGLE("PCM Playback Switch", AC97_PCM, 14, 1, 1),
+};
+
+/* Phone Mixer */
+static const struct snd_kcontrol_new wm9712_phone_mixer_controls[] = {
+	SOC_DAPM_SINGLE("PCBeep Bypass Switch", AC97_PC_BEEP, 7, 1, 1),
+	SOC_DAPM_SINGLE("Aux Playback Switch", AC97_CD, 7, 1, 1),
+	SOC_DAPM_SINGLE("Line Bypass Switch", AC97_LINE, 13, 1, 1),
+	SOC_DAPM_SINGLE("PCM Playback Switch", AC97_PCM, 13, 1, 1),
+	SOC_DAPM_SINGLE("Mic 1 Sidetone Switch", AC97_MIC, 14, 1, 1),
+	SOC_DAPM_SINGLE("Mic 2 Sidetone Switch", AC97_MIC, 13, 1, 1),
+};
+
+/* ALC headphone mux */
+static const struct snd_kcontrol_new wm9712_alc_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[1]);
+
+/* out 3 mux */
+static const struct snd_kcontrol_new wm9712_out3_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[2]);
+
+/* spk mux */
+static const struct snd_kcontrol_new wm9712_spk_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[3]);
+
+/* Capture to Phone mux */
+static const struct snd_kcontrol_new wm9712_capture_phone_mux_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[4]);
+
+/* Capture left select */
+static const struct snd_kcontrol_new wm9712_capture_selectl_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[8]);
+
+/* Capture right select */
+static const struct snd_kcontrol_new wm9712_capture_selectr_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[9]);
+
+/* Mic select */
+static const struct snd_kcontrol_new wm9712_mic_src_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[7]);
+
+/* diff select */
+static const struct snd_kcontrol_new wm9712_diff_sel_controls =
+SOC_DAPM_ENUM("Route", wm9712_enum[11]);
+
+static const struct snd_soc_dapm_widget wm9712_dapm_widgets[] = {
+SND_SOC_DAPM_MUX("ALC Sidetone Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_alc_mux_controls),
+SND_SOC_DAPM_MUX("Out3 Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_out3_mux_controls),
+SND_SOC_DAPM_MUX("Speaker Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_spk_mux_controls),
+SND_SOC_DAPM_MUX("Capture Phone Mux", SND_SOC_NOPM, 0, 0,
+	&wm9712_capture_phone_mux_controls),
+SND_SOC_DAPM_MUX("Left Capture Select", SND_SOC_NOPM, 0, 0,
+	&wm9712_capture_selectl_controls),
+SND_SOC_DAPM_MUX("Right Capture Select", SND_SOC_NOPM, 0, 0,
+	&wm9712_capture_selectr_controls),
+SND_SOC_DAPM_MUX("Mic Select Source", SND_SOC_NOPM, 0, 0,
+	&wm9712_mic_src_controls),
+SND_SOC_DAPM_MUX("Differential Source", SND_SOC_NOPM, 0, 0,
+	&wm9712_diff_sel_controls),
+SND_SOC_DAPM_MIXER("AC97 Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_MIXER_E("Left HP Mixer", AC97_INT_PAGING, 9, 1,
+	&wm9712_hpl_mixer_controls[0], ARRAY_SIZE(wm9712_hpl_mixer_controls),
+	mixer_event, SND_SOC_DAPM_POST_REG),
+SND_SOC_DAPM_MIXER_E("Right HP Mixer", AC97_INT_PAGING, 8, 1,
+	&wm9712_hpr_mixer_controls[0], ARRAY_SIZE(wm9712_hpr_mixer_controls),
+	 mixer_event, SND_SOC_DAPM_POST_REG),
+SND_SOC_DAPM_MIXER("Phone Mixer", AC97_INT_PAGING, 6, 1,
+	&wm9712_phone_mixer_controls[0], ARRAY_SIZE(wm9712_phone_mixer_controls)),
+SND_SOC_DAPM_MIXER("Speaker Mixer", AC97_INT_PAGING, 7, 1,
+	&wm9712_speaker_mixer_controls[0],
+	ARRAY_SIZE(wm9712_speaker_mixer_controls)),
+SND_SOC_DAPM_MIXER("Mono Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback", AC97_INT_PAGING, 14, 1),
+SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback", AC97_INT_PAGING, 13, 1),
+SND_SOC_DAPM_DAC("Aux DAC", "Aux Playback", SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_ADC("Left ADC", "Left HiFi Capture", AC97_INT_PAGING, 12, 1),
+SND_SOC_DAPM_ADC("Right ADC", "Right HiFi Capture", AC97_INT_PAGING, 11, 1),
+SND_SOC_DAPM_PGA("Headphone PGA", AC97_INT_PAGING, 4, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Speaker PGA", AC97_INT_PAGING, 3, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Out 3 PGA", AC97_INT_PAGING, 5, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Line PGA", AC97_INT_PAGING, 2, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Phone PGA", AC97_INT_PAGING, 1, 1, NULL, 0),
+SND_SOC_DAPM_PGA("Mic PGA", AC97_INT_PAGING, 0, 1, NULL, 0),
+SND_SOC_DAPM_MICBIAS("Mic Bias", AC97_INT_PAGING, 10, 1),
+SND_SOC_DAPM_OUTPUT("MONOOUT"),
+SND_SOC_DAPM_OUTPUT("HPOUTL"),
+SND_SOC_DAPM_OUTPUT("HPOUTR"),
+SND_SOC_DAPM_OUTPUT("LOUT2"),
+SND_SOC_DAPM_OUTPUT("ROUT2"),
+SND_SOC_DAPM_OUTPUT("OUT3"),
+SND_SOC_DAPM_INPUT("LINEINL"),
+SND_SOC_DAPM_INPUT("LINEINR"),
+SND_SOC_DAPM_INPUT("PHONE"),
+SND_SOC_DAPM_INPUT("PCBEEP"),
+SND_SOC_DAPM_INPUT("MIC1"),
+SND_SOC_DAPM_INPUT("MIC2"),
+};
+
+static const char *audio_map[][3] = {
+	/* virtual mixer - mixes left & right channels for spk and mono */
+	{"AC97 Mixer", NULL, "Left DAC"},
+	{"AC97 Mixer", NULL, "Right DAC"},
+
+	/* Left HP mixer */
+	{"Left HP Mixer", "PCBeep Bypass Switch", "PCBEEP"},
+	{"Left HP Mixer", "Aux Playback Switch",  "Aux DAC"},
+	{"Left HP Mixer", "Phone Bypass Switch",  "Phone PGA"},
+	{"Left HP Mixer", "Line Bypass Switch",   "Line PGA"},
+	{"Left HP Mixer", "PCM Playback Switch",  "Left DAC"},
+	{"Left HP Mixer", "Mic Sidetone Switch",  "Mic PGA"},
+	{"Left HP Mixer", NULL,  "ALC Sidetone Mux"},
+	//{"Right HP Mixer", NULL, "HP Mixer"},
+
+	/* Right HP mixer */
+	{"Right HP Mixer", "PCBeep Bypass Switch", "PCBEEP"},
+	{"Right HP Mixer", "Aux Playback Switch",  "Aux DAC"},
+	{"Right HP Mixer", "Phone Bypass Switch",  "Phone PGA"},
+	{"Right HP Mixer", "Line Bypass Switch",   "Line PGA"},
+	{"Right HP Mixer", "PCM Playback Switch",  "Right DAC"},
+	{"Right HP Mixer", "Mic Sidetone Switch",  "Mic PGA"},
+	{"Right HP Mixer", NULL,  "ALC Sidetone Mux"},
+
+	/* speaker mixer */
+	{"Speaker Mixer", "PCBeep Bypass Switch", "PCBEEP"},
+	{"Speaker Mixer", "Line Bypass Switch",   "Line PGA"},
+	{"Speaker Mixer", "PCM Playback Switch",  "AC97 Mixer"},
+	{"Speaker Mixer", "Phone Bypass Switch",  "Phone PGA"},
+	{"Speaker Mixer", "Aux Playback Switch",  "Aux DAC"},
+
+	/* Phone mixer */
+	{"Phone Mixer", "PCBeep Bypass Switch",  "PCBEEP"},
+	{"Phone Mixer", "Line Bypass Switch",    "Line PGA"},
+	{"Phone Mixer", "Aux Playback Switch",   "Aux DAC"},
+	{"Phone Mixer", "PCM Playback Switch",   "AC97 Mixer"},
+	{"Phone Mixer", "Mic 1 Sidetone Switch", "Mic PGA"},
+	{"Phone Mixer", "Mic 2 Sidetone Switch", "Mic PGA"},
+
+	/* inputs */
+	{"Line PGA", NULL, "LINEINL"},
+	{"Line PGA", NULL, "LINEINR"},
+	{"Phone PGA", NULL, "PHONE"},
+	{"Mic PGA", NULL, "MIC1"},
+	{"Mic PGA", NULL, "MIC2"},
+
+	/* left capture selector */
+	{"Left Capture Select", "Mic", "MIC1"},
+	{"Left Capture Select", "Speaker Mixer", "Speaker Mixer"},
+	{"Left Capture Select", "Line", "LINEINL"},
+	{"Left Capture Select", "Headphone Mixer", "Left HP Mixer"},
+	{"Left Capture Select", "Phone Mixer", "Phone Mixer"},
+	{"Left Capture Select", "Phone", "PHONE"},
+
+	/* right capture selector */
+	{"Right Capture Select", "Mic", "MIC2"},
+	{"Right Capture Select", "Speaker Mixer", "Speaker Mixer"},
+	{"Right Capture Select", "Line", "LINEINR"},
+	{"Right Capture Select", "Headphone Mixer", "Right HP Mixer"},
+	{"Right Capture Select", "Phone Mixer", "Phone Mixer"},
+	{"Right Capture Select", "Phone", "PHONE"},
+
+	/* ALC Sidetone */
+	{"ALC Sidetone Mux", "Stereo", "Left Capture Select"},
+	{"ALC Sidetone Mux", "Stereo", "Right Capture Select"},
+	{"ALC Sidetone Mux", "Left", "Left Capture Select"},
+	{"ALC Sidetone Mux", "Right", "Right Capture Select"},
+
+	/* ADC's */
+	{"Left ADC", NULL, "Left Capture Select"},
+	{"Right ADC", NULL, "Right Capture Select"},
+
+	/* outputs */
+	{"MONOOUT", NULL, "Phone Mixer"},
+	{"HPOUTL", NULL, "Headphone PGA"},
+	{"Headphone PGA", NULL, "Left HP Mixer"},
+	{"HPOUTR", NULL, "Headphone PGA"},
+	{"Headphone PGA", NULL, "Right HP Mixer"},
+
+	/* mono hp mixer */
+	{"Mono HP Mixer", NULL, "Left HP Mixer"},
+	{"Mono HP Mixer", NULL, "Right HP Mixer"},
+
+	/* Out3 Mux */
+	{"Out3 Mux", "Left", "Left HP Mixer"},
+	{"Out3 Mux", "Mono", "Phone Mixer"},
+	{"Out3 Mux", "Left + Right", "Mono HP Mixer"},
+	{"Out 3 PGA", NULL, "Out3 Mux"},
+	{"OUT3", NULL, "Out 3 PGA"},
+
+	/* speaker Mux */
+	{"Speaker Mux", "Speaker Mix", "Speaker Mixer"},
+	{"Speaker Mux", "Headphone Mix", "Mono HP Mixer"},
+	{"Speaker PGA", NULL, "Speaker Mux"},
+	{"LOUT2", NULL, "Speaker PGA"},
+	{"ROUT2", NULL, "Speaker PGA"},
+
+	{NULL, NULL, NULL},
+};
+
+static int wm9712_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(wm9712_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm9712_dapm_widgets[i]);
+	}
+
+	/* set up audio path audio_mapnects */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg == AC97_RESET || reg == AC97_GPIO_STATUS ||
+		reg == AC97_VENDOR_ID1 || reg == AC97_VENDOR_ID2 ||
+		reg == AC97_REC_GAIN)
+		return soc_ac97_ops.read(codec->ac97, reg);
+	else {
+		reg = reg >> 1;
+
+		if (reg > (ARRAY_SIZE(wm9712_reg)))
+			return -EIO;
+
+		return cache[reg];
+	}
+}
+
+static int ac97_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int val)
+{
+	u16 *cache = codec->reg_cache;
+
+	soc_ac97_ops.write(codec->ac97, reg, val);
+	reg = reg >> 1;
+	if (reg <= (ARRAY_SIZE(wm9712_reg)))
+		cache[reg] = val;
+
+	return 0;
+}
+
+static int ac97_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg;
+	u16 vra;
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg = AC97_PCM_FRONT_DAC_RATE;
+	else
+		reg = AC97_PCM_LR_ADC_RATE;
+
+	return ac97_write(codec, reg, runtime->rate);
+}
+
+static int ac97_aux_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	u16 vra, xsle;
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+	xsle = ac97_read(codec, AC97_PCI_SID);
+	ac97_write(codec, AC97_PCI_SID, xsle | 0x8000);
+
+	if (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+
+	return ac97_write(codec, AC97_PCM_SURR_DAC_RATE, runtime->rate);
+}
+
+#define WM9712_AC97_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+struct snd_soc_codec_dai wm9712_dai[] = {
+{
+	.name = "AC97 HiFi",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM9712_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM9712_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.prepare = ac97_prepare,},
+},
+{
+	.name = "AC97 Aux",
+	.playback = {
+		.stream_name = "Aux Playback",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = WM9712_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.prepare = ac97_aux_prepare,},
+}
+};
+EXPORT_SYMBOL_GPL(wm9712_dai);
+
+static int wm9712_dapm_event(struct snd_soc_codec *codec, int event)
+{
+	u16 reg;
+
+	switch (event) {
+	case SNDRV_CTL_POWER_D0: /* full On */
+		/* liam - maybe enable thermal shutdown */
+		reg = ac97_read(codec, AC97_EXTENDED_MID) & 0xdfff;
+		ac97_write(codec, AC97_EXTENDED_MID, reg);
+		break;
+	case SNDRV_CTL_POWER_D1: /* partial On */
+	case SNDRV_CTL_POWER_D2: /* partial On */
+		break;
+	case SNDRV_CTL_POWER_D3hot: /* Off, with power */
+		/* enable master bias and vmid */
+		reg = ac97_read(codec, AC97_EXTENDED_MID) & 0xbbff;
+		ac97_write(codec, AC97_EXTENDED_MID, reg);
+		ac97_write(codec, AC97_POWERDOWN, 0x0000);
+		break;
+	case SNDRV_CTL_POWER_D3cold: /* Off, without power */
+		/* disable everything including AC link */
+		ac97_write(codec, AC97_EXTENDED_MID, 0xffff);
+		ac97_write(codec, AC97_EXTENDED_MSTATUS, 0xffff);
+		ac97_write(codec, AC97_POWERDOWN, 0xffff);
+		break;
+	}
+	codec->dapm_state = event;
+	return 0;
+}
+
+static int wm9712_reset(struct snd_soc_codec *codec, int try_warm)
+{
+	if (try_warm && soc_ac97_ops.warm_reset) {
+		soc_ac97_ops.warm_reset(codec->ac97);
+		if (!(ac97_read(codec, 0) & 0x8000))
+			return 1;
+	}
+
+	soc_ac97_ops.reset(codec->ac97);
+	if (ac97_read(codec, 0) & 0x8000)
+		goto err;
+	return 0;
+
+err:
+	printk(KERN_ERR "WM9712 AC97 reset failed\n");
+	return -EIO;
+}
+
+static int wm9712_soc_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	wm9712_dapm_event(codec, SNDRV_CTL_POWER_D3cold);
+	return 0;
+}
+
+static int wm9712_soc_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i, ret;
+	u16 *cache = codec->reg_cache;
+
+	ret = wm9712_reset(codec, 1);
+	if (ret < 0){
+		printk(KERN_ERR "could not reset AC97 codec\n");
+		return ret;
+	}
+
+	wm9712_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+
+	if (ret == 0) {
+		/* Sync reg_cache with the hardware after cold reset */
+		for (i = 2; i < ARRAY_SIZE(wm9712_reg) << 1; i+=2) {
+			if (i == AC97_INT_PAGING || i == AC97_POWERDOWN ||
+				(i > 0x58 && i != 0x5c))
+				continue;
+			soc_ac97_ops.write(codec->ac97, i, cache[i>>1]);
+		}
+	}
+
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0)
+		wm9712_dapm_event(codec, SNDRV_CTL_POWER_D0);
+
+	return ret;
+}
+
+static int wm9712_soc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	printk(KERN_INFO "WM9711/WM9712 SoC Audio Codec %s\n", WM9712_VERSION);
+
+	socdev->codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (socdev->codec == NULL)
+		return -ENOMEM;
+	codec = socdev->codec;
+	mutex_init(&codec->mutex);
+
+	codec->reg_cache =
+		kzalloc(sizeof(u16) * ARRAY_SIZE(wm9712_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL) {
+		ret = -ENOMEM;
+		goto cache_err;
+	}
+	memcpy(codec->reg_cache, wm9712_reg, sizeof(u16) * ARRAY_SIZE(wm9712_reg));
+	codec->reg_cache_size = sizeof(u16) * ARRAY_SIZE(wm9712_reg);
+	codec->reg_cache_step = 2;
+
+	codec->name = "WM9712";
+	codec->owner = THIS_MODULE;
+	codec->dai = wm9712_dai;
+	codec->num_dai = ARRAY_SIZE(wm9712_dai);
+	codec->write = ac97_write;
+	codec->read = ac97_read;
+	codec->dapm_event = wm9712_dapm_event;
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	ret = snd_soc_new_ac97_codec(codec, &soc_ac97_ops, 0);
+	if (ret < 0) {
+		printk(KERN_ERR "wm9712: failed to register AC97 codec\n");
+		goto codec_err;
+	}
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0)
+		goto pcm_err;
+
+	ret = wm9712_reset(codec, 0);
+	if (ret < 0) {
+		printk(KERN_ERR "AC97 link error\n");
+		goto reset_err;
+	}
+
+	/* set alc mux to none */
+	ac97_write(codec, AC97_VIDEO, ac97_read(codec, AC97_VIDEO) | 0x3000);
+
+	wm9712_dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+	wm9712_add_controls(codec);
+	wm9712_add_widgets(codec);
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "wm9712: failed to register card\n");
+		goto reset_err;
+	}
+
+	return 0;
+
+reset_err:
+	snd_soc_free_pcms(socdev);
+
+pcm_err:
+	snd_soc_free_ac97_codec(codec);
+
+codec_err:
+	kfree(codec->reg_cache);
+
+cache_err:
+	kfree(socdev->codec);
+	socdev->codec = NULL;
+	return ret;
+}
+
+static int wm9712_soc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec == NULL)
+		return 0;
+
+	snd_soc_dapm_free(socdev);
+	snd_soc_free_pcms(socdev);
+	snd_soc_free_ac97_codec(codec);
+	kfree(codec->reg_cache);
+	kfree(codec);
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm9712 = {
+	.probe = 	wm9712_soc_probe,
+	.remove = 	wm9712_soc_remove,
+	.suspend =	wm9712_soc_suspend,
+	.resume =	wm9712_soc_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm9712);
+
+MODULE_DESCRIPTION("ASoC WM9711/WM9712 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/codecs/ac97.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/codecs/ac97.h	2007-06-05 19:53:41.000000000 -0400
@@ -0,0 +1,18 @@
+/*
+ * linux/sound/codecs/ac97.h -- ALSA SoC Layer
+ *
+ * Author:		Liam Girdwood
+ * Created:		Dec 1st 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_AC97_H
+#define __LINUX_SND_SOC_AC97_H
+
+extern struct snd_soc_codec_device soc_codec_dev_ac97;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/pxa/poodle.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/poodle.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,352 @@
+/*
+ * poodle.c  --  SoC audio for Poodle
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/locomo.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/poodle.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8731.h"
+#include "pxa2xx-pcm.h"
+#include "pxa2xx-i2s.h"
+
+#define POODLE_HP        1
+#define POODLE_HP_OFF    0
+#define POODLE_SPK_ON    1
+#define POODLE_SPK_OFF   0
+
+ /* audio clock in Hz - rounded from 12.235MHz */
+#define POODLE_AUDIO_CLOCK 12288000
+
+static int poodle_jack_func;
+static int poodle_spk_func;
+
+static void poodle_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0;
+
+	/* set up jack connection */
+	if (poodle_jack_func == POODLE_HP) {
+		/* set = unmute headphone */
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_L, 1);
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_R, 1);
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 1);
+	} else {
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_L, 0);
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_MUTE_R, 0);
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+	}
+
+	if (poodle_spk_func == POODLE_SPK_ON)
+		spk = 1;
+
+	/* set the enpoints to their new connetion states */
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", spk);
+
+	/* signal a DAPM event */
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int poodle_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	poodle_ext_control(codec);
+	return 0;
+}
+
+/* we need to unmute the HP at shutdown as the mute burns power on poodle */
+static int poodle_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* set = unmute headphone */
+	locomo_gpio_write(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_L, 1);
+	locomo_gpio_write(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_R, 1);
+	return 0;
+}
+
+static int poodle_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int clk = 0;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 48000:
+	case 96000:
+		clk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+		clk = 11289600;
+		break;
+	}
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8731_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set the I2S system clock as input (unused) */
+	ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops poodle_ops = {
+	.startup = poodle_startup,
+	.hw_params = poodle_hw_params,
+	.shutdown = poodle_shutdown,
+};
+
+static int poodle_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = poodle_jack_func;
+	return 0;
+}
+
+static int poodle_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (poodle_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	poodle_jack_func = ucontrol->value.integer.value[0];
+	poodle_ext_control(codec);
+	return 1;
+}
+
+static int poodle_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = poodle_spk_func;
+	return 0;
+}
+
+static int poodle_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (poodle_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	poodle_spk_func = ucontrol->value.integer.value[0];
+	poodle_ext_control(codec);
+	return 1;
+}
+
+static int poodle_amp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_AMP_ON, 0);
+	else
+		locomo_gpio_write(&poodle_locomo_device.dev,
+			POODLE_LOCOMO_GPIO_AMP_ON, 1);
+
+	return 0;
+}
+
+/* poodle machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_SPK("Ext Spk", poodle_amp_event),
+};
+
+/* Corgi machine audio_mapnections to the codec pins */
+static const char *audio_map[][3] = {
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	/* speaker connected to LOUT, ROUT */
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Off", "Headphone"};
+static const char *spk_function[] = {"Off", "On"};
+static const struct soc_enum poodle_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const snd_kcontrol_new_t wm8731_poodle_controls[] = {
+	SOC_ENUM_EXT("Jack Function", poodle_enum[0], poodle_get_jack,
+		poodle_set_jack),
+	SOC_ENUM_EXT("Speaker Function", poodle_enum[1], poodle_get_spk,
+		poodle_set_spk),
+};
+
+/*
+ * Logic for a wm8731 as connected on a Sharp SL-C7x0 Device
+ */
+static int poodle_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "MICIN", 1);
+
+	/* Add poodle specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8731_poodle_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8731_poodle_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add poodle specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8731_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8731_dapm_widgets[i]);
+	}
+
+	/* Set up poodle specific audio path audio_map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+/* poodle digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link poodle_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8731_dai,
+	.init = poodle_wm8731_init,
+	.ops = &poodle_ops,
+};
+
+/* poodle audio machine driver */
+static struct snd_soc_machine snd_soc_machine_poodle = {
+	.name = "Poodle",
+	.dai_link = &poodle_dai,
+	.num_links = 1,
+};
+
+/* poodle audio private data */
+static struct wm8731_setup_data poodle_wm8731_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* poodle audio subsystem */
+static struct snd_soc_device poodle_snd_devdata = {
+	.machine = &snd_soc_machine_poodle,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &poodle_wm8731_setup,
+};
+
+static struct platform_device *poodle_snd_device;
+
+static int __init poodle_init(void)
+{
+	int ret;
+
+	if (!machine_is_poodle())
+		return -ENODEV;
+
+	locomo_gpio_set_dir(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_AMP_ON, 0);
+	/* should we mute HP at startup - burning power ?*/
+	locomo_gpio_set_dir(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_L, 0);
+	locomo_gpio_set_dir(&poodle_locomo_device.dev,
+		POODLE_LOCOMO_GPIO_MUTE_R, 0);
+
+	poodle_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!poodle_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(poodle_snd_device, &poodle_snd_devdata);
+	poodle_snd_devdata.dev = &poodle_snd_device->dev;
+	ret = platform_device_add(poodle_snd_device);
+
+	if (ret)
+		platform_device_put(poodle_snd_device);
+
+	return ret;
+}
+
+static void __exit poodle_exit(void)
+{
+	platform_device_unregister(poodle_snd_device);
+}
+
+module_init(poodle_init);
+module_exit(poodle_exit);
+
+/* Module information */
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Poodle");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-ac97.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-ac97.h	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,22 @@
+/*
+ * linux/sound/arm/pxa2xx-ac97.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PXA2XX_AC97_H
+#define _PXA2XX_AC97_H
+
+/* pxa2xx DAI ID's */
+#define PXA2XX_DAI_AC97_HIFI	0
+#define PXA2XX_DAI_AC97_AUX		1
+#define PXA2XX_DAI_AC97_MIC		2
+
+extern struct snd_soc_cpu_dai pxa_ac97_dai[3];
+
+/* platform data */
+extern struct snd_ac97_bus_ops pxa2xx_ac97_ops;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/pxa/Makefile.orig	2007-06-05 17:30:09.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/Makefile	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,20 @@
+# PXA Platform Support
+snd-soc-pxa2xx-objs := pxa2xx-pcm.o
+snd-soc-pxa2xx-ac97-objs := pxa2xx-ac97.o
+snd-soc-pxa2xx-i2s-objs := pxa2xx-i2s.o
+
+obj-$(CONFIG_SND_PXA2XX_SOC) += snd-soc-pxa2xx.o
+obj-$(CONFIG_SND_PXA2XX_SOC_AC97) += snd-soc-pxa2xx-ac97.o
+obj-$(CONFIG_SND_PXA2XX_SOC_I2S) += snd-soc-pxa2xx-i2s.o
+
+# PXA Machine Support
+snd-soc-corgi-objs := corgi.o
+snd-soc-poodle-objs := poodle.o
+snd-soc-tosa-objs := tosa.o
+snd-soc-spitz-objs := spitz.o
+
+obj-$(CONFIG_SND_PXA2XX_SOC_CORGI) += snd-soc-corgi.o
+obj-$(CONFIG_SND_PXA2XX_SOC_POODLE) += snd-soc-poodle.o
+obj-$(CONFIG_SND_PXA2XX_SOC_TOSA) += snd-soc-tosa.o
+obj-$(CONFIG_SND_PXA2XX_SOC_SPITZ) += snd-soc-spitz.o
+
--- linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-ac97.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-ac97.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,431 @@
+/*
+ * linux/sound/pxa2xx-ac97.c -- AC97 support for the Intel PXA2xx chip.
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Dec 02, 2004
+ * Copyright:	MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/irq.h>
+#include <linux/mutex.h>
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+
+#include "pxa2xx-pcm.h"
+#include "pxa2xx-ac97.h"
+
+static DEFINE_MUTEX(car_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(gsr_wq);
+static volatile long gsr_bits;
+
+/*
+ * Beware PXA27x bugs:
+ *
+ *   o Slot 12 read from modem space will hang controller.
+ *   o CDONE, SDONE interrupt fails after any slot 12 IO.
+ *
+ * We therefore have an hybrid approach for waiting on SDONE (interrupt or
+ * 1 jiffy timeout if interrupt never comes).
+ */
+
+static unsigned short pxa2xx_ac97_read(struct snd_ac97 *ac97,
+	unsigned short reg)
+{
+	unsigned short val = -1;
+	volatile u32 *reg_addr;
+
+	mutex_lock(&car_mutex);
+
+	/* set up primary or secondary codec/modem space */
+#ifdef CONFIG_PXA27x
+	reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#else
+	if (reg == AC97_GPIO_STATUS)
+		reg_addr = ac97->num ? &SMC_REG_BASE : &PMC_REG_BASE;
+	else
+		reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#endif
+	reg_addr += (reg >> 1);
+
+#ifndef CONFIG_PXA27x
+	if (reg == AC97_GPIO_STATUS) {
+		/* read from controller cache */
+		val = *reg_addr;
+		goto out;
+	}
+#endif
+
+	/* start read access across the ac97 link */
+	GSR = GSR_CDONE | GSR_SDONE;
+	gsr_bits = 0;
+	val = *reg_addr;
+
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1);
+	if (!((GSR | gsr_bits) & GSR_SDONE)) {
+		printk(KERN_ERR "%s: read error (ac97_reg=%x GSR=%#lx)\n",
+				__FUNCTION__, reg, GSR | gsr_bits);
+		val = -1;
+		goto out;
+	}
+
+	/* valid data now */
+	GSR = GSR_CDONE | GSR_SDONE;
+	gsr_bits = 0;
+	val = *reg_addr;
+	/* but we've just started another cycle... */
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1);
+
+out:	mutex_unlock(&car_mutex);
+	return val;
+}
+
+static void pxa2xx_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+	unsigned short val)
+{
+	volatile u32 *reg_addr;
+
+	mutex_lock(&car_mutex);
+
+	/* set up primary or secondary codec/modem space */
+#ifdef CONFIG_PXA27x
+	reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#else
+	if (reg == AC97_GPIO_STATUS)
+		reg_addr = ac97->num ? &SMC_REG_BASE : &PMC_REG_BASE;
+	else
+		reg_addr = ac97->num ? &SAC_REG_BASE : &PAC_REG_BASE;
+#endif
+	reg_addr += (reg >> 1);
+
+	GSR = GSR_CDONE | GSR_SDONE;
+	gsr_bits = 0;
+	*reg_addr = val;
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_CDONE, 1);
+	if (!((GSR | gsr_bits) & GSR_CDONE))
+		printk(KERN_ERR "%s: write error (ac97_reg=%x GSR=%#lx)\n",
+				__FUNCTION__, reg, GSR | gsr_bits);
+
+	mutex_unlock(&car_mutex);
+}
+
+static void pxa2xx_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	gsr_bits = 0;
+
+#ifdef CONFIG_PXA27x
+	/* warm reset broken on Bulverde,
+	   so manually keep AC97 reset high */
+	pxa_gpio_mode(113 | GPIO_OUT | GPIO_DFLT_HIGH);
+	udelay(10);
+	GCR |= GCR_WARM_RST;
+	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
+	udelay(500);
+#else
+	GCR |= GCR_WARM_RST | GCR_PRIRDY_IEN | GCR_SECRDY_IEN;
+	wait_event_timeout(gsr_wq, gsr_bits & (GSR_PCR | GSR_SCR), 1);
+#endif
+
+	if (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)))
+		printk(KERN_INFO "%s: warm reset timeout (GSR=%#lx)\n",
+				 __FUNCTION__, gsr_bits);
+
+	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
+	GCR |= GCR_SDONE_IE|GCR_CDONE_IE;
+}
+
+static void pxa2xx_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	GCR &=  GCR_COLD_RST;  /* clear everything but nCRST */
+	GCR &= ~GCR_COLD_RST;  /* then assert nCRST */
+
+	gsr_bits = 0;
+#ifdef CONFIG_PXA27x
+	/* PXA27x Developers Manual section 13.5.2.2.1 */
+	pxa_set_cken(1 << 31, 1);
+	udelay(5);
+	pxa_set_cken(1 << 31, 0);
+	GCR = GCR_COLD_RST;
+	udelay(50);
+#else
+	GCR = GCR_COLD_RST;
+	GCR |= GCR_CDONE_IE|GCR_SDONE_IE;
+	wait_event_timeout(gsr_wq, gsr_bits & (GSR_PCR | GSR_SCR), 1);
+#endif
+
+	if (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)))
+		printk(KERN_INFO "%s: cold reset timeout (GSR=%#lx)\n",
+				 __FUNCTION__, gsr_bits);
+
+	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
+	GCR |= GCR_SDONE_IE|GCR_CDONE_IE;
+}
+
+static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id)
+{
+	long status;
+
+	status = GSR;
+	if (status) {
+		GSR = status;
+		gsr_bits |= status;
+		wake_up(&gsr_wq);
+
+#ifdef CONFIG_PXA27x
+		/* Although we don't use those we still need to clear them
+		   since they tend to spuriously trigger when MMC is used
+		   (hardware bug? go figure)... */
+		MISR = MISR_EOC;
+		PISR = PISR_EOC;
+		MCSR = MCSR_EOC;
+#endif
+
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+struct snd_ac97_bus_ops soc_ac97_ops = {
+	.read	= pxa2xx_ac97_read,
+	.write	= pxa2xx_ac97_write,
+	.warm_reset	= pxa2xx_ac97_warm_reset,
+	.reset	= pxa2xx_ac97_cold_reset,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_stereo_out = {
+	.name			= "AC97 PCM Stereo out",
+	.dev_addr		= __PREG(PCDR),
+	.drcmr			= &DRCMRTXPCDR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_stereo_in = {
+	.name			= "AC97 PCM Stereo in",
+	.dev_addr		= __PREG(PCDR),
+	.drcmr			= &DRCMRRXPCDR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_aux_mono_out = {
+	.name			= "AC97 Aux PCM (Slot 5) Mono out",
+	.dev_addr		= __PREG(MODR),
+	.drcmr			= &DRCMRTXMODR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_aux_mono_in = {
+	.name			= "AC97 Aux PCM (Slot 5) Mono in",
+	.dev_addr		= __PREG(MODR),
+	.drcmr			= &DRCMRRXMODR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_mic_mono_in = {
+	.name			= "AC97 Mic PCM (Slot 6) Mono in",
+	.dev_addr		= __PREG(MCDR),
+	.drcmr			= &DRCMRRXMCDR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST16 | DCMD_WIDTH2,
+};
+
+#ifdef CONFIG_PM
+static int pxa2xx_ac97_suspend(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	GCR |= GCR_ACLINK_OFF;
+	pxa_set_cken(CKEN2_AC97, 0);
+	return 0;
+}
+
+static int pxa2xx_ac97_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	pxa_gpio_mode(GPIO31_SYNC_AC97_MD);
+	pxa_gpio_mode(GPIO30_SDATA_OUT_AC97_MD);
+	pxa_gpio_mode(GPIO28_BITCLK_AC97_MD);
+	pxa_gpio_mode(GPIO29_SDATA_IN_AC97_MD);
+#ifdef CONFIG_PXA27x
+	/* Use GPIO 113 as AC97 Reset on Bulverde */
+	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
+#endif
+	pxa_set_cken(CKEN2_AC97, 1);
+	return 0;
+}
+
+#else
+#define pxa2xx_ac97_suspend	NULL
+#define pxa2xx_ac97_resume	NULL
+#endif
+
+static int pxa2xx_ac97_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = request_irq(IRQ_AC97, pxa2xx_ac97_irq, IRQF_DISABLED, "AC97", NULL);
+	if (ret < 0)
+		goto err;
+
+	pxa_gpio_mode(GPIO31_SYNC_AC97_MD);
+	pxa_gpio_mode(GPIO30_SDATA_OUT_AC97_MD);
+	pxa_gpio_mode(GPIO28_BITCLK_AC97_MD);
+	pxa_gpio_mode(GPIO29_SDATA_IN_AC97_MD);
+#ifdef CONFIG_PXA27x
+	/* Use GPIO 113 as AC97 Reset on Bulverde */
+	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
+#endif
+	pxa_set_cken(CKEN2_AC97, 1);
+	return 0;
+
+ err:
+	if (CKEN & CKEN2_AC97) {
+		GCR |= GCR_ACLINK_OFF;
+		free_irq(IRQ_AC97, NULL);
+		pxa_set_cken(CKEN2_AC97, 0);
+	}
+	return ret;
+}
+
+static void pxa2xx_ac97_remove(struct platform_device *pdev)
+{
+	GCR |= GCR_ACLINK_OFF;
+	free_irq(IRQ_AC97, NULL);
+	pxa_set_cken(CKEN2_AC97, 0);
+}
+
+static int pxa2xx_ac97_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->dma_data = &pxa2xx_ac97_pcm_stereo_out;
+	else
+		cpu_dai->dma_data = &pxa2xx_ac97_pcm_stereo_in;
+
+	return 0;
+}
+
+static int pxa2xx_ac97_hw_aux_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->dma_data = &pxa2xx_ac97_pcm_aux_mono_out;
+	else
+		cpu_dai->dma_data = &pxa2xx_ac97_pcm_aux_mono_in;
+
+	return 0;
+}
+
+static int pxa2xx_ac97_hw_mic_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+	else
+		cpu_dai->dma_data = &pxa2xx_ac97_pcm_mic_mono_in;
+
+	return 0;
+}
+
+#define PXA2XX_AC97_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+		SNDRV_PCM_RATE_48000)
+
+/*
+ * There is only 1 physical AC97 interface for pxa2xx, but it
+ * has extra fifo's that can be used for aux DACs and ADCs.
+ */
+struct snd_soc_cpu_dai pxa_ac97_dai[] = {
+{
+	.name = "pxa2xx-ac97",
+	.id = 0,
+	.type = SND_SOC_DAI_AC97,
+	.probe = pxa2xx_ac97_probe,
+	.remove = pxa2xx_ac97_remove,
+	.suspend = pxa2xx_ac97_suspend,
+	.resume = pxa2xx_ac97_resume,
+	.playback = {
+		.stream_name = "AC97 Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = PXA2XX_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.stream_name = "AC97 Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = PXA2XX_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.hw_params = pxa2xx_ac97_hw_params,},
+},
+{
+	.name = "pxa2xx-ac97-aux",
+	.id = 1,
+	.type = SND_SOC_DAI_AC97,
+	.playback = {
+		.stream_name = "AC97 Aux Playback",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = PXA2XX_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.stream_name = "AC97 Aux Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = PXA2XX_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.hw_params = pxa2xx_ac97_hw_aux_params,},
+},
+{
+	.name = "pxa2xx-ac97-mic",
+	.id = 2,
+	.type = SND_SOC_DAI_AC97,
+	.capture = {
+		.stream_name = "AC97 Mic Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = PXA2XX_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.hw_params = pxa2xx_ac97_hw_mic_params,},
+},
+};
+
+EXPORT_SYMBOL_GPL(pxa_ac97_dai);
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
+
+MODULE_AUTHOR("Nicolas Pitre");
+MODULE_DESCRIPTION("AC97 driver for the Intel PXA2xx chip");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-i2s.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-i2s.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,318 @@
+/*
+ * pxa2xx-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+
+#include "pxa2xx-pcm.h"
+#include "pxa2xx-i2s.h"
+
+struct pxa_i2s_port {
+	u32 sadiv;
+	u32 sacr0;
+	u32 sacr1;
+	u32 saimr;
+	int master;
+	u32 fmt;
+};
+static struct pxa_i2s_port pxa_i2s;
+
+static struct pxa2xx_pcm_dma_params pxa2xx_i2s_pcm_stereo_out = {
+	.name			= "I2S PCM Stereo out",
+	.dev_addr		= __PREG(SADR),
+	.drcmr			= &DRCMRTXSADR,
+	.dcmd			= DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_pcm_dma_params pxa2xx_i2s_pcm_stereo_in = {
+	.name			= "I2S PCM Stereo in",
+	.dev_addr		= __PREG(SADR),
+	.drcmr			= &DRCMRRXSADR,
+	.dcmd			= DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				  DCMD_BURST32 | DCMD_WIDTH4,
+};
+
+static struct pxa2xx_gpio gpio_bus[] = {
+	{ /* I2S SoC Slave */
+		.rx = GPIO29_SDATA_IN_I2S_MD,
+		.tx = GPIO30_SDATA_OUT_I2S_MD,
+		.clk = GPIO28_BITCLK_IN_I2S_MD,
+		.frm = GPIO31_SYNC_I2S_MD,
+	},
+	{ /* I2S SoC Master */
+#ifdef CONFIG_PXA27x
+		.sys = GPIO113_I2S_SYSCLK_MD,
+#else
+		.sys = GPIO32_SYSCLK_I2S_MD,
+#endif
+		.rx = GPIO29_SDATA_IN_I2S_MD,
+		.tx = GPIO30_SDATA_OUT_I2S_MD,
+		.clk = GPIO28_BITCLK_OUT_I2S_MD,
+		.frm = GPIO31_SYNC_I2S_MD,
+	},
+};
+
+static int pxa2xx_i2s_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	if (!cpu_dai->active) {
+		SACR0 |= SACR0_RST;
+		SACR0 = 0;
+	}
+
+	return 0;
+}
+
+/* wait for I2S controller to be ready */
+static int pxa_i2s_wait(void)
+{
+	int i;
+
+	/* flush the Rx FIFO */
+	for(i = 0; i < 16; i++)
+		SADR;
+	return 0;
+}
+
+static int pxa2xx_i2s_set_dai_fmt(struct snd_soc_cpu_dai *cpu_dai,
+		unsigned int fmt)
+{
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		pxa_i2s.fmt = 0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		pxa_i2s.fmt = SACR1_AMSL;
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		pxa_i2s.master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		pxa_i2s.master = 0;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int pxa2xx_i2s_set_dai_sysclk(struct snd_soc_cpu_dai *cpu_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	if (clk_id != PXA2XX_I2S_SYSCLK)
+		return -ENODEV;
+
+	if (pxa_i2s.master && dir == SND_SOC_CLOCK_OUT)
+		pxa_gpio_mode(gpio_bus[pxa_i2s.master].sys);
+
+	return 0;
+}
+
+static int pxa2xx_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].rx);
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].tx);
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].frm);
+	pxa_gpio_mode(gpio_bus[pxa_i2s.master].clk);
+	pxa_set_cken(CKEN8_I2S, 1);
+	pxa_i2s_wait();
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->dma_data = &pxa2xx_i2s_pcm_stereo_out;
+	else
+		cpu_dai->dma_data = &pxa2xx_i2s_pcm_stereo_in;
+
+	/* is port used by another stream */
+	if (!(SACR0 & SACR0_ENB)) {
+
+		SACR0 = 0;
+		SACR1 = 0;
+		if (pxa_i2s.master)
+			SACR0 |= SACR0_BCKD;
+
+		SACR0 |= SACR0_RFTH(14) | SACR0_TFTH(1);
+		SACR1 |= pxa_i2s.fmt;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		SAIMR |= SAIMR_TFS;
+	else
+		SAIMR |= SAIMR_RFS;
+
+	switch (params_rate(params)) {
+	case 8000:
+		SADIV = 0x48;
+		break;
+	case 11025:
+		SADIV = 0x34;
+		break;
+	case 16000:
+		SADIV = 0x24;
+		break;
+	case 22050:
+		SADIV = 0x1a;
+		break;
+	case 44100:
+		SADIV = 0xd;
+		break;
+	case 48000:
+		SADIV = 0xc;
+		break;
+	case 96000: /* not in manual and possibly slightly inaccurate */
+		SADIV = 0x6;
+		break;
+	}
+
+	return 0;
+}
+
+static int pxa2xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		SACR0 |= SACR0_ENB;
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void pxa2xx_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		SACR1 |= SACR1_DRPL;
+		SAIMR &= ~SAIMR_TFS;
+	} else {
+		SACR1 |= SACR1_DREC;
+		SAIMR &= ~SAIMR_RFS;
+	}
+
+	if (SACR1 & (SACR1_DREC | SACR1_DRPL)) {
+		SACR0 &= ~SACR0_ENB;
+		pxa_i2s_wait();
+		pxa_set_cken(CKEN8_I2S, 0);
+	}
+}
+
+#ifdef CONFIG_PM
+static int pxa2xx_i2s_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	/* store registers */
+	pxa_i2s.sacr0 = SACR0;
+	pxa_i2s.sacr1 = SACR1;
+	pxa_i2s.saimr = SAIMR;
+	pxa_i2s.sadiv = SADIV;
+
+	/* deactivate link */
+	SACR0 &= ~SACR0_ENB;
+	pxa_i2s_wait();
+	return 0;
+}
+
+static int pxa2xx_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	pxa_i2s_wait();
+
+	SACR0 = pxa_i2s.sacr0 &= ~SACR0_ENB;
+	SACR1 = pxa_i2s.sacr1;
+	SAIMR = pxa_i2s.saimr;
+	SADIV = pxa_i2s.sadiv;
+	SACR0 |= SACR0_ENB;
+
+	return 0;
+}
+
+#else
+#define pxa2xx_i2s_suspend	NULL
+#define pxa2xx_i2s_resume	NULL
+#endif
+
+#define PXA2XX_I2S_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000)
+
+struct snd_soc_cpu_dai pxa_i2s_dai = {
+	.name = "pxa2xx-i2s",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.suspend = pxa2xx_i2s_suspend,
+	.resume = pxa2xx_i2s_resume,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = PXA2XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = PXA2XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.startup = pxa2xx_i2s_startup,
+		.shutdown = pxa2xx_i2s_shutdown,
+		.trigger = pxa2xx_i2s_trigger,
+		.hw_params = pxa2xx_i2s_hw_params,},
+	.dai_ops = {
+		.set_fmt = pxa2xx_i2s_set_dai_fmt,
+		.set_sysclk = pxa2xx_i2s_set_dai_sysclk,
+	},
+};
+
+EXPORT_SYMBOL_GPL(pxa_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("pxa2xx I2S SoC Interface");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/pxa/spitz.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/spitz.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,394 @@
+/*
+ * spitz.c  --  SoC audio for Sharp SL-Cxx00 models Spitz, Borzoi and Akita
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/akita.h>
+#include <asm/arch/spitz.h>
+#include <asm/mach-types.h>
+#include "../codecs/wm8750.h"
+#include "pxa2xx-pcm.h"
+#include "pxa2xx-i2s.h"
+
+#define SPITZ_HP        0
+#define SPITZ_MIC       1
+#define SPITZ_LINE      2
+#define SPITZ_HEADSET   3
+#define SPITZ_HP_OFF    4
+#define SPITZ_SPK_ON    0
+#define SPITZ_SPK_OFF   1
+
+ /* audio clock in Hz - rounded from 12.235MHz */
+#define SPITZ_AUDIO_CLOCK 12288000
+
+static int spitz_jack_func;
+static int spitz_spk_func;
+
+static void spitz_ext_control(struct snd_soc_codec *codec)
+{
+	if (spitz_spk_func == SPITZ_SPK_ON)
+		snd_soc_dapm_set_endpoint(codec, "Ext Spk", 1);
+	else
+		snd_soc_dapm_set_endpoint(codec, "Ext Spk", 0);
+
+	/* set up jack connection */
+	switch (spitz_jack_func) {
+	case SPITZ_HP:
+		/* enable and unmute hp jack, disable mic bias */
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 1);
+		set_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		set_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_MIC:
+		/* enable mic jack and bias, mute hp */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 1);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_LINE:
+		/* enable line jack, disable mic bias and mute hp */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 1);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_HEADSET:
+		/* enable and unmute headset jack enable mic bias, mute L hp */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 1);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 1);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		set_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	case SPITZ_HP_OFF:
+
+		/* jack removed, everything off */
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Headset Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Mic Jack", 0);
+		snd_soc_dapm_set_endpoint(codec, "Line Jack", 0);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_L);
+		reset_scoop_gpio(&spitzscoop_device.dev, SPITZ_SCP_MUTE_R);
+		break;
+	}
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int spitz_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	spitz_ext_control(codec);
+	return 0;
+}
+
+static int spitz_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int clk = 0;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 48000:
+	case 96000:
+		clk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+		clk = 11289600;
+		break;
+	}
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8750_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set the I2S system clock as input (unused) */
+	ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops spitz_ops = {
+	.startup = spitz_startup,
+	.hw_params = spitz_hw_params,
+};
+
+static int spitz_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = spitz_jack_func;
+	return 0;
+}
+
+static int spitz_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (spitz_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	spitz_jack_func = ucontrol->value.integer.value[0];
+	spitz_ext_control(codec);
+	return 1;
+}
+
+static int spitz_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = spitz_spk_func;
+	return 0;
+}
+
+static int spitz_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (spitz_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	spitz_spk_func = ucontrol->value.integer.value[0];
+	spitz_ext_control(codec);
+	return 1;
+}
+
+static int spitz_mic_bias(struct snd_soc_dapm_widget *w, int event)
+{
+	if (machine_is_borzoi() || machine_is_spitz()) {
+		if (SND_SOC_DAPM_EVENT_ON(event))
+			set_scoop_gpio(&spitzscoop2_device.dev,
+				SPITZ_SCP2_MIC_BIAS);
+		else
+			reset_scoop_gpio(&spitzscoop2_device.dev,
+				SPITZ_SCP2_MIC_BIAS);
+	}
+
+	if (machine_is_akita()) {
+		if (SND_SOC_DAPM_EVENT_ON(event))
+			akita_set_ioexp(&akitaioexp_device.dev,
+				AKITA_IOEXP_MIC_BIAS);
+		else
+			akita_reset_ioexp(&akitaioexp_device.dev,
+				AKITA_IOEXP_MIC_BIAS);
+	}
+	return 0;
+}
+
+/* spitz machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8750_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", spitz_mic_bias),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_LINE("Line Jack", NULL),
+
+	/* headset is a mic and mono headphone */
+	SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* Spitz machine audio_map */
+static const char *audio_map[][3] = {
+
+	/* headphone connected to LOUT1, ROUT1 */
+	{"Headphone Jack", NULL, "LOUT1"},
+	{"Headphone Jack", NULL, "ROUT1"},
+
+	/* headset connected to ROUT1 and LINPUT1 with bias (def below) */
+	{"Headset Jack", NULL, "ROUT1"},
+
+	/* ext speaker connected to LOUT2, ROUT2  */
+	{"Ext Spk", NULL , "ROUT2"},
+	{"Ext Spk", NULL , "LOUT2"},
+
+	/* mic is connected to input 1 - with bias */
+	{"LINPUT1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic Jack"},
+
+	/* line is connected to input 1 - no bias */
+	{"LINPUT1", NULL, "Line Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum spitz_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new wm8750_spitz_controls[] = {
+	SOC_ENUM_EXT("Jack Function", spitz_enum[0], spitz_get_jack,
+		spitz_set_jack),
+	SOC_ENUM_EXT("Speaker Function", spitz_enum[1], spitz_get_spk,
+		spitz_set_spk),
+};
+
+/*
+ * Logic for a wm8750 as connected on a Sharp SL-Cxx00 Device
+ */
+static int spitz_wm8750_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* NC codec pins */
+	snd_soc_dapm_set_endpoint(codec, "RINPUT1", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINPUT2", 0);
+	snd_soc_dapm_set_endpoint(codec, "RINPUT2", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINPUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "RINPUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "OUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "MONO", 0);
+
+	/* Add spitz specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8750_spitz_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8750_spitz_controls[i], codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add spitz specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8750_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8750_dapm_widgets[i]);
+	}
+
+	/* Set up spitz specific audio path audio_map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+/* spitz digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link spitz_dai = {
+	.name = "wm8750",
+	.stream_name = "WM8750",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8750_dai,
+	.init = spitz_wm8750_init,
+	.ops = &spitz_ops,
+};
+
+/* spitz audio machine driver */
+static struct snd_soc_machine snd_soc_machine_spitz = {
+	.name = "Spitz",
+	.dai_link = &spitz_dai,
+	.num_links = 1,
+};
+
+/* spitz audio private data */
+static struct wm8750_setup_data spitz_wm8750_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* spitz audio subsystem */
+static struct snd_soc_device spitz_snd_devdata = {
+	.machine = &snd_soc_machine_spitz,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8750,
+	.codec_data = &spitz_wm8750_setup,
+};
+
+static struct platform_device *spitz_snd_device;
+
+static int __init spitz_init(void)
+{
+	int ret;
+
+	if (!(machine_is_spitz() || machine_is_borzoi() || machine_is_akita()))
+		return -ENODEV;
+
+	spitz_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!spitz_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(spitz_snd_device, &spitz_snd_devdata);
+	spitz_snd_devdata.dev = &spitz_snd_device->dev;
+	ret = platform_device_add(spitz_snd_device);
+
+	if (ret)
+		platform_device_put(spitz_snd_device);
+
+	return ret;
+}
+
+static void __exit spitz_exit(void)
+{
+	platform_device_unregister(spitz_snd_device);
+}
+
+module_init(spitz_init);
+module_exit(spitz_exit);
+
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Spitz");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-pcm.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-pcm.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,372 @@
+/*
+ * linux/sound/arm/pxa2xx-pcm.c -- ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	(C) 2004 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/audio.h>
+
+#include "pxa2xx-pcm.h"
+
+static const struct snd_pcm_hardware pxa2xx_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+					SNDRV_PCM_FMTBIT_S24_LE |
+					SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192 - 32,
+	.periods_min		= 1,
+	.periods_max		= PAGE_SIZE/sizeof(pxa_dma_desc),
+	.buffer_bytes_max	= 128 * 1024,
+	.fifo_size		= 32,
+};
+
+struct pxa2xx_runtime_data {
+	int dma_ch;
+	struct pxa2xx_pcm_dma_params *params;
+	pxa_dma_desc *dma_desc_array;
+	dma_addr_t dma_desc_array_phys;
+};
+
+static void pxa2xx_pcm_dma_irq(int dma_ch, void *dev_id)
+{
+	struct snd_pcm_substream *substream = dev_id;
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+	int dcsr;
+
+	dcsr = DCSR(dma_ch);
+	DCSR(dma_ch) = dcsr & ~DCSR_STOPIRQEN;
+
+	if (dcsr & DCSR_ENDINTR) {
+		snd_pcm_period_elapsed(substream);
+	} else {
+		printk( KERN_ERR "%s: DMA error on channel %d (DCSR=%#x)\n",
+			prtd->params->name, dma_ch, dcsr );
+	}
+}
+
+static int pxa2xx_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct pxa2xx_pcm_dma_params *dma = rtd->dai->cpu_dai->dma_data;
+	size_t totsize = params_buffer_bytes(params);
+	size_t period = params_period_bytes(params);
+	pxa_dma_desc *dma_desc;
+	dma_addr_t dma_buff_phys, next_desc_phys;
+	int ret;
+
+	/* return if this is a bufferless transfer e.g.
+	 * codec <--> BT codec or GSM modem -- lg FIXME */
+	 if (!dma)
+	 	return 0;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = pxa_request_dma(prtd->params->name, DMA_PRIO_LOW,
+			      pxa2xx_pcm_dma_irq, substream);
+		if (ret < 0)
+			return ret;
+		prtd->dma_ch = ret;
+	} else if (prtd->params != dma) {
+		pxa_free_dma(prtd->dma_ch);
+		prtd->params = dma;
+		ret = pxa_request_dma(prtd->params->name, DMA_PRIO_LOW,
+			      pxa2xx_pcm_dma_irq, substream);
+		if (ret < 0)
+			return ret;
+		prtd->dma_ch = ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = totsize;
+
+	dma_desc = prtd->dma_desc_array;
+	next_desc_phys = prtd->dma_desc_array_phys;
+	dma_buff_phys = runtime->dma_addr;
+	do {
+		next_desc_phys += sizeof(pxa_dma_desc);
+		dma_desc->ddadr = next_desc_phys;
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dma_desc->dsadr = dma_buff_phys;
+			dma_desc->dtadr = prtd->params->dev_addr;
+		} else {
+			dma_desc->dsadr = prtd->params->dev_addr;
+			dma_desc->dtadr = dma_buff_phys;
+		}
+		if (period > totsize)
+			period = totsize;
+		dma_desc->dcmd = prtd->params->dcmd | period | DCMD_ENDIRQEN;
+		dma_desc++;
+		dma_buff_phys += period;
+	} while (totsize -= period);
+	dma_desc[-1].ddadr = prtd->dma_desc_array_phys;
+
+	return 0;
+}
+
+static int pxa2xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd && prtd->params)
+		*prtd->params->drcmr = 0;
+
+	if (prtd->dma_ch) {
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		pxa_free_dma(prtd->dma_ch);
+		prtd->dma_ch = 0;
+	}
+
+	return 0;
+}
+
+static int pxa2xx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+
+	DCSR(prtd->dma_ch) &= ~DCSR_RUN;
+	DCSR(prtd->dma_ch) = 0;
+	DCMD(prtd->dma_ch) = 0;
+	*prtd->params->drcmr = prtd->dma_ch | DRCMR_MAPVLD;
+
+	return 0;
+}
+
+static int pxa2xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct pxa2xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		DDADR(prtd->dma_ch) = prtd->dma_desc_array_phys;
+		DCSR(prtd->dma_ch) = DCSR_RUN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		DCSR(prtd->dma_ch) &= ~DCSR_RUN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		DCSR(prtd->dma_ch) |= DCSR_RUN;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		DDADR(prtd->dma_ch) = prtd->dma_desc_array_phys;
+		DCSR(prtd->dma_ch) |= DCSR_RUN;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t
+pxa2xx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd = runtime->private_data;
+
+	dma_addr_t ptr = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+			 DSADR(prtd->dma_ch) : DTADR(prtd->dma_ch);
+	snd_pcm_uframes_t x = bytes_to_frames(runtime, ptr - runtime->dma_addr);
+
+	if (x == runtime->buffer_size)
+		x = 0;
+	return x;
+}
+
+static int pxa2xx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &pxa2xx_pcm_hardware);
+
+	/*
+	 * For mysterious reasons (and despite what the manual says)
+	 * playback samples are lost if the DMA count is not a multiple
+	 * of the DMA burst size.  Let's add a rule to enforce that.
+	 */
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+		SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);
+	if (ret)
+		goto out;
+
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+		SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);
+	if (ret)
+		goto out;
+
+	ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(struct pxa2xx_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	prtd->dma_desc_array =
+		dma_alloc_writecombine(substream->pcm->card->dev, PAGE_SIZE,
+				       &prtd->dma_desc_array_phys, GFP_KERNEL);
+	if (!prtd->dma_desc_array) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	runtime->private_data = prtd;
+	return 0;
+
+ err1:
+	kfree(prtd);
+ out:
+	return ret;
+}
+
+static int pxa2xx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pxa2xx_runtime_data *prtd = runtime->private_data;
+
+	dma_free_writecombine(substream->pcm->card->dev, PAGE_SIZE,
+			      prtd->dma_desc_array, prtd->dma_desc_array_phys);
+	kfree(prtd);
+	return 0;
+}
+
+static int pxa2xx_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops pxa2xx_pcm_ops = {
+	.open		= pxa2xx_pcm_open,
+	.close		= pxa2xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= pxa2xx_pcm_hw_params,
+	.hw_free	= pxa2xx_pcm_hw_free,
+	.prepare	= pxa2xx_pcm_prepare,
+	.trigger	= pxa2xx_pcm_trigger,
+	.pointer	= pxa2xx_pcm_pointer,
+	.mmap		= pxa2xx_pcm_mmap,
+};
+
+static int pxa2xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = pxa2xx_pcm_hardware.buffer_bytes_max;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void pxa2xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 pxa2xx_pcm_dmamask = DMA_32BIT_MASK;
+
+int pxa2xx_pcm_new(struct snd_card *card, struct snd_soc_codec_dai *dai,
+	struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &pxa2xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_32BIT_MASK;
+
+	if (dai->playback.channels_min) {
+		ret = pxa2xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = pxa2xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+struct snd_soc_platform pxa2xx_soc_platform = {
+	.name		= "pxa2xx-audio",
+	.pcm_ops 	= &pxa2xx_pcm_ops,
+	.pcm_new	= pxa2xx_pcm_new,
+	.pcm_free	= pxa2xx_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(pxa2xx_soc_platform);
+
+MODULE_AUTHOR("Nicolas Pitre");
+MODULE_DESCRIPTION("Intel PXA2xx PCM DMA module");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-pcm.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-pcm.h	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ * linux/sound/arm/pxa2xx-pcm.h -- ALSA PCM interface for the Intel PXA2xx chip
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Nov 30, 2004
+ * Copyright:	MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PXA2XX_PCM_H
+#define _PXA2XX_PCM_H
+
+struct pxa2xx_pcm_dma_params {
+	char *name;			/* stream identifier */
+	u32 dcmd;			/* DMA descriptor dcmd field */
+	volatile u32 *drcmr;		/* the DMA request channel to use */
+	u32 dev_addr;			/* device physical address for DMA */
+};
+
+struct pxa2xx_gpio {
+	u32 sys;
+	u32	rx;
+	u32 tx;
+	u32 clk;
+	u32 frm;
+};
+
+/* platform data */
+extern struct snd_soc_platform pxa2xx_soc_platform;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/pxa/tosa.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/tosa.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,289 @@
+/*
+ * tosa.c  --  SoC audio for Tosa
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ * GPIO's
+ *  1 - Jack Insertion
+ *  5 - Hookswitch (headset answer/hang up switch)
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/tmio.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/audio.h>
+#include <asm/arch/tosa.h>
+
+#include "../codecs/wm9712.h"
+#include "pxa2xx-pcm.h"
+#include "pxa2xx-ac97.h"
+
+static struct snd_soc_machine tosa;
+
+#define TOSA_HP        0
+#define TOSA_MIC_INT   1
+#define TOSA_HEADSET   2
+#define TOSA_HP_OFF    3
+#define TOSA_SPK_ON    0
+#define TOSA_SPK_OFF   1
+
+static int tosa_jack_func;
+static int tosa_spk_func;
+
+static void tosa_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0, mic_int = 0, hp = 0, hs = 0;
+
+	/* set up jack connection */
+	switch (tosa_jack_func) {
+	case TOSA_HP:
+		hp = 1;
+		break;
+	case TOSA_MIC_INT:
+		mic_int = 1;
+		break;
+	case TOSA_HEADSET:
+		hs = 1;
+		break;
+	}
+
+	if (tosa_spk_func == TOSA_SPK_ON)
+		spk = 1;
+
+	snd_soc_dapm_set_endpoint(codec, "Speaker", spk);
+	snd_soc_dapm_set_endpoint(codec, "Mic (Internal)", mic_int);
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", hp);
+	snd_soc_dapm_set_endpoint(codec, "Headset Jack", hs);
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int tosa_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	tosa_ext_control(codec);
+	return 0;
+}
+
+static struct snd_soc_ops tosa_ops = {
+	.startup = tosa_startup,
+};
+
+static int tosa_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tosa_jack_func;
+	return 0;
+}
+
+static int tosa_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (tosa_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tosa_jack_func = ucontrol->value.integer.value[0];
+	tosa_ext_control(codec);
+	return 1;
+}
+
+static int tosa_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = tosa_spk_func;
+	return 0;
+}
+
+static int tosa_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (tosa_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	tosa_spk_func = ucontrol->value.integer.value[0];
+	tosa_ext_control(codec);
+	return 1;
+}
+
+/* tosa dapm event handlers */
+static int tosa_hp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_tc6393_gpio(&tc6393_device.dev,TOSA_TC6393_L_MUTE);
+	else
+		reset_tc6393_gpio(&tc6393_device.dev,TOSA_TC6393_L_MUTE);
+	return 0;
+}
+
+/* tosa machine dapm widgets */
+static const struct snd_soc_dapm_widget tosa_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", tosa_hp_event),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+SND_SOC_DAPM_MIC("Mic (Internal)", NULL),
+SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+/* tosa audio map */
+static const char *audio_map[][3] = {
+
+	/* headphone connected to HPOUTL, HPOUTR */
+	{"Headphone Jack", NULL, "HPOUTL"},
+	{"Headphone Jack", NULL, "HPOUTR"},
+
+	/* ext speaker connected to LOUT2, ROUT2 */
+	{"Speaker", NULL, "LOUT2"},
+	{"Speaker", NULL, "ROUT2"},
+
+	/* internal mic is connected to mic1, mic2 differential - with bias */
+	{"MIC1", NULL, "Mic Bias"},
+	{"MIC2", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic (Internal)"},
+
+	/* headset is connected to HPOUTR, and LINEINR with bias */
+	{"Headset Jack", NULL, "HPOUTR"},
+	{"LINEINR", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Headset Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum tosa_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new tosa_controls[] = {
+	SOC_ENUM_EXT("Jack Function", tosa_enum[0], tosa_get_jack,
+		tosa_set_jack),
+	SOC_ENUM_EXT("Speaker Function", tosa_enum[1], tosa_get_spk,
+		tosa_set_spk),
+};
+
+static int tosa_ac97_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	snd_soc_dapm_set_endpoint(codec, "OUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "MONOOUT", 0);
+
+	/* add tosa specific controls */
+	for (i = 0; i < ARRAY_SIZE(tosa_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&tosa_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* add tosa specific widgets */
+	for (i = 0; i < ARRAY_SIZE(tosa_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &tosa_dapm_widgets[i]);
+	}
+
+	/* set up tosa specific audio path audio_map */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static struct snd_soc_dai_link tosa_dai[] = {
+{
+	.name = "AC97",
+	.stream_name = "AC97 HiFi",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_HIFI],
+	.codec_dai = &wm9712_dai[WM9712_DAI_AC97_HIFI],
+	.init = tosa_ac97_init,
+	.ops = &tosa_ops,
+},
+{
+	.name = "AC97 Aux",
+	.stream_name = "AC97 Aux",
+	.cpu_dai = &pxa_ac97_dai[PXA2XX_DAI_AC97_AUX],
+	.codec_dai = &wm9712_dai[WM9712_DAI_AC97_AUX],
+	.ops = &tosa_ops,
+},
+};
+
+static struct snd_soc_machine tosa = {
+	.name = "Tosa",
+	.dai_link = tosa_dai,
+	.num_links = ARRAY_SIZE(tosa_dai),
+};
+
+static struct snd_soc_device tosa_snd_devdata = {
+	.machine = &tosa,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm9712,
+};
+
+static struct platform_device *tosa_snd_device;
+
+static int __init tosa_init(void)
+{
+	int ret;
+
+	if (!machine_is_tosa())
+		return -ENODEV;
+
+	tosa_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!tosa_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(tosa_snd_device, &tosa_snd_devdata);
+	tosa_snd_devdata.dev = &tosa_snd_device->dev;
+	ret = platform_device_add(tosa_snd_device);
+
+	if (ret)
+		platform_device_put(tosa_snd_device);
+
+	return ret;
+}
+
+static void __exit tosa_exit(void)
+{
+	platform_device_unregister(tosa_snd_device);
+}
+
+module_init(tosa_init);
+module_exit(tosa_exit);
+
+/* Module information */
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Tosa");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/soc/pxa/Kconfig.orig	2007-06-05 17:30:02.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/Kconfig	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,59 @@
+menu "SoC Audio for the Intel PXA2xx"
+
+config SND_PXA2XX_SOC
+	tristate "SoC Audio for the Intel PXA2xx chip"
+	depends on ARCH_PXA && SND_SOC
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the PXA2xx AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_PXA2XX_AC97
+	tristate
+	select SND_AC97_CODEC
+
+config SND_PXA2XX_SOC_AC97
+	tristate
+	select AC97_BUS
+	select SND_SOC_AC97_BUS
+
+config SND_PXA2XX_SOC_I2S
+	tristate
+
+config SND_PXA2XX_SOC_CORGI
+	tristate "SoC Audio support for Sharp Zaurus SL-C7x0"
+	depends on SND_PXA2XX_SOC && PXA_SHARP_C7xx
+	select SND_PXA2XX_SOC_I2S
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-C7x0 models (Corgi, Shepherd, Husky).
+
+config SND_PXA2XX_SOC_SPITZ
+	tristate "SoC Audio support for Sharp Zaurus SL-Cxx00"
+	depends on SND_PXA2XX_SOC && PXA_SHARP_Cxx00
+	select SND_PXA2XX_SOC_I2S
+	select SND_SOC_WM8750
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-Cxx00 models (Spitz, Borzoi and Akita).
+
+config SND_PXA2XX_SOC_POODLE
+	tristate "SoC Audio support for Poodle"
+	depends on SND_PXA2XX_SOC && MACH_POODLE
+	select SND_PXA2XX_SOC_I2S
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-5600 model (Poodle).
+
+config SND_PXA2XX_SOC_TOSA
+	tristate "SoC AC97 Audio support for Tosa"
+	depends on SND_PXA2XX_SOC && MACH_TOSA
+	select SND_PXA2XX_SOC_AC97
+	select SND_SOC_WM9712
+	help
+	  Say Y if you want to add support for SoC audio on Sharp
+	  Zaurus SL-C6000x models (Tosa).
+
+endmenu
--- linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-i2s.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/pxa2xx-i2s.h	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,20 @@
+/*
+ * linux/sound/arm/pxa2xx-i2s.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PXA2XX_I2S_H
+#define _PXA2XX_I2S_H
+
+/* pxa2xx DAI ID's */
+#define PXA2XX_DAI_I2S			0
+
+/* I2S clock */
+#define PXA2XX_I2S_SYSCLK		0
+
+extern struct snd_soc_cpu_dai pxa_i2s_dai;
+
+#endif
--- linux-2.6.18.noarch/sound/soc/pxa/corgi.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/soc/pxa/corgi.c	2007-06-05 19:53:48.000000000 -0400
@@ -0,0 +1,383 @@
+/*
+ * corgi.c  --  SoC audio for Corgi
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Authors: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *          Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    30th Nov 2005   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/corgi.h>
+#include <asm/arch/audio.h>
+
+#include "../codecs/wm8731.h"
+#include "pxa2xx-pcm.h"
+#include "pxa2xx-i2s.h"
+
+#define CORGI_HP        0
+#define CORGI_MIC       1
+#define CORGI_LINE      2
+#define CORGI_HEADSET   3
+#define CORGI_HP_OFF    4
+#define CORGI_SPK_ON    0
+#define CORGI_SPK_OFF   1
+
+ /* audio clock in Hz - rounded from 12.235MHz */
+#define CORGI_AUDIO_CLOCK 12288000
+
+static int corgi_jack_func;
+static int corgi_spk_func;
+
+static void corgi_ext_control(struct snd_soc_codec *codec)
+{
+	int spk = 0, mic = 0, line = 0, hp = 0, hs = 0;
+
+	/* set up jack connection */
+	switch (corgi_jack_func) {
+	case CORGI_HP:
+		hp = 1;
+		/* set = unmute headphone */
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case CORGI_MIC:
+		mic = 1;
+		/* reset = mute headphone */
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case CORGI_LINE:
+		line = 1;
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	case CORGI_HEADSET:
+		hs = 1;
+		mic = 1;
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+		break;
+	}
+
+	if (corgi_spk_func == CORGI_SPK_ON)
+		spk = 1;
+
+	/* set the enpoints to their new connetion states */
+	snd_soc_dapm_set_endpoint(codec, "Ext Spk", spk);
+	snd_soc_dapm_set_endpoint(codec, "Mic Jack", mic);
+	snd_soc_dapm_set_endpoint(codec, "Line Jack", line);
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", hp);
+	snd_soc_dapm_set_endpoint(codec, "Headset Jack", hs);
+
+	/* signal a DAPM event */
+	snd_soc_dapm_sync_endpoints(codec);
+}
+
+static int corgi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* check the jack status at stream startup */
+	corgi_ext_control(codec);
+	return 0;
+}
+
+/* we need to unmute the HP at shutdown as the mute burns power on corgi */
+static int corgi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	/* set = unmute headphone */
+	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_L);
+	set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MUTE_R);
+	return 0;
+}
+
+static int corgi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int clk = 0;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 48000:
+	case 96000:
+		clk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+		clk = 11289600;
+		break;
+	}
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8731_SYSCLK, clk,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set the I2S system clock as input (unused) */
+	ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, PXA2XX_I2S_SYSCLK, 0,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops corgi_ops = {
+	.startup = corgi_startup,
+	.hw_params = corgi_hw_params,
+	.shutdown = corgi_shutdown,
+};
+
+static int corgi_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = corgi_jack_func;
+	return 0;
+}
+
+static int corgi_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (corgi_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	corgi_jack_func = ucontrol->value.integer.value[0];
+	corgi_ext_control(codec);
+	return 1;
+}
+
+static int corgi_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = corgi_spk_func;
+	return 0;
+}
+
+static int corgi_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (corgi_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	corgi_spk_func = ucontrol->value.integer.value[0];
+	corgi_ext_control(codec);
+	return 1;
+}
+
+static int corgi_amp_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_APM_ON);
+
+	return 0;
+}
+
+static int corgi_mic_event(struct snd_soc_dapm_widget *w, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		set_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+	else
+		reset_scoop_gpio(&corgiscoop_device.dev, CORGI_SCP_MIC_BIAS);
+
+	return 0;
+}
+
+/* corgi machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_MIC("Mic Jack", corgi_mic_event),
+SND_SOC_DAPM_SPK("Ext Spk", corgi_amp_event),
+SND_SOC_DAPM_LINE("Line Jack", NULL),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* Corgi machine audio map (connections to the codec pins) */
+static const char *audio_map[][3] = {
+
+	/* headset Jack  - in = micin, out = LHPOUT*/
+	{"Headset Jack", NULL, "LHPOUT"},
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	/* speaker connected to LOUT, ROUT */
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	/* mic is connected to MICIN (via right channel of headphone jack) */
+	{"MICIN", NULL, "Mic Jack"},
+
+	/* Same as the above but no mic bias for line signals */
+	{"MICIN", NULL, "Line Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum corgi_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new wm8731_corgi_controls[] = {
+	SOC_ENUM_EXT("Jack Function", corgi_enum[0], corgi_get_jack,
+		corgi_set_jack),
+	SOC_ENUM_EXT("Speaker Function", corgi_enum[1], corgi_get_spk,
+		corgi_set_spk),
+};
+
+/*
+ * Logic for a wm8731 as connected on a Sharp SL-C7x0 Device
+ */
+static int corgi_wm8731_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	snd_soc_dapm_set_endpoint(codec, "LLINEIN", 0);
+	snd_soc_dapm_set_endpoint(codec, "RLINEIN", 0);
+
+	/* Add corgi specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8731_corgi_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8731_corgi_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* Add corgi specific widgets */
+	for(i = 0; i < ARRAY_SIZE(wm8731_dapm_widgets); i++) {
+		snd_soc_dapm_new_control(codec, &wm8731_dapm_widgets[i]);
+	}
+
+	/* Set up corgi specific audio path audio_map */
+	for(i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+/* corgi digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link corgi_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731",
+	.cpu_dai = &pxa_i2s_dai,
+	.codec_dai = &wm8731_dai,
+	.init = corgi_wm8731_init,
+	.ops = &corgi_ops,
+};
+
+/* corgi audio machine driver */
+static struct snd_soc_machine snd_soc_machine_corgi = {
+	.name = "Corgi",
+	.dai_link = &corgi_dai,
+	.num_links = 1,
+};
+
+/* corgi audio private data */
+static struct wm8731_setup_data corgi_wm8731_setup = {
+	.i2c_address = 0x1b,
+};
+
+/* corgi audio subsystem */
+static struct snd_soc_device corgi_snd_devdata = {
+	.machine = &snd_soc_machine_corgi,
+	.platform = &pxa2xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8731,
+	.codec_data = &corgi_wm8731_setup,
+};
+
+static struct platform_device *corgi_snd_device;
+
+static int __init corgi_init(void)
+{
+	int ret;
+
+	if (!(machine_is_corgi() || machine_is_shepherd() || machine_is_husky()))
+		return -ENODEV;
+
+	corgi_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!corgi_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(corgi_snd_device, &corgi_snd_devdata);
+	corgi_snd_devdata.dev = &corgi_snd_device->dev;
+	ret = platform_device_add(corgi_snd_device);
+
+	if (ret)
+		platform_device_put(corgi_snd_device);
+
+	return ret;
+}
+
+static void __exit corgi_exit(void)
+{
+	platform_device_unregister(corgi_snd_device);
+}
+
+module_init(corgi_init);
+module_exit(corgi_exit);
+
+/* Module information */
+MODULE_AUTHOR("Richard Purdie");
+MODULE_DESCRIPTION("ALSA SoC Corgi");
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/mips/au1x00.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/mips/au1x00.c	2007-06-05 17:44:03.000000000 -0400
@@ -220,7 +220,7 @@
 }
 
 static irqreturn_t
-au1000_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+au1000_dma_interrupt(int irq, void *dev_id)
 {
 	struct audio_stream *stream = (struct audio_stream *) dev_id;
 	struct snd_pcm_substream *substream = stream->substream;
@@ -258,7 +258,7 @@
 
 static unsigned int rates[] = {8000, 11025, 16000, 22050};
 static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
-	.count	=  sizeof(rates) / sizeof(rates[0]),
+	.count	= ARRAY_SIZE(rates),
 	.list	= rates,
 	.mask	= 0,
 };
--- linux-2.6.18.noarch/sound/parisc/harmony.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/parisc/harmony.c	2007-06-05 17:44:46.000000000 -0400
@@ -193,7 +193,7 @@
 }
 
 static irqreturn_t
-snd_harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
+snd_harmony_interrupt(int irq, void *dev)
 {
 	u32 dstatus;
 	struct snd_harmony *h = dev;
@@ -854,7 +854,7 @@
 		       HARMONY_GAIN_HE_SHIFT, 1, 0),
 };
 
-static void __init 
+static void __devinit
 snd_harmony_mixer_reset(struct snd_harmony *h)
 {
 	harmony_mute(h);
@@ -863,7 +863,7 @@
 	harmony_unmute(h);
 }
 
-static int __init 
+static int __devinit
 snd_harmony_mixer_init(struct snd_harmony *h)
 {
 	struct snd_card *card = h->card;
@@ -1020,7 +1020,7 @@
 	.name = "harmony",
 	.id_table = snd_harmony_devtable,
 	.probe = snd_harmony_probe,
-	.remove = __devexit_p(snd_harmony_remove),
+	.remove = snd_harmony_remove,
 };
 
 static int __init 
--- linux-2.6.18.noarch/sound/Kconfig.orig	2007-06-05 16:07:46.000000000 -0400
+++ linux-2.6.18.noarch/sound/Kconfig	2007-06-05 20:32:30.000000000 -0400
@@ -76,6 +76,8 @@
 
 source "sound/parisc/Kconfig"
 
+source "sound/soc/Kconfig"
+
 endmenu
 
 menu "Open Sound System"
@@ -93,4 +95,12 @@
 
 endif
 
+config AC97_BUS
+	tristate
+	help
+	  This is used to avoid config and link hard dependencies between the
+	  sound subsystem and other function drivers completely unrelated to
+	  sound although they're sharing the AC97 bus. Concerned drivers
+	  should "select" this.
+
 endmenu
--- linux-2.6.18.noarch/sound/isa/opti9xx/opti92x-ad1848.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/opti9xx/opti92x-ad1848.c	2007-06-05 17:43:31.000000000 -0400
@@ -1090,7 +1090,7 @@
 	spin_unlock_irqrestore(&chip->lock, flags);
 }
 
-static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 {
 	struct snd_opti93x *codec = dev_id;
 	unsigned char status;
@@ -1683,6 +1683,8 @@
 	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
 	int err;
 
+	if (!cfg)
+		return -ENOMEM;
 	chip->dev = pnp_request_card_device(card, pid->devs[0].id, NULL);
 	if (chip->dev == NULL) {
 		kfree(cfg);
--- linux-2.6.18.noarch/sound/isa/cs423x/cs4231_lib.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/cs423x/cs4231_lib.c	2007-06-05 17:43:07.000000000 -0400
@@ -920,7 +920,7 @@
 		chip->capture_substream->runtime->overrange++;
 }
 
-irqreturn_t snd_cs4231_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t snd_cs4231_interrupt(int irq, void *dev_id)
 {
 	struct snd_cs4231 *chip = dev_id;
 	unsigned char status;
--- linux-2.6.18.noarch/sound/isa/opl3sa2.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/opl3sa2.c	2007-06-05 17:42:43.000000000 -0400
@@ -33,6 +33,7 @@
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
 #include <sound/initval.h>
+#include <sound/tlv.h>
 
 #include <asm/io.h>
 
@@ -293,7 +294,7 @@
 	return 0;
 }
 
-static irqreturn_t snd_opl3sa2_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_opl3sa2_interrupt(int irq, void *dev_id)
 {
 	unsigned short status;
 	struct snd_opl3sa2 *chip = dev_id;
@@ -311,12 +312,12 @@
 
 	if ((status & 0x10) && chip->rmidi != NULL) {
 		handled = 1;
-		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
 	}
 
 	if (status & 0x07) {	/* TI,CI,PI */
 		handled = 1;
-		snd_cs4231_interrupt(irq, chip->cs4231, regs);
+		snd_cs4231_interrupt(irq, chip->cs4231);
 	}
 
 	if (status & 0x40) { /* hardware volume change */
@@ -337,6 +338,14 @@
   .info = snd_opl3sa2_info_single, \
   .get = snd_opl3sa2_get_single, .put = snd_opl3sa2_put_single, \
   .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
+#define OPL3SA2_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .index = xindex, \
+  .info = snd_opl3sa2_info_single, \
+  .get = snd_opl3sa2_get_single, .put = snd_opl3sa2_put_single, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \
+  .tlv = { .p = (xtlv) } }
 
 static int snd_opl3sa2_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -395,6 +404,14 @@
   .info = snd_opl3sa2_info_double, \
   .get = snd_opl3sa2_get_double, .put = snd_opl3sa2_put_double, \
   .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
+#define OPL3SA2_DOUBLE_TLV(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .index = xindex, \
+  .info = snd_opl3sa2_info_double, \
+  .get = snd_opl3sa2_get_double, .put = snd_opl3sa2_put_double, \
+  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22), \
+  .tlv = { .p = (xtlv) } }
 
 static int snd_opl3sa2_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -469,11 +486,16 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_master, -3000, 200, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);
+
 static struct snd_kcontrol_new snd_opl3sa2_controls[] = {
 OPL3SA2_DOUBLE("Master Playback Switch", 0, 0x07, 0x08, 7, 7, 1, 1),
-OPL3SA2_DOUBLE("Master Playback Volume", 0, 0x07, 0x08, 0, 0, 15, 1),
+OPL3SA2_DOUBLE_TLV("Master Playback Volume", 0, 0x07, 0x08, 0, 0, 15, 1,
+		   db_scale_master),
 OPL3SA2_SINGLE("Mic Playback Switch", 0, 0x09, 7, 1, 1),
-OPL3SA2_SINGLE("Mic Playback Volume", 0, 0x09, 0, 31, 1)
+OPL3SA2_SINGLE_TLV("Mic Playback Volume", 0, 0x09, 0, 31, 1,
+		   db_scale_5bit_12db_max),
 };
 
 static struct snd_kcontrol_new snd_opl3sa2_tone_controls[] = {
--- linux-2.6.18.noarch/sound/isa/sgalaxy.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/sgalaxy.c	2007-06-05 17:42:43.000000000 -0400
@@ -109,7 +109,7 @@
 	return 0;
 }
 
-static irqreturn_t snd_sgalaxy_dummy_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_sgalaxy_dummy_interrupt(int irq, void *dev_id)
 {
 	return IRQ_NONE;
 }
--- linux-2.6.18.noarch/sound/isa/gus/gusmax.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/gusmax.c	2007-06-05 17:43:23.000000000 -0400
@@ -105,9 +105,9 @@
 	return 0;
 }
 
-static irqreturn_t snd_gusmax_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_gusmax_interrupt(int irq, void *dev_id)
 {
-	struct snd_gusmax *maxcard = (struct snd_gusmax *) dev_id;
+	struct snd_gusmax *maxcard = dev_id;
 	int loop, max = 5;
 	int handled = 0;
 
@@ -115,19 +115,20 @@
 		loop = 0;
 		if (inb(maxcard->gus_status_reg)) {
 			handled = 1;
-			snd_gus_interrupt(irq, maxcard->gus, regs);
+			snd_gus_interrupt(irq, maxcard->gus);
 			loop++;
 		}
 		if (inb(maxcard->pcm_status_reg) & 0x01) { /* IRQ bit is set? */
 			handled = 1;
-			snd_cs4231_interrupt(irq, maxcard->cs4231, regs);
+			snd_cs4231_interrupt(irq, maxcard->cs4231);
 			loop++;
 		}
 	} while (loop && --max > 0);
 	return IRQ_RETVAL(handled);
 }
 
-static void __devinit snd_gusmax_init(int dev, struct snd_card *card, struct snd_gus_card * gus)
+static void __devinit snd_gusmax_init(int dev, struct snd_card *card,
+				      struct snd_gus_card * gus)
 {
 	gus->equal_irq = 1;
 	gus->codec_flag = 1;
--- linux-2.6.18.noarch/sound/isa/gus/gusclassic.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/gusclassic.c	2007-06-05 17:43:23.000000000 -0400
@@ -76,7 +76,7 @@
 
 #define PFX	"gusclassic: "
 
-static int __init snd_gusclassic_detect(struct snd_gus_card * gus)
+static int __devinit snd_gusclassic_detect(struct snd_gus_card * gus)
 {
 	unsigned char d;
 
@@ -95,7 +95,7 @@
 	return 0;
 }
 
-static void __init snd_gusclassic_init(int dev, struct snd_gus_card * gus)
+static void __devinit snd_gusclassic_init(int dev, struct snd_gus_card * gus)
 {
 	gus->equal_irq = 0;
 	gus->codec_flag = 0;
--- linux-2.6.18.noarch/sound/isa/gus/gus_mem_proc.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/gus_mem_proc.c	2007-06-05 17:43:23.000000000 -0400
@@ -61,13 +61,13 @@
 	struct gus_proc_private *priv = entry->private_data;
 
 	switch (orig) {
-	case 0:	/* SEEK_SET */
+	case SEEK_SET:
 		file->f_pos = offset;
 		break;
-	case 1:	/* SEEK_CUR */
+	case SEEK_CUR:
 		file->f_pos += offset;
 		break;
-	case 2: /* SEEK_END, offset is negative */
+	case SEEK_END: /* offset is negative */
 		file->f_pos = priv->size + offset;
 		break;
 	default:
--- linux-2.6.18.noarch/sound/isa/gus/gus_irq.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/gus_irq.c	2007-06-05 17:43:23.000000000 -0400
@@ -30,7 +30,7 @@
 #define STAT_ADD(x)	while (0) { ; }
 #endif
 
-irqreturn_t snd_gus_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t snd_gus_interrupt(int irq, void *dev_id)
 {
 	struct snd_gus_card * gus = dev_id;
 	unsigned char status;
--- linux-2.6.18.noarch/sound/isa/gus/interwave.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/interwave.c	2007-06-05 17:43:23.000000000 -0400
@@ -299,9 +299,9 @@
 	return -ENODEV;
 }
 
-static irqreturn_t snd_interwave_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_interwave_interrupt(int irq, void *dev_id)
 {
-	struct snd_interwave *iwcard = (struct snd_interwave *) dev_id;
+	struct snd_interwave *iwcard = dev_id;
 	int loop, max = 5;
 	int handled = 0;
 
@@ -309,12 +309,12 @@
 		loop = 0;
 		if (inb(iwcard->gus_status_reg)) {
 			handled = 1;
-			snd_gus_interrupt(irq, iwcard->gus, regs);
+			snd_gus_interrupt(irq, iwcard->gus);
 			loop++;
 		}
 		if (inb(iwcard->pcm_status_reg) & 0x01) {	/* IRQ bit is set? */
 			handled = 1;
-			snd_cs4231_interrupt(irq, iwcard->cs4231, regs);
+			snd_cs4231_interrupt(irq, iwcard->cs4231);
 			loop++;
 		}
 	} while (loop && --max > 0);
@@ -564,6 +564,8 @@
 	struct pnp_resource_table * cfg = kmalloc(sizeof(struct pnp_resource_table), GFP_KERNEL);
 	int err;
 
+	if (!cfg)
+		return -ENOMEM;
 	iwcard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
 	if (iwcard->dev == NULL) {
 		kfree(cfg);
--- linux-2.6.18.noarch/sound/isa/gus/gus_mem.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/gus_mem.c	2007-06-05 17:43:23.000000000 -0400
@@ -143,9 +143,8 @@
 	struct snd_gf1_mem_block *pblock;
 	unsigned int ptr1, ptr2;
 
-	align--;
-	if (w_16 && align < 1)
-		align = 1;
+	if (w_16 && align < 2)
+		align = 2;
 	block->flags = w_16 ? SNDRV_GF1_MEM_BLOCK_16BIT : 0;
 	block->owner = SNDRV_GF1_MEM_OWNER_DRIVER;
 	block->share = 0;
@@ -165,7 +164,7 @@
 			if (pblock->next->ptr < boundary)
 				ptr2 = pblock->next->ptr;
 		}
-		ptr1 = (pblock->ptr + pblock->size + align) & ~align;
+		ptr1 = ALIGN(pblock->ptr + pblock->size, align);
 		if (ptr1 >= ptr2)
 			continue;
 		size1 = ptr2 - ptr1;
--- linux-2.6.18.noarch/sound/isa/gus/gus_main.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/gus/gus_main.c	2007-06-05 17:43:23.000000000 -0400
@@ -294,10 +294,10 @@
 		gus->mix_cntrl_reg |= 4;	/* enable MIC */
 	}
 	dma1 = gus->gf1.dma1;
-	dma1 = dma1 < 0 ? -dma1 : dma1;
+	dma1 = abs(dma1);
 	dma1 = dmas[dma1 & 7];
 	dma2 = gus->gf1.dma2;
-	dma2 = dma2 < 0 ? -dma2 : dma2;
+	dma2 = abs(dma2);
 	dma2 = dmas[dma2 & 7];
 	dma1 |= gus->equal_dma ? 0x40 : (dma2 << 3);
 
@@ -306,7 +306,7 @@
 		return -EINVAL;
 	}
 	irq = gus->gf1.irq;
-	irq = irq < 0 ? -irq : irq;
+	irq = abs(irq);
 	irq = irqs[irq & 0x0f];
 	if (irq == 0) {
 		snd_printk(KERN_ERR "Error! IRQ isn't defined.\n");
--- linux-2.6.18.noarch/sound/isa/dt019x.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/dt019x.c	2007-06-05 17:42:42.000000000 -0400
@@ -23,7 +23,6 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/pnp.h>
 #include <linux/moduleparam.h>
--- linux-2.6.18.noarch/sound/isa/cmi8330.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/cmi8330.c	2007-06-05 17:42:42.000000000 -0400
@@ -289,6 +289,8 @@
 	struct pnp_resource_table * cfg = kmalloc(sizeof(struct pnp_resource_table), GFP_KERNEL);
 	int err;
 
+	if (!cfg)
+		return -ENOMEM;
 	acard->cap = pnp_request_card_device(card, id->devs[0].id, NULL);
 	if (acard->cap == NULL) {
 		kfree(cfg);
--- linux-2.6.18.noarch/sound/isa/ad1848/ad1848.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/ad1848/ad1848.c	2007-06-05 17:42:59.000000000 -0400
@@ -65,7 +65,7 @@
 static struct platform_device *devices[SNDRV_CARDS];
 
 
-static int __init snd_ad1848_probe(struct platform_device *pdev)
+static int __devinit snd_ad1848_probe(struct platform_device *pdev)
 {
 	int dev = pdev->id;
 	struct snd_card *card;
--- linux-2.6.18.noarch/sound/isa/ad1848/ad1848_lib.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/ad1848/ad1848_lib.c	2007-06-05 17:42:59.000000000 -0400
@@ -29,6 +29,7 @@
 #include <sound/core.h>
 #include <sound/ad1848.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm_params.h>
 
 #include <asm/io.h>
@@ -118,6 +119,8 @@
 #endif
 }
 
+EXPORT_SYMBOL(snd_ad1848_out);
+
 static void snd_ad1848_dout(struct snd_ad1848 *chip,
 			    unsigned char reg, unsigned char value)
 {
@@ -580,7 +583,7 @@
 	return 0;
 }
 
-static irqreturn_t snd_ad1848_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_ad1848_interrupt(int irq, void *dev_id)
 {
 	struct snd_ad1848 *chip = dev_id;
 
@@ -941,6 +944,8 @@
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_ad1848_create);
+
 static struct snd_pcm_ops snd_ad1848_playback_ops = {
 	.open =		snd_ad1848_playback_open,
 	.close =	snd_ad1848_playback_close,
@@ -988,12 +993,16 @@
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_ad1848_pcm);
+
 const struct snd_pcm_ops *snd_ad1848_get_pcm_ops(int direction)
 {
 	return direction == SNDRV_PCM_STREAM_PLAYBACK ?
 		&snd_ad1848_playback_ops : &snd_ad1848_capture_ops;
 }
 
+EXPORT_SYMBOL(snd_ad1848_get_pcm_ops);
+
 /*
  *  MIXER part
  */
@@ -1171,7 +1180,8 @@
 
 /*
  */
-int snd_ad1848_add_ctl(struct snd_ad1848 *chip, const char *name, int index, int type, unsigned long value)
+int snd_ad1848_add_ctl_elem(struct snd_ad1848 *chip,
+			    const struct ad1848_mix_elem *c)
 {
 	static struct snd_kcontrol_new newctls[] = {
 		[AD1848_MIX_SINGLE] = {
@@ -1196,32 +1206,46 @@
 	struct snd_kcontrol *ctl;
 	int err;
 
-	ctl = snd_ctl_new1(&newctls[type], chip);
+	ctl = snd_ctl_new1(&newctls[c->type], chip);
 	if (! ctl)
 		return -ENOMEM;
-	strlcpy(ctl->id.name, name, sizeof(ctl->id.name));
-	ctl->id.index = index;
-	ctl->private_value = value;
+	strlcpy(ctl->id.name, c->name, sizeof(ctl->id.name));
+	ctl->id.index = c->index;
+	ctl->private_value = c->private_value;
+	if (c->tlv) {
+		ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;
+		ctl->tlv.p = c->tlv;
+	}
 	if ((err = snd_ctl_add(chip->card, ctl)) < 0)
 		return err;
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_ad1848_add_ctl_elem);
+
+static const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);
 
 static struct ad1848_mix_elem snd_ad1848_controls[] = {
 AD1848_DOUBLE("PCM Playback Switch", 0, AD1848_LEFT_OUTPUT, AD1848_RIGHT_OUTPUT, 7, 7, 1, 1),
-AD1848_DOUBLE("PCM Playback Volume", 0, AD1848_LEFT_OUTPUT, AD1848_RIGHT_OUTPUT, 0, 0, 63, 1),
+AD1848_DOUBLE_TLV("PCM Playback Volume", 0, AD1848_LEFT_OUTPUT, AD1848_RIGHT_OUTPUT, 0, 0, 63, 1,
+		  db_scale_6bit),
 AD1848_DOUBLE("Aux Playback Switch", 0, AD1848_AUX1_LEFT_INPUT, AD1848_AUX1_RIGHT_INPUT, 7, 7, 1, 1),
-AD1848_DOUBLE("Aux Playback Volume", 0, AD1848_AUX1_LEFT_INPUT, AD1848_AUX1_RIGHT_INPUT, 0, 0, 31, 1),
+AD1848_DOUBLE_TLV("Aux Playback Volume", 0, AD1848_AUX1_LEFT_INPUT, AD1848_AUX1_RIGHT_INPUT, 0, 0, 31, 1,
+		  db_scale_5bit_12db_max),
 AD1848_DOUBLE("Aux Playback Switch", 1, AD1848_AUX2_LEFT_INPUT, AD1848_AUX2_RIGHT_INPUT, 7, 7, 1, 1),
-AD1848_DOUBLE("Aux Playback Volume", 1, AD1848_AUX2_LEFT_INPUT, AD1848_AUX2_RIGHT_INPUT, 0, 0, 31, 1),
-AD1848_DOUBLE("Capture Volume", 0, AD1848_LEFT_INPUT, AD1848_RIGHT_INPUT, 0, 0, 15, 0),
+AD1848_DOUBLE_TLV("Aux Playback Volume", 1, AD1848_AUX2_LEFT_INPUT, AD1848_AUX2_RIGHT_INPUT, 0, 0, 31, 1,
+		  db_scale_5bit_12db_max),
+AD1848_DOUBLE_TLV("Capture Volume", 0, AD1848_LEFT_INPUT, AD1848_RIGHT_INPUT, 0, 0, 15, 0,
+		  db_scale_rec_gain),
 {
 	.name = "Capture Source",
 	.type = AD1848_MIX_CAPTURE,
 },
 AD1848_SINGLE("Loopback Capture Switch", 0, AD1848_LOOPBACK, 0, 1, 0),
-AD1848_SINGLE("Loopback Capture Volume", 0, AD1848_LOOPBACK, 1, 63, 0)
+AD1848_SINGLE_TLV("Loopback Capture Volume", 0, AD1848_LOOPBACK, 1, 63, 0,
+		  db_scale_6bit),
 };
                                         
 int snd_ad1848_mixer(struct snd_ad1848 *chip)
@@ -1245,12 +1269,7 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_ad1848_out);
-EXPORT_SYMBOL(snd_ad1848_create);
-EXPORT_SYMBOL(snd_ad1848_pcm);
-EXPORT_SYMBOL(snd_ad1848_get_pcm_ops);
 EXPORT_SYMBOL(snd_ad1848_mixer);
-EXPORT_SYMBOL(snd_ad1848_add_ctl);
 
 /*
  *  INIT part
--- linux-2.6.18.noarch/sound/isa/wavefront/yss225.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/wavefront/yss225.c	2007-06-05 17:43:45.000000000 -0400
@@ -0,0 +1,2739 @@
+/*
+ *  Copyright (c) 1998-2002 by Paul Davis <pbd@op.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/* weird stuff, derived from port I/O tracing with dosemu */
+
+static const struct {
+	unsigned char addr;
+	unsigned char data;
+} yss225_registers[] __devinitdata = {
+/* Set all bits for all channels on the MOD unit to zero */
+{ WAIT_IDLE }, { 0xe, 0x10 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x11 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x12 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x13 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x14 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x15 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x16 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x17 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x18 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x19 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x20 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x21 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x22 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x23 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x24 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x25 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x26 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x27 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x28 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x29 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x30 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x31 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x32 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x33 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x34 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x35 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x36 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x37 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x38 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x39 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x40 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x41 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x42 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x43 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x44 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x45 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x46 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x47 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x48 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x49 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x50 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x51 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x52 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x53 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x54 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x55 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x56 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x57 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x58 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x59 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x60 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x61 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x62 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x63 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x64 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x65 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x66 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x67 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x68 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x69 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x70 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x71 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x72 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x73 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x74 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x75 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x76 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x77 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x78 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x79 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x80 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x81 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x82 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x83 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x84 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x85 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x86 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x87 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x88 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x89 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x90 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x91 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x92 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x93 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x94 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x95 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x96 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x97 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x98 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x99 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xaa }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xab }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xac }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xad }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xae }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xaf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xba }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbe }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xca }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xce }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xda }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xde }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xea }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xeb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xec }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xed }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xee }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xef }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfa }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfe }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xff }, { 0xf, 0x00 },
+
+/* XXX But why do this twice? */
+{ WAIT_IDLE }, { 0xe, 0x10 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x11 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x12 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x13 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x14 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x15 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x16 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x17 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x18 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x19 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x20 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x21 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x22 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x23 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x24 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x25 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x26 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x27 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x28 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x29 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x30 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x31 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x32 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x33 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x34 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x35 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x36 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x37 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x38 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x39 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x40 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x41 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x42 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x43 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x44 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x45 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x46 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x47 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x48 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x49 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x50 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x51 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x52 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x53 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x54 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x55 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x56 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x57 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x58 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x59 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x60 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x61 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x62 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x63 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x64 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x65 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x66 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x67 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x68 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x69 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x70 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x71 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x72 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x73 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x74 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x75 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x76 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x77 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x78 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x79 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x80 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x81 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x82 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x83 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x84 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x85 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x86 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x87 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x88 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x89 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x90 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x91 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x92 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x93 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x94 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x95 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x96 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x97 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x98 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x99 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xaa }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xab }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xac }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xad }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xae }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xaf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xba }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbe }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xca }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xce }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xda }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xde }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xea }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xeb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xec }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xed }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xee }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xef }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfa }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfe }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xff }, { 0xf, 0x00 },
+
+/* mute on */
+{ WAIT_IDLE }, { 0x8, 0x02 },
+
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x44 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x42 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x43 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x7c }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x7e }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x46 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x49 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x47 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x4a }, { 0xd, 0x00 }, { 0xc, 0x00 },
+
+/* either because of stupidity by TB's programmers, or because it
+   actually does something, rezero the MOD page. */
+{ WAIT_IDLE }, { 0xe, 0x10 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x11 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x12 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x13 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x14 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x15 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x16 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x17 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x18 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x19 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x1f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x20 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x21 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x22 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x23 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x24 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x25 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x26 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x27 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x28 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x29 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x2f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x30 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x31 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x32 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x33 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x34 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x35 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x36 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x37 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x38 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x39 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x3f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x40 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x41 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x42 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x43 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x44 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x45 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x46 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x47 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x48 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x49 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x4f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x50 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x51 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x52 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x53 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x54 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x55 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x56 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x57 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x58 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x59 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x5f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x60 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x61 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x62 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x63 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x64 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x65 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x66 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x67 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x68 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x69 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x6f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x70 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x71 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x72 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x73 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x74 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x75 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x76 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x77 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x78 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x79 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x7f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x80 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x81 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x82 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x83 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x84 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x85 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x86 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x87 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x88 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x89 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x8f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x90 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x91 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x92 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x93 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x94 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x95 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x96 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x97 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x98 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x99 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9a }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9b }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9c }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9d }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9e }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0x9f }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xa9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xaa }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xab }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xac }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xad }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xae }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xaf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xb9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xba }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbe }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xbf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xc9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xca }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xce }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xcf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xd9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xda }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xde }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xdf }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xe9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xea }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xeb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xec }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xed }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xee }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xef }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf0 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf1 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf2 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf3 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf4 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf5 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf6 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf7 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf8 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xf9 }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfa }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfb }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfc }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfd }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xfe }, { 0xf, 0x00 },
+{ WAIT_IDLE }, { 0xe, 0xff }, { 0xf, 0x00 },
+
+/* load page zero */
+{ 0x9, 0x05 }, { 0xb, 0x00 }, { 0xa, 0x00 },
+
+{ 0xd, 0x01 }, { 0xc, 0x7c }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1e }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xf5 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x11 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x32 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x13 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x14 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x76 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x18 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x19 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0x1a }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0x17 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x10 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0xa0 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xd1 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0xf2 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x13 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xf4 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xe0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x15 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x16 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x17 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x50 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x71 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x92 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xb3 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xa0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xd4 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xf5 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x70 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0xa0 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x11 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x16 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x10 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x17 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1b }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1d }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xdf }, { WAIT_IDLE },
+
+/* Now load page one */
+{ 0x9, 0x05 }, { 0xb, 0x01 }, { 0xa, 0x00 },
+
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x19 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1f }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xd8 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x19 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x18 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0xfa }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1a }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xfb }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xa0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1b }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xd7 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xf7 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1c }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x3c }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x3f }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xdf }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x5d }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x7d }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0x9e }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xbe }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x03 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1b }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xdb }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xdb }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xe0 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xfb }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xfb }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1b }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x02 }, { 0xa, 0x00 },
+
+{ 0xc, 0xc4 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x25 }, { WAIT_IDLE },
+{ 0xc, 0x01 }, { WAIT_IDLE },
+{ 0xc, 0x06 }, { WAIT_IDLE },
+{ 0xc, 0xc4 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x25 }, { WAIT_IDLE },
+{ 0xc, 0x01 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x04 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x04 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x05 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x44 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x03 }, { 0xa, 0x00 },
+
+{ 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x47 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x06 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x70 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x42 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x42 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x42 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x42 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x40 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x04 }, { 0xa, 0x00 },
+
+{ 0xc, 0x63 }, { WAIT_IDLE },
+{ 0xc, 0x03 }, { WAIT_IDLE },
+{ 0xc, 0x26 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x2c }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x24 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x2e }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x01 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x22 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x22 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x22 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x62 }, { WAIT_IDLE },
+{ 0xc, 0x02 }, { WAIT_IDLE },
+{ 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xc, 0x01 }, { WAIT_IDLE },
+{ 0xc, 0x21 }, { WAIT_IDLE },
+{ 0xc, 0x01 }, { WAIT_IDLE },
+
+/* Load memory area (page six) */
+{ 0x9, 0x01 }, { 0xb, 0x06 },
+
+{ 0xa, 0x00 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x02 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x04 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x06 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x08 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x0a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x0c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x0e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x10 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x12 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x14 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x16 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x18 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x1a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x1c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x1e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x20 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x22 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x24 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x26 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x28 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x2a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x2c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x2e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x30 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x32 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x34 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x36 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x38 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x3a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x3c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x3e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x40 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x42 }, { 0xd, 0x03 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x44 }, { 0xd, 0x01 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x46 }, { 0xd, 0x0a }, { 0xc, 0x21 }, { WAIT_IDLE },
+{ 0xa, 0x48 }, { 0xd, 0x0d }, { 0xc, 0x23 }, { WAIT_IDLE },
+{ 0xa, 0x4a }, { 0xd, 0x23 }, { 0xc, 0x1b }, { WAIT_IDLE },
+{ 0xa, 0x4c }, { 0xd, 0x37 }, { 0xc, 0x8f }, { WAIT_IDLE },
+{ 0xa, 0x4e }, { 0xd, 0x45 }, { 0xc, 0x77 }, { WAIT_IDLE },
+{ 0xa, 0x50 }, { 0xd, 0x52 }, { 0xc, 0xe2 }, { WAIT_IDLE },
+{ 0xa, 0x52 }, { 0xd, 0x1c }, { 0xc, 0x92 }, { WAIT_IDLE },
+{ 0xa, 0x54 }, { 0xd, 0x1c }, { 0xc, 0x52 }, { WAIT_IDLE },
+{ 0xa, 0x56 }, { 0xd, 0x07 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x58 }, { 0xd, 0x2f }, { 0xc, 0xc6 }, { WAIT_IDLE },
+{ 0xa, 0x5a }, { 0xd, 0x0b }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x5c }, { 0xd, 0x30 }, { 0xc, 0x06 }, { WAIT_IDLE },
+{ 0xa, 0x5e }, { 0xd, 0x17 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x60 }, { 0xd, 0x3d }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xa, 0x62 }, { 0xd, 0x29 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x64 }, { 0xd, 0x3e }, { 0xc, 0x41 }, { WAIT_IDLE },
+{ 0xa, 0x66 }, { 0xd, 0x39 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x68 }, { 0xd, 0x4c }, { 0xc, 0x48 }, { WAIT_IDLE },
+{ 0xa, 0x6a }, { 0xd, 0x49 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x6c }, { 0xd, 0x4c }, { 0xc, 0x6c }, { WAIT_IDLE },
+{ 0xa, 0x6e }, { 0xd, 0x11 }, { 0xc, 0xd2 }, { WAIT_IDLE },
+{ 0xa, 0x70 }, { 0xd, 0x16 }, { 0xc, 0x0c }, { WAIT_IDLE },
+{ 0xa, 0x72 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x74 }, { 0xd, 0x00 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xa, 0x76 }, { 0xd, 0x0f }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x78 }, { 0xd, 0x00 }, { 0xc, 0x80 }, { WAIT_IDLE },
+{ 0xa, 0x7a }, { 0xd, 0x13 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x7c }, { 0xd, 0x80 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x7e }, { 0xd, 0x80 }, { 0xc, 0x80 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x07 }, { 0xa, 0x00 },
+
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x08 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x08 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x08 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x08 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0xe9 }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x8c }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x8c }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x1a }, { 0xc, 0x75 }, { WAIT_IDLE },
+{ 0xd, 0x0d }, { 0xc, 0x8b }, { WAIT_IDLE },
+{ 0xd, 0x04 }, { 0xc, 0xe9 }, { WAIT_IDLE },
+{ 0xd, 0x0b }, { 0xc, 0x16 }, { WAIT_IDLE },
+{ 0xd, 0x1a }, { 0xc, 0x38 }, { WAIT_IDLE },
+{ 0xd, 0x0d }, { 0xc, 0xc8 }, { WAIT_IDLE },
+{ 0xd, 0x04 }, { 0xc, 0x6f }, { WAIT_IDLE },
+{ 0xd, 0x0b }, { 0xc, 0x91 }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x8f }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x62 }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x62 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x7b }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x97 }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0x97 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x52 }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0xf6 }, { WAIT_IDLE },
+{ 0xd, 0x06 }, { 0xc, 0xf6 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x19 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x55 }, { WAIT_IDLE },
+{ 0xd, 0x14 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xd, 0x0d }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xd, 0x04 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xd, 0x14 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xd, 0x0d }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xd, 0x04 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xd, 0x05 }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+
+/* Now setup the MOD area. */
+{ 0xe, 0x01 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x02 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x03 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x04 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x05 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x06 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x07 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x08 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x09 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0a }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0b }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0c }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0d }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0e }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0f }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+
+{ 0xe, 0xb0 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb1 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb2 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb3 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb4 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb5 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb6 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb7 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb8 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb9 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xba }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xbb }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xbc }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xbd }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xbe }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xbf }, { 0xf, 0x20 }, { WAIT_IDLE },
+
+{ 0xe, 0xf0 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf1 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf2 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf3 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf4 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf5 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf6 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf7 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf8 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf9 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xfa }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xfb }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xfc }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xfd }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xfe }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xff }, { 0xf, 0x20 }, { WAIT_IDLE },
+
+{ 0xe, 0x10 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x11 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x12 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x13 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x14 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x15 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x16 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x17 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x18 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x19 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x1a }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x1b }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x1c }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x1d }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x1e }, { 0xf, 0x40 }, { WAIT_IDLE },
+{ 0xe, 0x1f }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x20 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x21 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x22 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x23 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x24 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x25 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x26 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x27 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x28 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x29 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x2a }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x2b }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x2c }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x2d }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x2e }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x2f }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x30 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x31 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x32 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x33 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x34 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x35 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x36 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x37 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x38 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x39 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x3a }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x3b }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x3c }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x3d }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x3e }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x3f }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0x40 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x41 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x42 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x43 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x44 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x45 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x46 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x47 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x48 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x49 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x4a }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x4b }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x4c }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x4d }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x4e }, { 0xf, 0x0e }, { WAIT_IDLE },
+{ 0xe, 0x4f }, { 0xf, 0x0e }, { WAIT_IDLE },
+{ 0xe, 0x50 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x51 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x52 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x53 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x54 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x55 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x56 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x57 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x58 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x59 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x5a }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x5b }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x5c }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x5d }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x5e }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x5f }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x60 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x61 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x62 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x63 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x64 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x65 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x66 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x67 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x68 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x69 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x6a }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x6b }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x6c }, { 0xf, 0x40 }, { WAIT_IDLE },
+{ 0xe, 0x6d }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x6e }, { 0xf, 0x40 }, { WAIT_IDLE },
+{ 0xe, 0x6f }, { 0xf, 0x40 }, { WAIT_IDLE },
+{ 0xe, 0x70 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x71 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x72 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x73 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x74 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x75 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x76 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x77 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x78 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x79 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x7a }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x7b }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x7c }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x7d }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x7e }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x7f }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x80 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x81 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x82 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x83 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x84 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x85 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x86 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x87 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x88 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x89 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x8a }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x8b }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x8c }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x8d }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x8e }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x8f }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x90 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x91 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x92 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x93 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x94 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x95 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x96 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x97 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x98 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x99 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x9a }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x9b }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x9c }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x9d }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x9e }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x9f }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa8 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa9 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xaa }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xab }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xac }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xad }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xae }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xaf }, { 0xf, 0x00 }, { WAIT_IDLE },
+
+{ 0xe, 0xc0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc8 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc9 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xca }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xcb }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xcc }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xcd }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xce }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xcf }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd8 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd9 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xda }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xdb }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xdc }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xdd }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xde }, { 0xf, 0x10 }, { WAIT_IDLE },
+{ 0xe, 0xdf }, { 0xf, 0x10 }, { WAIT_IDLE },
+{ 0xe, 0xe0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe8 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe9 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xea }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xeb }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xec }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xed }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xee }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xef }, { 0xf, 0x00 }, { WAIT_IDLE },
+
+{ 0xe, 0x01 }, { 0xf, 0x00 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x01 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x02 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x03 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x04 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x05 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x06 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x07 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x08 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x09 }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0a }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0b }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0c }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0d }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0e }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x0f }, { 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+
+/* mute on */
+{ 0x8, 0x02 },
+
+/* Now set the coefficients and so forth for the programs above */
+{ 0xb, 0x07 }, { 0xa, 0x46 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x49 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x4b }, { 0xd, 0x03 }, { 0xc, 0x11 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x4d }, { 0xd, 0x01 }, { 0xc, 0x32 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x46 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x49 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x40 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x41 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x01 }, { 0xa, 0x40 }, { 0xd, 0x02 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xb, 0x01 }, { 0xa, 0x41 }, { 0xd, 0x02 }, { 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x40 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x41 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x47 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x4a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x47 }, { 0xd, 0x01 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x4a }, { 0xd, 0x01 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x47 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x4a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x00 }, { 0xd, 0x01 }, { 0xc, 0x1c }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x44 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x44 }, { 0xd, 0x01 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x44 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x42 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x43 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x42 }, { 0xd, 0x01 }, { 0xc, 0x1a }, { WAIT_IDLE },
+{ 0xb, 0x00 }, { 0xa, 0x43 }, { 0xd, 0x01 }, { 0xc, 0x20 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x42 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x43 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x40 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x41 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x01 }, { 0xa, 0x40 }, { 0xd, 0x02 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xb, 0x01 }, { 0xa, 0x41 }, { 0xd, 0x02 }, { 0xc, 0x60 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x40 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x41 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x44 }, { 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x42 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x43 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x40 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x41 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x51 }, { 0xd, 0x06 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x50 }, { 0xd, 0x06 }, { 0xc, 0x40 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x4f }, { 0xd, 0x03 }, { 0xc, 0x81 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x53 }, { 0xd, 0x1a }, { 0xc, 0x76 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x54 }, { 0xd, 0x0d }, { 0xc, 0x8b }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x55 }, { 0xd, 0x04 }, { 0xc, 0xe9 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x56 }, { 0xd, 0x0b }, { 0xc, 0x17 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x57 }, { 0xd, 0x1a }, { 0xc, 0x38 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x58 }, { 0xd, 0x0d }, { 0xc, 0xc9 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x59 }, { 0xd, 0x04 }, { 0xc, 0x6f }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x5a }, { 0xd, 0x0b }, { 0xc, 0x91 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x73 }, { 0xd, 0x14 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x74 }, { 0xd, 0x0d }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x75 }, { 0xd, 0x04 }, { 0xc, 0xd9 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x76 }, { 0xd, 0x05 }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x77 }, { 0xd, 0x14 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x78 }, { 0xd, 0x0d }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x79 }, { 0xd, 0x04 }, { 0xc, 0xd9 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7a }, { 0xd, 0x05 }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x5e }, { 0xd, 0x03 }, { 0xc, 0x68 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x5c }, { 0xd, 0x04 }, { 0xc, 0x31 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x5d }, { 0xd, 0x04 }, { 0xc, 0x31 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x62 }, { 0xd, 0x03 }, { 0xc, 0x52 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x60 }, { 0xd, 0x04 }, { 0xc, 0x76 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x61 }, { 0xd, 0x04 }, { 0xc, 0x76 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x66 }, { 0xd, 0x03 }, { 0xc, 0x2e }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x64 }, { 0xd, 0x04 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x65 }, { 0xd, 0x04 }, { 0xc, 0xda }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x6a }, { 0xd, 0x02 }, { 0xc, 0xf6 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x68 }, { 0xd, 0x05 }, { 0xc, 0x62 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x69 }, { 0xd, 0x05 }, { 0xc, 0x62 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x46 }, { 0xd, 0x0a }, { 0xc, 0x22 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x48 }, { 0xd, 0x0d }, { 0xc, 0x24 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x6e }, { 0xd, 0x11 }, { 0xc, 0xd3 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x70 }, { 0xd, 0x15 }, { 0xc, 0xcb }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x52 }, { 0xd, 0x20 }, { 0xc, 0x93 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x54 }, { 0xd, 0x20 }, { 0xc, 0x54 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x4a }, { 0xd, 0x27 }, { 0xc, 0x1d }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x58 }, { 0xd, 0x2f }, { 0xc, 0xc8 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x5c }, { 0xd, 0x30 }, { 0xc, 0x07 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x4c }, { 0xd, 0x37 }, { 0xc, 0x90 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x60 }, { 0xd, 0x3d }, { 0xc, 0xdb }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x64 }, { 0xd, 0x3e }, { 0xc, 0x42 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x4e }, { 0xd, 0x45 }, { 0xc, 0x78 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x68 }, { 0xd, 0x4c }, { 0xc, 0x48 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x6c }, { 0xd, 0x4c }, { 0xc, 0x6c }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x50 }, { 0xd, 0x52 }, { 0xc, 0xe2 }, { WAIT_IDLE },
+{ 0xb, 0x06 }, { 0xa, 0x42 }, { 0xd, 0x02 }, { 0xc, 0xba }, { WAIT_IDLE },
+
+/* Some settings (?) */
+{ WAIT_IDLE }, { 0xe, 0x1e }, { 0xf, 0x14 },
+{ WAIT_IDLE }, { 0xe, 0xde }, { 0xf, 0x20 },
+{ WAIT_IDLE }, { 0xe, 0xdf }, { 0xf, 0x20 },
+
+/* some more coefficients */
+{ WAIT_IDLE }, { 0xb, 0x06 }, { 0xa, 0x78 }, { 0xd, 0x00 }, { 0xc, 0x40 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x03 }, { 0xd, 0x0f }, { 0xc, 0xff },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x0b }, { 0xd, 0x0f }, { 0xc, 0xff },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x02 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x0a }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x46 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ WAIT_IDLE }, { 0xb, 0x07 }, { 0xa, 0x49 }, { 0xd, 0x00 }, { 0xc, 0x00 },
+
+/* Now, for some strange reason, lets reload every page
+   and all the coefficients over again. I have *NO* idea
+   why this is done. I do know that no sound is produced
+   is this phase is omitted. */
+{ 0x9, 0x05 }, { 0xb, 0x00 }, { 0xa, 0x10 },
+
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x02 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x01 }, { 0xa, 0x10 },
+
+{ 0xd, 0x01 }, { 0xc, 0xc0 }, { WAIT_IDLE },
+{ 0xd, 0x01 }, { 0xc, 0xfa }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x1a }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+
+{ WAIT_IDLE }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x02 }, { 0xa, 0x10 },
+
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x46 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x03 }, { 0xa, 0x10 },
+
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x04 }, { 0xa, 0x10 },
+
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xc, 0x00 }, { WAIT_IDLE },
+
+/* Page six v.2 */
+{ 0x9, 0x01 }, { 0xb, 0x06 },
+
+{ 0xa, 0x10 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x12 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x14 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x16 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x18 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x1a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x1c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x1e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x20 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x22 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x24 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x26 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x28 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x2a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x2c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x2e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x30 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x32 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x34 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x36 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x38 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x3a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x3c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xa, 0x3e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+
+{ 0x9, 0x05 }, { 0xb, 0x07 }, { 0xa, 0x10 },
+
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+
+{ 0xe, 0x01 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x02 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x03 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x04 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x05 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x06 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x07 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xb0 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb1 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb2 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb3 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb4 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb5 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb6 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xb7 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf0 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf1 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf2 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf3 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf4 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf5 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf6 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0xf7 }, { 0xf, 0x20 }, { WAIT_IDLE },
+{ 0xe, 0x10 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x11 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x12 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x13 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x14 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x15 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x16 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x17 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x20 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x21 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x22 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x23 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x24 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x25 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x26 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x27 }, { 0xf, 0xff }, { WAIT_IDLE },
+{ 0xe, 0x30 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x31 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x32 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x33 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x34 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x35 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x36 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x37 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x40 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x41 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x42 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x43 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x44 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x45 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x46 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x47 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x50 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x51 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x52 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x53 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x54 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x55 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x56 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x57 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x60 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x61 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x62 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x63 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x64 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x65 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x66 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x67 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x70 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x71 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x72 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x73 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x74 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x75 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x76 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x77 }, { 0xf, 0xc0 }, { WAIT_IDLE },
+{ 0xe, 0x80 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x81 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x82 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x83 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x84 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x85 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x86 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x87 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x90 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x91 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x92 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x93 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x94 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x95 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x96 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x97 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xa7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xc7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xd7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe0 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe1 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe2 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe3 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe4 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe5 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe6 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0xe7 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x00 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x02 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x03 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x04 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x05 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x06 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+{ 0xe, 0x01 }, { 0xf, 0x07 }, { WAIT_IDLE },
+{ 0xe, 0x02 }, { 0xf, 0x01 }, { WAIT_IDLE },
+
+{ 0xb, 0x07 }, { 0xa, 0x46 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x49 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x45 }, { 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x48 }, { 0xd, 0x0f }, { 0xc, 0xff }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7b }, { 0xd, 0x04 }, { 0xc, 0xcc }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7d }, { 0xd, 0x04 }, { 0xc, 0xcc }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x7e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x46 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x49 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x47 }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x4a }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0x00 }, { WAIT_IDLE },
+
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x00 }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x00 }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x01 }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x01 }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x01 }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x01 }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x01 }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x01 }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x01 }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x01 }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x01 }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x01 }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x01 }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x01 }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x02 }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x02 }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x02 }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x02 }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x02 }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x02 }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x02 }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x02 }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x02 }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x02 }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x02 }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x02 }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x03 }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x03 }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x03 }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x03 }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x03 }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x03 }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x03 }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x03 }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x03 }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x03 }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x03 }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x03 }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x04 }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x04 }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x05 }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x05 }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x05 }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x05 }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x05 }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x05 }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x05 }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x05 }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x05 }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x05 }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x05 }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x05 }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x06 }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x06 }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x06 }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x06 }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x06 }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x06 }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x06 }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x06 }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x06 }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x06 }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x06 }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x06 }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x07 }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x07 }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x07 }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x07 }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x07 }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x07 }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x07 }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x07 }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x07 }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x07 }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x07 }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x07 }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x08 }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x08 }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x09 }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x09 }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x09 }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x09 }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x09 }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x09 }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x09 }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x09 }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x09 }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x09 }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x09 }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x09 }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0a }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0a }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0a }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0a }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0a }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0a }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0a }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0a }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0a }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0a }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0a }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0a }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0b }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0b }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0b }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0b }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0b }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0b }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0b }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0b }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0b }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0b }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0b }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0b }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0x00 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0x28 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0x51 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0x7a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0xa3 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0xcc },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0c }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0c }, { 0xc, 0xf5 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0d }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0d }, { 0xc, 0x1e },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0d }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0d }, { 0xc, 0x47 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0d }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0d }, { 0xc, 0x70 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0d }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0d }, { 0xc, 0x99 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0d }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0d }, { 0xc, 0xc2 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0d }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0d }, { 0xc, 0xeb },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0e }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0e }, { 0xc, 0x14 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0e }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0e }, { 0xc, 0x3d },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0e }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0e }, { 0xc, 0x66 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0e }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0e }, { 0xc, 0x8f },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0e }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0e }, { 0xc, 0xb8 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0e }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0e }, { 0xc, 0xe1 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0x0a },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0x33 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0x5c },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0x85 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0xae },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0xd7 },
+{ 0xb, 0x07 }, { 0xa, 0x4c }, { 0xd, 0x0f }, { 0xc, 0xff },
+{ 0xb, 0x07 }, { 0xa, 0x4e }, { 0xd, 0x0f }, { 0xc, 0xff },
+
+/* mute off */
+{ 0x8, 0x00 }, { WAIT_IDLE }
+};
--- linux-2.6.18.noarch/sound/isa/wavefront/wavefront_fx.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/wavefront/wavefront_fx.c	2007-06-05 17:43:45.000000000 -0400
@@ -21,6 +21,7 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include <sound/snd_wavefront.h>
 #include <sound/initval.h>
@@ -32,325 +33,17 @@
 #define FX_MSB_TRANSFER 0x02    /* transfer after DSP MSB byte written */
 #define FX_AUTO_INCR    0x04    /* auto-increment DSP address after transfer */
 
-/* weird stuff, derived from port I/O tracing with dosemu */
+#define WAIT_IDLE	0xff
 
-static unsigned char page_zero[] __devinitdata = {
-0x01, 0x7c, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x00,
-0x11, 0x00, 0x20, 0x00, 0x32, 0x00, 0x40, 0x00, 0x13, 0x00, 0x00,
-0x00, 0x14, 0x02, 0x76, 0x00, 0x60, 0x00, 0x80, 0x02, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x19,
-0x01, 0x1a, 0x01, 0x20, 0x01, 0x40, 0x01, 0x17, 0x00, 0x00, 0x01,
-0x80, 0x01, 0x20, 0x00, 0x10, 0x01, 0xa0, 0x03, 0xd1, 0x00, 0x00,
-0x01, 0xf2, 0x02, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0xf4, 0x02,
-0xe0, 0x00, 0x15, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17,
-0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x50, 0x00, 0x00, 0x00,
-0x40, 0x00, 0x00, 0x00, 0x71, 0x02, 0x00, 0x00, 0x60, 0x00, 0x00,
-0x00, 0x92, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xb3, 0x02,
-0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x40,
-0x00, 0x80, 0x00, 0xf5, 0x00, 0x20, 0x00, 0x70, 0x00, 0xa0, 0x02,
-0x11, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
-0x02, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x17, 0x00, 0x1b, 0x00,
-0x1d, 0x02, 0xdf
-};
-
-static unsigned char page_one[] __devinitdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x19, 0x00,
-0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd8, 0x00, 0x00,
-0x02, 0x20, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01,
-0xc0, 0x01, 0xfa, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x02, 0x60,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x02, 0x80, 0x00,
-0x00, 0x02, 0xfb, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x1b, 0x02, 0xd7,
-0x00, 0x00, 0x02, 0xf7, 0x03, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00,
-0x1c, 0x03, 0x3c, 0x00, 0x00, 0x03, 0x3f, 0x00, 0x00, 0x03, 0xc0,
-0x00, 0x00, 0x03, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5d, 0x00,
-0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0x7d, 0x00, 0x00, 0x03, 0xc0,
-0x00, 0x00, 0x03, 0x9e, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03,
-0xbe, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
-0xdb, 0x00, 0x00, 0x02, 0xdb, 0x00, 0x00, 0x02, 0xe0, 0x00, 0x00,
-0x02, 0xfb, 0x00, 0x00, 0x02, 0xc0, 0x02, 0x40, 0x02, 0xfb, 0x02,
-0x60, 0x00, 0x1b
-};
-
-static unsigned char page_two[] __devinitdata = {
-0xc4, 0x00, 0x44, 0x07, 0x44, 0x00, 0x40, 0x25, 0x01, 0x06, 0xc4,
-0x07, 0x40, 0x25, 0x01, 0x00, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x07,
-0x05, 0x05, 0x05, 0x04, 0x07, 0x05, 0x04, 0x07, 0x05, 0x44, 0x46,
-0x44, 0x46, 0x46, 0x07, 0x05, 0x44, 0x46, 0x05, 0x46, 0x05, 0x46,
-0x05, 0x46, 0x05, 0x44, 0x46, 0x05, 0x07, 0x44, 0x46, 0x05, 0x07,
-0x44, 0x46, 0x05, 0x07, 0x44, 0x46, 0x05, 0x07, 0x44, 0x05, 0x05,
-0x05, 0x44, 0x05, 0x05, 0x05, 0x46, 0x05, 0x46, 0x05, 0x46, 0x05,
-0x46, 0x05, 0x46, 0x07, 0x46, 0x07, 0x44
-};
-
-static unsigned char page_three[] __devinitdata = {
-0x07, 0x40, 0x00, 0x00, 0x00, 0x47, 0x00, 0x40, 0x00, 0x40, 0x06,
-0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
-0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00,
-0x60, 0x00, 0x70, 0x00, 0x40, 0x00, 0x40, 0x00, 0x42, 0x00, 0x40,
-0x00, 0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
-0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-0x00, 0x42, 0x00, 0x40, 0x00, 0x42, 0x00, 0x02, 0x00, 0x02, 0x00,
-0x02, 0x00, 0x42, 0x00, 0xc0, 0x00, 0x40
-};
-
-static unsigned char page_four[] __devinitdata = {
-0x63, 0x03, 0x26, 0x02, 0x2c, 0x00, 0x24, 0x00, 0x2e, 0x02, 0x02,
-0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
-0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
-0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00,
-0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x60,
-0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00,
-0x20, 0x00, 0x22, 0x02, 0x22, 0x02, 0x20, 0x00, 0x60, 0x00, 0x22,
-0x02, 0x62, 0x02, 0x20, 0x01, 0x21, 0x01
-};
-
-static unsigned char page_six[] __devinitdata = {
-0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00,
-0x00, 0x08, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0e,
-0x00, 0x00, 0x10, 0x00, 0x00, 0x12, 0x00, 0x00, 0x14, 0x00, 0x00,
-0x16, 0x00, 0x00, 0x18, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x1c, 0x00,
-0x00, 0x1e, 0x00, 0x00, 0x20, 0x00, 0x00, 0x22, 0x00, 0x00, 0x24,
-0x00, 0x00, 0x26, 0x00, 0x00, 0x28, 0x00, 0x00, 0x2a, 0x00, 0x00,
-0x2c, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x30, 0x00, 0x00, 0x32, 0x00,
-0x00, 0x34, 0x00, 0x00, 0x36, 0x00, 0x00, 0x38, 0x00, 0x00, 0x3a,
-0x00, 0x00, 0x3c, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x40, 0x00, 0x00,
-0x42, 0x03, 0x00, 0x44, 0x01, 0x00, 0x46, 0x0a, 0x21, 0x48, 0x0d,
-0x23, 0x4a, 0x23, 0x1b, 0x4c, 0x37, 0x8f, 0x4e, 0x45, 0x77, 0x50,
-0x52, 0xe2, 0x52, 0x1c, 0x92, 0x54, 0x1c, 0x52, 0x56, 0x07, 0x00,
-0x58, 0x2f, 0xc6, 0x5a, 0x0b, 0x00, 0x5c, 0x30, 0x06, 0x5e, 0x17,
-0x00, 0x60, 0x3d, 0xda, 0x62, 0x29, 0x00, 0x64, 0x3e, 0x41, 0x66,
-0x39, 0x00, 0x68, 0x4c, 0x48, 0x6a, 0x49, 0x00, 0x6c, 0x4c, 0x6c,
-0x6e, 0x11, 0xd2, 0x70, 0x16, 0x0c, 0x72, 0x00, 0x00, 0x74, 0x00,
-0x80, 0x76, 0x0f, 0x00, 0x78, 0x00, 0x80, 0x7a, 0x13, 0x00, 0x7c,
-0x80, 0x00, 0x7e, 0x80, 0x80
-};
-
-static unsigned char page_seven[] __devinitdata = {
-0x0f, 0xff, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-0x08, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f,
-0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x0f, 0xff,
-0x0f, 0xff, 0x0f, 0xff, 0x02, 0xe9, 0x06, 0x8c, 0x06, 0x8c, 0x0f,
-0xff, 0x1a, 0x75, 0x0d, 0x8b, 0x04, 0xe9, 0x0b, 0x16, 0x1a, 0x38,
-0x0d, 0xc8, 0x04, 0x6f, 0x0b, 0x91, 0x0f, 0xff, 0x06, 0x40, 0x06,
-0x40, 0x02, 0x8f, 0x0f, 0xff, 0x06, 0x62, 0x06, 0x62, 0x02, 0x7b,
-0x0f, 0xff, 0x06, 0x97, 0x06, 0x97, 0x02, 0x52, 0x0f, 0xff, 0x06,
-0xf6, 0x06, 0xf6, 0x02, 0x19, 0x05, 0x55, 0x05, 0x55, 0x05, 0x55,
-0x05, 0x55, 0x05, 0x55, 0x05, 0x55, 0x05, 0x55, 0x05, 0x55, 0x14,
-0xda, 0x0d, 0x93, 0x04, 0xda, 0x05, 0x93, 0x14, 0xda, 0x0d, 0x93,
-0x04, 0xda, 0x05, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x02, 0x00
-};
+#define FIRMWARE_IN_THE_KERNEL
 
-static unsigned char page_zero_v2[] __devinitdata = {
-0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-static unsigned char page_one_v2[] __devinitdata = {
-0x01, 0xc0, 0x01, 0xfa, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-static unsigned char page_two_v2[] __devinitdata = {
-0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00
-};
-static unsigned char page_three_v2[] __devinitdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00
-};
-static unsigned char page_four_v2[] __devinitdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00
-};
-
-static unsigned char page_seven_v2[] __devinitdata = {
-0x0f, 0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-static unsigned char mod_v2[] __devinitdata = {
-0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01, 0x02, 0x02,
-0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x04, 0x02, 0x00, 0x01, 0x05,
-0x02, 0x00, 0x01, 0x06, 0x02, 0x00, 0x01, 0x07, 0x02, 0x00, 0xb0,
-0x20, 0xb1, 0x20, 0xb2, 0x20, 0xb3, 0x20, 0xb4, 0x20, 0xb5, 0x20,
-0xb6, 0x20, 0xb7, 0x20, 0xf0, 0x20, 0xf1, 0x20, 0xf2, 0x20, 0xf3,
-0x20, 0xf4, 0x20, 0xf5, 0x20, 0xf6, 0x20, 0xf7, 0x20, 0x10, 0xff,
-0x11, 0xff, 0x12, 0xff, 0x13, 0xff, 0x14, 0xff, 0x15, 0xff, 0x16,
-0xff, 0x17, 0xff, 0x20, 0xff, 0x21, 0xff, 0x22, 0xff, 0x23, 0xff,
-0x24, 0xff, 0x25, 0xff, 0x26, 0xff, 0x27, 0xff, 0x30, 0x00, 0x31,
-0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00,
-0x37, 0x00, 0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44,
-0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x50, 0x00, 0x51, 0x00,
-0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57,
-0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x64, 0x00,
-0x65, 0x00, 0x66, 0x00, 0x67, 0x00, 0x70, 0xc0, 0x71, 0xc0, 0x72,
-0xc0, 0x73, 0xc0, 0x74, 0xc0, 0x75, 0xc0, 0x76, 0xc0, 0x77, 0xc0,
-0x80, 0x00, 0x81, 0x00, 0x82, 0x00, 0x83, 0x00, 0x84, 0x00, 0x85,
-0x00, 0x86, 0x00, 0x87, 0x00, 0x90, 0x00, 0x91, 0x00, 0x92, 0x00,
-0x93, 0x00, 0x94, 0x00, 0x95, 0x00, 0x96, 0x00, 0x97, 0x00, 0xa0,
-0x00, 0xa1, 0x00, 0xa2, 0x00, 0xa3, 0x00, 0xa4, 0x00, 0xa5, 0x00,
-0xa6, 0x00, 0xa7, 0x00, 0xc0, 0x00, 0xc1, 0x00, 0xc2, 0x00, 0xc3,
-0x00, 0xc4, 0x00, 0xc5, 0x00, 0xc6, 0x00, 0xc7, 0x00, 0xd0, 0x00,
-0xd1, 0x00, 0xd2, 0x00, 0xd3, 0x00, 0xd4, 0x00, 0xd5, 0x00, 0xd6,
-0x00, 0xd7, 0x00, 0xe0, 0x00, 0xe1, 0x00, 0xe2, 0x00, 0xe3, 0x00,
-0xe4, 0x00, 0xe5, 0x00, 0xe6, 0x00, 0xe7, 0x00, 0x01, 0x00, 0x02,
-0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x03,
-0x02, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x05, 0x02, 0x01, 0x01,
-0x06, 0x02, 0x01, 0x01, 0x07, 0x02, 0x01
-};
-static unsigned char coefficients[] __devinitdata = {
-0x07, 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x00, 0x4b, 0x03,
-0x11, 0x00, 0x4d, 0x01, 0x32, 0x07, 0x46, 0x00, 0x00, 0x07, 0x49,
-0x00, 0x00, 0x07, 0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x01,
-0x40, 0x02, 0x40, 0x01, 0x41, 0x02, 0x60, 0x07, 0x40, 0x00, 0x00,
-0x07, 0x41, 0x00, 0x00, 0x07, 0x47, 0x00, 0x00, 0x07, 0x4a, 0x00,
-0x00, 0x00, 0x47, 0x01, 0x00, 0x00, 0x4a, 0x01, 0x20, 0x07, 0x47,
-0x00, 0x00, 0x07, 0x4a, 0x00, 0x00, 0x07, 0x7c, 0x00, 0x00, 0x07,
-0x7e, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1c, 0x07, 0x7c, 0x00, 0x00,
-0x07, 0x7e, 0x00, 0x00, 0x07, 0x44, 0x00, 0x00, 0x00, 0x44, 0x01,
-0x00, 0x07, 0x44, 0x00, 0x00, 0x07, 0x42, 0x00, 0x00, 0x07, 0x43,
-0x00, 0x00, 0x00, 0x42, 0x01, 0x1a, 0x00, 0x43, 0x01, 0x20, 0x07,
-0x42, 0x00, 0x00, 0x07, 0x43, 0x00, 0x00, 0x07, 0x40, 0x00, 0x00,
-0x07, 0x41, 0x00, 0x00, 0x01, 0x40, 0x02, 0x40, 0x01, 0x41, 0x02,
-0x60, 0x07, 0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x07, 0x44,
-0x0f, 0xff, 0x07, 0x42, 0x00, 0x00, 0x07, 0x43, 0x00, 0x00, 0x07,
-0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x07, 0x51, 0x06, 0x40,
-0x07, 0x50, 0x06, 0x40, 0x07, 0x4f, 0x03, 0x81, 0x07, 0x53, 0x1a,
-0x76, 0x07, 0x54, 0x0d, 0x8b, 0x07, 0x55, 0x04, 0xe9, 0x07, 0x56,
-0x0b, 0x17, 0x07, 0x57, 0x1a, 0x38, 0x07, 0x58, 0x0d, 0xc9, 0x07,
-0x59, 0x04, 0x6f, 0x07, 0x5a, 0x0b, 0x91, 0x07, 0x73, 0x14, 0xda,
-0x07, 0x74, 0x0d, 0x93, 0x07, 0x75, 0x04, 0xd9, 0x07, 0x76, 0x05,
-0x93, 0x07, 0x77, 0x14, 0xda, 0x07, 0x78, 0x0d, 0x93, 0x07, 0x79,
-0x04, 0xd9, 0x07, 0x7a, 0x05, 0x93, 0x07, 0x5e, 0x03, 0x68, 0x07,
-0x5c, 0x04, 0x31, 0x07, 0x5d, 0x04, 0x31, 0x07, 0x62, 0x03, 0x52,
-0x07, 0x60, 0x04, 0x76, 0x07, 0x61, 0x04, 0x76, 0x07, 0x66, 0x03,
-0x2e, 0x07, 0x64, 0x04, 0xda, 0x07, 0x65, 0x04, 0xda, 0x07, 0x6a,
-0x02, 0xf6, 0x07, 0x68, 0x05, 0x62, 0x07, 0x69, 0x05, 0x62, 0x06,
-0x46, 0x0a, 0x22, 0x06, 0x48, 0x0d, 0x24, 0x06, 0x6e, 0x11, 0xd3,
-0x06, 0x70, 0x15, 0xcb, 0x06, 0x52, 0x20, 0x93, 0x06, 0x54, 0x20,
-0x54, 0x06, 0x4a, 0x27, 0x1d, 0x06, 0x58, 0x2f, 0xc8, 0x06, 0x5c,
-0x30, 0x07, 0x06, 0x4c, 0x37, 0x90, 0x06, 0x60, 0x3d, 0xdb, 0x06,
-0x64, 0x3e, 0x42, 0x06, 0x4e, 0x45, 0x78, 0x06, 0x68, 0x4c, 0x48,
-0x06, 0x6c, 0x4c, 0x6c, 0x06, 0x50, 0x52, 0xe2, 0x06, 0x42, 0x02,
-0xba
-};
-static unsigned char coefficients2[] __devinitdata = {
-0x07, 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x07, 0x45, 0x0f,
-0xff, 0x07, 0x48, 0x0f, 0xff, 0x07, 0x7b, 0x04, 0xcc, 0x07, 0x7d,
-0x04, 0xcc, 0x07, 0x7c, 0x00, 0x00, 0x07, 0x7e, 0x00, 0x00, 0x07,
-0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x07, 0x47, 0x00, 0x00,
-0x07, 0x4a, 0x00, 0x00, 0x07, 0x4c, 0x00, 0x00, 0x07, 0x4e, 0x00, 0x00
-};
-static unsigned char coefficients3[] __devinitdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x28, 0x00, 0x51, 0x00,
-0x51, 0x00, 0x7a, 0x00, 0x7a, 0x00, 0xa3, 0x00, 0xa3, 0x00, 0xcc,
-0x00, 0xcc, 0x00, 0xf5, 0x00, 0xf5, 0x01, 0x1e, 0x01, 0x1e, 0x01,
-0x47, 0x01, 0x47, 0x01, 0x70, 0x01, 0x70, 0x01, 0x99, 0x01, 0x99,
-0x01, 0xc2, 0x01, 0xc2, 0x01, 0xeb, 0x01, 0xeb, 0x02, 0x14, 0x02,
-0x14, 0x02, 0x3d, 0x02, 0x3d, 0x02, 0x66, 0x02, 0x66, 0x02, 0x8f,
-0x02, 0x8f, 0x02, 0xb8, 0x02, 0xb8, 0x02, 0xe1, 0x02, 0xe1, 0x03,
-0x0a, 0x03, 0x0a, 0x03, 0x33, 0x03, 0x33, 0x03, 0x5c, 0x03, 0x5c,
-0x03, 0x85, 0x03, 0x85, 0x03, 0xae, 0x03, 0xae, 0x03, 0xd7, 0x03,
-0xd7, 0x04, 0x00, 0x04, 0x00, 0x04, 0x28, 0x04, 0x28, 0x04, 0x51,
-0x04, 0x51, 0x04, 0x7a, 0x04, 0x7a, 0x04, 0xa3, 0x04, 0xa3, 0x04,
-0xcc, 0x04, 0xcc, 0x04, 0xf5, 0x04, 0xf5, 0x05, 0x1e, 0x05, 0x1e,
-0x05, 0x47, 0x05, 0x47, 0x05, 0x70, 0x05, 0x70, 0x05, 0x99, 0x05,
-0x99, 0x05, 0xc2, 0x05, 0xc2, 0x05, 0xeb, 0x05, 0xeb, 0x06, 0x14,
-0x06, 0x14, 0x06, 0x3d, 0x06, 0x3d, 0x06, 0x66, 0x06, 0x66, 0x06,
-0x8f, 0x06, 0x8f, 0x06, 0xb8, 0x06, 0xb8, 0x06, 0xe1, 0x06, 0xe1,
-0x07, 0x0a, 0x07, 0x0a, 0x07, 0x33, 0x07, 0x33, 0x07, 0x5c, 0x07,
-0x5c, 0x07, 0x85, 0x07, 0x85, 0x07, 0xae, 0x07, 0xae, 0x07, 0xd7,
-0x07, 0xd7, 0x08, 0x00, 0x08, 0x00, 0x08, 0x28, 0x08, 0x28, 0x08,
-0x51, 0x08, 0x51, 0x08, 0x7a, 0x08, 0x7a, 0x08, 0xa3, 0x08, 0xa3,
-0x08, 0xcc, 0x08, 0xcc, 0x08, 0xf5, 0x08, 0xf5, 0x09, 0x1e, 0x09,
-0x1e, 0x09, 0x47, 0x09, 0x47, 0x09, 0x70, 0x09, 0x70, 0x09, 0x99,
-0x09, 0x99, 0x09, 0xc2, 0x09, 0xc2, 0x09, 0xeb, 0x09, 0xeb, 0x0a,
-0x14, 0x0a, 0x14, 0x0a, 0x3d, 0x0a, 0x3d, 0x0a, 0x66, 0x0a, 0x66,
-0x0a, 0x8f, 0x0a, 0x8f, 0x0a, 0xb8, 0x0a, 0xb8, 0x0a, 0xe1, 0x0a,
-0xe1, 0x0b, 0x0a, 0x0b, 0x0a, 0x0b, 0x33, 0x0b, 0x33, 0x0b, 0x5c,
-0x0b, 0x5c, 0x0b, 0x85, 0x0b, 0x85, 0x0b, 0xae, 0x0b, 0xae, 0x0b,
-0xd7, 0x0b, 0xd7, 0x0c, 0x00, 0x0c, 0x00, 0x0c, 0x28, 0x0c, 0x28,
-0x0c, 0x51, 0x0c, 0x51, 0x0c, 0x7a, 0x0c, 0x7a, 0x0c, 0xa3, 0x0c,
-0xa3, 0x0c, 0xcc, 0x0c, 0xcc, 0x0c, 0xf5, 0x0c, 0xf5, 0x0d, 0x1e,
-0x0d, 0x1e, 0x0d, 0x47, 0x0d, 0x47, 0x0d, 0x70, 0x0d, 0x70, 0x0d,
-0x99, 0x0d, 0x99, 0x0d, 0xc2, 0x0d, 0xc2, 0x0d, 0xeb, 0x0d, 0xeb,
-0x0e, 0x14, 0x0e, 0x14, 0x0e, 0x3d, 0x0e, 0x3d, 0x0e, 0x66, 0x0e,
-0x66, 0x0e, 0x8f, 0x0e, 0x8f, 0x0e, 0xb8, 0x0e, 0xb8, 0x0e, 0xe1,
-0x0e, 0xe1, 0x0f, 0x0a, 0x0f, 0x0a, 0x0f, 0x33, 0x0f, 0x33, 0x0f,
-0x5c, 0x0f, 0x5c, 0x0f, 0x85, 0x0f, 0x85, 0x0f, 0xae, 0x0f, 0xae,
-0x0f, 0xd7, 0x0f, 0xd7, 0x0f, 0xff, 0x0f, 0xff
+#ifdef FIRMWARE_IN_THE_KERNEL
+#include "yss225.c"
+static const struct firmware yss225_registers_firmware = {
+	.data = (u8 *)yss225_registers,
+	.size = sizeof yss225_registers
 };
+#endif
 
 static int
 wavefront_fx_idle (snd_wavefront_t *dev)
@@ -555,465 +248,56 @@
    of the port I/O done, using the Yamaha faxback document as a guide
    to add more logic to the code. Its really pretty weird.
 
-   There was an alternative approach of just dumping the whole I/O
+   This is the approach of just dumping the whole I/O
    sequence as a series of port/value pairs and a simple loop
-   that output it. However, I hope that eventually I'll get more
-   control over what this code does, and so I tried to stick with
-   a somewhat "algorithmic" approach.
+   that outputs it.
 */
 
-
 int __devinit
 snd_wavefront_fx_start (snd_wavefront_t *dev)
-
 {
-	unsigned int i, j;
+	unsigned int i;
+	int err;
+	const struct firmware *firmware;
 
-	/* Set all bits for all channels on the MOD unit to zero */
-	/* XXX But why do this twice ? */
+	if (dev->fx_initialized)
+		return 0;
 
-	for (j = 0; j < 2; j++) {
-		for (i = 0x10; i <= 0xff; i++) {
-	    
-			if (!wavefront_fx_idle (dev)) {
-				return (-1);
+	err = request_firmware(&firmware, "yamaha/yss225_registers.bin",
+			       dev->card->dev);
+	if (err < 0) {
+#ifdef FIRMWARE_IN_THE_KERNEL
+		firmware = &yss225_registers_firmware;
+#else
+		err = -1;
+		goto out;
+#endif
+	}
+
+	for (i = 0; i + 1 < firmware->size; i += 2) {
+		if (firmware->data[i] >= 8 && firmware->data[i] < 16) {
+			outb(firmware->data[i + 1],
+			     dev->base + firmware->data[i]);
+		} else if (firmware->data[i] == WAIT_IDLE) {
+			if (!wavefront_fx_idle(dev)) {
+				err = -1;
+				goto out;
 			}
-	    
-			outb (i, dev->fx_mod_addr);
-			outb (0x0, dev->fx_mod_data);
-		}
-	}
-
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x02, dev->fx_op);                        /* mute on */
-
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x44, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x42, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x43, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x7c, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x7e, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x46, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x49, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x47, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x4a, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-
-	/* either because of stupidity by TB's programmers, or because it
-	   actually does something, rezero the MOD page.
-	*/
-	for (i = 0x10; i <= 0xff; i++) {
-	
-		if (!wavefront_fx_idle (dev)) {
-			return (-1);
+		} else {
+			snd_printk(KERN_ERR "invalid address"
+				   " in register data\n");
+			err = -1;
+			goto out;
 		}
-	
-		outb (i, dev->fx_mod_addr);
-		outb (0x0, dev->fx_mod_data);
 	}
-	/* load page zero */
 
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x00, dev->fx_dsp_page);
-	outb (0x00, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_zero); i += 2) {
-		outb (page_zero[i], dev->fx_dsp_msb);
-		outb (page_zero[i+1], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	/* Now load page one */
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x01, dev->fx_dsp_page);
-	outb (0x00, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_one); i += 2) {
-		outb (page_one[i], dev->fx_dsp_msb);
-		outb (page_one[i+1], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x02, dev->fx_dsp_page);
-	outb (0x00, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_two); i++) {
-		outb (page_two[i], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x03, dev->fx_dsp_page);
-	outb (0x00, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_three); i++) {
-		outb (page_three[i], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x04, dev->fx_dsp_page);
-	outb (0x00, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_four); i++) {
-		outb (page_four[i], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
+	dev->fx_initialized = 1;
+	err = 0;
 
-	/* Load memory area (page six) */
-    
-	outb (FX_LSB_TRANSFER, dev->fx_lcr); 
-	outb (0x06, dev->fx_dsp_page); 
-
-	for (i = 0; i < sizeof (page_six); i += 3) {
-		outb (page_six[i], dev->fx_dsp_addr);
-		outb (page_six[i+1], dev->fx_dsp_msb);
-		outb (page_six[i+2], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x00, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_seven); i += 2) {
-		outb (page_seven[i], dev->fx_dsp_msb);
-		outb (page_seven[i+1], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	/* Now setup the MOD area. We do this algorithmically in order to
-	   save a little data space. It could be done in the same fashion
-	   as the "pages".
-	*/
-
-	for (i = 0x00; i <= 0x0f; i++) {
-		outb (0x01, dev->fx_mod_addr);
-		outb (i, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-		outb (0x02, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0xb0; i <= 0xbf; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x20, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0xf0; i <= 0xff; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x20, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0x10; i <= 0x1d; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0xff, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0x1e, dev->fx_mod_addr);
-	outb (0x40, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	for (i = 0x1f; i <= 0x2d; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0xff, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0x2e, dev->fx_mod_addr);
-	outb (0x00, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	for (i = 0x2f; i <= 0x3e; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0x3f, dev->fx_mod_addr);
-	outb (0x20, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	for (i = 0x40; i <= 0x4d; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0x4e, dev->fx_mod_addr);
-	outb (0x0e, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x4f, dev->fx_mod_addr);
-	outb (0x0e, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-
-	for (i = 0x50; i <= 0x6b; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0x6c, dev->fx_mod_addr);
-	outb (0x40, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	outb (0x6d, dev->fx_mod_addr);
-	outb (0x00, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	outb (0x6e, dev->fx_mod_addr);
-	outb (0x40, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	outb (0x6f, dev->fx_mod_addr);
-	outb (0x40, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	for (i = 0x70; i <= 0x7f; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0xc0, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	for (i = 0x80; i <= 0xaf; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0xc0; i <= 0xdd; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0xde, dev->fx_mod_addr);
-	outb (0x10, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0xdf, dev->fx_mod_addr);
-	outb (0x10, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	for (i = 0xe0; i <= 0xef; i++) {
-		outb (i, dev->fx_mod_addr);
-		outb (0x00, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0x00; i <= 0x0f; i++) {
-		outb (0x01, dev->fx_mod_addr);
-		outb (i, dev->fx_mod_data);
-		outb (0x02, dev->fx_mod_addr);
-		outb (0x01, dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (0x02, dev->fx_op); /* mute on */
-
-	/* Now set the coefficients and so forth for the programs above */
-
-	for (i = 0; i < sizeof (coefficients); i += 4) {
-		outb (coefficients[i], dev->fx_dsp_page);
-		outb (coefficients[i+1], dev->fx_dsp_addr);
-		outb (coefficients[i+2], dev->fx_dsp_msb);
-		outb (coefficients[i+3], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	/* Some settings (?) that are too small to bundle into loops */
-
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x1e, dev->fx_mod_addr);
-	outb (0x14, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0xde, dev->fx_mod_addr);
-	outb (0x20, dev->fx_mod_data);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0xdf, dev->fx_mod_addr);
-	outb (0x20, dev->fx_mod_data);
-    
-	/* some more coefficients */
-
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x06, dev->fx_dsp_page);
-	outb (0x78, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x40, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x03, dev->fx_dsp_addr);
-	outb (0x0f, dev->fx_dsp_msb);
-	outb (0xff, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x0b, dev->fx_dsp_addr);
-	outb (0x0f, dev->fx_dsp_msb);
-	outb (0xff, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x02, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x0a, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x46, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-	if (!wavefront_fx_idle (dev)) return (-1);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x49, dev->fx_dsp_addr);
-	outb (0x00, dev->fx_dsp_msb);
-	outb (0x00, dev->fx_dsp_lsb);
-    
-	/* Now, for some strange reason, lets reload every page
-	   and all the coefficients over again. I have *NO* idea
-	   why this is done. I do know that no sound is produced
-	   is this phase is omitted.
-	*/
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x00, dev->fx_dsp_page);  
-	outb (0x10, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_zero_v2); i += 2) {
-		outb (page_zero_v2[i], dev->fx_dsp_msb);
-		outb (page_zero_v2[i+1], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x01, dev->fx_dsp_page);
-	outb (0x10, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_one_v2); i += 2) {
-		outb (page_one_v2[i], dev->fx_dsp_msb);
-		outb (page_one_v2[i+1], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	if (!wavefront_fx_idle (dev)) return (-1);
-	if (!wavefront_fx_idle (dev)) return (-1);
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x02, dev->fx_dsp_page);
-	outb (0x10, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_two_v2); i++) {
-		outb (page_two_v2[i], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x03, dev->fx_dsp_page);
-	outb (0x10, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_three_v2); i++) {
-		outb (page_three_v2[i], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x04, dev->fx_dsp_page);
-	outb (0x10, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_four_v2); i++) {
-		outb (page_four_v2[i], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-    
-	outb (FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x06, dev->fx_dsp_page);
-
-	/* Page six v.2 is algorithmic */
-    
-	for (i = 0x10; i <= 0x3e; i += 2) {
-		outb (i, dev->fx_dsp_addr);
-		outb (0x00, dev->fx_dsp_msb);
-		outb (0x00, dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);
-	outb (0x07, dev->fx_dsp_page);
-	outb (0x10, dev->fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_seven_v2); i += 2) {
-		outb (page_seven_v2[i], dev->fx_dsp_msb);
-		outb (page_seven_v2[i+1], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0x00; i < sizeof(mod_v2); i += 2) {
-		outb (mod_v2[i], dev->fx_mod_addr);
-		outb (mod_v2[i+1], dev->fx_mod_data);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0; i < sizeof (coefficients2); i += 4) {
-		outb (coefficients2[i], dev->fx_dsp_page);
-		outb (coefficients2[i+1], dev->fx_dsp_addr);
-		outb (coefficients2[i+2], dev->fx_dsp_msb);
-		outb (coefficients2[i+3], dev->fx_dsp_lsb);
-		if (!wavefront_fx_idle (dev)) return (-1);
-	}
-
-	for (i = 0; i < sizeof (coefficients3); i += 2) {
-		int x;
-
-		outb (0x07, dev->fx_dsp_page);
-		x = (i % 4) ? 0x4e : 0x4c;
-		outb (x, dev->fx_dsp_addr);
-		outb (coefficients3[i], dev->fx_dsp_msb);
-		outb (coefficients3[i+1], dev->fx_dsp_lsb);
-	}
-
-	outb (0x00, dev->fx_op); /* mute off */
-	if (!wavefront_fx_idle (dev)) return (-1);
-
-	return (0);
+out:
+#ifdef FIRMWARE_IN_THE_KERNEL
+	if (firmware != &yss225_registers_firmware)
+#endif
+		release_firmware(firmware);
+	return err;
 }
--- linux-2.6.18.noarch/sound/isa/wavefront/wavefront.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/wavefront/wavefront.c	2007-06-05 17:43:45.000000000 -0400
@@ -263,9 +263,7 @@
 
 #endif /* CONFIG_PNP */
 
-static irqreturn_t snd_wavefront_ics2115_interrupt(int irq, 
-					    void *dev_id, 
-					    struct pt_regs *regs)
+static irqreturn_t snd_wavefront_ics2115_interrupt(int irq, void *dev_id)
 {
 	snd_wavefront_card_t *acard;
 
@@ -404,6 +402,7 @@
 	init_waitqueue_head(&acard->wavefront.interrupt_sleeper);
 	spin_lock_init(&acard->wavefront.midi.open);
 	spin_lock_init(&acard->wavefront.midi.virtual);
+	acard->wavefront.card = card;
 	card->private_free = snd_wavefront_free;
 
 	return card;
--- linux-2.6.18.noarch/sound/isa/wavefront/wavefront_synth.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/wavefront/wavefront_synth.c	2007-06-05 17:43:45.000000000 -0400
@@ -1068,7 +1068,7 @@
 			blocksize = max_blksize;
 		} else {
 			/* round to nearest 16-byte value */
-			blocksize = ((length-written+7)&~0x7);
+			blocksize = ALIGN(length - written, 8);
 		}
 
 		if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_BLOCK, NULL, NULL)) {
--- linux-2.6.18.noarch/sound/isa/sb/sb16_csp.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/sb/sb16_csp.c	2007-06-05 17:43:39.000000000 -0400
@@ -161,10 +161,13 @@
  */
 static void snd_sb_csp_free(struct snd_hwdep *hwdep)
 {
+	int i;
 	struct snd_sb_csp *p = hwdep->private_data;
 	if (p) {
 		if (p->running & SNDRV_SB_CSP_ST_RUNNING)
 			snd_sb_csp_stop(p);
+		for (i = 0; i < ARRAY_SIZE(p->csp_programs); ++i)
+			release_firmware(p->csp_programs[i]);
 		kfree(p);
 	}
 }
@@ -687,8 +690,50 @@
 	return err;
 }
 
+#define FIRMWARE_IN_THE_KERNEL
+
+#ifdef FIRMWARE_IN_THE_KERNEL
 #include "sb16_csp_codecs.h"
 
+static const struct firmware snd_sb_csp_static_programs[] = {
+	{ .data = mulaw_main, .size = sizeof mulaw_main },
+	{ .data = alaw_main, .size = sizeof alaw_main },
+	{ .data = ima_adpcm_init, .size = sizeof ima_adpcm_init },
+	{ .data = ima_adpcm_playback, .size = sizeof ima_adpcm_playback },
+	{ .data = ima_adpcm_capture, .size = sizeof ima_adpcm_capture },
+};
+#endif
+
+static int snd_sb_csp_firmware_load(struct snd_sb_csp *p, int index, int flags)
+{
+	static const char *const names[] = {
+		"sb16/mulaw_main.csp",
+		"sb16/alaw_main.csp",
+		"sb16/ima_adpcm_init.csp",
+		"sb16/ima_adpcm_playback.csp",
+		"sb16/ima_adpcm_capture.csp",
+	};
+	const struct firmware *program;
+	int err;
+
+	BUILD_BUG_ON(ARRAY_SIZE(names) != CSP_PROGRAM_COUNT);
+	program = p->csp_programs[index];
+	if (!program) {
+		err = request_firmware(&program, names[index],
+				       p->chip->card->dev);
+		if (err >= 0)
+			p->csp_programs[index] = program;
+		else {
+#ifdef FIRMWARE_IN_THE_KERNEL
+			program = &snd_sb_csp_static_programs[index];
+#else
+			return err;
+#endif
+		}
+	}
+	return snd_sb_csp_load(p, program->data, program->size, flags);
+}
+
 /*
  * autoload hardware codec if necessary
  * return 0 if CSP is loaded and ready to run (p->running != 0)
@@ -708,27 +753,27 @@
 	} else {
 		switch (pcm_sfmt) {
 		case SNDRV_PCM_FORMAT_MU_LAW:
-			err = snd_sb_csp_load(p, &mulaw_main[0], sizeof(mulaw_main), 0);
+			err = snd_sb_csp_firmware_load(p, CSP_PROGRAM_MULAW, 0);
 			p->acc_format = SNDRV_PCM_FMTBIT_MU_LAW;
 			p->mode = SNDRV_SB_CSP_MODE_DSP_READ | SNDRV_SB_CSP_MODE_DSP_WRITE;
 			break;
 		case SNDRV_PCM_FORMAT_A_LAW:
-			err = snd_sb_csp_load(p, &alaw_main[0], sizeof(alaw_main), 0);
+			err = snd_sb_csp_firmware_load(p, CSP_PROGRAM_ALAW, 0);
 			p->acc_format = SNDRV_PCM_FMTBIT_A_LAW;
 			p->mode = SNDRV_SB_CSP_MODE_DSP_READ | SNDRV_SB_CSP_MODE_DSP_WRITE;
 			break;
 		case SNDRV_PCM_FORMAT_IMA_ADPCM:
-			err = snd_sb_csp_load(p, &ima_adpcm_init[0], sizeof(ima_adpcm_init),
-					      SNDRV_SB_CSP_LOAD_INITBLOCK);
+			err = snd_sb_csp_firmware_load(p, CSP_PROGRAM_ADPCM_INIT,
+						       SNDRV_SB_CSP_LOAD_INITBLOCK);
 			if (err)
 				break;
 			if (play_rec_mode == SNDRV_SB_CSP_MODE_DSP_WRITE) {
-				err = snd_sb_csp_load(p, &ima_adpcm_playback[0],
-						      sizeof(ima_adpcm_playback), 0);
+				err = snd_sb_csp_firmware_load
+					(p, CSP_PROGRAM_ADPCM_PLAYBACK, 0);
 				p->mode = SNDRV_SB_CSP_MODE_DSP_WRITE;
 			} else {
-				err = snd_sb_csp_load(p, &ima_adpcm_capture[0],
-						      sizeof(ima_adpcm_capture), 0);
+				err = snd_sb_csp_firmware_load
+					(p, CSP_PROGRAM_ADPCM_CAPTURE, 0);
 				p->mode = SNDRV_SB_CSP_MODE_DSP_READ;
 			}
 			p->acc_format = SNDRV_PCM_FMTBIT_IMA_ADPCM;
--- linux-2.6.18.noarch/sound/isa/sb/sb16_main.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/sb/sb16_main.c	2007-06-05 17:43:39.000000000 -0400
@@ -395,7 +395,7 @@
 	return result;
 }
 
-irqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id)
 {
 	struct snd_sb *chip = dev_id;
 	unsigned char status;
@@ -405,7 +405,7 @@
 	status = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);
 	spin_unlock(&chip->mixer_lock);
 	if ((status & SB_IRQTYPE_MPUIN) && chip->rmidi_callback)
-		chip->rmidi_callback(irq, chip->rmidi->private_data, regs);
+		chip->rmidi_callback(irq, chip->rmidi->private_data);
 	if (status & SB_IRQTYPE_8BIT) {
 		ok = 0;
 		if (chip->mode & SB_MODE_PLAYBACK_8) {
--- linux-2.6.18.noarch/sound/isa/sb/sb8.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/sb/sb8.c	2007-06-05 17:43:39.000000000 -0400
@@ -63,7 +63,7 @@
 	struct snd_sb *chip;
 };
 
-static irqreturn_t snd_sb8_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_sb8_interrupt(int irq, void *dev_id)
 {
 	struct snd_sb *chip = dev_id;
 
--- linux-2.6.18.noarch/sound/isa/sb/es968.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/sb/es968.c	2007-06-05 17:43:39.000000000 -0400
@@ -70,8 +70,7 @@
 
 #define	DRIVER_NAME	"snd-card-es968"
 
-static irqreturn_t snd_card_es968_interrupt(int irq, void *dev_id,
-					    struct pt_regs *regs)
+static irqreturn_t snd_card_es968_interrupt(int irq, void *dev_id)
 {
 	struct snd_sb *chip = dev_id;
 
--- linux-2.6.18.noarch/sound/isa/sb/sb_common.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/sb/sb_common.c	2007-06-05 17:43:39.000000000 -0400
@@ -232,7 +232,7 @@
 	chip->port = port;
 	
 	if (request_irq(irq, irq_handler, hardware == SB_HW_ALS4000 ?
-			IRQF_DISABLED | IRQF_SHARED : IRQF_DISABLED,
+			IRQF_SHARED : IRQF_DISABLED,
 			"SoundBlaster", (void *) chip)) {
 		snd_printk(KERN_ERR "sb: can't grab irq %d\n", irq);
 		snd_sbdsp_free(chip);
--- linux-2.6.18.noarch/sound/isa/Kconfig.orig	2007-06-05 16:07:52.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/Kconfig	2007-06-05 17:42:42.000000000 -0400
@@ -13,6 +13,7 @@
 
 config SND_ADLIB
 	tristate "AdLib FM card"
+	depends on SND
 	select SND_OPL3_LIB
 	help
 	  Say Y here to include support for AdLib FM cards.
@@ -357,6 +358,7 @@
 config SND_SB16_CSP
 	bool "Sound Blaster 16/AWE CSP support"
 	depends on (SND_SB16 || SND_SBAWE) && (BROKEN || !PPC)
+	select FW_LOADER
 	help
 	  Say Y here to include support for the CSP core.  This special
 	  coprocessor can do variable tasks like various compression and
@@ -389,6 +391,7 @@
 config SND_WAVEFRONT
 	tristate "Turtle Beach Maui,Tropez,Tropez+ (Wavefront)"
 	depends on SND
+	select FW_LOADER
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_CS4231_LIB
--- linux-2.6.18.noarch/sound/isa/es18xx.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/es18xx.c	2007-06-05 17:42:42.000000000 -0400
@@ -754,7 +754,7 @@
 		return snd_es18xx_playback2_trigger(chip, substream, cmd);
 }
 
-static irqreturn_t snd_es18xx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_es18xx_interrupt(int irq, void *dev_id)
 {
 	struct snd_es18xx *chip = dev_id;
 	unsigned char status;
@@ -799,7 +799,7 @@
 
 	/* MPU */
 	if ((status & MPU_IRQ) && chip->rmidi)
-		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
 
 	/* Hardware volume */
 	if (status & HWV_IRQ) {
@@ -2038,7 +2038,80 @@
 static struct platform_device *platform_devices[SNDRV_CARDS];
 
 #ifdef CONFIG_PNP
-static int pnp_registered;
+static int pnp_registered, pnpc_registered;
+
+static struct pnp_device_id snd_audiodrive_pnpbiosids[] = {
+	{ .id = "ESS1869" },
+	{ .id = "" }		/* end */
+};
+
+MODULE_DEVICE_TABLE(pnp, snd_audiodrive_pnpbiosids);
+
+/* PnP main device initialization */
+static int __devinit snd_audiodrive_pnp_init_main(int dev, struct pnp_dev *pdev,
+						  struct pnp_resource_table *cfg)
+{
+	int err;
+
+	pnp_init_resource_table(cfg);
+	if (port[dev] != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[0], port[dev], 16);
+	if (fm_port[dev] != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[1], fm_port[dev], 4);
+	if (mpu_port[dev] != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[2], mpu_port[dev], 2);
+	if (dma1[dev] != SNDRV_AUTO_DMA)
+		pnp_resource_change(&cfg->dma_resource[0], dma1[dev], 1);
+	if (dma2[dev] != SNDRV_AUTO_DMA)
+		pnp_resource_change(&cfg->dma_resource[1], dma2[dev], 1);
+	if (irq[dev] != SNDRV_AUTO_IRQ)
+		pnp_resource_change(&cfg->irq_resource[0], irq[dev], 1);
+	if (pnp_device_is_isapnp(pdev)) {
+		err = pnp_manual_config_dev(pdev, cfg, 0);
+		if (err < 0)
+			snd_printk(KERN_ERR PFX "PnP manual resources are invalid, using auto config\n");
+	}
+	err = pnp_activate_dev(pdev);
+	if (err < 0) {
+		snd_printk(KERN_ERR PFX "PnP configure failure (out of resources?)\n");
+		return -EBUSY;
+	}
+	/* ok. hack using Vendor-Defined Card-Level registers */
+	/* skip csn and logdev initialization - already done in isapnp_configure */
+	if (pnp_device_is_isapnp(pdev)) {
+		isapnp_cfg_begin(isapnp_card_number(pdev), isapnp_csn_number(pdev));
+		isapnp_write_byte(0x27, pnp_irq(pdev, 0));	/* Hardware Volume IRQ Number */
+		if (mpu_port[dev] != SNDRV_AUTO_PORT)
+			isapnp_write_byte(0x28, pnp_irq(pdev, 0)); /* MPU-401 IRQ Number */
+		isapnp_write_byte(0x72, pnp_irq(pdev, 0));	/* second IRQ */
+		isapnp_cfg_end();
+	}
+	port[dev] = pnp_port_start(pdev, 0);
+	fm_port[dev] = pnp_port_start(pdev, 1);
+	mpu_port[dev] = pnp_port_start(pdev, 2);
+	dma1[dev] = pnp_dma(pdev, 0);
+	dma2[dev] = pnp_dma(pdev, 1);
+	irq[dev] = pnp_irq(pdev, 0);
+	snd_printdd("PnP ES18xx: port=0x%lx, fm port=0x%lx, mpu port=0x%lx\n", port[dev], fm_port[dev], mpu_port[dev]);
+	snd_printdd("PnP ES18xx: dma1=%i, dma2=%i, irq=%i\n", dma1[dev], dma2[dev], irq[dev]);
+	return 0;
+}
+
+static int __devinit snd_audiodrive_pnp(int dev, struct snd_audiodrive *acard,
+					struct pnp_dev *pdev)
+{
+	struct pnp_resource_table * cfg = kmalloc(sizeof(struct pnp_resource_table), GFP_KERNEL);
+
+	if (!cfg)
+		return -ENOMEM;
+	acard->dev = pdev;
+	if (snd_audiodrive_pnp_init_main(dev, acard->dev, cfg) < 0) {
+		kfree(cfg);
+		return -EBUSY;
+	}
+	kfree(cfg);
+	return 0;
+}
 
 static struct pnp_card_device_id snd_audiodrive_pnpids[] = {
 	/* ESS 1868 (integrated on Compaq dual P-Pro motherboard and Genius 18PnP 3D) */
@@ -2061,13 +2134,11 @@
 
 MODULE_DEVICE_TABLE(pnp_card, snd_audiodrive_pnpids);
 
-static int __devinit snd_audiodrive_pnp(int dev, struct snd_audiodrive *acard,
+static int __devinit snd_audiodrive_pnpc(int dev, struct snd_audiodrive *acard,
 					struct pnp_card_link *card,
 					const struct pnp_card_device_id *id)
 {
-	struct pnp_dev *pdev;
 	struct pnp_resource_table * cfg = kmalloc(sizeof(struct pnp_resource_table), GFP_KERNEL);
-	int err;
 
 	if (!cfg)
 		return -ENOMEM;
@@ -2082,58 +2153,17 @@
 		return -EBUSY;
 	}
 	/* Control port initialization */
-	err = pnp_activate_dev(acard->devc);
-	if (err < 0) {
-		snd_printk(KERN_ERR PFX "PnP control configure failure (out of resources?)\n");
+	if (pnp_activate_dev(acard->devc) < 0) {
 		kfree(cfg);
+		snd_printk(KERN_ERR PFX "PnP control configure failure (out of resources?)\n");
 		return -EAGAIN;
 	}
 	snd_printdd("pnp: port=0x%llx\n",
 			(unsigned long long)pnp_port_start(acard->devc, 0));
-	/* PnP initialization */
-	pdev = acard->dev;
-	pnp_init_resource_table(cfg);
-	if (port[dev] != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[0], port[dev], 16);
-	if (fm_port[dev] != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[1], fm_port[dev], 4);
-	if (mpu_port[dev] != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[2], mpu_port[dev], 2);
-	if (dma1[dev] != SNDRV_AUTO_DMA)
-		pnp_resource_change(&cfg->dma_resource[0], dma1[dev], 1);
-	if (dma2[dev] != SNDRV_AUTO_DMA)
-		pnp_resource_change(&cfg->dma_resource[1], dma2[dev], 1);
-	if (irq[dev] != SNDRV_AUTO_IRQ)
-		pnp_resource_change(&cfg->irq_resource[0], irq[dev], 1);
-	err = pnp_manual_config_dev(pdev, cfg, 0);
-	if (err < 0)
-		snd_printk(KERN_ERR PFX "PnP manual resources are invalid, using auto config\n");
-	err = pnp_activate_dev(pdev);
-	if (err < 0) {
-		snd_printk(KERN_ERR PFX "PnP configure failure (out of resources?)\n");
+	if (snd_audiodrive_pnp_init_main(dev, acard->dev, cfg) < 0) {
 		kfree(cfg);
 		return -EBUSY;
 	}
-	/* ok. hack using Vendor-Defined Card-Level registers */
-	/* skip csn and logdev initialization - already done in isapnp_configure */
-	if (pnp_device_is_isapnp(pdev)) {
-		isapnp_cfg_begin(isapnp_card_number(pdev), isapnp_csn_number(pdev));
-		isapnp_write_byte(0x27, pnp_irq(pdev, 0));	/* Hardware Volume IRQ Number */
-		if (mpu_port[dev] != SNDRV_AUTO_PORT)
-			isapnp_write_byte(0x28, pnp_irq(pdev, 0)); /* MPU-401 IRQ Number */
-		isapnp_write_byte(0x72, pnp_irq(pdev, 0));	/* second IRQ */
-		isapnp_cfg_end();
-	} else {
-		snd_printk(KERN_ERR PFX "unable to install ISA PnP hack, expect malfunction\n");
-	}
-	port[dev] = pnp_port_start(pdev, 0);
-	fm_port[dev] = pnp_port_start(pdev, 1);
-	mpu_port[dev] = pnp_port_start(pdev, 2);
-	dma1[dev] = pnp_dma(pdev, 0);
-	dma2[dev] = pnp_dma(pdev, 1);
-	irq[dev] = pnp_irq(pdev, 0);
-	snd_printdd("PnP ES18xx: port=0x%lx, fm port=0x%lx, mpu port=0x%lx\n", port[dev], fm_port[dev], mpu_port[dev]);
-	snd_printdd("PnP ES18xx: dma1=%i, dma2=%i, irq=%i\n", dma1[dev], dma2[dev], irq[dev]);
 	kfree(cfg);
 	return 0;
 }
@@ -2302,7 +2332,69 @@
 #ifdef CONFIG_PNP
 static unsigned int __devinitdata es18xx_pnp_devices;
 
-static int __devinit snd_audiodrive_pnp_detect(struct pnp_card_link *pcard,
+static int __devinit snd_audiodrive_pnp_detect(struct pnp_dev *pdev,
+					    const struct pnp_device_id *id)
+{
+	static int dev;
+	int err;
+	struct snd_card *card;
+
+	if (pnp_device_is_isapnp(pdev))
+		return -ENOENT;	/* we have another procedure - card */
+	for (; dev < SNDRV_CARDS; dev++) {
+		if (enable[dev] && isapnp[dev])
+			break;
+	}
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+
+	card = snd_es18xx_card_new(dev);
+	if (! card)
+		return -ENOMEM;
+	if ((err = snd_audiodrive_pnp(dev, card->private_data, pdev)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	snd_card_set_dev(card, &pdev->dev);
+	if ((err = snd_audiodrive_probe(card, dev)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pnp_set_drvdata(pdev, card);
+	dev++;
+	es18xx_pnp_devices++;
+	return 0;
+}
+
+static void __devexit snd_audiodrive_pnp_remove(struct pnp_dev * pdev)
+{
+	snd_card_free(pnp_get_drvdata(pdev));
+	pnp_set_drvdata(pdev, NULL);
+}
+
+#ifdef CONFIG_PM
+static int snd_audiodrive_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)
+{
+	return snd_es18xx_suspend(pnp_get_drvdata(pdev), state);
+}
+static int snd_audiodrive_pnp_resume(struct pnp_dev *pdev)
+{
+	return snd_es18xx_resume(pnp_get_drvdata(pdev));
+}
+#endif
+
+static struct pnp_driver es18xx_pnp_driver = {
+	.name = "es18xx-pnpbios",
+	.id_table = snd_audiodrive_pnpbiosids,
+	.probe = snd_audiodrive_pnp_detect,
+	.remove = __devexit_p(snd_audiodrive_pnp_remove),
+#ifdef CONFIG_PM
+	.suspend = snd_audiodrive_pnp_suspend,
+	.resume = snd_audiodrive_pnp_resume,
+#endif
+};
+
+static int __devinit snd_audiodrive_pnpc_detect(struct pnp_card_link *pcard,
 					       const struct pnp_card_device_id *pid)
 {
 	static int dev;
@@ -2320,7 +2412,7 @@
 	if (! card)
 		return -ENOMEM;
 
-	if ((res = snd_audiodrive_pnp(dev, card->private_data, pcard, pid)) < 0) {
+	if ((res = snd_audiodrive_pnpc(dev, card->private_data, pcard, pid)) < 0) {
 		snd_card_free(card);
 		return res;
 	}
@@ -2336,19 +2428,19 @@
 	return 0;
 }
 
-static void __devexit snd_audiodrive_pnp_remove(struct pnp_card_link * pcard)
+static void __devexit snd_audiodrive_pnpc_remove(struct pnp_card_link * pcard)
 {
 	snd_card_free(pnp_get_card_drvdata(pcard));
 	pnp_set_card_drvdata(pcard, NULL);
 }
 
 #ifdef CONFIG_PM
-static int snd_audiodrive_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)
+static int snd_audiodrive_pnpc_suspend(struct pnp_card_link *pcard, pm_message_t state)
 {
 	return snd_es18xx_suspend(pnp_get_card_drvdata(pcard), state);
 }
 
-static int snd_audiodrive_pnp_resume(struct pnp_card_link *pcard)
+static int snd_audiodrive_pnpc_resume(struct pnp_card_link *pcard)
 {
 	return snd_es18xx_resume(pnp_get_card_drvdata(pcard));
 }
@@ -2359,11 +2451,11 @@
 	.flags = PNP_DRIVER_RES_DISABLE,
 	.name = "es18xx",
 	.id_table = snd_audiodrive_pnpids,
-	.probe = snd_audiodrive_pnp_detect,
-	.remove = __devexit_p(snd_audiodrive_pnp_remove),
+	.probe = snd_audiodrive_pnpc_detect,
+	.remove = __devexit_p(snd_audiodrive_pnpc_remove),
 #ifdef CONFIG_PM
-	.suspend	= snd_audiodrive_pnp_suspend,
-	.resume		= snd_audiodrive_pnp_resume,
+	.suspend	= snd_audiodrive_pnpc_suspend,
+	.resume		= snd_audiodrive_pnpc_resume,
 #endif
 };
 #endif /* CONFIG_PNP */
@@ -2373,8 +2465,10 @@
 	int i;
 
 #ifdef CONFIG_PNP
-	if (pnp_registered)
+	if (pnpc_registered)
 		pnp_unregister_card_driver(&es18xx_pnpc_driver);
+	if (pnp_registered)
+		pnp_unregister_driver(&es18xx_pnp_driver);
 #endif
 	for (i = 0; i < ARRAY_SIZE(platform_devices); ++i)
 		platform_device_unregister(platform_devices[i]);
@@ -2405,11 +2499,13 @@
 	}
 
 #ifdef CONFIG_PNP
-	err = pnp_register_card_driver(&es18xx_pnpc_driver);
-	if (!err) {
+	err = pnp_register_driver(&es18xx_pnp_driver);
+	if (!err)
 		pnp_registered = 1;
-		cards += es18xx_pnp_devices;
-	}
+	err = pnp_register_card_driver(&es18xx_pnpc_driver);
+	if (!err)
+		pnpc_registered = 1;
+	cards += es18xx_pnp_devices;
 #endif
 
 	if(!cards) {
--- linux-2.6.18.noarch/sound/isa/es1688/es1688_lib.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/es1688/es1688_lib.c	2007-06-05 17:43:16.000000000 -0400
@@ -479,7 +479,7 @@
 	return snd_es1688_trigger(chip, cmd, 0x0f);
 }
 
-static irqreturn_t snd_es1688_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_es1688_interrupt(int irq, void *dev_id)
 {
 	struct snd_es1688 *chip = dev_id;
 
--- linux-2.6.18.noarch/sound/isa/ad1816a/ad1816a_lib.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/ad1816a/ad1816a_lib.c	2007-06-05 17:42:52.000000000 -0400
@@ -24,6 +24,7 @@
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <sound/core.h>
+#include <sound/tlv.h>
 #include <sound/ad1816a.h>
 
 #include <asm/io.h>
@@ -314,7 +315,7 @@
 }
 
 
-static irqreturn_t snd_ad1816a_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_ad1816a_interrupt(int irq, void *dev_id)
 {
 	struct snd_ad1816a *chip = dev_id;
 	unsigned char status;
@@ -765,6 +766,13 @@
 	return change;
 }
 
+#define AD1816A_SINGLE_TLV(xname, reg, shift, mask, invert, xtlv)	\
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .info = snd_ad1816a_info_single, \
+  .get = snd_ad1816a_get_single, .put = snd_ad1816a_put_single, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \
+  .tlv = { .p = (xtlv) } }
 #define AD1816A_SINGLE(xname, reg, shift, mask, invert) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ad1816a_info_single, \
   .get = snd_ad1816a_get_single, .put = snd_ad1816a_put_single, \
@@ -822,6 +830,14 @@
 	return change;
 }
 
+#define AD1816A_DOUBLE_TLV(xname, reg, shift_left, shift_right, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .info = snd_ad1816a_info_double,		\
+  .get = snd_ad1816a_get_double, .put = snd_ad1816a_put_double, \
+  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24), \
+  .tlv = { .p = (xtlv) } }
+
 #define AD1816A_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_ad1816a_info_double, \
   .get = snd_ad1816a_get_double, .put = snd_ad1816a_put_double, \
@@ -890,28 +906,44 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_4bit, -4500, 300, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);
+
 static struct snd_kcontrol_new snd_ad1816a_controls[] __devinitdata = {
 AD1816A_DOUBLE("Master Playback Switch", AD1816A_MASTER_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("Master Playback Volume", AD1816A_MASTER_ATT, 8, 0, 31, 1),
+AD1816A_DOUBLE_TLV("Master Playback Volume", AD1816A_MASTER_ATT, 8, 0, 31, 1,
+		   db_scale_5bit),
 AD1816A_DOUBLE("PCM Playback Switch", AD1816A_VOICE_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("PCM Playback Volume", AD1816A_VOICE_ATT, 8, 0, 63, 1),
+AD1816A_DOUBLE_TLV("PCM Playback Volume", AD1816A_VOICE_ATT, 8, 0, 63, 1,
+		   db_scale_6bit),
 AD1816A_DOUBLE("Line Playback Switch", AD1816A_LINE_GAIN_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("Line Playback Volume", AD1816A_LINE_GAIN_ATT, 8, 0, 31, 1),
+AD1816A_DOUBLE_TLV("Line Playback Volume", AD1816A_LINE_GAIN_ATT, 8, 0, 31, 1,
+		   db_scale_5bit_12db_max),
 AD1816A_DOUBLE("CD Playback Switch", AD1816A_CD_GAIN_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("CD Playback Volume", AD1816A_CD_GAIN_ATT, 8, 0, 31, 1),
+AD1816A_DOUBLE_TLV("CD Playback Volume", AD1816A_CD_GAIN_ATT, 8, 0, 31, 1,
+		   db_scale_5bit_12db_max),
 AD1816A_DOUBLE("Synth Playback Switch", AD1816A_SYNTH_GAIN_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("Synth Playback Volume", AD1816A_SYNTH_GAIN_ATT, 8, 0, 31, 1),
+AD1816A_DOUBLE_TLV("Synth Playback Volume", AD1816A_SYNTH_GAIN_ATT, 8, 0, 31, 1,
+		   db_scale_5bit_12db_max),
 AD1816A_DOUBLE("FM Playback Switch", AD1816A_FM_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("FM Playback Volume", AD1816A_FM_ATT, 8, 0, 63, 1),
+AD1816A_DOUBLE_TLV("FM Playback Volume", AD1816A_FM_ATT, 8, 0, 63, 1,
+		   db_scale_6bit),
 AD1816A_SINGLE("Mic Playback Switch", AD1816A_MIC_GAIN_ATT, 15, 1, 1),
-AD1816A_SINGLE("Mic Playback Volume", AD1816A_MIC_GAIN_ATT, 8, 31, 1),
+AD1816A_SINGLE_TLV("Mic Playback Volume", AD1816A_MIC_GAIN_ATT, 8, 31, 1,
+		   db_scale_5bit_12db_max),
 AD1816A_SINGLE("Mic Boost", AD1816A_MIC_GAIN_ATT, 14, 1, 0),
 AD1816A_DOUBLE("Video Playback Switch", AD1816A_VID_GAIN_ATT, 15, 7, 1, 1),
-AD1816A_DOUBLE("Video Playback Volume", AD1816A_VID_GAIN_ATT, 8, 0, 31, 1),
+AD1816A_DOUBLE_TLV("Video Playback Volume", AD1816A_VID_GAIN_ATT, 8, 0, 31, 1,
+		   db_scale_5bit_12db_max),
 AD1816A_SINGLE("Phone Capture Switch", AD1816A_PHONE_IN_GAIN_ATT, 15, 1, 1),
-AD1816A_SINGLE("Phone Capture Volume", AD1816A_PHONE_IN_GAIN_ATT, 0, 15, 1),
+AD1816A_SINGLE_TLV("Phone Capture Volume", AD1816A_PHONE_IN_GAIN_ATT, 0, 15, 1,
+		   db_scale_4bit),
 AD1816A_SINGLE("Phone Playback Switch", AD1816A_PHONE_OUT_ATT, 7, 1, 1),
-AD1816A_SINGLE("Phone Playback Volume", AD1816A_PHONE_OUT_ATT, 0, 31, 1),
+AD1816A_SINGLE_TLV("Phone Playback Volume", AD1816A_PHONE_OUT_ATT, 0, 31, 1,
+		   db_scale_5bit),
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Capture Source",
@@ -920,7 +952,8 @@
 	.put = snd_ad1816a_put_mux,
 },
 AD1816A_DOUBLE("Capture Switch", AD1816A_ADC_PGA, 15, 7, 1, 1),
-AD1816A_DOUBLE("Capture Volume", AD1816A_ADC_PGA, 8, 0, 15, 0),
+AD1816A_DOUBLE_TLV("Capture Volume", AD1816A_ADC_PGA, 8, 0, 15, 0,
+		   db_scale_rec_gain),
 AD1816A_SINGLE("3D Control - Switch", AD1816A_3D_PHAT_CTRL, 15, 1, 1),
 AD1816A_SINGLE("3D Control - Level", AD1816A_3D_PHAT_CTRL, 0, 15, 0),
 };
--- linux-2.6.18.noarch/sound/isa/ad1816a/ad1816a.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/isa/ad1816a/ad1816a.c	2007-06-05 17:42:52.000000000 -0400
@@ -120,6 +120,8 @@
 	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
 	int err;
 
+	if (!cfg)
+		return -ENOMEM;
 	acard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
 	if (acard->dev == NULL) {
 		kfree(cfg);
--- linux-2.6.18.noarch/sound/oss/ymfpci.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ymfpci.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,361 +0,0 @@
-#ifndef __YMFPCI_H
-#define __YMFPCI_H
-
-/*
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
- *  Definitions for Yahama YMF724/740/744/754 chips
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-#include <linux/config.h>
-#include <linux/mutex.h>
-
-/*
- *  Direct registers
- */
-
-/* #define YMFREG(codec, reg)		(codec->port + YDSXGR_##reg) */
-
-#define	YDSXGR_INTFLAG			0x0004
-#define	YDSXGR_ACTIVITY			0x0006
-#define	YDSXGR_GLOBALCTRL		0x0008
-#define	YDSXGR_ZVCTRL			0x000A
-#define	YDSXGR_TIMERCTRL		0x0010
-#define	YDSXGR_TIMERCTRL_TEN		 0x0001
-#define	YDSXGR_TIMERCTRL_TIEN		 0x0002
-#define	YDSXGR_TIMERCOUNT		0x0012
-#define	YDSXGR_SPDIFOUTCTRL		0x0018
-#define	YDSXGR_SPDIFOUTSTATUS		0x001C
-#define	YDSXGR_EEPROMCTRL		0x0020
-#define	YDSXGR_SPDIFINCTRL		0x0034
-#define	YDSXGR_SPDIFINSTATUS		0x0038
-#define	YDSXGR_DSPPROGRAMDL		0x0048
-#define	YDSXGR_DLCNTRL			0x004C
-#define	YDSXGR_GPIOININTFLAG		0x0050
-#define	YDSXGR_GPIOININTENABLE		0x0052
-#define	YDSXGR_GPIOINSTATUS		0x0054
-#define	YDSXGR_GPIOOUTCTRL		0x0056
-#define	YDSXGR_GPIOFUNCENABLE		0x0058
-#define	YDSXGR_GPIOTYPECONFIG		0x005A
-#define	YDSXGR_AC97CMDDATA		0x0060
-#define	YDSXGR_AC97CMDADR		0x0062
-#define	YDSXGR_PRISTATUSDATA		0x0064
-#define	YDSXGR_PRISTATUSADR		0x0066
-#define	YDSXGR_SECSTATUSDATA		0x0068
-#define	YDSXGR_SECSTATUSADR		0x006A
-#define	YDSXGR_SECCONFIG		0x0070
-#define	YDSXGR_LEGACYOUTVOL		0x0080
-#define	YDSXGR_LEGACYOUTVOLL		0x0080
-#define	YDSXGR_LEGACYOUTVOLR		0x0082
-#define	YDSXGR_NATIVEDACOUTVOL		0x0084
-#define	YDSXGR_NATIVEDACOUTVOLL		0x0084
-#define	YDSXGR_NATIVEDACOUTVOLR		0x0086
-#define	YDSXGR_SPDIFOUTVOL		0x0088
-#define	YDSXGR_SPDIFOUTVOLL		0x0088
-#define	YDSXGR_SPDIFOUTVOLR		0x008A
-#define	YDSXGR_AC3OUTVOL		0x008C
-#define	YDSXGR_AC3OUTVOLL		0x008C
-#define	YDSXGR_AC3OUTVOLR		0x008E
-#define	YDSXGR_PRIADCOUTVOL		0x0090
-#define	YDSXGR_PRIADCOUTVOLL		0x0090
-#define	YDSXGR_PRIADCOUTVOLR		0x0092
-#define	YDSXGR_LEGACYLOOPVOL		0x0094
-#define	YDSXGR_LEGACYLOOPVOLL		0x0094
-#define	YDSXGR_LEGACYLOOPVOLR		0x0096
-#define	YDSXGR_NATIVEDACLOOPVOL		0x0098
-#define	YDSXGR_NATIVEDACLOOPVOLL	0x0098
-#define	YDSXGR_NATIVEDACLOOPVOLR	0x009A
-#define	YDSXGR_SPDIFLOOPVOL		0x009C
-#define	YDSXGR_SPDIFLOOPVOLL		0x009E
-#define	YDSXGR_SPDIFLOOPVOLR		0x009E
-#define	YDSXGR_AC3LOOPVOL		0x00A0
-#define	YDSXGR_AC3LOOPVOLL		0x00A0
-#define	YDSXGR_AC3LOOPVOLR		0x00A2
-#define	YDSXGR_PRIADCLOOPVOL		0x00A4
-#define	YDSXGR_PRIADCLOOPVOLL		0x00A4
-#define	YDSXGR_PRIADCLOOPVOLR		0x00A6
-#define	YDSXGR_NATIVEADCINVOL		0x00A8
-#define	YDSXGR_NATIVEADCINVOLL		0x00A8
-#define	YDSXGR_NATIVEADCINVOLR		0x00AA
-#define	YDSXGR_NATIVEDACINVOL		0x00AC
-#define	YDSXGR_NATIVEDACINVOLL		0x00AC
-#define	YDSXGR_NATIVEDACINVOLR		0x00AE
-#define	YDSXGR_BUF441OUTVOL		0x00B0
-#define	YDSXGR_BUF441OUTVOLL		0x00B0
-#define	YDSXGR_BUF441OUTVOLR		0x00B2
-#define	YDSXGR_BUF441LOOPVOL		0x00B4
-#define	YDSXGR_BUF441LOOPVOLL		0x00B4
-#define	YDSXGR_BUF441LOOPVOLR		0x00B6
-#define	YDSXGR_SPDIFOUTVOL2		0x00B8
-#define	YDSXGR_SPDIFOUTVOL2L		0x00B8
-#define	YDSXGR_SPDIFOUTVOL2R		0x00BA
-#define	YDSXGR_SPDIFLOOPVOL2		0x00BC
-#define	YDSXGR_SPDIFLOOPVOL2L		0x00BC
-#define	YDSXGR_SPDIFLOOPVOL2R		0x00BE
-#define	YDSXGR_ADCSLOTSR		0x00C0
-#define	YDSXGR_RECSLOTSR		0x00C4
-#define	YDSXGR_ADCFORMAT		0x00C8
-#define	YDSXGR_RECFORMAT		0x00CC
-#define	YDSXGR_P44SLOTSR		0x00D0
-#define	YDSXGR_STATUS			0x0100
-#define	YDSXGR_CTRLSELECT		0x0104
-#define	YDSXGR_MODE			0x0108
-#define	YDSXGR_SAMPLECOUNT		0x010C
-#define	YDSXGR_NUMOFSAMPLES		0x0110
-#define	YDSXGR_CONFIG			0x0114
-#define	YDSXGR_PLAYCTRLSIZE		0x0140
-#define	YDSXGR_RECCTRLSIZE		0x0144
-#define	YDSXGR_EFFCTRLSIZE		0x0148
-#define	YDSXGR_WORKSIZE			0x014C
-#define	YDSXGR_MAPOFREC			0x0150
-#define	YDSXGR_MAPOFEFFECT		0x0154
-#define	YDSXGR_PLAYCTRLBASE		0x0158
-#define	YDSXGR_RECCTRLBASE		0x015C
-#define	YDSXGR_EFFCTRLBASE		0x0160
-#define	YDSXGR_WORKBASE			0x0164
-#define	YDSXGR_DSPINSTRAM		0x1000
-#define	YDSXGR_CTRLINSTRAM		0x4000
-
-#define YDSXG_AC97READCMD		0x8000
-#define YDSXG_AC97WRITECMD		0x0000
-
-#define PCIR_LEGCTRL			0x40
-#define PCIR_ELEGCTRL			0x42
-#define PCIR_DSXGCTRL			0x48
-#define PCIR_DSXPWRCTRL1		0x4a
-#define PCIR_DSXPWRCTRL2		0x4e
-#define PCIR_OPLADR			0x60
-#define PCIR_SBADR			0x62
-#define PCIR_MPUADR			0x64
-
-#define YDSXG_DSPLENGTH			0x0080
-#define YDSXG_CTRLLENGTH		0x3000
-
-#define YDSXG_DEFAULT_WORK_SIZE		0x0400
-
-#define YDSXG_PLAYBACK_VOICES		64
-#define YDSXG_CAPTURE_VOICES		2
-#define YDSXG_EFFECT_VOICES		5
-
-/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
-#define NR_AC97		2
-
-#define YMF_SAMPF			256	/* Samples per frame @48000 */
-
-/*
- * The slot/voice control bank (2 of these per voice)
- */
-
-typedef struct stru_ymfpci_playback_bank {
-	u32 format;
-	u32 loop_default;
-	u32 base;			/* 32-bit address */
-	u32 loop_start;			/* 32-bit offset */
-	u32 loop_end;			/* 32-bit offset */
-	u32 loop_frac;			/* 8-bit fraction - loop_start */
-	u32 delta_end;			/* pitch delta end */
-	u32 lpfK_end;
-	u32 eg_gain_end;
-	u32 left_gain_end;
-	u32 right_gain_end;
-	u32 eff1_gain_end;
-	u32 eff2_gain_end;
-	u32 eff3_gain_end;
-	u32 lpfQ;
-	u32 status;		/* P3: Always 0 for some reason. */
-	u32 num_of_frames;
-	u32 loop_count;
-	u32 start;		/* P3: J. reads this to know where chip is. */
-	u32 start_frac;
-	u32 delta;
-	u32 lpfK;
-	u32 eg_gain;
-	u32 left_gain;
-	u32 right_gain;
-	u32 eff1_gain;
-	u32 eff2_gain;
-	u32 eff3_gain;
-	u32 lpfD1;
-	u32 lpfD2;
-} ymfpci_playback_bank_t;
-
-typedef struct stru_ymfpci_capture_bank {
-	u32 base;			/* 32-bit address (aligned at 4) */
-	u32 loop_end;			/* size in BYTES (aligned at 4) */
-	u32 start;			/* 32-bit offset */
-	u32 num_of_loops;		/* counter */
-} ymfpci_capture_bank_t;
-
-typedef struct stru_ymfpci_effect_bank {
-	u32 base;			/* 32-bit address */
-	u32 loop_end;			/* 32-bit offset */
-	u32 start;			/* 32-bit offset */
-	u32 temp;
-} ymfpci_effect_bank_t;
-
-typedef struct ymf_voice ymfpci_voice_t;
-/*
- * Throughout the code Yaroslav names YMF unit pointer "codec"
- * even though it does not correspond to any codec. Must be historic.
- * We replace it with "unit" over time.
- * AC97 parts use "codec" to denote a codec, naturally.
- */
-typedef struct ymf_unit ymfpci_t;
-
-typedef enum {
-	YMFPCI_PCM,
-	YMFPCI_SYNTH,
-	YMFPCI_MIDI
-} ymfpci_voice_type_t;
-
-struct ymf_voice {
-	// ymfpci_t *codec;
-	int number;
-	char use, pcm, synth, midi;	// bool
-	ymfpci_playback_bank_t *bank;
-	struct ymf_pcm *ypcm;
-	dma_addr_t bank_ba;
-};
-
-struct ymf_capture {
-	// struct ymf_unit *unit;
-	int use;
-	ymfpci_capture_bank_t *bank;
-	struct ymf_pcm *ypcm;
-};
-
-struct ymf_unit {
-	u8 rev;				/* PCI revision */
-	void __iomem *reg_area_virt;
-	void *dma_area_va;
-	dma_addr_t dma_area_ba;
-	unsigned int dma_area_size;
-
-	dma_addr_t bank_base_capture;
-	dma_addr_t bank_base_effect;
-	dma_addr_t work_base;
-	unsigned int work_size;
-
-	u32 *ctrl_playback;
-	dma_addr_t ctrl_playback_ba;
-	ymfpci_playback_bank_t *bank_playback[YDSXG_PLAYBACK_VOICES][2];
-	ymfpci_capture_bank_t *bank_capture[YDSXG_CAPTURE_VOICES][2];
-	ymfpci_effect_bank_t *bank_effect[YDSXG_EFFECT_VOICES][2];
-
-	int start_count;
-	int suspended;
-
-	u32 active_bank;
-	struct ymf_voice voices[YDSXG_PLAYBACK_VOICES];
-	struct ymf_capture capture[YDSXG_CAPTURE_VOICES];
-
-	struct ac97_codec *ac97_codec[NR_AC97];
-	u16 ac97_features;
-
-	struct pci_dev *pci;
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-	/* legacy hardware resources */
-	unsigned int iosynth, iomidi;
-	struct address_info opl3_data, mpu_data;
-#endif
-
-	spinlock_t reg_lock;
-	spinlock_t voice_lock;
-	spinlock_t ac97_lock;
-
-	/* soundcore stuff */
-	int dev_audio;
-	struct mutex open_mutex;
-
-	struct list_head ymf_devs;
-	struct list_head states;	/* List of states for this unit */
-};
-
-struct ymf_dmabuf {
-	dma_addr_t dma_addr;
-	void *rawbuf;
-	unsigned buforder;
-
-	/* OSS buffer management stuff */
-	unsigned numfrag;
-	unsigned fragshift;
-
-	/* our buffer acts like a circular ring */
-	unsigned hwptr;		/* where dma last started */
-	unsigned swptr;		/* where driver last clear/filled */
-	int count;		/* fill count */
-	unsigned total_bytes;	/* total bytes dmaed by hardware */
-
-	wait_queue_head_t wait;	/* put process on wait queue when no more space in buffer */
-
-	/* redundant, but makes calculations easier */
-	unsigned fragsize;
-	unsigned dmasize;	/* Total rawbuf[] size */
-
-	/* OSS stuff */
-	unsigned mapped:1;
-	unsigned ready:1;
-	unsigned ossfragshift;
-	int ossmaxfrags;
-	unsigned subdivision;
-};
-
-struct ymf_pcm_format {
-	int format;			/* OSS format */
-	int rate;			/* rate in Hz */
-	int voices;			/* number of voices */
-	int shift;			/* redundant, computed from the above */
-};
-
-typedef enum {
-	PLAYBACK_VOICE,
-	CAPTURE_REC,
-	CAPTURE_AC97,
-	EFFECT_DRY_LEFT,
-	EFFECT_DRY_RIGHT,
-	EFFECT_EFF1,
-	EFFECT_EFF2,
-	EFFECT_EFF3
-} ymfpci_pcm_type_t;
-
-/* This is variant record, but we hate unions. Little waste on pointers []. */
-struct ymf_pcm {
-	ymfpci_pcm_type_t type;
-	struct ymf_state *state;
-
-	ymfpci_voice_t *voices[2];
-	int capture_bank_number;
-
-	struct ymf_dmabuf dmabuf;
-	int running;
-	int spdif;
-};
-
-/*
- * "Software" or virtual channel, an instance of opened /dev/dsp.
- * It may have two physical channels (pcms) for duplex operations.
- */
-
-struct ymf_state {
-	struct list_head chain;
-	struct ymf_unit *unit;			/* backpointer */
-	struct ymf_pcm rpcm, wpcm;
-	struct ymf_pcm_format format;
-};
-
-#endif				/* __YMFPCI_H */
--- linux-2.6.18.noarch/sound/oss/sequencer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sequencer.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sequencer.c
+ * sound/oss/sequencer.c
  *
  * The sequencer personality manager.
  */
@@ -16,7 +16,6 @@
  */
 #include <linux/kmod.h>
 #include <linux/spinlock.h>
-#define SEQUENCER_C
 #include "sound_config.h"
 
 #include "midi_ctrl.h"
@@ -157,6 +156,7 @@
 	wake_up(&midi_sleeper);
 	spin_unlock_irqrestore(&lock,flags);
 }
+EXPORT_SYMBOL(seq_copy_to_input);
 
 static void sequencer_midi_input(int dev, unsigned char data)
 {
@@ -206,6 +206,7 @@
 	}
 	seq_copy_to_input(event_rec, len);
 }
+EXPORT_SYMBOL(seq_input_event);
 
 int sequencer_write(int dev, struct file *file, const char __user *buf, int count)
 {
@@ -1554,6 +1555,7 @@
 {
 	seq_startplay();
 }
+EXPORT_SYMBOL(sequencer_timer);
 
 int note_to_freq(int note_num)
 {
@@ -1587,6 +1589,7 @@
 
 	return note_freq;
 }
+EXPORT_SYMBOL(note_to_freq);
 
 unsigned long compute_finetune(unsigned long base_freq, int bend, int range,
 		 int vibrato_cents)
@@ -1640,19 +1643,12 @@
 	else
 		return (base_freq * amount) / 10000;	/* Bend up */
 }
-
+EXPORT_SYMBOL(compute_finetune);
 
 void sequencer_init(void)
 {
-	/* drag in sequencer_syms.o */
-	{
-		extern char sequencer_syms_symbol;
-		sequencer_syms_symbol = 0;
-	}
-
 	if (sequencer_ok)
 		return;
-	MIDIbuf_init();
 	queue = (unsigned char *)vmalloc(SEQ_MAX_QUEUE * EV_SZ);
 	if (queue == NULL)
 	{
@@ -1668,6 +1664,7 @@
 	}
 	sequencer_ok = 1;
 }
+EXPORT_SYMBOL(sequencer_init);
 
 void sequencer_unload(void)
 {
--- linux-2.6.18.noarch/sound/oss/yss225.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/yss225.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,319 +0,0 @@
-#include <linux/init.h>
-
-unsigned char page_zero[] __initdata = {
-0x01, 0x7c, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x00,
-0x11, 0x00, 0x20, 0x00, 0x32, 0x00, 0x40, 0x00, 0x13, 0x00, 0x00,
-0x00, 0x14, 0x02, 0x76, 0x00, 0x60, 0x00, 0x80, 0x02, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x19,
-0x01, 0x1a, 0x01, 0x20, 0x01, 0x40, 0x01, 0x17, 0x00, 0x00, 0x01,
-0x80, 0x01, 0x20, 0x00, 0x10, 0x01, 0xa0, 0x03, 0xd1, 0x00, 0x00,
-0x01, 0xf2, 0x02, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0xf4, 0x02,
-0xe0, 0x00, 0x15, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17,
-0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x50, 0x00, 0x00, 0x00,
-0x40, 0x00, 0x00, 0x00, 0x71, 0x02, 0x00, 0x00, 0x60, 0x00, 0x00,
-0x00, 0x92, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xb3, 0x02,
-0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x40,
-0x00, 0x80, 0x00, 0xf5, 0x00, 0x20, 0x00, 0x70, 0x00, 0xa0, 0x02,
-0x11, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
-0x02, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x17, 0x00, 0x1b, 0x00,
-0x1d, 0x02, 0xdf
-};    
-
-unsigned char page_one[] __initdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x19, 0x00,
-0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xd8, 0x00, 0x00,
-0x02, 0x20, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x01,
-0xc0, 0x01, 0xfa, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x02, 0x60,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x02, 0x80, 0x00,
-0x00, 0x02, 0xfb, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x1b, 0x02, 0xd7,
-0x00, 0x00, 0x02, 0xf7, 0x03, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00,
-0x1c, 0x03, 0x3c, 0x00, 0x00, 0x03, 0x3f, 0x00, 0x00, 0x03, 0xc0,
-0x00, 0x00, 0x03, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5d, 0x00,
-0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0x7d, 0x00, 0x00, 0x03, 0xc0,
-0x00, 0x00, 0x03, 0x9e, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03,
-0xbe, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
-0xdb, 0x00, 0x00, 0x02, 0xdb, 0x00, 0x00, 0x02, 0xe0, 0x00, 0x00,
-0x02, 0xfb, 0x00, 0x00, 0x02, 0xc0, 0x02, 0x40, 0x02, 0xfb, 0x02,
-0x60, 0x00, 0x1b
-};
-
-unsigned char page_two[] __initdata = {
-0xc4, 0x00, 0x44, 0x07, 0x44, 0x00, 0x40, 0x25, 0x01, 0x06, 0xc4,
-0x07, 0x40, 0x25, 0x01, 0x00, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x07,
-0x05, 0x05, 0x05, 0x04, 0x07, 0x05, 0x04, 0x07, 0x05, 0x44, 0x46,
-0x44, 0x46, 0x46, 0x07, 0x05, 0x44, 0x46, 0x05, 0x46, 0x05, 0x46,
-0x05, 0x46, 0x05, 0x44, 0x46, 0x05, 0x07, 0x44, 0x46, 0x05, 0x07,
-0x44, 0x46, 0x05, 0x07, 0x44, 0x46, 0x05, 0x07, 0x44, 0x05, 0x05,
-0x05, 0x44, 0x05, 0x05, 0x05, 0x46, 0x05, 0x46, 0x05, 0x46, 0x05,
-0x46, 0x05, 0x46, 0x07, 0x46, 0x07, 0x44
-};
-
-unsigned char page_three[] __initdata = {
-0x07, 0x40, 0x00, 0x00, 0x00, 0x47, 0x00, 0x40, 0x00, 0x40, 0x06,
-0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
-0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00,
-0x60, 0x00, 0x70, 0x00, 0x40, 0x00, 0x40, 0x00, 0x42, 0x00, 0x40,
-0x00, 0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
-0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-0x00, 0x42, 0x00, 0x40, 0x00, 0x42, 0x00, 0x02, 0x00, 0x02, 0x00,
-0x02, 0x00, 0x42, 0x00, 0xc0, 0x00, 0x40
-};
-
-unsigned char page_four[] __initdata = {
-0x63, 0x03, 0x26, 0x02, 0x2c, 0x00, 0x24, 0x00, 0x2e, 0x02, 0x02,
-0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
-0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
-0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x60, 0x00,
-0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x60,
-0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00, 0x60, 0x00, 0x20, 0x00,
-0x20, 0x00, 0x22, 0x02, 0x22, 0x02, 0x20, 0x00, 0x60, 0x00, 0x22,
-0x02, 0x62, 0x02, 0x20, 0x01, 0x21, 0x01
-};
-
-unsigned char page_six[] __initdata = {
-0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00,
-0x00, 0x08, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x0e,
-0x00, 0x00, 0x10, 0x00, 0x00, 0x12, 0x00, 0x00, 0x14, 0x00, 0x00,
-0x16, 0x00, 0x00, 0x18, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x1c, 0x00,
-0x00, 0x1e, 0x00, 0x00, 0x20, 0x00, 0x00, 0x22, 0x00, 0x00, 0x24,
-0x00, 0x00, 0x26, 0x00, 0x00, 0x28, 0x00, 0x00, 0x2a, 0x00, 0x00,
-0x2c, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x30, 0x00, 0x00, 0x32, 0x00,
-0x00, 0x34, 0x00, 0x00, 0x36, 0x00, 0x00, 0x38, 0x00, 0x00, 0x3a,
-0x00, 0x00, 0x3c, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x40, 0x00, 0x00,
-0x42, 0x03, 0x00, 0x44, 0x01, 0x00, 0x46, 0x0a, 0x21, 0x48, 0x0d,
-0x23, 0x4a, 0x23, 0x1b, 0x4c, 0x37, 0x8f, 0x4e, 0x45, 0x77, 0x50,
-0x52, 0xe2, 0x52, 0x1c, 0x92, 0x54, 0x1c, 0x52, 0x56, 0x07, 0x00,
-0x58, 0x2f, 0xc6, 0x5a, 0x0b, 0x00, 0x5c, 0x30, 0x06, 0x5e, 0x17,
-0x00, 0x60, 0x3d, 0xda, 0x62, 0x29, 0x00, 0x64, 0x3e, 0x41, 0x66,
-0x39, 0x00, 0x68, 0x4c, 0x48, 0x6a, 0x49, 0x00, 0x6c, 0x4c, 0x6c,
-0x6e, 0x11, 0xd2, 0x70, 0x16, 0x0c, 0x72, 0x00, 0x00, 0x74, 0x00,
-0x80, 0x76, 0x0f, 0x00, 0x78, 0x00, 0x80, 0x7a, 0x13, 0x00, 0x7c,
-0x80, 0x00, 0x7e, 0x80, 0x80
-};
-
-unsigned char page_seven[] __initdata = {
-0x0f, 0xff, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
-0x08, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f,
-0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x0f, 0xff,
-0x0f, 0xff, 0x0f, 0xff, 0x02, 0xe9, 0x06, 0x8c, 0x06, 0x8c, 0x0f,
-0xff, 0x1a, 0x75, 0x0d, 0x8b, 0x04, 0xe9, 0x0b, 0x16, 0x1a, 0x38,
-0x0d, 0xc8, 0x04, 0x6f, 0x0b, 0x91, 0x0f, 0xff, 0x06, 0x40, 0x06,
-0x40, 0x02, 0x8f, 0x0f, 0xff, 0x06, 0x62, 0x06, 0x62, 0x02, 0x7b,
-0x0f, 0xff, 0x06, 0x97, 0x06, 0x97, 0x02, 0x52, 0x0f, 0xff, 0x06,
-0xf6, 0x06, 0xf6, 0x02, 0x19, 0x05, 0x55, 0x05, 0x55, 0x05, 0x55,
-0x05, 0x55, 0x05, 0x55, 0x05, 0x55, 0x05, 0x55, 0x05, 0x55, 0x14,
-0xda, 0x0d, 0x93, 0x04, 0xda, 0x05, 0x93, 0x14, 0xda, 0x0d, 0x93,
-0x04, 0xda, 0x05, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x02, 0x00
-};
-
-unsigned char page_zero_v2[] __initdata = {
-0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-unsigned char page_one_v2[] __initdata = {
-0x01, 0xc0, 0x01, 0xfa, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-unsigned char page_two_v2[] __initdata = {
-0x46, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00
-};
-unsigned char page_three_v2[] __initdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00
-};
-unsigned char page_four_v2[] __initdata = {
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00
-};
-
-unsigned char page_seven_v2[] __initdata = {
-0x0f, 0xff, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-unsigned char mod_v2[] __initdata = {
-0x01, 0x00, 0x02, 0x00, 0x01, 0x01, 0x02, 0x00, 0x01, 0x02, 0x02,
-0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x04, 0x02, 0x00, 0x01, 0x05,
-0x02, 0x00, 0x01, 0x06, 0x02, 0x00, 0x01, 0x07, 0x02, 0x00, 0xb0,
-0x20, 0xb1, 0x20, 0xb2, 0x20, 0xb3, 0x20, 0xb4, 0x20, 0xb5, 0x20,
-0xb6, 0x20, 0xb7, 0x20, 0xf0, 0x20, 0xf1, 0x20, 0xf2, 0x20, 0xf3,
-0x20, 0xf4, 0x20, 0xf5, 0x20, 0xf6, 0x20, 0xf7, 0x20, 0x10, 0xff,
-0x11, 0xff, 0x12, 0xff, 0x13, 0xff, 0x14, 0xff, 0x15, 0xff, 0x16,
-0xff, 0x17, 0xff, 0x20, 0xff, 0x21, 0xff, 0x22, 0xff, 0x23, 0xff,
-0x24, 0xff, 0x25, 0xff, 0x26, 0xff, 0x27, 0xff, 0x30, 0x00, 0x31,
-0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00,
-0x37, 0x00, 0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44,
-0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x50, 0x00, 0x51, 0x00,
-0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57,
-0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x64, 0x00,
-0x65, 0x00, 0x66, 0x00, 0x67, 0x00, 0x70, 0xc0, 0x71, 0xc0, 0x72,
-0xc0, 0x73, 0xc0, 0x74, 0xc0, 0x75, 0xc0, 0x76, 0xc0, 0x77, 0xc0,
-0x80, 0x00, 0x81, 0x00, 0x82, 0x00, 0x83, 0x00, 0x84, 0x00, 0x85,
-0x00, 0x86, 0x00, 0x87, 0x00, 0x90, 0x00, 0x91, 0x00, 0x92, 0x00,
-0x93, 0x00, 0x94, 0x00, 0x95, 0x00, 0x96, 0x00, 0x97, 0x00, 0xa0,
-0x00, 0xa1, 0x00, 0xa2, 0x00, 0xa3, 0x00, 0xa4, 0x00, 0xa5, 0x00,
-0xa6, 0x00, 0xa7, 0x00, 0xc0, 0x00, 0xc1, 0x00, 0xc2, 0x00, 0xc3,
-0x00, 0xc4, 0x00, 0xc5, 0x00, 0xc6, 0x00, 0xc7, 0x00, 0xd0, 0x00,
-0xd1, 0x00, 0xd2, 0x00, 0xd3, 0x00, 0xd4, 0x00, 0xd5, 0x00, 0xd6,
-0x00, 0xd7, 0x00, 0xe0, 0x00, 0xe1, 0x00, 0xe2, 0x00, 0xe3, 0x00,
-0xe4, 0x00, 0xe5, 0x00, 0xe6, 0x00, 0xe7, 0x00, 0x01, 0x00, 0x02,
-0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x03,
-0x02, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x05, 0x02, 0x01, 0x01,
-0x06, 0x02, 0x01, 0x01, 0x07, 0x02, 0x01
-};
-unsigned char coefficients[] __initdata = {
-0x07, 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x00, 0x4b, 0x03,
-0x11, 0x00, 0x4d, 0x01, 0x32, 0x07, 0x46, 0x00, 0x00, 0x07, 0x49,
-0x00, 0x00, 0x07, 0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x01,
-0x40, 0x02, 0x40, 0x01, 0x41, 0x02, 0x60, 0x07, 0x40, 0x00, 0x00,
-0x07, 0x41, 0x00, 0x00, 0x07, 0x47, 0x00, 0x00, 0x07, 0x4a, 0x00,
-0x00, 0x00, 0x47, 0x01, 0x00, 0x00, 0x4a, 0x01, 0x20, 0x07, 0x47,
-0x00, 0x00, 0x07, 0x4a, 0x00, 0x00, 0x07, 0x7c, 0x00, 0x00, 0x07,
-0x7e, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1c, 0x07, 0x7c, 0x00, 0x00,
-0x07, 0x7e, 0x00, 0x00, 0x07, 0x44, 0x00, 0x00, 0x00, 0x44, 0x01,
-0x00, 0x07, 0x44, 0x00, 0x00, 0x07, 0x42, 0x00, 0x00, 0x07, 0x43,
-0x00, 0x00, 0x00, 0x42, 0x01, 0x1a, 0x00, 0x43, 0x01, 0x20, 0x07,
-0x42, 0x00, 0x00, 0x07, 0x43, 0x00, 0x00, 0x07, 0x40, 0x00, 0x00,
-0x07, 0x41, 0x00, 0x00, 0x01, 0x40, 0x02, 0x40, 0x01, 0x41, 0x02,
-0x60, 0x07, 0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x07, 0x44,
-0x0f, 0xff, 0x07, 0x42, 0x00, 0x00, 0x07, 0x43, 0x00, 0x00, 0x07,
-0x40, 0x00, 0x00, 0x07, 0x41, 0x00, 0x00, 0x07, 0x51, 0x06, 0x40,
-0x07, 0x50, 0x06, 0x40, 0x07, 0x4f, 0x03, 0x81, 0x07, 0x53, 0x1a,
-0x76, 0x07, 0x54, 0x0d, 0x8b, 0x07, 0x55, 0x04, 0xe9, 0x07, 0x56,
-0x0b, 0x17, 0x07, 0x57, 0x1a, 0x38, 0x07, 0x58, 0x0d, 0xc9, 0x07,
-0x59, 0x04, 0x6f, 0x07, 0x5a, 0x0b, 0x91, 0x07, 0x73, 0x14, 0xda,
-0x07, 0x74, 0x0d, 0x93, 0x07, 0x75, 0x04, 0xd9, 0x07, 0x76, 0x05,
-0x93, 0x07, 0x77, 0x14, 0xda, 0x07, 0x78, 0x0d, 0x93, 0x07, 0x79,
-0x04, 0xd9, 0x07, 0x7a, 0x05, 0x93, 0x07, 0x5e, 0x03, 0x68, 0x07,
-0x5c, 0x04, 0x31, 0x07, 0x5d, 0x04, 0x31, 0x07, 0x62, 0x03, 0x52,
-0x07, 0x60, 0x04, 0x76, 0x07, 0x61, 0x04, 0x76, 0x07, 0x66, 0x03,
-0x2e, 0x07, 0x64, 0x04, 0xda, 0x07, 0x65, 0x04, 0xda, 0x07, 0x6a,
-0x02, 0xf6, 0x07, 0x68, 0x05, 0x62, 0x07, 0x69, 0x05, 0x62, 0x06,
-0x46, 0x0a, 0x22, 0x06, 0x48, 0x0d, 0x24, 0x06, 0x6e, 0x11, 0xd3,
-0x06, 0x70, 0x15, 0xcb, 0x06, 0x52, 0x20, 0x93, 0x06, 0x54, 0x20,
-0x54, 0x06, 0x4a, 0x27, 0x1d, 0x06, 0x58, 0x2f, 0xc8, 0x06, 0x5c,
-0x30, 0x07, 0x06, 0x4c, 0x37, 0x90, 0x06, 0x60, 0x3d, 0xdb, 0x06,
-0x64, 0x3e, 0x42, 0x06, 0x4e, 0x45, 0x78, 0x06, 0x68, 0x4c, 0x48,
-0x06, 0x6c, 0x4c, 0x6c, 0x06, 0x50, 0x52, 0xe2, 0x06, 0x42, 0x02,
-0xba
-};
-unsigned char coefficients2[] __initdata = {
-0x07, 0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x07, 0x45, 0x0f,
-0xff, 0x07, 0x48, 0x0f, 0xff, 0x07, 0x7b, 0x04, 0xcc, 0x07, 0x7d,
-0x04, 0xcc, 0x07, 0x7c, 0x00, 0x00, 0x07, 0x7e, 0x00, 0x00, 0x07,
-0x46, 0x00, 0x00, 0x07, 0x49, 0x00, 0x00, 0x07, 0x47, 0x00, 0x00,
-0x07, 0x4a, 0x00, 0x00, 0x07, 0x4c, 0x00, 0x00, 0x07, 0x4e, 0x00, 0x00
-};
-unsigned char coefficients3[] __initdata = { 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x28, 0x00, 0x51, 0x00,
-0x51, 0x00, 0x7a, 0x00, 0x7a, 0x00, 0xa3, 0x00, 0xa3, 0x00, 0xcc,
-0x00, 0xcc, 0x00, 0xf5, 0x00, 0xf5, 0x01, 0x1e, 0x01, 0x1e, 0x01,
-0x47, 0x01, 0x47, 0x01, 0x70, 0x01, 0x70, 0x01, 0x99, 0x01, 0x99,
-0x01, 0xc2, 0x01, 0xc2, 0x01, 0xeb, 0x01, 0xeb, 0x02, 0x14, 0x02,
-0x14, 0x02, 0x3d, 0x02, 0x3d, 0x02, 0x66, 0x02, 0x66, 0x02, 0x8f,
-0x02, 0x8f, 0x02, 0xb8, 0x02, 0xb8, 0x02, 0xe1, 0x02, 0xe1, 0x03,
-0x0a, 0x03, 0x0a, 0x03, 0x33, 0x03, 0x33, 0x03, 0x5c, 0x03, 0x5c,
-0x03, 0x85, 0x03, 0x85, 0x03, 0xae, 0x03, 0xae, 0x03, 0xd7, 0x03,
-0xd7, 0x04, 0x00, 0x04, 0x00, 0x04, 0x28, 0x04, 0x28, 0x04, 0x51,
-0x04, 0x51, 0x04, 0x7a, 0x04, 0x7a, 0x04, 0xa3, 0x04, 0xa3, 0x04,
-0xcc, 0x04, 0xcc, 0x04, 0xf5, 0x04, 0xf5, 0x05, 0x1e, 0x05, 0x1e,
-0x05, 0x47, 0x05, 0x47, 0x05, 0x70, 0x05, 0x70, 0x05, 0x99, 0x05,
-0x99, 0x05, 0xc2, 0x05, 0xc2, 0x05, 0xeb, 0x05, 0xeb, 0x06, 0x14,
-0x06, 0x14, 0x06, 0x3d, 0x06, 0x3d, 0x06, 0x66, 0x06, 0x66, 0x06,
-0x8f, 0x06, 0x8f, 0x06, 0xb8, 0x06, 0xb8, 0x06, 0xe1, 0x06, 0xe1,
-0x07, 0x0a, 0x07, 0x0a, 0x07, 0x33, 0x07, 0x33, 0x07, 0x5c, 0x07,
-0x5c, 0x07, 0x85, 0x07, 0x85, 0x07, 0xae, 0x07, 0xae, 0x07, 0xd7,
-0x07, 0xd7, 0x08, 0x00, 0x08, 0x00, 0x08, 0x28, 0x08, 0x28, 0x08,
-0x51, 0x08, 0x51, 0x08, 0x7a, 0x08, 0x7a, 0x08, 0xa3, 0x08, 0xa3,
-0x08, 0xcc, 0x08, 0xcc, 0x08, 0xf5, 0x08, 0xf5, 0x09, 0x1e, 0x09,
-0x1e, 0x09, 0x47, 0x09, 0x47, 0x09, 0x70, 0x09, 0x70, 0x09, 0x99,
-0x09, 0x99, 0x09, 0xc2, 0x09, 0xc2, 0x09, 0xeb, 0x09, 0xeb, 0x0a,
-0x14, 0x0a, 0x14, 0x0a, 0x3d, 0x0a, 0x3d, 0x0a, 0x66, 0x0a, 0x66,
-0x0a, 0x8f, 0x0a, 0x8f, 0x0a, 0xb8, 0x0a, 0xb8, 0x0a, 0xe1, 0x0a,
-0xe1, 0x0b, 0x0a, 0x0b, 0x0a, 0x0b, 0x33, 0x0b, 0x33, 0x0b, 0x5c,
-0x0b, 0x5c, 0x0b, 0x85, 0x0b, 0x85, 0x0b, 0xae, 0x0b, 0xae, 0x0b,
-0xd7, 0x0b, 0xd7, 0x0c, 0x00, 0x0c, 0x00, 0x0c, 0x28, 0x0c, 0x28,
-0x0c, 0x51, 0x0c, 0x51, 0x0c, 0x7a, 0x0c, 0x7a, 0x0c, 0xa3, 0x0c,
-0xa3, 0x0c, 0xcc, 0x0c, 0xcc, 0x0c, 0xf5, 0x0c, 0xf5, 0x0d, 0x1e,
-0x0d, 0x1e, 0x0d, 0x47, 0x0d, 0x47, 0x0d, 0x70, 0x0d, 0x70, 0x0d,
-0x99, 0x0d, 0x99, 0x0d, 0xc2, 0x0d, 0xc2, 0x0d, 0xeb, 0x0d, 0xeb,
-0x0e, 0x14, 0x0e, 0x14, 0x0e, 0x3d, 0x0e, 0x3d, 0x0e, 0x66, 0x0e,
-0x66, 0x0e, 0x8f, 0x0e, 0x8f, 0x0e, 0xb8, 0x0e, 0xb8, 0x0e, 0xe1,
-0x0e, 0xe1, 0x0f, 0x0a, 0x0f, 0x0a, 0x0f, 0x33, 0x0f, 0x33, 0x0f,
-0x5c, 0x0f, 0x5c, 0x0f, 0x85, 0x0f, 0x85, 0x0f, 0xae, 0x0f, 0xae,
-0x0f, 0xd7, 0x0f, 0xd7, 0x0f, 0xff, 0x0f, 0xff
-};
-
--- linux-2.6.18.noarch/sound/oss/vidc.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/vidc.h	2007-06-05 17:44:14.000000000 -0400
@@ -33,7 +33,7 @@
  * DMA Interrupt handler
  */
 
-extern irqreturn_t vidc_sound_dma_irq(int irqnr, void *ref, struct pt_regs *regs);
+extern irqreturn_t vidc_sound_dma_irq(int irqnr, void *ref);
 
 /*
  * Filler routine pointer
--- linux-2.6.18.noarch/sound/oss/gus_card.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus_card.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,293 +0,0 @@
-/*
- * sound/gus_card.c
- *
- * Detection routine for the Gravis Ultrasound.
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- *
- * Frank van de Pol : Fixed GUS MAX interrupt handling, enabled simultanious
- *                    usage of CS4231A codec, GUS wave and MIDI for GUS MAX.
- * Christoph Hellwig: Adapted to module_init/module_exit, simple cleanups.
- *
- * Status:
- *              Tested... 
- */
-      
- 
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-
-#include "sound_config.h"
-
-#include "gus.h"
-#include "gus_hw.h"
-
-irqreturn_t gusintr(int irq, void *dev_id, struct pt_regs *dummy);
-
-int             gus_base = 0, gus_irq = 0, gus_dma = 0;
-int             gus_no_wave_dma = 0; 
-extern int      gus_wave_volume;
-extern int      gus_pcm_volume;
-extern int      have_gus_max;
-int             gus_pnp_flag = 0;
-#ifdef CONFIG_SOUND_GUS16
-static int      db16;	/* Has a Gus16 AD1848 on it */
-#endif
-
-static void __init attach_gus(struct address_info *hw_config)
-{
-	gus_wave_init(hw_config);
-
-	if (sound_alloc_dma(hw_config->dma, "GUS"))
-		printk(KERN_ERR "gus_card.c: Can't allocate DMA channel %d\n", hw_config->dma);
-	if (hw_config->dma2 != -1 && hw_config->dma2 != hw_config->dma)
-		if (sound_alloc_dma(hw_config->dma2, "GUS(2)"))
-			printk(KERN_ERR "gus_card.c: Can't allocate DMA channel %d\n", hw_config->dma2);
-	gus_midi_init(hw_config);
-	if(request_irq(hw_config->irq, gusintr, 0,  "Gravis Ultrasound", hw_config)<0)
-		printk(KERN_ERR "gus_card.c: Unable to allocate IRQ %d\n", hw_config->irq);
-
-	return;
-}
-
-static int __init probe_gus(struct address_info *hw_config)
-{
-	int             irq;
-	int             io_addr;
-
-	if (hw_config->card_subtype == 1)
-		gus_pnp_flag = 1;
-
-	irq = hw_config->irq;
-
-	if (hw_config->card_subtype == 0)	/* GUS/MAX/ACE */
-		if (irq != 3 && irq != 5 && irq != 7 && irq != 9 &&
-		    irq != 11 && irq != 12 && irq != 15)
-		  {
-			  printk(KERN_ERR "GUS: Unsupported IRQ %d\n", irq);
-			  return 0;
-		  }
-	if (gus_wave_detect(hw_config->io_base))
-		return 1;
-
-#ifndef EXCLUDE_GUS_IODETECT
-
-	/*
-	 * Look at the possible base addresses (0x2X0, X=1, 2, 3, 4, 5, 6)
-	 */
-
-	for (io_addr = 0x210; io_addr <= 0x260; io_addr += 0x10) {
-		if (io_addr == hw_config->io_base)	/* Already tested */
-			continue;
-		if (gus_wave_detect(io_addr)) {
-			hw_config->io_base = io_addr;
-			return 1;
-		}
-	}
-#endif
-
-	printk("NO GUS card found !\n");
-	return 0;
-}
-
-static void __exit unload_gus(struct address_info *hw_config)
-{
-	DDB(printk("unload_gus(%x)\n", hw_config->io_base));
-
-	gus_wave_unload(hw_config);
-
-	release_region(hw_config->io_base, 16);
-	release_region(hw_config->io_base + 0x100, 12);		/* 0x10c-> is MAX */
-	free_irq(hw_config->irq, hw_config);
-
-	sound_free_dma(hw_config->dma);
-
-	if (hw_config->dma2 != -1 && hw_config->dma2 != hw_config->dma)
-		sound_free_dma(hw_config->dma2);
-}
-
-irqreturn_t gusintr(int irq, void *dev_id, struct pt_regs *dummy)
-{
-	unsigned char src;
-	extern int gus_timer_enabled;
-	int handled = 0;
-
-#ifdef CONFIG_SOUND_GUSMAX
-	if (have_gus_max) {
-		struct address_info *hw_config = dev_id;
-		adintr(irq, (void *)hw_config->slots[1], NULL);
-	}
-#endif
-#ifdef CONFIG_SOUND_GUS16
-	if (db16) {
-		struct address_info *hw_config = dev_id;
-		adintr(irq, (void *)hw_config->slots[3], NULL);
-	}
-#endif
-
-	while (1)
-	{
-		if (!(src = inb(u_IrqStatus)))
-			break;
-		handled = 1;
-		if (src & DMA_TC_IRQ)
-		{
-			guswave_dma_irq();
-		}
-		if (src & (MIDI_TX_IRQ | MIDI_RX_IRQ))
-		{
-			gus_midi_interrupt(0);
-		}
-		if (src & (GF1_TIMER1_IRQ | GF1_TIMER2_IRQ))
-		{
-			if (gus_timer_enabled)
-				sound_timer_interrupt();
-			gus_write8(0x45, 0);	/* Ack IRQ */
-			gus_timer_command(4, 0x80);		/* Reset IRQ flags */
-		}
-		if (src & (WAVETABLE_IRQ | ENVELOPE_IRQ))
-			gus_voice_irq();
-	}
-	return IRQ_RETVAL(handled);
-}
-
-/*
- *	Some extra code for the 16 bit sampling option
- */
-
-#ifdef CONFIG_SOUND_GUS16
-
-static int __init init_gus_db16(struct address_info *hw_config)
-{
-	struct resource *ports;
-
-	ports = request_region(hw_config->io_base, 4, "ad1848");
-	if (!ports)
-		return 0;
-
-	if (!ad1848_detect(ports, NULL, hw_config->osp)) {
-		release_region(hw_config->io_base, 4);
-		return 0;
-	}
-
-	gus_pcm_volume = 100;
-	gus_wave_volume = 90;
-
-	hw_config->slots[3] = ad1848_init("GUS 16 bit sampling", ports,
-					  hw_config->irq,
-					  hw_config->dma,
-					  hw_config->dma, 0,
-					  hw_config->osp,
-					  THIS_MODULE);
-	return 1;
-}
-
-static void __exit unload_gus_db16(struct address_info *hw_config)
-{
-
-	ad1848_unload(hw_config->io_base,
-		      hw_config->irq,
-		      hw_config->dma,
-		      hw_config->dma, 0);
-	sound_unload_audiodev(hw_config->slots[3]);
-}
-#endif
-
-#ifdef CONFIG_SOUND_GUS16
-static int gus16;
-#endif
-#ifdef CONFIG_SOUND_GUSMAX
-static int no_wave_dma;   /* Set if no dma is to be used for the
-                                   wave table (GF1 chip) */
-#endif
-
-
-/*
- *    Note DMA2 of -1 has the right meaning in the GUS driver as well
- *      as here. 
- */
-
-static struct address_info cfg;
-
-static int __initdata io = -1;
-static int __initdata irq = -1;
-static int __initdata dma = -1;
-static int __initdata dma16 = -1;	/* Set this for modules that need it */
-static int __initdata type = 0;		/* 1 for PnP */
-
-module_param(io, int, 0);
-module_param(irq, int, 0);
-module_param(dma, int, 0);
-module_param(dma16, int, 0);
-module_param(type, int, 0);
-#ifdef CONFIG_SOUND_GUSMAX
-module_param(no_wave_dma, int, 0);
-#endif
-#ifdef CONFIG_SOUND_GUS16
-module_param(db16, int, 0);
-module_param(gus16, int, 0);
-#endif
-MODULE_LICENSE("GPL");
-
-static int __init init_gus(void)
-{
-	printk(KERN_INFO "Gravis Ultrasound audio driver Copyright (C) by Hannu Savolainen 1993-1996\n");
-
-	cfg.io_base = io;
-	cfg.irq = irq;
-	cfg.dma = dma;
-	cfg.dma2 = dma16;
-	cfg.card_subtype = type;
-#ifdef CONFIG_SOUND_GUSMAX
-	gus_no_wave_dma = no_wave_dma;
-#endif
-
-	if (cfg.io_base == -1 || cfg.dma == -1 || cfg.irq == -1) {
-		printk(KERN_ERR "I/O, IRQ, and DMA are mandatory\n");
-		return -EINVAL;
-	}
-
-#ifdef CONFIG_SOUND_GUS16
-	if (gus16 && init_gus_db16(&cfg))
-		db16 = 1;
-#endif
-	if (!probe_gus(&cfg))
-		return -ENODEV;
-	attach_gus(&cfg);
-
-	return 0;
-}
-
-static void __exit cleanup_gus(void)
-{
-#ifdef CONFIG_SOUND_GUS16
-	if (db16)
-		unload_gus_db16(&cfg);
-#endif
-	unload_gus(&cfg);
-}
-
-module_init(init_gus);
-module_exit(cleanup_gus);
-
-#ifndef MODULE
-static int __init setup_gus(char *str)
-{
-	/* io, irq, dma, dma2 */
-	int ints[5];
-	
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-	
-	io	= ints[1];
-	irq	= ints[2];
-	dma	= ints[3];
-	dma16	= ints[4];
-
-	return 1;
-}
-
-__setup("gus=", setup_gus);
-#endif
--- linux-2.6.18.noarch/sound/oss/waveartist.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/waveartist.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/sound/waveartist.h
+ * linux/sound/oss/waveartist.h
  *
  * def file for Rockwell RWA010 chip set, as installed in Rebel.com NetWinder
  */
--- linux-2.6.18.noarch/sound/oss/sequencer_syms.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sequencer_syms.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,29 +0,0 @@
-/*
- * Exported symbols for sequencer driver.
- */
-
-#include <linux/module.h>
-
-char sequencer_syms_symbol;
-
-#include "sound_config.h"
-#include "sound_calls.h"
-
-EXPORT_SYMBOL(note_to_freq);
-EXPORT_SYMBOL(compute_finetune);
-EXPORT_SYMBOL(seq_copy_to_input);
-EXPORT_SYMBOL(seq_input_event);
-EXPORT_SYMBOL(sequencer_init);
-EXPORT_SYMBOL(sequencer_timer);
-
-EXPORT_SYMBOL(sound_timer_init);
-EXPORT_SYMBOL(sound_timer_interrupt);
-EXPORT_SYMBOL(sound_timer_syncinterval);
-
-/* Tuning */
-
-#define _SEQUENCER_C_
-#include "tuning.h"
-
-EXPORT_SYMBOL(cent_tuning);
-EXPORT_SYMBOL(semitone_tuning);
--- linux-2.6.18.noarch/sound/oss/forte.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/forte.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2139 +0,0 @@
-/*
- * forte.c - ForteMedia FM801 OSS Driver
- *
- * Written by Martin K. Petersen <mkp@mkp.net>
- * Copyright (C) 2002 Hewlett-Packard Company
- * Portions Copyright (C) 2003 Martin K. Petersen
- *
- * Latest version: http://mkp.net/forte/
- *
- * Based upon the ALSA FM801 driver by Jaroslav Kysela and OSS drivers
- * by Thomas Sailer, Alan Cox, Zach Brown, and Jeff Garzik.  Thanks
- * guys!
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- *
- */
- 
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include <linux/pci.h>
-
-#include <linux/delay.h>
-#include <linux/poll.h>
-
-#include <linux/sound.h>
-#include <linux/ac97_codec.h>
-#include <linux/interrupt.h>
-
-#include <linux/proc_fs.h>
-#include <linux/mutex.h>
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-
-#define DRIVER_NAME	"forte"
-#define DRIVER_VERSION 	"$Id: forte.c,v 1.63 2003/03/01 05:32:42 mkp Exp $"
-#define PFX 		DRIVER_NAME ": "
-
-#undef M_DEBUG
-
-#ifdef M_DEBUG
-#define DPRINTK(args...) printk(KERN_WARNING args)
-#else
-#define DPRINTK(args...)
-#endif
-
-/* Card capabilities */
-#define FORTE_CAPS              (DSP_CAP_MMAP | DSP_CAP_TRIGGER)
-
-/* Supported audio formats */
-#define FORTE_FMTS		(AFMT_U8 | AFMT_S16_LE)
-
-/* Buffers */
-#define FORTE_MIN_FRAG_SIZE     256
-#define FORTE_MAX_FRAG_SIZE     PAGE_SIZE
-#define FORTE_DEF_FRAG_SIZE     256
-#define FORTE_MIN_FRAGMENTS     2
-#define FORTE_MAX_FRAGMENTS     256
-#define FORTE_DEF_FRAGMENTS     2
-#define FORTE_MIN_BUF_MSECS     500
-#define FORTE_MAX_BUF_MSECS     1000
-
-/* PCI BARs */
-#define FORTE_PCM_VOL           0x00    /* PCM Output Volume */
-#define FORTE_FM_VOL            0x02    /* FM Output Volume */
-#define FORTE_I2S_VOL           0x04    /* I2S Volume */
-#define FORTE_REC_SRC           0x06    /* Record Source */
-#define FORTE_PLY_CTRL          0x08    /* Playback Control */
-#define FORTE_PLY_COUNT         0x0a    /* Playback Count */
-#define FORTE_PLY_BUF1          0x0c    /* Playback Buffer I */
-#define FORTE_PLY_BUF2          0x10    /* Playback Buffer II */
-#define FORTE_CAP_CTRL          0x14    /* Capture Control */
-#define FORTE_CAP_COUNT         0x16    /* Capture Count */
-#define FORTE_CAP_BUF1          0x18    /* Capture Buffer I */
-#define FORTE_CAP_BUF2          0x1c    /* Capture Buffer II */
-#define FORTE_CODEC_CTRL        0x22    /* Codec Control */
-#define FORTE_I2S_MODE          0x24    /* I2S Mode Control */
-#define FORTE_VOLUME            0x26    /* Volume Up/Down/Mute Status */
-#define FORTE_I2C_CTRL          0x29    /* I2C Control */
-#define FORTE_AC97_CMD          0x2a    /* AC'97 Command */
-#define FORTE_AC97_DATA         0x2c    /* AC'97 Data */
-#define FORTE_MPU401_DATA       0x30    /* MPU401 Data */
-#define FORTE_MPU401_CMD        0x31    /* MPU401 Command */
-#define FORTE_GPIO_CTRL         0x52    /* General Purpose I/O Control */
-#define FORTE_GEN_CTRL          0x54    /* General Control */
-#define FORTE_IRQ_MASK          0x56    /* Interrupt Mask */
-#define FORTE_IRQ_STATUS        0x5a    /* Interrupt Status */
-#define FORTE_OPL3_BANK0        0x68    /* OPL3 Status Read / Bank 0 Write */
-#define FORTE_OPL3_DATA0        0x69    /* OPL3 Data 0 Write */
-#define FORTE_OPL3_BANK1        0x6a    /* OPL3 Bank 1 Write */
-#define FORTE_OPL3_DATA1        0x6b    /* OPL3 Bank 1 Write */
-#define FORTE_POWERDOWN         0x70    /* Blocks Power Down Control */
-
-#define FORTE_CAP_OFFSET        FORTE_CAP_CTRL - FORTE_PLY_CTRL
-
-#define FORTE_AC97_ADDR_SHIFT   10
-
-/* Playback and record control register bits */
-#define FORTE_BUF1_LAST         (1<<1)
-#define FORTE_BUF2_LAST         (1<<2)
-#define FORTE_START             (1<<5)
-#define FORTE_PAUSE             (1<<6)
-#define FORTE_IMMED_STOP        (1<<7)
-#define FORTE_RATE_SHIFT        8
-#define FORTE_RATE_MASK         (15 << FORTE_RATE_SHIFT)
-#define FORTE_CHANNELS_4        (1<<12) /* Playback only */
-#define FORTE_CHANNELS_6        (2<<12) /* Playback only */
-#define FORTE_CHANNELS_6MS      (3<<12) /* Playback only */
-#define FORTE_CHANNELS_MASK     (3<<12)
-#define FORTE_16BIT             (1<<14)
-#define FORTE_STEREO            (1<<15)
-
-/* IRQ status bits */
-#define FORTE_IRQ_PLAYBACK      (1<<8)
-#define FORTE_IRQ_CAPTURE       (1<<9)
-#define FORTE_IRQ_VOLUME        (1<<14)
-#define FORTE_IRQ_MPU           (1<<15)
-
-/* CODEC control */
-#define FORTE_CC_CODEC_RESET    (1<<5)
-#define FORTE_CC_AC97_RESET     (1<<6)
-
-/* AC97 cmd */
-#define FORTE_AC97_WRITE        (0<<7)
-#define FORTE_AC97_READ         (1<<7)
-#define FORTE_AC97_DP_INVALID   (0<<8)
-#define FORTE_AC97_DP_VALID     (1<<8)
-#define FORTE_AC97_PORT_RDY     (0<<9)
-#define FORTE_AC97_PORT_BSY     (1<<9)
-
-
-struct forte_channel {
-        const char 		*name;
-
-	unsigned short		ctrl; 		/* Ctrl BAR contents */
-	unsigned long 		iobase;		/* Ctrl BAR address */
-
-	wait_queue_head_t	wait;
-
-	void 			*buf; 		/* Buffer */
-	dma_addr_t		buf_handle; 	/* Buffer handle */
-
-        unsigned int 		record;
-	unsigned int		format;
-        unsigned int		rate;
-	unsigned int		stereo;
-
-	unsigned int		frag_sz; 	/* Current fragment size */
-	unsigned int		frag_num; 	/* Current # of fragments */
-	unsigned int		frag_msecs;     /* Milliseconds per frag */
-	unsigned int		buf_sz;		/* Current buffer size */
-
-	unsigned int		hwptr;		/* Tail */
-	unsigned int		swptr; 		/* Head */
-	unsigned int		filled_frags; 	/* Fragments currently full */
-	unsigned int		next_buf;	/* Index of next buffer */
-
-	unsigned int		active;		/* Channel currently in use */
-	unsigned int		mapped;		/* mmap */
-
-	unsigned int		buf_pages;	/* Real size of buffer */
-	unsigned int		nr_irqs;	/* Number of interrupts */
-	unsigned int		bytes;		/* Total bytes */
-	unsigned int		residue;	/* Partial fragment */
-};
-
-
-struct forte_chip {
-	struct pci_dev		*pci_dev;
-	unsigned long		iobase;
-	int			irq;
-
-	struct mutex		open_mutex; 	/* Device access */
-	spinlock_t		lock;		/* State */
-
-	spinlock_t		ac97_lock;
-	struct ac97_codec	*ac97;
-
-	int			multichannel;
-	int			dsp; 		/* OSS handle */
-	int                     trigger;	/* mmap I/O trigger */
-
-	struct forte_channel	play;
-	struct forte_channel	rec;
-};
-
-
-static int channels[] = { 2, 4, 6, };
-static int rates[]    = { 5500, 8000, 9600, 11025, 16000, 19200, 
-			  22050, 32000, 38400, 44100, 48000, };
-
-static struct forte_chip *forte;
-static int found;
-
-
-/* AC97 Codec -------------------------------------------------------------- */
-
-
-/** 
- * forte_ac97_wait:
- * @chip:	fm801 instance whose AC97 codec to wait on
- *
- * FIXME:
- *		Stop busy-waiting
- */
-
-static inline int
-forte_ac97_wait (struct forte_chip *chip)
-{
-	int i = 10000;
-
-	while ( (inw (chip->iobase + FORTE_AC97_CMD) & FORTE_AC97_PORT_BSY) 
-		&& i-- )
-		cpu_relax();
-
-	return i == 0;
-}
-
-
-/**
- * forte_ac97_read:
- * @codec:	AC97 codec to read from
- * @reg:	register to read
- */
-
-static u16
-forte_ac97_read (struct ac97_codec *codec, u8 reg)
-{
-	u16 ret = 0;
-	struct forte_chip *chip = codec->private_data;
-
-	spin_lock (&chip->ac97_lock);
-
-	/* Knock, knock */
-	if (forte_ac97_wait (chip)) {
-		printk (KERN_ERR PFX "ac97_read: Serial bus busy\n");
-		goto out;
-	}
-
-	/* Send read command */
-	outw (reg | (1<<7), chip->iobase + FORTE_AC97_CMD);
-
-	if (forte_ac97_wait (chip)) {
-		printk (KERN_ERR PFX "ac97_read: Bus busy reading reg 0x%x\n",
-			reg);
-		goto out;
-	}
-	
-	/* Sanity checking */
-	if (inw (chip->iobase + FORTE_AC97_CMD) & FORTE_AC97_DP_INVALID) {
-		printk (KERN_ERR PFX "ac97_read: Invalid data port");
-		goto out;
-	}
-
-	/* Fetch result */
-	ret = inw (chip->iobase + FORTE_AC97_DATA);
-
- out:
-	spin_unlock (&chip->ac97_lock);
-	return ret;
-}
-
-
-/**
- * forte_ac97_write:
- * @codec:	AC97 codec to send command to
- * @reg:	register to write
- * @val:	value to write
- */
-
-static void
-forte_ac97_write (struct ac97_codec *codec, u8 reg, u16 val)
-{
-	struct forte_chip *chip = codec->private_data;
-
-	spin_lock (&chip->ac97_lock);
-
-	/* Knock, knock */
-	if (forte_ac97_wait (chip)) {
-		printk (KERN_ERR PFX "ac97_write: Serial bus busy\n");
-		goto out;
-	}
-
-	outw (val, chip->iobase + FORTE_AC97_DATA);
-	outb (reg | FORTE_AC97_WRITE, chip->iobase + FORTE_AC97_CMD);
-
-	/* Wait for completion */
-	if (forte_ac97_wait (chip)) {
-		printk (KERN_ERR PFX "ac97_write: Bus busy after write\n");
-		goto out;
-	}
-
- out:
-	spin_unlock (&chip->ac97_lock);
-}
-
-
-/* Mixer ------------------------------------------------------------------- */
-
-
-/**
- * forte_mixer_open:
- * @inode:		
- * @file:		
- */
-
-static int
-forte_mixer_open (struct inode *inode, struct file *file)
-{
-	struct forte_chip *chip = forte;
-	file->private_data = chip->ac97;
-	return 0;
-}
-
-
-/**
- * forte_mixer_release:
- * @inode:		
- * @file:		
- */
-
-static int
-forte_mixer_release (struct inode *inode, struct file *file)
-{
-	/* We will welease Wodewick */
-	return 0;
-}
-
-
-/**
- * forte_mixer_ioctl:
- * @inode:		
- * @file:		
- */
-
-static int
-forte_mixer_ioctl (struct inode *inode, struct file *file, 
-		   unsigned int cmd, unsigned long arg)
-{
-	struct ac97_codec *codec = (struct ac97_codec *) file->private_data;
-
-	return codec->mixer_ioctl (codec, cmd, arg);
-}
-
-
-static struct file_operations forte_mixer_fops = {
-	.owner			= THIS_MODULE,
-	.llseek         	= no_llseek,
-	.ioctl          	= forte_mixer_ioctl,
-	.open           	= forte_mixer_open,
-	.release        	= forte_mixer_release,
-};
-
-
-/* Channel ----------------------------------------------------------------- */
-
-/** 
- * forte_channel_reset:
- * @channel:	Channel to reset
- * 
- * Locking:	Must be called with lock held.
- */
-
-static void
-forte_channel_reset (struct forte_channel *channel)
-{
-	if (!channel || !channel->iobase)
-		return;
-
-	DPRINTK ("%s: channel = %s\n", __FUNCTION__, channel->name);
-
-	channel->ctrl &= ~FORTE_START;
-	outw (channel->ctrl, channel->iobase + FORTE_PLY_CTRL);
-	
-	/* We always play at least two fragments, hence these defaults */
- 	channel->hwptr = channel->frag_sz;
-	channel->next_buf = 1;
-	channel->swptr = 0;
-	channel->filled_frags = 0;
-	channel->active = 0;
-	channel->bytes = 0;
-	channel->nr_irqs = 0;
-	channel->mapped = 0;
-	channel->residue = 0;
-}
-
-
-/** 
- * forte_channel_start:
- * @channel: 	Channel to start (record/playback)
- *
- * Locking:	Must be called with lock held.
- */
-
-static void inline
-forte_channel_start (struct forte_channel *channel)
-{
-	if (!channel || !channel->iobase || channel->active) 
-		return;
-
-	channel->ctrl &= ~(FORTE_PAUSE | FORTE_BUF1_LAST | FORTE_BUF2_LAST
-			   | FORTE_IMMED_STOP);
-	channel->ctrl |= FORTE_START;
-	channel->active = 1;
-	outw (channel->ctrl, channel->iobase + FORTE_PLY_CTRL);
-}
-
-
-/** 
- * forte_channel_stop:
- * @channel: 	Channel to stop
- *
- * Locking:	Must be called with lock held.
- */
-
-static void inline
-forte_channel_stop (struct forte_channel *channel)
-{
-	if (!channel || !channel->iobase) 
-		return;
-
-	channel->ctrl &= ~(FORTE_START | FORTE_PAUSE);	
-	channel->ctrl |= FORTE_IMMED_STOP;
-
-	channel->active = 0;
-	outw (channel->ctrl, channel->iobase + FORTE_PLY_CTRL);
-}
-
-
-/** 
- * forte_channel_pause:
- * @channel: 	Channel to pause
- *
- * Locking:	Must be called with lock held.
- */
-
-static void inline
-forte_channel_pause (struct forte_channel *channel)
-{
-	if (!channel || !channel->iobase) 
-		return;
-
-	channel->ctrl |= FORTE_PAUSE;
-
-	channel->active = 0;
-	outw (channel->ctrl, channel->iobase + FORTE_PLY_CTRL);
-}
-
-
-/** 
- * forte_channel_rate:
- * @channel: 	Channel whose rate to set.  Playback and record are
- *           	independent.
- * @rate:    	Channel rate in Hz
- *
- * Locking:	Must be called with lock held.
- */
-
-static int
-forte_channel_rate (struct forte_channel *channel, unsigned int rate)
-{
-	int new_rate;
-
-	if (!channel || !channel->iobase) 
-		return -EINVAL;
-
-	/* The FM801 only supports a handful of fixed frequencies.
-	 * We find the value closest to what userland requested.
-	 */
-	if      (rate <= 6250)  { rate = 5500;  new_rate =  0; }
-	else if (rate <= 8800)  { rate = 8000;  new_rate =  1; }
-	else if (rate <= 10312) { rate = 9600;  new_rate =  2; }
-	else if (rate <= 13512) { rate = 11025; new_rate =  3; }
-	else if (rate <= 17600) { rate = 16000; new_rate =  4; }
-	else if (rate <= 20625) { rate = 19200; new_rate =  5; }
-	else if (rate <= 27025) { rate = 22050; new_rate =  6; }
-	else if (rate <= 35200) { rate = 32000; new_rate =  7; }
-	else if (rate <= 41250) { rate = 38400; new_rate =  8; }
-	else if (rate <= 46050) { rate = 44100; new_rate =  9; }
-	else                    { rate = 48000; new_rate = 10; }
-
-	channel->ctrl &= ~FORTE_RATE_MASK;
-	channel->ctrl |= new_rate << FORTE_RATE_SHIFT;
-	channel->rate = rate;
-
-	DPRINTK ("%s: %s rate = %d\n", __FUNCTION__, channel->name, rate);
-
-	return rate;
-}
-
-
-/** 
- * forte_channel_format:
- * @channel: 	Channel whose audio format to set
- * @format:  	OSS format ID
- *
- * Locking:	Must be called with lock held.
- */
-
-static int
-forte_channel_format (struct forte_channel *channel, int format)
-{
-	if (!channel || !channel->iobase) 
-		return -EINVAL;
-
-	switch (format) {
-
-	case AFMT_QUERY:
-		break;
-	
-	case AFMT_U8:
-		channel->ctrl &= ~FORTE_16BIT;
-		channel->format = AFMT_U8;
-		break;
-
-	case AFMT_S16_LE:
-	default:
-		channel->ctrl |= FORTE_16BIT;
-		channel->format = AFMT_S16_LE;
-		break;
-	}
-
-	DPRINTK ("%s: %s want %d format, got %d\n", __FUNCTION__, channel->name, 
-		 format, channel->format);
-
-	return channel->format;
-}
-
-
-/** 
- * forte_channel_stereo:
- * @channel: 	Channel to toggle
- * @stereo:  	0 for Mono, 1 for Stereo
- *
- * Locking:	Must be called with lock held.
- */
-
-static int
-forte_channel_stereo (struct forte_channel *channel, unsigned int stereo)
-{
-	int ret;
-
-	if (!channel || !channel->iobase)
-		return -EINVAL;
-
-	DPRINTK ("%s: %s stereo = %d\n", __FUNCTION__, channel->name, stereo);
-
-	switch (stereo) {
-
-	case 0:
-		channel->ctrl &= ~(FORTE_STEREO | FORTE_CHANNELS_MASK);
-		channel-> stereo = stereo;
-		ret = stereo;
-		break;
-
-	case 1:
-		channel->ctrl &= ~FORTE_CHANNELS_MASK;
-		channel->ctrl |= FORTE_STEREO;
-		channel-> stereo = stereo;
-		ret = stereo;
-		break;
-
-	default:
-		DPRINTK ("Unsupported channel format");
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-
-/** 
- * forte_channel_buffer:
- * @channel:	Channel whose buffer to set up
- *
- * Locking:	Must be called with lock held.
- */
-
-static void
-forte_channel_buffer (struct forte_channel *channel, int sz, int num)
-{
-	unsigned int msecs, shift;
-
-	/* Go away, I'm busy */
-	if (channel->filled_frags || channel->bytes)
-		return;
-
-	/* Fragment size must be a power of 2 */
-	shift = 0; sz++;
-	while (sz >>= 1)
-		shift++;
-	channel->frag_sz = 1 << shift;
-
-	/* Round fragment size to something reasonable */
-	if (channel->frag_sz < FORTE_MIN_FRAG_SIZE)
-		channel->frag_sz = FORTE_MIN_FRAG_SIZE;
-
-	if (channel->frag_sz > FORTE_MAX_FRAG_SIZE)
-		channel->frag_sz = FORTE_MAX_FRAG_SIZE;
-
-	/* Find fragment length in milliseconds */
-	msecs = channel->frag_sz /
-		(channel->format == AFMT_S16_LE ? 2 : 1) /
-		(channel->stereo ? 2 : 1) /
-		(channel->rate / 1000);
-
-	channel->frag_msecs = msecs;
-
-	/* Pick a suitable number of fragments */
-	if (msecs * num < FORTE_MIN_BUF_MSECS)
-	     num = FORTE_MIN_BUF_MSECS / msecs;
-
-	if (msecs * num > FORTE_MAX_BUF_MSECS)
-	     num = FORTE_MAX_BUF_MSECS / msecs;
-
-	/* Fragment number must be a power of 2 */
-	shift = 0;	
-	while (num >>= 1)
-		shift++;
-	channel->frag_num = 1 << (shift + 1);
-
-	/* Round fragment number to something reasonable */
-	if (channel->frag_num < FORTE_MIN_FRAGMENTS)
-		channel->frag_num = FORTE_MIN_FRAGMENTS;
-
-	if (channel->frag_num > FORTE_MAX_FRAGMENTS)
-		channel->frag_num = FORTE_MAX_FRAGMENTS;
-
-	channel->buf_sz = channel->frag_sz * channel->frag_num;
-
-	DPRINTK ("%s: %s frag_sz = %d, frag_num = %d, buf_sz = %d\n",
-		 __FUNCTION__, channel->name, channel->frag_sz, 
-		 channel->frag_num, channel->buf_sz);
-}
-
-
-/** 
- * forte_channel_prep:
- * @channel:	Channel whose buffer to prepare
- *
- * Locking:	Lock held.
- */
-
-static void
-forte_channel_prep (struct forte_channel *channel)
-{
-	struct page *page;
-	int i;
-	
-	if (channel->buf)
-		return;
-
-	forte_channel_buffer (channel, channel->frag_sz, channel->frag_num);
-	channel->buf_pages = channel->buf_sz >> PAGE_SHIFT;
-
-	if (channel->buf_sz % PAGE_SIZE)
-		channel->buf_pages++;
-
-	DPRINTK ("%s: %s frag_sz = %d, frag_num = %d, buf_sz = %d, pg = %d\n", 
-		 __FUNCTION__, channel->name, channel->frag_sz, 
-		 channel->frag_num, channel->buf_sz, channel->buf_pages);
-
-	/* DMA buffer */
-	channel->buf = pci_alloc_consistent (forte->pci_dev, 
-					     channel->buf_pages * PAGE_SIZE,
-					     &channel->buf_handle);
-
-	if (!channel->buf || !channel->buf_handle)
-		BUG();
-
-	page = virt_to_page (channel->buf);
-	
-	/* FIXME: can this go away ? */
-	for (i = 0 ; i < channel->buf_pages ; i++)
-		SetPageReserved(page++);
-
-	/* Prep buffer registers */
-	outw (channel->frag_sz - 1, channel->iobase + FORTE_PLY_COUNT);
-	outl (channel->buf_handle, channel->iobase + FORTE_PLY_BUF1);
-	outl (channel->buf_handle + channel->frag_sz, 
-	      channel->iobase + FORTE_PLY_BUF2);
-
-	/* Reset hwptr */
- 	channel->hwptr = channel->frag_sz;
-	channel->next_buf = 1;
-
-	DPRINTK ("%s: %s buffer @ %p (%p)\n", __FUNCTION__, channel->name, 
-		 channel->buf, channel->buf_handle);
-}
-
-
-/** 
- * forte_channel_drain:
- * @chip:	
- * @channel:	
- *
- * Locking:	Don't hold the lock.
- */
-
-static inline int
-forte_channel_drain (struct forte_channel *channel)
-{
-	DECLARE_WAITQUEUE (wait, current);
-	unsigned long flags;
-
-	DPRINTK ("%s\n", __FUNCTION__);
-
-	if (channel->mapped) {
-		spin_lock_irqsave (&forte->lock, flags);
-		forte_channel_stop (channel);
-		spin_unlock_irqrestore (&forte->lock, flags);
-		return 0;
-	}
-
-	spin_lock_irqsave (&forte->lock, flags);
-	add_wait_queue (&channel->wait, &wait);
-
-	for (;;) {
-		if (channel->active == 0 || channel->filled_frags == 1)
-			break;
-
-		spin_unlock_irqrestore (&forte->lock, flags);
-
-		__set_current_state (TASK_INTERRUPTIBLE);
-		schedule();
-
-		spin_lock_irqsave (&forte->lock, flags);
-	}
-
-	forte_channel_stop (channel);
-	forte_channel_reset (channel);
-	set_current_state (TASK_RUNNING);
-	remove_wait_queue (&channel->wait, &wait);
-	spin_unlock_irqrestore (&forte->lock, flags);
-
-	return 0;
-}
-
-
-/** 
- * forte_channel_init:
- * @chip: 	Forte chip instance the channel hangs off
- * @channel: 	Channel to initialize
- *
- * Description:
- *	        Initializes a channel, sets defaults, and allocates
- *	        buffers.
- *
- * Locking:	No lock held.
- */
-
-static int
-forte_channel_init (struct forte_chip *chip, struct forte_channel *channel)
-{
-	DPRINTK ("%s: chip iobase @ %p\n", __FUNCTION__, (void *)chip->iobase);
-
-	spin_lock_irq (&chip->lock);
-	memset (channel, 0x0, sizeof (*channel));
-
-	if (channel == &chip->play) {
-		channel->name = "PCM_OUT";
-		channel->iobase = chip->iobase;
-		DPRINTK ("%s: PCM-OUT iobase @ %p\n", __FUNCTION__,
-			 (void *) channel->iobase);
-	}
-	else if (channel == &chip->rec) {
-		channel->name = "PCM_IN";
-		channel->iobase = chip->iobase + FORTE_CAP_OFFSET;
-		channel->record = 1;
-		DPRINTK ("%s: PCM-IN iobase @ %p\n", __FUNCTION__, 
-			 (void *) channel->iobase);
-	}
-	else
-		BUG();
-
-	init_waitqueue_head (&channel->wait);
-
-	/* Defaults: 48kHz, 16-bit, stereo */
-	channel->ctrl = inw (channel->iobase + FORTE_PLY_CTRL);
-	forte_channel_reset (channel);
-	forte_channel_stereo (channel, 1);
-	forte_channel_format (channel, AFMT_S16_LE);
-	forte_channel_rate (channel, 48000);
-	channel->frag_sz = FORTE_DEF_FRAG_SIZE;
-	channel->frag_num = FORTE_DEF_FRAGMENTS;
-
-	chip->trigger = 0;
-	spin_unlock_irq (&chip->lock);
-
-	return 0;
-}
-
-
-/** 
- * forte_channel_free:
- * @chip:	Chip this channel hangs off
- * @channel:	Channel to nuke 
- *
- * Description:
- * 		Resets channel and frees buffers.
- *
- * Locking:	Hold your horses.
- */
-
-static void
-forte_channel_free (struct forte_chip *chip, struct forte_channel *channel)
-{
-	DPRINTK ("%s: %s\n", __FUNCTION__, channel->name);
-
-	if (!channel->buf_handle)
-		return;
-
-	pci_free_consistent (chip->pci_dev, channel->buf_pages * PAGE_SIZE, 
-			     channel->buf, channel->buf_handle);
-	
-	memset (channel, 0x0, sizeof (*channel));
-}
-
-
-/* DSP --------------------------------------------------------------------- */
-
-
-/**
- * forte_dsp_ioctl:
- */
-
-static int
-forte_dsp_ioctl (struct inode *inode, struct file *file, unsigned int cmd,
-		 unsigned long arg)
-{
-	int ival=0, ret, rval=0, rd, wr, count;
-	struct forte_chip *chip;
-	struct audio_buf_info abi;
-	struct count_info cinfo;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	chip = file->private_data;
-	
-	if (file->f_mode & FMODE_WRITE)
-		wr = 1;
-	else 
-		wr = 0;
-
-	if (file->f_mode & FMODE_READ)
-		rd = 1;
-	else
-		rd = 0;
-
-	switch (cmd) {
-
-	case OSS_GETVERSION:
-		return put_user (SOUND_VERSION, p);
-
-	case SNDCTL_DSP_GETCAPS:
-		DPRINTK ("%s: GETCAPS\n", __FUNCTION__);
-
-		ival = FORTE_CAPS; /* DUPLEX */
-		return put_user (ival, p);
-
-	case SNDCTL_DSP_GETFMTS:
-		DPRINTK ("%s: GETFMTS\n", __FUNCTION__);
-
-		ival = FORTE_FMTS; /* U8, 16LE */
-		return put_user (ival, p);
-
-	case SNDCTL_DSP_SETFMT:	/* U8, 16LE */
-		DPRINTK ("%s: SETFMT\n", __FUNCTION__);
-
-		if (get_user (ival, p))
-			return -EFAULT;
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd) {
-			forte_channel_stop (&chip->rec);
-			rval = forte_channel_format (&chip->rec, ival);
-		}
-
-		if (wr) {
-			forte_channel_stop (&chip->rec);
-			rval = forte_channel_format (&chip->play, ival);
-		}
-
-		spin_unlock_irq (&chip->lock);
-	
-		return put_user (rval, p);
-
-	case SNDCTL_DSP_STEREO:	/* 0 - mono, 1 - stereo */
-		DPRINTK ("%s: STEREO\n", __FUNCTION__);
-
-		if (get_user (ival, p))
-			return -EFAULT;
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd) {
-			forte_channel_stop (&chip->rec);
-			rval = forte_channel_stereo (&chip->rec, ival);
-		}
-
-		if (wr) {
-			forte_channel_stop (&chip->rec);
-			rval = forte_channel_stereo (&chip->play, ival);
-		}
-
-		spin_unlock_irq (&chip->lock);
-
-                return put_user (rval, p);
-
-	case SNDCTL_DSP_CHANNELS: /* 1 - mono, 2 - stereo */
-		DPRINTK ("%s: CHANNELS\n", __FUNCTION__);
-
-		if (get_user (ival, p))
-			return -EFAULT;
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd) {
-			forte_channel_stop (&chip->rec);
-			rval = forte_channel_stereo (&chip->rec, ival-1) + 1;
-		}
-
-		if (wr) {
-			forte_channel_stop (&chip->play);
-			rval = forte_channel_stereo (&chip->play, ival-1) + 1;
-		}
-
-		spin_unlock_irq (&chip->lock);
-
-                return put_user (rval, p);
-
-	case SNDCTL_DSP_SPEED:
-		DPRINTK ("%s: SPEED\n", __FUNCTION__);
-
-		if (get_user (ival, p))
-                        return -EFAULT;
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd) {
-			forte_channel_stop (&chip->rec);
-			rval = forte_channel_rate (&chip->rec, ival);
-		}
-
-		if (wr) {
-			forte_channel_stop (&chip->play);
-			rval = forte_channel_rate (&chip->play, ival);
-		}
-
-		spin_unlock_irq (&chip->lock);
-
-                return put_user(rval, p);
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		DPRINTK ("%s: GETBLKSIZE\n", __FUNCTION__);
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd)
-			ival = chip->rec.frag_sz;
-
-		if (wr)
-			ival = chip->play.frag_sz;
-
-		spin_unlock_irq (&chip->lock);
-
-                return put_user (ival, p);
-
-	case SNDCTL_DSP_RESET:
-		DPRINTK ("%s: RESET\n", __FUNCTION__);
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd)
-			forte_channel_reset (&chip->rec);
-
-		if (wr)
-			forte_channel_reset (&chip->play);
-
-		spin_unlock_irq (&chip->lock);
-
-                return 0;
-
-	case SNDCTL_DSP_SYNC:
-		DPRINTK ("%s: SYNC\n", __FUNCTION__);
-
-		if (wr)
-			ret = forte_channel_drain (&chip->play);
-
-		return 0;
-
-	case SNDCTL_DSP_POST:
-		DPRINTK ("%s: POST\n", __FUNCTION__);
-
-		if (wr) {
-			spin_lock_irq (&chip->lock);
-
-			if (chip->play.filled_frags)
-				forte_channel_start (&chip->play);
-
-			spin_unlock_irq (&chip->lock);
-		}
-
-                return 0;
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		DPRINTK ("%s: SETFRAGMENT\n", __FUNCTION__);
-
-		if (get_user (ival, p))
-			return -EFAULT;
-
-		spin_lock_irq (&chip->lock);
-
-		if (rd) {
-			forte_channel_buffer (&chip->rec, ival & 0xffff, 
-					      (ival >> 16) & 0xffff);
-			ival = (chip->rec.frag_num << 16) + chip->rec.frag_sz;
-		}
-
-		if (wr) {
-			forte_channel_buffer (&chip->play, ival & 0xffff, 
-					      (ival >> 16) & 0xffff);
-			ival = (chip->play.frag_num << 16) +chip->play.frag_sz;
-		}
-
-		spin_unlock_irq (&chip->lock);
-
-		return put_user (ival, p);
-                
-        case SNDCTL_DSP_GETISPACE:
-		DPRINTK ("%s: GETISPACE\n", __FUNCTION__);
-
-		if (!rd)
-			return -EINVAL;
-
-		spin_lock_irq (&chip->lock);
-
-		abi.fragstotal = chip->rec.frag_num;
-		abi.fragsize = chip->rec.frag_sz;
-			
-		if (chip->rec.mapped) {
-			abi.fragments = chip->rec.frag_num - 2;
-			abi.bytes = abi.fragments * abi.fragsize;
-		}
-		else {
-			abi.fragments = chip->rec.filled_frags;
-			abi.bytes = abi.fragments * abi.fragsize;
-		}
-
-		spin_unlock_irq (&chip->lock);
-
-		return copy_to_user (argp, &abi, sizeof (abi)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETIPTR:
-		DPRINTK ("%s: GETIPTR\n", __FUNCTION__);
-
-		if (!rd)
-			return -EINVAL;
-
-		spin_lock_irq (&chip->lock);
-
-		if (chip->rec.active) 
-			cinfo.ptr = chip->rec.hwptr;
-		else
-			cinfo.ptr = 0;
-
-		cinfo.bytes = chip->rec.bytes;
-		cinfo.blocks = chip->rec.nr_irqs;
-		chip->rec.nr_irqs = 0;
-
-		spin_unlock_irq (&chip->lock);
-
-		return copy_to_user (argp, &cinfo, sizeof (cinfo)) ? -EFAULT : 0;
-
-        case SNDCTL_DSP_GETOSPACE:
-		if (!wr)
-			return -EINVAL;
-		
-		spin_lock_irq (&chip->lock);
-
-		abi.fragstotal = chip->play.frag_num;
-		abi.fragsize = chip->play.frag_sz;
-
-		if (chip->play.mapped) {
-			abi.fragments = chip->play.frag_num - 2;
-			abi.bytes = chip->play.buf_sz;
-		}
-		else {
-			abi.fragments = chip->play.frag_num - 
-				chip->play.filled_frags;
-
-			if (chip->play.residue)
-				abi.fragments--;
-
-			abi.bytes = abi.fragments * abi.fragsize +
-				chip->play.residue;
-		}
-
-		spin_unlock_irq (&chip->lock);
-		
-		return copy_to_user (argp, &abi, sizeof (abi)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETOPTR:
-		if (!wr)
-			return -EINVAL;
-
-		spin_lock_irq (&chip->lock);
-
-		if (chip->play.active) 
-			cinfo.ptr = chip->play.hwptr;
-		else
-			cinfo.ptr = 0;
-
-		cinfo.bytes = chip->play.bytes;
-		cinfo.blocks = chip->play.nr_irqs;
-		chip->play.nr_irqs = 0;
-
-		spin_unlock_irq (&chip->lock);
-
-		return copy_to_user (argp, &cinfo, sizeof (cinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETODELAY:
-		if (!wr)
-			return -EINVAL;
-
-		spin_lock_irq (&chip->lock);
-
-		if (!chip->play.active) {
-			ival = 0;
-		}
-		else if (chip->play.mapped) {
-			count = inw (chip->play.iobase + FORTE_PLY_COUNT) + 1;
-			ival = chip->play.frag_sz - count;
-		}
-		else {
-			ival = chip->play.filled_frags * chip->play.frag_sz;
-
-			if (chip->play.residue)
-				ival += chip->play.frag_sz - chip->play.residue;
-		}
-
-		spin_unlock_irq (&chip->lock);
-
-		return put_user (ival, p);
-
-	case SNDCTL_DSP_SETDUPLEX:
-		DPRINTK ("%s: SETDUPLEX\n", __FUNCTION__);
-
-		return -EINVAL;
-
-	case SNDCTL_DSP_GETTRIGGER:
-		DPRINTK ("%s: GETTRIGGER\n", __FUNCTION__);
-		
-		return put_user (chip->trigger, p);
-		
-	case SNDCTL_DSP_SETTRIGGER:
-
-		if (get_user (ival, p))
-			return -EFAULT;
-
-		DPRINTK ("%s: SETTRIGGER %d\n", __FUNCTION__, ival);
-
-		if (wr) {
-			spin_lock_irq (&chip->lock);
-
-			if (ival & PCM_ENABLE_OUTPUT)
-				forte_channel_start (&chip->play);
-			else {		
-				chip->trigger = 1;
-				forte_channel_prep (&chip->play);
-				forte_channel_stop (&chip->play);
-			}
-
-			spin_unlock_irq (&chip->lock);
-		}
-		else if (rd) {
-			spin_lock_irq (&chip->lock);
-
-			if (ival & PCM_ENABLE_INPUT)
-				forte_channel_start (&chip->rec);
-			else {		
-				chip->trigger = 1;
-				forte_channel_prep (&chip->rec);
-				forte_channel_stop (&chip->rec);
-			}
-
-			spin_unlock_irq (&chip->lock);
-		}
-
-		return 0;
-		
-	case SOUND_PCM_READ_RATE:
-		DPRINTK ("%s: PCM_READ_RATE\n", __FUNCTION__);		
-		return put_user (chip->play.rate, p);
-
-	case SOUND_PCM_READ_CHANNELS:
-		DPRINTK ("%s: PCM_READ_CHANNELS\n", __FUNCTION__);
-		return put_user (chip->play.stereo, p);
-
-	case SOUND_PCM_READ_BITS:
-		DPRINTK ("%s: PCM_READ_BITS\n", __FUNCTION__);		
-		return put_user (chip->play.format, p);
-
-	case SNDCTL_DSP_NONBLOCK:
-		DPRINTK ("%s: DSP_NONBLOCK\n", __FUNCTION__);		
-                file->f_flags |= O_NONBLOCK;
-		return 0;
-
-	default:
-		DPRINTK ("Unsupported ioctl: %x (%p)\n", cmd, argp);
-		break;
-	}
-
-	return -EINVAL;
-}
-
-
-/**
- * forte_dsp_open:
- */
-
-static int 
-forte_dsp_open (struct inode *inode, struct file *file)
-{
-	struct forte_chip *chip = forte; /* FIXME: HACK FROM HELL! */
-
-	if (file->f_flags & O_NONBLOCK) {
-		if (!mutex_trylock(&chip->open_mutex)) {
-			DPRINTK ("%s: returning -EAGAIN\n", __FUNCTION__);
-			return -EAGAIN;
-		}
-	}
-	else {
-		if (mutex_lock_interruptible(&chip->open_mutex)) {
-			DPRINTK ("%s: returning -ERESTARTSYS\n", __FUNCTION__);
-			return -ERESTARTSYS;
-		}
-	}
-
-	file->private_data = forte;
-
-	DPRINTK ("%s: dsp opened by %d\n", __FUNCTION__, current->pid);
-
-	if (file->f_mode & FMODE_WRITE)
-		forte_channel_init (forte, &forte->play);
-
-	if (file->f_mode & FMODE_READ)
-		forte_channel_init (forte, &forte->rec);
-
-	return nonseekable_open(inode, file);
-}
-
-
-/**
- * forte_dsp_release:
- */
-
-static int 
-forte_dsp_release (struct inode *inode, struct file *file)
-{
-	struct forte_chip *chip = file->private_data;
-	int ret = 0;
-
-	DPRINTK ("%s: chip @ %p\n", __FUNCTION__, chip);
-
-	if (file->f_mode & FMODE_WRITE) {
-		forte_channel_drain (&chip->play);
-
-		spin_lock_irq (&chip->lock);
-
- 		forte_channel_free (chip, &chip->play);
-
-		spin_unlock_irq (&chip->lock);
-        }
-
-	if (file->f_mode & FMODE_READ) {
-		while (chip->rec.filled_frags > 0)
-			interruptible_sleep_on (&chip->rec.wait);
-
-		spin_lock_irq (&chip->lock);
-
-		forte_channel_stop (&chip->rec);
-		forte_channel_free (chip, &chip->rec);
-
-		spin_unlock_irq (&chip->lock);
-	}
-
-	mutex_unlock(&chip->open_mutex);
-
-	return ret;
-}
-
-
-/**
- * forte_dsp_poll:
- *
- */
-
-static unsigned int 
-forte_dsp_poll (struct file *file, struct poll_table_struct *wait)
-{
-	struct forte_chip *chip;
-	struct forte_channel *channel;
-	unsigned int mask = 0;
-
-	chip = file->private_data;
-
-	if (file->f_mode & FMODE_WRITE) {
-		channel = &chip->play;
-
-		if (channel->active)
-			poll_wait (file, &channel->wait, wait);
-
-		spin_lock_irq (&chip->lock);
-
-		if (channel->frag_num - channel->filled_frags > 0)
-			mask |= POLLOUT | POLLWRNORM;
-
-		spin_unlock_irq (&chip->lock);
-	}
-
-	if (file->f_mode & FMODE_READ) {
-		channel = &chip->rec;
-
-		if (channel->active)
-			poll_wait (file, &channel->wait, wait);
-
-		spin_lock_irq (&chip->lock);
-
-		if (channel->filled_frags > 0)
-			mask |= POLLIN | POLLRDNORM;
-
-		spin_unlock_irq (&chip->lock);
-	}
-
-	return mask;
-}
-
-
-/**
- * forte_dsp_mmap:
- */
-
-static int
-forte_dsp_mmap (struct file *file, struct vm_area_struct *vma)
-{
-	struct forte_chip *chip;
-	struct forte_channel *channel;
-	unsigned long size;
-	int ret;
-
-	chip = file->private_data;
-
-	DPRINTK ("%s: start %lXh, size %ld, pgoff %ld\n", __FUNCTION__,
-                 vma->vm_start, vma->vm_end - vma->vm_start, vma->vm_pgoff);
-
-	spin_lock_irq (&chip->lock);
-
-	if (vma->vm_flags & VM_WRITE && chip->play.active) {
-		ret = -EBUSY;
-		goto out;
-	}
-
-        if (vma->vm_flags & VM_READ && chip->rec.active) {
-		ret = -EBUSY;
-		goto out;
-        }
-
-	if (file->f_mode & FMODE_WRITE)
-		channel = &chip->play;
-	else if (file->f_mode & FMODE_READ)
-		channel = &chip->rec;
-	else {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	forte_channel_prep (channel);
-	channel->mapped = 1;
-
-        if (vma->vm_pgoff != 0) {
-		ret = -EINVAL;
-                goto out;
-	}
-
-        size = vma->vm_end - vma->vm_start;
-
-        if (size > channel->buf_pages * PAGE_SIZE) {
-		DPRINTK ("%s: size (%ld) > buf_sz (%d) \n", __FUNCTION__,
-			 size, channel->buf_sz);
-		ret = -EINVAL;
-                goto out;
-	}
-
-        if (remap_pfn_range(vma, vma->vm_start,
-			      virt_to_phys(channel->buf) >> PAGE_SHIFT,
-			      size, vma->vm_page_prot)) {
-		DPRINTK ("%s: remap el a no worko\n", __FUNCTION__);
-		ret = -EAGAIN;
-                goto out;
-	}
-
-        ret = 0;
-
- out:
-	spin_unlock_irq (&chip->lock);
-        return ret;
-}
-
-
-/**
- * forte_dsp_write:
- */
-
-static ssize_t 
-forte_dsp_write (struct file *file, const char __user *buffer, size_t bytes, 
-		 loff_t *ppos)
-{
-	struct forte_chip *chip;
-	struct forte_channel *channel;
-	unsigned int i = bytes, sz = 0;
-	unsigned long flags;
-
-	if (!access_ok (VERIFY_READ, buffer, bytes))
-		return -EFAULT;
-
-	chip = (struct forte_chip *) file->private_data;
-
-	if (!chip)
-		BUG();
-
-	channel = &chip->play;
-
-	if (!channel)
-		BUG();
-
-	spin_lock_irqsave (&chip->lock, flags);
-
-	/* Set up buffers with the right fragment size */
-	forte_channel_prep (channel);
-
-	while (i) {
-		/* All fragment buffers in use -> wait */
-		if (channel->frag_num - channel->filled_frags == 0) {
-			DECLARE_WAITQUEUE (wait, current);
-
-			/* For trigger or non-blocking operation, get out */
-			if (chip->trigger || file->f_flags & O_NONBLOCK) {
-				spin_unlock_irqrestore (&chip->lock, flags);
-				return -EAGAIN;
-			}
-
-			/* Otherwise wait for buffers */
-			add_wait_queue (&channel->wait, &wait);
-
-			for (;;) {
-				spin_unlock_irqrestore (&chip->lock, flags);
-
-				set_current_state (TASK_INTERRUPTIBLE);
-				schedule();
-
-				spin_lock_irqsave (&chip->lock, flags);
-
-				if (channel->frag_num - channel->filled_frags)
-					break;
-			}
-
-			remove_wait_queue (&channel->wait, &wait);
-			set_current_state (TASK_RUNNING);
-
-			if (signal_pending (current)) {
-				spin_unlock_irqrestore (&chip->lock, flags);
-				return -ERESTARTSYS;
-			}
-		}
-
-		if (channel->residue)
-			sz = channel->residue;
-		else if (i > channel->frag_sz)
-			sz = channel->frag_sz;
-		else
-			sz = i;
-
-		spin_unlock_irqrestore (&chip->lock, flags);
-
-		if (copy_from_user ((void *) channel->buf + channel->swptr, buffer, sz))
-			return -EFAULT;
-
-		spin_lock_irqsave (&chip->lock, flags);
-
-		/* Advance software pointer */
-		buffer += sz;
-		channel->swptr += sz;
-		channel->swptr %= channel->buf_sz;
-		i -= sz;
-
-		/* Only bump filled_frags if a full fragment has been written */
-		if (channel->swptr % channel->frag_sz == 0) {
-			channel->filled_frags++;
-			channel->residue = 0;
-		}
-		else
-			channel->residue = channel->frag_sz - sz;
-
-		/* If playback isn't active, start it */
-		if (channel->active == 0 && chip->trigger == 0)
-			forte_channel_start (channel);
-	}
-
-	spin_unlock_irqrestore (&chip->lock, flags);
-
-	return bytes - i;
-}
-
-
-/**
- * forte_dsp_read:
- */
-
-static ssize_t 
-forte_dsp_read (struct file *file, char __user *buffer, size_t bytes, 
-		loff_t *ppos)
-{
-	struct forte_chip *chip;
-	struct forte_channel *channel;
-	unsigned int i = bytes, sz;
-	unsigned long flags;
-
-	if (!access_ok (VERIFY_WRITE, buffer, bytes))
-		return -EFAULT;
-
-	chip = (struct forte_chip *) file->private_data;
-
-	if (!chip)
-		BUG();
-
-	channel = &chip->rec;
-
-	if (!channel)
-		BUG();
-
-	spin_lock_irqsave (&chip->lock, flags);
-
-	/* Set up buffers with the right fragment size */
-	forte_channel_prep (channel);
-
-	/* Start recording */
-	if (!chip->trigger)
-		forte_channel_start (channel);
-
-	while (i) {
-		/* No fragment buffers in use -> wait */
-		if (channel->filled_frags == 0) {
-			DECLARE_WAITQUEUE (wait, current);
-
-			/* For trigger mode operation, get out */
-			if (chip->trigger) {
-				spin_unlock_irqrestore (&chip->lock, flags);
-				return -EAGAIN;
-			}
-
-			add_wait_queue (&channel->wait, &wait);
-
-			for (;;) {
-				if (channel->active == 0)
-					break;
-
-				if (channel->filled_frags)
-					break;
-						
-				spin_unlock_irqrestore (&chip->lock, flags);
-
-				set_current_state (TASK_INTERRUPTIBLE);
-				schedule();
-
-				spin_lock_irqsave (&chip->lock, flags);
-			}
-
-			set_current_state (TASK_RUNNING);
-			remove_wait_queue (&channel->wait, &wait);
-		}
-
-		if (i > channel->frag_sz)
-			sz = channel->frag_sz;
-		else
-			sz = i;
-
-		spin_unlock_irqrestore (&chip->lock, flags);
-
-		if (copy_to_user (buffer, (void *)channel->buf+channel->swptr, sz)) {
-			DPRINTK ("%s: copy_to_user failed\n", __FUNCTION__);
-			return -EFAULT;
-		}
-
-		spin_lock_irqsave (&chip->lock, flags);
-
-		/* Advance software pointer */
-		buffer += sz;
-		if (channel->filled_frags > 0)
-			channel->filled_frags--;
-		channel->swptr += channel->frag_sz;
-		channel->swptr %= channel->buf_sz;
-		i -= sz;
-	}
-
-	spin_unlock_irqrestore (&chip->lock, flags);
-
-	return bytes - i;
-}
-
-
-static struct file_operations forte_dsp_fops = {
-	.owner			= THIS_MODULE,
-	.llseek     		= &no_llseek,
-	.read       		= &forte_dsp_read,
-	.write      		= &forte_dsp_write,
-	.poll       		= &forte_dsp_poll,
-	.ioctl      		= &forte_dsp_ioctl,
-	.open       		= &forte_dsp_open,
-	.release    		= &forte_dsp_release,
-	.mmap			= &forte_dsp_mmap,
-};
-
-
-/* Common ------------------------------------------------------------------ */
-
-
-/**
- * forte_interrupt:
- */
-
-static irqreturn_t
-forte_interrupt (int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct forte_chip *chip = dev_id;
-	struct forte_channel *channel = NULL;
-	u16 status, count; 
-
-	status = inw (chip->iobase + FORTE_IRQ_STATUS);
-
-	/* If this is not for us, get outta here ASAP */
-	if ((status & (FORTE_IRQ_PLAYBACK | FORTE_IRQ_CAPTURE)) == 0)
-		return IRQ_NONE;
-	
-	if (status & FORTE_IRQ_PLAYBACK) {
-		channel = &chip->play;
-
-		spin_lock (&chip->lock);
-
-		if (channel->frag_sz == 0)
-			goto pack;
-
-		/* Declare a fragment done */
-		if (channel->filled_frags > 0)
-			channel->filled_frags--;
-		channel->bytes += channel->frag_sz;
-		channel->nr_irqs++;
-		
-		/* Flip-flop between buffer I and II */
-		channel->next_buf ^= 1;
-
-		/* Advance hardware pointer by fragment size and wrap around */
-		channel->hwptr += channel->frag_sz;
-		channel->hwptr %= channel->buf_sz;
-
-		/* Buffer I or buffer II BAR */
-                outl (channel->buf_handle + channel->hwptr, 
-		      channel->next_buf == 0 ?
-		      channel->iobase + FORTE_PLY_BUF1 :
-		      channel->iobase + FORTE_PLY_BUF2);
-
-		/* If the currently playing fragment is last, schedule pause */
-		if (channel->filled_frags == 1) 
-			forte_channel_pause (channel);
-
-	pack:
-		/* Acknowledge interrupt */
-                outw (FORTE_IRQ_PLAYBACK, chip->iobase + FORTE_IRQ_STATUS);
-
-		if (waitqueue_active (&channel->wait)) 
-			wake_up_all (&channel->wait);
-
-		spin_unlock (&chip->lock);
-	}
-
-	if (status & FORTE_IRQ_CAPTURE) {
-		channel = &chip->rec;
-		spin_lock (&chip->lock);
-
-		/* One fragment filled */
-		channel->filled_frags++;
-
-		/* Get # of completed bytes */
-		count = inw (channel->iobase + FORTE_PLY_COUNT) + 1;
-
-		if (count == 0) {
-			DPRINTK ("%s: last, filled_frags = %d\n", __FUNCTION__,
-				 channel->filled_frags);
-			channel->filled_frags = 0;
-			goto rack;
-		}
-
-		/* Buffer I or buffer II BAR */
-                outl (channel->buf_handle + channel->hwptr, 
-		      channel->next_buf == 0 ?
-		      channel->iobase + FORTE_PLY_BUF1 :
-		      channel->iobase + FORTE_PLY_BUF2);
-
-		/* Flip-flop between buffer I and II */
-		channel->next_buf ^= 1;
-
-		/* Advance hardware pointer by fragment size and wrap around */
-		channel->hwptr += channel->frag_sz;
-		channel->hwptr %= channel->buf_sz;
-
-		/* Out of buffers */
-		if (channel->filled_frags == channel->frag_num - 1)
-			forte_channel_stop (channel);
-	rack:
-		/* Acknowledge interrupt */
-                outw (FORTE_IRQ_CAPTURE, chip->iobase + FORTE_IRQ_STATUS);
-
-		spin_unlock (&chip->lock);
-
-		if (waitqueue_active (&channel->wait))
-			wake_up_all (&channel->wait);		
-	}
-
-	return IRQ_HANDLED;
-}
-
-
-/**
- * forte_proc_read:
- */
-
-static int
-forte_proc_read (char *page, char **start, off_t off, int count, 
-		 int *eof, void *data)
-{
-	int i = 0, p_rate, p_chan, r_rate;
-	unsigned short p_reg, r_reg;
-
-	i += sprintf (page, "ForteMedia FM801 OSS Lite driver\n%s\n \n", 
-		      DRIVER_VERSION);
-
-	if (!forte->iobase)
-		return i;
-
-	p_rate = p_chan = -1;
-	p_reg  = inw (forte->iobase + FORTE_PLY_CTRL);
-	p_rate = (p_reg >> 8) & 15;
-	p_chan = (p_reg >> 12) & 3;
-
- 	if (p_rate >= 0 || p_rate <= 10)
-		p_rate = rates[p_rate];
-
-	if (p_chan >= 0 || p_chan <= 2)
-		p_chan = channels[p_chan];
-
-	r_rate = -1;
-	r_reg  = inw (forte->iobase + FORTE_CAP_CTRL);
-	r_rate = (r_reg >> 8) & 15;
-
- 	if (r_rate >= 0 || r_rate <= 10)
-		r_rate = rates[r_rate]; 
-
-	i += sprintf (page + i,
-		      "             Playback  Capture\n"
-		      "FIFO empty : %-3s       %-3s\n"
-		      "Buf1 Last  : %-3s       %-3s\n"
-		      "Buf2 Last  : %-3s       %-3s\n"
-		      "Started    : %-3s       %-3s\n"
-		      "Paused     : %-3s       %-3s\n"
-		      "Immed Stop : %-3s       %-3s\n"
-		      "Rate       : %-5d     %-5d\n"
-		      "Channels   : %-5d     -\n"
-		      "16-bit     : %-3s       %-3s\n"
-		      "Stereo     : %-3s       %-3s\n"
-		      " \n"
-		      "Buffer Sz  : %-6d    %-6d\n"
-		      "Frag Sz    : %-6d    %-6d\n"
-		      "Frag Num   : %-6d    %-6d\n"
-		      "Frag msecs : %-6d    %-6d\n"
-		      "Used Frags : %-6d    %-6d\n"
-		      "Mapped     : %-3s       %-3s\n",
-		      p_reg & 1<<0  ? "yes" : "no",
-		      r_reg & 1<<0  ? "yes" : "no",
-		      p_reg & 1<<1  ? "yes" : "no",
-		      r_reg & 1<<1  ? "yes" : "no",
-		      p_reg & 1<<2  ? "yes" : "no",
-		      r_reg & 1<<2  ? "yes" : "no",
-		      p_reg & 1<<5  ? "yes" : "no",
-		      r_reg & 1<<5  ? "yes" : "no",
-		      p_reg & 1<<6  ? "yes" : "no",
-		      r_reg & 1<<6  ? "yes" : "no",
-		      p_reg & 1<<7  ? "yes" : "no",
-		      r_reg & 1<<7  ? "yes" : "no",
-		      p_rate, r_rate,
-		      p_chan,
-		      p_reg & 1<<14 ? "yes" : "no",
-		      r_reg & 1<<14 ? "yes" : "no",
-		      p_reg & 1<<15 ? "yes" : "no",
-		      r_reg & 1<<15 ? "yes" : "no",
-		      forte->play.buf_sz,       forte->rec.buf_sz,
-		      forte->play.frag_sz,      forte->rec.frag_sz,
-		      forte->play.frag_num,     forte->rec.frag_num,
-		      forte->play.frag_msecs,   forte->rec.frag_msecs,
-		      forte->play.filled_frags, forte->rec.filled_frags,
-		      forte->play.mapped ? "yes" : "no",
-		      forte->rec.mapped ? "yes" : "no"
-		);
-
-	return i;
-}
-
-
-/**
- * forte_proc_init:
- *
- * Creates driver info entries in /proc
- */
-
-static int __init 
-forte_proc_init (void)
-{
-	if (!proc_mkdir ("driver/forte", NULL))
-		return -EIO;
-
-	if (!create_proc_read_entry ("driver/forte/chip", 0, NULL, forte_proc_read, forte)) {
-		remove_proc_entry ("driver/forte", NULL);
-		return -EIO;
-	}
-
-	if (!create_proc_read_entry("driver/forte/ac97", 0, NULL, ac97_read_proc, forte->ac97)) {
-		remove_proc_entry ("driver/forte/chip", NULL);
-		remove_proc_entry ("driver/forte", NULL);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-
-/**
- * forte_proc_remove:
- *
- * Removes driver info entries in /proc
- */
-
-static void
-forte_proc_remove (void)
-{
-	remove_proc_entry ("driver/forte/ac97", NULL);
-	remove_proc_entry ("driver/forte/chip", NULL);
-	remove_proc_entry ("driver/forte", NULL);	
-}
-
-
-/**
- * forte_chip_init:
- * @chip:	Chip instance to initialize
- *
- * Description:
- * 		Resets chip, configures codec and registers the driver with
- * 		the sound subsystem.
- *
- * 		Press and hold Start for 8 secs, then switch on Run
- * 		and hold for 4 seconds.  Let go of Start.  Numbers
- * 		assume a properly oiled TWG.
- */
-
-static int __devinit
-forte_chip_init (struct forte_chip *chip)
-{
-	u8 revision;
-	u16 cmdw;
-	struct ac97_codec *codec;
-
-	pci_read_config_byte (chip->pci_dev, PCI_REVISION_ID, &revision);
-
-	if (revision >= 0xB1) {
-		chip->multichannel = 1;
-		printk (KERN_INFO PFX "Multi-channel device detected.\n");
-	}
-
-	/* Reset chip */
-	outw (FORTE_CC_CODEC_RESET | FORTE_CC_AC97_RESET, 
-	      chip->iobase + FORTE_CODEC_CTRL);
-	udelay(100);
-	outw (0, chip->iobase + FORTE_CODEC_CTRL);
-
-	/* Request read from AC97 */
-	outw (FORTE_AC97_READ | (0 << FORTE_AC97_ADDR_SHIFT), 
-	      chip->iobase + FORTE_AC97_CMD);
-	mdelay(750);
-
-	if ((inw (chip->iobase + FORTE_AC97_CMD) & (3<<8)) != (1<<8)) {
-		printk (KERN_INFO PFX "AC97 codec not responding");
-		return -EIO;
-	}
-
-	/* Init volume */
-	outw (0x0808, chip->iobase + FORTE_PCM_VOL);
-	outw (0x9f1f, chip->iobase + FORTE_FM_VOL);
-	outw (0x8808, chip->iobase + FORTE_I2S_VOL);
-
-	/* I2S control - I2S mode */
-	outw (0x0003, chip->iobase + FORTE_I2S_MODE);
-
-	/* Interrupt setup - unmask PLAYBACK & CAPTURE */
-	cmdw = inw (chip->iobase + FORTE_IRQ_MASK);
-	cmdw &= ~0x0003;
-	outw (cmdw, chip->iobase + FORTE_IRQ_MASK);
-
-	/* Interrupt clear */
-	outw (FORTE_IRQ_PLAYBACK|FORTE_IRQ_CAPTURE, 
-	      chip->iobase + FORTE_IRQ_STATUS);
-
-	/* Set up the AC97 codec */
-	if ((codec = ac97_alloc_codec()) == NULL)
-		return -ENOMEM;
-	codec->private_data = chip;
-	codec->codec_read = forte_ac97_read;
-	codec->codec_write = forte_ac97_write;
-	codec->id = 0;
-
-	if (ac97_probe_codec (codec) == 0) {
-		printk (KERN_ERR PFX "codec probe failed\n");
-		ac97_release_codec(codec);
-		return -1;
-	}
-
-	/* Register mixer */
-	if ((codec->dev_mixer = 
-	     register_sound_mixer (&forte_mixer_fops, -1)) < 0) {
-		printk (KERN_ERR PFX "couldn't register mixer!\n");
-		ac97_release_codec(codec);
-		return -1;
-	}
-
-	chip->ac97 = codec;
-
-	/* Register DSP */
-	if ((chip->dsp = register_sound_dsp (&forte_dsp_fops, -1) ) < 0) {
-		printk (KERN_ERR PFX "couldn't register dsp!\n");
-		return -1;
-	}
-
-	/* Register with /proc */
-	if (forte_proc_init()) {
-		printk (KERN_ERR PFX "couldn't add entries to /proc!\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-
-/**
- * forte_probe:
- * @pci_dev:	PCI struct for probed device
- * @pci_id:	
- *
- * Description:
- *		Allocates chip instance, I/O region, and IRQ
- */
-static int __init 
-forte_probe (struct pci_dev *pci_dev, const struct pci_device_id *pci_id)
-{
-	struct forte_chip *chip;
-	int ret = 0;
-
-	/* FIXME: Support more than one chip */
-	if (found++)
-		return -EIO;
-
-	/* Ignition */
-	if (pci_enable_device (pci_dev))
-		return -EIO;
-
-	pci_set_master (pci_dev);
-
-	/* Allocate chip instance and configure */
-	forte = (struct forte_chip *) 
-		kmalloc (sizeof (struct forte_chip), GFP_KERNEL);
-	chip = forte;
-
-	if (chip == NULL) {
-		printk (KERN_WARNING PFX "Out of memory");
-		return -ENOMEM;
-	}
-
-	memset (chip, 0, sizeof (struct forte_chip));
-	chip->pci_dev = pci_dev;
-
-	mutex_init(&chip->open_mutex);
-	spin_lock_init (&chip->lock);
-	spin_lock_init (&chip->ac97_lock);
-
-	if (! request_region (pci_resource_start (pci_dev, 0),
-			      pci_resource_len (pci_dev, 0), DRIVER_NAME)) {
-		printk (KERN_WARNING PFX "Unable to reserve I/O space");
-		ret = -ENOMEM;
-		goto error;
-	}
-
-	chip->iobase = pci_resource_start (pci_dev, 0);
-	chip->irq = pci_dev->irq;
-
-	if (request_irq (chip->irq, forte_interrupt, IRQF_SHARED, DRIVER_NAME,
-			 chip)) {
-		printk (KERN_WARNING PFX "Unable to reserve IRQ");
-		ret = -EIO;
-		goto error;
-	}		
-	
-	pci_set_drvdata (pci_dev, chip);
-
-	printk (KERN_INFO PFX "FM801 chip found at 0x%04lX-0x%16llX IRQ %u\n",
-		chip->iobase, (unsigned long long)pci_resource_end (pci_dev, 0),
-		chip->irq);
-
-	/* Power it up */
-	if ((ret = forte_chip_init (chip)) == 0)
-		return 0;
-
- error:
-	if (chip->irq)
-		free_irq (chip->irq, chip);
-
-	if (chip->iobase) 
-		release_region (pci_resource_start (pci_dev, 0),
-				pci_resource_len (pci_dev, 0));
-		
-	kfree (chip);
-
-	return ret;
-}
-
-
-/**
- * forte_remove:
- * @pci_dev:	PCI device to unclaim
- *
- */
-
-static void 
-forte_remove (struct pci_dev *pci_dev)
-{
-	struct forte_chip *chip = pci_get_drvdata (pci_dev);
-
-	if (chip == NULL)
-		return;
-
-	/* Turn volume down to avoid popping */
-	outw (0x1f1f, chip->iobase + FORTE_PCM_VOL);
-	outw (0x1f1f, chip->iobase + FORTE_FM_VOL);
-	outw (0x1f1f, chip->iobase + FORTE_I2S_VOL);
-
-	forte_proc_remove();
-	free_irq (chip->irq, chip);
-	release_region (chip->iobase, pci_resource_len (pci_dev, 0));
-
-	unregister_sound_dsp (chip->dsp);
-	unregister_sound_mixer (chip->ac97->dev_mixer);
-	ac97_release_codec(chip->ac97);
-	kfree (chip);
-
-	printk (KERN_INFO PFX "driver released\n");
-}
-
-
-static struct pci_device_id forte_pci_ids[] = {
-	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ 0, }
-};
-
-
-static struct pci_driver forte_pci_driver = {
-	.name			= DRIVER_NAME,
-	.id_table		= forte_pci_ids,
-	.probe	 		= forte_probe,
-	.remove			= forte_remove,
-
-};
-
-
-/**
- * forte_init_module:
- *
- */
-
-static int __init
-forte_init_module (void)
-{
-	printk (KERN_INFO PFX DRIVER_VERSION "\n");
-
-	return pci_register_driver (&forte_pci_driver);
-}
-
-
-/**
- * forte_cleanup_module:
- *
- */
-
-static void __exit 
-forte_cleanup_module (void)
-{
-	pci_unregister_driver (&forte_pci_driver);
-}
-
-
-module_init(forte_init_module);
-module_exit(forte_cleanup_module);
-
-MODULE_AUTHOR("Martin K. Petersen <mkp@mkp.net>");
-MODULE_DESCRIPTION("ForteMedia FM801 OSS Driver");
-MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE (pci, forte_pci_ids);
--- linux-2.6.18.noarch/sound/oss/au1000.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/au1000.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2216 +0,0 @@
-/*
- *      au1000.c  --  Sound driver for Alchemy Au1000 MIPS Internet Edge
- *                    Processor.
- *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	stevel@mvista.com or source@mvista.com
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
- * Module command line parameters:
- *
- *  Supported devices:
- *  /dev/dsp    standard OSS /dev/dsp device
- *  /dev/mixer  standard OSS /dev/mixer device
- *
- * Notes:
- *
- *  1. Much of the OSS buffer allocation, ioctl's, and mmap'ing are
- *     taken, slightly modified or not at all, from the ES1371 driver,
- *     so refer to the credits in es1371.c for those. The rest of the
- *     code (probe, open, read, write, the ISR, etc.) is new.
- *
- *  Revision history
- *    06.27.2001  Initial version
- *    03.20.2002  Added mutex locks around read/write methods, to prevent
- *                simultaneous access on SMP or preemptible kernels. Also
- *                removed the counter/pointer fragment aligning at the end
- *                of read/write methods [stevel].
- *    03.21.2002  Add support for coherent DMA on the audio read/write DMA
- *                channels [stevel].
- *
- */
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/init.h>
-#include <linux/page-flags.h>
-#include <linux/poll.h>
-#include <linux/pci.h>
-#include <linux/bitops.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/smp_lock.h>
-#include <linux/ac97_codec.h>
-#include <linux/interrupt.h>
-#include <linux/mutex.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/mach-au1x00/au1000.h>
-#include <asm/mach-au1x00/au1000_dma.h>
-
-/* --------------------------------------------------------------------- */
-
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-#undef AU1000_DEBUG
-#undef AU1000_VERBOSE_DEBUG
-
-#define AU1000_MODULE_NAME "Au1000 audio"
-#define PFX AU1000_MODULE_NAME
-
-#ifdef AU1000_DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG PFX ": " format "\n" , ## arg)
-#else
-#define dbg(format, arg...) do {} while (0)
-#endif
-#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
-#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
-
-
-/* misc stuff */
-#define POLL_COUNT   0x5000
-#define AC97_EXT_DACS (AC97_EXTID_SDAC | AC97_EXTID_CDAC | AC97_EXTID_LDAC)
-
-/* Boot options */
-static int      vra = 0;	// 0 = no VRA, 1 = use VRA if codec supports it
-module_param(vra, bool, 0);
-MODULE_PARM_DESC(vra, "if 1 use VRA if codec supports it");
-
-
-/* --------------------------------------------------------------------- */
-
-struct au1000_state {
-	/* soundcore stuff */
-	int             dev_audio;
-
-#ifdef AU1000_DEBUG
-	/* debug /proc entry */
-	struct proc_dir_entry *ps;
-	struct proc_dir_entry *ac97_ps;
-#endif				/* AU1000_DEBUG */
-
-	struct ac97_codec codec;
-	unsigned        codec_base_caps;// AC'97 reg 00h, "Reset Register"
-	unsigned        codec_ext_caps;	// AC'97 reg 28h, "Extended Audio ID"
-	int             no_vra;	// do not use VRA
-
-	spinlock_t      lock;
-	struct mutex open_mutex;
-	struct mutex sem;
-	mode_t          open_mode;
-	wait_queue_head_t open_wait;
-
-	struct dmabuf {
-		unsigned int    dmanr;	// DMA Channel number
-		unsigned        sample_rate;	// Hz
-		unsigned src_factor;     // SRC interp/decimation (no vra)
-		unsigned        sample_size;	// 8 or 16
-		int             num_channels;	// 1 = mono, 2 = stereo, 4, 6
-		int dma_bytes_per_sample;// DMA bytes per audio sample frame
-		int user_bytes_per_sample;// User bytes per audio sample frame
-		int cnt_factor;          // user-to-DMA bytes per audio
-		//  sample frame
-		void           *rawbuf;
-		dma_addr_t      dmaaddr;
-		unsigned        buforder;
-		unsigned numfrag;        // # of DMA fragments in DMA buffer
-		unsigned        fragshift;
-		void           *nextIn;	// ptr to next-in to DMA buffer
-		void           *nextOut;// ptr to next-out from DMA buffer
-		int             count;	// current byte count in DMA buffer
-		unsigned        total_bytes;	// total bytes written or read
-		unsigned        error;	// over/underrun
-		wait_queue_head_t wait;
-		/* redundant, but makes calculations easier */
-		unsigned fragsize;       // user perception of fragment size
-		unsigned dma_fragsize;   // DMA (real) fragment size
-		unsigned dmasize;        // Total DMA buffer size
-		//   (mult. of DMA fragsize)
-		/* OSS stuff */
-		unsigned        mapped:1;
-		unsigned        ready:1;
-		unsigned        stopped:1;
-		unsigned        ossfragshift;
-		int             ossmaxfrags;
-		unsigned        subdivision;
-	} dma_dac      , dma_adc;
-} au1000_state;
-
-/* --------------------------------------------------------------------- */
-
-
-static inline unsigned ld2(unsigned int x)
-{
-	unsigned        r = 0;
-
-	if (x >= 0x10000) {
-		x >>= 16;
-		r += 16;
-	}
-	if (x >= 0x100) {
-		x >>= 8;
-		r += 8;
-	}
-	if (x >= 0x10) {
-		x >>= 4;
-		r += 4;
-	}
-	if (x >= 4) {
-		x >>= 2;
-		r += 2;
-	}
-	if (x >= 2)
-		r++;
-	return r;
-}
-
-/* --------------------------------------------------------------------- */
-
-static void au1000_delay(int msec)
-{
-	unsigned long   tmo;
-	signed long     tmo2;
-
-	if (in_interrupt())
-		return;
-
-	tmo = jiffies + (msec * HZ) / 1000;
-	for (;;) {
-		tmo2 = tmo - jiffies;
-		if (tmo2 <= 0)
-			break;
-		schedule_timeout(tmo2);
-	}
-}
-
-
-/* --------------------------------------------------------------------- */
-
-static u16 rdcodec(struct ac97_codec *codec, u8 addr)
-{
-	struct au1000_state *s = (struct au1000_state *)codec->private_data;
-	unsigned long   flags;
-	u32             cmd;
-	u16             data;
-	int             i;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	for (i = 0; i < POLL_COUNT; i++)
-		if (!(au_readl(AC97C_STATUS) & AC97C_CP))
-			break;
-	if (i == POLL_COUNT)
-		err("rdcodec: codec cmd pending expired!");
-
-	cmd = (u32) addr & AC97C_INDEX_MASK;
-	cmd |= AC97C_READ;	// read command
-	au_writel(cmd, AC97C_CMD);
-
-	/* now wait for the data */
-	for (i = 0; i < POLL_COUNT; i++)
-		if (!(au_readl(AC97C_STATUS) & AC97C_CP))
-			break;
-	if (i == POLL_COUNT) {
-		err("rdcodec: read poll expired!");
-		return 0;
-	}
-
-	data = au_readl(AC97C_CMD) & 0xffff;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	return data;
-}
-
-
-static void wrcodec(struct ac97_codec *codec, u8 addr, u16 data)
-{
-	struct au1000_state *s = (struct au1000_state *)codec->private_data;
-	unsigned long   flags;
-	u32             cmd;
-	int             i;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	for (i = 0; i < POLL_COUNT; i++)
-		if (!(au_readl(AC97C_STATUS) & AC97C_CP))
-			break;
-	if (i == POLL_COUNT)
-		err("wrcodec: codec cmd pending expired!");
-
-	cmd = (u32) addr & AC97C_INDEX_MASK;
-	cmd &= ~AC97C_READ;	// write command
-	cmd |= ((u32) data << AC97C_WD_BIT);	// OR in the data word
-	au_writel(cmd, AC97C_CMD);
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void waitcodec(struct ac97_codec *codec)
-{
-	u16             temp;
-	int             i;
-
-	/* codec_wait is used to wait for a ready state after
-	   an AC97C_RESET. */
-	au1000_delay(10);
-
-	// first poll the CODEC_READY tag bit
-	for (i = 0; i < POLL_COUNT; i++)
-		if (au_readl(AC97C_STATUS) & AC97C_READY)
-			break;
-	if (i == POLL_COUNT) {
-		err("waitcodec: CODEC_READY poll expired!");
-		return;
-	}
-	// get AC'97 powerdown control/status register
-	temp = rdcodec(codec, AC97_POWER_CONTROL);
-
-	// If anything is powered down, power'em up
-	if (temp & 0x7f00) {
-		// Power on
-		wrcodec(codec, AC97_POWER_CONTROL, 0);
-		au1000_delay(100);
-		// Reread
-		temp = rdcodec(codec, AC97_POWER_CONTROL);
-	}
-    
-	// Check if Codec REF,ANL,DAC,ADC ready
-	if ((temp & 0x7f0f) != 0x000f)
-		err("codec reg 26 status (0x%x) not ready!!", temp);
-}
-
-
-/* --------------------------------------------------------------------- */
-
-/* stop the ADC before calling */
-static void set_adc_rate(struct au1000_state *s, unsigned rate)
-{
-	struct dmabuf  *adc = &s->dma_adc;
-	struct dmabuf  *dac = &s->dma_dac;
-	unsigned        adc_rate, dac_rate;
-	u16             ac97_extstat;
-
-	if (s->no_vra) {
-		// calc SRC factor
-		adc->src_factor = ((96000 / rate) + 1) >> 1;
-		adc->sample_rate = 48000 / adc->src_factor;
-		return;
-	}
-
-	adc->src_factor = 1;
-
-	ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
-
-	rate = rate > 48000 ? 48000 : rate;
-
-	// enable VRA
-	wrcodec(&s->codec, AC97_EXTENDED_STATUS,
-		ac97_extstat | AC97_EXTSTAT_VRA);
-	// now write the sample rate
-	wrcodec(&s->codec, AC97_PCM_LR_ADC_RATE, (u16) rate);
-	// read it back for actual supported rate
-	adc_rate = rdcodec(&s->codec, AC97_PCM_LR_ADC_RATE);
-
-#ifdef AU1000_VERBOSE_DEBUG
-	dbg("%s: set to %d Hz", __FUNCTION__, adc_rate);
-#endif
-
-	// some codec's don't allow unequal DAC and ADC rates, in which case
-	// writing one rate reg actually changes both.
-	dac_rate = rdcodec(&s->codec, AC97_PCM_FRONT_DAC_RATE);
-	if (dac->num_channels > 2)
-		wrcodec(&s->codec, AC97_PCM_SURR_DAC_RATE, dac_rate);
-	if (dac->num_channels > 4)
-		wrcodec(&s->codec, AC97_PCM_LFE_DAC_RATE, dac_rate);
-
-	adc->sample_rate = adc_rate;
-	dac->sample_rate = dac_rate;
-}
-
-/* stop the DAC before calling */
-static void set_dac_rate(struct au1000_state *s, unsigned rate)
-{
-	struct dmabuf  *dac = &s->dma_dac;
-	struct dmabuf  *adc = &s->dma_adc;
-	unsigned        adc_rate, dac_rate;
-	u16             ac97_extstat;
-
-	if (s->no_vra) {
-		// calc SRC factor
-		dac->src_factor = ((96000 / rate) + 1) >> 1;
-		dac->sample_rate = 48000 / dac->src_factor;
-		return;
-	}
-
-	dac->src_factor = 1;
-
-	ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
-
-	rate = rate > 48000 ? 48000 : rate;
-
-	// enable VRA
-	wrcodec(&s->codec, AC97_EXTENDED_STATUS,
-		ac97_extstat | AC97_EXTSTAT_VRA);
-	// now write the sample rate
-	wrcodec(&s->codec, AC97_PCM_FRONT_DAC_RATE, (u16) rate);
-	// I don't support different sample rates for multichannel,
-	// so make these channels the same.
-	if (dac->num_channels > 2)
-		wrcodec(&s->codec, AC97_PCM_SURR_DAC_RATE, (u16) rate);
-	if (dac->num_channels > 4)
-		wrcodec(&s->codec, AC97_PCM_LFE_DAC_RATE, (u16) rate);
-	// read it back for actual supported rate
-	dac_rate = rdcodec(&s->codec, AC97_PCM_FRONT_DAC_RATE);
-
-#ifdef AU1000_VERBOSE_DEBUG
-	dbg("%s: set to %d Hz", __FUNCTION__, dac_rate);
-#endif
-
-	// some codec's don't allow unequal DAC and ADC rates, in which case
-	// writing one rate reg actually changes both.
-	adc_rate = rdcodec(&s->codec, AC97_PCM_LR_ADC_RATE);
-
-	dac->sample_rate = dac_rate;
-	adc->sample_rate = adc_rate;
-}
-
-static void stop_dac(struct au1000_state *s)
-{
-	struct dmabuf  *db = &s->dma_dac;
-	unsigned long   flags;
-
-	if (db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	disable_dma(db->dmanr);
-
-	db->stopped = 1;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void  stop_adc(struct au1000_state *s)
-{
-	struct dmabuf  *db = &s->dma_adc;
-	unsigned long   flags;
-
-	if (db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	disable_dma(db->dmanr);
-
-	db->stopped = 1;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-
-static void set_xmit_slots(int num_channels)
-{
-	u32 ac97_config = au_readl(AC97C_CONFIG) & ~AC97C_XMIT_SLOTS_MASK;
-
-	switch (num_channels) {
-	case 1:		// mono
-	case 2:		// stereo, slots 3,4
-		ac97_config |= (0x3 << AC97C_XMIT_SLOTS_BIT);
-		break;
-	case 4:		// stereo with surround, slots 3,4,7,8
-		ac97_config |= (0x33 << AC97C_XMIT_SLOTS_BIT);
-		break;
-	case 6:		// stereo with surround and center/LFE, slots 3,4,6,7,8,9
-		ac97_config |= (0x7b << AC97C_XMIT_SLOTS_BIT);
-		break;
-	}
-
-	au_writel(ac97_config, AC97C_CONFIG);
-}
-
-static void     set_recv_slots(int num_channels)
-{
-	u32 ac97_config = au_readl(AC97C_CONFIG) & ~AC97C_RECV_SLOTS_MASK;
-
-	/*
-	 * Always enable slots 3 and 4 (stereo). Slot 6 is
-	 * optional Mic ADC, which I don't support yet.
-	 */
-	ac97_config |= (0x3 << AC97C_RECV_SLOTS_BIT);
-
-	au_writel(ac97_config, AC97C_CONFIG);
-}
-
-static void start_dac(struct au1000_state *s)
-{
-	struct dmabuf  *db = &s->dma_dac;
-	unsigned long   flags;
-	unsigned long   buf1, buf2;
-
-	if (!db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	au_readl(AC97C_STATUS);	// read status to clear sticky bits
-
-	// reset Buffer 1 and 2 pointers to nextOut and nextOut+dma_fragsize
-	buf1 = virt_to_phys(db->nextOut);
-	buf2 = buf1 + db->dma_fragsize;
-	if (buf2 >= db->dmaaddr + db->dmasize)
-		buf2 -= db->dmasize;
-
-	set_xmit_slots(db->num_channels);
-
-	init_dma(db->dmanr);
-	if (get_dma_active_buffer(db->dmanr) == 0) {
-		clear_dma_done0(db->dmanr);	// clear DMA done bit
-		set_dma_addr0(db->dmanr, buf1);
-		set_dma_addr1(db->dmanr, buf2);
-	} else {
-		clear_dma_done1(db->dmanr);	// clear DMA done bit
-		set_dma_addr1(db->dmanr, buf1);
-		set_dma_addr0(db->dmanr, buf2);
-	}
-	set_dma_count(db->dmanr, db->dma_fragsize>>1);
-	enable_dma_buffers(db->dmanr);
-
-	start_dma(db->dmanr);
-
-#ifdef AU1000_VERBOSE_DEBUG
-	dump_au1000_dma_channel(db->dmanr);
-#endif
-
-	db->stopped = 0;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void start_adc(struct au1000_state *s)
-{
-	struct dmabuf  *db = &s->dma_adc;
-	unsigned long   flags;
-	unsigned long   buf1, buf2;
-
-	if (!db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	au_readl(AC97C_STATUS);	// read status to clear sticky bits
-
-	// reset Buffer 1 and 2 pointers to nextIn and nextIn+dma_fragsize
-	buf1 = virt_to_phys(db->nextIn);
-	buf2 = buf1 + db->dma_fragsize;
-	if (buf2 >= db->dmaaddr + db->dmasize)
-		buf2 -= db->dmasize;
-
-	set_recv_slots(db->num_channels);
-
-	init_dma(db->dmanr);
-	if (get_dma_active_buffer(db->dmanr) == 0) {
-		clear_dma_done0(db->dmanr);	// clear DMA done bit
-		set_dma_addr0(db->dmanr, buf1);
-		set_dma_addr1(db->dmanr, buf2);
-	} else {
-		clear_dma_done1(db->dmanr);	// clear DMA done bit
-		set_dma_addr1(db->dmanr, buf1);
-		set_dma_addr0(db->dmanr, buf2);
-	}
-	set_dma_count(db->dmanr, db->dma_fragsize>>1);
-	enable_dma_buffers(db->dmanr);
-
-	start_dma(db->dmanr);
-
-#ifdef AU1000_VERBOSE_DEBUG
-	dump_au1000_dma_channel(db->dmanr);
-#endif
-
-	db->stopped = 0;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-/* --------------------------------------------------------------------- */
-
-#define DMABUF_DEFAULTORDER (17-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-static inline void dealloc_dmabuf(struct au1000_state *s, struct dmabuf *db)
-{
-	struct page    *page, *pend;
-
-	if (db->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(db->rawbuf +
-				    (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			ClearPageReserved(page);
-		dma_free_noncoherent(NULL,
-				PAGE_SIZE << db->buforder,
-				db->rawbuf,
-				db->dmaaddr);
-	}
-	db->rawbuf = db->nextIn = db->nextOut = NULL;
-	db->mapped = db->ready = 0;
-}
-
-static int prog_dmabuf(struct au1000_state *s, struct dmabuf *db)
-{
-	int             order;
-	unsigned user_bytes_per_sec;
-	unsigned        bufs;
-	struct page    *page, *pend;
-	unsigned        rate = db->sample_rate;
-
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-		for (order = DMABUF_DEFAULTORDER;
-		     order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = dma_alloc_noncoherent(NULL,
-						PAGE_SIZE << order,
-						&db->dmaaddr,
-						0)))
-				break;
-		if (!db->rawbuf)
-			return -ENOMEM;
-		db->buforder = order;
-		/* now mark the pages as reserved;
-		   otherwise remap_pfn_range doesn't do what we want */
-		pend = virt_to_page(db->rawbuf +
-				    (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			SetPageReserved(page);
-	}
-
-	db->cnt_factor = 1;
-	if (db->sample_size == 8)
-		db->cnt_factor *= 2;
-	if (db->num_channels == 1)
-		db->cnt_factor *= 2;
-	db->cnt_factor *= db->src_factor;
-
-	db->count = 0;
-	db->nextIn = db->nextOut = db->rawbuf;
-
-	db->user_bytes_per_sample = (db->sample_size>>3) * db->num_channels;
-	db->dma_bytes_per_sample = 2 * ((db->num_channels == 1) ?
-					2 : db->num_channels);
-
-	user_bytes_per_sec = rate * db->user_bytes_per_sample;
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < user_bytes_per_sec)
-			db->fragshift = ld2(user_bytes_per_sec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(user_bytes_per_sec / 100 /
-				    (db->subdivision ? db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3;
-	}
-
-	db->fragsize = 1 << db->fragshift;
-	db->dma_fragsize = db->fragsize * db->cnt_factor;
-	db->numfrag = bufs / db->dma_fragsize;
-
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->fragsize = 1 << db->fragshift;
-		db->dma_fragsize = db->fragsize * db->cnt_factor;
-		db->numfrag = bufs / db->dma_fragsize;
-	}
-
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
-
-	db->dmasize = db->dma_fragsize * db->numfrag;
-	memset(db->rawbuf, 0, bufs);
-
-#ifdef AU1000_VERBOSE_DEBUG
-	dbg("rate=%d, samplesize=%d, channels=%d",
-	    rate, db->sample_size, db->num_channels);
-	dbg("fragsize=%d, cnt_factor=%d, dma_fragsize=%d",
-	    db->fragsize, db->cnt_factor, db->dma_fragsize);
-	dbg("numfrag=%d, dmasize=%d", db->numfrag, db->dmasize);
-#endif
-
-	db->ready = 1;
-	return 0;
-}
-
-static inline int prog_dmabuf_adc(struct au1000_state *s)
-{
-	stop_adc(s);
-	return prog_dmabuf(s, &s->dma_adc);
-
-}
-
-static inline int prog_dmabuf_dac(struct au1000_state *s)
-{
-	stop_dac(s);
-	return prog_dmabuf(s, &s->dma_dac);
-}
-
-
-/* hold spinlock for the following */
-static irqreturn_t dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct au1000_state *s = (struct au1000_state *) dev_id;
-	struct dmabuf  *dac = &s->dma_dac;
-	unsigned long   newptr;
-	u32 ac97c_stat, buff_done;
-
-	ac97c_stat = au_readl(AC97C_STATUS);
-#ifdef AU1000_VERBOSE_DEBUG
-	if (ac97c_stat & (AC97C_XU | AC97C_XO | AC97C_TE))
-		dbg("AC97C status = 0x%08x", ac97c_stat);
-#endif
-
-	if ((buff_done = get_dma_buffer_done(dac->dmanr)) == 0) {
-		/* fastpath out, to ease interrupt sharing */
-		return IRQ_HANDLED;
-	}
-
-	spin_lock(&s->lock);
-	
-	if (buff_done != (DMA_D0 | DMA_D1)) {
-		dac->nextOut += dac->dma_fragsize;
-		if (dac->nextOut >= dac->rawbuf + dac->dmasize)
-			dac->nextOut -= dac->dmasize;
-
-		/* update playback pointers */
-		newptr = virt_to_phys(dac->nextOut) + dac->dma_fragsize;
-		if (newptr >= dac->dmaaddr + dac->dmasize)
-			newptr -= dac->dmasize;
-
-		dac->count -= dac->dma_fragsize;
-		dac->total_bytes += dac->dma_fragsize;
-
-		if (dac->count <= 0) {
-#ifdef AU1000_VERBOSE_DEBUG
-			dbg("dac underrun");
-#endif
-			spin_unlock(&s->lock);
-			stop_dac(s);
-			spin_lock(&s->lock);
-			dac->count = 0;
-			dac->nextIn = dac->nextOut;
-		} else if (buff_done == DMA_D0) {
-			clear_dma_done0(dac->dmanr);	// clear DMA done bit
-			set_dma_count0(dac->dmanr, dac->dma_fragsize>>1);
-			set_dma_addr0(dac->dmanr, newptr);
-			enable_dma_buffer0(dac->dmanr);	// reenable
-		} else {
-			clear_dma_done1(dac->dmanr);	// clear DMA done bit
-			set_dma_count1(dac->dmanr, dac->dma_fragsize>>1);
-			set_dma_addr1(dac->dmanr, newptr);
-			enable_dma_buffer1(dac->dmanr);	// reenable
-		}
-	} else {
-		// both done bits set, we missed an interrupt
-		spin_unlock(&s->lock);
-		stop_dac(s);
-		spin_lock(&s->lock);
-
-		dac->nextOut += 2*dac->dma_fragsize;
-		if (dac->nextOut >= dac->rawbuf + dac->dmasize)
-			dac->nextOut -= dac->dmasize;
-
-		dac->count -= 2*dac->dma_fragsize;
-		dac->total_bytes += 2*dac->dma_fragsize;
-
-		if (dac->count > 0) {
-			spin_unlock(&s->lock);
-			start_dac(s);
-			spin_lock(&s->lock);
-		}
-	}
-
-	/* wake up anybody listening */
-	if (waitqueue_active(&dac->wait))
-		wake_up(&dac->wait);
-
-	spin_unlock(&s->lock);
-
-	return IRQ_HANDLED;
-}
-
-
-static irqreturn_t adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct au1000_state *s = (struct au1000_state *) dev_id;
-	struct dmabuf  *adc = &s->dma_adc;
-	unsigned long   newptr;
-	u32 ac97c_stat, buff_done;
-
-	ac97c_stat = au_readl(AC97C_STATUS);
-#ifdef AU1000_VERBOSE_DEBUG
-	if (ac97c_stat & (AC97C_RU | AC97C_RO))
-		dbg("AC97C status = 0x%08x", ac97c_stat);
-#endif
-
-	if ((buff_done = get_dma_buffer_done(adc->dmanr)) == 0) {
-		/* fastpath out, to ease interrupt sharing */
-		return IRQ_HANDLED;
-	}
-
-	spin_lock(&s->lock);
-	
-	if (buff_done != (DMA_D0 | DMA_D1)) {
-		if (adc->count + adc->dma_fragsize > adc->dmasize) {
-			// Overrun. Stop ADC and log the error
-			spin_unlock(&s->lock);
-			stop_adc(s);
-			adc->error++;
-			err("adc overrun");
-			return IRQ_NONE;
-		}
-
-		adc->nextIn += adc->dma_fragsize;
-		if (adc->nextIn >= adc->rawbuf + adc->dmasize)
-			adc->nextIn -= adc->dmasize;
-
-		/* update capture pointers */
-		newptr = virt_to_phys(adc->nextIn) + adc->dma_fragsize;
-		if (newptr >= adc->dmaaddr + adc->dmasize)
-			newptr -= adc->dmasize;
-
-		adc->count += adc->dma_fragsize;
-		adc->total_bytes += adc->dma_fragsize;
-
-		if (buff_done == DMA_D0) {
-			clear_dma_done0(adc->dmanr);	// clear DMA done bit
-			set_dma_count0(adc->dmanr, adc->dma_fragsize>>1);
-			set_dma_addr0(adc->dmanr, newptr);
-			enable_dma_buffer0(adc->dmanr);	// reenable
-		} else {
-			clear_dma_done1(adc->dmanr);	// clear DMA done bit
-			set_dma_count1(adc->dmanr, adc->dma_fragsize>>1);
-			set_dma_addr1(adc->dmanr, newptr);
-			enable_dma_buffer1(adc->dmanr);	// reenable
-		}
-	} else {
-		// both done bits set, we missed an interrupt
-		spin_unlock(&s->lock);
-		stop_adc(s);
-		spin_lock(&s->lock);
-		
-		if (adc->count + 2*adc->dma_fragsize > adc->dmasize) {
-			// Overrun. Log the error
-			adc->error++;
-			err("adc overrun");
-			spin_unlock(&s->lock);
-			return IRQ_NONE;
-		}
-
-		adc->nextIn += 2*adc->dma_fragsize;
-		if (adc->nextIn >= adc->rawbuf + adc->dmasize)
-			adc->nextIn -= adc->dmasize;
-
-		adc->count += 2*adc->dma_fragsize;
-		adc->total_bytes += 2*adc->dma_fragsize;
-		
-		spin_unlock(&s->lock);
-		start_adc(s);
-		spin_lock(&s->lock);
-	}
-
-	/* wake up anybody listening */
-	if (waitqueue_active(&adc->wait))
-		wake_up(&adc->wait);
-
-	spin_unlock(&s->lock);
-
-	return IRQ_HANDLED;
-}
-
-/* --------------------------------------------------------------------- */
-
-static loff_t au1000_llseek(struct file *file, loff_t offset, int origin)
-{
-	return -ESPIPE;
-}
-
-
-static int au1000_open_mixdev(struct inode *inode, struct file *file)
-{
-	file->private_data = &au1000_state;
-	return nonseekable_open(inode, file);
-}
-
-static int au1000_release_mixdev(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
-                        unsigned long arg)
-{
-	return codec->mixer_ioctl(codec, cmd, arg);
-}
-
-static int au1000_ioctl_mixdev(struct inode *inode, struct file *file,
-			       unsigned int cmd, unsigned long arg)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	struct ac97_codec *codec = &s->codec;
-
-	return mixdev_ioctl(codec, cmd, arg);
-}
-
-static /*const */ struct file_operations au1000_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= au1000_llseek,
-	.ioctl		= au1000_ioctl_mixdev,
-	.open		= au1000_open_mixdev,
-	.release	= au1000_release_mixdev,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct au1000_state *s, int nonblock)
-{
-	unsigned long   flags;
-	int             count, tmo;
-
-	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
-		return 0;
-
-	for (;;) {
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-			break;
-		if (nonblock)
-			return -EBUSY;
-		tmo = 1000 * count / (s->no_vra ?
-				      48000 : s->dma_dac.sample_rate);
-		tmo /= s->dma_dac.dma_bytes_per_sample;
-		au1000_delay(tmo);
-	}
-	if (signal_pending(current))
-		return -ERESTARTSYS;
-	return 0;
-}
-
-/* --------------------------------------------------------------------- */
-
-static inline u8 S16_TO_U8(s16 ch)
-{
-	return (u8) (ch >> 8) + 0x80;
-}
-static inline s16 U8_TO_S16(u8 ch)
-{
-	return (s16) (ch - 0x80) << 8;
-}
-
-/*
- * Translates user samples to dma buffer suitable for AC'97 DAC data:
- *     If mono, copy left channel to right channel in dma buffer.
- *     If 8 bit samples, cvt to 16-bit before writing to dma buffer.
- *     If interpolating (no VRA), duplicate every audio frame src_factor times.
- */
-static int translate_from_user(struct dmabuf *db,
-			       char* dmabuf,
-			       char* userbuf,
-			       int dmacount)
-{
-	int             sample, i;
-	int             interp_bytes_per_sample;
-	int             num_samples;
-	int             mono = (db->num_channels == 1);
-	char            usersample[12];
-	s16             ch, dmasample[6];
-
-	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
-		// no translation necessary, just copy
-		if (copy_from_user(dmabuf, userbuf, dmacount))
-			return -EFAULT;
-		return dmacount;
-	}
-
-	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
-	num_samples = dmacount / interp_bytes_per_sample;
-
-	for (sample = 0; sample < num_samples; sample++) {
-		if (copy_from_user(usersample, userbuf,
-				   db->user_bytes_per_sample)) {
-			dbg("%s: fault", __FUNCTION__);
-			return -EFAULT;
-		}
-
-		for (i = 0; i < db->num_channels; i++) {
-			if (db->sample_size == 8)
-				ch = U8_TO_S16(usersample[i]);
-			else
-				ch = *((s16 *) (&usersample[i * 2]));
-			dmasample[i] = ch;
-			if (mono)
-				dmasample[i + 1] = ch;	// right channel
-		}
-
-		// duplicate every audio frame src_factor times
-		for (i = 0; i < db->src_factor; i++)
-			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
-
-		userbuf += db->user_bytes_per_sample;
-		dmabuf += interp_bytes_per_sample;
-	}
-
-	return num_samples * interp_bytes_per_sample;
-}
-
-/*
- * Translates AC'97 ADC samples to user buffer:
- *     If mono, send only left channel to user buffer.
- *     If 8 bit samples, cvt from 16 to 8 bit before writing to user buffer.
- *     If decimating (no VRA), skip over src_factor audio frames.
- */
-static int translate_to_user(struct dmabuf *db,
-			     char* userbuf,
-			     char* dmabuf,
-			     int dmacount)
-{
-	int             sample, i;
-	int             interp_bytes_per_sample;
-	int             num_samples;
-	int             mono = (db->num_channels == 1);
-	char            usersample[12];
-
-	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
-		// no translation necessary, just copy
-		if (copy_to_user(userbuf, dmabuf, dmacount))
-			return -EFAULT;
-		return dmacount;
-	}
-
-	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
-	num_samples = dmacount / interp_bytes_per_sample;
-
-	for (sample = 0; sample < num_samples; sample++) {
-		for (i = 0; i < db->num_channels; i++) {
-			if (db->sample_size == 8)
-				usersample[i] =
-					S16_TO_U8(*((s16 *) (&dmabuf[i * 2])));
-			else
-				*((s16 *) (&usersample[i * 2])) =
-					*((s16 *) (&dmabuf[i * 2]));
-		}
-
-		if (copy_to_user(userbuf, usersample,
-				 db->user_bytes_per_sample)) {
-			dbg("%s: fault", __FUNCTION__);
-			return -EFAULT;
-		}
-
-		userbuf += db->user_bytes_per_sample;
-		dmabuf += interp_bytes_per_sample;
-	}
-
-	return num_samples * interp_bytes_per_sample;
-}
-
-/*
- * Copy audio data to/from user buffer from/to dma buffer, taking care
- * that we wrap when reading/writing the dma buffer. Returns actual byte
- * count written to or read from the dma buffer.
- */
-static int copy_dmabuf_user(struct dmabuf *db, char* userbuf,
-			    int count, int to_user)
-{
-	char           *bufptr = to_user ? db->nextOut : db->nextIn;
-	char           *bufend = db->rawbuf + db->dmasize;
-	int             cnt, ret;
-
-	if (bufptr + count > bufend) {
-		int             partial = (int) (bufend - bufptr);
-		if (to_user) {
-			if ((cnt = translate_to_user(db, userbuf,
-						     bufptr, partial)) < 0)
-				return cnt;
-			ret = cnt;
-			if ((cnt = translate_to_user(db, userbuf + partial,
-						     db->rawbuf,
-						     count - partial)) < 0)
-				return cnt;
-			ret += cnt;
-		} else {
-			if ((cnt = translate_from_user(db, bufptr, userbuf,
-						       partial)) < 0)
-				return cnt;
-			ret = cnt;
-			if ((cnt = translate_from_user(db, db->rawbuf,
-						       userbuf + partial,
-						       count - partial)) < 0)
-				return cnt;
-			ret += cnt;
-		}
-	} else {
-		if (to_user)
-			ret = translate_to_user(db, userbuf, bufptr, count);
-		else
-			ret = translate_from_user(db, bufptr, userbuf, count);
-	}
-
-	return ret;
-}
-
-
-static ssize_t au1000_read(struct file *file, char *buffer,
-			   size_t count, loff_t *ppos)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	struct dmabuf  *db = &s->dma_adc;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t         ret;
-	unsigned long   flags;
-	int             cnt, usercnt, avail;
-
-	if (db->mapped)
-		return -ENXIO;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-
-	count *= db->cnt_factor;
-
-	mutex_lock(&s->sem);
-	add_wait_queue(&db->wait, &wait);
-
-	while (count > 0) {
-		// wait for samples in ADC dma buffer
-		do {
-			if (db->stopped)
-				start_adc(s);
-			spin_lock_irqsave(&s->lock, flags);
-			avail = db->count;
-			if (avail <= 0)
-				__set_current_state(TASK_INTERRUPTIBLE);
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (avail <= 0) {
-				if (file->f_flags & O_NONBLOCK) {
-					if (!ret)
-						ret = -EAGAIN;
-					goto out;
-				}
-				mutex_unlock(&s->sem);
-				schedule();
-				if (signal_pending(current)) {
-					if (!ret)
-						ret = -ERESTARTSYS;
-					goto out2;
-				}
-				mutex_lock(&s->sem);
-			}
-		} while (avail <= 0);
-
-		// copy from nextOut to user
-		if ((cnt = copy_dmabuf_user(db, buffer,
-					    count > avail ?
-					    avail : count, 1)) < 0) {
-			if (!ret)
-				ret = -EFAULT;
-			goto out;
-		}
-
-		spin_lock_irqsave(&s->lock, flags);
-		db->count -= cnt;
-		db->nextOut += cnt;
-		if (db->nextOut >= db->rawbuf + db->dmasize)
-			db->nextOut -= db->dmasize;
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		count -= cnt;
-		usercnt = cnt / db->cnt_factor;
-		buffer += usercnt;
-		ret += usercnt;
-	}			// while (count > 0)
-
-out:
-	mutex_unlock(&s->sem);
-out2:
-	remove_wait_queue(&db->wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-static ssize_t au1000_write(struct file *file, const char *buffer,
-	     		    size_t count, loff_t * ppos)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	struct dmabuf  *db = &s->dma_dac;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t         ret = 0;
-	unsigned long   flags;
-	int             cnt, usercnt, avail;
-
-#ifdef AU1000_VERBOSE_DEBUG
-	dbg("write: count=%d", count);
-#endif
-
-	if (db->mapped)
-		return -ENXIO;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-
-	count *= db->cnt_factor;
-
-	mutex_lock(&s->sem);
-	add_wait_queue(&db->wait, &wait);
-
-	while (count > 0) {
-		// wait for space in playback buffer
-		do {
-			spin_lock_irqsave(&s->lock, flags);
-			avail = (int) db->dmasize - db->count;
-			if (avail <= 0)
-				__set_current_state(TASK_INTERRUPTIBLE);
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (avail <= 0) {
-				if (file->f_flags & O_NONBLOCK) {
-					if (!ret)
-						ret = -EAGAIN;
-					goto out;
-				}
-				mutex_unlock(&s->sem);
-				schedule();
-				if (signal_pending(current)) {
-					if (!ret)
-						ret = -ERESTARTSYS;
-					goto out2;
-				}
-				mutex_lock(&s->sem);
-			}
-		} while (avail <= 0);
-
-		// copy from user to nextIn
-		if ((cnt = copy_dmabuf_user(db, (char *) buffer,
-					    count > avail ?
-					    avail : count, 0)) < 0) {
-			if (!ret)
-				ret = -EFAULT;
-			goto out;
-		}
-
-		spin_lock_irqsave(&s->lock, flags);
-		db->count += cnt;
-		db->nextIn += cnt;
-		if (db->nextIn >= db->rawbuf + db->dmasize)
-			db->nextIn -= db->dmasize;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (db->stopped)
-			start_dac(s);
-
-		count -= cnt;
-		usercnt = cnt / db->cnt_factor;
-		buffer += usercnt;
-		ret += usercnt;
-	}			// while (count > 0)
-
-out:
-	mutex_unlock(&s->sem);
-out2:
-	remove_wait_queue(&db->wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int au1000_poll(struct file *file,
-				struct poll_table_struct *wait)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	unsigned long   flags;
-	unsigned int    mask = 0;
-
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac.ready)
-			return 0;
-		poll_wait(file, &s->dma_dac.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!s->dma_adc.ready)
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-
-	spin_lock_irqsave(&s->lock, flags);
-	
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.count >= (signed)s->dma_adc.dma_fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >=
-			    (signed)s->dma_dac.dma_fragsize) 
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed) s->dma_dac.dmasize >=
-			    s->dma_dac.count + (signed)s->dma_dac.dma_fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int au1000_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	struct dmabuf  *db;
-	unsigned long   size;
-	int ret = 0;
-
-	dbg("%s", __FUNCTION__);
-    
-	lock_kernel();
-	mutex_lock(&s->sem);
-	if (vma->vm_flags & VM_WRITE)
-		db = &s->dma_dac;
-	else if (vma->vm_flags & VM_READ)
-		db = &s->dma_adc;
-	else {
-		ret = -EINVAL;
-		goto out;
-	}
-	if (vma->vm_pgoff != 0) {
-		ret = -EINVAL;
-		goto out;
-	}
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder)) {
-		ret = -EINVAL;
-		goto out;
-	}
-	if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(db->rawbuf),
-			     size, vma->vm_page_prot)) {
-		ret = -EAGAIN;
-		goto out;
-	}
-	vma->vm_flags &= ~VM_IO;
-	db->mapped = 1;
-out:
-	mutex_unlock(&s->sem);
-	unlock_kernel();
-	return ret;
-}
-
-
-#ifdef AU1000_VERBOSE_DEBUG
-static struct ioctl_str_t {
-	unsigned int    cmd;
-	const char     *str;
-} ioctl_str[] = {
-	{SNDCTL_DSP_RESET, "SNDCTL_DSP_RESET"},
-	{SNDCTL_DSP_SYNC, "SNDCTL_DSP_SYNC"},
-	{SNDCTL_DSP_SPEED, "SNDCTL_DSP_SPEED"},
-	{SNDCTL_DSP_STEREO, "SNDCTL_DSP_STEREO"},
-	{SNDCTL_DSP_GETBLKSIZE, "SNDCTL_DSP_GETBLKSIZE"},
-	{SNDCTL_DSP_SAMPLESIZE, "SNDCTL_DSP_SAMPLESIZE"},
-	{SNDCTL_DSP_CHANNELS, "SNDCTL_DSP_CHANNELS"},
-	{SOUND_PCM_WRITE_CHANNELS, "SOUND_PCM_WRITE_CHANNELS"},
-	{SOUND_PCM_WRITE_FILTER, "SOUND_PCM_WRITE_FILTER"},
-	{SNDCTL_DSP_POST, "SNDCTL_DSP_POST"},
-	{SNDCTL_DSP_SUBDIVIDE, "SNDCTL_DSP_SUBDIVIDE"},
-	{SNDCTL_DSP_SETFRAGMENT, "SNDCTL_DSP_SETFRAGMENT"},
-	{SNDCTL_DSP_GETFMTS, "SNDCTL_DSP_GETFMTS"},
-	{SNDCTL_DSP_SETFMT, "SNDCTL_DSP_SETFMT"},
-	{SNDCTL_DSP_GETOSPACE, "SNDCTL_DSP_GETOSPACE"},
-	{SNDCTL_DSP_GETISPACE, "SNDCTL_DSP_GETISPACE"},
-	{SNDCTL_DSP_NONBLOCK, "SNDCTL_DSP_NONBLOCK"},
-	{SNDCTL_DSP_GETCAPS, "SNDCTL_DSP_GETCAPS"},
-	{SNDCTL_DSP_GETTRIGGER, "SNDCTL_DSP_GETTRIGGER"},
-	{SNDCTL_DSP_SETTRIGGER, "SNDCTL_DSP_SETTRIGGER"},
-	{SNDCTL_DSP_GETIPTR, "SNDCTL_DSP_GETIPTR"},
-	{SNDCTL_DSP_GETOPTR, "SNDCTL_DSP_GETOPTR"},
-	{SNDCTL_DSP_MAPINBUF, "SNDCTL_DSP_MAPINBUF"},
-	{SNDCTL_DSP_MAPOUTBUF, "SNDCTL_DSP_MAPOUTBUF"},
-	{SNDCTL_DSP_SETSYNCRO, "SNDCTL_DSP_SETSYNCRO"},
-	{SNDCTL_DSP_SETDUPLEX, "SNDCTL_DSP_SETDUPLEX"},
-	{SNDCTL_DSP_GETODELAY, "SNDCTL_DSP_GETODELAY"},
-	{SNDCTL_DSP_GETCHANNELMASK, "SNDCTL_DSP_GETCHANNELMASK"},
-	{SNDCTL_DSP_BIND_CHANNEL, "SNDCTL_DSP_BIND_CHANNEL"},
-	{OSS_GETVERSION, "OSS_GETVERSION"},
-	{SOUND_PCM_READ_RATE, "SOUND_PCM_READ_RATE"},
-	{SOUND_PCM_READ_CHANNELS, "SOUND_PCM_READ_CHANNELS"},
-	{SOUND_PCM_READ_BITS, "SOUND_PCM_READ_BITS"},
-	{SOUND_PCM_READ_FILTER, "SOUND_PCM_READ_FILTER"}
-};
-#endif
-
-// Need to hold a spin-lock before calling this!
-static int dma_count_done(struct dmabuf *db)
-{
-	if (db->stopped)
-		return 0;
-
-	return db->dma_fragsize - get_dma_residue(db->dmanr);
-}
-
-
-static int au1000_ioctl(struct inode *inode, struct file *file,
-                        unsigned int cmd, unsigned long arg)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-	unsigned long   flags;
-	audio_buf_info  abinfo;
-	count_info      cinfo;
-	int             count;
-	int             val, mapped, ret, diff;
-
-	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-
-#ifdef AU1000_VERBOSE_DEBUG
-	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
-		if (ioctl_str[count].cmd == cmd)
-			break;
-	}
-	if (count < sizeof(ioctl_str) / sizeof(ioctl_str[0]))
-		dbg("ioctl %s, arg=0x%lx", ioctl_str[count].str, arg);
-	else
-		dbg("ioctl 0x%x unknown, arg=0x%lx", cmd, arg);
-#endif
-
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, (int *) arg);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s, file->f_flags & O_NONBLOCK);
-		return 0;
-
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
-				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
-
-	case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq();
-			s->dma_dac.count = s->dma_dac.total_bytes = 0;
-			s->dma_dac.nextIn = s->dma_dac.nextOut =
-				s->dma_dac.rawbuf;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq();
-			s->dma_adc.count = s->dma_adc.total_bytes = 0;
-			s->dma_adc.nextIn = s->dma_adc.nextOut =
-				s->dma_adc.rawbuf;
-		}
-		return 0;
-
-	case SNDCTL_DSP_SPEED:
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (val >= 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				set_adc_rate(s, val);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				set_dac_rate(s, val);
-			}
-			if (s->open_mode & FMODE_READ)
-				if ((ret = prog_dmabuf_adc(s)))
-					return ret;
-			if (s->open_mode & FMODE_WRITE)
-				if ((ret = prog_dmabuf_dac(s)))
-					return ret;
-		}
-		return put_user((file->f_mode & FMODE_READ) ?
-				s->dma_adc.sample_rate :
-				s->dma_dac.sample_rate,
-				(int *)arg);
-
-	case SNDCTL_DSP_STEREO:
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.num_channels = val ? 2 : 1;
-			if ((ret = prog_dmabuf_adc(s)))
-				return ret;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.num_channels = val ? 2 : 1;
-			if (s->codec_ext_caps & AC97_EXT_DACS) {
-				// disable surround and center/lfe in AC'97
-				u16 ext_stat = rdcodec(&s->codec,
-						       AC97_EXTENDED_STATUS);
-				wrcodec(&s->codec, AC97_EXTENDED_STATUS,
-					ext_stat | (AC97_EXTSTAT_PRI |
-						    AC97_EXTSTAT_PRJ |
-						    AC97_EXTSTAT_PRK));
-			}
-			if ((ret = prog_dmabuf_dac(s)))
-				return ret;
-		}
-		return 0;
-
-	case SNDCTL_DSP_CHANNELS:
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (val != 0) {
-			if (file->f_mode & FMODE_READ) {
-				if (val < 0 || val > 2)
-					return -EINVAL;
-				stop_adc(s);
-				s->dma_adc.num_channels = val;
-				if ((ret = prog_dmabuf_adc(s)))
-					return ret;
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				switch (val) {
-				case 1:
-				case 2:
-					break;
-				case 3:
-				case 5:
-					return -EINVAL;
-				case 4:
-					if (!(s->codec_ext_caps &
-					      AC97_EXTID_SDAC))
-						return -EINVAL;
-					break;
-				case 6:
-					if ((s->codec_ext_caps &
-					     AC97_EXT_DACS) != AC97_EXT_DACS)
-						return -EINVAL;
-					break;
-				default:
-					return -EINVAL;
-				}
-
-				stop_dac(s);
-				if (val <= 2 &&
-				    (s->codec_ext_caps & AC97_EXT_DACS)) {
-					// disable surround and center/lfe
-					// channels in AC'97
-					u16             ext_stat =
-						rdcodec(&s->codec,
-							AC97_EXTENDED_STATUS);
-					wrcodec(&s->codec,
-						AC97_EXTENDED_STATUS,
-						ext_stat | (AC97_EXTSTAT_PRI |
-							    AC97_EXTSTAT_PRJ |
-							    AC97_EXTSTAT_PRK));
-				} else if (val >= 4) {
-					// enable surround, center/lfe
-					// channels in AC'97
-					u16             ext_stat =
-						rdcodec(&s->codec,
-							AC97_EXTENDED_STATUS);
-					ext_stat &= ~AC97_EXTSTAT_PRJ;
-					if (val == 6)
-						ext_stat &=
-							~(AC97_EXTSTAT_PRI |
-							  AC97_EXTSTAT_PRK);
-					wrcodec(&s->codec,
-						AC97_EXTENDED_STATUS,
-						ext_stat);
-				}
-
-				s->dma_dac.num_channels = val;
-				if ((ret = prog_dmabuf_dac(s)))
-					return ret;
-			}
-		}
-		return put_user(val, (int *) arg);
-
-	case SNDCTL_DSP_GETFMTS:	/* Returns a mask */
-		return put_user(AFMT_S16_LE | AFMT_U8, (int *) arg);
-
-	case SNDCTL_DSP_SETFMT:	/* Selects ONE fmt */
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				if (val == AFMT_S16_LE)
-					s->dma_adc.sample_size = 16;
-				else {
-					val = AFMT_U8;
-					s->dma_adc.sample_size = 8;
-				}
-				if ((ret = prog_dmabuf_adc(s)))
-					return ret;
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				if (val == AFMT_S16_LE)
-					s->dma_dac.sample_size = 16;
-				else {
-					val = AFMT_U8;
-					s->dma_dac.sample_size = 8;
-				}
-				if ((ret = prog_dmabuf_dac(s)))
-					return ret;
-			}
-		} else {
-			if (file->f_mode & FMODE_READ)
-				val = (s->dma_adc.sample_size == 16) ?
-					AFMT_S16_LE : AFMT_U8;
-			else
-				val = (s->dma_dac.sample_size == 16) ?
-					AFMT_S16_LE : AFMT_U8;
-		}
-		return put_user(val, (int *) arg);
-
-	case SNDCTL_DSP_POST:
-		return 0;
-
-	case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		spin_lock_irqsave(&s->lock, flags);
-		if (file->f_mode & FMODE_READ && !s->dma_adc.stopped)
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && !s->dma_dac.stopped)
-			val |= PCM_ENABLE_OUTPUT;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return put_user(val, (int *) arg);
-
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT)
-				start_adc(s);
-			else
-				stop_adc(s);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT)
-				start_dac(s);
-			else
-				stop_dac(s);
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		abinfo.fragsize = s->dma_dac.fragsize;
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		count -= dma_count_done(&s->dma_dac);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		abinfo.bytes = (s->dma_dac.dmasize - count) /
-			s->dma_dac.cnt_factor;
-		abinfo.fragstotal = s->dma_dac.numfrag;
-		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
-#ifdef AU1000_VERBOSE_DEBUG
-		dbg("bytes=%d, fragments=%d", abinfo.bytes, abinfo.fragments);
-#endif
-		return copy_to_user((void *) arg, &abinfo,
-				    sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		abinfo.fragsize = s->dma_adc.fragsize;
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_adc.count;
-		count += dma_count_done(&s->dma_adc);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		abinfo.bytes = count / s->dma_adc.cnt_factor;
-		abinfo.fragstotal = s->dma_adc.numfrag;
-		abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;
-		return copy_to_user((void *) arg, &abinfo,
-				    sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_NONBLOCK:
-		file->f_flags |= O_NONBLOCK;
-		return 0;
-
-	case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		count -= dma_count_done(&s->dma_dac);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		count /= s->dma_dac.cnt_factor;
-		return put_user(count, (int *) arg);
-
-	case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cinfo.bytes = s->dma_adc.total_bytes;
-		count = s->dma_adc.count;
-		if (!s->dma_adc.stopped) {
-			diff = dma_count_done(&s->dma_adc);
-			count += diff;
-			cinfo.bytes += diff;
-			cinfo.ptr =  virt_to_phys(s->dma_adc.nextIn) + diff -
-				s->dma_adc.dmaaddr;
-		} else
-			cinfo.ptr = virt_to_phys(s->dma_adc.nextIn) -
-				s->dma_adc.dmaaddr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= (s->dma_adc.dma_fragsize-1);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		cinfo.blocks = count >> s->dma_adc.fragshift;
-		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cinfo.bytes = s->dma_dac.total_bytes;
-		count = s->dma_dac.count;
-		if (!s->dma_dac.stopped) {
-			diff = dma_count_done(&s->dma_dac);
-			count -= diff;
-			cinfo.bytes += diff;
-			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) + diff -
-				s->dma_dac.dmaaddr;
-		} else
-			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) -
-				s->dma_dac.dmaaddr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= (s->dma_dac.dma_fragsize-1);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		cinfo.blocks = count >> s->dma_dac.fragshift;
-		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE)
-			return put_user(s->dma_dac.fragsize, (int *) arg);
-		else
-			return put_user(s->dma_adc.fragsize, (int *) arg);
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-			if ((ret = prog_dmabuf_adc(s)))
-				return ret;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.ossfragshift = val & 0xffff;
-			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac.ossfragshift < 4)
-				s->dma_dac.ossfragshift = 4;
-			if (s->dma_dac.ossfragshift > 15)
-				s->dma_dac.ossfragshift = 15;
-			if (s->dma_dac.ossmaxfrags < 4)
-				s->dma_dac.ossmaxfrags = 4;
-			if ((ret = prog_dmabuf_dac(s)))
-				return ret;
-		}
-		return 0;
-
-	case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-			return -EINVAL;
-		if (get_user(val, (int *) arg))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.subdivision = val;
-			if ((ret = prog_dmabuf_adc(s)))
-				return ret;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.subdivision = val;
-			if ((ret = prog_dmabuf_dac(s)))
-				return ret;
-		}
-		return 0;
-
-	case SOUND_PCM_READ_RATE:
-		return put_user((file->f_mode & FMODE_READ) ?
-				s->dma_adc.sample_rate :
-				s->dma_dac.sample_rate,
-				(int *)arg);
-
-	case SOUND_PCM_READ_CHANNELS:
-		if (file->f_mode & FMODE_READ)
-			return put_user(s->dma_adc.num_channels, (int *)arg);
-		else
-			return put_user(s->dma_dac.num_channels, (int *)arg);
-
-	case SOUND_PCM_READ_BITS:
-		if (file->f_mode & FMODE_READ)
-			return put_user(s->dma_adc.sample_size, (int *)arg);
-		else
-			return put_user(s->dma_dac.sample_size, (int *)arg);
-
-	case SOUND_PCM_WRITE_FILTER:
-	case SNDCTL_DSP_SETSYNCRO:
-	case SOUND_PCM_READ_FILTER:
-		return -EINVAL;
-	}
-
-	return mixdev_ioctl(&s->codec, cmd, arg);
-}
-
-
-static int  au1000_open(struct inode *inode, struct file *file)
-{
-	int             minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	struct au1000_state *s = &au1000_state;
-	int             ret;
-
-#ifdef AU1000_VERBOSE_DEBUG
-	if (file->f_flags & O_NONBLOCK)
-		dbg("%s: non-blocking", __FUNCTION__);
-	else
-		dbg("%s: blocking", __FUNCTION__);
-#endif
-	
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & file->f_mode) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-
-	stop_dac(s);
-	stop_adc(s);
-
-	if (file->f_mode & FMODE_READ) {
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
-			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
-		s->dma_adc.num_channels = 1;
-		s->dma_adc.sample_size = 8;
-		set_adc_rate(s, 8000);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			s->dma_adc.sample_size = 16;
-	}
-
-	if (file->f_mode & FMODE_WRITE) {
-		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
-			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
-		s->dma_dac.num_channels = 1;
-		s->dma_dac.sample_size = 8;
-		set_dac_rate(s, 8000);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			s->dma_dac.sample_size = 16;
-	}
-
-	if (file->f_mode & FMODE_READ) {
-		if ((ret = prog_dmabuf_adc(s)))
-			return ret;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if ((ret = prog_dmabuf_dac(s)))
-			return ret;
-	}
-
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	mutex_unlock(&s->open_mutex);
-	mutex_init(&s->sem);
-	return nonseekable_open(inode, file);
-}
-
-static int au1000_release(struct inode *inode, struct file *file)
-{
-	struct au1000_state *s = (struct au1000_state *)file->private_data;
-
-	lock_kernel();
-	
-	if (file->f_mode & FMODE_WRITE) {
-		unlock_kernel();
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-		lock_kernel();
-	}
-
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac(s);
-		dealloc_dmabuf(s, &s->dma_dac);
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-		dealloc_dmabuf(s, &s->dma_adc);
-	}
-	s->open_mode &= ((~file->f_mode) & (FMODE_READ|FMODE_WRITE));
-	mutex_unlock(&s->open_mutex);
-	wake_up(&s->open_wait);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const */ struct file_operations au1000_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= au1000_llseek,
-	.read		= au1000_read,
-	.write		= au1000_write,
-	.poll		= au1000_poll,
-	.ioctl		= au1000_ioctl,
-	.mmap		= au1000_mmap,
-	.open		= au1000_open,
-	.release	= au1000_release,
-};
-
-
-/* --------------------------------------------------------------------- */
-
-
-/* --------------------------------------------------------------------- */
-
-/*
- * for debugging purposes, we'll create a proc device that dumps the
- * CODEC chipstate
- */
-
-#ifdef AU1000_DEBUG
-static int proc_au1000_dump(char *buf, char **start, off_t fpos,
-			    int length, int *eof, void *data)
-{
-	struct au1000_state *s = &au1000_state;
-	int             cnt, len = 0;
-
-	/* print out header */
-	len += sprintf(buf + len, "\n\t\tAU1000 Audio Debug\n\n");
-
-	// print out digital controller state
-	len += sprintf(buf + len, "AU1000 Audio Controller registers\n");
-	len += sprintf(buf + len, "---------------------------------\n");
-	len += sprintf (buf + len, "AC97C_CONFIG = %08x\n",
-			au_readl(AC97C_CONFIG));
-	len += sprintf (buf + len, "AC97C_STATUS = %08x\n",
-			au_readl(AC97C_STATUS));
-	len += sprintf (buf + len, "AC97C_CNTRL  = %08x\n",
-			au_readl(AC97C_CNTRL));
-
-	/* print out CODEC state */
-	len += sprintf(buf + len, "\nAC97 CODEC registers\n");
-	len += sprintf(buf + len, "----------------------\n");
-	for (cnt = 0; cnt <= 0x7e; cnt += 2)
-		len += sprintf(buf + len, "reg %02x = %04x\n",
-			       cnt, rdcodec(&s->codec, cnt));
-
-	if (fpos >= len) {
-		*start = buf;
-		*eof = 1;
-		return 0;
-	}
-	*start = buf + fpos;
-	if ((len -= fpos) > length)
-		return length;
-	*eof = 1;
-	return len;
-
-}
-#endif /* AU1000_DEBUG */
-
-/* --------------------------------------------------------------------- */
-
-MODULE_AUTHOR("Monta Vista Software, stevel@mvista.com");
-MODULE_DESCRIPTION("Au1000 Audio Driver");
-
-/* --------------------------------------------------------------------- */
-
-static int __devinit au1000_probe(void)
-{
-	struct au1000_state *s = &au1000_state;
-	int             val;
-#ifdef AU1000_DEBUG
-	char            proc_str[80];
-#endif
-
-	memset(s, 0, sizeof(struct au1000_state));
-
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac.wait);
-	init_waitqueue_head(&s->open_wait);
-	mutex_init(&s->open_mutex);
-	spin_lock_init(&s->lock);
-	s->codec.private_data = s;
-	s->codec.id = 0;
-	s->codec.codec_read = rdcodec;
-	s->codec.codec_write = wrcodec;
-	s->codec.codec_wait = waitcodec;
-
-	if (!request_mem_region(CPHYSADDR(AC97C_CONFIG),
-			    0x14, AU1000_MODULE_NAME)) {
-		err("AC'97 ports in use");
-		return -1;
-	}
-	// Allocate the DMA Channels
-	if ((s->dma_dac.dmanr = request_au1000_dma(DMA_ID_AC97C_TX,
-						   "audio DAC",
-						   dac_dma_interrupt,
-						   IRQF_DISABLED, s)) < 0) {
-		err("Can't get DAC DMA");
-		goto err_dma1;
-	}
-	if ((s->dma_adc.dmanr = request_au1000_dma(DMA_ID_AC97C_RX,
-						   "audio ADC",
-						   adc_dma_interrupt,
-						   IRQF_DISABLED, s)) < 0) {
-		err("Can't get ADC DMA");
-		goto err_dma2;
-	}
-
-	info("DAC: DMA%d/IRQ%d, ADC: DMA%d/IRQ%d",
-	     s->dma_dac.dmanr, get_dma_done_irq(s->dma_dac.dmanr),
-	     s->dma_adc.dmanr, get_dma_done_irq(s->dma_adc.dmanr));
-
-	// enable DMA coherency in read/write DMA channels
-	set_dma_mode(s->dma_dac.dmanr,
-		     get_dma_mode(s->dma_dac.dmanr) & ~DMA_NC);
-	set_dma_mode(s->dma_adc.dmanr,
-		     get_dma_mode(s->dma_adc.dmanr) & ~DMA_NC);
-
-	/* register devices */
-
-	if ((s->dev_audio = register_sound_dsp(&au1000_audio_fops, -1)) < 0)
-		goto err_dev1;
-	if ((s->codec.dev_mixer =
-	     register_sound_mixer(&au1000_mixer_fops, -1)) < 0)
-		goto err_dev2;
-
-#ifdef AU1000_DEBUG
-	/* intialize the debug proc device */
-	s->ps = create_proc_read_entry(AU1000_MODULE_NAME, 0, NULL,
-				       proc_au1000_dump, NULL);
-#endif /* AU1000_DEBUG */
-
-	// configure pins for AC'97
-	au_writel(au_readl(SYS_PINFUNC) & ~0x02, SYS_PINFUNC);
-
-	// Assert reset for 10msec to the AC'97 controller, and enable clock
-	au_writel(AC97C_RS | AC97C_CE, AC97C_CNTRL);
-	au1000_delay(10);
-	au_writel(AC97C_CE, AC97C_CNTRL);
-	au1000_delay(10);	// wait for clock to stabilize
-
-	/* cold reset the AC'97 */
-	au_writel(AC97C_RESET, AC97C_CONFIG);
-	au1000_delay(10);
-	au_writel(0, AC97C_CONFIG);
-	/* need to delay around 500msec(bleech) to give
-	   some CODECs enough time to wakeup */
-	au1000_delay(500);
-
-	/* warm reset the AC'97 to start the bitclk */
-	au_writel(AC97C_SG | AC97C_SYNC, AC97C_CONFIG);
-	udelay(100);
-	au_writel(0, AC97C_CONFIG);
-
-	/* codec init */
-	if (!ac97_probe_codec(&s->codec))
-		goto err_dev3;
-
-	s->codec_base_caps = rdcodec(&s->codec, AC97_RESET);
-	s->codec_ext_caps = rdcodec(&s->codec, AC97_EXTENDED_ID);
-	info("AC'97 Base/Extended ID = %04x/%04x",
-	     s->codec_base_caps, s->codec_ext_caps);
-
-	/*
-	 * On the Pb1000, audio playback is on the AUX_OUT
-	 * channel (which defaults to LNLVL_OUT in AC'97
-	 * rev 2.2) so make sure this channel is listed
-	 * as supported (soundcard.h calls this channel
-	 * ALTPCM). ac97_codec.c does not handle detection
-	 * of this channel correctly.
-	 */
-	s->codec.supported_mixers |= SOUND_MASK_ALTPCM;
-	/*
-	 * Now set AUX_OUT's default volume.
-	 */
-	val = 0x4343;
-	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_ALTPCM,
-		     (unsigned long) &val);
-	
-	if (!(s->codec_ext_caps & AC97_EXTID_VRA)) {
-		// codec does not support VRA
-		s->no_vra = 1;
-	} else if (!vra) {
-		// Boot option says disable VRA
-		u16 ac97_extstat = rdcodec(&s->codec, AC97_EXTENDED_STATUS);
-		wrcodec(&s->codec, AC97_EXTENDED_STATUS,
-			ac97_extstat & ~AC97_EXTSTAT_VRA);
-		s->no_vra = 1;
-	}
-	if (s->no_vra)
-		info("no VRA, interpolating and decimating");
-
-	/* set mic to be the recording source */
-	val = SOUND_MASK_MIC;
-	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_RECSRC,
-		     (unsigned long) &val);
-
-#ifdef AU1000_DEBUG
-	sprintf(proc_str, "driver/%s/%d/ac97", AU1000_MODULE_NAME,
-		s->codec.id);
-	s->ac97_ps = create_proc_read_entry (proc_str, 0, NULL,
-					     ac97_read_proc, &s->codec);
-#endif
-
-#ifdef CONFIG_MIPS_XXS1500
-	/* deassert eapd */
-	wrcodec(&s->codec, AC97_POWER_CONTROL,
-			rdcodec(&s->codec, AC97_POWER_CONTROL) & ~0x8000);
-	/* mute a number of signals which seem to be causing problems
-	 * if not muted.
-	 */
-	wrcodec(&s->codec, AC97_PCBEEP_VOL, 0x8000);
-	wrcodec(&s->codec, AC97_PHONE_VOL, 0x8008);
-	wrcodec(&s->codec, AC97_MIC_VOL, 0x8008);
-	wrcodec(&s->codec, AC97_LINEIN_VOL, 0x8808);
-	wrcodec(&s->codec, AC97_CD_VOL, 0x8808);
-	wrcodec(&s->codec, AC97_VIDEO_VOL, 0x8808);
-	wrcodec(&s->codec, AC97_AUX_VOL, 0x8808);
-	wrcodec(&s->codec, AC97_PCMOUT_VOL, 0x0808);
-	wrcodec(&s->codec, AC97_GENERAL_PURPOSE, 0x2000);
-#endif
-
-	return 0;
-
- err_dev3:
-	unregister_sound_mixer(s->codec.dev_mixer);
- err_dev2:
-	unregister_sound_dsp(s->dev_audio);
- err_dev1:
-	free_au1000_dma(s->dma_adc.dmanr);
- err_dma2:
-	free_au1000_dma(s->dma_dac.dmanr);
- err_dma1:
-	release_mem_region(CPHYSADDR(AC97C_CONFIG), 0x14);
-	return -1;
-}
-
-static void au1000_remove(void)
-{
-	struct au1000_state *s = &au1000_state;
-
-	if (!s)
-		return;
-#ifdef AU1000_DEBUG
-	if (s->ps)
-		remove_proc_entry(AU1000_MODULE_NAME, NULL);
-#endif /* AU1000_DEBUG */
-	synchronize_irq();
-	free_au1000_dma(s->dma_adc.dmanr);
-	free_au1000_dma(s->dma_dac.dmanr);
-	release_mem_region(CPHYSADDR(AC97C_CONFIG), 0x14);
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->codec.dev_mixer);
-}
-
-static int __init init_au1000(void)
-{
-	info("stevel@mvista.com, built " __TIME__ " on " __DATE__);
-	return au1000_probe();
-}
-
-static void __exit cleanup_au1000(void)
-{
-	info("unloading");
-	au1000_remove();
-}
-
-module_init(init_au1000);
-module_exit(cleanup_au1000);
-
-/* --------------------------------------------------------------------- */
-
-#ifndef MODULE
-
-static int __init au1000_setup(char *options)
-{
-	char           *this_opt;
-
-	if (!options || !*options)
-		return 0;
-
-	while ((this_opt = strsep(&options, ","))) {
-		if (!*this_opt)
-			continue;
-		if (!strncmp(this_opt, "vra", 3)) {
-			vra = 1;
-		}
-	}
-
-	return 1;
-}
-
-__setup("au1000_audio=", au1000_setup);
-
-#endif /* MODULE */
--- linux-2.6.18.noarch/sound/oss/sb_audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sb_audio.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sb_audio.c
+ * sound/oss/sb_audio.c
  *
  * Audio routines for Sound Blaster compatible cards.
  *
--- linux-2.6.18.noarch/sound/oss/au1550_ac97.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/au1550_ac97.c	2007-06-05 17:44:14.000000000 -0400
@@ -719,8 +719,7 @@
 }
 
 
-static void
-dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static void dac_dma_interrupt(int irq, void *dev_id)
 {
 	struct au1550_state *s = (struct au1550_state *) dev_id;
 	struct dmabuf  *db = &s->dma_dac;
@@ -754,8 +753,7 @@
 }
 
 
-static void
-adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static void adc_dma_interrupt(int irq, void *dev_id)
 {
 	struct	au1550_state *s = (struct au1550_state *)dev_id;
 	struct	dmabuf  *dp = &s->dma_adc;
@@ -1356,11 +1354,11 @@
 		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
 
 #ifdef DEBUG
-	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
+	for (count = 0; count < ARRAY_SIZE(ioctl_str); count++) {
 		if (ioctl_str[count].cmd == cmd)
 			break;
 	}
-	if (count < sizeof(ioctl_str) / sizeof(ioctl_str[0]))
+	if (count < ARRAY_SIZE(ioctl_str))
 		pr_debug("ioctl %s, arg=0x%lxn", ioctl_str[count].str, arg);
 	else
 		pr_debug("ioctl 0x%x unknown, arg=0x%lx\n", cmd, arg);
--- linux-2.6.18.noarch/sound/oss/rme96xx.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/rme96xx.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,78 +0,0 @@
-/* (C) 2000 Guenter Geiger <geiger@debian.org>
-   with copy/pastes from the driver of Winfried Ritsch <ritsch@iem.kug.ac.at>
-
-Modifications - Heiko Purnhagen <purnhage@tnt.uni-hannover.de>
-   HP20020116 towards REV 1.5 support, based on ALSA's card-rme9652.c
-   HP20020201 completed?
-
-A text/graphic control panel (rmectrl/xrmectrl) is available from
-   http://gige.xdv.org/pages/soft/pages/rme
-*/
-
-
-#ifndef AFMT_S32_BLOCKED
-#define AFMT_S32_BLOCKED 0x0000400
-#endif
-
-/* AFMT_S16_BLOCKED not yet supported */
-#ifndef AFMT_S16_BLOCKED 
-#define AFMT_S16_BLOCKED 0x0000800
-#endif
-
-
-typedef struct rme_status {
-	unsigned int irq:1;
-	unsigned int lockmask:3;     /* ADAT input PLLs locked */
-	                             /*   100=ADAT1, 010=ADAT2, 001=ADAT3 */
-	unsigned int sr48:1;         /* sample rate: 0=44.1/88.2 1=48/96 kHz */
-	unsigned int wclock:1;       /* 1=wordclock used */
-	unsigned int bufpoint:10;
-	unsigned int syncmask:3;     /* ADAT input in sync with system clock */
-	                             /* 100=ADAT1, 010=ADAT2, 001=ADAT3 */
-	unsigned int doublespeed:1;  /* sample rate: 0=44.1/48 1=88.2/96 kHz */
-	unsigned int tc_busy:1;
-	unsigned int tc_out:1;
-	unsigned int crystalrate:3;  /* spdif input sample rate: */
-	                             /*   000=64kHz, 100=88.2kHz, 011=96kHz */
-	                             /*   111=32kHz, 110=44.1kHz, 101=48kHz */
-	unsigned int spdif_error:1;  /* 1=no spdif lock */
-	unsigned int bufid:1;
-	unsigned int tc_valid:1;     /* 1=timecode input detected */
-	unsigned int spdif_read:1;
-} rme_status_t;
-
-
-/* only fields marked W: can be modified by writing to SOUND_MIXER_PRIVATE3 */
-typedef struct rme_control {
-	unsigned int start:1;
-	unsigned int latency:3;      /* buffer size / latency [samples]: */
-	                             /*   0=64 ... 7=8192 */
-	unsigned int master:1;       /* W: clock mode: 1=master 0=slave/auto */
-	unsigned int ie:1;
-	unsigned int sr48:1;         /* samplerate 0=44.1/88.2, 1=48/96 kHz */
-	unsigned int spare:1;
-	unsigned int doublespeed:1;  /* double speed 0=44.1/48, 1=88.2/96 Khz */
-	unsigned int pro:1;          /* W: SPDIF-OUT 0=consumer, 1=professional */
-	unsigned int emphasis:1;     /* W: SPDIF-OUT emphasis 0=off, 1=on */
-	unsigned int dolby:1;        /* W: SPDIF-OUT non-audio bit 1=set, 0=unset */
-	unsigned int opt_out:1;      /* W: use 1st optical OUT as SPDIF: 1=yes, 0=no */
-	unsigned int wordclock:1;    /* W: use Wordclock as sync (overwrites master) */
-        unsigned int spdif_in:2;     /* W: SPDIF-IN: */
-                                     /*    00=optical (ADAT1), 01=coaxial (Cinch), 10=internal CDROM */
-	unsigned int sync_ref:2;     /* W: preferred sync-source in autosync */
-                                     /*    00=ADAT1, 01=ADAT2, 10=ADAT3, 11=SPDIF */
-	unsigned int spdif_reset:1;
-	unsigned int spdif_select:1;
-	unsigned int spdif_clock:1;
-	unsigned int spdif_write:1;
-	unsigned int adat1_cd:1;     /* W: Rev 1.5+: if set, internal CD connector carries ADAT */
-} rme_ctrl_t;
-
-
-typedef struct _rme_mixer {
-	int i_offset;
-	int o_offset;
-	int devnr;
-	int spare[8];
-} rme_mixer;
-
--- linux-2.6.18.noarch/sound/oss/sound_timer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sound_timer.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sound_timer.c
+ * sound/oss/sound_timer.c
  */
 /*
  * Copyright (C) by Hannu Savolainen 1993-1997
@@ -76,6 +76,7 @@
 	tmr_ctr = 0;
 	usecs_per_tmr = new_usecs;
 }
+EXPORT_SYMBOL(sound_timer_syncinterval);
 
 static void tmr_reset(void)
 {
@@ -300,6 +301,7 @@
 	}
 	spin_unlock_irqrestore(&lock,flags);
 }
+EXPORT_SYMBOL(sound_timer_interrupt);
 
 void  sound_timer_init(struct sound_lowlev_timer *t, char *name)
 {
@@ -321,3 +323,5 @@
 	strcpy(sound_timer.info.name, name);
 	sound_timer_devs[n] = &sound_timer;
 }
+EXPORT_SYMBOL(sound_timer_init);
+
--- linux-2.6.18.noarch/sound/oss/os.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/os.h	2007-06-05 17:44:14.000000000 -0400
@@ -43,4 +43,4 @@
 #undef PSEUDO_DMA_AUTOINIT
 #define ALLOW_BUFFER_MAPPING
 
-extern struct file_operations oss_sound_fops;
+extern const struct file_operations oss_sound_fops;
--- linux-2.6.18.noarch/sound/oss/awe_hw.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/awe_hw.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,99 +0,0 @@
-/*
- * sound/awe_hw.h
- *
- * Access routines and definitions for the low level driver for the 
- * Creative AWE32/SB32/AWE64 wave table synth.
- *   version 0.4.4; Jan. 4, 2000
- *
- * Copyright (C) 1996-2000 Takashi Iwai
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef AWE_HW_H_DEF
-#define AWE_HW_H_DEF
-
-/*
- * Emu-8000 control registers
- * name(channel)	reg, port
- */
-
-#define awe_cmd_idx(reg,ch)	(((reg)<< 5) | (ch))
-
-#define Data0    0		/* 0x620: doubleword r/w */
-#define Data1    1		/* 0xA20: doubleword r/w */
-#define Data2    2		/* 0xA22: word r/w */
-#define Data3    3		/* 0xE20: word r/w */
-#define Pointer  4		/* 0xE22 register pointer r/w */
-
-#define AWE_CPF(ch)	awe_cmd_idx(0,ch), Data0	/* DW: current pitch and fractional address */
-#define AWE_PTRX(ch)	awe_cmd_idx(1,ch), Data0	/* DW: pitch target and reverb send */
-#define AWE_CVCF(ch)	awe_cmd_idx(2,ch), Data0	/* DW: current volume and filter cutoff */
-#define AWE_VTFT(ch)	awe_cmd_idx(3,ch), Data0	/* DW: volume and filter cutoff targets */
-#define AWE_0080(ch)	awe_cmd_idx(4,ch), Data0	/* DW: ?? */
-#define AWE_00A0(ch)	awe_cmd_idx(5,ch), Data0	/* DW: ?? */
-#define AWE_PSST(ch)	awe_cmd_idx(6,ch), Data0	/* DW: pan send and loop start address */
-#define AWE_CSL(ch)	awe_cmd_idx(7,ch), Data0	/* DW: chorus send and loop end address */
-#define AWE_CCCA(ch)	awe_cmd_idx(0,ch), Data1	/* DW: Q, control bits, and current address */
-#define AWE_HWCF4	awe_cmd_idx(1,9),  Data1	/* DW: config dw 4 */
-#define AWE_HWCF5	awe_cmd_idx(1,10), Data1	/* DW: config dw 5 */
-#define AWE_HWCF6	awe_cmd_idx(1,13), Data1	/* DW: config dw 6 */
-#define AWE_HWCF7	awe_cmd_idx(1,14), Data1	/* DW: config dw 7? (not documented) */
-#define AWE_SMALR	awe_cmd_idx(1,20), Data1	/* DW: sound memory address for left read */
-#define AWE_SMARR	awe_cmd_idx(1,21), Data1	/* DW:    for right read */
-#define AWE_SMALW	awe_cmd_idx(1,22), Data1	/* DW: sound memory address for left write */
-#define AWE_SMARW	awe_cmd_idx(1,23), Data1	/* DW:    for right write */
-#define AWE_SMLD	awe_cmd_idx(1,26), Data1	/* W: sound memory left data */
-#define AWE_SMRD	awe_cmd_idx(1,26), Data2	/* W:    right data */
-#define AWE_WC		awe_cmd_idx(1,27), Data2	/* W: sample counter */
-#define AWE_WC_Cmd	awe_cmd_idx(1,27)
-#define AWE_WC_Port	Data2
-#define AWE_HWCF1	awe_cmd_idx(1,29), Data1	/* W: config w 1 */
-#define AWE_HWCF2	awe_cmd_idx(1,30), Data1	/* W: config w 2 */
-#define AWE_HWCF3	awe_cmd_idx(1,31), Data1	/* W: config w 3 */
-#define AWE_INIT1(ch)	awe_cmd_idx(2,ch), Data1	/* W: init array 1 */
-#define AWE_INIT2(ch)	awe_cmd_idx(2,ch), Data2	/* W: init array 2 */
-#define AWE_INIT3(ch)	awe_cmd_idx(3,ch), Data1	/* W: init array 3 */
-#define AWE_INIT4(ch)	awe_cmd_idx(3,ch), Data2	/* W: init array 4 */
-#define AWE_ENVVOL(ch)	awe_cmd_idx(4,ch), Data1	/* W: volume envelope delay */
-#define AWE_DCYSUSV(ch)	awe_cmd_idx(5,ch), Data1	/* W: volume envelope sustain and decay */
-#define AWE_ENVVAL(ch)	awe_cmd_idx(6,ch), Data1	/* W: modulation envelope delay */
-#define AWE_DCYSUS(ch)	awe_cmd_idx(7,ch), Data1	/* W: modulation envelope sustain and decay */
-#define AWE_ATKHLDV(ch)	awe_cmd_idx(4,ch), Data2	/* W: volume envelope attack and hold */
-#define AWE_LFO1VAL(ch)	awe_cmd_idx(5,ch), Data2	/* W: LFO#1 Delay */
-#define AWE_ATKHLD(ch)	awe_cmd_idx(6,ch), Data2	/* W: modulation envelope attack and hold */
-#define AWE_LFO2VAL(ch)	awe_cmd_idx(7,ch), Data2	/* W: LFO#2 Delay */
-#define AWE_IP(ch)	awe_cmd_idx(0,ch), Data3	/* W: initial pitch */
-#define AWE_IFATN(ch)	awe_cmd_idx(1,ch), Data3	/* W: initial filter cutoff and attenuation */
-#define AWE_PEFE(ch)	awe_cmd_idx(2,ch), Data3	/* W: pitch and filter envelope heights */
-#define AWE_FMMOD(ch)	awe_cmd_idx(3,ch), Data3	/* W: vibrato and filter modulation freq */
-#define AWE_TREMFRQ(ch)	awe_cmd_idx(4,ch), Data3	/* W: LFO#1 tremolo amount and freq */
-#define AWE_FM2FRQ2(ch)	awe_cmd_idx(5,ch), Data3	/* W: LFO#2 vibrato amount and freq */
-
-/* used during detection (returns ROM version?; not documented in ADIP) */
-#define AWE_U1		0xE0, Data3	  /* (R)(W) used in initialization */
-#define AWE_U2(ch)	0xC0+(ch), Data3  /* (W)(W) used in init envelope  */
-
-
-#define AWE_MAX_VOICES		32
-#define AWE_NORMAL_VOICES	30	/*30&31 are reserved for DRAM refresh*/
-
-#define AWE_MAX_CHANNELS	32	/* max midi channels (must >= voices) */
-#define AWE_MAX_LAYERS	AWE_MAX_VOICES	/* maximum number of multiple layers */
-
-#define AWE_DRAM_OFFSET		0x200000
-#define AWE_MAX_DRAM_SIZE	(28 * 1024)	/* 28 MB is max onboard memory */
-
-#endif
--- linux-2.6.18.noarch/sound/oss/pas2_midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/pas2_midi.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/pas2_midi.c
+ * sound/oss/pas2_midi.c
  *
  * The low level driver for the PAS Midi Interface.
  */
--- linux-2.6.18.noarch/sound/oss/opl3sa2.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/opl3sa2.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/opl3sa2.c
+ * sound/oss/opl3sa2.c
  *
  * A low level driver for Yamaha OPL3-SA2 and SA3 cards.
  * NOTE: All traces of the name OPL3-SAx have now (December 2000) been
--- linux-2.6.18.noarch/sound/oss/opl3.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/opl3.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/opl3.c
+ * sound/oss/opl3.c
  *
  * A low level driver for Yamaha YM3812 and OPL-3 -chips
  *
@@ -166,7 +166,7 @@
 		return 0;
 	}
 
-	devc = (struct opl_devinfo *)kmalloc(sizeof(*devc), GFP_KERNEL);
+	devc = kzalloc(sizeof(*devc), GFP_KERNEL);
 
 	if (devc == NULL)
 	{
@@ -175,7 +175,6 @@
 		return 0;
 	}
 
-	memset(devc, 0, sizeof(*devc));
 	strcpy(devc->fm_info.name, "OPL2");
 
 	if (!request_region(ioaddr, 4, devc->fm_info.name)) {
--- linux-2.6.18.noarch/sound/oss/nm256.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/nm256.h	2007-06-05 17:44:14.000000000 -0400
@@ -115,7 +115,7 @@
     int has_irq;
 
     /* The card interrupt service routine. */
-    irqreturn_t (*introutine) (int, void *, struct pt_regs *);
+    irq_handler_t introutine;
 
     /* Current audio config, cached. */
     struct sinfo {
--- linux-2.6.18.noarch/sound/oss/es1371.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/es1371.c	2007-06-05 17:44:14.000000000 -0400
@@ -130,6 +130,8 @@
 #include <linux/wait.h>
 #include <linux/dma-mapping.h>
 #include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/kernel.h>
 
 #include <asm/io.h>
 #include <asm/page.h>
@@ -1100,9 +1102,9 @@
 	outb((s->midi.ocnt > 0) ? UCTRL_RXINTEN | UCTRL_ENA_TXINT : UCTRL_RXINTEN, s->io+ES1371_REG_UART_CONTROL);
 }
 
-static irqreturn_t es1371_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t es1371_interrupt(int irq, void *dev_id)
 {
-        struct es1371_state *s = (struct es1371_state *)dev_id;
+        struct es1371_state *s = dev_id;
 	unsigned int intsrc, sctl;
 	
 	/* fastpath out, to ease interrupt sharing */
@@ -2869,11 +2871,10 @@
 		printk(KERN_WARNING "es1371: architecture does not support 32bit PCI busmaster DMA\n");
 		return i;
 	}
-	if (!(s = kmalloc(sizeof(struct es1371_state), GFP_KERNEL))) {
+	if (!(s = kzalloc(sizeof(struct es1371_state), GFP_KERNEL))) {
 		printk(KERN_WARNING PFX "out of memory\n");
 		return -ENOMEM;
 	}
-	memset(s, 0, sizeof(struct es1371_state));
 	
 	s->codec = ac97_alloc_codec();
 	if(s->codec == NULL)
@@ -2997,7 +2998,7 @@
 	set_fs(KERNEL_DS);
 	val = SOUND_MASK_LINE;
 	mixdev_ioctl(s->codec, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
-	for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
+	for (i = 0; i < ARRAY_SIZE(initvol); i++) {
 		val = initvol[i].vol;
 		mixdev_ioctl(s->codec, initvol[i].mixch, (unsigned long)&val);
 	}
--- linux-2.6.18.noarch/sound/oss/trix.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/trix.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/trix.c
+ * sound/oss/trix.c
  *
  * Low level driver for the MediaTrix AudioTrix Pro
  * (MT-0002-PC Control Chip)
--- linux-2.6.18.noarch/sound/oss/sgalaxy.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sgalaxy.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,207 +0,0 @@
-/*
- * sound/sgalaxy.c
- *
- * Low level driver for Aztech Sound Galaxy cards.
- * Copyright 1998 Artur Skawina <skawina@geocities.com>
- *
- * Supported cards:
- *    Aztech Sound Galaxy Waverider Pro 32 - 3D
- *    Aztech Sound Galaxy Washington 16
- *
- * Based on cs4232.c by Hannu Savolainen and Alan Cox.
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- * Changes:
- * 11-10-2000	Bartlomiej Zolnierkiewicz <bkz@linux-ide.org>
- *		Added __init to sb_rst() and sb_cmd()
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-
-#include "sound_config.h"
-#include "ad1848.h"
-
-static void sleep( unsigned howlong )
-{
-	current->state   = TASK_INTERRUPTIBLE;
-	schedule_timeout(howlong);
-}
-
-#define DPORT 0x80
-
-/* Sound Blaster regs */
-
-#define SBDSP_RESET      0x6
-#define SBDSP_READ       0xA
-#define SBDSP_COMMAND    0xC
-#define SBDSP_STATUS     SBDSP_COMMAND
-#define SBDSP_DATA_AVAIL 0xE
-
-static int __init sb_rst(int base)
-{
-	int   i;
-   
-	outb( 1, base+SBDSP_RESET );     /* reset the DSP */
-	outb( 0, base+SBDSP_RESET );
-    
-	for ( i=0; i<500; i++ )          /* delay */
-		inb(DPORT);
-      
-	for ( i=0; i<100000; i++ )
-	{
-		if ( inb( base+SBDSP_DATA_AVAIL )&0x80 )
-			break;
-	}
-
-	if ( inb( base+SBDSP_READ )!=0xAA )
-		return 0;
-
-	return 1;
-}
-
-static int __init sb_cmd( int base, unsigned char val )
-{
-	int  i;
-
-	for ( i=100000; i; i-- )
-	{
-		if ( (inb( base+SBDSP_STATUS )&0x80)==0 )
-		{
-        		outb( val, base+SBDSP_COMMAND );
-        		break;
-		}
-	}
-	return i;      /* i>0 == success */
-}
-
-
-#define ai_sgbase    driver_use_1
-
-static int __init probe_sgalaxy( struct address_info *ai )
-{
-	struct resource *ports;
-	int n;
-
-	if (!request_region(ai->io_base, 4, "WSS config")) {
-		printk(KERN_ERR "sgalaxy: WSS IO port 0x%03x not available\n", ai->io_base);
-		return 0;
-	}
-
-	ports = request_region(ai->io_base + 4, 4, "ad1848");
-	if (!ports) {
-		printk(KERN_ERR "sgalaxy: WSS IO port 0x%03x not available\n", ai->io_base);
-		release_region(ai->io_base, 4);
-		return 0;
-	}
-
-	if (!request_region( ai->ai_sgbase, 0x10, "SoundGalaxy SB")) {
-		printk(KERN_ERR "sgalaxy: SB IO port 0x%03x not available\n", ai->ai_sgbase);
-		release_region(ai->io_base + 4, 4);
-		release_region(ai->io_base, 4);
-		return 0;
-	}
-        
-	if (ad1848_detect(ports, NULL, ai->osp))
-		goto out;  /* The card is already active, check irq etc... */
-        
-	/* switch to MSS/WSS mode */
-   
-	sb_rst( ai->ai_sgbase );
-   
-	sb_cmd( ai->ai_sgbase, 9 );
-	sb_cmd( ai->ai_sgbase, 0 );
-
-	sleep( HZ/10 );
-
-out:
-      	if (!probe_ms_sound(ai, ports)) {
-		release_region(ai->io_base + 4, 4);
-		release_region(ai->io_base, 4);
-		release_region(ai->ai_sgbase, 0x10);
-		return 0;
-	}
-
-	attach_ms_sound(ai, ports, THIS_MODULE);
-	n=ai->slots[0];
-	
-	if (n!=-1 && audio_devs[n]->mixer_dev != -1 ) {
-		AD1848_REROUTE( SOUND_MIXER_LINE1, SOUND_MIXER_LINE );   /* Line-in */
-		AD1848_REROUTE( SOUND_MIXER_LINE2, SOUND_MIXER_SYNTH );  /* FM+Wavetable*/
-		AD1848_REROUTE( SOUND_MIXER_LINE3, SOUND_MIXER_CD );     /* CD */
-	}
-	return 1;
-}
-
-static void __exit unload_sgalaxy( struct address_info *ai )
-{
-	unload_ms_sound( ai );
-	release_region( ai->ai_sgbase, 0x10 );
-}
-
-static struct address_info cfg;
-
-static int __initdata io	= -1;
-static int __initdata irq	= -1;
-static int __initdata dma	= -1;
-static int __initdata dma2	= -1;
-static int __initdata sgbase	= -1;
-
-module_param(io, int, 0);
-module_param(irq, int, 0);
-module_param(dma, int, 0);
-module_param(dma2, int, 0);
-module_param(sgbase, int, 0);
-
-static int __init init_sgalaxy(void)
-{
-	cfg.io_base   = io;
-	cfg.irq       = irq;
-	cfg.dma       = dma;
-	cfg.dma2      = dma2;
-	cfg.ai_sgbase = sgbase;
-
-	if (cfg.io_base == -1 || cfg.irq == -1 || cfg.dma == -1 || cfg.ai_sgbase == -1 ) {
-		printk(KERN_ERR "sgalaxy: io, irq, dma and sgbase must be set.\n");
-		return -EINVAL;
-	}
-
-	if ( probe_sgalaxy(&cfg) == 0 )
-		return -ENODEV;
-
-	return 0;
-}
-
-static void __exit cleanup_sgalaxy(void)
-{
-	unload_sgalaxy(&cfg);
-}
-
-module_init(init_sgalaxy);
-module_exit(cleanup_sgalaxy);
-
-#ifndef MODULE
-static int __init setup_sgalaxy(char *str)
-{
-	/* io, irq, dma, dma2, sgbase */
-	int ints[6];
-	
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-	io	= ints[1];
-	irq	= ints[2];
-	dma	= ints[3];
-	dma2	= ints[4];
-	sgbase	= ints[5];
-
-	return 1;
-}
-
-__setup("sgalaxy=", setup_sgalaxy);
-#endif
-MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/oss/pas2_mixer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/pas2_mixer.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,6 +1,6 @@
 
 /*
- * sound/pas2_mixer.c
+ * sound/oss/pas2_mixer.c
  *
  * Mixer routines for the Pro Audio Spectrum cards.
  */
--- linux-2.6.18.noarch/sound/oss/mpu401.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/mpu401.h	2007-06-05 17:44:14.000000000 -0400
@@ -3,12 +3,9 @@
 int probe_uart401 (struct address_info *hw_config, struct module *owner);
 void unload_uart401 (struct address_info *hw_config);
 
-irqreturn_t uart401intr (int irq, void *dev_id, struct pt_regs * dummy);
+irqreturn_t uart401intr (int irq, void *dev_id);
 
 /*	From mpu401.c */
 int probe_mpu401(struct address_info *hw_config, struct resource *ports);
 int attach_mpu401(struct address_info * hw_config, struct module *owner);
 void unload_mpu401(struct address_info *hw_info);
-
-int intchk_mpu401(void *dev_id);
-irqreturn_t mpuintr(int irq, void *dev_id, struct pt_regs * dummy);
--- linux-2.6.18.noarch/sound/oss/ics2101.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ics2101.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,247 +0,0 @@
-/*
- * sound/ics2101.c
- *
- * Driver for the ICS2101 mixer of GUS v3.7.
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- *
- * Thomas Sailer   : ioctl code reworked (vmalloc/vfree removed)
- * Bartlomiej Zolnierkiewicz : added __init to ics2101_mixer_init()
- */
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include "sound_config.h"
-
-#include <linux/ultrasound.h>
-
-#include "gus.h"
-#include "gus_hw.h"
-
-#define MIX_DEVS	(SOUND_MASK_MIC|SOUND_MASK_LINE| \
-			 SOUND_MASK_SYNTH| \
-  			 SOUND_MASK_CD | SOUND_MASK_VOLUME)
-
-extern int     *gus_osp;
-extern int      gus_base;
-extern spinlock_t gus_lock;
-static int      volumes[ICS_MIXDEVS];
-static int      left_fix[ICS_MIXDEVS] =
-{1, 1, 1, 2, 1, 2};
-static int      right_fix[ICS_MIXDEVS] =
-{2, 2, 2, 1, 2, 1};
-
-static int scale_vol(int vol)
-{
-	/*
-	 *  Experimental volume scaling by Risto Kankkunen.
-	 *  This should give smoother volume response than just
-	 *  a plain multiplication.
-	 */
-	 
-	int e;
-
-	if (vol < 0)
-		vol = 0;
-	if (vol > 100)
-		vol = 100;
-	vol = (31 * vol + 50) / 100;
-	e = 0;
-	if (vol)
-	{
-		while (vol < 16)
-		{
-			vol <<= 1;
-			e--;
-		}
-		vol -= 16;
-		e += 7;
-	}
-	return ((e << 4) + vol);
-}
-
-static void write_mix(int dev, int chn, int vol)
-{
-	int *selector;
-	unsigned long flags;
-	int ctrl_addr = dev << 3;
-	int attn_addr = dev << 3;
-
-	vol = scale_vol(vol);
-
-	if (chn == CHN_LEFT)
-	{
-		selector = left_fix;
-		ctrl_addr |= 0x00;
-		attn_addr |= 0x02;
-	}
-	else
-	{
-		selector = right_fix;
-		ctrl_addr |= 0x01;
-		attn_addr |= 0x03;
-	}
-
-	spin_lock_irqsave(&gus_lock, flags);
-	outb((ctrl_addr), u_MixSelect);
-	outb((selector[dev]), u_MixData);
-	outb((attn_addr), u_MixSelect);
-	outb(((unsigned char) vol), u_MixData);
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static int set_volumes(int dev, int vol)
-{
-	int left = vol & 0x00ff;
-	int right = (vol >> 8) & 0x00ff;
-
-	if (left < 0)
-		left = 0;
-	if (left > 100)
-		left = 100;
-	if (right < 0)
-		right = 0;
-	if (right > 100)
-		right = 100;
-
-	write_mix(dev, CHN_LEFT, left);
-	write_mix(dev, CHN_RIGHT, right);
-
-	vol = left + (right << 8);
-	volumes[dev] = vol;
-	return vol;
-}
-
-static int ics2101_mixer_ioctl(int dev, unsigned int cmd, void __user *arg)
-{
-	int val;
-	
-	if (((cmd >> 8) & 0xff) == 'M') {
-		if (_SIOC_DIR(cmd) & _SIOC_WRITE) {
-			
-			if (get_user(val, (int __user *)arg))
-				return -EFAULT;
-			switch (cmd & 0xff) {
-			case SOUND_MIXER_RECSRC:
-				return gus_default_mixer_ioctl(dev, cmd, arg);
-
-			case SOUND_MIXER_MIC:
-				val = set_volumes(DEV_MIC, val);
-				break;
-				
-			case SOUND_MIXER_CD:
-				val = set_volumes(DEV_CD, val);
-				break;
-
-			case SOUND_MIXER_LINE:
-				val = set_volumes(DEV_LINE, val);
-				break;
-
-			case SOUND_MIXER_SYNTH:
-				val = set_volumes(DEV_GF1, val);
-				break;
-
-			case SOUND_MIXER_VOLUME:
-				val = set_volumes(DEV_VOL, val);
-				break;
-
-			default:
-				return -EINVAL;
-			}
-			return put_user(val, (int __user *)arg);
-		} else {
-			switch (cmd & 0xff) {
-				/*
-				 * Return parameters
-				 */
-			case SOUND_MIXER_RECSRC:
-				return gus_default_mixer_ioctl(dev, cmd, arg);
-
-			case SOUND_MIXER_DEVMASK:
-				val = MIX_DEVS; 
-				break;
-
-			case SOUND_MIXER_STEREODEVS:
-				val = SOUND_MASK_LINE | SOUND_MASK_CD | SOUND_MASK_SYNTH | SOUND_MASK_VOLUME | SOUND_MASK_MIC; 
-				break;
-
-			case SOUND_MIXER_RECMASK:
-				val = SOUND_MASK_MIC | SOUND_MASK_LINE; 
-				break;
-				
-			case SOUND_MIXER_CAPS:
-				val = 0; 
-				break;
-
-			case SOUND_MIXER_MIC:
-				val = volumes[DEV_MIC];
-				break;
-				
-			case SOUND_MIXER_LINE:
-				val = volumes[DEV_LINE];
-				break;
-
-			case SOUND_MIXER_CD:
-				val = volumes[DEV_CD];
-				break;
-
-			case SOUND_MIXER_VOLUME:
-				val = volumes[DEV_VOL];
-				break;
-
-			case SOUND_MIXER_SYNTH:
-				val = volumes[DEV_GF1]; 
-				break;
-
-			default:
-				return -EINVAL;
-			}
-			return put_user(val, (int __user *)arg);
-		}
-	}
-	return -EINVAL;
-}
-
-static struct mixer_operations ics2101_mixer_operations =
-{
-	.owner	= THIS_MODULE,
-	.id	= "ICS2101",
-	.name	= "ICS2101 Multimedia Mixer",
-	.ioctl	= ics2101_mixer_ioctl
-};
-
-int __init ics2101_mixer_init(void)
-{
-	int i;
-	int n;
-
-	if ((n = sound_alloc_mixerdev()) != -1)
-	{
-		mixer_devs[n] = &ics2101_mixer_operations;
-
-		/*
-		 * Some GUS v3.7 cards had some channels flipped. Disable
-		 * the flipping feature if the model id is other than 5.
-		 */
-
-		if (inb(u_MixSelect) != 5)
-		{
-			for (i = 0; i < ICS_MIXDEVS; i++)
-				left_fix[i] = 1;
-			for (i = 0; i < ICS_MIXDEVS; i++)
-				right_fix[i] = 2;
-		}
-		set_volumes(DEV_GF1, 0x5a5a);
-		set_volumes(DEV_CD, 0x5a5a);
-		set_volumes(DEV_MIC, 0x0000);
-		set_volumes(DEV_LINE, 0x5a5a);
-		set_volumes(DEV_VOL, 0x5a5a);
-		set_volumes(DEV_UNUSED, 0x0000);
-	}
-	return n;
-}
--- linux-2.6.18.noarch/sound/oss/uart6850.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/uart6850.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/uart6850.c
+ * sound/oss/uart6850.c
  *
  *
  * Copyright (C) by Hannu Savolainen 1993-1997
@@ -104,7 +104,7 @@
 	}
 }
 
-static irqreturn_t m6850intr(int irq, void *dev_id, struct pt_regs *dummy)
+static irqreturn_t m6850intr(int irq, void *dev_id)
 {
 	if (input_avail())
 		uart6850_input_loop();
--- linux-2.6.18.noarch/sound/oss/midi_syms.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/midi_syms.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,29 +0,0 @@
-/*
- * Exported symbols for midi driver.
- */
-
-#include <linux/module.h>
-
-char midi_syms_symbol;
-
-#include "sound_config.h"
-#define _MIDI_SYNTH_C_
-#include "midi_synth.h"
-
-EXPORT_SYMBOL(do_midi_msg);
-EXPORT_SYMBOL(midi_synth_open);
-EXPORT_SYMBOL(midi_synth_close);
-EXPORT_SYMBOL(midi_synth_ioctl);
-EXPORT_SYMBOL(midi_synth_kill_note);
-EXPORT_SYMBOL(midi_synth_start_note);
-EXPORT_SYMBOL(midi_synth_set_instr);
-EXPORT_SYMBOL(midi_synth_reset);
-EXPORT_SYMBOL(midi_synth_hw_control);
-EXPORT_SYMBOL(midi_synth_aftertouch);
-EXPORT_SYMBOL(midi_synth_controller);
-EXPORT_SYMBOL(midi_synth_panning);
-EXPORT_SYMBOL(midi_synth_setup_voice);
-EXPORT_SYMBOL(midi_synth_send_sysex);
-EXPORT_SYMBOL(midi_synth_bender);
-EXPORT_SYMBOL(midi_synth_load_patch);
-EXPORT_SYMBOL(MIDIbuf_avail);
--- linux-2.6.18.noarch/sound/oss/ad1848_mixer.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ad1848_mixer.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/ad1848_mixer.h
+ * sound/oss/ad1848_mixer.h
  *
  * Definitions for the mixer of AD1848 and compatible codecs.
  */
--- linux-2.6.18.noarch/sound/oss/cs46xx.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs46xx.c	2007-06-05 17:44:14.000000000 -0400
@@ -91,12 +91,13 @@
 #include <linux/poll.h>
 #include <linux/ac97_codec.h>
 #include <linux/mutex.h>
+#include <linux/mm.h>
 
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/uaccess.h>
 
-#include "cs46xxpm-24.h"
+#include "cs46xxpm.h"
 #include "cs46xx_wrapper-24.h"
 #include "cs461x.h"
 
@@ -389,8 +390,10 @@
 static int cs46xx_powerup(struct cs_card *card, unsigned int type);
 static int cs461x_powerdown(struct cs_card *card, unsigned int type, int suspendflag);
 static void cs461x_clear_serial_FIFOs(struct cs_card *card, int type);
+#ifdef CONFIG_PM
 static int cs46xx_suspend_tbl(struct pci_dev *pcidev, pm_message_t state);
 static int cs46xx_resume_tbl(struct pci_dev *pcidev);
+#endif
 
 #if CSDEBUG
 
@@ -777,7 +780,7 @@
 		rate = 48000 / 9;
 
 	/*
-	 *  We can not capture at at rate greater than the Input Rate (48000).
+	 *  We cannot capture at at rate greater than the Input Rate (48000).
 	 *  Return an error if an attempt is made to stray outside that limit.
 	 */
 	if (rate > 48000)
@@ -1611,7 +1614,7 @@
                 wake_up(&card->midi.owait);
 }
 
-static irqreturn_t cs_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t cs_interrupt(int irq, void *dev_id)
 {
 	struct cs_card *card = (struct cs_card *)dev_id;
 	/* Single channel card */
@@ -2980,7 +2983,7 @@
 	
 	card->active+=change;
 	
-	acpi_dev = pci_find_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3, NULL);
+	acpi_dev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3, NULL);
 	if (acpi_dev == NULL)
 		return;		/* Not a thinkpad thats for sure */
 
@@ -3006,6 +3009,7 @@
 				change,card->active));
 		outw(control&~0x2000, port+0x10);
 	}
+	pci_dev_put(acpi_dev);
 }
 
 	
@@ -3044,10 +3048,9 @@
 		CS_DBGOUT(CS_WAVE_READ, 2, printk("cs46xx: cs_open() FMODE_READ\n") );
 		if (card->states[0] == NULL) {
 			state = card->states[0] =
-				kmalloc(sizeof(struct cs_state), GFP_KERNEL);
+				kzalloc(sizeof(struct cs_state), GFP_KERNEL);
 			if (state == NULL)
 				return -ENOMEM;
-			memset(state, 0, sizeof(struct cs_state));
 			mutex_init(&state->sem);
 			dmabuf = &state->dmabuf;
 			dmabuf->pbuf = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);
@@ -3110,10 +3113,9 @@
 		CS_DBGOUT(CS_OPEN, 2, printk("cs46xx: cs_open() FMODE_WRITE\n") );
 		if (card->states[1] == NULL) {
 			state = card->states[1] =
-				kmalloc(sizeof(struct cs_state), GFP_KERNEL);
+				kzalloc(sizeof(struct cs_state), GFP_KERNEL);
 			if (state == NULL)
 				return -ENOMEM;
-			memset(state, 0, sizeof(struct cs_state));
 			mutex_init(&state->sem);
 			dmabuf = &state->dmabuf;
 			dmabuf->pbuf = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);
@@ -4751,8 +4753,8 @@
 	mdelay(5 * cs_laptop_wait);		/* Shouldnt be needed ?? */
 	
 /*
-* If we are resuming under 2.2.x then we can not schedule a timeout.
-* so, just spin the CPU.
+* If we are resuming under 2.2.x then we cannot schedule a timeout,
+* so just spin the CPU.
 */
 	if (card->pm.flags & CS46XX_PM_IDLE) {
 	/*
@@ -5071,11 +5073,10 @@
 	pci_read_config_word(pci_dev, PCI_SUBSYSTEM_VENDOR_ID, &ss_vendor);
 	pci_read_config_word(pci_dev, PCI_SUBSYSTEM_ID, &ss_card);
 
-	if ((card = kmalloc(sizeof(struct cs_card), GFP_KERNEL)) == NULL) {
+	if ((card = kzalloc(sizeof(struct cs_card), GFP_KERNEL)) == NULL) {
 		printk(KERN_ERR "cs46xx: out of memory\n");
 		return -ENOMEM;
 	}
-	memset(card, 0, sizeof(*card));
 	card->ba0_addr = RSRCADDRESS(pci_dev, 0);
 	card->ba1_addr = RSRCADDRESS(pci_dev, 1);
 	card->pci_dev = pci_dev;
@@ -5389,8 +5390,10 @@
 	.id_table = cs46xx_pci_tbl,
 	.probe	  = cs46xx_probe,
 	.remove	  = __devexit_p(cs46xx_remove),
-	.suspend  = CS46XX_SUSPEND_TBL,
-	.resume	  = CS46XX_RESUME_TBL,
+#ifdef CONFIG_PM
+	.suspend  = cs46xx_suspend_tbl,
+	.resume	  = cs46xx_resume_tbl,
+#endif
 };
 
 static int __init cs46xx_init_module(void)
@@ -5420,7 +5423,7 @@
 module_init(cs46xx_init_module);
 module_exit(cs46xx_cleanup_module);
 
-#if CS46XX_ACPI_SUPPORT
+#ifdef CONFIG_PM
 static int cs46xx_suspend_tbl(struct pci_dev *pcidev, pm_message_t state)
 {
 	struct cs_card *s = PCI_GET_DRIVER_DATA(pcidev);
--- linux-2.6.18.noarch/sound/oss/wavfront.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/wavfront.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,3554 +0,0 @@
-/*  -*- linux-c -*-
- *
- * sound/wavfront.c
- *
- * A Linux driver for Turtle Beach WaveFront Series (Maui, Tropez, Tropez Plus)
- *
- * This driver supports the onboard wavetable synthesizer (an ICS2115),
- * including patch, sample and program loading and unloading, conversion
- * of GUS patches during loading, and full user-level access to all
- * WaveFront commands. It tries to provide semi-intelligent patch and
- * sample management as well.
- *
- * It also provides support for the ICS emulation of an MPU-401.  Full
- * support for the ICS emulation's "virtual MIDI mode" is provided in
- * wf_midi.c.
- *
- * Support is also provided for the Tropez Plus' onboard FX processor,
- * a Yamaha YSS225. Currently, code exists to configure the YSS225,
- * and there is an interface allowing tweaking of any of its memory
- * addresses. However, I have been unable to decipher the logical
- * positioning of the configuration info for various effects, so for
- * now, you just get the YSS225 in the same state as Turtle Beach's
- * "SETUPSND.EXE" utility leaves it.
- *
- * The boards' DAC/ADC (a Crystal CS4232) is supported by cs4232.[co],
- * This chip also controls the configuration of the card: the wavefront
- * synth is logical unit 4.
- *
- *
- * Supported devices:
- *
- *   /dev/dsp                      - using cs4232+ad1848 modules, OSS compatible
- *   /dev/midiNN and /dev/midiNN+1 - using wf_midi code, OSS compatible
- *   /dev/synth00                  - raw synth interface
- * 
- **********************************************************************
- *
- * Copyright (C) by Paul Barton-Davis 1998
- *
- * Some portions of this file are taken from work that is
- * copyright (C) by Hannu Savolainen 1993-1996
- *
- * Although the relevant code here is all new, the handling of
- * sample/alias/multi- samples is entirely based on a driver by Matt
- * Martin and Rutger Nijlunsing which demonstrated how to get things
- * to work correctly. The GUS patch loading code has been almost
- * unaltered by me, except to fit formatting and function names in the
- * rest of the file. Many thanks to them.
- *
- * Appreciation and thanks to Hannu Savolainen for his early work on the Maui
- * driver, and answering a few questions while this one was developed.
- *
- * Absolutely NO thanks to Turtle Beach/Voyetra and Yamaha for their
- * complete lack of help in developing this driver, and in particular
- * for their utter silence in response to questions about undocumented
- * aspects of configuring a WaveFront soundcard, particularly the
- * effects processor.
- *
- * $Id: wavfront.c,v 0.7 1998/09/09 15:47:36 pbd Exp $
- *
- * This program is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- * Changes:
- * 11-10-2000	Bartlomiej Zolnierkiewicz <bkz@linux-ide.org>
- *		Added some __init and __initdata to entries in yss225.c
- */
-
-#include <linux/module.h>
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/smp_lock.h>
-#include <linux/ptrace.h>
-#include <linux/fcntl.h>
-#include <linux/syscalls.h>
-#include <linux/ioport.h>    
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-#include <linux/config.h>
-
-#include <linux/delay.h>
-
-#include "sound_config.h"
-
-#include <linux/wavefront.h>
-
-#define _MIDI_SYNTH_C_
-#define MIDI_SYNTH_NAME	"WaveFront MIDI"
-#define MIDI_SYNTH_CAPS	SYNTH_CAP_INPUT
-#include "midi_synth.h"
-
-/* Compile-time control of the extent to which OSS is supported.
-
-   I consider /dev/sequencer to be an anachronism, but given its
-   widespread usage by various Linux MIDI software, it seems worth
-   offering support to it if it's not too painful. Instead of using
-   /dev/sequencer, I recommend:
-
-     for synth programming and patch loading: /dev/synthNN
-     for kernel-synchronized MIDI sequencing: the ALSA sequencer
-     for direct MIDI control: /dev/midiNN
-
-   I have never tried static compilation into the kernel. The #if's
-   for this are really just notes to myself about what the code is
-   for.
-*/
-
-#define OSS_SUPPORT_SEQ            0x1  /* use of /dev/sequencer */
-#define OSS_SUPPORT_STATIC_INSTALL 0x2  /* static compilation into kernel */
-
-#define OSS_SUPPORT_LEVEL          0x1  /* just /dev/sequencer for now */
-
-#if    OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-static int (*midi_load_patch) (int devno, int format, const char __user *addr,
-			       int offs, int count, int pmgr_flag) = NULL;
-#endif /* OSS_SUPPORT_SEQ */
-
-/* if WF_DEBUG not defined, no run-time debugging messages will
-   be available via the debug flag setting. Given the current
-   beta state of the driver, this will remain set until a future 
-   version.
-*/
-
-#define WF_DEBUG 1
-
-#ifdef WF_DEBUG
-
-/* Thank goodness for gcc's preprocessor ... */
-
-#define DPRINT(cond, format, args...) \
-       if ((dev.debug & (cond)) == (cond)) { \
-	     printk (KERN_DEBUG LOGNAME format, ## args); \
-       }
-#else
-#define DPRINT(cond, format, args...)
-#endif
-
-#define LOGNAME "WaveFront: "
-
-/* bitmasks for WaveFront status port value */
-
-#define STAT_RINTR_ENABLED	0x01
-#define STAT_CAN_READ		0x02
-#define STAT_INTR_READ		0x04
-#define STAT_WINTR_ENABLED	0x10
-#define STAT_CAN_WRITE		0x20
-#define STAT_INTR_WRITE		0x40
-
-/*** Module-accessible parameters ***************************************/
-
-static int wf_raw;     /* we normally check for "raw state" to firmware
-			   loading. if set, then during driver loading, the
-			   state of the board is ignored, and we reset the
-			   board and load the firmware anyway.
-			*/
-		   
-static int fx_raw = 1; /* if this is zero, we'll leave the FX processor in
-		          whatever state it is when the driver is loaded.
-		          The default is to download the microprogram and
-		          associated coefficients to set it up for "default"
-		          operation, whatever that means.
-		       */
-
-static int debug_default;  /* you can set this to control debugging
-			      during driver loading. it takes any combination
-			      of the WF_DEBUG_* flags defined in
-			      wavefront.h
-			   */
-
-/* XXX this needs to be made firmware and hardware version dependent */
-
-static char *ospath = "/etc/sound/wavefront.os"; /* where to find a processed
-					            version of the WaveFront OS
-					          */
-
-static int wait_polls = 2000; /* This is a number of tries we poll the
-				 status register before resorting to sleeping.
-				 WaveFront being an ISA card each poll takes
-				 about 1.2us. So before going to
-			         sleep we wait up to 2.4ms in a loop.
-			     */
-
-static int sleep_length = HZ/100; /* This says how long we're going to
-				     sleep between polls.
-			             10ms sounds reasonable for fast response.
-			          */
-
-static int sleep_tries = 50;       /* Wait for status 0.5 seconds total. */
-
-static int reset_time = 2; /* hundreths of a second we wait after a HW reset for
-			      the expected interrupt.
-			   */
-
-static int ramcheck_time = 20;    /* time in seconds to wait while ROM code
-			             checks on-board RAM.
-			          */
-
-static int osrun_time = 10;  /* time in seconds we wait for the OS to
-			        start running.
-			     */
-
-module_param(wf_raw, int, 0);
-module_param(fx_raw, int, 0);
-module_param(debug_default, int, 0);
-module_param(wait_polls, int, 0);
-module_param(sleep_length, int, 0);
-module_param(sleep_tries, int, 0);
-module_param(ospath, charp, 0);
-module_param(reset_time, int, 0);
-module_param(ramcheck_time, int, 0);
-module_param(osrun_time, int, 0);
-
-/***************************************************************************/
-
-/* Note: because this module doesn't export any symbols, this really isn't
-   a global variable, even if it looks like one. I was quite confused by
-   this when I started writing this as a (newer) module -- pbd.
-*/
-
-struct wf_config {
-	int devno;            /* device number from kernel */
-	int irq;              /* "you were one, one of the few ..." */
-	int base;             /* low i/o port address */
-
-#define mpu_data_port    base 
-#define mpu_command_port base + 1 /* write semantics */
-#define mpu_status_port  base + 1 /* read semantics */
-#define data_port        base + 2 
-#define status_port      base + 3 /* read semantics */
-#define control_port     base + 3 /* write semantics  */
-#define block_port       base + 4 /* 16 bit, writeonly */
-#define last_block_port  base + 6 /* 16 bit, writeonly */
-
-	/* FX ports. These are mapped through the ICS2115 to the YS225.
-	   The ICS2115 takes care of flipping the relevant pins on the
-	   YS225 so that access to each of these ports does the right
-	   thing. Note: these are NOT documented by Turtle Beach.
-	*/
-
-#define fx_status       base + 8 
-#define fx_op           base + 8 
-#define fx_lcr          base + 9 
-#define fx_dsp_addr     base + 0xa
-#define fx_dsp_page     base + 0xb 
-#define fx_dsp_lsb      base + 0xc 
-#define fx_dsp_msb      base + 0xd 
-#define fx_mod_addr     base + 0xe
-#define fx_mod_data     base + 0xf 
-
-	volatile int irq_ok;               /* set by interrupt handler */
-        volatile int irq_cnt;              /* ditto */
-	int opened;                        /* flag, holds open(2) mode */
-	char debug;                        /* debugging flags */
-	int freemem;                       /* installed RAM, in bytes */ 
-
-	int synth_dev;                     /* devno for "raw" synth */
-	int mididev;                       /* devno for internal MIDI */
-	int ext_mididev;                   /* devno for external MIDI */ 
-        int fx_mididev;                    /* devno for FX MIDI interface */
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-	int oss_dev;                      /* devno for OSS sequencer synth */
-#endif /* OSS_SUPPORT_SEQ */
-
-	char fw_version[2];                /* major = [0], minor = [1] */
-	char hw_version[2];                /* major = [0], minor = [1] */
-	char israw;                        /* needs Motorola microcode */
-	char has_fx;                       /* has FX processor (Tropez+) */
-	char prog_status[WF_MAX_PROGRAM];  /* WF_SLOT_* */
-	char patch_status[WF_MAX_PATCH];   /* WF_SLOT_* */
-	char sample_status[WF_MAX_SAMPLE]; /* WF_ST_* | WF_SLOT_* */
-	int samples_used;                  /* how many */
-	char interrupts_on;                /* h/w MPU interrupts enabled ? */
-	char rom_samples_rdonly;           /* can we write on ROM samples */
-	wait_queue_head_t interrupt_sleeper; 
-} dev;
-
-static DEFINE_SPINLOCK(lock);
-static int  detect_wffx(void);
-static int  wffx_ioctl (wavefront_fx_info *);
-static int  wffx_init (void);
-
-static int wavefront_delete_sample (int sampnum);
-static int wavefront_find_free_sample (void);
-
-/* From wf_midi.c */
-
-extern int  virtual_midi_enable  (void);
-extern int  virtual_midi_disable (void);
-extern int  detect_wf_mpu (int, int);
-extern int  install_wf_mpu (void);
-extern int  uninstall_wf_mpu (void);
-
-typedef struct {
-	int cmd;
-	char *action;
-	unsigned int read_cnt;
-	unsigned int write_cnt;
-	int need_ack;
-} wavefront_command;
-
-static struct {
-	int errno;
-	const char *errstr;
-} wavefront_errors[] = {
-	{ 0x01, "Bad sample number" },
-	{ 0x02, "Out of sample memory" },
-	{ 0x03, "Bad patch number" },
-	{ 0x04, "Error in number of voices" },
-	{ 0x06, "Sample load already in progress" },
-	{ 0x0B, "No sample load request pending" },
-	{ 0x0E, "Bad MIDI channel number" },
-	{ 0x10, "Download Record Error" },
-	{ 0x80, "Success" },
-	{ 0 }
-};
-
-#define NEEDS_ACK 1
-
-static wavefront_command wavefront_commands[] = {
-	{ WFC_SET_SYNTHVOL, "set synthesizer volume", 0, 1, NEEDS_ACK },
-	{ WFC_GET_SYNTHVOL, "get synthesizer volume", 1, 0, 0},
-	{ WFC_SET_NVOICES, "set number of voices", 0, 1, NEEDS_ACK },
-	{ WFC_GET_NVOICES, "get number of voices", 1, 0, 0 },
-	{ WFC_SET_TUNING, "set synthesizer tuning", 0, 2, NEEDS_ACK },
-	{ WFC_GET_TUNING, "get synthesizer tuning", 2, 0, 0 },
-	{ WFC_DISABLE_CHANNEL, "disable synth channel", 0, 1, NEEDS_ACK },
-	{ WFC_ENABLE_CHANNEL, "enable synth channel", 0, 1, NEEDS_ACK },
-	{ WFC_GET_CHANNEL_STATUS, "get synth channel status", 3, 0, 0 },
-	{ WFC_MISYNTH_OFF, "disable midi-in to synth", 0, 0, NEEDS_ACK },
-	{ WFC_MISYNTH_ON, "enable midi-in to synth", 0, 0, NEEDS_ACK },
-	{ WFC_VMIDI_ON, "enable virtual midi mode", 0, 0, NEEDS_ACK },
-	{ WFC_VMIDI_OFF, "disable virtual midi mode", 0, 0, NEEDS_ACK },
-	{ WFC_MIDI_STATUS, "report midi status", 1, 0, 0 },
-	{ WFC_FIRMWARE_VERSION, "report firmware version", 2, 0, 0 },
-	{ WFC_HARDWARE_VERSION, "report hardware version", 2, 0, 0 },
-	{ WFC_GET_NSAMPLES, "report number of samples", 2, 0, 0 },
-	{ WFC_INSTOUT_LEVELS, "report instantaneous output levels", 7, 0, 0 },
-	{ WFC_PEAKOUT_LEVELS, "report peak output levels", 7, 0, 0 },
-	{ WFC_DOWNLOAD_SAMPLE, "download sample",
-	  0, WF_SAMPLE_BYTES, NEEDS_ACK },
-	{ WFC_DOWNLOAD_BLOCK, "download block", 0, 0, NEEDS_ACK},
-	{ WFC_DOWNLOAD_SAMPLE_HEADER, "download sample header",
-	  0, WF_SAMPLE_HDR_BYTES, NEEDS_ACK },
-	{ WFC_UPLOAD_SAMPLE_HEADER, "upload sample header", 13, 2, 0 },
-
-	/* This command requires a variable number of bytes to be written.
-	   There is a hack in wavefront_cmd() to support this. The actual
-	   count is passed in as the read buffer ptr, cast appropriately.
-	   Ugh.
-	*/
-
-	{ WFC_DOWNLOAD_MULTISAMPLE, "download multisample", 0, 0, NEEDS_ACK },
-
-	/* This one is a hack as well. We just read the first byte of the
-	   response, don't fetch an ACK, and leave the rest to the 
-	   calling function. Ugly, ugly, ugly.
-	*/
-
-	{ WFC_UPLOAD_MULTISAMPLE, "upload multisample", 2, 1, 0 },
-	{ WFC_DOWNLOAD_SAMPLE_ALIAS, "download sample alias",
-	  0, WF_ALIAS_BYTES, NEEDS_ACK },
-	{ WFC_UPLOAD_SAMPLE_ALIAS, "upload sample alias", WF_ALIAS_BYTES, 2, 0},
-	{ WFC_DELETE_SAMPLE, "delete sample", 0, 2, NEEDS_ACK },
-	{ WFC_IDENTIFY_SAMPLE_TYPE, "identify sample type", 5, 2, 0 },
-	{ WFC_UPLOAD_SAMPLE_PARAMS, "upload sample parameters" },
-	{ WFC_REPORT_FREE_MEMORY, "report free memory", 4, 0, 0 },
-	{ WFC_DOWNLOAD_PATCH, "download patch", 0, 134, NEEDS_ACK },
-	{ WFC_UPLOAD_PATCH, "upload patch", 132, 2, 0 },
-	{ WFC_DOWNLOAD_PROGRAM, "download program", 0, 33, NEEDS_ACK },
-	{ WFC_UPLOAD_PROGRAM, "upload program", 32, 1, 0 },
-	{ WFC_DOWNLOAD_EDRUM_PROGRAM, "download enhanced drum program", 0, 9,
-	  NEEDS_ACK},
-	{ WFC_UPLOAD_EDRUM_PROGRAM, "upload enhanced drum program", 8, 1, 0},
-	{ WFC_SET_EDRUM_CHANNEL, "set enhanced drum program channel",
-	  0, 1, NEEDS_ACK },
-	{ WFC_DISABLE_DRUM_PROGRAM, "disable drum program", 0, 1, NEEDS_ACK },
-	{ WFC_REPORT_CHANNEL_PROGRAMS, "report channel program numbers",
-	  32, 0, 0 },
-	{ WFC_NOOP, "the no-op command", 0, 0, NEEDS_ACK },
-	{ 0x00 }
-};
-
-static const char *
-wavefront_errorstr (int errnum)
-
-{
-	int i;
-
-	for (i = 0; wavefront_errors[i].errstr; i++) {
-		if (wavefront_errors[i].errno == errnum) {
-			return wavefront_errors[i].errstr;
-		}
-	}
-
-	return "Unknown WaveFront error";
-}
-
-static wavefront_command *
-wavefront_get_command (int cmd) 
-
-{
-	int i;
-
-	for (i = 0; wavefront_commands[i].cmd != 0; i++) {
-		if (cmd == wavefront_commands[i].cmd) {
-			return &wavefront_commands[i];
-		}
-	}
-
-	return (wavefront_command *) 0;
-}
-
-static inline int
-wavefront_status (void) 
-
-{
-	return inb (dev.status_port);
-}
-
-static int
-wavefront_wait (int mask)
-
-{
-	int i;
-
-	for (i = 0; i < wait_polls; i++)
-		if (wavefront_status() & mask)
-			return 1;
-
-	for (i = 0; i < sleep_tries; i++) {
-
-		if (wavefront_status() & mask) {
-			set_current_state(TASK_RUNNING);
-			return 1;
-		}
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(sleep_length);
-		if (signal_pending(current))
-			break;
-	}
-
-	set_current_state(TASK_RUNNING);
-	return 0;
-}
-
-static int
-wavefront_read (void)
-
-{
-	if (wavefront_wait (STAT_CAN_READ))
-		return inb (dev.data_port);
-
-	DPRINT (WF_DEBUG_DATA, "read timeout.\n");
-
-	return -1;
-}
-
-static int
-wavefront_write (unsigned char data)
-
-{
-	if (wavefront_wait (STAT_CAN_WRITE)) {
-		outb (data, dev.data_port);
-		return 0;
-	}
-
-	DPRINT (WF_DEBUG_DATA, "write timeout.\n");
-
-	return -1;
-}
-
-static int
-wavefront_cmd (int cmd, unsigned char *rbuf, unsigned char *wbuf)
-
-{
-	int ack;
-	int i;
-	int c;
-	wavefront_command *wfcmd;
-
-	if ((wfcmd = wavefront_get_command (cmd)) == (wavefront_command *) 0) {
-		printk (KERN_WARNING LOGNAME "command 0x%x not supported.\n",
-			cmd);
-		return 1;
-	}
-
-	/* Hack to handle the one variable-size write command. See
-	   wavefront_send_multisample() for the other half of this
-	   gross and ugly strategy.
-	*/
-
-	if (cmd == WFC_DOWNLOAD_MULTISAMPLE) {
-		wfcmd->write_cnt = (unsigned int) rbuf;
-		rbuf = NULL;
-	}
-
-	DPRINT (WF_DEBUG_CMD, "0x%x [%s] (%d,%d,%d)\n",
-			       cmd, wfcmd->action, wfcmd->read_cnt,
-			       wfcmd->write_cnt, wfcmd->need_ack);
-    
-	if (wavefront_write (cmd)) { 
-		DPRINT ((WF_DEBUG_IO|WF_DEBUG_CMD), "cannot request "
-						     "0x%x [%s].\n",
-						     cmd, wfcmd->action);
-		return 1;
-	} 
-
-	if (wfcmd->write_cnt > 0) {
-		DPRINT (WF_DEBUG_DATA, "writing %d bytes "
-					"for 0x%x\n",
-					wfcmd->write_cnt, cmd);
-
-		for (i = 0; i < wfcmd->write_cnt; i++) {
-			if (wavefront_write (wbuf[i])) {
-				DPRINT (WF_DEBUG_IO, "bad write for byte "
-						      "%d of 0x%x [%s].\n",
-						      i, cmd, wfcmd->action);
-				return 1;
-			}
-
-			DPRINT (WF_DEBUG_DATA, "write[%d] = 0x%x\n",
-						i, wbuf[i]);
-		}
-	}
-
-	if (wfcmd->read_cnt > 0) {
-		DPRINT (WF_DEBUG_DATA, "reading %d ints "
-					"for 0x%x\n",
-					wfcmd->read_cnt, cmd);
-
-		for (i = 0; i < wfcmd->read_cnt; i++) {
-
-			if ((c = wavefront_read()) == -1) {
-				DPRINT (WF_DEBUG_IO, "bad read for byte "
-						      "%d of 0x%x [%s].\n",
-						      i, cmd, wfcmd->action);
-				return 1;
-			}
-
-			/* Now handle errors. Lots of special cases here */
-	    
-			if (c == 0xff) { 
-				if ((c = wavefront_read ()) == -1) {
-					DPRINT (WF_DEBUG_IO, "bad read for "
-							      "error byte at "
-							      "read byte %d "
-							      "of 0x%x [%s].\n",
-							      i, cmd,
-							      wfcmd->action);
-					return 1;
-				}
-
-				/* Can you believe this madness ? */
-
-				if (c == 1 &&
-				    wfcmd->cmd == WFC_IDENTIFY_SAMPLE_TYPE) {
-					rbuf[0] = WF_ST_EMPTY;
-					return (0);
-
-				} else if (c == 3 &&
-					   wfcmd->cmd == WFC_UPLOAD_PATCH) {
-
-					return 3;
-
-				} else if (c == 1 &&
-					   wfcmd->cmd == WFC_UPLOAD_PROGRAM) {
-
-					return 1;
-
-				} else {
-
-					DPRINT (WF_DEBUG_IO, "error %d (%s) "
-							      "during "
-							      "read for byte "
-							      "%d of 0x%x "
-							      "[%s].\n",
-							      c,
-							      wavefront_errorstr (c),
-							      i, cmd,
-							      wfcmd->action);
-					return 1;
-
-				}
-		
-		} else {
-				rbuf[i] = c;
-			}
-			
-			DPRINT (WF_DEBUG_DATA, "read[%d] = 0x%x\n",i, rbuf[i]);
-		}
-	}
-	
-	if ((wfcmd->read_cnt == 0 && wfcmd->write_cnt == 0) || wfcmd->need_ack) {
-
-		DPRINT (WF_DEBUG_CMD, "reading ACK for 0x%x\n", cmd);
-
-		/* Some commands need an ACK, but return zero instead
-		   of the standard value.
-		*/
-	    
-		if ((ack = wavefront_read()) == 0) {
-			ack = WF_ACK;
-		}
-	
-		if (ack != WF_ACK) {
-			if (ack == -1) {
-				DPRINT (WF_DEBUG_IO, "cannot read ack for "
-						      "0x%x [%s].\n",
-						      cmd, wfcmd->action);
-				return 1;
-		
-			} else {
-				int err = -1; /* something unknown */
-
-				if (ack == 0xff) { /* explicit error */
-		    
-					if ((err = wavefront_read ()) == -1) {
-						DPRINT (WF_DEBUG_DATA,
-							"cannot read err "
-							"for 0x%x [%s].\n",
-							cmd, wfcmd->action);
-					}
-				}
-				
-				DPRINT (WF_DEBUG_IO, "0x%x [%s] "
-					"failed (0x%x, 0x%x, %s)\n",
-					cmd, wfcmd->action, ack, err,
-					wavefront_errorstr (err));
-				
-				return -err;
-			}
-		}
-		
-		DPRINT (WF_DEBUG_DATA, "ack received "
-					"for 0x%x [%s]\n",
-					cmd, wfcmd->action);
-	} else {
-
-		DPRINT (WF_DEBUG_CMD, "0x%x [%s] does not need "
-				       "ACK (%d,%d,%d)\n",
-				       cmd, wfcmd->action, wfcmd->read_cnt,
-				       wfcmd->write_cnt, wfcmd->need_ack);
-	}
-
-	return 0;
-	
-}
-
-/***********************************************************************
-WaveFront: data munging   
-
-Things here are weird. All data written to the board cannot 
-have its most significant bit set. Any data item with values 
-potentially > 0x7F (127) must be split across multiple bytes.
-
-Sometimes, we need to munge numeric values that are represented on
-the x86 side as 8-32 bit values. Sometimes, we need to munge data
-that is represented on the x86 side as an array of bytes. The most
-efficient approach to handling both cases seems to be to use 2
-different functions for munging and 2 for de-munging. This avoids
-weird casting and worrying about bit-level offsets.
-
-**********************************************************************/
-
-static 
-unsigned char *
-munge_int32 (unsigned int src,
-	     unsigned char *dst,
-	     unsigned int dst_size)
-{
-	int i;
-
-	for (i = 0;i < dst_size; i++) {
-		*dst = src & 0x7F;  /* Mask high bit of LSB */
-		src = src >> 7;     /* Rotate Right 7 bits  */
-	                            /* Note: we leave the upper bits in place */ 
-
-		dst++;
- 	};
-	return dst;
-};
-
-static int 
-demunge_int32 (unsigned char* src, int src_size)
-
-{
-	int i;
- 	int outval = 0;
-	
- 	for (i = src_size - 1; i >= 0; i--) {
-		outval=(outval<<7)+src[i];
-	}
-
-	return outval;
-};
-
-static 
-unsigned char *
-munge_buf (unsigned char *src, unsigned char *dst, unsigned int dst_size)
-
-{
-	int i;
-	unsigned int last = dst_size / 2;
-
-	for (i = 0; i < last; i++) {
-		*dst++ = src[i] & 0x7f;
-		*dst++ = src[i] >> 7;
-	}
-	return dst;
-}
-
-static 
-unsigned char *
-demunge_buf (unsigned char *src, unsigned char *dst, unsigned int src_bytes)
-
-{
-	int i;
-	unsigned char *end = src + src_bytes;
-    
-	end = src + src_bytes;
-
-	/* NOTE: src and dst *CAN* point to the same address */
-
-	for (i = 0; src != end; i++) {
-		dst[i] = *src++;
-		dst[i] |= (*src++)<<7;
-	}
-
-	return dst;
-}
-
-/***********************************************************************
-WaveFront: sample, patch and program management.
-***********************************************************************/
-
-static int
-wavefront_delete_sample (int sample_num)
-
-{
-	unsigned char wbuf[2];
-	int x;
-
-	wbuf[0] = sample_num & 0x7f;
-	wbuf[1] = sample_num >> 7;
-
-	if ((x = wavefront_cmd (WFC_DELETE_SAMPLE, NULL, wbuf)) == 0) {
-		dev.sample_status[sample_num] = WF_ST_EMPTY;
-	}
-
-	return x;
-}
-
-static int
-wavefront_get_sample_status (int assume_rom)
-
-{
-	int i;
-	unsigned char rbuf[32], wbuf[32];
-	unsigned int    sc_real, sc_alias, sc_multi;
-
-	/* check sample status */
-    
-	if (wavefront_cmd (WFC_GET_NSAMPLES, rbuf, wbuf)) {
-		printk (KERN_WARNING LOGNAME "cannot request sample count.\n");
-		return -1;
-	} 
-    
-	sc_real = sc_alias = sc_multi = dev.samples_used = 0;
-    
-	for (i = 0; i < WF_MAX_SAMPLE; i++) {
-	
-		wbuf[0] = i & 0x7f;
-		wbuf[1] = i >> 7;
-
-		if (wavefront_cmd (WFC_IDENTIFY_SAMPLE_TYPE, rbuf, wbuf)) {
-			printk (KERN_WARNING LOGNAME
-				"cannot identify sample "
-				"type of slot %d\n", i);
-			dev.sample_status[i] = WF_ST_EMPTY;
-			continue;
-		}
-
-		dev.sample_status[i] = (WF_SLOT_FILLED|rbuf[0]);
-
-		if (assume_rom) {
-			dev.sample_status[i] |= WF_SLOT_ROM;
-		}
-
-		switch (rbuf[0] & WF_ST_MASK) {
-		case WF_ST_SAMPLE:
-			sc_real++;
-			break;
-		case WF_ST_MULTISAMPLE:
-			sc_multi++;
-			break;
-		case WF_ST_ALIAS:
-			sc_alias++;
-			break;
-		case WF_ST_EMPTY:
-			break;
-
-		default:
-			printk (KERN_WARNING LOGNAME "unknown sample type for "
-				"slot %d (0x%x)\n", 
-				i, rbuf[0]);
-		}
-
-		if (rbuf[0] != WF_ST_EMPTY) {
-			dev.samples_used++;
-		} 
-	}
-
-	printk (KERN_INFO LOGNAME
-		"%d samples used (%d real, %d aliases, %d multi), "
-		"%d empty\n", dev.samples_used, sc_real, sc_alias, sc_multi,
-		WF_MAX_SAMPLE - dev.samples_used);
-
-
-	return (0);
-
-}
-
-static int
-wavefront_get_patch_status (void)
-
-{
-	unsigned char patchbuf[WF_PATCH_BYTES];
-	unsigned char patchnum[2];
-	wavefront_patch *p;
-	int i, x, cnt, cnt2;
-
-	for (i = 0; i < WF_MAX_PATCH; i++) {
-		patchnum[0] = i & 0x7f;
-		patchnum[1] = i >> 7;
-
-		if ((x = wavefront_cmd (WFC_UPLOAD_PATCH, patchbuf,
-					patchnum)) == 0) {
-
-			dev.patch_status[i] |= WF_SLOT_FILLED;
-			p = (wavefront_patch *) patchbuf;
-			dev.sample_status
-				[p->sample_number|(p->sample_msb<<7)] |=
-				WF_SLOT_USED;
-	    
-		} else if (x == 3) { /* Bad patch number */
-			dev.patch_status[i] = 0;
-		} else {
-			printk (KERN_ERR LOGNAME "upload patch "
-				"error 0x%x\n", x);
-			dev.patch_status[i] = 0;
-			return 1;
-		}
-	}
-
-	/* program status has already filled in slot_used bits */
-
-	for (i = 0, cnt = 0, cnt2 = 0; i < WF_MAX_PATCH; i++) {
-		if (dev.patch_status[i] & WF_SLOT_FILLED) {
-			cnt++;
-		}
-		if (dev.patch_status[i] & WF_SLOT_USED) {
-			cnt2++;
-		}
-	
-	}
-	printk (KERN_INFO LOGNAME
-		"%d patch slots filled, %d in use\n", cnt, cnt2);
-
-	return (0);
-}
-
-static int
-wavefront_get_program_status (void)
-
-{
-	unsigned char progbuf[WF_PROGRAM_BYTES];
-	wavefront_program prog;
-	unsigned char prognum;
-	int i, x, l, cnt;
-
-	for (i = 0; i < WF_MAX_PROGRAM; i++) {
-		prognum = i;
-
-		if ((x = wavefront_cmd (WFC_UPLOAD_PROGRAM, progbuf,
-					&prognum)) == 0) {
-
-			dev.prog_status[i] |= WF_SLOT_USED;
-
-			demunge_buf (progbuf, (unsigned char *) &prog,
-				     WF_PROGRAM_BYTES);
-
-			for (l = 0; l < WF_NUM_LAYERS; l++) {
-				if (prog.layer[l].mute) {
-					dev.patch_status
-						[prog.layer[l].patch_number] |=
-						WF_SLOT_USED;
-				}
-			}
-		} else if (x == 1) { /* Bad program number */
-			dev.prog_status[i] = 0;
-		} else {
-			printk (KERN_ERR LOGNAME "upload program "
-				"error 0x%x\n", x);
-			dev.prog_status[i] = 0;
-		}
-	}
-
-	for (i = 0, cnt = 0; i < WF_MAX_PROGRAM; i++) {
-		if (dev.prog_status[i]) {
-			cnt++;
-		}
-	}
-
-	printk (KERN_INFO LOGNAME "%d programs slots in use\n", cnt);
-
-	return (0);
-}
-
-static int
-wavefront_send_patch (wavefront_patch_info *header)
-
-{
-	unsigned char buf[WF_PATCH_BYTES+2];
-	unsigned char *bptr;
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "downloading patch %d\n",
-				      header->number);
-
-	dev.patch_status[header->number] |= WF_SLOT_FILLED;
-
-	bptr = buf;
-	bptr = munge_int32 (header->number, buf, 2);
-	munge_buf ((unsigned char *)&header->hdr.p, bptr, WF_PATCH_BYTES);
-    
-	if (wavefront_cmd (WFC_DOWNLOAD_PATCH, NULL, buf)) {
-		printk (KERN_ERR LOGNAME "download patch failed\n");
-		return -(EIO);
-	}
-
-	return (0);
-}
-
-static int
-wavefront_send_program (wavefront_patch_info *header)
-
-{
-	unsigned char buf[WF_PROGRAM_BYTES+1];
-	int i;
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "downloading program %d\n",
-		header->number);
-
-	dev.prog_status[header->number] = WF_SLOT_USED;
-
-	/* XXX need to zero existing SLOT_USED bit for program_status[i]
-	   where `i' is the program that's being (potentially) overwritten.
-	*/
-    
-	for (i = 0; i < WF_NUM_LAYERS; i++) {
-		if (header->hdr.pr.layer[i].mute) {
-			dev.patch_status[header->hdr.pr.layer[i].patch_number] |=
-				WF_SLOT_USED;
-
-			/* XXX need to mark SLOT_USED for sample used by
-			   patch_number, but this means we have to load it. Ick.
-			*/
-		}
-	}
-
-	buf[0] = header->number;
-	munge_buf ((unsigned char *)&header->hdr.pr, &buf[1], WF_PROGRAM_BYTES);
-    
-	if (wavefront_cmd (WFC_DOWNLOAD_PROGRAM, NULL, buf)) {
-		printk (KERN_WARNING LOGNAME "download patch failed\n");	
-		return -(EIO);
-	}
-
-	return (0);
-}
-
-static int
-wavefront_freemem (void)
-
-{
-	char rbuf[8];
-
-	if (wavefront_cmd (WFC_REPORT_FREE_MEMORY, rbuf, NULL)) {
-		printk (KERN_WARNING LOGNAME "can't get memory stats.\n");
-		return -1;
-	} else {
-		return demunge_int32 (rbuf, 4);
-	}
-}
-
-static int
-wavefront_send_sample (wavefront_patch_info *header,
-		       UINT16 __user *dataptr,
-		       int data_is_unsigned)
-
-{
-	/* samples are downloaded via a 16-bit wide i/o port
-	   (you could think of it as 2 adjacent 8-bit wide ports
-	   but its less efficient that way). therefore, all
-	   the blocksizes and so forth listed in the documentation,
-	   and used conventionally to refer to sample sizes,
-	   which are given in 8-bit units (bytes), need to be
-	   divided by 2.
-        */
-
-	UINT16 sample_short;
-	UINT32 length;
-	UINT16 __user *data_end = NULL;
-	unsigned int i;
-	const int max_blksize = 4096/2;
-	unsigned int written;
-	unsigned int blocksize;
-	int dma_ack;
-	int blocknum;
-	unsigned char sample_hdr[WF_SAMPLE_HDR_BYTES];
-	unsigned char *shptr;
-	int skip = 0;
-	int initial_skip = 0;
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "sample %sdownload for slot %d, "
-				      "type %d, %d bytes from %p\n",
-				      header->size ? "" : "header ", 
-				      header->number, header->subkey,
-				      header->size,
-				      header->dataptr);
-
-	if (header->number == WAVEFRONT_FIND_FREE_SAMPLE_SLOT) {
-		int x;
-
-		if ((x = wavefront_find_free_sample ()) < 0) {
-			return -ENOMEM;
-		}
-		printk (KERN_DEBUG LOGNAME "unspecified sample => %d\n", x);
-		header->number = x;
-	}
-
-	if (header->size) {
-
-		/* XXX it's a debatable point whether or not RDONLY semantics
-		   on the ROM samples should cover just the sample data or
-		   the sample header. For now, it only covers the sample data,
-		   so anyone is free at all times to rewrite sample headers.
-
-		   My reason for this is that we have the sample headers
-		   available in the WFB file for General MIDI, and so these
-		   can always be reset if needed. The sample data, however,
-		   cannot be recovered without a complete reset and firmware
-		   reload of the ICS2115, which is a very expensive operation.
-
-		   So, doing things this way allows us to honor the notion of
-		   "RESETSAMPLES" reasonably cheaply. Note however, that this
-		   is done purely at user level: there is no WFB parser in
-		   this driver, and so a complete reset (back to General MIDI,
-		   or theoretically some other configuration) is the
-		   responsibility of the user level library. 
-
-		   To try to do this in the kernel would be a little
-		   crazy: we'd need 158K of kernel space just to hold
-		   a copy of the patch/program/sample header data.
-		*/
-
-		if (dev.rom_samples_rdonly) {
-			if (dev.sample_status[header->number] & WF_SLOT_ROM) {
-				printk (KERN_ERR LOGNAME "sample slot %d "
-					"write protected\n",
-					header->number);
-				return -EACCES;
-			}
-		}
-
-		wavefront_delete_sample (header->number);
-	}
-
-	if (header->size) {
-		dev.freemem = wavefront_freemem ();
-
-		if (dev.freemem < header->size) {
-			printk (KERN_ERR LOGNAME
-				"insufficient memory to "
-				"load %d byte sample.\n",
-				header->size);
-			return -ENOMEM;
-		}
-	
-	}
-
-	skip = WF_GET_CHANNEL(&header->hdr.s);
-
-	if (skip > 0 && header->hdr.s.SampleResolution != LINEAR_16BIT) {
-		printk (KERN_ERR LOGNAME "channel selection only "
-			"possible on 16-bit samples");
-		return -(EINVAL);
-	}
-
-	switch (skip) {
-	case 0:
-		initial_skip = 0;
-		skip = 1;
-		break;
-	case 1:
-		initial_skip = 0;
-		skip = 2;
-		break;
-	case 2:
-		initial_skip = 1;
-		skip = 2;
-		break;
-	case 3:
-		initial_skip = 2;
-		skip = 3;
-		break;
-	case 4:
-		initial_skip = 3;
-		skip = 4;
-		break;
-	case 5:
-		initial_skip = 4;
-		skip = 5;
-		break;
-	case 6:
-		initial_skip = 5;
-		skip = 6;
-		break;
-	}
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "channel selection: %d => "
-				      "initial skip = %d, skip = %d\n",
-				      WF_GET_CHANNEL (&header->hdr.s),
-				      initial_skip, skip);
-    
-	/* Be safe, and zero the "Unused" bits ... */
-
-	WF_SET_CHANNEL(&header->hdr.s, 0);
-
-	/* adjust size for 16 bit samples by dividing by two.  We always
-	   send 16 bits per write, even for 8 bit samples, so the length
-	   is always half the size of the sample data in bytes.
-	*/
-
-	length = header->size / 2;
-
-	/* the data we're sent has not been munged, and in fact, the
-	   header we have to send isn't just a munged copy either.
-	   so, build the sample header right here.
-	*/
-
-	shptr = &sample_hdr[0];
-
-	shptr = munge_int32 (header->number, shptr, 2);
-
-	if (header->size) {
-		shptr = munge_int32 (length, shptr, 4);
-	}
-
-	/* Yes, a 4 byte result doesn't contain all of the offset bits,
-	   but the offset only uses 24 bits.
-	*/
-
-	shptr = munge_int32 (*((UINT32 *) &header->hdr.s.sampleStartOffset),
-			     shptr, 4);
-	shptr = munge_int32 (*((UINT32 *) &header->hdr.s.loopStartOffset),
-			     shptr, 4);
-	shptr = munge_int32 (*((UINT32 *) &header->hdr.s.loopEndOffset),
-			     shptr, 4);
-	shptr = munge_int32 (*((UINT32 *) &header->hdr.s.sampleEndOffset),
-			     shptr, 4);
-	
-	/* This one is truly weird. What kind of weirdo decided that in
-	   a system dominated by 16 and 32 bit integers, they would use
-	   a just 12 bits ?
-	*/
-	
-	shptr = munge_int32 (header->hdr.s.FrequencyBias, shptr, 3);
-	
-	/* Why is this nybblified, when the MSB is *always* zero ? 
-	   Anyway, we can't take address of bitfield, so make a
-	   good-faith guess at where it starts.
-	*/
-	
-	shptr = munge_int32 (*(&header->hdr.s.FrequencyBias+1),
-			     shptr, 2);
-
-	if (wavefront_cmd (header->size ?
-			   WFC_DOWNLOAD_SAMPLE : WFC_DOWNLOAD_SAMPLE_HEADER,
-			   NULL, sample_hdr)) {
-		printk (KERN_WARNING LOGNAME "sample %sdownload refused.\n",
-			header->size ? "" : "header ");
-		return -(EIO);
-	}
-
-	if (header->size == 0) {
-		goto sent; /* Sorry. Just had to have one somewhere */
-	}
-    
-	data_end = dataptr + length;
-
-	/* Do any initial skip over an unused channel's data */
-
-	dataptr += initial_skip;
-    
-	for (written = 0, blocknum = 0;
-	     written < length; written += max_blksize, blocknum++) {
-	
-		if ((length - written) > max_blksize) {
-			blocksize = max_blksize;
-		} else {
-			/* round to nearest 16-byte value */
-			blocksize = ((length-written+7)&~0x7);
-		}
-
-		if (wavefront_cmd (WFC_DOWNLOAD_BLOCK, NULL, NULL)) {
-			printk (KERN_WARNING LOGNAME "download block "
-				"request refused.\n");
-			return -(EIO);
-		}
-
-		for (i = 0; i < blocksize; i++) {
-
-			if (dataptr < data_end) {
-		
-				__get_user (sample_short, dataptr);
-				dataptr += skip;
-		
-				if (data_is_unsigned) { /* GUS ? */
-
-					if (WF_SAMPLE_IS_8BIT(&header->hdr.s)) {
-			
-						/* 8 bit sample
-						 resolution, sign
-						 extend both bytes.
-						*/
-			
-						((unsigned char*)
-						 &sample_short)[0] += 0x7f;
-						((unsigned char*)
-						 &sample_short)[1] += 0x7f;
-			
-					} else {
-			
-						/* 16 bit sample
-						 resolution, sign
-						 extend the MSB.
-						*/
-			
-						sample_short += 0x7fff;
-					}
-				}
-
-			} else {
-
-				/* In padding section of final block:
-
-				   Don't fetch unsupplied data from
-				   user space, just continue with
-				   whatever the final value was.
-				*/
-			}
-	    
-			if (i < blocksize - 1) {
-				outw (sample_short, dev.block_port);
-			} else {
-				outw (sample_short, dev.last_block_port);
-			}
-		}
-
-		/* Get "DMA page acknowledge", even though its really
-		   nothing to do with DMA at all.
-		*/
-	
-		if ((dma_ack = wavefront_read ()) != WF_DMA_ACK) {
-			if (dma_ack == -1) {
-				printk (KERN_ERR LOGNAME "upload sample "
-					"DMA ack timeout\n");
-				return -(EIO);
-			} else {
-				printk (KERN_ERR LOGNAME "upload sample "
-					"DMA ack error 0x%x\n",
-					dma_ack);
-				return -(EIO);
-			}
-		}
-	}
-
-	dev.sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_SAMPLE);
-
-	/* Note, label is here because sending the sample header shouldn't
-	   alter the sample_status info at all.
-	*/
-
- sent:
-	return (0);
-}
-
-static int
-wavefront_send_alias (wavefront_patch_info *header)
-
-{
-	unsigned char alias_hdr[WF_ALIAS_BYTES];
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "download alias, %d is "
-				      "alias for %d\n",
-				      header->number,
-				      header->hdr.a.OriginalSample);
-    
-	munge_int32 (header->number, &alias_hdr[0], 2);
-	munge_int32 (header->hdr.a.OriginalSample, &alias_hdr[2], 2);
-	munge_int32 (*((unsigned int *)&header->hdr.a.sampleStartOffset),
-		     &alias_hdr[4], 4);
-	munge_int32 (*((unsigned int *)&header->hdr.a.loopStartOffset),
-		     &alias_hdr[8], 4);
-	munge_int32 (*((unsigned int *)&header->hdr.a.loopEndOffset),
-		     &alias_hdr[12], 4);
-	munge_int32 (*((unsigned int *)&header->hdr.a.sampleEndOffset),
-		     &alias_hdr[16], 4);
-	munge_int32 (header->hdr.a.FrequencyBias, &alias_hdr[20], 3);
-	munge_int32 (*(&header->hdr.a.FrequencyBias+1), &alias_hdr[23], 2);
-
-	if (wavefront_cmd (WFC_DOWNLOAD_SAMPLE_ALIAS, NULL, alias_hdr)) {
-		printk (KERN_ERR LOGNAME "download alias failed.\n");
-		return -(EIO);
-	}
-
-	dev.sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_ALIAS);
-
-	return (0);
-}
-
-static int
-wavefront_send_multisample (wavefront_patch_info *header)
-{
-	int i;
-	int num_samples;
-	unsigned char msample_hdr[WF_MSAMPLE_BYTES];
-
-	munge_int32 (header->number, &msample_hdr[0], 2);
-
-	/* You'll recall at this point that the "number of samples" value
-	   in a wavefront_multisample struct is actually the log2 of the
-	   real number of samples.
-	*/
-
-	num_samples = (1<<(header->hdr.ms.NumberOfSamples&7));
-	msample_hdr[2] = (unsigned char) header->hdr.ms.NumberOfSamples;
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "multi %d with %d=%d samples\n",
-				      header->number,
-				      header->hdr.ms.NumberOfSamples,
-				      num_samples);
-
-	for (i = 0; i < num_samples; i++) {
-		DPRINT(WF_DEBUG_LOAD_PATCH|WF_DEBUG_DATA, "sample[%d] = %d\n",
-		       i, header->hdr.ms.SampleNumber[i]);
-		munge_int32 (header->hdr.ms.SampleNumber[i],
-		     &msample_hdr[3+(i*2)], 2);
-	}
-    
-	/* Need a hack here to pass in the number of bytes
-	   to be written to the synth. This is ugly, and perhaps
-	   one day, I'll fix it.
-	*/
-
-	if (wavefront_cmd (WFC_DOWNLOAD_MULTISAMPLE, 
-			   (unsigned char *) ((num_samples*2)+3),
-			   msample_hdr)) {
-		printk (KERN_ERR LOGNAME "download of multisample failed.\n");
-		return -(EIO);
-	}
-
-	dev.sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_MULTISAMPLE);
-
-	return (0);
-}
-
-static int
-wavefront_fetch_multisample (wavefront_patch_info *header)
-{
-	int i;
-	unsigned char log_ns[1];
-	unsigned char number[2];
-	int num_samples;
-
-	munge_int32 (header->number, number, 2);
-    
-	if (wavefront_cmd (WFC_UPLOAD_MULTISAMPLE, log_ns, number)) {
-		printk (KERN_ERR LOGNAME "upload multisample failed.\n");
-		return -(EIO);
-	}
-    
-	DPRINT (WF_DEBUG_DATA, "msample %d has %d samples\n",
-				header->number, log_ns[0]);
-
-	header->hdr.ms.NumberOfSamples = log_ns[0];
-
-	/* get the number of samples ... */
-
-	num_samples = (1 << log_ns[0]);
-    
-	for (i = 0; i < num_samples; i++) {
-		s8 d[2];
-	
-		if ((d[0] = wavefront_read ()) == -1) {
-			printk (KERN_ERR LOGNAME "upload multisample failed "
-				"during sample loop.\n");
-			return -(EIO);
-		}
-
-		if ((d[1] = wavefront_read ()) == -1) {
-			printk (KERN_ERR LOGNAME "upload multisample failed "
-				"during sample loop.\n");
-			return -(EIO);
-		}
-	
-		header->hdr.ms.SampleNumber[i] =
-			demunge_int32 ((unsigned char *) d, 2);
-	
-		DPRINT (WF_DEBUG_DATA, "msample sample[%d] = %d\n",
-					i, header->hdr.ms.SampleNumber[i]);
-	}
-
-	return (0);
-}
-
-
-static int
-wavefront_send_drum (wavefront_patch_info *header)
-
-{
-	unsigned char drumbuf[WF_DRUM_BYTES];
-	wavefront_drum *drum = &header->hdr.d;
-	int i;
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "downloading edrum for MIDI "
-		"note %d, patch = %d\n", 
-		header->number, drum->PatchNumber);
-
-	drumbuf[0] = header->number & 0x7f;
-
-	for (i = 0; i < 4; i++) {
-		munge_int32 (((unsigned char *)drum)[i], &drumbuf[1+(i*2)], 2);
-	}
-
-	if (wavefront_cmd (WFC_DOWNLOAD_EDRUM_PROGRAM, NULL, drumbuf)) {
-		printk (KERN_ERR LOGNAME "download drum failed.\n");
-		return -(EIO);
-	}
-
-	return (0);
-}
-
-static int 
-wavefront_find_free_sample (void)
-
-{
-	int i;
-
-	for (i = 0; i < WF_MAX_SAMPLE; i++) {
-		if (!(dev.sample_status[i] & WF_SLOT_FILLED)) {
-			return i;
-		}
-	}
-	printk (KERN_WARNING LOGNAME "no free sample slots!\n");
-	return -1;
-}
-
-static int 
-wavefront_find_free_patch (void)
-
-{
-	int i;
-
-	for (i = 0; i < WF_MAX_PATCH; i++) {
-		if (!(dev.patch_status[i] & WF_SLOT_FILLED)) {
-			return i;
-		}
-	}
-	printk (KERN_WARNING LOGNAME "no free patch slots!\n");
-	return -1;
-}
-
-static int 
-log2_2048(int n)
-
-{
-	int tbl[]={0, 0, 2048, 3246, 4096, 4755, 5294, 5749, 6143,
-		   6492, 6803, 7084, 7342, 7578, 7797, 8001, 8192,
-		   8371, 8540, 8699, 8851, 8995, 9132, 9264, 9390,
-		   9510, 9626, 9738, 9845, 9949, 10049, 10146};
-	int i;
-
-	/* Returns 2048*log2(n) */
-
-	/* FIXME: this is like doing integer math
-	   on quantum particles (RuN) */
-
-	i=0;
-	while(n>=32*256) {
-		n>>=8;
-		i+=2048*8;
-	}
-	while(n>=32) {
-		n>>=1;
-		i+=2048;
-	}
-	i+=tbl[n];
-	return(i);
-}
-
-static int
-wavefront_load_gus_patch (int devno, int format, const char __user *addr,
-			  int offs, int count, int pmgr_flag)
-{
-	struct patch_info guspatch;
-	wavefront_patch_info *samp, *pat, *prog;
-	wavefront_patch *patp;
-	wavefront_sample *sampp;
-	wavefront_program *progp;
-
-	int i,base_note;
-	long sizeof_patch;
-	int rc = -ENOMEM;
-
-	samp = kmalloc(3 * sizeof(wavefront_patch_info), GFP_KERNEL);
-	if (!samp)
-		goto free_fail;
-	pat = samp + 1;
-	prog = pat + 1;
-
-	/* Copy in the header of the GUS patch */
-
-	sizeof_patch = (long) &guspatch.data[0] - (long) &guspatch; 
-	if (copy_from_user(&((char *) &guspatch)[offs],
-			   &(addr)[offs], sizeof_patch - offs)) {
-		rc = -EFAULT;
-		goto free_fail;
-	}
-
-	if ((i = wavefront_find_free_patch ()) == -1) {
-		rc = -EBUSY;
-		goto free_fail;
-	}
-	pat->number = i;
-	pat->subkey = WF_ST_PATCH;
-	patp = &pat->hdr.p;
-
-	if ((i = wavefront_find_free_sample ()) == -1) {
-		rc = -EBUSY;
-		goto free_fail;
-	}
-	samp->number = i;
-	samp->subkey = WF_ST_SAMPLE;
-	samp->size = guspatch.len;
-	sampp = &samp->hdr.s;
-
-	prog->number = guspatch.instr_no;
-	progp = &prog->hdr.pr;
-
-	/* Setup the patch structure */
-
-	patp->amplitude_bias=guspatch.volume;
-	patp->portamento=0;
-	patp->sample_number= samp->number & 0xff;
-	patp->sample_msb= samp->number >> 8;
-	patp->pitch_bend= /*12*/ 0;
-	patp->mono=1;
-	patp->retrigger=1;
-	patp->nohold=(guspatch.mode & WAVE_SUSTAIN_ON) ? 0:1;
-	patp->frequency_bias=0;
-	patp->restart=0;
-	patp->reuse=0;
-	patp->reset_lfo=1;
-	patp->fm_src2=0;
-	patp->fm_src1=WF_MOD_MOD_WHEEL;
-	patp->am_src=WF_MOD_PRESSURE;
-	patp->am_amount=127;
-	patp->fc1_mod_amount=0;
-	patp->fc2_mod_amount=0; 
-	patp->fm_amount1=0;
-	patp->fm_amount2=0;
-	patp->envelope1.attack_level=127;
-	patp->envelope1.decay1_level=127;
-	patp->envelope1.decay2_level=127;
-	patp->envelope1.sustain_level=127;
-	patp->envelope1.release_level=0;
-	patp->envelope2.attack_velocity=127;
-	patp->envelope2.attack_level=127;
-	patp->envelope2.decay1_level=127;
-	patp->envelope2.decay2_level=127;
-	patp->envelope2.sustain_level=127;
-	patp->envelope2.release_level=0;
-	patp->envelope2.attack_velocity=127;
-	patp->randomizer=0;
-
-	/* Program for this patch */
-
-	progp->layer[0].patch_number= pat->number; /* XXX is this right ? */
-	progp->layer[0].mute=1;
-	progp->layer[0].pan_or_mod=1;
-	progp->layer[0].pan=7;
-	progp->layer[0].mix_level=127  /* guspatch.volume */;
-	progp->layer[0].split_type=0;
-	progp->layer[0].split_point=0;
-	progp->layer[0].play_below=0;
-
-	for (i = 1; i < 4; i++) {
-		progp->layer[i].mute=0;
-	}
-
-	/* Sample data */
-
-	sampp->SampleResolution=((~guspatch.mode & WAVE_16_BITS)<<1);
-
-	for (base_note=0;
-	     note_to_freq (base_note) < guspatch.base_note;
-	     base_note++);
-
-	if ((guspatch.base_note-note_to_freq(base_note))
-	    >(note_to_freq(base_note)-guspatch.base_note))
-		base_note++;
-
-	printk(KERN_DEBUG "ref freq=%d,base note=%d\n",
-	       guspatch.base_freq,
-	       base_note);
-
-	sampp->FrequencyBias = (29550 - log2_2048(guspatch.base_freq)
-				+ base_note*171);
-	printk(KERN_DEBUG "Freq Bias is %d\n", sampp->FrequencyBias);
-	sampp->Loop=(guspatch.mode & WAVE_LOOPING) ? 1:0;
-	sampp->sampleStartOffset.Fraction=0;
-	sampp->sampleStartOffset.Integer=0;
-	sampp->loopStartOffset.Fraction=0;
-	sampp->loopStartOffset.Integer=guspatch.loop_start
-		>>((guspatch.mode&WAVE_16_BITS) ? 1:0);
-	sampp->loopEndOffset.Fraction=0;
-	sampp->loopEndOffset.Integer=guspatch.loop_end
-		>>((guspatch.mode&WAVE_16_BITS) ? 1:0);
-	sampp->sampleEndOffset.Fraction=0;
-	sampp->sampleEndOffset.Integer=guspatch.len >> (guspatch.mode&1);
-	sampp->Bidirectional=(guspatch.mode&WAVE_BIDIR_LOOP) ? 1:0;
-	sampp->Reverse=(guspatch.mode&WAVE_LOOP_BACK) ? 1:0;
-
-	/* Now ship it down */
-
-	wavefront_send_sample (samp,
-			       (unsigned short __user *) &(addr)[sizeof_patch],
-			       (guspatch.mode & WAVE_UNSIGNED) ? 1:0);
-	wavefront_send_patch (pat);
-	wavefront_send_program (prog);
-
-	/* Now pan as best we can ... use the slave/internal MIDI device
-	   number if it exists (since it talks to the WaveFront), or the
-	   master otherwise.
-	*/
-
-	if (dev.mididev > 0) {
-		midi_synth_controller (dev.mididev, guspatch.instr_no, 10,
-				       ((guspatch.panning << 4) > 127) ?
-				       127 : (guspatch.panning << 4));
-	}
-	rc = 0;
-
-free_fail:
-	kfree(samp);
-	return rc;
-}
-
-static int
-wavefront_load_patch (const char __user *addr)
-
-
-{
-	wavefront_patch_info header;
-	
-	if (copy_from_user (&header, addr, sizeof(wavefront_patch_info) -
-			    sizeof(wavefront_any))) {
-		printk (KERN_WARNING LOGNAME "bad address for load patch.\n");
-		return -EFAULT;
-	}
-
-	DPRINT (WF_DEBUG_LOAD_PATCH, "download "
-				      "Sample type: %d "
-				      "Sample number: %d "
-				      "Sample size: %d\n",
-				      header.subkey,
-				      header.number,
-				      header.size);
-
-	switch (header.subkey) {
-	case WF_ST_SAMPLE:  /* sample or sample_header, based on patch->size */
-
-		if (copy_from_user((unsigned char *) &header.hdr.s,
-				   (unsigned char __user *) header.hdrptr,
-				   sizeof (wavefront_sample)))
-			return -EFAULT;
-
-		return wavefront_send_sample (&header, header.dataptr, 0);
-
-	case WF_ST_MULTISAMPLE:
-
-		if (copy_from_user(&header.hdr.s, header.hdrptr,
-				   sizeof(wavefront_multisample)))
-			return -EFAULT;
-
-		return wavefront_send_multisample (&header);
-
-
-	case WF_ST_ALIAS:
-
-		if (copy_from_user(&header.hdr.a, header.hdrptr,
-				   sizeof (wavefront_alias)))
-			return -EFAULT;
-
-		return wavefront_send_alias (&header);
-
-	case WF_ST_DRUM:
-		if (copy_from_user(&header.hdr.d, header.hdrptr,
-				   sizeof (wavefront_drum)))
-			return -EFAULT;
-
-		return wavefront_send_drum (&header);
-
-	case WF_ST_PATCH:
-		if (copy_from_user(&header.hdr.p, header.hdrptr,
-				   sizeof (wavefront_patch)))
-			return -EFAULT;
-
-		return wavefront_send_patch (&header);
-
-	case WF_ST_PROGRAM:
-		if (copy_from_user(&header.hdr.pr, header.hdrptr,
-				   sizeof (wavefront_program)))
-			return -EFAULT;
-
-		return wavefront_send_program (&header);
-
-	default:
-		printk (KERN_ERR LOGNAME "unknown patch type %d.\n",
-			header.subkey);
-		return -(EINVAL);
-	}
-
-	return 0;
-}
-
-/***********************************************************************
-WaveFront: /dev/sequencer{,2} and other hardware-dependent interfaces
-***********************************************************************/
-
-static void
-process_sample_hdr (UCHAR8 *buf)
-
-{
-	wavefront_sample s;
-	UCHAR8 *ptr;
-
-	ptr = buf;
-
-	/* The board doesn't send us an exact copy of a "wavefront_sample"
-	   in response to an Upload Sample Header command. Instead, we 
-	   have to convert the data format back into our data structure,
-	   just as in the Download Sample command, where we have to do
-	   something very similar in the reverse direction.
-	*/
-
-	*((UINT32 *) &s.sampleStartOffset) = demunge_int32 (ptr, 4); ptr += 4;
-	*((UINT32 *) &s.loopStartOffset) = demunge_int32 (ptr, 4); ptr += 4;
-	*((UINT32 *) &s.loopEndOffset) = demunge_int32 (ptr, 4); ptr += 4;
-	*((UINT32 *) &s.sampleEndOffset) = demunge_int32 (ptr, 4); ptr += 4;
-	*((UINT32 *) &s.FrequencyBias) = demunge_int32 (ptr, 3); ptr += 3;
-
-	s.SampleResolution = *ptr & 0x3;
-	s.Loop = *ptr & 0x8;
-	s.Bidirectional = *ptr & 0x10;
-	s.Reverse = *ptr & 0x40;
-
-	/* Now copy it back to where it came from */
-
-	memcpy (buf, (unsigned char *) &s, sizeof (wavefront_sample));
-}
-
-static int
-wavefront_synth_control (int cmd, wavefront_control *wc)
-
-{
-	unsigned char patchnumbuf[2];
-	int i;
-
-	DPRINT (WF_DEBUG_CMD, "synth control with "
-		"cmd 0x%x\n", wc->cmd);
-
-	/* Pre-handling of or for various commands */
-
-	switch (wc->cmd) {
-	case WFC_DISABLE_INTERRUPTS:
-		printk (KERN_INFO LOGNAME "interrupts disabled.\n");
-		outb (0x80|0x20, dev.control_port);
-		dev.interrupts_on = 0;
-		return 0;
-
-	case WFC_ENABLE_INTERRUPTS:
-		printk (KERN_INFO LOGNAME "interrupts enabled.\n");
-		outb (0x80|0x40|0x20, dev.control_port);
-		dev.interrupts_on = 1;
-		return 0;
-
-	case WFC_INTERRUPT_STATUS:
-		wc->rbuf[0] = dev.interrupts_on;
-		return 0;
-
-	case WFC_ROMSAMPLES_RDONLY:
-		dev.rom_samples_rdonly = wc->wbuf[0];
-		wc->status = 0;
-		return 0;
-
-	case WFC_IDENTIFY_SLOT_TYPE:
-		i = wc->wbuf[0] | (wc->wbuf[1] << 7);
-		if (i <0 || i >= WF_MAX_SAMPLE) {
-			printk (KERN_WARNING LOGNAME "invalid slot ID %d\n",
-				i);
-			wc->status = EINVAL;
-			return 0;
-		}
-		wc->rbuf[0] = dev.sample_status[i];
-		wc->status = 0;
-		return 0;
-
-	case WFC_DEBUG_DRIVER:
-		dev.debug = wc->wbuf[0];
-		printk (KERN_INFO LOGNAME "debug = 0x%x\n", dev.debug);
-		return 0;
-
-	case WFC_FX_IOCTL:
-		wffx_ioctl ((wavefront_fx_info *) &wc->wbuf[0]);
-		return 0;
-
-	case WFC_UPLOAD_PATCH:
-		munge_int32 (*((UINT32 *) wc->wbuf), patchnumbuf, 2);
-		memcpy (wc->wbuf, patchnumbuf, 2);
-		break;
-
-	case WFC_UPLOAD_MULTISAMPLE:
-		/* multisamples have to be handled differently, and
-		   cannot be dealt with properly by wavefront_cmd() alone.
-		*/
-		wc->status = wavefront_fetch_multisample
-			((wavefront_patch_info *) wc->rbuf);
-		return 0;
-
-	case WFC_UPLOAD_SAMPLE_ALIAS:
-		printk (KERN_INFO LOGNAME "support for sample alias upload "
-			"being considered.\n");
-		wc->status = EINVAL;
-		return -EINVAL;
-	}
-
-	wc->status = wavefront_cmd (wc->cmd, wc->rbuf, wc->wbuf);
-
-	/* Post-handling of certain commands.
-
-	   In particular, if the command was an upload, demunge the data
-	   so that the user-level doesn't have to think about it.
-	*/
-
-	if (wc->status == 0) {
-		switch (wc->cmd) {
-			/* intercept any freemem requests so that we know
-			   we are always current with the user-level view
-			   of things.
-			*/
-
-		case WFC_REPORT_FREE_MEMORY:
-			dev.freemem = demunge_int32 (wc->rbuf, 4);
-			break;
-
-		case WFC_UPLOAD_PATCH:
-			demunge_buf (wc->rbuf, wc->rbuf, WF_PATCH_BYTES);
-			break;
-
-		case WFC_UPLOAD_PROGRAM:
-			demunge_buf (wc->rbuf, wc->rbuf, WF_PROGRAM_BYTES);
-			break;
-
-		case WFC_UPLOAD_EDRUM_PROGRAM:
-			demunge_buf (wc->rbuf, wc->rbuf, WF_DRUM_BYTES - 1);
-			break;
-
-		case WFC_UPLOAD_SAMPLE_HEADER:
-			process_sample_hdr (wc->rbuf);
-			break;
-
-		case WFC_UPLOAD_SAMPLE_ALIAS:
-			printk (KERN_INFO LOGNAME "support for "
-				"sample aliases still "
-				"being considered.\n");
-			break;
-
-		case WFC_VMIDI_OFF:
-			if (virtual_midi_disable () < 0) {
-				return -(EIO);
-			}
-			break;
-
-		case WFC_VMIDI_ON:
-			if (virtual_midi_enable () < 0) {
-				return -(EIO);
-			}
-			break;
-		}
-	}
-
-	return 0;
-}
-
-
-/***********************************************************************/
-/* WaveFront: Linux file system interface (for access via raw synth)    */
-/***********************************************************************/
-
-static int 
-wavefront_open (struct inode *inode, struct file *file)
-{
-	/* XXX fix me */
-	dev.opened = file->f_flags;
-	return 0;
-}
-
-static int
-wavefront_release(struct inode *inode, struct file *file)
-{
-	lock_kernel();
-	dev.opened = 0;
-	dev.debug = 0;
-	unlock_kernel();
-	return 0;
-}
-
-static int
-wavefront_ioctl(struct inode *inode, struct file *file,
-		unsigned int cmd, unsigned long arg)
-{
-	wavefront_control wc;
-	int err;
-
-	switch (cmd) {
-
-	case WFCTL_WFCMD:
-		if (copy_from_user(&wc, (void __user *) arg, sizeof (wc)))
-			return -EFAULT;
-		
-		if ((err = wavefront_synth_control (cmd, &wc)) == 0) {
-			if (copy_to_user ((void __user *) arg, &wc, sizeof (wc)))
-				return -EFAULT;
-		}
-
-		return err;
-		
-	case WFCTL_LOAD_SPP:
-		return wavefront_load_patch ((const char __user *) arg);
-		
-	default:
-		printk (KERN_WARNING LOGNAME "invalid ioctl %#x\n", cmd);
-		return -(EINVAL);
-
-	}
-	return 0;
-}
-
-static /*const*/ struct file_operations wavefront_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= wavefront_ioctl,
-	.open		= wavefront_open,
-	.release	= wavefront_release,
-};
-
-
-/***********************************************************************/
-/* WaveFront: OSS installation and support interface                   */
-/***********************************************************************/
-
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-
-static struct synth_info wavefront_info =
-{"Turtle Beach WaveFront", 0, SYNTH_TYPE_SAMPLE, SAMPLE_TYPE_WAVEFRONT,
- 0, 32, 0, 0, SYNTH_CAP_INPUT};
-
-static int
-wavefront_oss_open (int devno, int mode)
-
-{
-	dev.opened = mode;
-	return 0;
-}
-
-static void
-wavefront_oss_close (int devno)
-
-{
-	dev.opened = 0;
-	dev.debug = 0;
-	return;
-}
-
-static int
-wavefront_oss_ioctl (int devno, unsigned int cmd, void __user * arg)
-
-{
-	wavefront_control wc;
-	int err;
-
-	switch (cmd) {
-	case SNDCTL_SYNTH_INFO:
-		if(copy_to_user(arg, &wavefront_info, sizeof (wavefront_info)))
-			return -EFAULT;
-		return 0;
-
-	case SNDCTL_SEQ_RESETSAMPLES:
-//		printk (KERN_WARNING LOGNAME "driver cannot reset samples.\n");
-		return 0; /* don't force an error */
-
-	case SNDCTL_SEQ_PERCMODE:
-		return 0; /* don't force an error */
-
-	case SNDCTL_SYNTH_MEMAVL:
-		if ((dev.freemem = wavefront_freemem ()) < 0) {
-			printk (KERN_ERR LOGNAME "cannot get memory size\n");
-			return -EIO;
-		} else {
-			return dev.freemem;
-		}
-		break;
-
-	case SNDCTL_SYNTH_CONTROL:
-		if(copy_from_user (&wc, arg, sizeof (wc)))
-			err = -EFAULT;
-		else if ((err = wavefront_synth_control (cmd, &wc)) == 0) {
-			if(copy_to_user (arg, &wc, sizeof (wc)))
-				err = -EFAULT;
-		}
-
-		return err;
-
-	default:
-		return -(EINVAL);
-	}
-}
-
-static int
-wavefront_oss_load_patch (int devno, int format, const char __user *addr,
-			  int offs, int count, int pmgr_flag)
-{
-
-	if (format == SYSEX_PATCH) {	/* Handled by midi_synth.c */
-		if (midi_load_patch == NULL) {
-			printk (KERN_ERR LOGNAME
-				"SYSEX not loadable: "
-				"no midi patch loader!\n");
-			return -(EINVAL);
-		}
-
-		return midi_load_patch (devno, format, addr,
-					offs, count, pmgr_flag);
-
-	} else if (format == GUS_PATCH) {
-		return wavefront_load_gus_patch (devno, format,
-						 addr, offs, count, pmgr_flag);
-
-	} else if (format != WAVEFRONT_PATCH) {
-		printk (KERN_ERR LOGNAME "unknown patch format %d\n", format);
-		return -(EINVAL);
-	}
-
-	if (count < sizeof (wavefront_patch_info)) {
-		printk (KERN_ERR LOGNAME "sample header too short\n");
-		return -(EINVAL);
-	}
-
-	/* "addr" points to a user-space wavefront_patch_info */
-
-	return wavefront_load_patch (addr);
-}	
-
-static struct synth_operations wavefront_operations =
-{
-	.owner		= THIS_MODULE,
-	.id		= "WaveFront",
-	.info		= &wavefront_info,
-	.midi_dev	= 0,
-	.synth_type	= SYNTH_TYPE_SAMPLE,
-	.synth_subtype	= SAMPLE_TYPE_WAVEFRONT,
-	.open		= wavefront_oss_open,
-	.close		= wavefront_oss_close,
-	.ioctl		= wavefront_oss_ioctl,
-	.kill_note	= midi_synth_kill_note,
-	.start_note	= midi_synth_start_note,
-	.set_instr	= midi_synth_set_instr,
-	.reset		= midi_synth_reset,
-	.load_patch	= midi_synth_load_patch,
-	.aftertouch	= midi_synth_aftertouch,
-	.controller	= midi_synth_controller,
-	.panning	= midi_synth_panning,
-	.bender		= midi_synth_bender,
-	.setup_voice	= midi_synth_setup_voice
-};
-#endif /* OSS_SUPPORT_SEQ */
-
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_STATIC_INSTALL
-
-static void __init attach_wavefront (struct address_info *hw_config)
-{
-    (void) install_wavefront ();
-}
-
-static int __init probe_wavefront (struct address_info *hw_config)
-{
-    return !detect_wavefront (hw_config->irq, hw_config->io_base);
-}
-
-static void __exit unload_wavefront (struct address_info *hw_config) 
-{
-    (void) uninstall_wavefront ();
-}
-
-#endif /* OSS_SUPPORT_STATIC_INSTALL */
-
-/***********************************************************************/
-/* WaveFront: Linux modular sound kernel installation interface        */
-/***********************************************************************/
-
-static irqreturn_t
-wavefrontintr(int irq, void *dev_id, struct pt_regs *dummy)
-{
-	struct wf_config *hw = dev_id;
-
-	/*
-	   Some comments on interrupts. I attempted a version of this
-	   driver that used interrupts throughout the code instead of
-	   doing busy and/or sleep-waiting. Alas, it appears that once
-	   the Motorola firmware is downloaded, the card *never*
-	   generates an RX interrupt. These are successfully generated
-	   during firmware loading, and after that wavefront_status()
-	   reports that an interrupt is pending on the card from time
-	   to time, but it never seems to be delivered to this
-	   driver. Note also that wavefront_status() continues to
-	   report that RX interrupts are enabled, suggesting that I
-	   didn't goof up and disable them by mistake.
-
-	   Thus, I stepped back to a prior version of
-	   wavefront_wait(), the only place where this really
-	   matters. Its sad, but I've looked through the code to check
-	   on things, and I really feel certain that the Motorola
-	   firmware prevents RX-ready interrupts.
-	*/
-
-	if ((wavefront_status() & (STAT_INTR_READ|STAT_INTR_WRITE)) == 0) {
-		return IRQ_NONE;
-	}
-
-	hw->irq_ok = 1;
-	hw->irq_cnt++;
-	wake_up_interruptible (&hw->interrupt_sleeper);
-	return IRQ_HANDLED;
-}
-
-/* STATUS REGISTER 
-
-0 Host Rx Interrupt Enable (1=Enabled)
-1 Host Rx Register Full (1=Full)
-2 Host Rx Interrupt Pending (1=Interrupt)
-3 Unused
-4 Host Tx Interrupt (1=Enabled)
-5 Host Tx Register empty (1=Empty)
-6 Host Tx Interrupt Pending (1=Interrupt)
-7 Unused
-*/
-
-static int
-wavefront_interrupt_bits (int irq)
-
-{
-	int bits;
-
-	switch (irq) {
-	case 9:
-		bits = 0x00;
-		break;
-	case 5:
-		bits = 0x08;
-		break;
-	case 12:
-		bits = 0x10;
-		break;
-	case 15:
-		bits = 0x18;
-		break;
-	
-	default:
-		printk (KERN_WARNING LOGNAME "invalid IRQ %d\n", irq);
-		bits = -1;
-	}
-
-	return bits;
-}
-
-static void
-wavefront_should_cause_interrupt (int val, int port, int timeout)
-
-{
-	unsigned long flags;
-
-	/* this will not help on SMP - but at least it compiles */
-	spin_lock_irqsave(&lock, flags);
-	dev.irq_ok = 0;
-	outb (val,port);
-	interruptible_sleep_on_timeout (&dev.interrupt_sleeper, timeout);
-	spin_unlock_irqrestore(&lock,flags);
-}
-
-static int __init wavefront_hw_reset (void)
-{
-	int bits;
-	int hwv[2];
-	unsigned long irq_mask;
-	short reported_irq;
-
-	/* IRQ already checked in init_module() */
-
-	bits = wavefront_interrupt_bits (dev.irq);
-
-	printk (KERN_DEBUG LOGNAME "autodetecting WaveFront IRQ\n");
-
-	irq_mask = probe_irq_on ();
-
-	outb (0x0, dev.control_port); 
-	outb (0x80 | 0x40 | bits, dev.data_port);	
-	wavefront_should_cause_interrupt(0x80|0x40|0x10|0x1,
-					 dev.control_port,
-					 (reset_time*HZ)/100);
-
-	reported_irq = probe_irq_off (irq_mask);
-
-	if (reported_irq != dev.irq) {
-		if (reported_irq == 0) {
-			printk (KERN_ERR LOGNAME
-				"No unassigned interrupts detected "
-				"after h/w reset\n");
-		} else if (reported_irq < 0) {
-			printk (KERN_ERR LOGNAME
-				"Multiple unassigned interrupts detected "
-				"after h/w reset\n");
-		} else {
-			printk (KERN_ERR LOGNAME "autodetected IRQ %d not the "
-				"value provided (%d)\n", reported_irq,
-				dev.irq);
-		}
-		dev.irq = -1;
-		return 1;
-	} else {
-		printk (KERN_INFO LOGNAME "autodetected IRQ at %d\n",
-			reported_irq);
-	}
-
-	if (request_irq (dev.irq, wavefrontintr,
-			 IRQF_DISABLED|IRQF_SHARED,
-			 "wavefront synth", &dev) < 0) {
-		printk (KERN_WARNING LOGNAME "IRQ %d not available!\n",
-			dev.irq);
-		return 1;
-	}
-
-	/* try reset of port */
-      
-	outb (0x0, dev.control_port); 
-  
-	/* At this point, the board is in reset, and the H/W initialization
-	   register is accessed at the same address as the data port.
-     
-	   Bit 7 - Enable IRQ Driver	
-	   0 - Tri-state the Wave-Board drivers for the PC Bus IRQs
-	   1 - Enable IRQ selected by bits 5:3 to be driven onto the PC Bus.
-     
-	   Bit 6 - MIDI Interface Select
-
-	   0 - Use the MIDI Input from the 26-pin WaveBlaster
-	   compatible header as the serial MIDI source
-	   1 - Use the MIDI Input from the 9-pin D connector as the
-	   serial MIDI source.
-     
-	   Bits 5:3 - IRQ Selection
-	   0 0 0 - IRQ 2/9
-	   0 0 1 - IRQ 5
-	   0 1 0 - IRQ 12
-	   0 1 1 - IRQ 15
-	   1 0 0 - Reserved
-	   1 0 1 - Reserved
-	   1 1 0 - Reserved
-	   1 1 1 - Reserved
-     
-	   Bits 2:1 - Reserved
-	   Bit 0 - Disable Boot ROM
-	   0 - memory accesses to 03FC30-03FFFFH utilize the internal Boot ROM
-	   1 - memory accesses to 03FC30-03FFFFH are directed to external 
-	   storage.
-     
-	*/
-
-	/* configure hardware: IRQ, enable interrupts, 
-	   plus external 9-pin MIDI interface selected
-	*/
-
-	outb (0x80 | 0x40 | bits, dev.data_port);	
-  
-	/* CONTROL REGISTER
-
-	   0 Host Rx Interrupt Enable (1=Enabled)      0x1
-	   1 Unused                                    0x2
-	   2 Unused                                    0x4
-	   3 Unused                                    0x8
-	   4 Host Tx Interrupt Enable                 0x10
-	   5 Mute (0=Mute; 1=Play)                    0x20
-	   6 Master Interrupt Enable (1=Enabled)      0x40
-	   7 Master Reset (0=Reset; 1=Run)            0x80
-
-	   Take us out of reset, mute output, master + TX + RX interrupts on.
-	   
-	   We'll get an interrupt presumably to tell us that the TX
-	   register is clear.
-	*/
-
-	wavefront_should_cause_interrupt(0x80|0x40|0x10|0x1,
-					 dev.control_port,
-					 (reset_time*HZ)/100);
-
-	/* Note: data port is now the data port, not the h/w initialization
-	   port.
-	 */
-
-	if (!dev.irq_ok) {
-		printk (KERN_WARNING LOGNAME
-			"intr not received after h/w un-reset.\n");
-		goto gone_bad;
-	} 
-
-	dev.interrupts_on = 1;
-	
-	/* Note: data port is now the data port, not the h/w initialization
-	   port.
-
-	   At this point, only "HW VERSION" or "DOWNLOAD OS" commands
-	   will work. So, issue one of them, and wait for TX
-	   interrupt. This can take a *long* time after a cold boot,
-	   while the ISC ROM does its RAM test. The SDK says up to 4
-	   seconds - with 12MB of RAM on a Tropez+, it takes a lot
-	   longer than that (~16secs). Note that the card understands
-	   the difference between a warm and a cold boot, so
-	   subsequent ISC2115 reboots (say, caused by module
-	   reloading) will get through this much faster.
-
-	   XXX Interesting question: why is no RX interrupt received first ?
-	*/
-
-	wavefront_should_cause_interrupt(WFC_HARDWARE_VERSION, 
-					 dev.data_port, ramcheck_time*HZ);
-
-	if (!dev.irq_ok) {
-		printk (KERN_WARNING LOGNAME
-			"post-RAM-check interrupt not received.\n");
-		goto gone_bad;
-	} 
-
-	if (!wavefront_wait (STAT_CAN_READ)) {
-		printk (KERN_WARNING LOGNAME
-			"no response to HW version cmd.\n");
-		goto gone_bad;
-	}
-	
-	if ((hwv[0] = wavefront_read ()) == -1) {
-		printk (KERN_WARNING LOGNAME
-			"board not responding correctly.\n");
-		goto gone_bad;
-	}
-
-	if (hwv[0] == 0xFF) { /* NAK */
-
-		/* Board's RAM test failed. Try to read error code,
-		   and tell us about it either way.
-		*/
-		
-		if ((hwv[0] = wavefront_read ()) == -1) {
-			printk (KERN_WARNING LOGNAME "on-board RAM test failed "
-				"(bad error code).\n");
-		} else {
-			printk (KERN_WARNING LOGNAME "on-board RAM test failed "
-				"(error code: 0x%x).\n",
-				hwv[0]);
-		}
-		goto gone_bad;
-	}
-
-	/* We're OK, just get the next byte of the HW version response */
-
-	if ((hwv[1] = wavefront_read ()) == -1) {
-		printk (KERN_WARNING LOGNAME "incorrect h/w response.\n");
-		goto gone_bad;
-	}
-
-	printk (KERN_INFO LOGNAME "hardware version %d.%d\n",
-		hwv[0], hwv[1]);
-
-	return 0;
-
-
-     gone_bad:
-	if (dev.irq >= 0) {
-		free_irq (dev.irq, &dev);
-		dev.irq = -1;
-	}
-	return (1);
-}
-
-static int __init detect_wavefront (int irq, int io_base)
-{
-	unsigned char   rbuf[4], wbuf[4];
-
-	/* TB docs say the device takes up 8 ports, but we know that
-	   if there is an FX device present (i.e. a Tropez+) it really
-	   consumes 16.
-	*/
-
-	if (!request_region (io_base, 16, "wavfront")) {
-		printk (KERN_ERR LOGNAME "IO address range 0x%x - 0x%x "
-			"already in use - ignored\n", dev.base,
-			dev.base+15);
-		return -1;
-	}
-  
-	dev.irq = irq;
-	dev.base = io_base;
-	dev.israw = 0;
-	dev.debug = debug_default;
-	dev.interrupts_on = 0;
-	dev.irq_cnt = 0;
-	dev.rom_samples_rdonly = 1; /* XXX default lock on ROM sample slots */
-
-	if (wavefront_cmd (WFC_FIRMWARE_VERSION, rbuf, wbuf) == 0) {
-
-		dev.fw_version[0] = rbuf[0];
-		dev.fw_version[1] = rbuf[1];
-		printk (KERN_INFO LOGNAME
-			"firmware %d.%d already loaded.\n",
-			rbuf[0], rbuf[1]);
-
-		/* check that a command actually works */
-      
-		if (wavefront_cmd (WFC_HARDWARE_VERSION,
-				   rbuf, wbuf) == 0) {
-			dev.hw_version[0] = rbuf[0];
-			dev.hw_version[1] = rbuf[1];
-		} else {
-			printk (KERN_WARNING LOGNAME "not raw, but no "
-				"hardware version!\n");
-			release_region (io_base, 16);
-			return 0;
-		}
-
-		if (!wf_raw) {
-			/* will re-acquire region in install_wavefront() */
-			release_region (io_base, 16);
-			return 1;
-		} else {
-			printk (KERN_INFO LOGNAME
-				"reloading firmware anyway.\n");
-			dev.israw = 1;
-		}
-
-	} else {
-
-		dev.israw = 1;
-		printk (KERN_INFO LOGNAME
-			"no response to firmware probe, assume raw.\n");
-
-	}
-
-	init_waitqueue_head (&dev.interrupt_sleeper);
-
-	if (wavefront_hw_reset ()) {
-		printk (KERN_WARNING LOGNAME "hardware reset failed\n");
-		release_region (io_base, 16);
-		return 0;
-	}
-
-	/* Check for FX device, present only on Tropez+ */
-
-	dev.has_fx = (detect_wffx () == 0);
-
-	/* will re-acquire region in install_wavefront() */
-	release_region (io_base, 16);
-	return 1;
-}
-
-#include "os.h"
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <asm/uaccess.h>
-
-
-static int
-wavefront_download_firmware (char *path)
-
-{
-	unsigned char section[WF_SECTION_MAX];
-	char section_length; /* yes, just a char; max value is WF_SECTION_MAX */
-	int section_cnt_downloaded = 0;
-	int fd;
-	int c;
-	int i;
-	mm_segment_t fs;
-
-	/* This tries to be a bit cleverer than the stuff Alan Cox did for
-	   the generic sound firmware, in that it actually knows
-	   something about the structure of the Motorola firmware. In
-	   particular, it uses a version that has been stripped of the
-	   20K of useless header information, and had section lengths
-	   added, making it possible to load the entire OS without any
-	   [kv]malloc() activity, since the longest entity we ever read is
-	   42 bytes (well, WF_SECTION_MAX) long.
-	*/
-
-	fs = get_fs();
-	set_fs (get_ds());
-
-	if ((fd = sys_open (path, 0, 0)) < 0) {
-		printk (KERN_WARNING LOGNAME "Unable to load \"%s\".\n",
-			path);
-		return 1;
-	}
-
-	while (1) {
-		int x;
-
-		if ((x = sys_read (fd, &section_length, sizeof (section_length))) !=
-		    sizeof (section_length)) {
-			printk (KERN_ERR LOGNAME "firmware read error.\n");
-			goto failure;
-		}
-
-		if (section_length == 0) {
-			break;
-		}
-
-		if (sys_read (fd, section, section_length) != section_length) {
-			printk (KERN_ERR LOGNAME "firmware section "
-				"read error.\n");
-			goto failure;
-		}
-
-		/* Send command */
-	
-		if (wavefront_write (WFC_DOWNLOAD_OS)) {
-			goto failure;
-		}
-	
-		for (i = 0; i < section_length; i++) {
-			if (wavefront_write (section[i])) {
-				goto failure;
-			}
-		}
-	
-		/* get ACK */
-	
-		if (wavefront_wait (STAT_CAN_READ)) {
-
-			if ((c = inb (dev.data_port)) != WF_ACK) {
-
-				printk (KERN_ERR LOGNAME "download "
-					"of section #%d not "
-					"acknowledged, ack = 0x%x\n",
-					section_cnt_downloaded + 1, c);
-				goto failure;
-		
-			}
-
-		} else {
-			printk (KERN_ERR LOGNAME "time out for firmware ACK.\n");
-			goto failure;
-		}
-
-	}
-
-	sys_close (fd);
-	set_fs (fs);
-	return 0;
-
- failure:
-	sys_close (fd);
-	set_fs (fs);
-	printk (KERN_ERR "\nWaveFront: firmware download failed!!!\n");
-	return 1;
-}
-
-static int __init wavefront_config_midi (void)
-{
-	unsigned char rbuf[4], wbuf[4];
-    
-	if (detect_wf_mpu (dev.irq, dev.base) < 0) {
-		printk (KERN_WARNING LOGNAME
-			"could not find working MIDI device\n");
-		return -1;
-	} 
-
-	if ((dev.mididev = install_wf_mpu ()) < 0) {
-		printk (KERN_WARNING LOGNAME
-			"MIDI interfaces not configured\n");
-		return -1;
-	}
-
-	/* Route external MIDI to WaveFront synth (by default) */
-    
-	if (wavefront_cmd (WFC_MISYNTH_ON, rbuf, wbuf)) {
-		printk (KERN_WARNING LOGNAME
-			"cannot enable MIDI-IN to synth routing.\n");
-		/* XXX error ? */
-	}
-
-
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-	/* Get the regular MIDI patch loading function, so we can
-	   use it if we ever get handed a SYSEX patch. This is
-	   unlikely, because its so damn slow, but we may as well
-	   leave this functionality from maui.c behind, since it
-	   could be useful for sequencer applications that can
-	   only use MIDI to do patch loading.
-	*/
-
-	if (midi_devs[dev.mididev]->converter != NULL) {
-		midi_load_patch = midi_devs[dev.mididev]->converter->load_patch;
-		midi_devs[dev.mididev]->converter->load_patch =
-		    &wavefront_oss_load_patch;
-	}
-
-#endif /* OSS_SUPPORT_SEQ */
-	
-	/* Turn on Virtual MIDI, but first *always* turn it off,
-	   since otherwise consectutive reloads of the driver will
-	   never cause the hardware to generate the initial "internal" or 
-	   "external" source bytes in the MIDI data stream. This
-	   is pretty important, since the internal hardware generally will
-	   be used to generate none or very little MIDI output, and
-	   thus the only source of MIDI data is actually external. Without
-	   the switch bytes, the driver will think it all comes from
-	   the internal interface. Duh.
-	*/
-
-	if (wavefront_cmd (WFC_VMIDI_OFF, rbuf, wbuf)) { 
-		printk (KERN_WARNING LOGNAME
-			"virtual MIDI mode not disabled\n");
-		return 0; /* We're OK, but missing the external MIDI dev */
-	}
-
-	if ((dev.ext_mididev = virtual_midi_enable ()) < 0) {
-		printk (KERN_WARNING LOGNAME "no virtual MIDI access.\n");
-	} else {
-		if (wavefront_cmd (WFC_VMIDI_ON, rbuf, wbuf)) {
-			printk (KERN_WARNING LOGNAME
-				"cannot enable virtual MIDI mode.\n");
-			virtual_midi_disable ();
-		} 
-	}
-    
-	return 0;
-}
-
-static int __init wavefront_do_reset (int atboot)
-{
-	char voices[1];
-
-	if (!atboot && wavefront_hw_reset ()) {
-		printk (KERN_WARNING LOGNAME "hw reset failed.\n");
-		goto gone_bad;
-	}
-
-	if (dev.israw) {
-		if (wavefront_download_firmware (ospath)) {
-			goto gone_bad;
-		}
-
-		dev.israw = 0;
-
-		/* Wait for the OS to get running. The protocol for
-		   this is non-obvious, and was determined by
-		   using port-IO tracing in DOSemu and some
-		   experimentation here.
-		   
-		   Rather than using timed waits, use interrupts creatively.
-		*/
-
-		wavefront_should_cause_interrupt (WFC_NOOP,
-						  dev.data_port,
-						  (osrun_time*HZ));
-
-		if (!dev.irq_ok) {
-			printk (KERN_WARNING LOGNAME
-				"no post-OS interrupt.\n");
-			goto gone_bad;
-		}
-		
-		/* Now, do it again ! */
-		
-		wavefront_should_cause_interrupt (WFC_NOOP,
-						  dev.data_port, (10*HZ));
-		
-		if (!dev.irq_ok) {
-			printk (KERN_WARNING LOGNAME
-				"no post-OS interrupt(2).\n");
-			goto gone_bad;
-		}
-
-		/* OK, no (RX/TX) interrupts any more, but leave mute
-		   in effect. 
-		*/
-		
-		outb (0x80|0x40, dev.control_port); 
-
-		/* No need for the IRQ anymore */
-		
-		free_irq (dev.irq, &dev);
-
-	}
-
-	if (dev.has_fx && fx_raw) {
-		wffx_init ();
-	}
-
-	/* SETUPSND.EXE asks for sample memory config here, but since i
-	   have no idea how to interpret the result, we'll forget
-	   about it.
-	*/
-	
-	if ((dev.freemem = wavefront_freemem ()) < 0) {
-		goto gone_bad;
-	}
-		
-	printk (KERN_INFO LOGNAME "available DRAM %dk\n", dev.freemem / 1024);
-
-	if (wavefront_write (0xf0) ||
-	    wavefront_write (1) ||
-	    (wavefront_read () < 0)) {
-		dev.debug = 0;
-		printk (KERN_WARNING LOGNAME "MPU emulation mode not set.\n");
-		goto gone_bad;
-	}
-
-	voices[0] = 32;
-
-	if (wavefront_cmd (WFC_SET_NVOICES, NULL, voices)) {
-		printk (KERN_WARNING LOGNAME
-			"cannot set number of voices to 32.\n");
-		goto gone_bad;
-	}
-
-
-	return 0;
-
- gone_bad:
-	/* reset that sucker so that it doesn't bother us. */
-
-	outb (0x0, dev.control_port);
-	dev.interrupts_on = 0;
-	if (dev.irq >= 0) {
-		free_irq (dev.irq, &dev);
-	}
-	return 1;
-}
-
-static int __init wavefront_init (int atboot)
-{
-	int samples_are_from_rom;
-
-	if (dev.israw) {
-		samples_are_from_rom = 1;
-	} else {
-		/* XXX is this always true ? */
-		samples_are_from_rom = 0;
-	}
-
-	if (dev.israw || fx_raw) {
-		if (wavefront_do_reset (atboot)) {
-			return -1;
-		}
-	}
-
-	wavefront_get_sample_status (samples_are_from_rom);
-	wavefront_get_program_status ();
-	wavefront_get_patch_status ();
-
-	/* Start normal operation: unreset, master interrupt enabled, no mute
-	*/
-
-	outb (0x80|0x40|0x20, dev.control_port); 
-
-	return (0);
-}
-
-static int __init install_wavefront (void)
-{
-	if (!request_region (dev.base+2, 6, "wavefront synth"))
-		return -1;
-
-	if (dev.has_fx) {
-		if (!request_region (dev.base+8, 8, "wavefront fx")) {
-			release_region (dev.base+2, 6);
-			return -1;
-		}
-	}
-
-	if ((dev.synth_dev = register_sound_synth (&wavefront_fops, -1)) < 0) {
-		printk (KERN_ERR LOGNAME "cannot register raw synth\n");
-		goto err_out;
-	}
-
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-	if ((dev.oss_dev = sound_alloc_synthdev()) == -1) {
-		printk (KERN_ERR LOGNAME "Too many sequencers\n");
-		/* FIXME: leak: should unregister sound synth */
-		goto err_out;
-	} else {
-		synth_devs[dev.oss_dev] = &wavefront_operations;
-	}
-#endif /* OSS_SUPPORT_SEQ */
-
-	if (wavefront_init (1) < 0) {
-		printk (KERN_WARNING LOGNAME "initialization failed.\n");
-
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-		sound_unload_synthdev (dev.oss_dev);
-#endif /* OSS_SUPPORT_SEQ */ 
-
-		goto err_out;
-	}
-    
-	if (wavefront_config_midi ()) {
-		printk (KERN_WARNING LOGNAME "could not initialize MIDI.\n");
-	}
-
-	return dev.oss_dev;
-
-err_out:
-	release_region (dev.base+2, 6);
-	if (dev.has_fx)
-		release_region (dev.base+8, 8);
-	return -1;
-}
-
-static void __exit uninstall_wavefront (void)
-{
-	/* the first two i/o addresses are freed by the wf_mpu code */
-	release_region (dev.base+2, 6);
-
-	if (dev.has_fx) {
-		release_region (dev.base+8, 8);
-	}
-
-	unregister_sound_synth (dev.synth_dev);
-
-#if OSS_SUPPORT_LEVEL & OSS_SUPPORT_SEQ
-	sound_unload_synthdev (dev.oss_dev);
-#endif /* OSS_SUPPORT_SEQ */ 
-	uninstall_wf_mpu ();
-}
-
-/***********************************************************************/
-/*   WaveFront FX control                                              */
-/***********************************************************************/
-
-#include "yss225.h"
-
-/* Control bits for the Load Control Register
- */
-
-#define FX_LSB_TRANSFER 0x01    /* transfer after DSP LSB byte written */
-#define FX_MSB_TRANSFER 0x02    /* transfer after DSP MSB byte written */
-#define FX_AUTO_INCR    0x04    /* auto-increment DSP address after transfer */
-
-static int
-wffx_idle (void) 
-    
-{
-	int i;
-	unsigned int x = 0x80;
-    
-	for (i = 0; i < 1000; i++) {
-		x = inb (dev.fx_status);
-		if ((x & 0x80) == 0) {
-			break;
-		}
-	}
-    
-	if (x & 0x80) {
-		printk (KERN_ERR LOGNAME "FX device never idle.\n");
-		return 0;
-	}
-    
-	return (1);
-}
-
-int __init detect_wffx (void)
-{
-	/* This is a crude check, but its the best one I have for now.
-	   Certainly on the Maui and the Tropez, wffx_idle() will
-	   report "never idle", which suggests that this test should
-	   work OK.
-	*/
-
-	if (inb (dev.fx_status) & 0x80) {
-		printk (KERN_INFO LOGNAME "Hmm, probably a Maui or Tropez.\n");
-		return -1;
-	}
-
-	return 0;
-}	
-
-static void
-wffx_mute (int onoff)
-    
-{
-	if (!wffx_idle()) {
-		return;
-	}
-    
-	outb (onoff ? 0x02 : 0x00, dev.fx_op);
-}
-
-static int
-wffx_memset (int page,
-	     int addr, int cnt, unsigned short *data)
-{
-	if (page < 0 || page > 7) {
-		printk (KERN_ERR LOGNAME "FX memset: "
-			"page must be >= 0 and <= 7\n");
-		return -(EINVAL);
-	}
-
-	if (addr < 0 || addr > 0x7f) {
-		printk (KERN_ERR LOGNAME "FX memset: "
-			"addr must be >= 0 and <= 7f\n");
-		return -(EINVAL);
-	}
-
-	if (cnt == 1) {
-
-		outb (FX_LSB_TRANSFER, dev.fx_lcr);
-		outb (page, dev.fx_dsp_page);
-		outb (addr, dev.fx_dsp_addr);
-		outb ((data[0] >> 8), dev.fx_dsp_msb);
-		outb ((data[0] & 0xff), dev.fx_dsp_lsb);
-
-		printk (KERN_INFO LOGNAME "FX: addr %d:%x set to 0x%x\n",
-			page, addr, data[0]);
-	
-	} else {
-		int i;
-
-		outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-		outb (page, dev.fx_dsp_page);
-		outb (addr, dev.fx_dsp_addr);
-
-		for (i = 0; i < cnt; i++) {
-			outb ((data[i] >> 8), dev.fx_dsp_msb);
-			outb ((data[i] & 0xff), dev.fx_dsp_lsb);
-			if (!wffx_idle ()) {
-				break;
-			}
-		}
-
-		if (i != cnt) {
-			printk (KERN_WARNING LOGNAME
-				"FX memset "
-				"(0x%x, 0x%x, %p, %d) incomplete\n",
-				page, addr, data, cnt);
-			return -(EIO);
-		}
-	}
-
-	return 0;
-}
-
-static int
-wffx_ioctl (wavefront_fx_info *r)
-
-{
-	unsigned short page_data[256];
-	unsigned short *pd;
-
-	switch (r->request) {
-	case WFFX_MUTE:
-		wffx_mute (r->data[0]);
-		return 0;
-
-	case WFFX_MEMSET:
-
-		if (r->data[2] <= 0) {
-			printk (KERN_ERR LOGNAME "cannot write "
-				"<= 0 bytes to FX\n");
-			return -(EINVAL);
-		} else if (r->data[2] == 1) {
-			pd = (unsigned short *) &r->data[3];
-		} else {
-			if (r->data[2] > sizeof (page_data)) {
-				printk (KERN_ERR LOGNAME "cannot write "
-					"> 255 bytes to FX\n");
-				return -(EINVAL);
-			}
-			if (copy_from_user(page_data,
-					   (unsigned char __user *)r->data[3],
-					   r->data[2]))
-				return -EFAULT;
-			pd = page_data;
-		}
-
-		return wffx_memset (r->data[0], /* page */
-				    r->data[1], /* addr */
-				    r->data[2], /* cnt */
-				    pd);
-
-	default:
-		printk (KERN_WARNING LOGNAME
-			"FX: ioctl %d not yet supported\n",
-			r->request);
-		return -(EINVAL);
-	}
-}
-
-/* YSS225 initialization.
-
-   This code was developed using DOSEMU. The Turtle Beach SETUPSND
-   utility was run with I/O tracing in DOSEMU enabled, and a reconstruction
-   of the port I/O done, using the Yamaha faxback document as a guide
-   to add more logic to the code. Its really pretty weird.
-
-   There was an alternative approach of just dumping the whole I/O
-   sequence as a series of port/value pairs and a simple loop
-   that output it. However, I hope that eventually I'll get more
-   control over what this code does, and so I tried to stick with
-   a somewhat "algorithmic" approach.
-*/
-
-static int __init wffx_init (void)
-{
-	int i;
-	int j;
-
-	/* Set all bits for all channels on the MOD unit to zero */
-	/* XXX But why do this twice ? */
-
-	for (j = 0; j < 2; j++) {
-		for (i = 0x10; i <= 0xff; i++) {
-	    
-			if (!wffx_idle ()) {
-				return (-1);
-			}
-	    
-			outb (i, dev.fx_mod_addr);
-			outb (0x0, dev.fx_mod_data);
-		}
-	}
-
-	if (!wffx_idle()) return (-1);
-	outb (0x02, dev.fx_op);                        /* mute on */
-
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x44, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x42, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x43, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x7c, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x7e, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x46, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x49, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x47, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x4a, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-
-	/* either because of stupidity by TB's programmers, or because it
-	   actually does something, rezero the MOD page.
-	*/
-	for (i = 0x10; i <= 0xff; i++) {
-	
-		if (!wffx_idle ()) {
-			return (-1);
-		}
-	
-		outb (i, dev.fx_mod_addr);
-		outb (0x0, dev.fx_mod_data);
-	}
-	/* load page zero */
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x00, dev.fx_dsp_page);
-	outb (0x00, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_zero); i += 2) {
-		outb (page_zero[i], dev.fx_dsp_msb);
-		outb (page_zero[i+1], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	/* Now load page one */
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x01, dev.fx_dsp_page);
-	outb (0x00, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_one); i += 2) {
-		outb (page_one[i], dev.fx_dsp_msb);
-		outb (page_one[i+1], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x02, dev.fx_dsp_page);
-	outb (0x00, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_two); i++) {
-		outb (page_two[i], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x03, dev.fx_dsp_page);
-	outb (0x00, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_three); i++) {
-		outb (page_three[i], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x04, dev.fx_dsp_page);
-	outb (0x00, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_four); i++) {
-		outb (page_four[i], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	/* Load memory area (page six) */
-    
-	outb (FX_LSB_TRANSFER, dev.fx_lcr); 
-	outb (0x06, dev.fx_dsp_page); 
-
-	for (i = 0; i < sizeof (page_six); i += 3) {
-		outb (page_six[i], dev.fx_dsp_addr);
-		outb (page_six[i+1], dev.fx_dsp_msb);
-		outb (page_six[i+2], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x00, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_seven); i += 2) {
-		outb (page_seven[i], dev.fx_dsp_msb);
-		outb (page_seven[i+1], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	/* Now setup the MOD area. We do this algorithmically in order to
-	   save a little data space. It could be done in the same fashion
-	   as the "pages".
-	*/
-
-	for (i = 0x00; i <= 0x0f; i++) {
-		outb (0x01, dev.fx_mod_addr);
-		outb (i, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-		outb (0x02, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0xb0; i <= 0xbf; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x20, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0xf0; i <= 0xff; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x20, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0x10; i <= 0x1d; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0xff, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0x1e, dev.fx_mod_addr);
-	outb (0x40, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	for (i = 0x1f; i <= 0x2d; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0xff, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0x2e, dev.fx_mod_addr);
-	outb (0x00, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	for (i = 0x2f; i <= 0x3e; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0x3f, dev.fx_mod_addr);
-	outb (0x20, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	for (i = 0x40; i <= 0x4d; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0x4e, dev.fx_mod_addr);
-	outb (0x0e, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-	outb (0x4f, dev.fx_mod_addr);
-	outb (0x0e, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-
-	for (i = 0x50; i <= 0x6b; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0x6c, dev.fx_mod_addr);
-	outb (0x40, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	outb (0x6d, dev.fx_mod_addr);
-	outb (0x00, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	outb (0x6e, dev.fx_mod_addr);
-	outb (0x40, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	outb (0x6f, dev.fx_mod_addr);
-	outb (0x40, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	for (i = 0x70; i <= 0x7f; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0xc0, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	for (i = 0x80; i <= 0xaf; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0xc0; i <= 0xdd; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0xde, dev.fx_mod_addr);
-	outb (0x10, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-	outb (0xdf, dev.fx_mod_addr);
-	outb (0x10, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-
-	for (i = 0xe0; i <= 0xef; i++) {
-		outb (i, dev.fx_mod_addr);
-		outb (0x00, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0x00; i <= 0x0f; i++) {
-		outb (0x01, dev.fx_mod_addr);
-		outb (i, dev.fx_mod_data);
-		outb (0x02, dev.fx_mod_addr);
-		outb (0x01, dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (0x02, dev.fx_op); /* mute on */
-
-	/* Now set the coefficients and so forth for the programs above */
-
-	for (i = 0; i < sizeof (coefficients); i += 4) {
-		outb (coefficients[i], dev.fx_dsp_page);
-		outb (coefficients[i+1], dev.fx_dsp_addr);
-		outb (coefficients[i+2], dev.fx_dsp_msb);
-		outb (coefficients[i+3], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	/* Some settings (?) that are too small to bundle into loops */
-
-	if (!wffx_idle()) return (-1);
-	outb (0x1e, dev.fx_mod_addr);
-	outb (0x14, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-	outb (0xde, dev.fx_mod_addr);
-	outb (0x20, dev.fx_mod_data);
-	if (!wffx_idle()) return (-1);
-	outb (0xdf, dev.fx_mod_addr);
-	outb (0x20, dev.fx_mod_data);
-    
-	/* some more coefficients */
-
-	if (!wffx_idle()) return (-1);
-	outb (0x06, dev.fx_dsp_page);
-	outb (0x78, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x40, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x03, dev.fx_dsp_addr);
-	outb (0x0f, dev.fx_dsp_msb);
-	outb (0xff, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x0b, dev.fx_dsp_addr);
-	outb (0x0f, dev.fx_dsp_msb);
-	outb (0xff, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x02, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x0a, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x46, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-	if (!wffx_idle()) return (-1);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x49, dev.fx_dsp_addr);
-	outb (0x00, dev.fx_dsp_msb);
-	outb (0x00, dev.fx_dsp_lsb);
-    
-	/* Now, for some strange reason, lets reload every page
-	   and all the coefficients over again. I have *NO* idea
-	   why this is done. I do know that no sound is produced
-	   is this phase is omitted.
-	*/
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x00, dev.fx_dsp_page);  
-	outb (0x10, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_zero_v2); i += 2) {
-		outb (page_zero_v2[i], dev.fx_dsp_msb);
-		outb (page_zero_v2[i+1], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x01, dev.fx_dsp_page);
-	outb (0x10, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_one_v2); i += 2) {
-		outb (page_one_v2[i], dev.fx_dsp_msb);
-		outb (page_one_v2[i+1], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	if (!wffx_idle()) return (-1);
-	if (!wffx_idle()) return (-1);
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x02, dev.fx_dsp_page);
-	outb (0x10, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_two_v2); i++) {
-		outb (page_two_v2[i], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x03, dev.fx_dsp_page);
-	outb (0x10, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_three_v2); i++) {
-		outb (page_three_v2[i], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x04, dev.fx_dsp_page);
-	outb (0x10, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_four_v2); i++) {
-		outb (page_four_v2[i], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-    
-	outb (FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x06, dev.fx_dsp_page);
-
-	/* Page six v.2 is algorithmic */
-    
-	for (i = 0x10; i <= 0x3e; i += 2) {
-		outb (i, dev.fx_dsp_addr);
-		outb (0x00, dev.fx_dsp_msb);
-		outb (0x00, dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	outb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev.fx_lcr);
-	outb (0x07, dev.fx_dsp_page);
-	outb (0x10, dev.fx_dsp_addr);
-
-	for (i = 0; i < sizeof (page_seven_v2); i += 2) {
-		outb (page_seven_v2[i], dev.fx_dsp_msb);
-		outb (page_seven_v2[i+1], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0x00; i < sizeof(mod_v2); i += 2) {
-		outb (mod_v2[i], dev.fx_mod_addr);
-		outb (mod_v2[i+1], dev.fx_mod_data);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0; i < sizeof (coefficients2); i += 4) {
-		outb (coefficients2[i], dev.fx_dsp_page);
-		outb (coefficients2[i+1], dev.fx_dsp_addr);
-		outb (coefficients2[i+2], dev.fx_dsp_msb);
-		outb (coefficients2[i+3], dev.fx_dsp_lsb);
-		if (!wffx_idle()) return (-1);
-	}
-
-	for (i = 0; i < sizeof (coefficients3); i += 2) {
-		int x;
-
-		outb (0x07, dev.fx_dsp_page);
-		x = (i % 4) ? 0x4e : 0x4c;
-		outb (x, dev.fx_dsp_addr);
-		outb (coefficients3[i], dev.fx_dsp_msb);
-		outb (coefficients3[i+1], dev.fx_dsp_lsb);
-	}
-
-	outb (0x00, dev.fx_op); /* mute off */
-	if (!wffx_idle()) return (-1);
-
-	return (0);
-}
-
-static int io = -1;
-static int irq = -1;
-
-MODULE_AUTHOR      ("Paul Barton-Davis <pbd@op.net>");
-MODULE_DESCRIPTION ("Turtle Beach WaveFront Linux Driver");
-MODULE_LICENSE("GPL");
-module_param       (io, int, 0);
-module_param       (irq, int, 0);
-
-static int __init init_wavfront (void)
-{
-	printk ("Turtle Beach WaveFront Driver\n"
-		"Copyright (C) by Hannu Solvainen, "
-		"Paul Barton-Davis 1993-1998.\n");
-
-	/* XXX t'would be lovely to ask the CS4232 for these values, eh ? */
-
-	if (io == -1 || irq == -1) {
-		printk (KERN_INFO LOGNAME "irq and io options must be set.\n");
-		return -EINVAL;
-	}
-
-	if (wavefront_interrupt_bits (irq) < 0) {
-		printk (KERN_INFO LOGNAME
-			"IRQ must be 9, 5, 12 or 15 (not %d)\n", irq);
-		return -ENODEV;
-	}
-
-	if (detect_wavefront (irq, io) < 0) {
-		return -ENODEV;
-	} 
-
-	if (install_wavefront () < 0) {
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static void __exit cleanup_wavfront (void)
-{
-	uninstall_wavefront ();
-}
-
-module_init(init_wavfront);
-module_exit(cleanup_wavfront);
--- linux-2.6.18.noarch/sound/oss/mpu401.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/mpu401.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/mpu401.c
+ * sound/oss/mpu401.c
  *
  * The low level driver for Roland MPU-401 compatible Midi cards.
  */
@@ -432,19 +432,10 @@
 	devc->m_busy = 0;
 }
 
-int intchk_mpu401(void *dev_id)
+static irqreturn_t mpuintr(int irq, void *dev_id)
 {
 	struct mpu_config *devc;
-	int dev = (int) dev_id;
-
-	devc = &dev_conf[dev];
-	return input_avail(devc);
-}
-
-irqreturn_t mpuintr(int irq, void *dev_id, struct pt_regs *dummy)
-{
-	struct mpu_config *devc;
-	int dev = (int) dev_id;
+	int dev = (int)(unsigned long) dev_id;
 	int handled = 0;
 
 	devc = &dev_conf[dev];
@@ -1032,7 +1023,7 @@
 				devc->capabilities |= MPU_CAP_INTLG;	/* Supports intelligent mode */
 
 
-	mpu401_synth_operations[m] = (struct synth_operations *)kmalloc(sizeof(struct synth_operations), GFP_KERNEL);
+	mpu401_synth_operations[m] = kmalloc(sizeof(struct synth_operations), GFP_KERNEL);
 
 	if (mpu401_synth_operations[m] == NULL)
 	{
@@ -1761,8 +1752,6 @@
 EXPORT_SYMBOL(probe_mpu401);
 EXPORT_SYMBOL(attach_mpu401);
 EXPORT_SYMBOL(unload_mpu401);
-EXPORT_SYMBOL(intchk_mpu401);
-EXPORT_SYMBOL(mpuintr);
 
 static struct address_info cfg;
 
--- linux-2.6.18.noarch/sound/oss/ad1889.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ad1889.c	2007-06-05 17:44:14.000000000 -0400
@@ -230,9 +230,8 @@
 	struct dmabuf *dmabuf;
 	int i;
 
-	if ((dev = kmalloc(sizeof(ad1889_dev_t), GFP_KERNEL)) == NULL) 
+	if ((dev = kzalloc(sizeof(ad1889_dev_t), GFP_KERNEL)) == NULL)
 		return NULL;
-	memset(dev, 0, sizeof(ad1889_dev_t));
 	spin_lock_init(&dev->lock);
 	dev->pci = pci;
 
@@ -778,7 +777,7 @@
 	return 0;
 }
 
-static struct file_operations ad1889_fops = {
+static const struct file_operations ad1889_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= ad1889_read,
@@ -812,7 +811,7 @@
 	return codec->mixer_ioctl(codec, cmd, arg);
 }
 
-static struct file_operations ad1889_mixer_fops = {
+static const struct file_operations ad1889_mixer_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.ioctl		= ad1889_mixer_ioctl,
@@ -929,7 +928,7 @@
 };
 MODULE_DEVICE_TABLE(pci, ad1889_id_tbl);
 
-static irqreturn_t ad1889_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t ad1889_interrupt(int irq, void *dev_id)
 {
 	u32 stat;
 	ad1889_dev_t *dev = (ad1889_dev_t *)dev_id;
--- linux-2.6.18.noarch/sound/oss/mad16.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/mad16.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,1113 +0,0 @@
-/*
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * mad16.c
- *
- * Initialization code for OPTi MAD16 compatible audio chips. Including
- *
- *      OPTi 82C928     MAD16           (replaced by C929)
- *      OAK OTI-601D    Mozart
- *      OAK OTI-605	Mozart		(later version with MPU401 Midi)
- *      OPTi 82C929     MAD16 Pro
- *      OPTi 82C930
- *      OPTi 82C924
- *
- * These audio interface chips don't produce sound themselves. They just
- * connect some other components (OPL-[234] and a WSS compatible codec)
- * to the PC bus and perform I/O, DMA and IRQ address decoding. There is
- * also a UART for the MPU-401 mode (not 82C928/Mozart).
- * The Mozart chip appears to be compatible with the 82C928, although later
- * issues of the card, using the OTI-605 chip, have an MPU-401 compatible Midi
- * port. This port is configured differently to that of the OPTi audio chips.
- *
- *	Changes
- *	
- *	Alan Cox		Clean up, added module selections.
- *
- *	A. Wik			Added support for Opti924 PnP.
- *				Improved debugging support.	16-May-1998
- *				Fixed bug.			16-Jun-1998
- *
- *      Torsten Duwe            Made Opti924 PnP support non-destructive
- *                                                             	23-Dec-1998
- *
- *	Paul Grayson		Added support for Midi on later Mozart cards.
- *								25-Nov-1999
- *	Christoph Hellwig	Adapted to module_init/module_exit.
- *	Arnaldo C. de Melo	got rid of attach_uart401       21-Sep-2000
- *
- *	Pavel Rabel		Clean up                           Nov-2000
- */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/gameport.h>
-#include <linux/spinlock.h>
-#include "sound_config.h"
-
-#include "ad1848.h"
-#include "sb.h"
-#include "mpu401.h"
-
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
-#define SUPPORT_JOYSTICK 1
-#endif
-
-static int      mad16_conf;
-static int      mad16_cdsel;
-static DEFINE_SPINLOCK(lock);
-
-#define C928	1
-#define MOZART	2
-#define C929	3
-#define C930	4
-#define C924    5
-
-/*
- *    Registers
- *
- *      The MAD16 occupies I/O ports 0xf8d to 0xf93 (fixed locations).
- *      All ports are inactive by default. They can be activated by
- *      writing 0xE2 or 0xE3 to the password register. The password is valid
- *      only until the next I/O read or write.
- *
- *      82C930 uses 0xE4 as the password and indirect addressing to access
- *      the config registers.
- */
-
-#define MC0_PORT	0xf8c	/* Dummy port */
-#define MC1_PORT	0xf8d	/* SB address, CD-ROM interface type, joystick */
-#define MC2_PORT	0xf8e	/* CD-ROM address, IRQ, DMA, plus OPL4 bit */
-#define MC3_PORT	0xf8f
-#define PASSWD_REG	0xf8f
-#define MC4_PORT	0xf90
-#define MC5_PORT	0xf91
-#define MC6_PORT	0xf92
-#define MC7_PORT	0xf93
-#define MC8_PORT	0xf94
-#define MC9_PORT	0xf95
-#define MC10_PORT	0xf96
-#define MC11_PORT	0xf97
-#define MC12_PORT	0xf98
-
-static int      board_type = C928;
-
-static int     *mad16_osp;
-static int	c931_detected;	/* minor differences from C930 */
-static char	c924pnp;	/* "     "           "    C924 */
-static int	debug;  	/* debugging output */
-
-#ifdef DDB
-#undef DDB
-#endif
-#define DDB(x) do {if (debug) x;} while (0)
-
-static unsigned char mad_read(int port)
-{
-	unsigned long flags;
-	unsigned char tmp;
-
-	spin_lock_irqsave(&lock,flags);
-
-	switch (board_type)	/* Output password */
-	{
-		case C928:
-		case MOZART:
-			outb((0xE2), PASSWD_REG);
-			break;
-
-		case C929:
-			outb((0xE3), PASSWD_REG);
-			break;
-
-		case C930:
-			/* outb(( 0xE4),  PASSWD_REG); */
-			break;
-
-		case C924:
-			/* the c924 has its ports relocated by -128 if
-			   PnP is enabled  -aw */
-			if (!c924pnp)
-				outb((0xE5), PASSWD_REG); else
-				outb((0xE5), PASSWD_REG - 0x80);
-			break;
-	}
-
-	if (board_type == C930)
-	{
-		outb((port - MC0_PORT), 0xe0e);	/* Write to index reg */
-		tmp = inb(0xe0f);	/* Read from data reg */
-	}
-	else
-		if (!c924pnp)
-			tmp = inb(port); else
-			tmp = inb(port-0x80);
-	spin_unlock_irqrestore(&lock,flags);
-
-	return tmp;
-}
-
-static void mad_write(int port, int value)
-{
-	unsigned long   flags;
-
-	spin_lock_irqsave(&lock,flags);
-
-	switch (board_type)	/* Output password */
-	{
-		case C928:
-		case MOZART:
-			outb((0xE2), PASSWD_REG);
-			break;
-
-		case C929:
-			outb((0xE3), PASSWD_REG);
-			break;
-
-		case C930:
-			/* outb(( 0xE4),  PASSWD_REG); */
-			break;
-
-		case C924:
-			if (!c924pnp)
-				outb((0xE5), PASSWD_REG); else
-				outb((0xE5), PASSWD_REG - 0x80);
-			break;
-	}
-
-	if (board_type == C930)
-	{
-		outb((port - MC0_PORT), 0xe0e);	/* Write to index reg */
-		outb(((unsigned char) (value & 0xff)), 0xe0f);
-	}
-	else
-		if (!c924pnp)
-			outb(((unsigned char) (value & 0xff)), port); else
-			outb(((unsigned char) (value & 0xff)), port-0x80);
-	spin_unlock_irqrestore(&lock,flags);
-}
-
-static int __init detect_c930(void)
-{
-	unsigned char   tmp = mad_read(MC1_PORT);
-
-	if ((tmp & 0x06) != 0x06)
-	{
-		DDB(printk("Wrong C930 signature (%x)\n", tmp));
-		/* return 0; */
-	}
-	mad_write(MC1_PORT, 0);
-
-	if (mad_read(MC1_PORT) != 0x06)
-	{
-		DDB(printk("Wrong C930 signature2 (%x)\n", tmp));
-		/* return 0; */
-	}
-	mad_write(MC1_PORT, tmp);	/* Restore bits */
-
-	mad_write(MC7_PORT, 0);
-	if ((tmp = mad_read(MC7_PORT)) != 0)
-	{
-		DDB(printk("MC7 not writable (%x)\n", tmp));
-		return 0;
-	}
-	mad_write(MC7_PORT, 0xcb);
-	if ((tmp = mad_read(MC7_PORT)) != 0xcb)
-	{
-		DDB(printk("MC7 not writable2 (%x)\n", tmp));
-		return 0;
-	}
-
-	tmp = mad_read(MC0_PORT+18);
-	if (tmp == 0xff || tmp == 0x00)
-		return 1;
-	/* We probably have a C931 */
-	DDB(printk("Detected C931 config=0x%02x\n", tmp));
-	c931_detected = 1;
-
-	/*
-         * We cannot configure the chip if it is in PnP mode.
-         * If we have a CSN assigned (bit 8 in MC13) we first try
-         * a software reset, then a software power off, finally
-         * Clearing PnP mode. The last option is not
-	 * Bit 8 in MC13 
-         */
-	if ((mad_read(MC0_PORT+13) & 0x80) == 0)
-		return 1;
-
-	/* Software reset */
-	mad_write(MC9_PORT, 0x02);
-	mad_write(MC9_PORT, 0x00);
-
-	if ((mad_read(MC0_PORT+13) & 0x80) == 0)
-		return 1;
-	
-	/* Power off, and on again */
-	mad_write(MC9_PORT, 0xc2);
-	mad_write(MC9_PORT, 0xc0);
-
-	if ((mad_read(MC0_PORT+13) & 0x80) == 0)
-		return 1;
-	
-#if 0	
-	/* Force off PnP mode. This is not recommended because
-	 * the PnP bios will not recognize the chip on the next
-	 * warm boot and may assignd different resources to other
-	 * PnP/PCI cards.
-	 */
-	mad_write(MC0_PORT+17, 0x04);
-#endif
-	return 1;
-}
-
-static int __init detect_mad16(void)
-{
-	unsigned char tmp, tmp2, bit;
-	int i, port;
-
-	/*
-	 * Check that reading a register doesn't return bus float (0xff)
-	 * when the card is accessed using password. This may fail in case
-	 * the card is in low power mode. Normally at least the power saving
-	 * mode bit should be 0.
-	 */
-
-	if ((tmp = mad_read(MC1_PORT)) == 0xff)
-	{
-		DDB(printk("MC1_PORT returned 0xff\n"));
-		return 0;
-	}
-	for (i = 0xf8d; i <= 0xf98; i++)
-		if (!c924pnp)
-			DDB(printk("Port %0x (init value) = %0x\n", i, mad_read(i)));
-		else
-			DDB(printk("Port %0x (init value) = %0x\n", i-0x80, mad_read(i)));
-
-	if (board_type == C930)
-		return detect_c930();
-
-	/*
-	 * Now check that the gate is closed on first I/O after writing
-	 * the password. (This is how a MAD16 compatible card works).
-	 */
-
-	if ((tmp2 = inb(MC1_PORT)) == tmp)	/* It didn't close */
-	{
-		DDB(printk("MC1_PORT didn't close after read (0x%02x)\n", tmp2));
-		return 0;
-	}
-
-	bit  = (c924pnp) ?     0x20 : 0x80;
-	port = (c924pnp) ? MC2_PORT : MC1_PORT;
-
-	tmp = mad_read(port);
-	mad_write(port, tmp ^ bit);	/* Toggle a bit */
-	if ((tmp2 = mad_read(port)) != (tmp ^ bit))	/* Compare the bit */
-	{
-		mad_write(port, tmp);	/* Restore */
-		DDB(printk("Bit revert test failed (0x%02x, 0x%02x)\n", tmp, tmp2));
-		return 0;
-	}
-	mad_write(port, tmp);	/* Restore */
-	return 1;		/* Bingo */
-}
-
-static int __init wss_init(struct address_info *hw_config)
-{
-	/*
-	 * Check if the IO port returns valid signature. The original MS Sound
-	 * system returns 0x04 while some cards (AudioTrix Pro for example)
-	 * return 0x00.
-	 */
-
-	if ((inb(hw_config->io_base + 3) & 0x3f) != 0x04 &&
-	    (inb(hw_config->io_base + 3) & 0x3f) != 0x00)
-	{
-		DDB(printk("No MSS signature detected on port 0x%x (0x%x)\n", hw_config->io_base, inb(hw_config->io_base + 3)));
-		return 0;
-	}
-	/*
-	 * Check that DMA0 is not in use with a 8 bit board.
-	 */
-	if (hw_config->dma == 0 && inb(hw_config->io_base + 3) & 0x80)
-	{
-		printk("MSS: Can't use DMA0 with a 8 bit card/slot\n");
-		return 0;
-	}
-	if (hw_config->irq > 9 && inb(hw_config->io_base + 3) & 0x80)
-		printk(KERN_ERR "MSS: Can't use IRQ%d with a 8 bit card/slot\n", hw_config->irq);
-	return 1;
-}
-
-static void __init init_c930(struct address_info *hw_config, int base)
-{
-	unsigned char cfg = 0;
-
-	cfg |= (0x0f & mad16_conf);
-
-	if(c931_detected)
-	{
-		/* Bit 0 has reversd meaning. Bits 1 and 2 sese
-		   reversed on write.
-		   Support only IDE cdrom. IDE port programmed
-		   somewhere else. */
-		cfg =  (cfg & 0x09) ^ 0x07;
-	}
-	cfg |= base << 4;
-	mad_write(MC1_PORT, cfg);
-
-	/* MC2 is CD configuration. Don't touch it. */
-
-	mad_write(MC3_PORT, 0);	/* Disable SB mode IRQ and DMA */
-
-	/* bit 2 of MC4 reverses it's meaning between the C930
-	   and the C931. */
-	cfg = c931_detected ? 0x04 : 0x00;
-
-	if(mad16_cdsel & 0x20)
-		mad_write(MC4_PORT, 0x62|cfg);  /* opl4 */
-	else
-		mad_write(MC4_PORT, 0x52|cfg);  /* opl3 */
-
-	mad_write(MC5_PORT, 0x3C);	/* Init it into mode2 */
-	mad_write(MC6_PORT, 0x02);	/* Enable WSS, Disable MPU and SB */
-	mad_write(MC7_PORT, 0xCB);
-	mad_write(MC10_PORT, 0x11);
-}
-
-static int __init chip_detect(void)
-{
-	int i;
-
-	/*
-	 *    Then try to detect with the old password
-	 */
-	board_type = C924;
-
-	DDB(printk("Detect using password = 0xE5\n"));
-	
-	if (detect_mad16()) {
-		return 1;
-	}
-	
-	board_type = C928;
-
-	DDB(printk("Detect using password = 0xE2\n"));
-
-	if (detect_mad16())
-	{
-		unsigned char model;
-
-		if (((model = mad_read(MC3_PORT)) & 0x03) == 0x03) {
-			DDB(printk("mad16.c: Mozart detected\n"));
-			board_type = MOZART;
-		} else {
-			DDB(printk("mad16.c: 82C928 detected???\n"));
-			board_type = C928;
-		}
-		return 1;
-	}
-
-	board_type = C929;
-
-	DDB(printk("Detect using password = 0xE3\n"));
-
-	if (detect_mad16())
-	{
-		DDB(printk("mad16.c: 82C929 detected\n"));
-		return 1;
-	}
-
-	if (inb(PASSWD_REG) != 0xff)
-		return 0;
-
-	/*
-	 * First relocate MC# registers to 0xe0e/0xe0f, disable password 
-	 */
-
-	outb((0xE4), PASSWD_REG);
-	outb((0x80), PASSWD_REG);
-
-	board_type = C930;
-
-	DDB(printk("Detect using password = 0xE4\n"));
-
-	for (i = 0xf8d; i <= 0xf93; i++)
-		DDB(printk("port %03x = %02x\n", i, mad_read(i)));
-
-        if(detect_mad16()) {
-		DDB(printk("mad16.c: 82C930 detected\n"));
-		return 1;
-	}
-
-	/* The C931 has the password reg at F8D */
-	outb((0xE4), 0xF8D);
-	outb((0x80), 0xF8D);
-	DDB(printk("Detect using password = 0xE4 for C931\n"));
-
-	if (detect_mad16()) {
-		return 1;
-	}
-
-	board_type = C924;
-	c924pnp++;
-	DDB(printk("Detect using password = 0xE5 (again), port offset -0x80\n"));
-	if (detect_mad16()) {
-		DDB(printk("mad16.c: 82C924 PnP detected\n"));
-		return 1;
-	}
-	
-	c924pnp=0;
-
-	return 0;
-}
-
-static int __init probe_mad16(struct address_info *hw_config)
-{
-	int i;
-	unsigned char tmp;
-	unsigned char cs4231_mode = 0;
-
-	int ad_flags = 0;
-
-	signed char bits;
-
-	static char     dma_bits[4] = {
-		1, 2, 0, 3
-	};
-
-	int config_port = hw_config->io_base + 0, version_port = hw_config->io_base + 3;
-	int dma = hw_config->dma, dma2 = hw_config->dma2;
-	unsigned char dma2_bit = 0;
-	int base;
-	struct resource *ports;
-
-	mad16_osp = hw_config->osp;
-
-	switch (hw_config->io_base) {
-	case 0x530:
-		base = 0;
-		break;
-	case 0xe80:
-		base = 1;
-		break;
-	case 0xf40:
-		base = 2;
-		break;
-	case 0x604:
-		base = 3;
-		break;
-	default:
-		printk(KERN_ERR "MAD16/Mozart: Bad WSS base address 0x%x\n", hw_config->io_base);
-		return 0;
-	}
-
-	if (dma != 0 && dma != 1 && dma != 3) {
-		printk(KERN_ERR "MSS: Bad DMA %d\n", dma);
-		return 0;
-	}
-
-	/*
-	 *    Check that all ports return 0xff (bus float) when no password
-	 *      is written to the password register.
-	 */
-
-	DDB(printk("--- Detecting MAD16 / Mozart ---\n"));
-	if (!chip_detect())
-		return 0;
-
-	switch (hw_config->irq) {
-	case 7:
-		bits = 8;
-		break;
-	case 9:
-		bits = 0x10;
-		break;
-	case 10:
-		bits = 0x18;
-		break;
-	case 12:
-		bits = 0x20;
-		break;
-	case 5:	/* Also IRQ5 is possible on C930 */
-		if (board_type == C930 || c924pnp) {
-			bits = 0x28;
-			break;
-		}
-	default:
-		printk(KERN_ERR "MAD16/Mozart: Bad IRQ %d\n", hw_config->irq);
-		return 0;
-	}
-
-	ports = request_region(hw_config->io_base + 4, 4, "ad1848");
-	if (!ports) {
-		printk(KERN_ERR "MSS: I/O port conflict\n");
-		return 0;
-	}
-	if (!request_region(hw_config->io_base, 4, "mad16 WSS config")) {
-		release_region(hw_config->io_base + 4, 4);
-		printk(KERN_ERR "MSS: I/O port conflict\n");
-		return 0;
-	}
-
-	if (board_type == C930) {
-		init_c930(hw_config, base);
-		goto got_it;
-	}
-
-	for (i = 0xf8d; i <= 0xf93; i++) {
-		if (!c924pnp)
-			DDB(printk("port %03x = %02x\n", i, mad_read(i)));
-		else
-			DDB(printk("port %03x = %02x\n", i-0x80, mad_read(i)));
-	}
-
-/*
- * Set the WSS address
- */
-
-	tmp = (mad_read(MC1_PORT) & 0x0f) | 0x80;	/* Enable WSS, Disable SB */
-	tmp |= base << 4;	/* WSS port select bits */
-
-	/*
-	 * Set optional CD-ROM and joystick settings.
-	 */
-
-	tmp &= ~0x0f;
-	tmp |= (mad16_conf & 0x0f);	/* CD-ROM and joystick bits */
-	mad_write(MC1_PORT, tmp);
-
-	tmp = mad16_cdsel;
-	mad_write(MC2_PORT, tmp);
-	mad_write(MC3_PORT, 0xf0);	/* Disable SB */
-
-	if (board_type == C924)	/* Specific C924 init values */
-	{
-		mad_write(MC4_PORT, 0xA0);
-		mad_write(MC5_PORT, 0x05);
-		mad_write(MC6_PORT, 0x03);
-	}
-	if (!ad1848_detect(ports, &ad_flags, mad16_osp))
-		goto fail;
-
-	if (ad_flags & (AD_F_CS4231 | AD_F_CS4248))
-		cs4231_mode = 0x02;	/* CS4248/CS4231 sync delay switch */
-
-	if (board_type == C929)
-	{
-		mad_write(MC4_PORT, 0xa2);
-		mad_write(MC5_PORT, 0xA5 | cs4231_mode);
-		mad_write(MC6_PORT, 0x03);	/* Disable MPU401 */
-	}
-	else
-	{
-		mad_write(MC4_PORT, 0x02);
-		mad_write(MC5_PORT, 0x30 | cs4231_mode);
-	}
-
-	for (i = 0xf8d; i <= 0xf93; i++) {
-		if (!c924pnp)
-			DDB(printk("port %03x after init = %02x\n", i, mad_read(i)));
-		else
-			DDB(printk("port %03x after init = %02x\n", i-0x80, mad_read(i)));
-	}
-
-got_it:
-	ad_flags = 0;
-	if (!ad1848_detect(ports, &ad_flags, mad16_osp))
-		goto fail;
-
-	if (!wss_init(hw_config))
-		goto fail;
-
-	/*
-	 * Set the IRQ and DMA addresses.
-	 */
-	
-	outb((bits | 0x40), config_port);
-	if ((inb(version_port) & 0x40) == 0)
-		printk(KERN_ERR "[IRQ Conflict?]\n");
-
-	/*
-	 * Handle the capture DMA channel
-	 */
-
-	if (ad_flags & AD_F_CS4231 && dma2 != -1 && dma2 != dma)
-	{
-		if (!((dma == 0 && dma2 == 1) ||
-			(dma == 1 && dma2 == 0) ||
-			(dma == 3 && dma2 == 0)))
-		{		/* Unsupported combination. Try to swap channels */
-			int tmp = dma;
-
-			dma = dma2;
-			dma2 = tmp;
-		}
-		if ((dma == 0 && dma2 == 1) || (dma == 1 && dma2 == 0) ||
-			(dma == 3 && dma2 == 0))
-		{
-			dma2_bit = 0x04;	/* Enable capture DMA */
-		}
-		else
-		{
-			printk("MAD16: Invalid capture DMA\n");
-			dma2 = dma;
-		}
-	}
-	else dma2 = dma;
-
-	outb((bits | dma_bits[dma] | dma2_bit), config_port);	/* Write IRQ+DMA setup */
-
-	hw_config->slots[0] = ad1848_init("mad16 WSS", ports,
-					  hw_config->irq,
-					  dma,
-					  dma2, 0,
-					  hw_config->osp,
-					  THIS_MODULE);
-	return 1;
-
-fail:
-	release_region(hw_config->io_base + 4, 4);
-	release_region(hw_config->io_base, 4);
-	return 0;
-}
-
-static int __init probe_mad16_mpu(struct address_info *hw_config)
-{
-	unsigned char tmp;
-
-	if (board_type < C929)	/* Early chip. No MPU support. Just SB MIDI */
-	{
-
-#ifdef CONFIG_MAD16_OLDCARD
-
-		tmp = mad_read(MC3_PORT);
-
-		/* 
-		 * MAD16 SB base is defined by the WSS base. It cannot be changed 
-		 * alone.
-		 * Ignore configured I/O base. Use the active setting. 
-		 */
-
-		if (mad_read(MC1_PORT) & 0x20)
-			hw_config->io_base = 0x240;
-		else
-			hw_config->io_base = 0x220;
-
-		switch (hw_config->irq)
-		{
-			case 5:
-				tmp = (tmp & 0x3f) | 0x80;
-				break;
-			case 7:
-				tmp = (tmp & 0x3f);
-				break;
-			case 11:
-				tmp = (tmp & 0x3f) | 0x40;
-				break;
-			default:
-				printk(KERN_ERR "mad16/Mozart: Invalid MIDI IRQ\n");
-				return 0;
-		}
-
-		mad_write(MC3_PORT, tmp | 0x04);
-		hw_config->driver_use_1 = SB_MIDI_ONLY;
-		if (!request_region(hw_config->io_base, 16, "soundblaster"))
-			return 0;
-		if (!sb_dsp_detect(hw_config, 0, 0, NULL)) {
-			release_region(hw_config->io_base, 16);
-			return 0;
-		}
-
-		if (mad_read(MC1_PORT) & 0x20)
-			hw_config->io_base = 0x240;
-		else
-			hw_config->io_base = 0x220;
-
-		hw_config->name = "Mad16/Mozart";
-		sb_dsp_init(hw_config, THIS_MODULE);
-		return 1;
-#else
-		/* assuming all later Mozart cards are identified as
-		 * either 82C928 or Mozart. If so, following code attempts
-		 * to set MPU register. TODO - add probing
-		 */
-
-		tmp = mad_read(MC8_PORT);
-
-		switch (hw_config->irq)
-		{
-			case 5:
-				tmp |= 0x08;
-				break;
-			case 7:
-				tmp |= 0x10;
-				break;
-			case 9:
-				tmp |= 0x18;
-				break;
-			case 10:
-				tmp |= 0x20;
-				break;
-			case 11:
-				tmp |= 0x28;
-				break;
-			default:
-				printk(KERN_ERR "mad16/MOZART: invalid mpu_irq\n");
-				return 0;
-		}
-
-		switch (hw_config->io_base)
-		{
-			case 0x300:
-				tmp |= 0x01;
-				break;
-			case 0x310:
-				tmp |= 0x03;
-				break;
-			case 0x320:
-				tmp |= 0x05;
-				break;
-			case 0x330:
-				tmp |= 0x07;
-				break;
-			default:
-				printk(KERN_ERR "mad16/MOZART: invalid mpu_io\n");
-				return 0;
-		}
-
-		mad_write(MC8_PORT, tmp);	/* write MPU port parameters */
-		goto probe_401;
-#endif
-	}
-	tmp = mad_read(MC6_PORT) & 0x83;
-	tmp |= 0x80;		/* MPU-401 enable */
-
-	/* Set the MPU base bits */
-
-	switch (hw_config->io_base)
-	{
-		case 0x300:
-			tmp |= 0x60;
-			break;
-		case 0x310:
-			tmp |= 0x40;
-			break;
-		case 0x320:
-			tmp |= 0x20;
-			break;
-		case 0x330:
-			tmp |= 0x00;
-			break;
-		default:
-			printk(KERN_ERR "MAD16: Invalid MIDI port 0x%x\n", hw_config->io_base);
-			return 0;
-	}
-
-	/* Set the MPU IRQ bits */
-
-	switch (hw_config->irq)
-	{
-		case 5:
-			tmp |= 0x10;
-			break;
-		case 7:
-			tmp |= 0x18;
-			break;
-		case 9:
-			tmp |= 0x00;
-			break;
-		case 10:
-			tmp |= 0x08;
-			break;
-		default:
-			printk(KERN_ERR "MAD16: Invalid MIDI IRQ %d\n", hw_config->irq);
-			break;
-	}
-			
-	mad_write(MC6_PORT, tmp);	/* Write MPU401 config */
-
-#ifndef CONFIG_MAD16_OLDCARD
-probe_401:
-#endif
-	hw_config->driver_use_1 = SB_MIDI_ONLY;
-	hw_config->name = "Mad16/Mozart";
-	return probe_uart401(hw_config, THIS_MODULE);
-}
-
-static void __exit unload_mad16(struct address_info *hw_config)
-{
-	ad1848_unload(hw_config->io_base + 4,
-			hw_config->irq,
-			hw_config->dma,
-			hw_config->dma2, 0);
-	release_region(hw_config->io_base, 4);
-	sound_unload_audiodev(hw_config->slots[0]);
-}
-
-static void __exit unload_mad16_mpu(struct address_info *hw_config)
-{
-#ifdef CONFIG_MAD16_OLDCARD
-	if (board_type < C929)	/* Early chip. No MPU support. Just SB MIDI */
-	{
-		sb_dsp_unload(hw_config, 0);
-		return;
-	}
-#endif
-
-	unload_uart401(hw_config);
-}
-
-static struct address_info cfg;
-static struct address_info cfg_mpu;
-
-static int found_mpu;
-
-static int __initdata mpu_io = 0;
-static int __initdata mpu_irq = 0;
-static int __initdata io = -1;
-static int __initdata dma = -1;
-static int __initdata dma16 = -1; /* Set this for modules that need it */
-static int __initdata irq = -1;
-static int __initdata cdtype = 0;
-static int __initdata cdirq = 0;
-static int __initdata cdport = 0x340;
-static int __initdata cddma = -1;
-static int __initdata opl4 = 0;
-static int __initdata joystick = 0;
-
-module_param(mpu_io, int, 0);
-module_param(mpu_irq, int, 0);
-module_param(io, int, 0);
-module_param(dma, int, 0);
-module_param(dma16, int, 0);
-module_param(irq, int, 0);
-module_param(cdtype, int, 0);
-module_param(cdirq, int, 0);
-module_param(cdport, int, 0);
-module_param(cddma, int, 0);
-module_param(opl4, int, 0);
-module_param(joystick, bool, 0);
-module_param(debug, bool, 0644);
-
-static int __initdata dma_map[2][8] =
-{
-	{0x03, -1, -1, -1, -1, 0x00, 0x01, 0x02},
-	{0x03, -1, 0x01, 0x00, -1, -1, -1, -1}
-};
-
-static int __initdata irq_map[16] =
-{
-	0x00, -1, -1, 0x0A,
-	-1, 0x04, -1, 0x08,
-	-1, 0x10, 0x14, 0x18,
-	-1, -1, -1, -1
-};
-
-#ifdef SUPPORT_JOYSTICK
-
-static struct gameport *gameport;
-
-static int __devinit mad16_register_gameport(int io_port)
-{
-	if (!request_region(io_port, 1, "mad16 gameport")) {
-		printk(KERN_ERR "mad16: gameport address 0x%#x already in use\n", io_port);
-		return -EBUSY;
-	}
-
-	gameport = gameport_allocate_port();
-	if (!gameport) {
-		printk(KERN_ERR "mad16: can not allocate memory for gameport\n");
-		release_region(io_port, 1);
-		return -ENOMEM;
-	}
-
-	gameport_set_name(gameport, "MAD16 Gameport");
-	gameport_set_phys(gameport, "isa%04x/gameport0", io_port);
-	gameport->io = io_port;
-
-	gameport_register_port(gameport);
-
-	return 0;
-}
-
-static inline void mad16_unregister_gameport(void)
-{
-	if (gameport) {
-		/* the gameport was initialized so we must free it up */
-		gameport_unregister_port(gameport);
-		gameport = NULL;
-		release_region(0x201, 1);
-	}
-}
-#else
-static inline int mad16_register_gameport(int io_port) { return -ENOSYS; }
-static inline void mad16_unregister_gameport(void) { }
-#endif
-
-static int __devinit init_mad16(void)
-{
-	int dmatype = 0;
-
-	printk(KERN_INFO "MAD16 audio driver Copyright (C) by Hannu Savolainen 1993-1996\n");
-
-	printk(KERN_INFO "CDROM ");
-	switch (cdtype)
-	{
-		case 0x00:
-			printk("Disabled");
-			cdirq = 0;
-			break;
-		case 0x02:
-			printk("Sony CDU31A");
-			dmatype = 1;
-			if(cddma == -1) cddma = 3;
-			break;
-		case 0x04:
-			printk("Mitsumi");
-			dmatype = 0;
-			if(cddma == -1) cddma = 5;
-			break;
-		case 0x06:
-			printk("Panasonic Lasermate");
-			dmatype = 1;
-			if(cddma == -1) cddma = 3;
-			break;
-		case 0x08:
-			printk("Secondary IDE");
-			dmatype = 0;
-			if(cddma == -1) cddma = 5;
-			break;
-		case 0x0A:
-			printk("Primary IDE");
-			dmatype = 0;
-			if(cddma == -1) cddma = 5;
-			break;
-		default:
-			printk("\n");
-			printk(KERN_ERR "Invalid CDROM type\n");
-			return -EINVAL;
-	}
-
-	/*
-	 *    Build the config words
-	 */
-
-	mad16_conf = (joystick ^ 1) | cdtype;
-	mad16_cdsel = 0;
-	if (opl4)
-		mad16_cdsel |= 0x20;
-
-	if(cdtype){
-		if (cddma > 7 || cddma < 0 || dma_map[dmatype][cddma] == -1)
-		{
-			printk("\n");
-			printk(KERN_ERR "Invalid CDROM DMA\n");
-			return -EINVAL;
-		}
-		if (cddma)
-			printk(", DMA %d", cddma);
-		else
-			printk(", no DMA");
-
-		if (!cdirq)
-			printk(", no IRQ");
-		else if (cdirq < 0 || cdirq > 15 || irq_map[cdirq] == -1)
-		{
-			printk(", invalid IRQ (disabling)");
-			cdirq = 0;
-		}
-		else printk(", IRQ %d", cdirq);
-
-		mad16_cdsel |= dma_map[dmatype][cddma];
-
-		if (cdtype < 0x08)
-		{
-			switch (cdport)
-			{
-				case 0x340:
-					mad16_cdsel |= 0x00;
-					break;
-				case 0x330:
-					mad16_cdsel |= 0x40;
-					break;
-				case 0x360:
-					mad16_cdsel |= 0x80;
-					break;
-				case 0x320:
-					mad16_cdsel |= 0xC0;
-					break;
-				default:
-					printk(KERN_ERR "Unknown CDROM I/O base %d\n", cdport);
-					return -EINVAL;
-			}
-		}
-		mad16_cdsel |= irq_map[cdirq];
-	}
-
-	printk(".\n");
-
-	cfg.io_base = io;
-	cfg.irq = irq;
-	cfg.dma = dma;
-	cfg.dma2 = dma16;
-
-	if (cfg.io_base == -1 || cfg.dma == -1 || cfg.irq == -1) {
-		printk(KERN_ERR "I/O, DMA and irq are mandatory\n");
-		return -EINVAL;
-	}
-
-	if (!request_region(MC0_PORT, 12, "mad16"))
-		return -EBUSY;
-
-	if (!probe_mad16(&cfg)) {
-		release_region(MC0_PORT, 12);
-		return -ENODEV;
-	}
-
-	cfg_mpu.io_base = mpu_io;
-	cfg_mpu.irq = mpu_irq;
-
-	found_mpu = probe_mad16_mpu(&cfg_mpu);
-
-	if (joystick)
-		mad16_register_gameport(0x201);
-
-	return 0;
-}
-
-static void __exit cleanup_mad16(void)
-{
-	if (found_mpu)
-		unload_mad16_mpu(&cfg_mpu);
-	mad16_unregister_gameport();
-	unload_mad16(&cfg);
-	release_region(MC0_PORT, 12);
-}
-
-module_init(init_mad16);
-module_exit(cleanup_mad16);
-
-#ifndef MODULE
-static int __init setup_mad16(char *str)
-{
-	/* io, irq */
-	int ints[8];
-
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-
-	io	 = ints[1];
-	irq	 = ints[2];
-	dma	 = ints[3];
-	dma16	 = ints[4];
-	mpu_io	 = ints[5];
-	mpu_irq  = ints[6];
-	joystick = ints[7];
-
-	return 1;
-}
-
-__setup("mad16=", setup_mad16);
-#endif
-MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/oss/soundcard.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/soundcard.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/sound/soundcard.c
+ * linux/sound/oss/soundcard.c
  *
  * Sound card driver for Linux
  *
@@ -32,6 +32,7 @@
 #include <linux/ctype.h>
 #include <linux/stddef.h>
 #include <linux/kmod.h>
+#include <linux/kernel.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include <linux/wait.h>
@@ -42,6 +43,7 @@
 #include <linux/proc_fs.h>
 #include <linux/smp_lock.h>
 #include <linux/module.h>
+#include <linux/mm.h>
 
 /*
  * This ought to be moved into include/asm/dma.h
@@ -107,6 +109,7 @@
 		mixer_vols[n].levels[i] = levels[i];
 	return mixer_vols[n].levels;
 }
+EXPORT_SYMBOL(load_mixer_volumes);
 
 static int set_mixer_levels(void __user * arg)
 {
@@ -139,7 +142,7 @@
 
 static ssize_t sound_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
-	int dev = iminor(file->f_dentry->d_inode);
+	int dev = iminor(file->f_path.dentry->d_inode);
 	int ret = -EINVAL;
 
 	/*
@@ -172,7 +175,7 @@
 
 static ssize_t sound_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 {
-	int dev = iminor(file->f_dentry->d_inode);
+	int dev = iminor(file->f_path.dentry->d_inode);
 	int ret = -EINVAL;
 	
 	lock_kernel();
@@ -391,7 +394,7 @@
 
 static unsigned int sound_poll(struct file *file, poll_table * wait)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = file->f_path.dentry->d_inode;
 	int dev = iminor(inode);
 
 	DEB(printk("sound_poll(dev=%d)\n", dev));
@@ -416,7 +419,7 @@
 	int dev_class;
 	unsigned long size;
 	struct dma_buffparms *dmap = NULL;
-	int dev = iminor(file->f_dentry->d_inode);
+	int dev = iminor(file->f_path.dentry->d_inode);
 
 	dev_class = dev & 0x0f;
 	dev >>= 4;
@@ -480,7 +483,7 @@
 	return 0;
 }
 
-struct file_operations oss_sound_fops = {
+const struct file_operations oss_sound_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= sound_read,
@@ -541,12 +544,6 @@
 	int             err;
 	int i, j;
 	
-	/* drag in sound_syms.o */
-	{
-		extern char sound_syms_symbol;
-		sound_syms_symbol = 0;
-	}
-
 #ifdef CONFIG_PCI
 	if(dmabug)
 		isa_dma_bridge_buggy = dmabug;
@@ -561,18 +558,18 @@
 	/* Protecting the innocent */
 	sound_dmap_flag = (dmabuf > 0 ? 1 : 0);
 
-	for (i = 0; i < sizeof (dev_list) / sizeof *dev_list; i++) {
-		class_device_create(sound_class, NULL,
-				    MKDEV(SOUND_MAJOR, dev_list[i].minor),
-				    NULL, "%s", dev_list[i].name);
+	for (i = 0; i < ARRAY_SIZE(dev_list); i++) {
+		device_create(sound_class, NULL,
+			      MKDEV(SOUND_MAJOR, dev_list[i].minor),
+			      "%s", dev_list[i].name);
 
 		if (!dev_list[i].num)
 			continue;
 
 		for (j = 1; j < *dev_list[i].num; j++)
-			class_device_create(sound_class, NULL,
-					    MKDEV(SOUND_MAJOR, dev_list[i].minor + (j*0x10)),
-					    NULL, "%s%d", dev_list[i].name, j);
+			device_create(sound_class, NULL,
+				      MKDEV(SOUND_MAJOR, dev_list[i].minor + (j*0x10)),
+				      "%s%d", dev_list[i].name, j);
 	}
 
 	if (sound_nblocks >= 1024)
@@ -585,12 +582,12 @@
 {
 	int i, j;
 
-	for (i = 0; i < sizeof (dev_list) / sizeof *dev_list; i++) {
-		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, dev_list[i].minor));
+	for (i = 0; i < ARRAY_SIZE(dev_list); i++) {
+		device_destroy(sound_class, MKDEV(SOUND_MAJOR, dev_list[i].minor));
 		if (!dev_list[i].num)
 			continue;
 		for (j = 1; j < *dev_list[i].num; j++)
-			class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, dev_list[i].minor + (j*0x10)));
+			device_destroy(sound_class, MKDEV(SOUND_MAJOR, dev_list[i].minor + (j*0x10)));
 	}
 	
 	unregister_sound_special(1);
@@ -614,6 +611,8 @@
 module_init(oss_init);
 module_exit(oss_cleanup);
 MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("OSS Sound subsystem");
+MODULE_AUTHOR("Hannu Savolainen, et al.");
 
 
 int sound_alloc_dma(int chn, char *deviceID)
@@ -627,6 +626,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(sound_alloc_dma);
 
 int sound_open_dma(int chn, char *deviceID)
 {
@@ -642,6 +642,7 @@
 	dma_alloc_map[chn] = DMA_MAP_BUSY;
 	return 0;
 }
+EXPORT_SYMBOL(sound_open_dma);
 
 void sound_free_dma(int chn)
 {
@@ -652,6 +653,7 @@
 	free_dma(chn);
 	dma_alloc_map[chn] = DMA_MAP_UNAVAIL;
 }
+EXPORT_SYMBOL(sound_free_dma);
 
 void sound_close_dma(int chn)
 {
@@ -661,6 +663,7 @@
 	}
 	dma_alloc_map[chn] = DMA_MAP_FREE;
 }
+EXPORT_SYMBOL(sound_close_dma);
 
 static void do_sequencer_timer(unsigned long dummy)
 {
@@ -714,6 +717,7 @@
 	printk("\n");
 #endif
 }
+EXPORT_SYMBOL(conf_printf);
 
 void conf_printf2(char *name, int base, int irq, int dma, int dma2)
 {
@@ -734,3 +738,5 @@
 	printk("\n");
 #endif
 }
+EXPORT_SYMBOL(conf_printf2);
+
--- linux-2.6.18.noarch/sound/oss/rme96xx.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/rme96xx.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,1857 +0,0 @@
-/* (C) 2000 Guenter Geiger <geiger@debian.org>
-   with copy/pastes from the driver of Winfried Ritsch <ritsch@iem.kug.ac.at>
-   based on es1370.c
-
-
-
-   *  10 Jan 2001: 0.1 initial version
-   *  19 Jan 2001: 0.2 fixed bug in select()
-   *  27 Apr 2001: 0.3 more than one card usable
-   *  11 May 2001: 0.4 fixed for SMP, included into kernel source tree
-   *  17 May 2001: 0.5 draining code didn't work on new cards
-   *  18 May 2001: 0.6 remove synchronize_irq() call 
-   *  17 Jul 2001: 0.7 updated xrmectrl to make it work for newer cards
-   *   2 feb 2002: 0.8 fixed pci device handling, see below for patches from Heiko (Thanks!)
-                       Marcus Meissner <Marcus.Meissner@caldera.de>
-
-		       Modifications - Heiko Purnhagen <purnhage@tnt.uni-hannover.de>
-		       HP20020108 fixed handling of "large" read()
-		       HP20020116 towards REV 1.5 support, based on ALSA's card-rme9652.c
-		       HP20020118 made mixer ioctl and handling of devices>1 more safe
-		       HP20020201 fixed handling of "large" read() properly
-		       added REV 1.5 S/P-DIF receiver support
-		       SNDCTL_DSP_SPEED now returns the actual speed
-   *  10 Aug 2002: added synchronize_irq() again
-
-TODO:
-   - test more than one card --- done
-   - check for pci IOREGION (see es1370) in rme96xx_probe ??
-   - error detection
-   - mmap interface
-   - mixer mmap interface
-   - mixer ioctl
-   - get rid of noise upon first open (why ??)
-   - allow multiple open (at least for read)
-   - allow multiple open for non overlapping regions
-   - recheck the multiple devices part (offsets of different devices, etc)
-   - do decent draining in _release --- done
-   - SMP support
-   - what about using fragstotal>2 for small fragsize? (HP20020118)
-   - add support for AFMT_S32_LE
-*/
-
-#ifndef RMEVERSION
-#define RMEVERSION "0.8"
-#endif
-
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/sched.h>
-#include <linux/sound.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/smp_lock.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/poll.h>
-#include <linux/wait.h>
-#include <linux/mutex.h>
-
-#include <asm/dma.h>
-#include <asm/page.h>
-
-#include "rme96xx.h"
-
-#define NR_DEVICE 2
-
-static int devices = 1;
-module_param(devices, int, 0);
-MODULE_PARM_DESC(devices, "number of dsp devices allocated by the driver");
-
-
-MODULE_AUTHOR("Guenter Geiger, geiger@debian.org");
-MODULE_DESCRIPTION("RME9652/36 \"Hammerfall\" Driver");
-MODULE_LICENSE("GPL");
-
-
-#ifdef DEBUG
-#define DBG(x) printk("RME_DEBUG:");x
-#define COMM(x) printk("RME_COMM: " x "\n");
-#else
-#define DBG(x) while (0) {}
-#define COMM(x)
-#endif
-
-/*-------------------------------------------------------------------------- 
-                        Preporcessor Macros and Definitions
- --------------------------------------------------------------------------*/
-
-#define RME96xx_MAGIC 0x6473
-
-/* Registers-Space in offsets from base address with 16MByte size */
-
-#define RME96xx_IO_EXTENT     16l*1024l*1024l
-#define RME96xx_CHANNELS_PER_CARD 26
-
-/*                  Write - Register */
-
-/* 0,4,8,12,16,20,24,28 ... hardware init (erasing fifo-pointer intern) */
-#define RME96xx_num_of_init_regs   8
-
-#define RME96xx_init_buffer       (0/4)
-#define RME96xx_play_buffer       (32/4)  /* pointer to 26x64kBit RAM from mainboard */
-#define RME96xx_rec_buffer        (36/4)  /* pointer to 26x64kBit RAM from mainboard */
-#define RME96xx_control_register  (64/4)  /* exact meaning see below */
-#define RME96xx_irq_clear         (96/4)  /* irq acknowledge */
-#define RME96xx_time_code         (100/4) /* if used with alesis adat */
-#define RME96xx_thru_base         (128/4) /* 132...228 Thru for 26 channels */
-#define RME96xx_thru_channels     RME96xx_CHANNELS_PER_CARD
-
-/*                     Read Register */
-
-#define RME96xx_status_register    0     /* meaning see below */
-
-
-
-/* Status Register: */
-/* ------------------------------------------------------------------------ */
-#define RME96xx_IRQ          0x0000001 /* IRQ is High if not reset by RMExx_irq_clear */
-#define RME96xx_lock_2       0x0000002 /* ADAT 3-PLL: 1=locked, 0=unlocked */
-#define RME96xx_lock_1       0x0000004 /* ADAT 2-PLL: 1=locked, 0=unlocked */
-#define RME96xx_lock_0       0x0000008 /* ADAT 1-PLL: 1=locked, 0=unlocked */
-
-#define RME96xx_fs48         0x0000010 /* sample rate 0 ...44.1/88.2,  1 ... 48/96 Khz */
-#define RME96xx_wsel_rd      0x0000020 /* if Word-Clock is used and valid then 1 */
-#define RME96xx_buf_pos1     0x0000040 /* Bit 6..15 : Position of buffer-pointer in 64Bytes-blocks */
-#define RME96xx_buf_pos2     0x0000080 /* resolution +/- 1 64Byte/block (since 64Bytes bursts) */
- 
-#define RME96xx_buf_pos3     0x0000100 /* 10 bits = 1024 values */
-#define RME96xx_buf_pos4     0x0000200 /* if we mask off the first 6 bits, we can take the status */
-#define RME96xx_buf_pos5     0x0000400 /* register as sample counter in the hardware buffer */
-#define RME96xx_buf_pos6     0x0000800 
-
-#define RME96xx_buf_pos7     0x0001000 
-#define RME96xx_buf_pos8     0x0002000 
-#define RME96xx_buf_pos9     0x0004000
-#define RME96xx_buf_pos10    0x0008000 
-
-#define RME96xx_sync_2       0x0010000 /* if ADAT-IN3 synced to system clock */
-#define RME96xx_sync_1       0x0020000 /* if ADAT-IN2 synced to system clock */
-#define RME96xx_sync_0       0x0040000 /* if ADAT-IN1 synced to system clock */
-#define RME96xx_DS_rd        0x0080000 /* 1=Double Speed, 0=Normal Speed */
-
-#define RME96xx_tc_busy      0x0100000 /* 1=time-code copy in progress (960ms) */
-#define RME96xx_tc_out       0x0200000 /* time-code out bit */
-#define RME96xx_F_0          0x0400000 /*  000=64kHz, 100=88.2kHz, 011=96kHz  */
-#define RME96xx_F_1          0x0800000 /*  111=32kHz, 110=44.1kHz, 101=48kHz, */
-
-#define RME96xx_F_2          0x1000000 /*  001=Rev 1.5+ external Crystal Chip */
-#define RME96xx_ERF          0x2000000 /* Error-Flag of SDPIF Receiver (1=No Lock)*/
-#define RME96xx_buffer_id    0x4000000 /* toggles by each interrupt on rec/play */
-#define RME96xx_tc_valid     0x8000000 /* 1 = a signal is detected on time-code input */
-#define RME96xx_SPDIF_READ  0x10000000 /* byte available from Rev 1.5+ SPDIF interface */
-
-/* Status Register Fields */
-
-#define RME96xx_lock            (RME96xx_lock_0|RME96xx_lock_1|RME96xx_lock_2)
-#define RME96xx_sync            (RME96xx_sync_0|RME96xx_sync_1|RME96xx_sync_2)
-#define RME96xx_F               (RME96xx_F_0|RME96xx_F_1|RME96xx_F_2)
-#define rme96xx_decode_spdif_rate(x) ((x)>>22)
-
-/* Bit 6..15 : h/w buffer pointer */
-#define RME96xx_buf_pos          0x000FFC0 
-/* Bits 31,30,29 are bits 5,4,3 of h/w pointer position on later
-   Rev G EEPROMS and Rev 1.5 cards or later.
-*/ 
-#define RME96xx_REV15_buf_pos(x) ((((x)&0xE0000000)>>26)|((x)&RME96xx_buf_pos))
-
-
-/* Control-Register: */			    
-/*--------------------------------------------------------------------------------*/
-
-#define RME96xx_start_bit	0x0001 /* start record/play */
-#define RME96xx_latency0	0x0002 /* Buffer size / latency */
-#define RME96xx_latency1	0x0004 /*   buffersize = 512Bytes * 2^n */
-#define RME96xx_latency2	0x0008 /*   0=64samples ... 7=8192samples */
-
-#define RME96xx_Master		0x0010 /* Clock Mode 1=Master, 0=Slave/Auto */
-#define RME96xx_IE		0x0020 /* Interupt Enable */
-#define RME96xx_freq		0x0040 /* samplerate 0=44.1/88.2, 1=48/96 kHz*/
-#define RME96xx_freq1		0x0080 /* samplerate 0=32 kHz, 1=other rates ??? (from ALSA, but may be wrong) */
-#define RME96xx_DS              0x0100 /* double speed 0=44.1/48, 1=88.2/96 Khz */
-#define RME96xx_PRO		0x0200 /* SPDIF-OUT 0=consumer, 1=professional */
-#define RME96xx_EMP		0x0400 /* SPDIF-OUT emphasis 0=off, 1=on */
-#define RME96xx_Dolby		0x0800 /* SPDIF-OUT non-audio bit 1=set, 0=unset */
-
-#define RME96xx_opt_out	        0x1000 /* use 1st optical OUT as SPDIF: 1=yes, 0=no */
-#define RME96xx_wsel            0x2000 /* use Wordclock as sync (overwrites master) */
-#define RME96xx_inp_0           0x4000 /* SPDIF-IN 00=optical (ADAT1), */
-#define RME96xx_inp_1           0x8000 /* 01=coaxial (Cinch), 10=internal CDROM */
-
-#define RME96xx_SyncRef0       0x10000 /* preferred sync-source in autosync */
-#define RME96xx_SyncRef1       0x20000 /* 00=ADAT1, 01=ADAT2, 10=ADAT3, 11=SPDIF */
-
-#define RME96xx_SPDIF_RESET    (1<<18) /* Rev 1.5+: h/w SPDIF receiver */
-#define RME96xx_SPDIF_SELECT   (1<<19)
-#define RME96xx_SPDIF_CLOCK    (1<<20)
-#define RME96xx_SPDIF_WRITE    (1<<21)
-#define RME96xx_ADAT1_INTERNAL (1<<22) /* Rev 1.5+: if set, internal CD connector carries ADAT */
-
-
-#define RME96xx_ctrl_init            (RME96xx_latency0 |\
-                                     RME96xx_Master |\
-                                     RME96xx_inp_1)
-                              
-
-
-/* Control register fields and shortcuts */
-
-#define RME96xx_latency (RME96xx_latency0|RME96xx_latency1|RME96xx_latency2)
-#define RME96xx_inp         (RME96xx_inp_0|RME96xx_inp_1)
-#define RME96xx_SyncRef    (RME96xx_SyncRef0|RME96xx_SyncRef1)
-#define RME96xx_mixer_allowed (RME96xx_Master|RME96xx_PRO|RME96xx_EMP|RME96xx_Dolby|RME96xx_opt_out|RME96xx_wsel|RME96xx_inp|RME96xx_SyncRef|RME96xx_ADAT1_INTERNAL)
-
-/* latency = 512Bytes * 2^n, where n is made from Bit3 ... Bit1  (??? HP20020201) */
-
-#define RME96xx_SET_LATENCY(x)   (((x)&0x7)<<1)
-#define RME96xx_GET_LATENCY(x)   (((x)>>1)&0x7)
-#define RME96xx_SET_inp(x) (((x)&0x3)<<14)
-#define RME96xx_GET_inp(x)   (((x)>>14)&0x3)
-#define RME96xx_SET_SyncRef(x) (((x)&0x3)<<17)
-#define RME96xx_GET_SyncRef(x)   (((x)>>17)&0x3)
-
-
-/* buffer sizes */
-#define RME96xx_BYTES_PER_SAMPLE  4 /* sizeof(u32) */
-#define RME_16K 16*1024
-
-#define RME96xx_DMA_MAX_SAMPLES  (RME_16K)
-#define RME96xx_DMA_MAX_SIZE     (RME_16K * RME96xx_BYTES_PER_SAMPLE)
-#define RME96xx_DMA_MAX_SIZE_ALL (RME96xx_DMA_MAX_SIZE * RME96xx_CHANNELS_PER_CARD)
-
-#define RME96xx_NUM_OF_FRAGMENTS     2
-#define RME96xx_FRAGMENT_MAX_SIZE    (RME96xx_DMA_MAX_SIZE/2)
-#define RME96xx_FRAGMENT_MAX_SAMPLES (RME96xx_DMA_MAX_SAMPLES/2)
-#define RME96xx_MAX_LATENCY       7   /* 16k samples */
-
-
-#define RME96xx_MAX_DEVS 4 /* we provide some OSS stereodevs */
-#define RME96xx_MASK_DEVS 0x3 /* RME96xx_MAX_DEVS-1 */
-
-#define RME_MESS "rme96xx:"
-/*------------------------------------------------------------------------ 
-                  Types, struct and function declarations 
- ------------------------------------------------------------------------*/
-
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT RME_MESS" invalid magic value\n";
-
-#define VALIDATE_STATE(s)                         \
-({                                                \
-	if (!(s) || (s)->magic != RME96xx_MAGIC) { \
-		printk(invalid_magic);            \
-		return -ENXIO;                    \
-	}                                         \
-})
-
-/* --------------------------------------------------------------------- */
-
-
-static struct file_operations rme96xx_audio_fops;
-static struct file_operations rme96xx_mixer_fops;
-static int numcards;
-
-typedef int32_t raw_sample_t;
-
-typedef struct _rme96xx_info {
-
-	/* hardware settings */
-	int magic;
-	struct pci_dev * pcidev; /* pci_dev structure */
-	unsigned long __iomem *iobase;	
-	unsigned int irq;
-
-	/* list of rme96xx devices */
-	struct list_head devs;
-
-	spinlock_t lock;
-
-	u32 *recbuf;             /* memory for rec buffer */
-	u32 *playbuf;            /* memory for play buffer */
-
-	u32 control_register;
-
-	u32 thru_bits; /* thru 1=on, 0=off channel 1=Bit1... channel 26= Bit26 */
-
-	int hw_rev;             /* h/w rev * 10 (i.e. 1.5 has hw_rev = 15) */
-	char *card_name;	/* hammerfall or hammerfall light names */
-
-	int open_count;         /* unused ???   HP20020201 */
-
-	int rate;
-	int latency;
-	unsigned int fragsize;
-	int started;
-
-	int hwptr; /* can be negativ because of pci burst offset  */
-	unsigned int hwbufid;  /* set by interrupt, buffer which is written/read now */
-	
-	struct dmabuf {
-
-		unsigned int format;
-		int formatshift;
-		int inchannels;       /* number of channels for device */
-		int outchannels;       /* number of channels for device */
-		int mono; /* if true, we play mono on 2 channels */
-		int inoffset; /* which channel is considered the first one */
-         	int outoffset;
-		
-		/* state */
-		int opened;               /* open() made */
-		int started;              /* first write/read */
-		int mmapped;              /* mmap */
-		int open_mode;
-
-		struct _rme96xx_info *s;  
-
-		/* pointer to read/write position in buffer */
-		unsigned readptr;          
-		unsigned writeptr;          
-
-		unsigned error; /* over/underruns cleared on sync again */
-
-		/* waiting and locking */
-		wait_queue_head_t wait;
-		struct mutex  open_mutex;
-		wait_queue_head_t open_wait;
-
-	} dma[RME96xx_MAX_DEVS]; 
-
-	int dspnum[RME96xx_MAX_DEVS];  /* register with sound subsystem */ 
-	int mixer;  /* register with sound subsystem */ 
-} rme96xx_info;
-
-
-/* fiddling with the card (first level hardware control) */
-
-static inline void rme96xx_set_ctrl(rme96xx_info* s,int mask)
-{
-
-	s->control_register|=mask;
-	writel(s->control_register,s->iobase + RME96xx_control_register);
-
-}
-
-static inline void rme96xx_unset_ctrl(rme96xx_info* s,int mask)
-{
-
-	s->control_register&=(~mask);
-	writel(s->control_register,s->iobase + RME96xx_control_register);
-
-}
-
-static inline int rme96xx_get_sample_rate_status(rme96xx_info* s)
-{
-	int val;
-	u32 status;
-	status = readl(s->iobase + RME96xx_status_register);
-	val = (status & RME96xx_fs48) ? 48000 : 44100;
-	if (status & RME96xx_DS_rd)
-		val *= 2;
-	return val;
-}
-
-static inline int rme96xx_get_sample_rate_ctrl(rme96xx_info* s)
-{
-	int val;
-	val = (s->control_register & RME96xx_freq) ? 48000 : 44100;
-	if (s->control_register & RME96xx_DS)
-		val *= 2;
-	return val;
-}
-
-
-/* code from ALSA card-rme9652.c for rev 1.5 SPDIF receiver   HP 20020201 */
-
-static void rme96xx_spdif_set_bit (rme96xx_info* s, int mask, int onoff)
-{
-	if (onoff) 
-		s->control_register |= mask;
-	else 
-		s->control_register &= ~mask;
-		
-	writel(s->control_register,s->iobase + RME96xx_control_register);
-}
-
-static void rme96xx_spdif_write_byte (rme96xx_info* s, const int val)
-{
-	long mask;
-	long i;
-
-	for (i = 0, mask = 0x80; i < 8; i++, mask >>= 1) {
-		if (val & mask)
-			rme96xx_spdif_set_bit (s, RME96xx_SPDIF_WRITE, 1);
-		else 
-			rme96xx_spdif_set_bit (s, RME96xx_SPDIF_WRITE, 0);
-
-		rme96xx_spdif_set_bit (s, RME96xx_SPDIF_CLOCK, 1);
-		rme96xx_spdif_set_bit (s, RME96xx_SPDIF_CLOCK, 0);
-	}
-}
-
-static int rme96xx_spdif_read_byte (rme96xx_info* s)
-{
-	long mask;
-	long val;
-	long i;
-
-	val = 0;
-
-	for (i = 0, mask = 0x80;  i < 8; i++, mask >>= 1) {
-		rme96xx_spdif_set_bit (s, RME96xx_SPDIF_CLOCK, 1);
-		if (readl(s->iobase + RME96xx_status_register) & RME96xx_SPDIF_READ)
-			val |= mask;
-		rme96xx_spdif_set_bit (s, RME96xx_SPDIF_CLOCK, 0);
-	}
-
-	return val;
-}
-
-static void rme96xx_write_spdif_codec (rme96xx_info* s, const int address, const int data)
-{
-	rme96xx_spdif_set_bit (s, RME96xx_SPDIF_SELECT, 1);
-	rme96xx_spdif_write_byte (s, 0x20);
-	rme96xx_spdif_write_byte (s, address);
-	rme96xx_spdif_write_byte (s, data);
-	rme96xx_spdif_set_bit (s, RME96xx_SPDIF_SELECT, 0);
-}
-
-
-static int rme96xx_spdif_read_codec (rme96xx_info* s, const int address)
-{
-	int ret;
-
-	rme96xx_spdif_set_bit (s, RME96xx_SPDIF_SELECT, 1);
-	rme96xx_spdif_write_byte (s, 0x20);
-	rme96xx_spdif_write_byte (s, address);
-	rme96xx_spdif_set_bit (s, RME96xx_SPDIF_SELECT, 0);
-	rme96xx_spdif_set_bit (s, RME96xx_SPDIF_SELECT, 1);
-
-	rme96xx_spdif_write_byte (s, 0x21);
-	ret = rme96xx_spdif_read_byte (s);
-	rme96xx_spdif_set_bit (s, RME96xx_SPDIF_SELECT, 0);
-
-	return ret;
-}
-
-static void rme96xx_initialize_spdif_receiver (rme96xx_info* s)
-{
-	/* XXX what unsets this ? */
-	/* no idea ???   HP 20020201 */
-
-	s->control_register |= RME96xx_SPDIF_RESET;
-
-	rme96xx_write_spdif_codec (s, 4, 0x40);
-	rme96xx_write_spdif_codec (s, 17, 0x13);
-	rme96xx_write_spdif_codec (s, 6, 0x02);
-}
-
-static inline int rme96xx_spdif_sample_rate (rme96xx_info *s, int *spdifrate)
-{
-	unsigned int rate_bits;
-
-	*spdifrate = 0x1;
-	if (readl(s->iobase + RME96xx_status_register) & RME96xx_ERF) {
-		return -1;	/* error condition */
-	}
-	
-	if (s->hw_rev == 15) {
-
-		int x, y, ret;
-		
-		x = rme96xx_spdif_read_codec (s, 30);
-
-		if (x != 0) 
-			y = 48000 * 64 / x;
-		else
-			y = 0;
-
-		if      (y > 30400 && y < 33600)  {ret = 32000; *spdifrate = 0x7;}
-		else if (y > 41900 && y < 46000)  {ret = 44100; *spdifrate = 0x6;}
-		else if (y > 46000 && y < 50400)  {ret = 48000; *spdifrate = 0x5;}
-		else if (y > 60800 && y < 67200)  {ret = 64000; *spdifrate = 0x0;}
-		else if (y > 83700 && y < 92000)  {ret = 88200; *spdifrate = 0x4;}
-		else if (y > 92000 && y < 100000) {ret = 96000; *spdifrate = 0x3;}
-		else                              {ret = 0; *spdifrate = 0x1;}
-		return ret;
-	}
-
-	rate_bits = readl(s->iobase + RME96xx_status_register) & RME96xx_F;
-
-	switch (*spdifrate = rme96xx_decode_spdif_rate(rate_bits)) {
-	case 0x7:
-		return 32000;
-		break;
-
-	case 0x6:
-		return 44100;
-		break;
-
-	case 0x5:
-		return 48000;
-		break;
-
-	case 0x4:
-		return 88200;
-		break;
-
-	case 0x3:
-		return 96000;
-		break;
-
-	case 0x0:
-		return 64000;
-		break;
-
-	default:
-		/* was an ALSA warning ...
-		  snd_printk("%s: unknown S/PDIF input rate (bits = 0x%x)\n",
-		  s->card_name, rate_bits);
-		*/
-		return 0;
-		break;
-	}
-}
-
-/* end of code from ALSA card-rme9652.c */
-
-
-
-/* the hwbuf in the status register seems to have some jitter, to get rid of
-   it, we first only let the numbers grow, to be on the secure side we 
-   subtract a certain amount RME96xx_BURSTBYTES from the resulting number */
-
-/* the function returns the hardware pointer in bytes */
-#define RME96xx_BURSTBYTES -64  /* bytes by which hwptr could be off */
-
-static inline int rme96xx_gethwptr(rme96xx_info* s,int exact)
-{
-	unsigned long flags;
-	if (exact) {
-		unsigned int hwp;
-/* the hwptr seems to be rather unreliable :(, so we don't use it */
-		spin_lock_irqsave(&s->lock,flags);
-		
-		hwp  = readl(s->iobase + RME96xx_status_register) & 0xffc0;
-		s->hwptr = (hwp < s->hwptr) ? s->hwptr : hwp;
-//		s->hwptr = hwp;
-
-		spin_unlock_irqrestore(&s->lock,flags);
-		return (s->hwptr+RME96xx_BURSTBYTES) & ((s->fragsize<<1)-1);
-	}
-	return (s->hwbufid ? s->fragsize : 0);
-}
-
-static inline void rme96xx_setlatency(rme96xx_info* s,int l)
-{
-	s->latency = l;
-	s->fragsize = 1<<(8+l);
-	rme96xx_unset_ctrl(s,RME96xx_latency);
-	rme96xx_set_ctrl(s,RME96xx_SET_LATENCY(l));	
-}
-
-
-static void rme96xx_clearbufs(struct dmabuf* dma)
-{
-	int i,j;
-	unsigned long flags;
-
-	/* clear dmabufs */
-	for(i=0;i<devices;i++) {
-		for (j=0;j<dma->outchannels + dma->mono;j++)
-			memset(&dma->s->playbuf[(dma->outoffset + j)*RME96xx_DMA_MAX_SAMPLES], 
-			       0, RME96xx_DMA_MAX_SIZE);
-	}
-	spin_lock_irqsave(&dma->s->lock,flags);
-	dma->writeptr = 0;
-	dma->readptr = 0;
-	spin_unlock_irqrestore(&dma->s->lock,flags);
-}
-
-static int rme96xx_startcard(rme96xx_info *s,int stop)
-{
-	int i;
-	unsigned long flags;
-
-	COMM       ("startcard");
-	if(s->control_register & RME96xx_IE){
-		/* disable interrupt first */
-		
-		rme96xx_unset_ctrl( s,RME96xx_start_bit );
-		udelay(10);
-		rme96xx_unset_ctrl( s,RME96xx_IE);
-		spin_lock_irqsave(&s->lock,flags); /* timing is critical */
-		s->started = 0;
-		spin_unlock_irqrestore(&s->lock,flags);
-		if (stop) {
-		     COMM("Sound card stopped");
-		     return 1;
-		}
-	}
-	COMM       ("interrupt disabled");
-	/* first initialize all pointers on card */
-	for(i=0;i<RME96xx_num_of_init_regs;i++){
-		writel(0,s->iobase + i);
-		udelay(10); /* ?? */
-	}
-	COMM       ("regs cleaned");
-
-	spin_lock_irqsave(&s->lock,flags); /* timing is critical */
-	udelay(10);
-	s->started = 1;
-	s->hwptr = 0;
-	spin_unlock_irqrestore(&s->lock,flags);
-
-	rme96xx_set_ctrl( s, RME96xx_IE | RME96xx_start_bit);
-
-
-	COMM("Sound card started");
-  
-	return 1;
-}
-
-
-static inline int rme96xx_getospace(struct dmabuf * dma, unsigned int hwp)
-{
-	int cnt;
-	int  swptr;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dma->s->lock,flags); 
-	swptr = dma->writeptr;
-	cnt = (hwp - swptr);
-	
-	if (cnt < 0) {
-	     cnt = ((dma->s->fragsize<<1) - swptr);
-	}
-	spin_unlock_irqrestore(&dma->s->lock,flags);
-	return cnt;
-}
-
-static inline int rme96xx_getispace(struct dmabuf * dma, unsigned int hwp)
-{
-	int cnt;
-	int  swptr;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dma->s->lock,flags); 
-	swptr = dma->readptr;
-	cnt = (hwp - swptr);
-	 
-	if (cnt < 0) {
-		cnt = ((dma->s->fragsize<<1) - swptr);
-	}
-	spin_unlock_irqrestore(&dma->s->lock,flags);
-	return cnt;
-}
-
-
-static inline int rme96xx_copyfromuser(struct dmabuf* dma,const char __user * buffer,int count,int hop)
-{
-	int swptr = dma->writeptr;
-	switch (dma->format) {
-	case AFMT_S32_BLOCKED:
-	{
-	     char __user * buf = (char __user *)buffer;
-	     int cnt = count/dma->outchannels;
-	     int i;
-	     for (i=0;i < dma->outchannels;i++) {
-		  char* hwbuf =(char*) &dma->s->playbuf[(dma->outoffset + i)*RME96xx_DMA_MAX_SAMPLES];
-		  hwbuf+=swptr;
-
-		  if (copy_from_user(hwbuf,buf, cnt))
-		       return -1;
-		  buf+=hop;
-	     }
-	     swptr+=cnt;
-	     break;
-	}
-	case AFMT_S16_LE:
-	{
-	     int i,j;
-	     int cnt = count/dma->outchannels;
-	     for (i=0;i < dma->outchannels + dma->mono;i++) {
-		     short __user * sbuf = (short __user *)buffer + i*(!dma->mono);
-		     short* hwbuf =(short*) &dma->s->playbuf[(dma->outoffset + i)*RME96xx_DMA_MAX_SAMPLES];	     
-		     hwbuf+=(swptr>>1);
-		     for (j=0;j<(cnt>>1);j++) {
-			     hwbuf++; /* skip the low 16 bits */
-			     __get_user(*hwbuf++,sbuf++);
-			     sbuf+=(dma->outchannels-1);
-		     }
-	     }
-	     swptr += (cnt<<1);
-	     break;
-	}
-	default:
-	     printk(RME_MESS" unsupported format\n");
-	     return -1;
-	} /* switch */
-
-	swptr&=((dma->s->fragsize<<1) -1);
-	dma->writeptr = swptr;
-
-	return 0;
-}
-
-/* The count argument is the number of bytes */
-static inline int rme96xx_copytouser(struct dmabuf* dma,const char __user* buffer,int count,int hop)
-{
-	int swptr = dma->readptr;
-	switch (dma->format) {
-	case AFMT_S32_BLOCKED:
-	{
-	     char __user * buf = (char __user *)buffer;
-	     int cnt = count/dma->inchannels;
-	     int i;
-
-	     for (i=0;i < dma->inchannels;i++) {
-		  char* hwbuf =(char*) &dma->s->recbuf[(dma->inoffset + i)*RME96xx_DMA_MAX_SAMPLES];
-		  hwbuf+=swptr;
-
-		  if (copy_to_user(buf,hwbuf,cnt))
-		       return -1;
-		  buf+=hop;
-	     }
-	     swptr+=cnt;
-	     break;
-	}
-	case AFMT_S16_LE:
-	{
-	     int i,j;
-	     int cnt = count/dma->inchannels;
-	     for (i=0;i < dma->inchannels;i++) {
-		  short __user * sbuf = (short __user *)buffer + i;
-		  short* hwbuf =(short*) &dma->s->recbuf[(dma->inoffset + i)*RME96xx_DMA_MAX_SAMPLES];	     
-		  hwbuf+=(swptr>>1);
-		  for (j=0;j<(cnt>>1);j++) {
-		       hwbuf++;
-		       __put_user(*hwbuf++,sbuf++);
-		       sbuf+=(dma->inchannels-1);
-		  }
-	     }
-	     swptr += (cnt<<1);
-	     break;
-	}
-	default:
-	     printk(RME_MESS" unsupported format\n");
-	     return -1;
-	} /* switch */
-	
-	swptr&=((dma->s->fragsize<<1) -1);	
-	dma->readptr = swptr;
-	return 0;
-}
-
-
-static irqreturn_t rme96xx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	int i;
-	rme96xx_info *s = (rme96xx_info *)dev_id;
-	struct dmabuf *db;
-	u32 status;
-	unsigned long flags;
-
-	status = readl(s->iobase + RME96xx_status_register);
-	if (!(status & RME96xx_IRQ)) {
-		return IRQ_NONE;
-	}
-
-	spin_lock_irqsave(&s->lock,flags);
-	writel(0,s->iobase + RME96xx_irq_clear);
-
-	s->hwbufid = (status & RME96xx_buffer_id)>>26;	
-	if ((status & 0xffc0) <= 256) s->hwptr = 0; 
-	for(i=0;i<devices;i++)
-	{
-		db = &(s->dma[i]);
-		if(db->started > 0)
-			wake_up(&(db->wait));		
-	}  
-	spin_unlock_irqrestore(&s->lock,flags);
-	return IRQ_HANDLED;
-}
-
-
-
-/*---------------------------------------------------------------------------- 
- PCI detection and module initialization stuff 
- ----------------------------------------------------------------------------*/
-
-static void* busmaster_malloc(int size) {
-     int pg; /* 2 s exponent of memory size */
-        char *buf;
-
-        DBG(printk("kernel malloc pages ..\n"));
-        
-        for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
-
-        buf = (char *) __get_free_pages(GFP_KERNEL | GFP_DMA, pg);
-
-        if (buf) {
-                struct page* page, *last_page;
-
-                page = virt_to_page(buf);
-                last_page = page + (1 << pg);
-                DBG(printk("setting reserved bit\n"));
-                while (page < last_page) {
-			SetPageReserved(page);
-                        page++;
-                }
-		return buf;
-        }
-	DBG(printk("allocated %ld",(long)buf));
-	return NULL;
-}
-
-static void busmaster_free(void* ptr,int size) {
-        int pg;
-	struct page* page, *last_page;
-
-        if (ptr == NULL)
-                return;
-
-        for (pg = 0; PAGE_SIZE * (1 << pg) < size; pg++);
-
-        page = virt_to_page(ptr);
-        last_page = page + (1 << pg);
-        while (page < last_page) {
-		ClearPageReserved(page);
-		page++;
-	}
-	DBG(printk("freeing pages\n"));
-        free_pages((unsigned long) ptr, pg);
-	DBG(printk("done\n"));
-}
-
-/* initialize those parts of the info structure which are not pci detectable resources */
-
-static int rme96xx_dmabuf_init(rme96xx_info * s,struct dmabuf* dma,int ioffset,int ooffset) {
-
-	mutex_init(&dma->open_mutex);
-	init_waitqueue_head(&dma->open_wait);
-	init_waitqueue_head(&dma->wait);
-	dma->s = s; 
-	dma->error = 0;
-
-	dma->format = AFMT_S32_BLOCKED;
-	dma->formatshift = 0;
-	dma->inchannels = dma->outchannels = 1;
-	dma->inoffset = ioffset;
-	dma->outoffset = ooffset;
-
-	dma->opened=0;
-	dma->started=0;
-	dma->mmapped=0;
-	dma->open_mode=0;
-	dma->mono=0;
-
-	rme96xx_clearbufs(dma);
-	return 0;
-}
-
-
-static int rme96xx_init(rme96xx_info* s)
-{
-	int i;
-	int status;
-	unsigned short rev;
-
-	DBG(printk("%s\n", __FUNCTION__));
-	numcards++;
-
-	s->magic = RME96xx_MAGIC; 
-
-	spin_lock_init(&s->lock);
-
-	COMM            ("setup busmaster memory")
-	s->recbuf = busmaster_malloc(RME96xx_DMA_MAX_SIZE_ALL);
-	s->playbuf = busmaster_malloc(RME96xx_DMA_MAX_SIZE_ALL);
-
-	if (!s->recbuf || !s->playbuf) {
-		printk(KERN_ERR RME_MESS" Unable to allocate busmaster memory\n");
-		return -ENODEV;
-	}
-
-	COMM            ("setting rec and playbuffers")
-
-	writel((u32) virt_to_bus(s->recbuf),s->iobase + RME96xx_rec_buffer);
-  	writel((u32) virt_to_bus(s->playbuf),s->iobase + RME96xx_play_buffer);
-
-	COMM             ("initializing control register")
-	rme96xx_unset_ctrl(s,0xffffffff);
-	rme96xx_set_ctrl(s,RME96xx_ctrl_init);
-
-
-	COMM              ("setup devices")	
-	for (i=0;i < devices;i++) {
-		struct dmabuf * dma = &s->dma[i];
-		rme96xx_dmabuf_init(s,dma,2*i,2*i);
-	}
-
-	/* code from ALSA card-rme9652.c   HP 20020201 */
-        /* Determine the h/w rev level of the card. This seems like
-	   a particularly kludgy way to encode it, but its what RME
-	   chose to do, so we follow them ...
-	*/
-
-	status = readl(s->iobase + RME96xx_status_register);
-	if (rme96xx_decode_spdif_rate(status&RME96xx_F) == 1) {
-		s->hw_rev = 15;
-	} else {
-		s->hw_rev = 11;
-	}
-
-	/* Differentiate between the standard Hammerfall, and the
-	   "Light", which does not have the expansion board. This
-	   method comes from information received from Mathhias
-	   Clausen at RME. Display the EEPROM and h/w revID where
-	   relevant.  
-	*/
-
-	pci_read_config_word(s->pcidev, PCI_CLASS_REVISION, &rev);
-	switch (rev & 0xff) {
-	case 8: /* original eprom */
-		if (s->hw_rev == 15) {
-			s->card_name = "RME Digi9636 (Rev 1.5)";
-		} else {
-			s->card_name = "RME Digi9636";
-		}
-		break;
-	case 9: /* W36_G EPROM */
-		s->card_name = "RME Digi9636 (Rev G)";
-		break;
-	case 4: /* W52_G EPROM */
-		s->card_name = "RME Digi9652 (Rev G)";
-		break;
-	default:
-	case 3: /* original eprom */
-		if (s->hw_rev == 15) {
-			s->card_name = "RME Digi9652 (Rev 1.5)";
-		} else {
-			s->card_name = "RME Digi9652";
-		}
-		break;
-	}
-
-	printk(KERN_INFO RME_MESS" detected %s (hw_rev %d)\n",s->card_name,s->hw_rev); 
-
-	if (s->hw_rev == 15)
-		rme96xx_initialize_spdif_receiver (s);
-
-	s->started = 0;
-	rme96xx_setlatency(s,7);
-
-	printk(KERN_INFO RME_MESS" card %d initialized\n",numcards); 
-	return 0;
-}
-
-
-/* open uses this to figure out which device was opened .. this seems to be 
-   unnecessary complex */
-
-static LIST_HEAD(devs);
-
-static int __devinit rme96xx_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
-{
-	int i;
-	rme96xx_info *s;
-
-	DBG(printk("%s\n", __FUNCTION__));
-	
-	if (pcidev->irq == 0) 
-		return -1;
-	if (!pci_dma_supported(pcidev, 0xffffffff)) {
-		printk(KERN_WARNING RME_MESS" architecture does not support 32bit PCI busmaster DMA\n");
-		return -1;
-	}
-	if (!(s = kmalloc(sizeof(rme96xx_info), GFP_KERNEL))) {
-		printk(KERN_WARNING RME_MESS" out of memory\n");
-		return -1;
-	}
-	memset(s, 0, sizeof(rme96xx_info));
-
-	s->pcidev = pcidev;
-	s->iobase = ioremap(pci_resource_start(pcidev, 0),RME96xx_IO_EXTENT);
-	s->irq = pcidev->irq;
-
-        DBG(printk("remapped iobase: %lx irq %d\n",(long)s->iobase,s->irq));
-
-	if (pci_enable_device(pcidev))
-		goto err_irq;
-	if (request_irq(s->irq, rme96xx_interrupt, IRQF_SHARED, "rme96xx", s)) {
-		printk(KERN_ERR RME_MESS" irq %u in use\n", s->irq);
-		goto err_irq;
-	}
-	
-	/* initialize the card */
-
-	i = 0;
-	if (rme96xx_init(s) < 0) {
-		printk(KERN_ERR RME_MESS" initialization failed\n");
-		goto err_devices;
-	}
-	for (i=0;i<devices;i++) {
-		if ((s->dspnum[i] = register_sound_dsp(&rme96xx_audio_fops, -1)) < 0)
-			goto err_devices;
-	}
-
-	if ((s->mixer = register_sound_mixer(&rme96xx_mixer_fops, -1)) < 0)
-		goto err_devices;
-
-	pci_set_drvdata(pcidev, s);
-	pcidev->dma_mask = 0xffffffff; /* ????? */
-	/* put it into driver list */
-	list_add_tail(&s->devs, &devs);
-
-	DBG(printk("initialization successful\n"));
-	return 0;
-
-	/* error handler */
- err_devices:
-	while (i--) 
-		unregister_sound_dsp(s->dspnum[i]);
-	free_irq(s->irq,s);
- err_irq:
-	kfree(s);
-	return -1;
-}
-
-
-static void __devexit rme96xx_remove(struct pci_dev *dev)
-{
-	int i;
-	rme96xx_info *s = pci_get_drvdata(dev);
-
-	if (!s) {
-		printk(KERN_ERR"device structure not valid\n");
-		return ;
-	}
-
-	if (s->started) rme96xx_startcard(s,0);
-
-	i = devices;
-	while (i) {
-		i--;
-		unregister_sound_dsp(s->dspnum[i]);
-	}
-	
-	unregister_sound_mixer(s->mixer);
-	synchronize_irq(s->irq);
-	free_irq(s->irq,s);
-	busmaster_free(s->recbuf,RME96xx_DMA_MAX_SIZE_ALL);
-	busmaster_free(s->playbuf,RME96xx_DMA_MAX_SIZE_ALL);
-	kfree(s);
-	pci_set_drvdata(dev, NULL);
-}
-
-
-#ifndef PCI_VENDOR_ID_RME 
-#define PCI_VENDOR_ID_RME 0x10ee
-#endif
-#ifndef PCI_DEVICE_ID_RME9652
-#define PCI_DEVICE_ID_RME9652 0x3fc4
-#endif
-#ifndef PCI_ANY_ID
-#define PCI_ANY_ID 0
-#endif
-
-static struct pci_device_id id_table[] = {
-	{
-		.vendor	   = PCI_VENDOR_ID_RME,
-		.device	   = PCI_DEVICE_ID_RME9652,
-		.subvendor = PCI_ANY_ID,
-		.subdevice = PCI_ANY_ID,
-	},
-	{ 0, },
-};
-
-MODULE_DEVICE_TABLE(pci, id_table);
-
-static struct pci_driver rme96xx_driver = {
-	.name	  =  "rme96xx",
-	.id_table = id_table,
-	.probe	  = rme96xx_probe,
-	.remove	  = __devexit_p(rme96xx_remove),
-};
-
-static int __init init_rme96xx(void)
-{
-	printk(KERN_INFO RME_MESS" version "RMEVERSION" time " __TIME__ " " __DATE__ "\n");
-	devices = ((devices-1) & RME96xx_MASK_DEVS) + 1;
-	printk(KERN_INFO RME_MESS" reserving %d dsp device(s)\n",devices);
-        numcards = 0;
-	return pci_register_driver(&rme96xx_driver);
-}
-
-static void __exit cleanup_rme96xx(void)
-{
-	printk(KERN_INFO RME_MESS" unloading\n");
-	pci_unregister_driver(&rme96xx_driver);
-}
-
-module_init(init_rme96xx);
-module_exit(cleanup_rme96xx);
-
-
-
-
-
-/*-------------------------------------------------------------------------- 
-   Implementation of file operations 
----------------------------------------------------------------------------*/
-
-#define RME96xx_FMT (AFMT_S16_LE|AFMT_U8|AFMT_S32_BLOCKED)
-/* AFTM_U8 is not (yet?) supported ...  HP20020201 */
-
-static int rme96xx_ioctl(struct inode *in, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct dmabuf * dma = (struct dmabuf *)file->private_data; 
-	rme96xx_info *s = dma->s;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int count;
-	int val = 0;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_STATE(s);
-
-	DBG(printk("ioctl %ud\n",cmd));
-
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-#if 0
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac2(s, 0/*file->f_flags & O_NONBLOCK*/);
-#endif
-		return 0;
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-		
-        case SNDCTL_DSP_RESET:
-//		rme96xx_clearbufs(dma);
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-/* generally it's not a problem if we change the speed 
-			if (dma->open_mode & (~file->f_mode) & (FMODE_READ|FMODE_WRITE))
-				return -EINVAL;
-*/
-			spin_lock_irqsave(&s->lock, flags);
-
-			switch (val) {
-			case 44100:
-			case 88200:
-				rme96xx_unset_ctrl(s,RME96xx_freq);
-				break;
-			case 48000: 
-			case 96000: 
-				rme96xx_set_ctrl(s,RME96xx_freq);
-				break;
-			/* just report current rate as default
-			   e.g. use 0 to "select" current digital input rate
-			default:
-				rme96xx_unset_ctrl(s,RME96xx_freq);
-				val = 44100;
-			*/
-			}
-			if (val > 50000)
-				rme96xx_set_ctrl(s,RME96xx_DS);
-			else
-				rme96xx_unset_ctrl(s,RME96xx_DS);
-			/* set val to actual value  HP 20020201 */
-			/* NOTE: if not "Sync Master", reported rate might be not yet "updated" ... but I don't want to insert a long udelay() here */
-			if ((s->control_register & RME96xx_Master) && !(s->control_register & RME96xx_wsel))
-				val = rme96xx_get_sample_rate_ctrl(s);
-			else
-				val = rme96xx_get_sample_rate_status(s);
-			s->rate = val;
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		DBG(printk("speed set to %d\n",val));
-		return put_user(val, p);
-		
-        case SNDCTL_DSP_STEREO: /* this plays a mono file on two channels */
-                if (get_user(val, p))
-			return -EFAULT;
-		
-		if (!val) {
-			DBG(printk("setting to mono\n")); 
-			dma->mono=1; 
-			dma->inchannels = 1;
-			dma->outchannels = 1;
-		}
-		else {
-			DBG(printk("setting to stereo\n")); 
-			dma->mono = 0;
-			dma->inchannels = 2;
-			dma->outchannels = 2;
-		}
-		return 0;
-        case SNDCTL_DSP_CHANNELS:
-		/* remember to check for resonable offset/channel pairs here */
-                if (get_user(val, p))
-			return -EFAULT;
-
-		if (file->f_mode & FMODE_WRITE) { 			
-			if (val > 0 && (dma->outoffset + val) <= RME96xx_CHANNELS_PER_CARD) 
-				dma->outchannels = val;
-			else
-				dma->outchannels = val = 2;
-			DBG(printk("setting to outchannels %d\n",val)); 
-		}
-		if (file->f_mode & FMODE_READ) {
-			if (val > 0 && (dma->inoffset + val) <= RME96xx_CHANNELS_PER_CARD) 
-				dma->inchannels = val;
-			else
-				dma->inchannels = val = 2;
-			DBG(printk("setting to inchannels %d\n",val)); 
-		}
-
-		dma->mono=0;
-
-		return put_user(val, p);
-		
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(RME96xx_FMT, p);
-		
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		DBG(printk("setting to format %x\n",val)); 
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			if (val & RME96xx_FMT)
-				dma->format = val;
-			switch (dma->format) {
-			case AFMT_S16_LE:
-				dma->formatshift=1;
-				break;
-			case AFMT_S32_BLOCKED:
-				dma->formatshift=0;
-				break;
-			}
-		}
-		return put_user(dma->format, p);
-		
-	case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-#if 0
-		if (file->f_mode & FMODE_READ && s->ctrl & CTRL_ADC_EN) 
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && s->ctrl & CTRL_DAC2_EN) 
-			val |= PCM_ENABLE_OUTPUT;
-#endif
-		return put_user(val, p);
-		
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-#if 0
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))
-					return ret;
-				start_adc(s);
-			} else
-				stop_adc(s);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac2.ready && (ret = prog_dmabuf_dac2(s)))
-					return ret;
-				start_dac2(s);
-			} else
-				stop_dac2(s);
-		}
-#endif
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-
-		val = rme96xx_gethwptr(dma->s,0);
-
-
-		count = rme96xx_getospace(dma,val);
-		if (!s->started) count = s->fragsize*2;
-		abinfo.fragsize =(s->fragsize*dma->outchannels)>>dma->formatshift;
-                abinfo.bytes = (count*dma->outchannels)>>dma->formatshift;
-                abinfo.fragstotal = 2;
-                abinfo.fragments = (count > s->fragsize); 
-
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-
-		val = rme96xx_gethwptr(dma->s,0);
-
-		count = rme96xx_getispace(dma,val);
-
-		abinfo.fragsize = (s->fragsize*dma->inchannels)>>dma->formatshift;
-                abinfo.bytes = (count*dma->inchannels)>>dma->formatshift;
-                abinfo.fragstotal = 2;
-                abinfo.fragments = count > s->fragsize; 
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-		
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY: /* What should this exactly do ? ,
-				      ATM it is just abinfo.bytes */
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-
-		val = rme96xx_gethwptr(dma->s,0);
-		count = val - dma->readptr;
-		if (count < 0)
-			count += s->fragsize<<1;
-
-		return put_user(count, p);
-
-
-/* check out how to use mmaped mode (can only be blocked !!!) */
-        case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		val = rme96xx_gethwptr(dma->s,0);
-		spin_lock_irqsave(&s->lock,flags);
-                cinfo.bytes = s->fragsize<<1;
-		count = val - dma->readptr;
-		if (count < 0)
-			count += s->fragsize<<1;
-
-                cinfo.blocks = (count > s->fragsize); 
-                cinfo.ptr = val;
-		if (dma->mmapped)
-			dma->readptr &= s->fragsize<<1;
-		spin_unlock_irqrestore(&s->lock,flags);
-
-                if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		val = rme96xx_gethwptr(dma->s,0);
-		spin_lock_irqsave(&s->lock,flags);
-                cinfo.bytes = s->fragsize<<1;
-		count = val - dma->writeptr;
-		if (count < 0)
-			count += s->fragsize<<1;
-
-                cinfo.blocks = (count > s->fragsize); 
-                cinfo.ptr = val;
-		if (dma->mmapped)
-			dma->writeptr &= s->fragsize<<1;
-		spin_unlock_irqrestore(&s->lock,flags);
-                if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-        case SNDCTL_DSP_GETBLKSIZE:
-	     return put_user(s->fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-                if (get_user(val, p))
-			return -EFAULT;
-		val&=0xffff;
-		val -= 7;
-		if (val < 0) val = 0;
-		if (val > 7) val = 7;
-		rme96xx_setlatency(s,val);
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-#if 0
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac2.subdivision))
-			return -EINVAL;
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		if (file->f_mode & FMODE_WRITE)
-			s->dma_dac2.subdivision = val;
-#endif		
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		/* HP20020201 */
-		s->rate = rme96xx_get_sample_rate_status(s);
-		return put_user(s->rate, p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user(dma->outchannels, p);
-
-        case SOUND_PCM_READ_BITS:
-		switch (dma->format) {
-			case AFMT_S32_BLOCKED:
-				val = 32;
-				break;
-			case AFMT_S16_LE:
-				val = 16;
-				break;
-		}
-		return put_user(val, p);
-
-        case SOUND_PCM_WRITE_FILTER:
-        case SNDCTL_DSP_SETSYNCRO:
-        case SOUND_PCM_READ_FILTER:
-                return -EINVAL;
-		
-	}
-
-
-	return -ENODEV;
-}
-
-
-
-static int rme96xx_open(struct inode *in, struct file *f)
-{
-	int minor = iminor(in);
-	struct list_head *list;
-	int devnum;
-	rme96xx_info *s;
-	struct dmabuf* dma;
-	DECLARE_WAITQUEUE(wait, current); 
-
-	DBG(printk("device num %d open\n",devnum));
-
-	nonseekable_open(in, f);
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, rme96xx_info, devs);
-		for (devnum=0; devnum<devices; devnum++)
-			if (!((s->dspnum[devnum] ^ minor) & ~0xf)) 
-				break;
-		if (devnum<devices)
-			break;
-	}
-       	VALIDATE_STATE(s);
-
-	dma = &s->dma[devnum];
-	f->private_data = dma;
-	/* wait for device to become free */
-	mutex_lock(&dma->open_mutex);
-	while (dma->open_mode & f->f_mode) {
-		if (f->f_flags & O_NONBLOCK) {
-			mutex_unlock(&dma->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&dma->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&dma->open_mutex);
-		schedule();
-		remove_wait_queue(&dma->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&dma->open_mutex);
-	}
-
-	COMM                ("hardware open")
-
-	if (!dma->opened) rme96xx_dmabuf_init(dma->s,dma,dma->inoffset,dma->outoffset);
-
-	dma->open_mode |= (f->f_mode & (FMODE_READ | FMODE_WRITE));
-	dma->opened = 1;
-	mutex_unlock(&dma->open_mutex);
-
-	DBG(printk("device num %d open finished\n",devnum));
-	return 0;
-}
-
-static int rme96xx_release(struct inode *in, struct file *file)
-{
-	struct dmabuf * dma = (struct dmabuf*) file->private_data;
-	/* int hwp;  ... was unused   HP20020201 */
-	DBG(printk("%s\n", __FUNCTION__));
-
-	COMM          ("draining")
-	if (dma->open_mode & FMODE_WRITE) {
-#if 0 /* Why doesn't this work with some cards ?? */
-	     hwp = rme96xx_gethwptr(dma->s,0);
-	     while (rme96xx_getospace(dma,hwp)) {
-		  interruptible_sleep_on(&(dma->wait));
-		  hwp = rme96xx_gethwptr(dma->s,0);
-	     }
-#endif
-	     rme96xx_clearbufs(dma);
-	}
-
-	dma->open_mode &= (~file->f_mode) & (FMODE_READ|FMODE_WRITE);
-
-	if (!(dma->open_mode & (FMODE_READ|FMODE_WRITE))) {
-	     dma->opened = 0;
-	     if (dma->s->started) rme96xx_startcard(dma->s,1);
-	}
-
-	wake_up(&dma->open_wait);
-	mutex_unlock(&dma->open_mutex);
-
-	return 0;
-}
-
-
-static ssize_t rme96xx_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct dmabuf *dma = (struct dmabuf *)file->private_data;
-	ssize_t ret = 0;
-	int cnt; /* number of bytes from "buffer" that will/can be used */
-	int hop = count/dma->outchannels;
-	int hwp;
-	int exact = (file->f_flags & O_NONBLOCK); 
-
-
-	if(dma == NULL || (dma->s) == NULL) 
-		return -ENXIO;
-
-	if (dma->mmapped || !dma->opened)
-		return -ENXIO;
-
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-
-	if (! (dma->open_mode  & FMODE_WRITE))
-                return -ENXIO;
-
-	if (!dma->s->started) rme96xx_startcard(dma->s,exact);
-	hwp = rme96xx_gethwptr(dma->s,0);
-
-	if(!(dma->started)){		 
-		COMM          ("first write")
-			
-		dma->readptr = hwp;
-		dma->writeptr = hwp;
-		dma->started = 1;
-	}
-
-  	while (count > 0) {
-		cnt = rme96xx_getospace(dma,hwp);		
-		cnt>>=dma->formatshift;
-		cnt*=dma->outchannels;
-		if (cnt > count)
-			cnt = count;
-
-		if (cnt != 0) {
-		        if (rme96xx_copyfromuser(dma,buffer,cnt,hop))
-				return ret ? ret : -EFAULT;
-			count -= cnt;
-			buffer += cnt;
-			ret += cnt;
-			if (count == 0) return ret;
-		}
-		if (file->f_flags & O_NONBLOCK)
-			return ret ? ret : -EAGAIN;
-		
-		if ((hwp - dma->writeptr) <= 0) {
-			interruptible_sleep_on(&(dma->wait));
-			
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
-		}			
-
-		hwp = rme96xx_gethwptr(dma->s,exact);
-
-	}; /* count > 0 */
-
-	return ret;
-}
-
-static ssize_t rme96xx_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{ 
-	struct dmabuf *dma = (struct dmabuf *)file->private_data;
-	ssize_t ret = 0;
-	int cnt; /* number of bytes from "buffer" that will/can be used */
-	int hop = count/dma->inchannels;
-	int hwp;
-	int exact = (file->f_flags & O_NONBLOCK); 
-
-
-	if(dma == NULL || (dma->s) == NULL) 
-		return -ENXIO;
-
-	if (dma->mmapped || !dma->opened)
-		return -ENXIO;
-
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-
-	if (! (dma->open_mode  & FMODE_READ))
-                return -ENXIO;
-
-	if (!dma->s->started) rme96xx_startcard(dma->s,exact);
-	hwp = rme96xx_gethwptr(dma->s,0);
-
-	if(!(dma->started)){		 
-		COMM          ("first read")
-		     
-		dma->writeptr = hwp;
-		dma->readptr = hwp;
-		dma->started = 1;
-	}
-
-  	while (count > 0) {
-		cnt = rme96xx_getispace(dma,hwp);		
-		cnt>>=dma->formatshift;
-		cnt*=dma->inchannels;
-
-		if (cnt > count)
-			cnt = count;
-
-		if (cnt != 0) {
-		        
-			if (rme96xx_copytouser(dma,buffer,cnt,hop))
-				return ret ? ret : -EFAULT;
-			
-			count -= cnt;
-			buffer += cnt;
-			ret += cnt;
-			if (count == 0) return ret;
-		}
-		if (file->f_flags & O_NONBLOCK)
-			return ret ? ret : -EAGAIN;
-		
-		if ((hwp - dma->readptr) <= 0) {
-			interruptible_sleep_on(&(dma->wait));
-			
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
-		}			
-		hwp = rme96xx_gethwptr(dma->s,exact);
-
-	}; /* count > 0 */
-
-	return ret;
-}
-
-static int rm96xx_mmap(struct file *file, struct vm_area_struct *vma) {
-	struct dmabuf *dma = (struct dmabuf *)file->private_data;
-	rme96xx_info* s = dma->s;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-
-	if (vma->vm_pgoff != 0) {
-		unlock_kernel();
-		return -EINVAL;
-	}
-	size = vma->vm_end - vma->vm_start;
-	if (size > RME96xx_DMA_MAX_SIZE) {
-		unlock_kernel();
-		return -EINVAL;
-	}
-
-
-	if (vma->vm_flags & VM_WRITE) {
-		if (!s->started) rme96xx_startcard(s,1);
-
-		if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(s->playbuf + dma->outoffset*RME96xx_DMA_MAX_SIZE) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
-			unlock_kernel();
-			return -EAGAIN;
-		}
-	} 
-	else if (vma->vm_flags & VM_READ) {
-		if (!s->started) rme96xx_startcard(s,1);
-		if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(s->playbuf + dma->inoffset*RME96xx_DMA_MAX_SIZE) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
-			unlock_kernel();
-			return -EAGAIN;
-		}
-	} else  {
-		unlock_kernel();
-		return -EINVAL;
-	}
-
-
-/* this is the mapping */
-	vma->vm_flags &= ~VM_IO;
-	dma->mmapped = 1;
-	unlock_kernel();
-	return 0;
-}
-
-static unsigned int rme96xx_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct dmabuf *dma = (struct dmabuf *)file->private_data;
-	rme96xx_info* s = dma->s;
-	unsigned int mask = 0;
-	unsigned int hwp,cnt;
-
-        DBG(printk("rme96xx poll_wait ...\n"));
-	VALIDATE_STATE(s);
-
-	if (!s->started) {
-		  mask |= POLLOUT | POLLWRNORM;
-	}
-	poll_wait(file, &dma->wait, wait);
-
-	hwp = rme96xx_gethwptr(dma->s,0);
-
-        DBG(printk("rme96xx poll: ..cnt %d > %d\n",cnt,s->fragsize));	
-
-	cnt = rme96xx_getispace(dma,hwp);
-
-	if (file->f_mode & FMODE_READ) 
-	     if (cnt > 0)
-		  mask |= POLLIN | POLLRDNORM;
-
-
-
-	cnt = rme96xx_getospace(dma,hwp);
-
-	if (file->f_mode & FMODE_WRITE) 
-	     if (cnt > 0)
-		  mask |= POLLOUT | POLLWRNORM;
-
-
-//        printk("rme96xx poll_wait ...%d > %d\n",rme96xx_getospace(dma,hwp),rme96xx_getispace(dma,hwp));
-
-	return mask;
-}
-
-
-static struct file_operations rme96xx_audio_fops = {
-	.owner	 = THIS_MODULE,
-	.read	 = rme96xx_read,
-	.write	 = rme96xx_write,
-	.poll	 = rme96xx_poll,
-	.ioctl	 = rme96xx_ioctl,  
-	.mmap	 = rm96xx_mmap,
-	.open	 = rme96xx_open,  
-	.release = rme96xx_release 
-};
-
-static int rme96xx_mixer_open(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	struct list_head *list;
-	rme96xx_info *s;
-
-	COMM  ("mixer open");
-
-	nonseekable_open(inode, file);
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, rme96xx_info, devs);
-		if (s->mixer== minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-
-	COMM                       ("mixer opened")
-	return 0;
-}
-
-static int rme96xx_mixer_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	rme96xx_info *s = (rme96xx_info *)file->private_data;
-	u32 status;
-	int spdifrate;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	status = readl(s->iobase + RME96xx_status_register);
-	/* hack to convert rev 1.5 SPDIF rate to "crystalrate" format   HP 20020201 */
-	rme96xx_spdif_sample_rate(s,&spdifrate);
-	status = (status & ~RME96xx_F) | ((spdifrate<<22) & RME96xx_F);
-
-	VALIDATE_STATE(s);
-	if (cmd == SOUND_MIXER_PRIVATE1) {
-		rme_mixer mixer;
-		if (copy_from_user(&mixer,argp,sizeof(mixer)))
-			return -EFAULT;
-		
-		mixer.devnr &= RME96xx_MASK_DEVS;
-		if (mixer.devnr >= devices)
-			mixer.devnr = devices-1;
-		if (file->f_mode & FMODE_WRITE && !s->dma[mixer.devnr].opened) {
-			/* modify only if device not open */
-			if (mixer.o_offset < 0)
-				mixer.o_offset = 0;
-			if (mixer.o_offset >= RME96xx_CHANNELS_PER_CARD)
-				mixer.o_offset = RME96xx_CHANNELS_PER_CARD-1;
-			if (mixer.i_offset < 0)
-				mixer.i_offset = 0;
-			if (mixer.i_offset >= RME96xx_CHANNELS_PER_CARD)
-				mixer.i_offset = RME96xx_CHANNELS_PER_CARD-1;
-			s->dma[mixer.devnr].outoffset = mixer.o_offset;
-			s->dma[mixer.devnr].inoffset = mixer.i_offset;
-		}
-
-		mixer.o_offset = s->dma[mixer.devnr].outoffset;
-		mixer.i_offset = s->dma[mixer.devnr].inoffset;
-
-		return copy_to_user(argp, &mixer, sizeof(mixer)) ? -EFAULT : 0;
-	}
-	if (cmd == SOUND_MIXER_PRIVATE2) {
-		return put_user(status, p);
-	}
-	if (cmd == SOUND_MIXER_PRIVATE3) {
-		u32 control;
-		if (copy_from_user(&control,argp,sizeof(control)))
-			return -EFAULT;
-		if (file->f_mode & FMODE_WRITE) {
-			s->control_register &= ~RME96xx_mixer_allowed;
-			s->control_register |= control & RME96xx_mixer_allowed;
-			writel(control,s->iobase + RME96xx_control_register);
-		}
-
-	     return put_user(s->control_register, p);
-	}
-	return -1;
-}
-
-
-
-static int rme96xx_mixer_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static /*const*/ struct file_operations rme96xx_mixer_fops = {
-	.owner	 = THIS_MODULE,
-	.ioctl	 = rme96xx_mixer_ioctl,
-	.open	 = rme96xx_mixer_open,
-	.release = rme96xx_mixer_release,
-};
--- linux-2.6.18.noarch/sound/oss/cs46xxpm-24.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs46xxpm-24.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,48 +0,0 @@
-/*******************************************************************************
-*
-*      "cs46xxpm-24.h" --  Cirrus Logic-Crystal CS46XX linux audio driver.
-*
-*      Copyright (C) 2000,2001  Cirrus Logic Corp.  
-*            -- tom woller (twoller@crystal.cirrus.com) or
-*               (pcaudio@crystal.cirrus.com).
-*
-*      This program is free software; you can redistribute it and/or modify
-*      it under the terms of the GNU General Public License as published by
-*      the Free Software Foundation; either version 2 of the License, or
-*      (at your option) any later version.
-*
-*      This program is distributed in the hope that it will be useful,
-*      but WITHOUT ANY WARRANTY; without even the implied warranty of
-*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*      GNU General Public License for more details.
-*
-*      You should have received a copy of the GNU General Public License
-*      along with this program; if not, write to the Free Software
-*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-* 12/22/00 trw - new file. 
-*
-*******************************************************************************/
-#ifndef __CS46XXPM24_H
-#define __CS46XXPM24_H
-
-#include <linux/pm.h>
-#include "cs46xxpm.h"
-
-
-#define CS46XX_ACPI_SUPPORT 1
-#ifdef CS46XX_ACPI_SUPPORT
-/* 
-* for now (12/22/00) only enable the pm_register PM support.
-* allow these table entries to be null.
-*/
-static int cs46xx_suspend_tbl(struct pci_dev *pcidev, pm_message_t state);
-static int cs46xx_resume_tbl(struct pci_dev *pcidev);
-#define CS46XX_SUSPEND_TBL cs46xx_suspend_tbl
-#define CS46XX_RESUME_TBL cs46xx_resume_tbl
-#else
-#define CS46XX_SUSPEND_TBL cs46xx_null
-#define CS46XX_RESUME_TBL cs46xx_null
-#endif
-
-#endif
--- linux-2.6.18.noarch/sound/oss/ite8172.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ite8172.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2261 +0,0 @@
-/*
- *      ite8172.c  --  ITE IT8172G Sound Driver.
- *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	stevel@mvista.com or source@mvista.com
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
- * Module command line parameters:
- *
- *  Supported devices:
- *  /dev/dsp    standard OSS /dev/dsp device
- *  /dev/mixer  standard OSS /dev/mixer device
- *
- * Notes:
- *
- *  1. Much of the OSS buffer allocation, ioctl's, and mmap'ing are
- *     taken, slightly modified or not at all, from the ES1371 driver,
- *     so refer to the credits in es1371.c for those. The rest of the
- *     code (probe, open, read, write, the ISR, etc.) is new.
- *  2. The following support is untested:
- *      * Memory mapping the audio buffers, and the ioctl controls that go
- *        with it.
- *      * S/PDIF output.
- *      * I2S support.
- *  3. The following is not supported:
- *      * legacy audio mode.
- *  4. Support for volume button interrupts is implemented but doesn't
- *     work yet.
- *
- *  Revision history
- *    02.08.2001  Initial release
- *    06.22.2001  Added I2S support
- *    07.30.2003  Removed initialisation to zero for static variables
- *		   (spdif[NR_DEVICE], i2s_fmt[NR_DEVICE], and devindex)
- */
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/bitops.h>
-#include <linux/proc_fs.h>
-#include <linux/spinlock.h>
-#include <linux/smp_lock.h>
-#include <linux/ac97_codec.h>
-#include <linux/interrupt.h>
-#include <linux/mutex.h>
-
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <asm/uaccess.h>
-#include <asm/it8172/it8172.h>
-
-/* --------------------------------------------------------------------- */
-
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-#define IT8172_DEBUG
-#undef IT8172_VERBOSE_DEBUG
-#define DBG(x) {}
-
-#define IT8172_MODULE_NAME "IT8172 audio"
-#define PFX IT8172_MODULE_NAME
-
-#ifdef IT8172_DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG PFX ": " format "\n" , ## arg)
-#else
-#define dbg(format, arg...) do {} while (0)
-#endif
-#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
-#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
-
-
-#define IT8172_MODULE_NAME "IT8172 audio"
-#define PFX IT8172_MODULE_NAME
-
-#ifdef IT8172_DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG PFX ": " format "\n" , ## arg)
-#else
-#define dbg(format, arg...) do {} while (0)
-#endif
-#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
-#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
-
-
-static const unsigned sample_shift[] = { 0, 1, 1, 2 };
-
-
-/*
- * Audio Controller register bit definitions follow. See
- * include/asm/it8172/it8172.h for register offsets.
- */
-
-/* PCM Out Volume Reg */
-#define PCMOV_PCMOM	(1<<15)	/* PCM Out Mute default 1: mute */
-#define	PCMOV_PCMRCG_BIT 8	/* PCM Right channel Gain */
-#define	PCMOV_PCMRCG_MASK (0x1f<<PCMOV_PCMRCG_BIT)
-#define PCMOV_PCMLCG_BIT 0	/* PCM Left channel gain  */
-#define PCMOV_PCMLCG_MASK 0x1f
-
-/* FM Out Volume Reg */
-#define FMOV_FMOM       (1<<15)	/* FM Out Mute default 1: mute */
-#define	FMOV_FMRCG_BIT	8	/* FM Right channel Gain */
-#define	FMOV_FMRCG_MASK (0x1f<<FMOV_FMRCG_BIT)
-#define FMOV_FMLCG_BIT	0	/* FM Left channel gain  */
-#define FMOV_FMLCG_MASK 0x1f
-
-/* I2S Out Volume Reg */
-#define I2SV_I2SOM	 (1<<15) /* I2S Out Mute default 1: mute */
-#define	I2SV_I2SRCG_BIT	 8	 /* I2S Right channel Gain */
-#define	I2SV_I2SRCG_MASK (0x1f<<I2SV_I2SRCG_BIT)
-#define I2SV_I2SLCG_BIT	 0	 /* I2S Left channel gain  */
-#define I2SV_I2SLCG_MASK 0x1f
-
-/* Digital Recording Source Select Reg */
-#define	DRSS_BIT   0
-#define	DRSS_MASK  0x07
-#define   DRSS_AC97_PRIM 0
-#define   DRSS_FM        1
-#define   DRSS_I2S       2
-#define   DRSS_PCM       3
-#define   DRSS_AC97_SEC  4
-
-/* Playback/Capture Channel Control Registers */
-#define	CC_SM	        (1<<15)	/* Stereo, Mone 0: mono 1: stereo */
-#define	CC_DF	        (1<<14)	/* Data Format 0: 8 bit 1: 16 bit */
-#define CC_FMT_BIT      14
-#define CC_FMT_MASK     (0x03<<CC_FMT_BIT)
-#define CC_CF_BIT       12      /* Channel format (Playback only) */
-#define CC_CF_MASK      (0x03<<CC_CF_BIT)
-#define	  CC_CF_2	0
-#define   CC_CF_4	(1<<CC_CF_BIT)
-#define   CC_CF_6	(2<<CC_CF_BIT)
-#define CC_SR_BIT       8       /* sample Rate */
-#define CC_SR_MASK      (0x0f<<CC_SR_BIT)
-#define	  CC_SR_5500	0
-#define	  CC_SR_8000	(1<<CC_SR_BIT)
-#define	  CC_SR_9600	(2<<CC_SR_BIT)
-#define	  CC_SR_11025	(3<<CC_SR_BIT)
-#define	  CC_SR_16000	(4<<CC_SR_BIT)
-#define	  CC_SR_19200	(5<<CC_SR_BIT)
-#define	  CC_SR_22050	(6<<CC_SR_BIT)
-#define	  CC_SR_32000	(7<<CC_SR_BIT)
-#define	  CC_SR_38400	(8<<CC_SR_BIT)
-#define	  CC_SR_44100	(9<<CC_SR_BIT)
-#define	  CC_SR_48000	(10<<CC_SR_BIT)
-#define	CC_CSP	        (1<<7)	/* Channel stop 
-				 * 0: End of Current buffer
-				 * 1: Immediately stop when rec stop */
-#define CC_CP	        (1<<6)	/* Channel pause 0: normal, 1: pause */
-#define	CC_CA	        (1<<5)	/* Channel Action 0: Stop , 1: start */
-#define	CC_CB2L         (1<<2)	/* Cur. buf. 2 xfr is last 0: No, 1: Yes */
-#define CC_CB1L         (1<<1)	/* Cur. buf. 1 xfr is last 0: No, 1: Yes */
-#define CC_DE	        1	/* DFC/DFIFO Data Empty 1: empty, 0: not empty
-				 * (Playback only)
-				 */
-
-/* Codec Control Reg */
-#define CODECC_GME	(1<<9)	/* AC97 GPIO Mode enable */
-#define	CODECC_ATM	(1<<8)	/* AC97 ATE test mode 0: test 1: normal */
-#define	CODECC_WR	(1<<6)	/* AC97 Warn reset 1: warm reset , 0: Normal */
-#define	CODECC_CR	(1<<5)	/* AC97 Cold reset 1: Cold reset , 0: Normal */
-
-
-/* I2S Control Reg	*/
-#define	I2SMC_SR_BIT	 6	/* I2S Sampling rate 
-				 * 00: 48KHz, 01: 44.1 KHz, 10: 32 32 KHz */
-#define	I2SMC_SR_MASK    (0x03<<I2SMC_SR_BIT)
-#define	  I2SMC_SR_48000 0
-#define	  I2SMC_SR_44100 (1<<I2SMC_SR_BIT)
-#define	  I2SMC_SR_32000 (2<<I2SMC_SR_BIT)
-#define	I2SMC_SRSS	 (1<<5)	/* Sample Rate Source Select 1:S/W, 0: H/W */
-#define I2SMC_I2SF_BIT	 0	/* I2S Format */
-#define I2SMC_I2SF_MASK  0x03
-#define   I2SMC_I2SF_DAC 0
-#define   I2SMC_I2SF_ADC 2
-#define   I2SMC_I2SF_I2S 3
-
-
-/* Volume up, Down, Mute */
-#define	VS_VMP	(1<<2)	/* Volume mute 1: pushed, 0: not */
-#define	VS_VDP	(1<<1)	/* Volume Down 1: pushed, 0: not */
-#define VS_VUP	1	/* Volime Up 1: pushed, 0: not */
-
-/* SRC, Mixer test control/DFC status reg */
-#define SRCS_DPUSC      (1<<5)	/* DFC Playback underrun Status/clear */
-#define	SRCS_DCOSC	(1<<4)	/* DFC Capture Overrun Status/clear */
-#define SRCS_SIS	(1<<3)	/* SRC input select 1: Mixer, 0: Codec I/F */
-#define SRCS_CDIS_BIT	0	/* Codec Data Input Select */
-#define SRCS_CDIS_MASK  0x07
-#define   SRCS_CDIS_MIXER 0
-#define   SRCS_CDIS_PCM   1
-#define   SRCS_CDIS_I2S   2
-#define   SRCS_CDIS_FM    3
-#define   SRCS_CDIS_DFC   4
-
-
-/* Codec Index Reg command Port */
-#define CIRCP_CID_BIT   10
-#define CIRCP_CID_MASK  (0x03<<CIRCP_CID_BIT)
-#define CIRCP_CPS	(1<<9)	/* Command Port Status 0: ready, 1: busy */
-#define	CIRCP_DPVF	(1<<8)	/* Data Port Valid Flag 0: invalis, 1: valid */
-#define CIRCP_RWC	(1<<7)	/* Read/write command */
-#define CIRCP_CIA_BIT   0
-#define CIRCP_CIA_MASK  0x007F	/* Codec Index Address */
-
-/* Test Mode Control/Test group Select Control */
-
-/* General Control Reg */
-#define GC_VDC_BIT	6	/* Volume Division Control */
-#define GC_VDC_MASK     (0x03<<GC_VDC_BIT)
-#define   GC_VDC_NONE   0
-#define   GC_VDC_DIV2   (1<<GC_VDC_BIT)
-#define   GC_VDC_DIV4   (2<<GC_VDC_BIT)
-#define	GC_SOE	        (1<<2)	/* S/PDIF Output enable */
-#define	GC_SWR	        1	/* Software warn reset */
-
-/* Interrupt mask Control Reg */
-#define	IMC_VCIM	(1<<6)	/* Volume CNTL interrupt mask */
-#define	IMC_CCIM	(1<<1)	/* Capture Chan. iterrupt mask */
-#define	IMC_PCIM	1	/* Playback Chan. interrupt mask */
-
-/* Interrupt status/clear reg */
-#define	ISC_VCI	        (1<<6)	/* Volume CNTL interrupt 1: clears */
-#define	ISC_CCI	        (1<<1)	/* Capture Chan. interrupt 1: clears  */
-#define	ISC_PCI	        1	/* Playback Chan. interrupt 1: clears */
-
-/* misc stuff */
-#define POLL_COUNT   0x5000
-
-
-/* --------------------------------------------------------------------- */
-
-/*
- * Define DIGITAL1 as the I2S channel, since it is not listed in
- * soundcard.h.
- */
-#define SOUND_MIXER_I2S        SOUND_MIXER_DIGITAL1
-#define SOUND_MASK_I2S         SOUND_MASK_DIGITAL1
-#define SOUND_MIXER_READ_I2S   MIXER_READ(SOUND_MIXER_I2S)
-#define SOUND_MIXER_WRITE_I2S  MIXER_WRITE(SOUND_MIXER_I2S)
-
-/* --------------------------------------------------------------------- */
-
-struct it8172_state {
-	/* list of it8172 devices */
-	struct list_head devs;
-
-	/* the corresponding pci_dev structure */
-	struct pci_dev *dev;
-
-	/* soundcore stuff */
-	int dev_audio;
-
-	/* hardware resources */
-	unsigned long io;
-	unsigned int irq;
-
-	/* PCI ID's */
-	u16 vendor;
-	u16 device;
-	u8 rev; /* the chip revision */
-
-	/* options */
-	int spdif_volume; /* S/PDIF output is enabled if != -1 */
-	int i2s_volume;   /* current I2S out volume, in OSS format */
-	int i2s_recording;/* 1 = recording from I2S, 0 = not */
-    
-#ifdef IT8172_DEBUG
-	/* debug /proc entry */
-	struct proc_dir_entry *ps;
-	struct proc_dir_entry *ac97_ps;
-#endif /* IT8172_DEBUG */
-
-	struct ac97_codec codec;
-
-	unsigned short pcc, capcc;
-	unsigned dacrate, adcrate;
-
-	spinlock_t lock;
-	struct mutex open_mutex;
-	mode_t open_mode;
-	wait_queue_head_t open_wait;
-
-	struct dmabuf {
-		void *rawbuf;
-		dma_addr_t dmaaddr;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-		void* nextIn;
-		void* nextOut;
-		int count;
-		int curBufPtr;
-		unsigned total_bytes;
-		unsigned error; /* over/underrun */
-		wait_queue_head_t wait;
-		/* redundant, but makes calculations easier */
-		unsigned fragsize;
-		unsigned dmasize;
-		unsigned fragsamples;
-		/* OSS stuff */
-		unsigned mapped:1;
-		unsigned ready:1;
-		unsigned stopped:1;
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-	} dma_dac, dma_adc;
-};
-
-/* --------------------------------------------------------------------- */
-
-static LIST_HEAD(devs);
-
-/* --------------------------------------------------------------------- */
-
-static inline unsigned ld2(unsigned int x)
-{
-	unsigned r = 0;
-	
-	if (x >= 0x10000) {
-		x >>= 16;
-		r += 16;
-	}
-	if (x >= 0x100) {
-		x >>= 8;
-		r += 8;
-	}
-	if (x >= 0x10) {
-		x >>= 4;
-		r += 4;
-	}
-	if (x >= 4) {
-		x >>= 2;
-		r += 2;
-	}
-	if (x >= 2)
-		r++;
-	return r;
-}
-
-/* --------------------------------------------------------------------- */
-
-static void it8172_delay(int msec)
-{
-	unsigned long tmo;
-	signed long tmo2;
-
-	if (in_interrupt())
-		return;
-    
-	tmo = jiffies + (msec*HZ)/1000;
-	for (;;) {
-		tmo2 = tmo - jiffies;
-		if (tmo2 <= 0)
-			break;
-		schedule_timeout(tmo2);
-	}
-}
-
-
-static unsigned short
-get_compat_rate(unsigned* rate)
-{
-	unsigned rate_out = *rate;
-	unsigned short sr;
-    
-	if (rate_out >= 46050) {
-		sr = CC_SR_48000; rate_out = 48000;
-	} else if (rate_out >= 41250) {
-		sr = CC_SR_44100; rate_out = 44100;
-	} else if (rate_out >= 35200) {
-		sr = CC_SR_38400; rate_out = 38400;
-	} else if (rate_out >= 27025) {
-		sr = CC_SR_32000; rate_out = 32000;
-	} else if (rate_out >= 20625) {
-		sr = CC_SR_22050; rate_out = 22050;
-	} else if (rate_out >= 17600) {
-		sr = CC_SR_19200; rate_out = 19200;
-	} else if (rate_out >= 13513) {
-		sr = CC_SR_16000; rate_out = 16000;
-	} else if (rate_out >= 10313) {
-		sr = CC_SR_11025; rate_out = 11025;
-	} else if (rate_out >= 8800) {
-		sr = CC_SR_9600; rate_out = 9600;
-	} else if (rate_out >= 6750) {
-		sr = CC_SR_8000; rate_out = 8000;
-	} else {
-		sr = CC_SR_5500; rate_out = 5500;
-	}
-
-	*rate = rate_out;
-	return sr;
-}
-
-static void set_adc_rate(struct it8172_state *s, unsigned rate)
-{
-	unsigned long flags;
-	unsigned short sr;
-    
-	sr = get_compat_rate(&rate);
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->capcc &= ~CC_SR_MASK;
-	s->capcc |= sr;
-	outw(s->capcc, s->io+IT_AC_CAPCC);
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	s->adcrate = rate;
-}
-
-
-static void set_dac_rate(struct it8172_state *s, unsigned rate)
-{
-	unsigned long flags;
-	unsigned short sr;
-    
-	sr = get_compat_rate(&rate);
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->pcc &= ~CC_SR_MASK;
-	s->pcc |= sr;
-	outw(s->pcc, s->io+IT_AC_PCC);
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	s->dacrate = rate;
-}
-
-
-/* --------------------------------------------------------------------- */
-
-static u16 rdcodec(struct ac97_codec *codec, u8 addr)
-{
-	struct it8172_state *s = (struct it8172_state *)codec->private_data;
-	unsigned long flags;
-	unsigned short circp, data;
-	int i;
-    
-	spin_lock_irqsave(&s->lock, flags);
-
-	for (i = 0; i < POLL_COUNT; i++)
-		if (!(inw(s->io+IT_AC_CIRCP) & CIRCP_CPS))
-			break;
-	if (i == POLL_COUNT)
-		err("rdcodec: codec ready poll expired!");
-
-	circp = addr & CIRCP_CIA_MASK;
-	circp |= (codec->id << CIRCP_CID_BIT);
-	circp |= CIRCP_RWC; // read command
-	outw(circp, s->io+IT_AC_CIRCP);
-
-	/* now wait for the data */
-	for (i = 0; i < POLL_COUNT; i++)
-		if (inw(s->io+IT_AC_CIRCP) & CIRCP_DPVF)
-			break;
-	if (i == POLL_COUNT)
-		err("rdcodec: read poll expired!");
-
-	data = inw(s->io+IT_AC_CIRDP);
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	return data;
-}
-
-
-static void wrcodec(struct ac97_codec *codec, u8 addr, u16 data)
-{
-	struct it8172_state *s = (struct it8172_state *)codec->private_data;
-	unsigned long flags;
-	unsigned short circp;
-	int i;
-    
-	spin_lock_irqsave(&s->lock, flags);
-
-	for (i = 0; i < POLL_COUNT; i++)
-		if (!(inw(s->io+IT_AC_CIRCP) & CIRCP_CPS))
-			break;
-	if (i == POLL_COUNT)
-		err("wrcodec: codec ready poll expired!");
-
-	circp = addr & CIRCP_CIA_MASK;
-	circp |= (codec->id << CIRCP_CID_BIT);
-	circp &= ~CIRCP_RWC; // write command
-
-	outw(data,  s->io+IT_AC_CIRDP);  // send data first
-	outw(circp, s->io+IT_AC_CIRCP);
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-
-static void waitcodec(struct ac97_codec *codec)
-{
-	unsigned short temp;
-
-	/* codec_wait is used to wait for a ready state after
-	   an AC97_RESET. */
-	it8172_delay(10);
-
-	temp = rdcodec(codec, 0x26);
-
-	// If power down, power up
-	if (temp & 0x3f00) {
-		// Power on
-		wrcodec(codec, 0x26, 0);
-		it8172_delay(100);
-		// Reread
-		temp = rdcodec(codec, 0x26);
-	}
-    
-	// Check if Codec REF,ANL,DAC,ADC ready***/
-	if ((temp & 0x3f0f) != 0x000f) {
-		err("codec reg 26 status (0x%x) not ready!!", temp);
-		return;
-	}
-}
-
-
-/* --------------------------------------------------------------------- */
-
-static inline void stop_adc(struct it8172_state *s)
-{
-	struct dmabuf* db = &s->dma_adc;
-	unsigned long flags;
-	unsigned char imc;
-    
-	if (db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	s->capcc &= ~(CC_CA | CC_CP | CC_CB2L | CC_CB1L);
-	s->capcc |= CC_CSP;
-	outw(s->capcc, s->io+IT_AC_CAPCC);
-    
-	// disable capture interrupt
-	imc = inb(s->io+IT_AC_IMC);
-	outb(imc | IMC_CCIM, s->io+IT_AC_IMC);
-
-	db->stopped = 1;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static inline void stop_dac(struct it8172_state *s)
-{
-	struct dmabuf* db = &s->dma_dac;
-	unsigned long flags;
-	unsigned char imc;
-    
-	if (db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	s->pcc &= ~(CC_CA | CC_CP | CC_CB2L | CC_CB1L);
-	s->pcc |= CC_CSP;
-	outw(s->pcc, s->io+IT_AC_PCC);
-    
-	// disable playback interrupt
-	imc = inb(s->io+IT_AC_IMC);
-	outb(imc | IMC_PCIM, s->io+IT_AC_IMC);
-
-	db->stopped = 1;
-    
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_dac(struct it8172_state *s)
-{
-	struct dmabuf* db = &s->dma_dac;
-	unsigned long flags;
-	unsigned char imc;
-	unsigned long buf1, buf2;
-    
-	if (!db->stopped)
-		return;
-    
-	spin_lock_irqsave(&s->lock, flags);
-
-	// reset Buffer 1 and 2 pointers to nextOut and nextOut+fragsize
-	buf1 = virt_to_bus(db->nextOut);
-	buf2 = buf1 + db->fragsize;
-	if (buf2 >= db->dmaaddr + db->dmasize)
-		buf2 -= db->dmasize;
-    
-	outl(buf1, s->io+IT_AC_PCB1STA);
-	outl(buf2, s->io+IT_AC_PCB2STA);
-	db->curBufPtr = IT_AC_PCB1STA;
-    
-	// enable playback interrupt
-	imc = inb(s->io+IT_AC_IMC);
-	outb(imc & ~IMC_PCIM, s->io+IT_AC_IMC);
-
-	s->pcc &= ~(CC_CSP | CC_CP | CC_CB2L | CC_CB1L);
-	s->pcc |= CC_CA;
-	outw(s->pcc, s->io+IT_AC_PCC);
-    
-	db->stopped = 0;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_adc(struct it8172_state *s)
-{
-	struct dmabuf* db = &s->dma_adc;
-	unsigned long flags;
-	unsigned char imc;
-	unsigned long buf1, buf2;
-    
-	if (!db->stopped)
-		return;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	// reset Buffer 1 and 2 pointers to nextIn and nextIn+fragsize
-	buf1 = virt_to_bus(db->nextIn);
-	buf2 = buf1 + db->fragsize;
-	if (buf2 >= db->dmaaddr + db->dmasize)
-		buf2 -= db->dmasize;
-    
-	outl(buf1, s->io+IT_AC_CAPB1STA);
-	outl(buf2, s->io+IT_AC_CAPB2STA);
-	db->curBufPtr = IT_AC_CAPB1STA;
-
-	// enable capture interrupt
-	imc = inb(s->io+IT_AC_IMC);
-	outb(imc & ~IMC_CCIM, s->io+IT_AC_IMC);
-
-	s->capcc &= ~(CC_CSP | CC_CP | CC_CB2L | CC_CB1L);
-	s->capcc |= CC_CA;
-	outw(s->capcc, s->io+IT_AC_CAPCC);
-    
-	db->stopped = 0;
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-/* --------------------------------------------------------------------- */
-
-#define DMABUF_DEFAULTORDER (17-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-static inline void dealloc_dmabuf(struct it8172_state *s, struct dmabuf *db)
-{
-	struct page *page, *pend;
-
-	if (db->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(db->rawbuf +
-				    (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			ClearPageReserved(page);
-		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder,
-				    db->rawbuf, db->dmaaddr);
-	}
-	db->rawbuf = db->nextIn = db->nextOut = NULL;
-	db->mapped = db->ready = 0;
-}
-
-static int prog_dmabuf(struct it8172_state *s, struct dmabuf *db,
-		       unsigned rate, unsigned fmt, unsigned reg)
-{
-	int order;
-	unsigned bytepersec;
-	unsigned bufs;
-	struct page *page, *pend;
-
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-		for (order = DMABUF_DEFAULTORDER;
-		     order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf =
-			     pci_alloc_consistent(s->dev,
-						  PAGE_SIZE << order,
-						  &db->dmaaddr)))
-				break;
-		if (!db->rawbuf)
-			return -ENOMEM;
-		db->buforder = order;
-		/* now mark the pages as reserved;
-		   otherwise remap_pfn_range doesn't do what we want */
-		pend = virt_to_page(db->rawbuf +
-				    (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			SetPageReserved(page);
-	}
-
-	db->count = 0;
-	db->nextIn = db->nextOut = db->rawbuf;
-    
-	bytepersec = rate << sample_shift[fmt];
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < bytepersec)
-			db->fragshift = ld2(bytepersec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(bytepersec/100/(db->subdivision ?
-						    db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3;
-	}
-	db->numfrag = bufs >> db->fragshift;
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->numfrag = bufs >> db->fragshift;
-	}
-	db->fragsize = 1 << db->fragshift;
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
-	db->fragsamples = db->fragsize >> sample_shift[fmt];
-	db->dmasize = db->numfrag << db->fragshift;
-	memset(db->rawbuf, (fmt & (CC_DF>>CC_FMT_BIT)) ? 0 : 0x80, bufs);
-    
-#ifdef IT8172_VERBOSE_DEBUG
-	dbg("rate=%d, fragsize=%d, numfrag=%d, dmasize=%d",
-	    rate, db->fragsize, db->numfrag, db->dmasize);
-#endif
-
-	// set data length register
-	outw(db->fragsize, s->io+reg+2);
-	db->ready = 1;
-
-	return 0;
-}
-
-static inline int prog_dmabuf_adc(struct it8172_state *s)
-{
-	stop_adc(s);
-	return prog_dmabuf(s, &s->dma_adc, s->adcrate,
-			   (s->capcc & CC_FMT_MASK) >> CC_FMT_BIT,
-			   IT_AC_CAPCC);
-}
-
-static inline int prog_dmabuf_dac(struct it8172_state *s)
-{
-	stop_dac(s);
-	return prog_dmabuf(s, &s->dma_dac, s->dacrate,
-			   (s->pcc & CC_FMT_MASK) >> CC_FMT_BIT,
-			   IT_AC_PCC);
-}
-
-
-/* hold spinlock for the following! */
-
-static irqreturn_t it8172_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct it8172_state *s = (struct it8172_state *)dev_id;
-	struct dmabuf* dac = &s->dma_dac;
-	struct dmabuf* adc = &s->dma_adc;
-	unsigned char isc, vs;
-	unsigned short vol, mute;
-	unsigned long newptr;
-    
-	spin_lock(&s->lock);
-
-	isc = inb(s->io+IT_AC_ISC);
-
-	/* fastpath out, to ease interrupt sharing */
-	if (!(isc & (ISC_VCI | ISC_CCI | ISC_PCI))) {
-		spin_unlock(&s->lock);
-		return IRQ_NONE;
-	}
-    
-	/* clear audio interrupts first */
-	outb(isc | ISC_VCI | ISC_CCI | ISC_PCI, s->io+IT_AC_ISC);
-    
-	/* handle volume button events (ignore if S/PDIF enabled) */
-	if ((isc & ISC_VCI) && s->spdif_volume == -1) {
-		vs = inb(s->io+IT_AC_VS);
-		outb(0, s->io+IT_AC_VS);
-		vol = inw(s->io+IT_AC_PCMOV);
-		mute = vol & PCMOV_PCMOM;
-		vol &= PCMOV_PCMLCG_MASK;
-		if ((vs & VS_VUP) && vol > 0)
-			vol--;
-		if ((vs & VS_VDP) && vol < 0x1f)
-			vol++;
-		vol |= (vol << PCMOV_PCMRCG_BIT);
-		if (vs & VS_VMP)
-			vol |= (mute ^ PCMOV_PCMOM);
-		outw(vol, s->io+IT_AC_PCMOV);
-	}
-    
-	/* update capture pointers */
-	if (isc & ISC_CCI) {
-		if (adc->count > adc->dmasize - adc->fragsize) {
-			// Overrun. Stop ADC and log the error
-			stop_adc(s);
-			adc->error++;
-			dbg("adc overrun");
-		} else {
-			newptr = virt_to_bus(adc->nextIn) + 2*adc->fragsize;
-			if (newptr >= adc->dmaaddr + adc->dmasize)
-				newptr -= adc->dmasize;
-	    
-			outl(newptr, s->io+adc->curBufPtr);
-			adc->curBufPtr = (adc->curBufPtr == IT_AC_CAPB1STA) ?
-				IT_AC_CAPB2STA : IT_AC_CAPB1STA;
-	    
-			adc->nextIn += adc->fragsize;
-			if (adc->nextIn >= adc->rawbuf + adc->dmasize)
-				adc->nextIn -= adc->dmasize;
-	    
-			adc->count += adc->fragsize;
-			adc->total_bytes += adc->fragsize;
-
-			/* wake up anybody listening */
-			if (waitqueue_active(&adc->wait))
-				wake_up_interruptible(&adc->wait);
-		}
-	}
-    
-	/* update playback pointers */
-	if (isc & ISC_PCI) {
-		newptr = virt_to_bus(dac->nextOut) + 2*dac->fragsize;
-		if (newptr >= dac->dmaaddr + dac->dmasize)
-			newptr -= dac->dmasize;
-	
-		outl(newptr, s->io+dac->curBufPtr);
-		dac->curBufPtr = (dac->curBufPtr == IT_AC_PCB1STA) ?
-			IT_AC_PCB2STA : IT_AC_PCB1STA;
-	
-		dac->nextOut += dac->fragsize;
-		if (dac->nextOut >= dac->rawbuf + dac->dmasize)
-			dac->nextOut -= dac->dmasize;
-	
-		dac->count -= dac->fragsize;
-		dac->total_bytes += dac->fragsize;
-
-		/* wake up anybody listening */
-		if (waitqueue_active(&dac->wait))
-			wake_up_interruptible(&dac->wait);
-	
-		if (dac->count <= 0)
-			stop_dac(s);
-	}
-    
-	spin_unlock(&s->lock);
-	return IRQ_HANDLED;
-}
-
-/* --------------------------------------------------------------------- */
-
-static int it8172_open_mixdev(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	struct list_head *list;
-	struct it8172_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct it8172_state, devs);
-		if (s->codec.dev_mixer == minor)
-			break;
-	}
-	file->private_data = s;
-	return nonseekable_open(inode, file);
-}
-
-static int it8172_release_mixdev(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-
-static u16
-cvt_ossvol(unsigned int gain)
-{
-	u16 ret;
-    
-	if (gain == 0)
-		return 0;
-    
-	if (gain > 100)
-		gain = 100;
-    
-	ret = (100 - gain + 32) / 4;
-	ret = ret > 31 ? 31 : ret;
-	return ret;
-}
-
-
-static int mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
-			unsigned long arg)
-{
-	struct it8172_state *s = (struct it8172_state *)codec->private_data;
-	unsigned int left, right;
-	unsigned long flags;
-	int val;
-	u16 vol;
-    
-	/*
-	 * When we are in S/PDIF mode, we want to disable any analog output so
-	 * we filter the master/PCM channel volume ioctls.
-	 *
-	 * Also filter I2S channel, which AC'97 knows nothing about.
-	 */
-
-	switch (cmd) {
-	case SOUND_MIXER_WRITE_VOLUME:
-		// if not in S/PDIF mode, pass to AC'97
-		if (s->spdif_volume == -1)
-			break;
-		return 0;
-	case SOUND_MIXER_WRITE_PCM:
-		// if not in S/PDIF mode, pass to AC'97
-		if (s->spdif_volume == -1)
-			break;
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		right = ((val >> 8)  & 0xff);
-		left = (val  & 0xff);
-		if (right > 100)
-			right = 100;
-		if (left > 100)
-			left = 100;
-		s->spdif_volume = (right << 8) | left;
-		vol = cvt_ossvol(left);
-		vol |= (cvt_ossvol(right) << PCMOV_PCMRCG_BIT);
-		if (vol == 0)
-			vol = PCMOV_PCMOM; // mute
-		spin_lock_irqsave(&s->lock, flags);
-		outw(vol, s->io+IT_AC_PCMOV);
-		spin_unlock_irqrestore(&s->lock, flags);
-		return put_user(s->spdif_volume, (int *)arg);
-	case SOUND_MIXER_READ_PCM:
-		// if not in S/PDIF mode, pass to AC'97
-		if (s->spdif_volume == -1)
-			break;
-		return put_user(s->spdif_volume, (int *)arg);
-	case SOUND_MIXER_WRITE_I2S:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		right = ((val >> 8)  & 0xff);
-		left = (val  & 0xff);
-		if (right > 100)
-			right = 100;
-		if (left > 100)
-			left = 100;
-		s->i2s_volume = (right << 8) | left;
-		vol = cvt_ossvol(left);
-		vol |= (cvt_ossvol(right) << I2SV_I2SRCG_BIT);
-		if (vol == 0)
-			vol = I2SV_I2SOM; // mute
-		outw(vol, s->io+IT_AC_I2SV);
-		return put_user(s->i2s_volume, (int *)arg);
-	case SOUND_MIXER_READ_I2S:
-		return put_user(s->i2s_volume, (int *)arg);
-	case SOUND_MIXER_WRITE_RECSRC:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (val & SOUND_MASK_I2S) {
-			s->i2s_recording = 1;
-			outb(DRSS_I2S, s->io+IT_AC_DRSS);
-			return 0;
-		} else {
-			s->i2s_recording = 0;
-			outb(DRSS_AC97_PRIM, s->io+IT_AC_DRSS);
-			// now let AC'97 select record source
-			break;
-		}
-	case SOUND_MIXER_READ_RECSRC:
-		if (s->i2s_recording)
-			return put_user(SOUND_MASK_I2S, (int *)arg);
-		else
-			// let AC'97 report recording source
-			break;
-	}
-
-	return codec->mixer_ioctl(codec, cmd, arg);
-}
-
-static int it8172_ioctl_mixdev(struct inode *inode, struct file *file,
-			       unsigned int cmd, unsigned long arg)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	struct ac97_codec *codec = &s->codec;
-
-	return mixdev_ioctl(codec, cmd, arg);
-}
-
-static /*const*/ struct file_operations it8172_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= it8172_ioctl_mixdev,
-	.open		= it8172_open_mixdev,
-	.release	= it8172_release_mixdev,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct it8172_state *s, int nonblock)
-{
-	unsigned long flags;
-	int count, tmo;
-	
-	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
-		return 0;
-
-	for (;;) {
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-			break;
-		//if (nonblock)
-		//return -EBUSY;
-		tmo = 1000 * count / s->dacrate;
-		tmo >>= sample_shift[(s->pcc & CC_FMT_MASK) >> CC_FMT_BIT];
-		it8172_delay(tmo);
-	}
-	if (signal_pending(current))
-		return -ERESTARTSYS;
-	return 0;
-}
-
-/* --------------------------------------------------------------------- */
-
-
-/*
- * Copy audio data to/from user buffer from/to dma buffer, taking care
- * that we wrap when reading/writing the dma buffer. Returns actual byte
- * count written to or read from the dma buffer.
- */
-static int copy_dmabuf_user(struct dmabuf *db, char* userbuf,
-			    int count, int to_user)
-{
-	char* bufptr = to_user ? db->nextOut : db->nextIn;
-	char* bufend = db->rawbuf + db->dmasize;
-	
-	if (bufptr + count > bufend) {
-		int partial = (int)(bufend - bufptr);
-		if (to_user) {
-			if (copy_to_user(userbuf, bufptr, partial))
-				return -EFAULT;
-			if (copy_to_user(userbuf + partial, db->rawbuf,
-					 count - partial))
-				return -EFAULT;
-		} else {
-			if (copy_from_user(bufptr, userbuf, partial))
-				return -EFAULT;
-			if (copy_from_user(db->rawbuf,
-					   userbuf + partial,
-					   count - partial))
-				return -EFAULT;
-		}
-	} else {
-		if (to_user) {
-			if (copy_to_user(userbuf, bufptr, count))
-				return -EFAULT;
-		} else {
-			if (copy_from_user(bufptr, userbuf, count))
-				return -EFAULT;
-		}
-	}
-	
-	return count;
-}
-
-
-static ssize_t it8172_read(struct file *file, char *buffer,
-			   size_t count, loff_t *ppos)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	struct dmabuf *db = &s->dma_adc;
-	ssize_t ret;
-	unsigned long flags;
-	int cnt, remainder, avail;
-
-	if (db->mapped)
-		return -ENXIO;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-
-	while (count > 0) {
-		// wait for samples in capture buffer
-		do {
-			spin_lock_irqsave(&s->lock, flags);
-			if (db->stopped)
-				start_adc(s);
-			avail = db->count;
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (avail <= 0) {
-				if (file->f_flags & O_NONBLOCK) {
-					if (!ret)
-						ret = -EAGAIN;
-					return ret;
-				}
-				interruptible_sleep_on(&db->wait);
-				if (signal_pending(current)) {
-					if (!ret)
-						ret = -ERESTARTSYS;
-					return ret;
-				}
-			}
-		} while (avail <= 0);
-
-		// copy from nextOut to user
-		if ((cnt = copy_dmabuf_user(db, buffer, count > avail ?
-					    avail : count, 1)) < 0) {
-			if (!ret)
-				ret = -EFAULT;
-			return ret;
-		}
-
-		spin_lock_irqsave(&s->lock, flags);
-		db->count -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		db->nextOut += cnt;
-		if (db->nextOut >= db->rawbuf + db->dmasize)
-			db->nextOut -= db->dmasize;	
-
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-	} // while (count > 0)
-
-	/*
-	 * See if the dma buffer count after this read call is
-	 * aligned on a fragsize boundary. If not, read from
-	 * buffer until we reach a boundary, and let's hope this
-	 * is just the last remainder of an audio record. If not
-	 * it means the user is not reading in fragsize chunks, in
-	 * which case it's his/her fault that there are audio gaps
-	 * in their record.
-	 */
-	spin_lock_irqsave(&s->lock, flags);
-	remainder = db->count % db->fragsize;
-	if (remainder) {
-		db->nextOut += remainder;
-		if (db->nextOut >= db->rawbuf + db->dmasize)
-			db->nextOut -= db->dmasize;
-		db->count -= remainder;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	return ret;
-}
-
-static ssize_t it8172_write(struct file *file, const char *buffer,
-			    size_t count, loff_t *ppos)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	struct dmabuf *db = &s->dma_dac;
-	ssize_t ret;
-	unsigned long flags;
-	int cnt, remainder, avail;
-
-	if (db->mapped)
-		return -ENXIO;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-    
-	while (count > 0) {
-		// wait for space in playback buffer
-		do {
-			spin_lock_irqsave(&s->lock, flags);
-			avail = db->dmasize - db->count;
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (avail <= 0) {
-				if (file->f_flags & O_NONBLOCK) {
-					if (!ret)
-						ret = -EAGAIN;
-					return ret;
-				}
-				interruptible_sleep_on(&db->wait);
-				if (signal_pending(current)) {
-					if (!ret)
-						ret = -ERESTARTSYS;
-					return ret;
-				}
-			}
-		} while (avail <= 0);
-	
-		// copy to nextIn
-		if ((cnt = copy_dmabuf_user(db, (char*)buffer,
-					    count > avail ?
-					    avail : count, 0)) < 0) {
-			if (!ret)
-				ret = -EFAULT;
-			return ret;
-		}
-
-		spin_lock_irqsave(&s->lock, flags);
-		db->count += cnt;
-		if (db->stopped)
-			start_dac(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-	
-		db->nextIn += cnt;
-		if (db->nextIn >= db->rawbuf + db->dmasize)
-			db->nextIn -= db->dmasize;
-	
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-	} // while (count > 0)
-	
-	/*
-	 * See if the dma buffer count after this write call is
-	 * aligned on a fragsize boundary. If not, fill buffer
-	 * with silence to the next boundary, and let's hope this
-	 * is just the last remainder of an audio playback. If not
-	 * it means the user is not sending us fragsize chunks, in
-	 * which case it's his/her fault that there are audio gaps
-	 * in their playback.
-	 */
-	spin_lock_irqsave(&s->lock, flags);
-	remainder = db->count % db->fragsize;
-	if (remainder) {
-		int fill_cnt = db->fragsize - remainder;
-		memset(db->nextIn, 0, fill_cnt);
-		db->nextIn += fill_cnt;
-		if (db->nextIn >= db->rawbuf + db->dmasize)
-			db->nextIn -= db->dmasize;
-		db->count += fill_cnt;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int it8172_poll(struct file *file,
-				struct poll_table_struct *wait)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac.ready)
-			return 0;
-		poll_wait(file, &s->dma_dac.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!s->dma_adc.ready)
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-	
-	spin_lock_irqsave(&s->lock, flags);
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) 
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed)s->dma_dac.dmasize >=
-			    s->dma_dac.count + (signed)s->dma_dac.fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int it8172_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	struct dmabuf *db;
-	unsigned long size;
-
-	lock_kernel();
-	if (vma->vm_flags & VM_WRITE)
-		db = &s->dma_dac;
-	else if (vma->vm_flags & VM_READ)
-		db = &s->dma_adc;
-	else {
-		unlock_kernel();
-		return -EINVAL;
-	}
-	if (vma->vm_pgoff != 0) {
-		unlock_kernel();
-		return -EINVAL;
-	}
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder)) {
-		unlock_kernel();
-		return -EINVAL;
-	}
-	if (remap_pfn_range(vma, vma->vm_start,
-			     virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-			     size, vma->vm_page_prot)) {
-		unlock_kernel();
-		return -EAGAIN;
-	}
-	db->mapped = 1;
-	unlock_kernel();
-	return 0;
-}
-
-
-#ifdef IT8172_VERBOSE_DEBUG
-static struct ioctl_str_t {
-	unsigned int cmd;
-	const char* str;
-} ioctl_str[] = {
-	{SNDCTL_DSP_RESET, "SNDCTL_DSP_RESET"},
-	{SNDCTL_DSP_SYNC, "SNDCTL_DSP_SYNC"},
-	{SNDCTL_DSP_SPEED, "SNDCTL_DSP_SPEED"},
-	{SNDCTL_DSP_STEREO, "SNDCTL_DSP_STEREO"},
-	{SNDCTL_DSP_GETBLKSIZE, "SNDCTL_DSP_GETBLKSIZE"},
-	{SNDCTL_DSP_SAMPLESIZE, "SNDCTL_DSP_SAMPLESIZE"},
-	{SNDCTL_DSP_CHANNELS, "SNDCTL_DSP_CHANNELS"},
-	{SOUND_PCM_WRITE_CHANNELS, "SOUND_PCM_WRITE_CHANNELS"},
-	{SOUND_PCM_WRITE_FILTER, "SOUND_PCM_WRITE_FILTER"},
-	{SNDCTL_DSP_POST, "SNDCTL_DSP_POST"},
-	{SNDCTL_DSP_SUBDIVIDE, "SNDCTL_DSP_SUBDIVIDE"},
-	{SNDCTL_DSP_SETFRAGMENT, "SNDCTL_DSP_SETFRAGMENT"},
-	{SNDCTL_DSP_GETFMTS, "SNDCTL_DSP_GETFMTS"},
-	{SNDCTL_DSP_SETFMT, "SNDCTL_DSP_SETFMT"},
-	{SNDCTL_DSP_GETOSPACE, "SNDCTL_DSP_GETOSPACE"},
-	{SNDCTL_DSP_GETISPACE, "SNDCTL_DSP_GETISPACE"},
-	{SNDCTL_DSP_NONBLOCK, "SNDCTL_DSP_NONBLOCK"},
-	{SNDCTL_DSP_GETCAPS, "SNDCTL_DSP_GETCAPS"},
-	{SNDCTL_DSP_GETTRIGGER, "SNDCTL_DSP_GETTRIGGER"},
-	{SNDCTL_DSP_SETTRIGGER, "SNDCTL_DSP_SETTRIGGER"},
-	{SNDCTL_DSP_GETIPTR, "SNDCTL_DSP_GETIPTR"},
-	{SNDCTL_DSP_GETOPTR, "SNDCTL_DSP_GETOPTR"},
-	{SNDCTL_DSP_MAPINBUF, "SNDCTL_DSP_MAPINBUF"},
-	{SNDCTL_DSP_MAPOUTBUF, "SNDCTL_DSP_MAPOUTBUF"},
-	{SNDCTL_DSP_SETSYNCRO, "SNDCTL_DSP_SETSYNCRO"},
-	{SNDCTL_DSP_SETDUPLEX, "SNDCTL_DSP_SETDUPLEX"},
-	{SNDCTL_DSP_GETODELAY, "SNDCTL_DSP_GETODELAY"},
-	{SNDCTL_DSP_GETCHANNELMASK, "SNDCTL_DSP_GETCHANNELMASK"},
-	{SNDCTL_DSP_BIND_CHANNEL, "SNDCTL_DSP_BIND_CHANNEL"},
-	{OSS_GETVERSION, "OSS_GETVERSION"},
-	{SOUND_PCM_READ_RATE, "SOUND_PCM_READ_RATE"},
-	{SOUND_PCM_READ_CHANNELS, "SOUND_PCM_READ_CHANNELS"},
-	{SOUND_PCM_READ_BITS, "SOUND_PCM_READ_BITS"},
-	{SOUND_PCM_READ_FILTER, "SOUND_PCM_READ_FILTER"}
-};
-#endif    
-
-static int it8172_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-	unsigned long flags;
-	audio_buf_info abinfo;
-	count_info cinfo;
-	int count;
-	int val, mapped, ret, diff;
-
-	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-
-#ifdef IT8172_VERBOSE_DEBUG
-	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
-		if (ioctl_str[count].cmd == cmd)
-			break;
-	}
-	if (count < sizeof(ioctl_str)/sizeof(ioctl_str[0]))
-		dbg("ioctl %s, arg=0x%08x",
-		    ioctl_str[count].str, (unsigned int)arg);
-	else
-		dbg("ioctl unknown, 0x%x", cmd);
-#endif
-    
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, (int *)arg);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s, file->f_flags & O_NONBLOCK);
-		return 0;
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
-				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
-		
-	case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq(s->irq);
-			s->dma_dac.count = s->dma_dac.total_bytes = 0;
-			s->dma_dac.nextIn = s->dma_dac.nextOut =
-				s->dma_dac.rawbuf;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->irq);
-			s->dma_adc.count = s->dma_adc.total_bytes = 0;
-			s->dma_adc.nextIn = s->dma_adc.nextOut =
-				s->dma_adc.rawbuf;
-		}
-		return 0;
-
-	case SNDCTL_DSP_SPEED:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (val >= 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				set_adc_rate(s, val);
-				if ((ret = prog_dmabuf_adc(s)))
-					return ret;
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				set_dac_rate(s, val);
-				if ((ret = prog_dmabuf_dac(s)))
-					return ret;
-			}
-		}
-		return put_user((file->f_mode & FMODE_READ) ?
-				s->adcrate : s->dacrate, (int *)arg);
-
-	case SNDCTL_DSP_STEREO:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			if (val)
-				s->capcc |= CC_SM;
-			else
-				s->capcc &= ~CC_SM;
-			outw(s->capcc, s->io+IT_AC_CAPCC);
-			if ((ret = prog_dmabuf_adc(s)))
-				return ret;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			if (val)
-				s->pcc |= CC_SM;
-			else
-				s->pcc &= ~CC_SM;
-			outw(s->pcc, s->io+IT_AC_PCC);
-			if ((ret = prog_dmabuf_dac(s)))
-				return ret;
-		}
-		return 0;
-
-	case SNDCTL_DSP_CHANNELS:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (val != 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				if (val >= 2) {
-					val = 2;
-					s->capcc |= CC_SM;
-				}
-				else
-					s->capcc &= ~CC_SM;
-				outw(s->capcc, s->io+IT_AC_CAPCC);
-				if ((ret = prog_dmabuf_adc(s)))
-					return ret;
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				switch (val) {
-				case 1:
-					s->pcc &= ~CC_SM;
-					break;
-				case 2:
-					s->pcc |= CC_SM;
-					break;
-				default:
-					// FIX! support multichannel???
-					val = 2;
-					s->pcc |= CC_SM;
-					break;
-				}
-				outw(s->pcc, s->io+IT_AC_PCC);
-				if ((ret = prog_dmabuf_dac(s)))
-					return ret;
-			}
-		}
-		return put_user(val, (int *)arg);
-		
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-		return put_user(AFMT_S16_LE|AFMT_U8, (int *)arg);
-		
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				if (val == AFMT_S16_LE)
-					s->capcc |= CC_DF;
-				else {
-					val = AFMT_U8;
-					s->capcc &= ~CC_DF;
-				}
-				outw(s->capcc, s->io+IT_AC_CAPCC);
-				if ((ret = prog_dmabuf_adc(s)))
-					return ret;
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				if (val == AFMT_S16_LE)
-					s->pcc |= CC_DF;
-				else {
-					val = AFMT_U8;
-					s->pcc &= ~CC_DF;
-				}
-				outw(s->pcc, s->io+IT_AC_PCC);
-				if ((ret = prog_dmabuf_dac(s)))
-					return ret;
-			}
-		} else {
-			if (file->f_mode & FMODE_READ)
-				val = (s->capcc & CC_DF) ?
-					AFMT_S16_LE : AFMT_U8;
-			else
-				val = (s->pcc & CC_DF) ?
-					AFMT_S16_LE : AFMT_U8;
-		}
-		return put_user(val, (int *)arg);
-		
-	case SNDCTL_DSP_POST:
-		return 0;
-
-	case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		spin_lock_irqsave(&s->lock, flags);
-		if (file->f_mode & FMODE_READ && !s->dma_adc.stopped)
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && !s->dma_dac.stopped)
-			val |= PCM_ENABLE_OUTPUT;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return put_user(val, (int *)arg);
-		
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT)
-				start_adc(s);
-			else
-				stop_adc(s);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT)
-				start_dac(s);
-			else
-				stop_dac(s);
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		abinfo.fragsize = s->dma_dac.fragsize;
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		if (!s->dma_dac.stopped)
-			count -= (s->dma_dac.fragsize -
-				  inw(s->io+IT_AC_PCDL));
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		abinfo.bytes = s->dma_dac.dmasize - count;
-		abinfo.fragstotal = s->dma_dac.numfrag;
-		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;      
-		return copy_to_user((void *)arg, &abinfo, sizeof(abinfo)) ?
-			-EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		abinfo.fragsize = s->dma_adc.fragsize;
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_adc.count;
-		if (!s->dma_adc.stopped)
-			count += (s->dma_adc.fragsize -
-				  inw(s->io+IT_AC_CAPCDL));
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		abinfo.bytes = count;
-		abinfo.fragstotal = s->dma_adc.numfrag;
-		abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;      
-		return copy_to_user((void *)arg, &abinfo, sizeof(abinfo)) ?
-			-EFAULT : 0;
-		
-	case SNDCTL_DSP_NONBLOCK:
-		file->f_flags |= O_NONBLOCK;
-		return 0;
-
-	case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		if (!s->dma_dac.stopped)
-			count -= (s->dma_dac.fragsize -
-				  inw(s->io+IT_AC_PCDL));
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		return put_user(count, (int *)arg);
-
-	case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cinfo.bytes = s->dma_adc.total_bytes;
-		count = s->dma_adc.count;
-		if (!s->dma_adc.stopped) {
-			diff = s->dma_adc.fragsize - inw(s->io+IT_AC_CAPCDL);
-			count += diff;
-			cinfo.bytes += diff;
-			cinfo.ptr = inl(s->io+s->dma_adc.curBufPtr) -
-				s->dma_adc.dmaaddr;
-		} else
-			cinfo.ptr = virt_to_bus(s->dma_adc.nextIn) -
-				s->dma_adc.dmaaddr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		cinfo.blocks = count >> s->dma_adc.fragshift;
-		if (copy_to_user((void *)arg, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-	case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cinfo.bytes = s->dma_dac.total_bytes;
-		count = s->dma_dac.count;
-		if (!s->dma_dac.stopped) {
-			diff = s->dma_dac.fragsize - inw(s->io+IT_AC_CAPCDL);
-			count -= diff;
-			cinfo.bytes += diff;
-			cinfo.ptr = inl(s->io+s->dma_dac.curBufPtr) -
-				s->dma_dac.dmaaddr;
-		} else
-			cinfo.ptr = virt_to_bus(s->dma_dac.nextOut) -
-				s->dma_dac.dmaaddr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= s->dma_dac.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		cinfo.blocks = count >> s->dma_dac.fragshift;
-		if (copy_to_user((void *)arg, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE)
-			return put_user(s->dma_dac.fragsize, (int *)arg);
-		else
-			return put_user(s->dma_adc.fragsize, (int *)arg);
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-			if ((ret = prog_dmabuf_adc(s)))
-				return ret;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.ossfragshift = val & 0xffff;
-			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac.ossfragshift < 4)
-				s->dma_dac.ossfragshift = 4;
-			if (s->dma_dac.ossfragshift > 15)
-				s->dma_dac.ossfragshift = 15;
-			if (s->dma_dac.ossmaxfrags < 4)
-				s->dma_dac.ossmaxfrags = 4;
-			if ((ret = prog_dmabuf_dac(s)))
-				return ret;
-		}
-		return 0;
-
-	case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-			return -EINVAL;
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.subdivision = val;
-			if ((ret = prog_dmabuf_adc(s)))
-				return ret;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.subdivision = val;
-			if ((ret = prog_dmabuf_dac(s)))
-				return ret;
-		}
-		return 0;
-
-	case SOUND_PCM_READ_RATE:
-		return put_user((file->f_mode & FMODE_READ) ?
-				s->adcrate : s->dacrate, (int *)arg);
-
-	case SOUND_PCM_READ_CHANNELS:
-		if (file->f_mode & FMODE_READ)
-			return put_user((s->capcc & CC_SM) ? 2 : 1,
-					(int *)arg);
-		else
-			return put_user((s->pcc & CC_SM) ? 2 : 1,
-					(int *)arg);
-	    
-	case SOUND_PCM_READ_BITS:
-		if (file->f_mode & FMODE_READ)
-			return put_user((s->capcc & CC_DF) ? 16 : 8,
-					(int *)arg);
-		else
-			return put_user((s->pcc & CC_DF) ? 16 : 8,
-					(int *)arg);
-
-	case SOUND_PCM_WRITE_FILTER:
-	case SNDCTL_DSP_SETSYNCRO:
-	case SOUND_PCM_READ_FILTER:
-		return -EINVAL;
-	}
-
-	return mixdev_ioctl(&s->codec, cmd, arg);
-}
-
-
-static int it8172_open(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	struct list_head *list;
-	struct it8172_state *s;
-	int ret;
-    
-#ifdef IT8172_VERBOSE_DEBUG
-	if (file->f_flags & O_NONBLOCK)
-		dbg("%s: non-blocking", __FUNCTION__);
-	else
-		dbg("%s: blocking", __FUNCTION__);
-#endif
-	
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct it8172_state, devs);
-		if (!((s->dev_audio ^ minor) & ~0xf))
-			break;
-	}
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & file->f_mode) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	if (file->f_mode & FMODE_READ) {
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
-			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
-		s->capcc &= ~(CC_SM | CC_DF);
-		set_adc_rate(s, 8000);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			s->capcc |= CC_DF;
-		outw(s->capcc, s->io+IT_AC_CAPCC);
-		if ((ret = prog_dmabuf_adc(s))) {
-			spin_unlock_irqrestore(&s->lock, flags);
-			return ret;
-		}
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
-			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
-		s->pcc &= ~(CC_SM | CC_DF);
-		set_dac_rate(s, 8000);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			s->pcc |= CC_DF;
-		outw(s->pcc, s->io+IT_AC_PCC);
-		if ((ret = prog_dmabuf_dac(s))) {
-			spin_unlock_irqrestore(&s->lock, flags);
-			return ret;
-		}
-	}
-    
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	s->open_mode |= (file->f_mode & (FMODE_READ | FMODE_WRITE));
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int it8172_release(struct inode *inode, struct file *file)
-{
-	struct it8172_state *s = (struct it8172_state *)file->private_data;
-
-#ifdef IT8172_VERBOSE_DEBUG
-	dbg("%s", __FUNCTION__);
-#endif
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE)
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac(s);
-		dealloc_dmabuf(s, &s->dma_dac);
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-		dealloc_dmabuf(s, &s->dma_adc);
-	}
-	s->open_mode &= ((~file->f_mode) & (FMODE_READ|FMODE_WRITE));
-	mutex_unlock(&s->open_mutex);
-	wake_up(&s->open_wait);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations it8172_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= it8172_read,
-	.write		= it8172_write,
-	.poll		= it8172_poll,
-	.ioctl		= it8172_ioctl,
-	.mmap		= it8172_mmap,
-	.open		= it8172_open,
-	.release	= it8172_release,
-};
-
-
-/* --------------------------------------------------------------------- */
-
-
-/* --------------------------------------------------------------------- */
-
-/*
- * for debugging purposes, we'll create a proc device that dumps the
- * CODEC chipstate
- */
-
-#ifdef IT8172_DEBUG
-static int proc_it8172_dump (char *buf, char **start, off_t fpos,
-			     int length, int *eof, void *data)
-{
-	struct it8172_state *s;
-	int cnt, len = 0;
-
-	if (list_empty(&devs))
-		return 0;
-	s = list_entry(devs.next, struct it8172_state, devs);
-
-	/* print out header */
-	len += sprintf(buf + len, "\n\t\tIT8172 Audio Debug\n\n");
-
-	// print out digital controller state
-	len += sprintf (buf + len, "IT8172 Audio Controller registers\n");
-	len += sprintf (buf + len, "---------------------------------\n");
-	cnt=0;
-	while (cnt < 0x72) {
-		if (cnt == IT_AC_PCB1STA || cnt == IT_AC_PCB2STA ||
-		    cnt == IT_AC_CAPB1STA || cnt == IT_AC_CAPB2STA ||
-		    cnt == IT_AC_PFDP) {
-			len+= sprintf (buf + len, "reg %02x = %08x\n",
-				       cnt, inl(s->io+cnt));
-			cnt += 4;
-		} else {
-			len+= sprintf (buf + len, "reg %02x = %04x\n",
-				       cnt, inw(s->io+cnt));
-			cnt += 2;
-		}
-	}
-    
-	/* print out CODEC state */
-	len += sprintf (buf + len, "\nAC97 CODEC registers\n");
-	len += sprintf (buf + len, "----------------------\n");
-	for (cnt=0; cnt <= 0x7e; cnt = cnt +2)
-		len+= sprintf (buf + len, "reg %02x = %04x\n",
-			       cnt, rdcodec(&s->codec, cnt));
-
-	if (fpos >=len){
-		*start = buf;
-		*eof =1;
-		return 0;
-	}
-	*start = buf + fpos;
-	if ((len -= fpos) > length)
-		return length;
-	*eof =1;
-	return len;
-
-}
-#endif /* IT8172_DEBUG */
-
-/* --------------------------------------------------------------------- */
-
-/* maximum number of devices; only used for command line params */
-#define NR_DEVICE 5
-
-static int spdif[NR_DEVICE];
-static int i2s_fmt[NR_DEVICE];
-
-static unsigned int devindex;
-
-module_param_array(spdif, int, NULL, 0);
-MODULE_PARM_DESC(spdif, "if 1 the S/PDIF digital output is enabled");
-module_param_array(i2s_fmt, int, NULL, 0);
-MODULE_PARM_DESC(i2s_fmt, "the format of I2S");
-
-MODULE_AUTHOR("Monta Vista Software, stevel@mvista.com");
-MODULE_DESCRIPTION("IT8172 Audio Driver");
-
-/* --------------------------------------------------------------------- */
-
-static int __devinit it8172_probe(struct pci_dev *pcidev,
-				  const struct pci_device_id *pciid)
-{
-	struct it8172_state *s;
-	int i, val;
-	unsigned short pcisr, vol;
-	unsigned char legacy, imc;
-	char proc_str[80];
-    
-	if (pcidev->irq == 0) 
-		return -1;
-
-	if (!(s = kmalloc(sizeof(struct it8172_state), GFP_KERNEL))) {
-		err("alloc of device struct failed");
-		return -1;
-	}
-	
-	memset(s, 0, sizeof(struct it8172_state));
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac.wait);
-	init_waitqueue_head(&s->open_wait);
-	mutex_init(&s->open_mutex);
-	spin_lock_init(&s->lock);
-	s->dev = pcidev;
-	s->io = pci_resource_start(pcidev, 0);
-	s->irq = pcidev->irq;
-	s->vendor = pcidev->vendor;
-	s->device = pcidev->device;
-	pci_read_config_byte(pcidev, PCI_REVISION_ID, &s->rev);
-	s->codec.private_data = s;
-	s->codec.id = 0;
-	s->codec.codec_read = rdcodec;
-	s->codec.codec_write = wrcodec;
-	s->codec.codec_wait = waitcodec;
-
-	if (!request_region(s->io, pci_resource_len(pcidev,0),
-			    IT8172_MODULE_NAME)) {
-		err("io ports %#lx->%#lx in use",
-		    s->io, s->io + pci_resource_len(pcidev,0)-1);
-		goto err_region;
-	}
-	if (request_irq(s->irq, it8172_interrupt, IRQF_DISABLED,
-			IT8172_MODULE_NAME, s)) {
-		err("irq %u in use", s->irq);
-		goto err_irq;
-	}
-
-	info("IO at %#lx, IRQ %d", s->io, s->irq);
-
-	/* register devices */
-	if ((s->dev_audio = register_sound_dsp(&it8172_audio_fops, -1)) < 0)
-		goto err_dev1;
-	if ((s->codec.dev_mixer =
-	     register_sound_mixer(&it8172_mixer_fops, -1)) < 0)
-		goto err_dev2;
-
-#ifdef IT8172_DEBUG
-	/* initialize the debug proc device */
-	s->ps = create_proc_read_entry(IT8172_MODULE_NAME, 0, NULL,
-				       proc_it8172_dump, NULL);
-#endif /* IT8172_DEBUG */
-	
-	/*
-	 * Reset the Audio device using the IT8172 PCI Reset register. This
-	 * creates an audible double click on a speaker connected to Line-out.
-	 */
-	IT_IO_READ16(IT_PM_PCISR, pcisr);
-	pcisr |= IT_PM_PCISR_ACSR;
-	IT_IO_WRITE16(IT_PM_PCISR, pcisr);
-	/* wait up to 100msec for reset to complete */
-	for (i=0; pcisr & IT_PM_PCISR_ACSR; i++) {
-		it8172_delay(10);
-		if (i == 10)
-			break;
-		IT_IO_READ16(IT_PM_PCISR, pcisr);
-	}
-	if (i == 10) {
-		err("chip reset timeout!");
-		goto err_dev3;
-	}
-    
-	/* enable pci io and bus mastering */
-	if (pci_enable_device(pcidev))
-		goto err_dev3;
-	pci_set_master(pcidev);
-
-	/* get out of legacy mode */
-	pci_read_config_byte (pcidev, 0x40, &legacy);
-	pci_write_config_byte (pcidev, 0x40, legacy & ~1);
-    
-	s->spdif_volume = -1;
-	/* check to see if s/pdif mode is being requested */
-	if (spdif[devindex]) {
-		info("enabling S/PDIF output");
-		s->spdif_volume = 0;
-		outb(GC_SOE, s->io+IT_AC_GC);
-	} else {
-		info("disabling S/PDIF output");
-		outb(0, s->io+IT_AC_GC);
-	}
-    
-	/* check to see if I2S format requested */
-	if (i2s_fmt[devindex]) {
-		info("setting I2S format to 0x%02x", i2s_fmt[devindex]);
-		outb(i2s_fmt[devindex], s->io+IT_AC_I2SMC);
-	} else {
-		outb(I2SMC_I2SF_I2S, s->io+IT_AC_I2SMC);
-	}
-
-	/* cold reset the AC97 */
-	outw(CODECC_CR, s->io+IT_AC_CODECC);
-	udelay(1000);
-	outw(0, s->io+IT_AC_CODECC);
-	/* need to delay around 500msec(bleech) to give
-	   some CODECs enough time to wakeup */
-	it8172_delay(500);
-    
-	/* AC97 warm reset to start the bitclk */
-	outw(CODECC_WR, s->io+IT_AC_CODECC);
-	udelay(1000);
-	outw(0, s->io+IT_AC_CODECC);
-    
-	/* codec init */
-	if (!ac97_probe_codec(&s->codec))
-		goto err_dev3;
-
-	/* add I2S as allowable recording source */
-	s->codec.record_sources |= SOUND_MASK_I2S;
-	
-	/* Enable Volume button interrupts */
-	imc = inb(s->io+IT_AC_IMC);
-	outb(imc & ~IMC_VCIM, s->io+IT_AC_IMC);
-
-	/* Un-mute PCM and FM out on the controller */
-	vol = inw(s->io+IT_AC_PCMOV);
-	outw(vol & ~PCMOV_PCMOM, s->io+IT_AC_PCMOV);
-	vol = inw(s->io+IT_AC_FMOV);
-	outw(vol & ~FMOV_FMOM, s->io+IT_AC_FMOV);
-    
-	/* set channel defaults to 8-bit, mono, 8 Khz */
-	s->pcc = 0;
-	s->capcc = 0;
-	set_dac_rate(s, 8000);
-	set_adc_rate(s, 8000);
-
-	/* set mic to be the recording source */
-	val = SOUND_MASK_MIC;
-	mixdev_ioctl(&s->codec, SOUND_MIXER_WRITE_RECSRC,
-		     (unsigned long)&val);
-
-	/* mute AC'97 master and PCM when in S/PDIF mode */
-	if (s->spdif_volume != -1) {
-		val = 0x0000;
-		s->codec.mixer_ioctl(&s->codec, SOUND_MIXER_WRITE_VOLUME,
-				     (unsigned long)&val);
-		s->codec.mixer_ioctl(&s->codec, SOUND_MIXER_WRITE_PCM,
-				     (unsigned long)&val);
-	}
-    
-#ifdef IT8172_DEBUG
-	sprintf(proc_str, "driver/%s/%d/ac97", IT8172_MODULE_NAME,
-		s->codec.id);
-	s->ac97_ps = create_proc_read_entry (proc_str, 0, NULL,
-					     ac97_read_proc, &s->codec);
-#endif
-    
-	/* store it in the driver field */
-	pci_set_drvdata(pcidev, s);
-	pcidev->dma_mask = 0xffffffff;
-	/* put it into driver list */
-	list_add_tail(&s->devs, &devs);
-	/* increment devindex */
-	if (devindex < NR_DEVICE-1)
-		devindex++;
-	return 0;
-
- err_dev3:
-	unregister_sound_mixer(s->codec.dev_mixer);
- err_dev2:
-	unregister_sound_dsp(s->dev_audio);
- err_dev1:
-	err("cannot register misc device");
-	free_irq(s->irq, s);
- err_irq:
-	release_region(s->io, pci_resource_len(pcidev,0));
- err_region:
-	kfree(s);
-	return -1;
-}
-
-static void __devexit it8172_remove(struct pci_dev *dev)
-{
-	struct it8172_state *s = pci_get_drvdata(dev);
-
-	if (!s)
-		return;
-	list_del(&s->devs);
-#ifdef IT8172_DEBUG
-	if (s->ps)
-		remove_proc_entry(IT8172_MODULE_NAME, NULL);
-#endif /* IT8172_DEBUG */
-	synchronize_irq(s->irq);
-	free_irq(s->irq, s);
-	release_region(s->io, pci_resource_len(dev,0));
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->codec.dev_mixer);
-	kfree(s);
-	pci_set_drvdata(dev, NULL);
-}
-
-
-
-static struct pci_device_id id_table[] = {
-	{ PCI_VENDOR_ID_ITE, PCI_DEVICE_ID_ITE_IT8172G_AUDIO, PCI_ANY_ID,
-	  PCI_ANY_ID, 0, 0 },
-	{ 0, }
-};
-
-MODULE_DEVICE_TABLE(pci, id_table);
-
-static struct pci_driver it8172_driver = {
-	.name = IT8172_MODULE_NAME,
-	.id_table = id_table,
-	.probe = it8172_probe,
-	.remove = __devexit_p(it8172_remove)
-};
-
-static int __init init_it8172(void)
-{
-	info("version v0.5 time " __TIME__ " " __DATE__);
-	return pci_register_driver(&it8172_driver);
-}
-
-static void __exit cleanup_it8172(void)
-{
-	info("unloading");
-	pci_unregister_driver(&it8172_driver);
-}
-
-module_init(init_it8172);
-module_exit(cleanup_it8172);
-
-/* --------------------------------------------------------------------- */
-
-#ifndef MODULE
-
-/* format is: it8172=[spdif],[i2s:<I2S format>] */
-
-static int __init it8172_setup(char *options)
-{
-	char* this_opt;
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= NR_DEVICE)
-		return 0;
-
-	if (!options || !*options)
-		return 0;
-
-	while (this_opt = strsep(&options, ",")) {
-		if (!*this_opt)
-			continue;
-		if (!strncmp(this_opt, "spdif", 5)) {
-			spdif[nr_dev] = 1;
-		} else if (!strncmp(this_opt, "i2s:", 4)) {
-			if (!strncmp(this_opt+4, "dac", 3))
-				i2s_fmt[nr_dev] = I2SMC_I2SF_DAC;
-			else if (!strncmp(this_opt+4, "adc", 3))
-				i2s_fmt[nr_dev] = I2SMC_I2SF_ADC;
-			else if (!strncmp(this_opt+4, "i2s", 3))
-				i2s_fmt[nr_dev] = I2SMC_I2SF_I2S;
-		}
-	}
-
-	nr_dev++;
-	return 1;
-}
-
-__setup("it8172=", it8172_setup);
-
-#endif /* MODULE */
--- linux-2.6.18.noarch/sound/oss/sys_timer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sys_timer.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sys_timer.c
+ * sound/oss/sys_timer.c
  *
  * The default timer for the Level 2 sequencer interface
  * Uses the (1/HZ sec) timer of kernel.
--- linux-2.6.18.noarch/sound/oss/maestro.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/maestro.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,60 +0,0 @@
-/*
- *	Registers for the ESS PCI cards
- */
- 
-/*
- *	Memory access
- */
- 
-#define ESS_MEM_DATA		0x00
-#define	ESS_MEM_INDEX		0x02
-
-/*
- *	AC-97 Codec port. Delay 1uS after each write. This is used to
- *	talk AC-97 (see intel.com). Write data then register.
- */
- 
-#define ESS_AC97_INDEX		0x30		/* byte wide */
-#define ESS_AC97_DATA		0x32
-
-/* 
- *	Reading is a bit different. You write register|0x80 to ubdex
- *	delay 1uS poll the low bit of index, when it clears read the
- *	data value.
- */
-
-/*
- *	Control port. Not yet fully understood
- *	The value 0xC090 gets loaded to it then 0x0000 and 0x2800
- *	to the data port. Then after 4uS the value 0x300 is written
- */
- 
-#define RING_BUS_CTRL_L		0x34
-#define RING_BUS_CTRL_H		0x36
-
-/*
- *	This is also used during setup. The value 0x17 is written to it
- */
- 
-#define ESS_SETUP_18		0x18
-
-/*
- *	And this one gets 0x000b
- */
- 
-#define ESS_SETUP_A2		0xA2
-
-/*
- *	And this 0x0000
- */
- 
-#define ESS_SETUP_A4		0xA4
-#define ESS_SETUP_A6		0xA6
-
-/*
- *	Stuff to do with Harpo - the wave stuff
- */
- 
-#define ESS_WAVETABLE_SIZE	0x14
-#define 	ESS_WAVETABLE_2M	0xA180
-
--- linux-2.6.18.noarch/sound/oss/opl3sa.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/opl3sa.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,329 +0,0 @@
-/*
- * sound/opl3sa.c
- *
- * Low level driver for Yamaha YMF701B aka OPL3-SA chip
- * 
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- * Changes:
- *	Alan Cox		Modularisation
- *	Christoph Hellwig	Adapted to module_init/module_exit
- *	Arnaldo C. de Melo	got rid of attach_uart401
- *
- * FIXME:
- * 	Check for install of mpu etc is wrong, should check result of the mss stuff
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/spinlock.h>
-
-#undef  SB_OK
-
-#include "sound_config.h"
-
-#include "ad1848.h"
-#include "mpu401.h"
-
-#ifdef SB_OK
-#include "sb.h"
-static int sb_initialized;
-#endif
-
-static DEFINE_SPINLOCK(lock);
-
-static unsigned char opl3sa_read(int addr)
-{
-	unsigned long flags;
-	unsigned char tmp;
-
-	spin_lock_irqsave(&lock,flags);
-	outb((0x1d), 0xf86);	/* password */
-	outb(((unsigned char) addr), 0xf86);	/* address */
-	tmp = inb(0xf87);	/* data */
-	spin_unlock_irqrestore(&lock,flags);
-
-	return tmp;
-}
-
-static void opl3sa_write(int addr, int data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&lock,flags);
-	outb((0x1d), 0xf86);	/* password */
-	outb(((unsigned char) addr), 0xf86);	/* address */
-	outb(((unsigned char) data), 0xf87);	/* data */
-	spin_unlock_irqrestore(&lock,flags);
-}
-
-static int __init opl3sa_detect(void)
-{
-	int tmp;
-
-	if (((tmp = opl3sa_read(0x01)) & 0xc4) != 0x04)
-	{
-		DDB(printk("OPL3-SA detect error 1 (%x)\n", opl3sa_read(0x01)));
-		/* return 0; */
-	}
-
-	/*
-	 * Check that the password feature has any effect
-	 */
-	
-	if (inb(0xf87) == tmp)
-	{
-		DDB(printk("OPL3-SA detect failed 2 (%x/%x)\n", tmp, inb(0xf87)));
-		return 0;
-	}
-	tmp = (opl3sa_read(0x04) & 0xe0) >> 5;
-
-	if (tmp != 0 && tmp != 1)
-	{
-		DDB(printk("OPL3-SA detect failed 3 (%d)\n", tmp));
-		return 0;
-	}
-	DDB(printk("OPL3-SA mode %x detected\n", tmp));
-
-	opl3sa_write(0x01, 0x00);	/* Disable MSS */
-	opl3sa_write(0x02, 0x00);	/* Disable SB */
-	opl3sa_write(0x03, 0x00);	/* Disable MPU */
-
-	return 1;
-}
-
-/*
- *    Probe and attach routines for the Windows Sound System mode of
- *     OPL3-SA
- */
-
-static int __init probe_opl3sa_wss(struct address_info *hw_config, struct resource *ports)
-{
-	unsigned char tmp = 0x24;	/* WSS enable */
-
-	/*
-	 * Check if the IO port returns valid signature. The original MS Sound
-	 * system returns 0x04 while some cards (OPL3-SA for example)
-	 * return 0x00.
-	 */
-
-	if (!opl3sa_detect())
-	{
-		printk(KERN_ERR "OSS: OPL3-SA chip not found\n");
-		return 0;
-	}
-	
-	switch (hw_config->io_base)
-	{
-		case 0x530:
-			tmp |= 0x00;
-			break;
-		case 0xe80:
-			tmp |= 0x08;
-			break;
-		case 0xf40:
-			tmp |= 0x10;
-			break;
-		case 0x604:
-			tmp |= 0x18;
-			break;
-		default:
-			printk(KERN_ERR "OSS: Unsupported OPL3-SA/WSS base %x\n", hw_config->io_base);
-		  return 0;
-	}
-
-	opl3sa_write(0x01, tmp);	/* WSS setup register */
-
-	return probe_ms_sound(hw_config, ports);
-}
-
-static void __init attach_opl3sa_wss(struct address_info *hw_config, struct resource *ports)
-{
-	int nm = num_mixers;
-
-	/* FIXME */
-	attach_ms_sound(hw_config, ports, THIS_MODULE);
-	if (num_mixers > nm)	/* A mixer was installed */
-	{
-		AD1848_REROUTE(SOUND_MIXER_LINE1, SOUND_MIXER_CD);
-		AD1848_REROUTE(SOUND_MIXER_LINE2, SOUND_MIXER_SYNTH);
-		AD1848_REROUTE(SOUND_MIXER_LINE3, SOUND_MIXER_LINE);
-	}
-}
-
-
-static int __init probe_opl3sa_mpu(struct address_info *hw_config)
-{
-	unsigned char conf;
-	static signed char irq_bits[] = {
-		-1, -1, -1, -1, -1, 1, -1, 2, -1, 3, 4
-	};
-
-	if (hw_config->irq > 10)
-	{
-		printk(KERN_ERR "OPL3-SA: Bad MPU IRQ %d\n", hw_config->irq);
-		return 0;
-	}
-	if (irq_bits[hw_config->irq] == -1)
-	{
-		printk(KERN_ERR "OPL3-SA: Bad MPU IRQ %d\n", hw_config->irq);
-		return 0;
-	}
-	switch (hw_config->io_base)
-	{
-		case 0x330:
-			conf = 0x00;
-			break;
-		case 0x332:
-			conf = 0x20;
-			break;
-		case 0x334:
-			conf = 0x40;
-			break;
-		case 0x300:
-			conf = 0x60;
-			break;
-		default:
-			return 0;	/* Invalid port */
-	}
-
-	conf |= 0x83;		/* MPU & OPL3 (synth) & game port enable */
-	conf |= irq_bits[hw_config->irq] << 2;
-
-	opl3sa_write(0x03, conf);
-
-	hw_config->name = "OPL3-SA (MPU401)";
-
-	return probe_uart401(hw_config, THIS_MODULE);
-}
-
-static void __exit unload_opl3sa_wss(struct address_info *hw_config)
-{
-	int dma2 = hw_config->dma2;
-
-	if (dma2 == -1)
-		dma2 = hw_config->dma;
-
-	release_region(0xf86, 2);
-	release_region(hw_config->io_base, 4);
-
-	ad1848_unload(hw_config->io_base + 4,
-		      hw_config->irq,
-		      hw_config->dma,
-		      dma2,
-		      0);
-	sound_unload_audiodev(hw_config->slots[0]);
-}
-
-static inline void __exit unload_opl3sa_mpu(struct address_info *hw_config)
-{
-	unload_uart401(hw_config);
-}
-
-#ifdef SB_OK
-static inline void __exit unload_opl3sa_sb(struct address_info *hw_config)
-{
-	sb_dsp_unload(hw_config);
-}
-#endif
-
-static int found_mpu;
-
-static struct address_info cfg;
-static struct address_info cfg_mpu;
-
-static int __initdata io	= -1;
-static int __initdata irq	= -1;
-static int __initdata dma	= -1;
-static int __initdata dma2	= -1;
-static int __initdata mpu_io	= -1;
-static int __initdata mpu_irq	= -1;
-
-module_param(io, int, 0);
-module_param(irq, int, 0);
-module_param(dma, int, 0);
-module_param(dma2, int, 0);
-module_param(mpu_io, int, 0);
-module_param(mpu_irq, int, 0);
-
-static int __init init_opl3sa(void)
-{
-	struct resource *ports;
-	if (io == -1 || irq == -1 || dma == -1) {
-		printk(KERN_ERR "opl3sa: dma, irq and io must be set.\n");
-		return -EINVAL;
-	}
-
-	cfg.io_base = io;
-	cfg.irq = irq;
-	cfg.dma = dma;
-	cfg.dma2 = dma2;
-	
-	cfg_mpu.io_base = mpu_io;
-	cfg_mpu.irq = mpu_irq;
-
-	ports = request_region(io + 4, 4, "ad1848");
-	if (!ports)
-		return -EBUSY;
-
-	if (!request_region(0xf86, 2, "OPL3-SA"))/* Control port is busy */ {
-		release_region(io + 4, 4);
-		return 0;
-	}
-
-	if (!request_region(io, 4, "WSS config")) {
-		release_region(0x86, 2);
-		release_region(io + 4, 4);
-		return 0;
-	}
-
-	if (probe_opl3sa_wss(&cfg, ports) == 0) {
-		release_region(0xf86, 2);
-		release_region(io, 4);
-		release_region(io + 4, 4);
-		return -ENODEV;
-	}
-
-	found_mpu=probe_opl3sa_mpu(&cfg_mpu);
-
-	attach_opl3sa_wss(&cfg, ports);
-	return 0;
-}
-
-static void __exit cleanup_opl3sa(void)
-{
-	if(found_mpu)
-		unload_opl3sa_mpu(&cfg_mpu);
-	unload_opl3sa_wss(&cfg);
-}
-
-module_init(init_opl3sa);
-module_exit(cleanup_opl3sa);
-
-#ifndef MODULE
-static int __init setup_opl3sa(char *str)
-{
-	/* io, irq, dma, dma2, mpu_io, mpu_irq */
-	int ints[7];
-	
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-	
-	io	= ints[1];
-	irq	= ints[2];
-	dma	= ints[3];
-	dma2	= ints[4];
-	mpu_io	= ints[5];
-	mpu_irq	= ints[6];
-
-	return 1;
-}
-
-__setup("opl3sa=", setup_opl3sa);
-#endif
-MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/oss/Makefile.orig	2007-06-05 16:07:54.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/Makefile	2007-06-05 17:44:14.000000000 -0400
@@ -15,72 +15,42 @@
 obj-$(CONFIG_SOUND_AEDSP16)	+= aedsp16.o
 obj-$(CONFIG_SOUND_PSS)		+= pss.o ad1848.o mpu401.o
 obj-$(CONFIG_SOUND_TRIX)	+= trix.o ad1848.o sb_lib.o uart401.o
-obj-$(CONFIG_SOUND_OPL3SA1)	+= opl3sa.o ad1848.o uart401.o
 obj-$(CONFIG_SOUND_SSCAPE)	+= sscape.o ad1848.o mpu401.o
-obj-$(CONFIG_SOUND_MAD16)	+= mad16.o ad1848.o sb_lib.o uart401.o
 obj-$(CONFIG_SOUND_CS4232)	+= cs4232.o uart401.o
 obj-$(CONFIG_SOUND_MSS)		+= ad1848.o
 obj-$(CONFIG_SOUND_OPL3SA2)	+= opl3sa2.o ad1848.o mpu401.o
 obj-$(CONFIG_SOUND_PAS)		+= pas2.o sb.o sb_lib.o uart401.o
 obj-$(CONFIG_SOUND_SB)		+= sb.o sb_lib.o uart401.o
 obj-$(CONFIG_SOUND_KAHLUA)	+= kahlua.o
-obj-$(CONFIG_SOUND_WAVEFRONT)	+= wavefront.o
-obj-$(CONFIG_SOUND_MAUI)	+= maui.o mpu401.o
 obj-$(CONFIG_SOUND_MPU401)	+= mpu401.o
 obj-$(CONFIG_SOUND_UART6850)	+= uart6850.o
-obj-$(CONFIG_SOUND_GUS)		+= gus.o ad1848.o
 obj-$(CONFIG_SOUND_ADLIB)	+= adlib_card.o opl3.o
 obj-$(CONFIG_SOUND_YM3812)	+= opl3.o
 obj-$(CONFIG_SOUND_VMIDI)	+= v_midi.o
 obj-$(CONFIG_SOUND_VIDC)	+= vidc_mod.o
 obj-$(CONFIG_SOUND_WAVEARTIST)	+= waveartist.o
-obj-$(CONFIG_SOUND_SGALAXY)	+= sgalaxy.o ad1848.o
 obj-$(CONFIG_SOUND_AD1816)	+= ad1816.o
 obj-$(CONFIG_SOUND_AD1889)	+= ad1889.o ac97_codec.o
 obj-$(CONFIG_SOUND_ACI_MIXER)	+= aci.o
-obj-$(CONFIG_SOUND_AWE32_SYNTH)	+= awe_wave.o
 
 obj-$(CONFIG_SOUND_VIA82CXXX)	+= via82cxxx_audio.o ac97_codec.o
 ifeq ($(CONFIG_MIDI_VIA82CXXX),y)
   obj-$(CONFIG_SOUND_VIA82CXXX) += sound.o uart401.o
 endif
-obj-$(CONFIG_SOUND_YMFPCI)	+= ymfpci.o ac97_codec.o
-ifeq ($(CONFIG_SOUND_YMFPCI_LEGACY),y)
-  obj-$(CONFIG_SOUND_YMFPCI)    += opl3.o uart401.o
-endif
 obj-$(CONFIG_SOUND_MSNDCLAS)	+= msnd.o msnd_classic.o
 obj-$(CONFIG_SOUND_MSNDPIN)	+= msnd.o msnd_pinnacle.o
 obj-$(CONFIG_SOUND_VWSND)	+= vwsnd.o
 obj-$(CONFIG_SOUND_NM256)	+= nm256_audio.o ac97.o
 obj-$(CONFIG_SOUND_ICH)		+= i810_audio.o ac97_codec.o
-obj-$(CONFIG_SOUND_SONICVIBES)	+= sonicvibes.o
-obj-$(CONFIG_SOUND_CMPCI)	+= cmpci.o
-ifeq ($(CONFIG_SOUND_CMPCI_FM),y)
-  obj-$(CONFIG_SOUND_CMPCI)     += sound.o opl3.o
-endif
-ifeq ($(CONFIG_SOUND_CMPCI_MIDI),y)
-  obj-$(CONFIG_SOUND_CMPCI)     += sound.o mpu401.o
-endif
-obj-$(CONFIG_SOUND_ES1370)	+= es1370.o
 obj-$(CONFIG_SOUND_ES1371)	+= es1371.o ac97_codec.o
 obj-$(CONFIG_SOUND_VRC5477)	+= nec_vrc5477.o ac97_codec.o
-obj-$(CONFIG_SOUND_AU1000)	+= au1000.o ac97_codec.o
 obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o
-obj-$(CONFIG_SOUND_ESSSOLO1)	+= esssolo1.o
 obj-$(CONFIG_SOUND_FUSION)	+= cs46xx.o ac97_codec.o
-obj-$(CONFIG_SOUND_MAESTRO)	+= maestro.o
-obj-$(CONFIG_SOUND_MAESTRO3)	+= maestro3.o ac97_codec.o
 obj-$(CONFIG_SOUND_TRIDENT)	+= trident.o ac97_codec.o
-obj-$(CONFIG_SOUND_HARMONY)	+= harmony.o
 obj-$(CONFIG_SOUND_EMU10K1)	+= ac97_codec.o
 obj-$(CONFIG_SOUND_BCM_CS4297A)	+= swarm_cs4297a.o
-obj-$(CONFIG_SOUND_RME96XX)     += rme96xx.o
 obj-$(CONFIG_SOUND_BT878)	+= btaudio.o
-obj-$(CONFIG_SOUND_ALI5455)	+= ali5455.o ac97_codec.o
-obj-$(CONFIG_SOUND_IT8172)	+= ite8172.o ac97_codec.o
-obj-$(CONFIG_SOUND_FORTE)	+= forte.o ac97_codec.o
 
-obj-$(CONFIG_SOUND_AD1980)	+= ac97_plugin_ad1980.o ac97_codec.o
 obj-$(CONFIG_SOUND_WM97XX)	+= ac97_plugin_wm97xx.o
 
 ifeq ($(CONFIG_MIDI_EMU10K1),y)
@@ -88,28 +58,25 @@
 endif
 
 obj-$(CONFIG_SOUND_EMU10K1)	+= emu10k1/
-obj-$(CONFIG_SOUND_CS4281)	+= cs4281/
 obj-$(CONFIG_DMASOUND)		+= dmasound/
 
 # Declare multi-part drivers.
 
 sound-objs	:= 							\
-    dev_table.o soundcard.o sound_syms.o		\
-    audio.o audio_syms.o dmabuf.o					\
-    midi_syms.o midi_synth.o midibuf.o					\
-    sequencer.o sequencer_syms.o sound_timer.o sys_timer.o
+    dev_table.o soundcard.o 		\
+    audio.o dmabuf.o					\
+    midi_synth.o midibuf.o					\
+    sequencer.o sound_timer.o sys_timer.o
 
-gus-objs	:= gus_card.o gus_midi.o gus_vol.o gus_wave.o ics2101.o
 pas2-objs	:= pas2_card.o pas2_midi.o pas2_mixer.o pas2_pcm.o
 sb-objs		:= sb_card.o
 sb_lib-objs	:= sb_common.o sb_audio.o sb_midi.o sb_mixer.o sb_ess.o
 vidc_mod-objs	:= vidc.o vidc_fill.o
-wavefront-objs  := wavfront.o wf_midi.o yss225.o
 
 hostprogs-y	:= bin2hex hex2hex
 
 # Files generated that shall be removed upon make clean
-clean-files := maui_boot.h msndperm.c msndinit.c pndsperm.c pndspini.c \
+clean-files := msndperm.c msndinit.c pndsperm.c pndspini.c \
                pss_boot.h trix_boot.h
 
 # Firmware files that need translation
@@ -119,21 +86,6 @@
 # will be forced to be remade.
 #
 
-# Turtle Beach Maui / Tropez
-
-$(obj)/maui.o: $(obj)/maui_boot.h
-
-ifeq ($(CONFIG_MAUI_HAVE_BOOT),y)
-    $(obj)/maui_boot.h: $(patsubst "%", %, $(CONFIG_MAUI_BOOT_FILE)) $(obj)/bin2hex
-	$(obj)/bin2hex -i maui_os < $< > $@
-else
-    $(obj)/maui_boot.h:
-	(							\
-	    echo 'static unsigned char * maui_os = NULL;';	\
-	    echo 'static int maui_osLen = 0;';			\
-	) > $@
-endif
-
 # Turtle Beach MultiSound
 
 ifeq ($(CONFIG_MSNDCLAS_HAVE_BOOT),y)
--- linux-2.6.18.noarch/sound/oss/via82cxxx_audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/via82cxxx_audio.c	2007-06-05 17:44:14.000000000 -0400
@@ -1547,7 +1547,7 @@
 
 	DPRINTK ("ENTER\n");
 
-	while ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
+	while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
 		drvr = pci_dev_driver (pdev);
 		if (drvr == &via_driver) {
 			assert (pci_get_drvdata (pdev) != NULL);
@@ -1562,6 +1562,7 @@
 	return -ENODEV;
 
 match:
+	pci_dev_put(pdev);
 	file->private_data = card->ac97;
 
 	DPRINTK ("EXIT, returning 0\n");
@@ -1618,7 +1619,7 @@
 }
 
 
-static struct file_operations via_mixer_fops = {
+static const struct file_operations via_mixer_fops = {
 	.owner		= THIS_MODULE,
 	.open		= via_mixer_open,
 	.llseek		= no_llseek,
@@ -1911,7 +1912,7 @@
 }
 
 
-static irqreturn_t  via_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t  via_interrupt(int irq, void *dev_id)
 {
 	struct via_info *card = dev_id;
 	u32 status32;
@@ -1926,7 +1927,7 @@
         {
 #ifdef CONFIG_MIDI_VIA82CXXX
 	    	 if (card->midi_devc)
-                    	uart401intr(irq, card->midi_devc, regs);
+                    	uart401intr(irq, card->midi_devc);
 #endif
 		return IRQ_HANDLED;
     	}
@@ -1949,7 +1950,7 @@
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t via_new_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t via_new_interrupt(int irq, void *dev_id)
 {
 	struct via_info *card = dev_id;
 	u32 status32;
@@ -2041,7 +2042,7 @@
  *
  */
 
-static struct file_operations via_dsp_fops = {
+static const struct file_operations via_dsp_fops = {
 	.owner		= THIS_MODULE,
 	.open		= via_dsp_open,
 	.release	= via_dsp_release,
@@ -2119,8 +2120,8 @@
 		return NOPAGE_SIGBUS; /* Disallow mremap */
 	}
         if (!card) {
-		DPRINTK ("EXIT, returning NOPAGE_OOM\n");
-		return NOPAGE_OOM;	/* Nothing allocated */
+		DPRINTK ("EXIT, returning NOPAGE_SIGBUS\n");
+		return NOPAGE_SIGBUS;	/* Nothing allocated */
 	}
 
 	pgoff = vma->vm_pgoff + ((address - vma->vm_start) >> PAGE_SHIFT);
@@ -3245,7 +3246,7 @@
 	}
 
 	card = NULL;
-	while ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
+	while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
 		drvr = pci_dev_driver (pdev);
 		if (drvr == &via_driver) {
 			assert (pci_get_drvdata (pdev) != NULL);
@@ -3264,6 +3265,7 @@
 	return -ENODEV;
 
 match:
+	pci_dev_put(pdev);
 	if (nonblock) {
 		if (!mutex_trylock(&card->open_mutex)) {
 			DPRINTK ("EXIT, returning -EAGAIN\n");
--- linux-2.6.18.noarch/sound/oss/ad1848.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ad1848.h	2007-06-05 17:44:14.000000000 -0400
@@ -18,7 +18,6 @@
 int ad1848_detect (struct resource *ports, int *flags, int *osp);
 int ad1848_control(int cmd, int arg);
 
-irqreturn_t adintr(int irq, void *dev_id, struct pt_regs * dummy);
 void attach_ms_sound(struct address_info * hw_config, struct resource *ports, struct module * owner);
 
 int probe_ms_sound(struct address_info *hw_config, struct resource *ports);
--- linux-2.6.18.noarch/sound/oss/ymfpci.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ymfpci.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2692 +0,0 @@
-/*
- *  Copyright 1999 Jaroslav Kysela <perex@suse.cz>
- *  Copyright 2000 Alan Cox <alan@redhat.com>
- *  Copyright 2001 Kai Germaschewski <kai@tp1.ruhr-uni-bochum.de>
- *  Copyright 2002 Pete Zaitcev <zaitcev@yahoo.com>
- *
- *  Yamaha YMF7xx driver.
- *
- *  This code is a result of high-speed collision
- *  between ymfpci.c of ALSA and cs46xx.c of Linux.
- *  -- Pete Zaitcev <zaitcev@yahoo.com>; 2000/09/18
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * TODO:
- *  - Use P44Slot for 44.1 playback (beware of idle buzzing in P44Slot).
- *  - 96KHz playback for DVD - use pitch of 2.0.
- *  - Retain DMA buffer on close, do not wait the end of frame.
- *  - Resolve XXX tagged questions.
- *  - Cannot play 5133Hz.
- *  - 2001/01/07 Consider if we can remove voice_lock, like so:
- *     : Allocate/deallocate voices in open/close under semafore.
- *     : We access voices in interrupt, that only for pcms that open.
- *    voice_lock around playback_prepare closes interrupts for insane duration.
- *  - Revisit the way voice_alloc is done - too confusing, overcomplicated.
- *    Should support various channel types, however.
- *  - Remove prog_dmabuf from read/write, leave it in open.
- *  - 2001/01/07 Replace the OPL3 part of CONFIG_SOUND_YMFPCI_LEGACY code with
- *    native synthesizer through a playback slot.
- *  - 2001/11/29 ac97_save_state
- *    Talk to Kai to remove ac97_save_state before it's too late!
- *  - Second AC97
- *  - Restore S/PDIF - Toshibas have it.
- *
- * Kai used pci_alloc_consistent for DMA buffer, which sounds a little
- * unconventional. However, given how small our fragments can be,
- * a little uncached access is perhaps better than endless flushing.
- * On i386 and other I/O-coherent architectures pci_alloc_consistent
- * is entirely harmless.
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/slab.h>
-#include <linux/poll.h>
-#include <linux/soundcard.h>
-#include <linux/ac97_codec.h>
-#include <linux/sound.h>
-
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <asm/uaccess.h>
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-# include "sound_config.h"
-# include "mpu401.h"
-#endif
-#include "ymfpci.h"
-
-/*
- * I do not believe in debug levels as I never can guess what
- * part of the code is going to be problematic in the future.
- * Don't forget to run your klogd with -c 8.
- *
- * Example (do not remove):
- * #define YMFDBG(fmt, arg...)  do{ printk(KERN_DEBUG fmt, ##arg); }while(0)
- */
-#define YMFDBGW(fmt, arg...)  /* */	/* write counts */
-#define YMFDBGI(fmt, arg...)  /* */	/* interrupts */
-#define YMFDBGX(fmt, arg...)  /* */	/* ioctl */
-
-static int ymf_playback_trigger(ymfpci_t *unit, struct ymf_pcm *ypcm, int cmd);
-static void ymf_capture_trigger(ymfpci_t *unit, struct ymf_pcm *ypcm, int cmd);
-static void ymfpci_voice_free(ymfpci_t *unit, ymfpci_voice_t *pvoice);
-static int ymf_capture_alloc(struct ymf_unit *unit, int *pbank);
-static int ymf_playback_prepare(struct ymf_state *state);
-static int ymf_capture_prepare(struct ymf_state *state);
-static struct ymf_state *ymf_state_alloc(ymfpci_t *unit);
-
-static void ymfpci_aclink_reset(struct pci_dev * pci);
-static void ymfpci_disable_dsp(ymfpci_t *unit);
-static void ymfpci_download_image(ymfpci_t *codec);
-static void ymf_memload(ymfpci_t *unit);
-
-static DEFINE_SPINLOCK(ymf_devs_lock);
-static LIST_HEAD(ymf_devs);
-
-/*
- *  constants
- */
-
-static struct pci_device_id ymf_id_tbl[] = {
-#define DEV(dev, data) \
-	{ PCI_VENDOR_ID_YAMAHA, dev, PCI_ANY_ID, PCI_ANY_ID, 0, 0, \
-		(unsigned long)data }
-	DEV (PCI_DEVICE_ID_YAMAHA_724,  "YMF724"),
-	DEV (PCI_DEVICE_ID_YAMAHA_724F, "YMF724F"),
-	DEV (PCI_DEVICE_ID_YAMAHA_740,  "YMF740"),
-	DEV (PCI_DEVICE_ID_YAMAHA_740C, "YMF740C"),
-	DEV (PCI_DEVICE_ID_YAMAHA_744,  "YMF744"),
-	DEV (PCI_DEVICE_ID_YAMAHA_754,  "YMF754"),
-#undef DEV
-	{ }
-};
-MODULE_DEVICE_TABLE(pci, ymf_id_tbl);
-
-/*
- *  common I/O routines
- */
-
-static inline void ymfpci_writeb(ymfpci_t *codec, u32 offset, u8 val)
-{
-	writeb(val, codec->reg_area_virt + offset);
-}
-
-static inline u16 ymfpci_readw(ymfpci_t *codec, u32 offset)
-{
-	return readw(codec->reg_area_virt + offset);
-}
-
-static inline void ymfpci_writew(ymfpci_t *codec, u32 offset, u16 val)
-{
-	writew(val, codec->reg_area_virt + offset);
-}
-
-static inline u32 ymfpci_readl(ymfpci_t *codec, u32 offset)
-{
-	return readl(codec->reg_area_virt + offset);
-}
-
-static inline void ymfpci_writel(ymfpci_t *codec, u32 offset, u32 val)
-{
-	writel(val, codec->reg_area_virt + offset);
-}
-
-static int ymfpci_codec_ready(ymfpci_t *codec, int secondary, int sched)
-{
-	signed long end_time;
-	u32 reg = secondary ? YDSXGR_SECSTATUSADR : YDSXGR_PRISTATUSADR;
-	
-	end_time = jiffies + 3 * (HZ / 4);
-	do {
-		if ((ymfpci_readw(codec, reg) & 0x8000) == 0)
-			return 0;
-		if (sched) {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(1);
-		}
-	} while (end_time - (signed long)jiffies >= 0);
-	printk(KERN_ERR "ymfpci_codec_ready: codec %i is not ready [0x%x]\n",
-	    secondary, ymfpci_readw(codec, reg));
-	return -EBUSY;
-}
-
-static void ymfpci_codec_write(struct ac97_codec *dev, u8 reg, u16 val)
-{
-	ymfpci_t *codec = dev->private_data;
-	u32 cmd;
-
-	spin_lock(&codec->ac97_lock);
-	/* XXX Do make use of dev->id */
-	ymfpci_codec_ready(codec, 0, 0);
-	cmd = ((YDSXG_AC97WRITECMD | reg) << 16) | val;
-	ymfpci_writel(codec, YDSXGR_AC97CMDDATA, cmd);
-	spin_unlock(&codec->ac97_lock);
-}
-
-static u16 _ymfpci_codec_read(ymfpci_t *unit, u8 reg)
-{
-	int i;
-
-	if (ymfpci_codec_ready(unit, 0, 0))
-		return ~0;
-	ymfpci_writew(unit, YDSXGR_AC97CMDADR, YDSXG_AC97READCMD | reg);
-	if (ymfpci_codec_ready(unit, 0, 0))
-		return ~0;
-	if (unit->pci->device == PCI_DEVICE_ID_YAMAHA_744 && unit->rev < 2) {
-		for (i = 0; i < 600; i++)
-			ymfpci_readw(unit, YDSXGR_PRISTATUSDATA);
-	}
-	return ymfpci_readw(unit, YDSXGR_PRISTATUSDATA);
-}
-
-static u16 ymfpci_codec_read(struct ac97_codec *dev, u8 reg)
-{
-	ymfpci_t *unit = dev->private_data;
-	u16 ret;
-	
-	spin_lock(&unit->ac97_lock);
-	ret = _ymfpci_codec_read(unit, reg);
-	spin_unlock(&unit->ac97_lock);
-	
-	return ret;
-}
-
-/*
- *  Misc routines
- */
-
-/*
- * Calculate the actual sampling rate relatetively to the base clock (48kHz).
- */
-static u32 ymfpci_calc_delta(u32 rate)
-{
-	switch (rate) {
-	case 8000:	return 0x02aaab00;
-	case 11025:	return 0x03accd00;
-	case 16000:	return 0x05555500;
-	case 22050:	return 0x07599a00;
-	case 32000:	return 0x0aaaab00;
-	case 44100:	return 0x0eb33300;
-	default:	return ((rate << 16) / 48000) << 12;
-	}
-}
-
-static u32 def_rate[8] = {
-	100, 2000, 8000, 11025, 16000, 22050, 32000, 48000
-};
-
-static u32 ymfpci_calc_lpfK(u32 rate)
-{
-	u32 i;
-	static u32 val[8] = {
-		0x00570000, 0x06AA0000, 0x18B20000, 0x20930000,
-		0x2B9A0000, 0x35A10000, 0x3EAA0000, 0x40000000
-	};
-	
-	if (rate == 44100)
-		return 0x40000000;	/* FIXME: What's the right value? */
-	for (i = 0; i < 8; i++)
-		if (rate <= def_rate[i])
-			return val[i];
-	return val[0];
-}
-
-static u32 ymfpci_calc_lpfQ(u32 rate)
-{
-	u32 i;
-	static u32 val[8] = {
-		0x35280000, 0x34A70000, 0x32020000, 0x31770000,
-		0x31390000, 0x31C90000, 0x33D00000, 0x40000000
-	};
-	
-	if (rate == 44100)
-		return 0x370A0000;
-	for (i = 0; i < 8; i++)
-		if (rate <= def_rate[i])
-			return val[i];
-	return val[0];
-}
-
-static u32 ymf_calc_lend(u32 rate)
-{
-	return (rate * YMF_SAMPF) / 48000;
-}
-
-/*
- * We ever allow only a few formats, but let's be generic, for smaller surprise.
- */
-static int ymf_pcm_format_width(int format)
-{
-	static int mask16 = AFMT_S16_LE|AFMT_S16_BE|AFMT_U16_LE|AFMT_U16_BE;
-
-	if ((format & (format-1)) != 0) {
-		printk(KERN_ERR "ymfpci: format 0x%x is not a power of 2\n", format);
-		return 8;
-	}
-
-	if (format == AFMT_IMA_ADPCM) return 4;
-	if ((format & mask16) != 0) return 16;
-	return 8;
-}
-
-static void ymf_pcm_update_shift(struct ymf_pcm_format *f)
-{
-	f->shift = 0;
-	if (f->voices == 2)
-		f->shift++;
-	if (ymf_pcm_format_width(f->format) == 16)
-		f->shift++;
-}
-
-/* Are you sure 32K is not too much? See if mpg123 skips on loaded systems. */
-#define DMABUF_DEFAULTORDER (15-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-/*
- * Allocate DMA buffer
- */
-static int alloc_dmabuf(ymfpci_t *unit, struct ymf_dmabuf *dmabuf)
-{
-	void *rawbuf = NULL;
-	dma_addr_t dma_addr;
-	int order;
-	struct page *map, *mapend;
-
-	/* alloc as big a chunk as we can */
-	for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--) {
-		rawbuf = pci_alloc_consistent(unit->pci, PAGE_SIZE << order, &dma_addr);
-		if (rawbuf)
-			break;
-	}
-	if (!rawbuf)
-		return -ENOMEM;
-
-#if 0
-	printk(KERN_DEBUG "ymfpci: allocated %ld (order = %d) bytes at %p\n",
-	       PAGE_SIZE << order, order, rawbuf);
-#endif
-
-	dmabuf->ready  = dmabuf->mapped = 0;
-	dmabuf->rawbuf = rawbuf;
-	dmabuf->dma_addr = dma_addr;
-	dmabuf->buforder = order;
-
-	/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-	mapend = virt_to_page(rawbuf + (PAGE_SIZE << order) - 1);
-	for (map = virt_to_page(rawbuf); map <= mapend; map++)
-		set_bit(PG_reserved, &map->flags);
-
-	return 0;
-}
-
-/*
- * Free DMA buffer
- */
-static void dealloc_dmabuf(ymfpci_t *unit, struct ymf_dmabuf *dmabuf)
-{
-	struct page *map, *mapend;
-
-	if (dmabuf->rawbuf) {
-		/* undo marking the pages as reserved */
-		mapend = virt_to_page(dmabuf->rawbuf + (PAGE_SIZE << dmabuf->buforder) - 1);
-		for (map = virt_to_page(dmabuf->rawbuf); map <= mapend; map++)
-			clear_bit(PG_reserved, &map->flags);
-
-		pci_free_consistent(unit->pci, PAGE_SIZE << dmabuf->buforder,
-		    dmabuf->rawbuf, dmabuf->dma_addr);
-	}
-	dmabuf->rawbuf = NULL;
-	dmabuf->mapped = dmabuf->ready = 0;
-}
-
-static int prog_dmabuf(struct ymf_state *state, int rec)
-{
-	struct ymf_dmabuf *dmabuf;
-	int w_16;
-	unsigned bufsize;
-	unsigned long flags;
-	int redzone, redfrags;
-	int ret;
-
-	w_16 = ymf_pcm_format_width(state->format.format) == 16;
-	dmabuf = rec ? &state->rpcm.dmabuf : &state->wpcm.dmabuf;
-
-	spin_lock_irqsave(&state->unit->reg_lock, flags);
-	dmabuf->hwptr = dmabuf->swptr = 0;
-	dmabuf->total_bytes = 0;
-	dmabuf->count = 0;
-	spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-
-	/* allocate DMA buffer if not allocated yet */
-	if (!dmabuf->rawbuf)
-		if ((ret = alloc_dmabuf(state->unit, dmabuf)))
-			return ret;
-
-	/*
-	 * Create fake fragment sizes and numbers for OSS ioctls.
-	 * Import what Doom might have set with SNDCTL_DSP_SETFRAGMENT.
-	 */
-	bufsize = PAGE_SIZE << dmabuf->buforder;
-	/* By default we give 4 big buffers. */
-	dmabuf->fragshift = (dmabuf->buforder + PAGE_SHIFT - 2);
-	if (dmabuf->ossfragshift > 3 &&
-	    dmabuf->ossfragshift < dmabuf->fragshift) {
-		/* If OSS set smaller fragments, give more smaller buffers. */
-		dmabuf->fragshift = dmabuf->ossfragshift;
-	}
-	dmabuf->fragsize = 1 << dmabuf->fragshift;
-
-	dmabuf->numfrag = bufsize >> dmabuf->fragshift;
-	dmabuf->dmasize = dmabuf->numfrag << dmabuf->fragshift;
-
-	if (dmabuf->ossmaxfrags >= 2) {
-		redzone = ymf_calc_lend(state->format.rate);
-		redzone <<= state->format.shift;
-		redzone *= 3;
-		redfrags = (redzone + dmabuf->fragsize-1) >> dmabuf->fragshift;
-
-		if (dmabuf->ossmaxfrags + redfrags < dmabuf->numfrag) {
-			dmabuf->numfrag = dmabuf->ossmaxfrags + redfrags;
-			dmabuf->dmasize = dmabuf->numfrag << dmabuf->fragshift;
-		}
-	}
-
-	memset(dmabuf->rawbuf, w_16 ? 0 : 0x80, dmabuf->dmasize);
-
-	/*
-	 *	Now set up the ring 
-	 */
-
-	/* XXX   ret = rec? cap_pre(): pbk_pre();  */
-	spin_lock_irqsave(&state->unit->voice_lock, flags);
-	if (rec) {
-		if ((ret = ymf_capture_prepare(state)) != 0) {
-			spin_unlock_irqrestore(&state->unit->voice_lock, flags);
-			return ret;
-		}
-	} else {
-		if ((ret = ymf_playback_prepare(state)) != 0) {
-			spin_unlock_irqrestore(&state->unit->voice_lock, flags);
-			return ret;
-		}
-	}
-	spin_unlock_irqrestore(&state->unit->voice_lock, flags);
-
-	/* set the ready flag for the dma buffer (this comment is not stupid) */
-	dmabuf->ready = 1;
-
-#if 0
-	printk(KERN_DEBUG "prog_dmabuf: rate %d format 0x%x,"
-	    " numfrag %d fragsize %d dmasize %d\n",
-	       state->format.rate, state->format.format, dmabuf->numfrag,
-	       dmabuf->fragsize, dmabuf->dmasize);
-#endif
-
-	return 0;
-}
-
-static void ymf_start_dac(struct ymf_state *state)
-{
-	ymf_playback_trigger(state->unit, &state->wpcm, 1);
-}
-
-// static void ymf_start_adc(struct ymf_state *state)
-// {
-// 	ymf_capture_trigger(state->unit, &state->rpcm, 1);
-// }
-
-/*
- * Wait until output is drained.
- * This does not kill the hardware for the sake of ioctls.
- */
-static void ymf_wait_dac(struct ymf_state *state)
-{
-	struct ymf_unit *unit = state->unit;
-	struct ymf_pcm *ypcm = &state->wpcm;
-	DECLARE_WAITQUEUE(waita, current);
-	unsigned long flags;
-
-	add_wait_queue(&ypcm->dmabuf.wait, &waita);
-
-	spin_lock_irqsave(&unit->reg_lock, flags);
-	if (ypcm->dmabuf.count != 0 && !ypcm->running) {
-		ymf_playback_trigger(unit, ypcm, 1);
-	}
-
-#if 0
-	if (file->f_flags & O_NONBLOCK) {
-		/*
-		 * XXX Our  mistake is to attach DMA buffer to state
-		 * rather than to some per-device structure.
-		 * Cannot skip waiting, can only make it shorter.
-		 */
-	}
-#endif
-
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	while (ypcm->running) {
-		spin_unlock_irqrestore(&unit->reg_lock, flags);
-		schedule();
-		spin_lock_irqsave(&unit->reg_lock, flags);
-		set_current_state(TASK_UNINTERRUPTIBLE);
-	}
-	spin_unlock_irqrestore(&unit->reg_lock, flags);
-
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&ypcm->dmabuf.wait, &waita);
-
-	/*
-	 * This function may take up to 4 seconds to reach this point
-	 * (32K circular buffer, 8000 Hz). User notices.
-	 */
-}
-
-/* Can just stop, without wait. Or can we? */
-static void ymf_stop_adc(struct ymf_state *state)
-{
-	struct ymf_unit *unit = state->unit;
-	unsigned long flags;
-
-	spin_lock_irqsave(&unit->reg_lock, flags);
-	ymf_capture_trigger(unit, &state->rpcm, 0);
-	spin_unlock_irqrestore(&unit->reg_lock, flags);
-}
-
-/*
- *  Hardware start management
- */
-
-static void ymfpci_hw_start(ymfpci_t *unit)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&unit->reg_lock, flags);
-	if (unit->start_count++ == 0) {
-		ymfpci_writel(unit, YDSXGR_MODE,
-		    ymfpci_readl(unit, YDSXGR_MODE) | 3);
-		unit->active_bank = ymfpci_readl(unit, YDSXGR_CTRLSELECT) & 1;
-	}
-	spin_unlock_irqrestore(&unit->reg_lock, flags);
-}
-
-static void ymfpci_hw_stop(ymfpci_t *unit)
-{
-	unsigned long flags;
-	long timeout = 1000;
-
-	spin_lock_irqsave(&unit->reg_lock, flags);
-	if (--unit->start_count == 0) {
-		ymfpci_writel(unit, YDSXGR_MODE,
-		    ymfpci_readl(unit, YDSXGR_MODE) & ~3);
-		while (timeout-- > 0) {
-			if ((ymfpci_readl(unit, YDSXGR_STATUS) & 2) == 0)
-				break;
-		}
-	}
-	spin_unlock_irqrestore(&unit->reg_lock, flags);
-}
-
-/*
- *  Playback voice management
- */
-
-static int voice_alloc(ymfpci_t *codec, ymfpci_voice_type_t type, int pair, ymfpci_voice_t *rvoice[])
-{
-	ymfpci_voice_t *voice, *voice2;
-	int idx;
-
-	for (idx = 0; idx < YDSXG_PLAYBACK_VOICES; idx += pair ? 2 : 1) {
-		voice = &codec->voices[idx];
-		voice2 = pair ? &codec->voices[idx+1] : NULL;
-		if (voice->use || (voice2 && voice2->use))
-			continue;
-		voice->use = 1;
-		if (voice2)
-			voice2->use = 1;
-		switch (type) {
-		case YMFPCI_PCM:
-			voice->pcm = 1;
-			if (voice2)
-				voice2->pcm = 1;
-			break;
-		case YMFPCI_SYNTH:
-			voice->synth = 1;
-			break;
-		case YMFPCI_MIDI:
-			voice->midi = 1;
-			break;
-		}
-		ymfpci_hw_start(codec);
-		rvoice[0] = voice;
-		if (voice2) {
-			ymfpci_hw_start(codec);
-			rvoice[1] = voice2;
-		}
-		return 0;
-	}
-	return -EBUSY;	/* Your audio channel is open by someone else. */
-}
-
-static void ymfpci_voice_free(ymfpci_t *unit, ymfpci_voice_t *pvoice)
-{
-	ymfpci_hw_stop(unit);
-	pvoice->use = pvoice->pcm = pvoice->synth = pvoice->midi = 0;
-	pvoice->ypcm = NULL;
-}
-
-/*
- */
-
-static void ymf_pcm_interrupt(ymfpci_t *codec, ymfpci_voice_t *voice)
-{
-	struct ymf_pcm *ypcm;
-	int redzone;
-	int pos, delta, swptr;
-	int played, distance;
-	struct ymf_state *state;
-	struct ymf_dmabuf *dmabuf;
-	char silence;
-
-	if ((ypcm = voice->ypcm) == NULL) {
-		return;
-	}
-	if ((state = ypcm->state) == NULL) {
-		ypcm->running = 0;	// lock it
-		return;
-	}
-	dmabuf = &ypcm->dmabuf;
-	spin_lock(&codec->reg_lock);
-	if (ypcm->running) {
-		YMFDBGI("ymfpci: %d, intr bank %d count %d start 0x%x:%x\n",
-		   voice->number, codec->active_bank, dmabuf->count,
-		   le32_to_cpu(voice->bank[0].start),
-		   le32_to_cpu(voice->bank[1].start));
-		silence = (ymf_pcm_format_width(state->format.format) == 16) ?
-		    0 : 0x80;
-		/* We need actual left-hand-side redzone size here. */
-		redzone = ymf_calc_lend(state->format.rate);
-		redzone <<= (state->format.shift + 1);
-		swptr = dmabuf->swptr;
-
-		pos = le32_to_cpu(voice->bank[codec->active_bank].start);
-		pos <<= state->format.shift;
-		if (pos < 0 || pos >= dmabuf->dmasize) {	/* ucode bug */
-			printk(KERN_ERR "ymfpci%d: runaway voice %d: hwptr %d=>%d dmasize %d\n",
-			    codec->dev_audio, voice->number,
-			    dmabuf->hwptr, pos, dmabuf->dmasize);
-			pos = 0;
-		}
-		if (pos < dmabuf->hwptr) {
-			delta = dmabuf->dmasize - dmabuf->hwptr;
-			memset(dmabuf->rawbuf + dmabuf->hwptr, silence, delta);
-			delta += pos;
-			memset(dmabuf->rawbuf, silence, pos);
-		} else {
-			delta = pos - dmabuf->hwptr;
-			memset(dmabuf->rawbuf + dmabuf->hwptr, silence, delta);
-		}
-		dmabuf->hwptr = pos;
-
-		if (dmabuf->count == 0) {
-			printk(KERN_ERR "ymfpci%d: %d: strain: hwptr %d\n",
-			    codec->dev_audio, voice->number, dmabuf->hwptr);
-			ymf_playback_trigger(codec, ypcm, 0);
-		}
-
-		if (swptr <= pos) {
-			distance = pos - swptr;
-		} else {
-			distance = dmabuf->dmasize - (swptr - pos);
-		}
-		if (distance < redzone) {
-			/*
-			 * hwptr inside redzone => DMA ran out of samples.
-			 */
-			if (delta < dmabuf->count) {
-				/*
-				 * Lost interrupt or other screwage.
-				 */
-				printk(KERN_ERR "ymfpci%d: %d: lost: delta %d"
-				    " hwptr %d swptr %d distance %d count %d\n",
-				    codec->dev_audio, voice->number, delta,
-				    dmabuf->hwptr, swptr, distance, dmabuf->count);
-			} else {
-				/*
-				 * Normal end of DMA.
-				 */
-				YMFDBGI("ymfpci%d: %d: done: delta %d"
-				    " hwptr %d swptr %d distance %d count %d\n",
-				    codec->dev_audio, voice->number, delta,
-				    dmabuf->hwptr, swptr, distance, dmabuf->count);
-			}
-			played = dmabuf->count;
-			if (ypcm->running) {
-				ymf_playback_trigger(codec, ypcm, 0);
-			}
-		} else {
-			/*
-			 * hwptr is chipping away towards a remote swptr.
-			 * Calculate other distance and apply it to count.
-			 */
-			if (swptr >= pos) {
-				distance = swptr - pos;
-			} else {
-				distance = dmabuf->dmasize - (pos - swptr);
-			}
-			if (distance < dmabuf->count) {
-				played = dmabuf->count - distance;
-			} else {
-				played = 0;
-			}
-		}
-
-		dmabuf->total_bytes += played;
-		dmabuf->count -= played;
-		if (dmabuf->count < dmabuf->dmasize / 2) {
-			wake_up(&dmabuf->wait);
-		}
-	}
-	spin_unlock(&codec->reg_lock);
-}
-
-static void ymf_cap_interrupt(ymfpci_t *unit, struct ymf_capture *cap)
-{
-	struct ymf_pcm *ypcm;
-	int redzone;
-	struct ymf_state *state;
-	struct ymf_dmabuf *dmabuf;
-	int pos, delta;
-	int cnt;
-
-	if ((ypcm = cap->ypcm) == NULL) {
-		return;
-	}
-	if ((state = ypcm->state) == NULL) {
-		ypcm->running = 0;	// lock it
-		return;
-	}
-	dmabuf = &ypcm->dmabuf;
-	spin_lock(&unit->reg_lock);
-	if (ypcm->running) {
-		redzone = ymf_calc_lend(state->format.rate);
-		redzone <<= (state->format.shift + 1);
-
-		pos = le32_to_cpu(cap->bank[unit->active_bank].start);
-		// pos <<= state->format.shift;
-		if (pos < 0 || pos >= dmabuf->dmasize) {	/* ucode bug */
-			printk(KERN_ERR "ymfpci%d: runaway capture %d: hwptr %d=>%d dmasize %d\n",
-			    unit->dev_audio, ypcm->capture_bank_number,
-			    dmabuf->hwptr, pos, dmabuf->dmasize);
-			pos = 0;
-		}
-		if (pos < dmabuf->hwptr) {
-			delta = dmabuf->dmasize - dmabuf->hwptr;
-			delta += pos;
-		} else {
-			delta = pos - dmabuf->hwptr;
-		}
-		dmabuf->hwptr = pos;
-
-		cnt = dmabuf->count;
-		cnt += delta;
-		if (cnt + redzone > dmabuf->dmasize) {
-			/* Overflow - bump swptr */
-			dmabuf->count = dmabuf->dmasize - redzone;
-			dmabuf->swptr = dmabuf->hwptr + redzone;
-			if (dmabuf->swptr >= dmabuf->dmasize) {
-				dmabuf->swptr -= dmabuf->dmasize;
-			}
-		} else {
-			dmabuf->count = cnt;
-		}
-
-		dmabuf->total_bytes += delta;
-		if (dmabuf->count) {		/* && is_sleeping  XXX */
-			wake_up(&dmabuf->wait);
-		}
-	}
-	spin_unlock(&unit->reg_lock);
-}
-
-static int ymf_playback_trigger(ymfpci_t *codec, struct ymf_pcm *ypcm, int cmd)
-{
-
-	if (ypcm->voices[0] == NULL) {
-		return -EINVAL;
-	}
-	if (cmd != 0) {
-		codec->ctrl_playback[ypcm->voices[0]->number + 1] =
-		    cpu_to_le32(ypcm->voices[0]->bank_ba);
-		if (ypcm->voices[1] != NULL)
-			codec->ctrl_playback[ypcm->voices[1]->number + 1] =
-			    cpu_to_le32(ypcm->voices[1]->bank_ba);
-		ypcm->running = 1;
-	} else {
-		codec->ctrl_playback[ypcm->voices[0]->number + 1] = 0;
-		if (ypcm->voices[1] != NULL)
-			codec->ctrl_playback[ypcm->voices[1]->number + 1] = 0;
-		ypcm->running = 0;
-	}
-	return 0;
-}
-
-static void ymf_capture_trigger(ymfpci_t *codec, struct ymf_pcm *ypcm, int cmd)
-{
-	u32 tmp;
-
-	if (cmd != 0) {
-		tmp = ymfpci_readl(codec, YDSXGR_MAPOFREC) | (1 << ypcm->capture_bank_number);
-		ymfpci_writel(codec, YDSXGR_MAPOFREC, tmp);
-		ypcm->running = 1;
-	} else {
-		tmp = ymfpci_readl(codec, YDSXGR_MAPOFREC) & ~(1 << ypcm->capture_bank_number);
-		ymfpci_writel(codec, YDSXGR_MAPOFREC, tmp);
-		ypcm->running = 0;
-	}
-}
-
-static int ymfpci_pcm_voice_alloc(struct ymf_pcm *ypcm, int voices)
-{
-	struct ymf_unit *unit;
-	int err;
-
-	unit = ypcm->state->unit;
-	if (ypcm->voices[1] != NULL && voices < 2) {
-		ymfpci_voice_free(unit, ypcm->voices[1]);
-		ypcm->voices[1] = NULL;
-	}
-	if (voices == 1 && ypcm->voices[0] != NULL)
-		return 0;		/* already allocated */
-	if (voices == 2 && ypcm->voices[0] != NULL && ypcm->voices[1] != NULL)
-		return 0;		/* already allocated */
-	if (voices > 1) {
-		if (ypcm->voices[0] != NULL && ypcm->voices[1] == NULL) {
-			ymfpci_voice_free(unit, ypcm->voices[0]);
-			ypcm->voices[0] = NULL;
-		}		
-		if ((err = voice_alloc(unit, YMFPCI_PCM, 1, ypcm->voices)) < 0)
-			return err;
-		ypcm->voices[0]->ypcm = ypcm;
-		ypcm->voices[1]->ypcm = ypcm;
-	} else {
-		if ((err = voice_alloc(unit, YMFPCI_PCM, 0, ypcm->voices)) < 0)
-			return err;
-		ypcm->voices[0]->ypcm = ypcm;
-	}
-	return 0;
-}
-
-static void ymf_pcm_init_voice(ymfpci_voice_t *voice, int stereo,
-    int rate, int w_16, unsigned long addr, unsigned int end, int spdif)
-{
-	u32 format;
-	u32 delta = ymfpci_calc_delta(rate);
-	u32 lpfQ = ymfpci_calc_lpfQ(rate);
-	u32 lpfK = ymfpci_calc_lpfK(rate);
-	ymfpci_playback_bank_t *bank;
-	int nbank;
-
-	/*
-	 * The gain is a floating point number. According to the manual,
-	 * bit 31 indicates a sign bit, bit 30 indicates an integer part,
-	 * and bits [29:15] indicate a decimal fraction part. Thus,
-	 * for a gain of 1.0 the constant of 0x40000000 is loaded.
-	 */
-	unsigned default_gain = cpu_to_le32(0x40000000);
-
-	format = (stereo ? 0x00010000 : 0) | (w_16 ? 0 : 0x80000000);
-	if (stereo)
-		end >>= 1;
-	if (w_16)
-		end >>= 1;
-	for (nbank = 0; nbank < 2; nbank++) {
-		bank = &voice->bank[nbank];
-		bank->format = cpu_to_le32(format);
-		bank->loop_default = 0;	/* 0-loops forever, otherwise count */
-		bank->base = cpu_to_le32(addr);
-		bank->loop_start = 0;
-		bank->loop_end = cpu_to_le32(end);
-		bank->loop_frac = 0;
-		bank->eg_gain_end = default_gain;
-		bank->lpfQ = cpu_to_le32(lpfQ);
-		bank->status = 0;
-		bank->num_of_frames = 0;
-		bank->loop_count = 0;
-		bank->start = 0;
-		bank->start_frac = 0;
-		bank->delta =
-		bank->delta_end = cpu_to_le32(delta);
-		bank->lpfK =
-		bank->lpfK_end = cpu_to_le32(lpfK);
-		bank->eg_gain = default_gain;
-		bank->lpfD1 =
-		bank->lpfD2 = 0;
-
-		bank->left_gain = 
-		bank->right_gain =
-		bank->left_gain_end =
-		bank->right_gain_end =
-		bank->eff1_gain =
-		bank->eff2_gain =
-		bank->eff3_gain =
-		bank->eff1_gain_end =
-		bank->eff2_gain_end =
-		bank->eff3_gain_end = 0;
-
-		if (!stereo) {
-			if (!spdif) {
-				bank->left_gain = 
-				bank->right_gain =
-				bank->left_gain_end =
-				bank->right_gain_end = default_gain;
-			} else {
-				bank->eff2_gain =
-				bank->eff2_gain_end =
-				bank->eff3_gain =
-				bank->eff3_gain_end = default_gain;
-			}
-		} else {
-			if (!spdif) {
-				if ((voice->number & 1) == 0) {
-					bank->left_gain =
-					bank->left_gain_end = default_gain;
-				} else {
-					bank->format |= cpu_to_le32(1);
-					bank->right_gain =
-					bank->right_gain_end = default_gain;
-				}
-			} else {
-				if ((voice->number & 1) == 0) {
-					bank->eff2_gain =
-					bank->eff2_gain_end = default_gain;
-				} else {
-					bank->format |= cpu_to_le32(1);
-					bank->eff3_gain =
-					bank->eff3_gain_end = default_gain;
-				}
-			}
-		}
-	}
-}
-
-/*
- * XXX Capture channel allocation is entirely fake at the moment.
- * We use only one channel and mark it busy as required.
- */
-static int ymf_capture_alloc(struct ymf_unit *unit, int *pbank)
-{
-	struct ymf_capture *cap;
-	int cbank;
-
-	cbank = 1;		/* Only ADC slot is used for now. */
-	cap = &unit->capture[cbank];
-	if (cap->use)
-		return -EBUSY;
-	cap->use = 1;
-	*pbank = cbank;
-	return 0;
-}
-
-static int ymf_playback_prepare(struct ymf_state *state)
-{
-	struct ymf_pcm *ypcm = &state->wpcm;
-	int err, nvoice;
-
-	if ((err = ymfpci_pcm_voice_alloc(ypcm, state->format.voices)) < 0) {
-		/* Somebody started 32 mpg123's in parallel? */
-		printk(KERN_INFO "ymfpci%d: cannot allocate voice\n",
-		    state->unit->dev_audio);
-		return err;
-	}
-
-	for (nvoice = 0; nvoice < state->format.voices; nvoice++) {
-		ymf_pcm_init_voice(ypcm->voices[nvoice],
-		    state->format.voices == 2, state->format.rate,
-		    ymf_pcm_format_width(state->format.format) == 16,
-		    ypcm->dmabuf.dma_addr, ypcm->dmabuf.dmasize,
-		    ypcm->spdif);
-	}
-	return 0;
-}
-
-static int ymf_capture_prepare(struct ymf_state *state)
-{
-	ymfpci_t *unit = state->unit;
-	struct ymf_pcm *ypcm = &state->rpcm;
-	ymfpci_capture_bank_t * bank;
-	/* XXX This is confusing, gotta rename one of them banks... */
-	int nbank;		/* flip-flop bank */
-	int cbank;		/* input [super-]bank */
-	struct ymf_capture *cap;
-	u32 rate, format;
-
-	if (ypcm->capture_bank_number == -1) {
-		if (ymf_capture_alloc(unit, &cbank) != 0)
-			return -EBUSY;
-
-		ypcm->capture_bank_number = cbank;
-
-		cap = &unit->capture[cbank];
-		cap->bank = unit->bank_capture[cbank][0];
-		cap->ypcm = ypcm;
-		ymfpci_hw_start(unit);
-	}
-
-	// ypcm->frag_size = snd_pcm_lib_transfer_fragment(substream);
-	// frag_size is replaced with nonfragged byte-aligned rolling buffer
-	rate = ((48000 * 4096) / state->format.rate) - 1;
-	format = 0;
-	if (state->format.voices == 2)
-		format |= 2;
-	if (ymf_pcm_format_width(state->format.format) == 8)
-		format |= 1;
-	switch (ypcm->capture_bank_number) {
-	case 0:
-		ymfpci_writel(unit, YDSXGR_RECFORMAT, format);
-		ymfpci_writel(unit, YDSXGR_RECSLOTSR, rate);
-		break;
-	case 1:
-		ymfpci_writel(unit, YDSXGR_ADCFORMAT, format);
-		ymfpci_writel(unit, YDSXGR_ADCSLOTSR, rate);
-		break;
-	}
-	for (nbank = 0; nbank < 2; nbank++) {
-		bank = unit->bank_capture[ypcm->capture_bank_number][nbank];
-		bank->base = cpu_to_le32(ypcm->dmabuf.dma_addr);
-		// bank->loop_end = ypcm->dmabuf.dmasize >> state->format.shift;
-		bank->loop_end = cpu_to_le32(ypcm->dmabuf.dmasize);
-		bank->start = 0;
-		bank->num_of_loops = 0;
-	}
-#if 0 /* s/pdif */
-	if (state->digital.dig_valid)
-		/*state->digital.type == SND_PCM_DIG_AES_IEC958*/
-		ymfpci_writew(codec, YDSXGR_SPDIFOUTSTATUS,
-		    state->digital.dig_status[0] | (state->digital.dig_status[1] << 8));
-#endif
-	return 0;
-}
-
-static irqreturn_t ymf_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	ymfpci_t *codec = dev_id;
-	u32 status, nvoice, mode;
-	struct ymf_voice *voice;
-	struct ymf_capture *cap;
-
-	status = ymfpci_readl(codec, YDSXGR_STATUS);
-	if (status & 0x80000000) {
-		codec->active_bank = ymfpci_readl(codec, YDSXGR_CTRLSELECT) & 1;
-		spin_lock(&codec->voice_lock);
-		for (nvoice = 0; nvoice < YDSXG_PLAYBACK_VOICES; nvoice++) {
-			voice = &codec->voices[nvoice];
-			if (voice->use)
-				ymf_pcm_interrupt(codec, voice);
-		}
-		for (nvoice = 0; nvoice < YDSXG_CAPTURE_VOICES; nvoice++) {
-			cap = &codec->capture[nvoice];
-			if (cap->use)
-				ymf_cap_interrupt(codec, cap);
-		}
-		spin_unlock(&codec->voice_lock);
-		spin_lock(&codec->reg_lock);
-		ymfpci_writel(codec, YDSXGR_STATUS, 0x80000000);
-		mode = ymfpci_readl(codec, YDSXGR_MODE) | 2;
-		ymfpci_writel(codec, YDSXGR_MODE, mode);
-		spin_unlock(&codec->reg_lock);
-	}
-
-	status = ymfpci_readl(codec, YDSXGR_INTFLAG);
-	if (status & 1) {
-		/* timer handler */
-		ymfpci_writel(codec, YDSXGR_INTFLAG, ~0);
-	}
-	return IRQ_HANDLED;
-}
-
-static void ymf_pcm_free_substream(struct ymf_pcm *ypcm)
-{
-	unsigned long flags;
-	struct ymf_unit *unit;
-
-	unit = ypcm->state->unit;
-
-	if (ypcm->type == PLAYBACK_VOICE) {
-		spin_lock_irqsave(&unit->voice_lock, flags);
-		if (ypcm->voices[1])
-			ymfpci_voice_free(unit, ypcm->voices[1]);
-		if (ypcm->voices[0])
-			ymfpci_voice_free(unit, ypcm->voices[0]);
-		spin_unlock_irqrestore(&unit->voice_lock, flags);
-	} else {
-		if (ypcm->capture_bank_number != -1) {
-			unit->capture[ypcm->capture_bank_number].use = 0;
-			ypcm->capture_bank_number = -1;
-			ymfpci_hw_stop(unit);
-		}
-	}
-}
-
-static struct ymf_state *ymf_state_alloc(ymfpci_t *unit)
-{
-	struct ymf_pcm *ypcm;
-	struct ymf_state *state;
-
-	if ((state = kmalloc(sizeof(struct ymf_state), GFP_KERNEL)) == NULL) {
-		goto out0;
-	}
-	memset(state, 0, sizeof(struct ymf_state));
-
-	ypcm = &state->wpcm;
-	ypcm->state = state;
-	ypcm->type = PLAYBACK_VOICE;
-	ypcm->capture_bank_number = -1;
-	init_waitqueue_head(&ypcm->dmabuf.wait);
-
-	ypcm = &state->rpcm;
-	ypcm->state = state;
-	ypcm->type = CAPTURE_AC97;
-	ypcm->capture_bank_number = -1;
-	init_waitqueue_head(&ypcm->dmabuf.wait);
-
-	state->unit = unit;
-
-	state->format.format = AFMT_U8;
-	state->format.rate = 8000;
-	state->format.voices = 1;
-	ymf_pcm_update_shift(&state->format);
-
-	return state;
-
-out0:
-	return NULL;
-}
-
-/* AES/IEC958 channel status bits */
-#define SND_PCM_AES0_PROFESSIONAL	(1<<0)	/* 0 = consumer, 1 = professional */
-#define SND_PCM_AES0_NONAUDIO		(1<<1)	/* 0 = audio, 1 = non-audio */
-#define SND_PCM_AES0_PRO_EMPHASIS	(7<<2)	/* mask - emphasis */
-#define SND_PCM_AES0_PRO_EMPHASIS_NOTID	(0<<2)	/* emphasis not indicated */
-#define SND_PCM_AES0_PRO_EMPHASIS_NONE	(1<<2)	/* none emphasis */
-#define SND_PCM_AES0_PRO_EMPHASIS_5015	(3<<2)	/* 50/15us emphasis */
-#define SND_PCM_AES0_PRO_EMPHASIS_CCITT	(7<<2)	/* CCITT J.17 emphasis */
-#define SND_PCM_AES0_PRO_FREQ_UNLOCKED	(1<<5)	/* source sample frequency: 0 = locked, 1 = unlocked */
-#define SND_PCM_AES0_PRO_FS		(3<<6)	/* mask - sample frequency */
-#define SND_PCM_AES0_PRO_FS_NOTID	(0<<6)	/* fs not indicated */
-#define SND_PCM_AES0_PRO_FS_44100	(1<<6)	/* 44.1kHz */
-#define SND_PCM_AES0_PRO_FS_48000	(2<<6)	/* 48kHz */
-#define SND_PCM_AES0_PRO_FS_32000	(3<<6)	/* 32kHz */
-#define SND_PCM_AES0_CON_NOT_COPYRIGHT	(1<<2)	/* 0 = copyright, 1 = not copyright */
-#define SND_PCM_AES0_CON_EMPHASIS	(7<<3)	/* mask - emphasis */
-#define SND_PCM_AES0_CON_EMPHASIS_NONE	(0<<3)	/* none emphasis */
-#define SND_PCM_AES0_CON_EMPHASIS_5015	(1<<3)	/* 50/15us emphasis */
-#define SND_PCM_AES0_CON_MODE		(3<<6)	/* mask - mode */
-#define SND_PCM_AES1_PRO_MODE		(15<<0)	/* mask - channel mode */
-#define SND_PCM_AES1_PRO_MODE_NOTID	(0<<0)	/* not indicated */
-#define SND_PCM_AES1_PRO_MODE_STEREOPHONIC (2<<0) /* stereophonic - ch A is left */
-#define SND_PCM_AES1_PRO_MODE_SINGLE	(4<<0)	/* single channel */
-#define SND_PCM_AES1_PRO_MODE_TWO	(8<<0)	/* two channels */
-#define SND_PCM_AES1_PRO_MODE_PRIMARY	(12<<0)	/* primary/secondary */
-#define SND_PCM_AES1_PRO_MODE_BYTE3	(15<<0)	/* vector to byte 3 */
-#define SND_PCM_AES1_PRO_USERBITS	(15<<4)	/* mask - user bits */
-#define SND_PCM_AES1_PRO_USERBITS_NOTID	(0<<4)	/* not indicated */
-#define SND_PCM_AES1_PRO_USERBITS_192	(8<<4)	/* 192-bit structure */
-#define SND_PCM_AES1_PRO_USERBITS_UDEF	(12<<4)	/* user defined application */
-#define SND_PCM_AES1_CON_CATEGORY	0x7f
-#define SND_PCM_AES1_CON_GENERAL	0x00
-#define SND_PCM_AES1_CON_EXPERIMENTAL	0x40
-#define SND_PCM_AES1_CON_SOLIDMEM_MASK	0x0f
-#define SND_PCM_AES1_CON_SOLIDMEM_ID	0x08
-#define SND_PCM_AES1_CON_BROADCAST1_MASK 0x07
-#define SND_PCM_AES1_CON_BROADCAST1_ID	0x04
-#define SND_PCM_AES1_CON_DIGDIGCONV_MASK 0x07
-#define SND_PCM_AES1_CON_DIGDIGCONV_ID	0x02
-#define SND_PCM_AES1_CON_ADC_COPYRIGHT_MASK 0x1f
-#define SND_PCM_AES1_CON_ADC_COPYRIGHT_ID 0x06
-#define SND_PCM_AES1_CON_ADC_MASK	0x1f
-#define SND_PCM_AES1_CON_ADC_ID		0x16
-#define SND_PCM_AES1_CON_BROADCAST2_MASK 0x0f
-#define SND_PCM_AES1_CON_BROADCAST2_ID	0x0e
-#define SND_PCM_AES1_CON_LASEROPT_MASK	0x07
-#define SND_PCM_AES1_CON_LASEROPT_ID	0x01
-#define SND_PCM_AES1_CON_MUSICAL_MASK	0x07
-#define SND_PCM_AES1_CON_MUSICAL_ID	0x05
-#define SND_PCM_AES1_CON_MAGNETIC_MASK	0x07
-#define SND_PCM_AES1_CON_MAGNETIC_ID	0x03
-#define SND_PCM_AES1_CON_IEC908_CD	(SND_PCM_AES1_CON_LASEROPT_ID|0x00)
-#define SND_PCM_AES1_CON_NON_IEC908_CD	(SND_PCM_AES1_CON_LASEROPT_ID|0x08)
-#define SND_PCM_AES1_CON_PCM_CODER	(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x00)
-#define SND_PCM_AES1_CON_SAMPLER	(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x20)
-#define SND_PCM_AES1_CON_MIXER		(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x10)
-#define SND_PCM_AES1_CON_RATE_CONVERTER	(SND_PCM_AES1_CON_DIGDIGCONV_ID|0x18)
-#define SND_PCM_AES1_CON_SYNTHESIZER	(SND_PCM_AES1_CON_MUSICAL_ID|0x00)
-#define SND_PCM_AES1_CON_MICROPHONE	(SND_PCM_AES1_CON_MUSICAL_ID|0x08)
-#define SND_PCM_AES1_CON_DAT		(SND_PCM_AES1_CON_MAGNETIC_ID|0x00)
-#define SND_PCM_AES1_CON_VCR		(SND_PCM_AES1_CON_MAGNETIC_ID|0x08)
-#define SND_PCM_AES1_CON_ORIGINAL	(1<<7)	/* this bits depends on the category code */
-#define SND_PCM_AES2_PRO_SBITS		(7<<0)	/* mask - sample bits */
-#define SND_PCM_AES2_PRO_SBITS_20	(2<<0)	/* 20-bit - coordination */
-#define SND_PCM_AES2_PRO_SBITS_24	(4<<0)	/* 24-bit - main audio */
-#define SND_PCM_AES2_PRO_SBITS_UDEF	(6<<0)	/* user defined application */
-#define SND_PCM_AES2_PRO_WORDLEN	(7<<3)	/* mask - source word length */
-#define SND_PCM_AES2_PRO_WORDLEN_NOTID	(0<<3)	/* not indicated */
-#define SND_PCM_AES2_PRO_WORDLEN_22_18	(2<<3)	/* 22-bit or 18-bit */
-#define SND_PCM_AES2_PRO_WORDLEN_23_19	(4<<3)	/* 23-bit or 19-bit */
-#define SND_PCM_AES2_PRO_WORDLEN_24_20	(5<<3)	/* 24-bit or 20-bit */
-#define SND_PCM_AES2_PRO_WORDLEN_20_16	(6<<3)	/* 20-bit or 16-bit */
-#define SND_PCM_AES2_CON_SOURCE		(15<<0)	/* mask - source number */
-#define SND_PCM_AES2_CON_SOURCE_UNSPEC	(0<<0)	/* unspecified */
-#define SND_PCM_AES2_CON_CHANNEL	(15<<4)	/* mask - channel number */
-#define SND_PCM_AES2_CON_CHANNEL_UNSPEC	(0<<4)	/* unspecified */
-#define SND_PCM_AES3_CON_FS		(15<<0)	/* mask - sample frequency */
-#define SND_PCM_AES3_CON_FS_44100	(0<<0)	/* 44.1kHz */
-#define SND_PCM_AES3_CON_FS_48000	(2<<0)	/* 48kHz */
-#define SND_PCM_AES3_CON_FS_32000	(3<<0)	/* 32kHz */
-#define SND_PCM_AES3_CON_CLOCK		(3<<4)	/* mask - clock accuracy */
-#define SND_PCM_AES3_CON_CLOCK_1000PPM	(0<<4)	/* 1000 ppm */
-#define SND_PCM_AES3_CON_CLOCK_50PPM	(1<<4)	/* 50 ppm */
-#define SND_PCM_AES3_CON_CLOCK_VARIABLE	(2<<4)	/* variable pitch */
-
-/*
- * User interface
- */
-
-/*
- * in this loop, dmabuf.count signifies the amount of data that is
- * waiting to be copied to the user's buffer.  it is filled by the dma
- * machine and drained by this loop.
- */
-static ssize_t
-ymf_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct ymf_state *state = (struct ymf_state *)file->private_data;
-	struct ymf_dmabuf *dmabuf = &state->rpcm.dmabuf;
-	struct ymf_unit *unit = state->unit;
-	DECLARE_WAITQUEUE(waita, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned int swptr;
-	int cnt;			/* This many to go in this revolution */
-
-	if (dmabuf->mapped)
-		return -ENXIO;
-	if (!dmabuf->ready && (ret = prog_dmabuf(state, 1)))
-		return ret;
-	ret = 0;
-
-	add_wait_queue(&dmabuf->wait, &waita);
-	set_current_state(TASK_INTERRUPTIBLE);
-	while (count > 0) {
-		spin_lock_irqsave(&unit->reg_lock, flags);
-		if (unit->suspended) {
-			spin_unlock_irqrestore(&unit->reg_lock, flags);
-			schedule();
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (signal_pending(current)) {
-				if (!ret) ret = -EAGAIN;
-				break;
-			}
-			continue;
-		}
-		swptr = dmabuf->swptr;
-		cnt = dmabuf->dmasize - swptr;
-		if (dmabuf->count < cnt)
-			cnt = dmabuf->count;
-		spin_unlock_irqrestore(&unit->reg_lock, flags);
-
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			unsigned long tmo;
-			/* buffer is empty, start the dma machine and wait for data to be
-			   recorded */
-			spin_lock_irqsave(&state->unit->reg_lock, flags);
-			if (!state->rpcm.running) {
-				ymf_capture_trigger(state->unit, &state->rpcm, 1);
-			}
-			spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret) ret = -EAGAIN;
-				break;
-			}
-			/* This isnt strictly right for the 810  but it'll do */
-			tmo = (dmabuf->dmasize * HZ) / (state->format.rate * 2);
-			tmo >>= state->format.shift;
-			/* There are two situations when sleep_on_timeout returns, one is when
-			   the interrupt is serviced correctly and the process is waked up by
-			   ISR ON TIME. Another is when timeout is expired, which means that
-			   either interrupt is NOT serviced correctly (pending interrupt) or it
-			   is TOO LATE for the process to be scheduled to run (scheduler latency)
-			   which results in a (potential) buffer overrun. And worse, there is
-			   NOTHING we can do to prevent it. */
-			tmo = schedule_timeout(tmo);
-			spin_lock_irqsave(&state->unit->reg_lock, flags);
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (tmo == 0 && dmabuf->count == 0) {
-				printk(KERN_ERR "ymfpci%d: recording schedule timeout, "
-				    "dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				    state->unit->dev_audio,
-				    dmabuf->dmasize, dmabuf->fragsize, dmabuf->count,
-				    dmabuf->hwptr, dmabuf->swptr);
-			}
-			spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			if (signal_pending(current)) {
-				if (!ret) ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-
-		if (copy_to_user(buffer, dmabuf->rawbuf + swptr, cnt)) {
-			if (!ret) ret = -EFAULT;
-			break;
-		}
-
-		swptr = (swptr + cnt) % dmabuf->dmasize;
-
-		spin_lock_irqsave(&unit->reg_lock, flags);
-		if (unit->suspended) {
-			spin_unlock_irqrestore(&unit->reg_lock, flags);
-			continue;
-		}
-
-		dmabuf->swptr = swptr;
-		dmabuf->count -= cnt;
-		// spin_unlock_irqrestore(&unit->reg_lock, flags);
-
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		// spin_lock_irqsave(&unit->reg_lock, flags);
-		if (!state->rpcm.running) {
-			ymf_capture_trigger(unit, &state->rpcm, 1);
-		}
-		spin_unlock_irqrestore(&unit->reg_lock, flags);
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dmabuf->wait, &waita);
-
-	return ret;
-}
-
-static ssize_t
-ymf_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct ymf_state *state = (struct ymf_state *)file->private_data;
-	struct ymf_dmabuf *dmabuf = &state->wpcm.dmabuf;
-	struct ymf_unit *unit = state->unit;
-	DECLARE_WAITQUEUE(waita, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned int swptr;
-	int cnt;			/* This many to go in this revolution */
-	int redzone;
-	int delay;
-
-	YMFDBGW("ymf_write: count %d\n", count);
-
-	if (dmabuf->mapped)
-		return -ENXIO;
-	if (!dmabuf->ready && (ret = prog_dmabuf(state, 0)))
-		return ret;
-	ret = 0;
-
-	/*
-	 * Alan's cs46xx works without a red zone - marvel of ingenuity.
-	 * We are not so brilliant... Red zone does two things:
-	 *  1. allows for safe start after a pause as we have no way
-	 *     to know what the actual, relentlessly advancing, hwptr is.
-	 *  2. makes computations in ymf_pcm_interrupt simpler.
-	 */
-	redzone = ymf_calc_lend(state->format.rate) << state->format.shift;
-	redzone *= 3;	/* 2 redzone + 1 possible uncertainty reserve. */
-
-	add_wait_queue(&dmabuf->wait, &waita);
-	set_current_state(TASK_INTERRUPTIBLE);
-	while (count > 0) {
-		spin_lock_irqsave(&unit->reg_lock, flags);
-		if (unit->suspended) {
-			spin_unlock_irqrestore(&unit->reg_lock, flags);
-			schedule();
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (signal_pending(current)) {
-				if (!ret) ret = -EAGAIN;
-				break;
-			}
-			continue;
-		}
-		if (dmabuf->count < 0) {
-			printk(KERN_ERR
-			   "ymf_write: count %d, was legal in cs46xx\n",
-			    dmabuf->count);
-			dmabuf->count = 0;
-		}
-		if (dmabuf->count == 0) {
-			swptr = dmabuf->hwptr;
-			if (state->wpcm.running) {
-				/*
-				 * Add uncertainty reserve.
-				 */
-				cnt = ymf_calc_lend(state->format.rate);
-				cnt <<= state->format.shift;
-				if ((swptr += cnt) >= dmabuf->dmasize) {
-					swptr -= dmabuf->dmasize;
-				}
-			}
-			dmabuf->swptr = swptr;
-		} else {
-			/*
-			 * XXX This is not right if dmabuf->count is small -
-			 * about 2*x frame size or less. We cannot count on
-			 * on appending and not causing an artefact.
-			 * Should use a variation of the count==0 case above.
-			 */
-			swptr = dmabuf->swptr;
-		}
-		cnt = dmabuf->dmasize - swptr;
-		if (dmabuf->count + cnt > dmabuf->dmasize - redzone)
-			cnt = (dmabuf->dmasize - redzone) - dmabuf->count;
-		spin_unlock_irqrestore(&unit->reg_lock, flags);
-
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			YMFDBGW("ymf_write: full, count %d swptr %d\n",
-			   dmabuf->count, dmabuf->swptr);
-			/*
-			 * buffer is full, start the dma machine and
-			 * wait for data to be played
-			 */
-			spin_lock_irqsave(&unit->reg_lock, flags);
-			if (!state->wpcm.running) {
-				ymf_playback_trigger(unit, &state->wpcm, 1);
-			}
-			spin_unlock_irqrestore(&unit->reg_lock, flags);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret) ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			set_current_state(TASK_INTERRUPTIBLE);
-			if (signal_pending(current)) {
-				if (!ret) ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(dmabuf->rawbuf + swptr, buffer, cnt)) {
-			if (!ret) ret = -EFAULT;
-			break;
-		}
-
-		if ((swptr += cnt) >= dmabuf->dmasize) {
-			swptr -= dmabuf->dmasize;
-		}
-
-		spin_lock_irqsave(&unit->reg_lock, flags);
-		if (unit->suspended) {
-			spin_unlock_irqrestore(&unit->reg_lock, flags);
-			continue;
-		}
-		dmabuf->swptr = swptr;
-		dmabuf->count += cnt;
-
-		/*
-		 * Start here is a bad idea - may cause startup click
-		 * in /bin/play when dmabuf is not full yet.
-		 * However, some broken applications do not make
-		 * any use of SNDCTL_DSP_SYNC (Doom is the worst).
-		 * One frame is about 5.3ms, Doom write size is 46ms.
-		 */
-		delay = state->format.rate / 20;	/* 50ms */
-		delay <<= state->format.shift;
-		if (dmabuf->count >= delay && !state->wpcm.running) {
-			ymf_playback_trigger(unit, &state->wpcm, 1);
-		}
-
-		spin_unlock_irqrestore(&unit->reg_lock, flags);
-
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-	}
-
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dmabuf->wait, &waita);
-
-	YMFDBGW("ymf_write: ret %d dmabuf.count %d\n", ret, dmabuf->count);
-	return ret;
-}
-
-static unsigned int ymf_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct ymf_state *state = (struct ymf_state *)file->private_data;
-	struct ymf_dmabuf *dmabuf;
-	int redzone;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	if (file->f_mode & FMODE_WRITE)
-		poll_wait(file, &state->wpcm.dmabuf.wait, wait);
-	if (file->f_mode & FMODE_READ)
-		poll_wait(file, &state->rpcm.dmabuf.wait, wait);
-
-	spin_lock_irqsave(&state->unit->reg_lock, flags);
-	if (file->f_mode & FMODE_READ) {
-		dmabuf = &state->rpcm.dmabuf;
-		if (dmabuf->count >= (signed)dmabuf->fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		redzone = ymf_calc_lend(state->format.rate);
-		redzone <<= state->format.shift;
-		redzone *= 3;
-
-		dmabuf = &state->wpcm.dmabuf;
-		if (dmabuf->mapped) {
-			if (dmabuf->count >= (signed)dmabuf->fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			/*
-			 * Don't select unless a full fragment is available.
-			 * Otherwise artsd does GETOSPACE, sees 0, and loops.
-			 */
-			if (dmabuf->count + redzone + dmabuf->fragsize
-			     <= dmabuf->dmasize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-
-	return mask;
-}
-
-static int ymf_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct ymf_state *state = (struct ymf_state *)file->private_data;
-	struct ymf_dmabuf *dmabuf = &state->wpcm.dmabuf;
-	int ret;
-	unsigned long size;
-
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf(state, 0)) != 0)
-			return ret;
-	} else if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf(state, 1)) != 0)
-			return ret;
-	} else 
-		return -EINVAL;
-
-	if (vma->vm_pgoff != 0)
-		return -EINVAL;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << dmabuf->buforder))
-		return -EINVAL;
-	if (remap_pfn_range(vma, vma->vm_start,
-			     virt_to_phys(dmabuf->rawbuf) >> PAGE_SHIFT,
-			     size, vma->vm_page_prot))
-		return -EAGAIN;
-	dmabuf->mapped = 1;
-
-/* P3 */ printk(KERN_INFO "ymfpci: using memory mapped sound, untested!\n");
-	return 0;
-}
-
-static int ymf_ioctl(struct inode *inode, struct file *file,
-    unsigned int cmd, unsigned long arg)
-{
-	struct ymf_state *state = (struct ymf_state *)file->private_data;
-	struct ymf_dmabuf *dmabuf;
-	unsigned long flags;
-	audio_buf_info abinfo;
-	count_info cinfo;
-	int redzone;
-	int val;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	switch (cmd) {
-	case OSS_GETVERSION:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETVER) arg 0x%lx\n", cmd, arg);
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_RESET:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(RESET)\n", cmd);
-		if (file->f_mode & FMODE_WRITE) {
-			ymf_wait_dac(state);
-			dmabuf = &state->wpcm.dmabuf;
-			spin_lock_irqsave(&state->unit->reg_lock, flags);
-			dmabuf->ready = 0;
-			dmabuf->swptr = dmabuf->hwptr;
-			dmabuf->count = dmabuf->total_bytes = 0;
-			spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		}
-		if (file->f_mode & FMODE_READ) {
-			ymf_stop_adc(state);
-			dmabuf = &state->rpcm.dmabuf;
-			spin_lock_irqsave(&state->unit->reg_lock, flags);
-			dmabuf->ready = 0;
-			dmabuf->swptr = dmabuf->hwptr;
-			dmabuf->count = dmabuf->total_bytes = 0;
-			spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		}
-		return 0;
-
-	case SNDCTL_DSP_SYNC:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(SYNC)\n", cmd);
-		if (file->f_mode & FMODE_WRITE) {
-			dmabuf = &state->wpcm.dmabuf;
-			if (file->f_flags & O_NONBLOCK) {
-				spin_lock_irqsave(&state->unit->reg_lock, flags);
-				if (dmabuf->count != 0 && !state->wpcm.running) {
-					ymf_start_dac(state);
-				}
-				spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			} else {
-				ymf_wait_dac(state);
-			}
-		}
-		/* XXX What does this do for reading? dmabuf->count=0; ? */
-		return 0;
-
-	case SNDCTL_DSP_SPEED: /* set smaple rate */
-		if (get_user(val, p))
-			return -EFAULT;
-		YMFDBGX("ymf_ioctl: cmd 0x%x(SPEED) sp %d\n", cmd, val);
-		if (val >= 8000 && val <= 48000) {
-			if (file->f_mode & FMODE_WRITE) {
-				ymf_wait_dac(state);
-				dmabuf = &state->wpcm.dmabuf;
-				spin_lock_irqsave(&state->unit->reg_lock, flags);
-				dmabuf->ready = 0;
-				state->format.rate = val;
-				ymf_pcm_update_shift(&state->format);
-				spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			}
-			if (file->f_mode & FMODE_READ) {
-				ymf_stop_adc(state);
-				dmabuf = &state->rpcm.dmabuf;
-				spin_lock_irqsave(&state->unit->reg_lock, flags);
-				dmabuf->ready = 0;
-				state->format.rate = val;
-				ymf_pcm_update_shift(&state->format);
-				spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			}
-		}
-		return put_user(state->format.rate, p);
-
-	/*
-	 * OSS manual does not mention SNDCTL_DSP_STEREO at all.
-	 * All channels are mono and if you want stereo, you
-	 * play into two channels with SNDCTL_DSP_CHANNELS.
-	 * However, mpg123 calls it. I wonder, why Michael Hipp used it.
-	 */
-	case SNDCTL_DSP_STEREO: /* set stereo or mono channel */
-		if (get_user(val, p))
-			return -EFAULT;
-		YMFDBGX("ymf_ioctl: cmd 0x%x(STEREO) st %d\n", cmd, val);
-		if (file->f_mode & FMODE_WRITE) {
-			ymf_wait_dac(state); 
-			dmabuf = &state->wpcm.dmabuf;
-			spin_lock_irqsave(&state->unit->reg_lock, flags);
-			dmabuf->ready = 0;
-			state->format.voices = val ? 2 : 1;
-			ymf_pcm_update_shift(&state->format);
-			spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		}
-		if (file->f_mode & FMODE_READ) {
-			ymf_stop_adc(state);
-			dmabuf = &state->rpcm.dmabuf;
-			spin_lock_irqsave(&state->unit->reg_lock, flags);
-			dmabuf->ready = 0;
-			state->format.voices = val ? 2 : 1;
-			ymf_pcm_update_shift(&state->format);
-			spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETBLK)\n", cmd);
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf(state, 0)))
-				return val;
-			val = state->wpcm.dmabuf.fragsize;
-			YMFDBGX("ymf_ioctl: GETBLK w %d\n", val);
-			return put_user(val, p);
-		}
-		if (file->f_mode & FMODE_READ) {
-			if ((val = prog_dmabuf(state, 1)))
-				return val;
-			val = state->rpcm.dmabuf.fragsize;
-			YMFDBGX("ymf_ioctl: GETBLK r %d\n", val);
-			return put_user(val, p);
-		}
-		return -EINVAL;
-
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask of supported sample format*/
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETFMTS)\n", cmd);
-		return put_user(AFMT_S16_LE|AFMT_U8, p);
-
-	case SNDCTL_DSP_SETFMT: /* Select sample format */
-		if (get_user(val, p))
-			return -EFAULT;
-		YMFDBGX("ymf_ioctl: cmd 0x%x(SETFMT) fmt %d\n", cmd, val);
-		if (val == AFMT_S16_LE || val == AFMT_U8) {
-			if (file->f_mode & FMODE_WRITE) {
-				ymf_wait_dac(state);
-				dmabuf = &state->wpcm.dmabuf;
-				spin_lock_irqsave(&state->unit->reg_lock, flags);
-				dmabuf->ready = 0;
-				state->format.format = val;
-				ymf_pcm_update_shift(&state->format);
-				spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			}
-			if (file->f_mode & FMODE_READ) {
-				ymf_stop_adc(state);
-				dmabuf = &state->rpcm.dmabuf;
-				spin_lock_irqsave(&state->unit->reg_lock, flags);
-				dmabuf->ready = 0;
-				state->format.format = val;
-				ymf_pcm_update_shift(&state->format);
-				spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-			}
-		}
-		return put_user(state->format.format, p);
-
-	case SNDCTL_DSP_CHANNELS:
-		if (get_user(val, p))
-			return -EFAULT;
-		YMFDBGX("ymf_ioctl: cmd 0x%x(CHAN) ch %d\n", cmd, val);
-		if (val != 0) {
-			if (file->f_mode & FMODE_WRITE) {
-				ymf_wait_dac(state);
-				if (val == 1 || val == 2) {
-					spin_lock_irqsave(&state->unit->reg_lock, flags);
-					dmabuf = &state->wpcm.dmabuf;
-					dmabuf->ready = 0;
-					state->format.voices = val;
-					ymf_pcm_update_shift(&state->format);
-					spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-				}
-			}
-			if (file->f_mode & FMODE_READ) {
-				ymf_stop_adc(state);
-				if (val == 1 || val == 2) {
-					spin_lock_irqsave(&state->unit->reg_lock, flags);
-					dmabuf = &state->rpcm.dmabuf;
-					dmabuf->ready = 0;
-					state->format.voices = val;
-					ymf_pcm_update_shift(&state->format);
-					spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-				}
-			}
-		}
-		return put_user(state->format.voices, p);
-
-	case SNDCTL_DSP_POST:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(POST)\n", cmd);
-		/*
-		 * Quoting OSS PG:
-		 *    The ioctl SNDCTL_DSP_POST is a lightweight version of
-		 *    SNDCTL_DSP_SYNC. It just tells to the driver that there
-		 *    is likely to be a pause in the output. This makes it
-		 *    possible for the device to handle the pause more
-		 *    intelligently. This ioctl doesn't block the application.
-		 *
-		 * The paragraph above is a clumsy way to say "flush ioctl".
-		 * This ioctl is used by mpg123.
-		 */
-		spin_lock_irqsave(&state->unit->reg_lock, flags);
-		if (state->wpcm.dmabuf.count != 0 && !state->wpcm.running) {
-			ymf_start_dac(state);
-		}
-		spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		return 0;
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, p))
-			return -EFAULT;
-		YMFDBGX("ymf_ioctl: cmd 0x%x(SETFRAG) fr 0x%04x:%04x(%d:%d)\n",
-		    cmd,
-		    (val >> 16) & 0xFFFF, val & 0xFFFF,
-		    (val >> 16) & 0xFFFF, val & 0xFFFF);
-		dmabuf = &state->wpcm.dmabuf;
-		dmabuf->ossfragshift = val & 0xffff;
-		dmabuf->ossmaxfrags = (val >> 16) & 0xffff;
-		if (dmabuf->ossfragshift < 4)
-			dmabuf->ossfragshift = 4;
-		if (dmabuf->ossfragshift > 15)
-			dmabuf->ossfragshift = 15;
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETOSPACE)\n", cmd);
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		dmabuf = &state->wpcm.dmabuf;
-		if (!dmabuf->ready && (val = prog_dmabuf(state, 0)) != 0)
-			return val;
-		redzone = ymf_calc_lend(state->format.rate);
-		redzone <<= state->format.shift;
-		redzone *= 3;
-		spin_lock_irqsave(&state->unit->reg_lock, flags);
-		abinfo.fragsize = dmabuf->fragsize;
-		abinfo.bytes = dmabuf->dmasize - dmabuf->count - redzone;
-		abinfo.fragstotal = dmabuf->numfrag;
-		abinfo.fragments = abinfo.bytes >> dmabuf->fragshift;
-		spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETISPACE)\n", cmd);
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		dmabuf = &state->rpcm.dmabuf;
-		if (!dmabuf->ready && (val = prog_dmabuf(state, 1)) != 0)
-			return val;
-		spin_lock_irqsave(&state->unit->reg_lock, flags);
-		abinfo.fragsize = dmabuf->fragsize;
-		abinfo.bytes = dmabuf->count;
-		abinfo.fragstotal = dmabuf->numfrag;
-		abinfo.fragments = abinfo.bytes >> dmabuf->fragshift;
-		spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_NONBLOCK:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(NONBLOCK)\n", cmd);
-		file->f_flags |= O_NONBLOCK;
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETCAPS)\n", cmd);
-		/* return put_user(DSP_CAP_REALTIME|DSP_CAP_TRIGGER|DSP_CAP_MMAP,
-			    p); */
-		return put_user(0, p);
-
-	case SNDCTL_DSP_GETIPTR:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETIPTR)\n", cmd);
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		dmabuf = &state->rpcm.dmabuf;
-		spin_lock_irqsave(&state->unit->reg_lock, flags);
-		cinfo.bytes = dmabuf->total_bytes;
-		cinfo.blocks = dmabuf->count >> dmabuf->fragshift;
-		cinfo.ptr = dmabuf->hwptr;
-		spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		YMFDBGX("ymf_ioctl: GETIPTR ptr %d bytes %d\n",
-		    cinfo.ptr, cinfo.bytes);
-		return copy_to_user(argp, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETOPTR:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(GETOPTR)\n", cmd);
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		dmabuf = &state->wpcm.dmabuf;
-		spin_lock_irqsave(&state->unit->reg_lock, flags);
-		cinfo.bytes = dmabuf->total_bytes;
-		cinfo.blocks = dmabuf->count >> dmabuf->fragshift;
-		cinfo.ptr = dmabuf->hwptr;
-		spin_unlock_irqrestore(&state->unit->reg_lock, flags);
-		YMFDBGX("ymf_ioctl: GETOPTR ptr %d bytes %d\n",
-		    cinfo.ptr, cinfo.bytes);
-		return copy_to_user(argp, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_SETDUPLEX:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(SETDUPLEX)\n", cmd);
-		return 0;		/* Always duplex */
-
-	case SOUND_PCM_READ_RATE:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(READ_RATE)\n", cmd);
-		return put_user(state->format.rate, p);
-
-	case SOUND_PCM_READ_CHANNELS:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(READ_CH)\n", cmd);
-		return put_user(state->format.voices, p);
-
-	case SOUND_PCM_READ_BITS:
-		YMFDBGX("ymf_ioctl: cmd 0x%x(READ_BITS)\n", cmd);
-		return put_user(AFMT_S16_LE, p);
-
-	case SNDCTL_DSP_MAPINBUF:
-	case SNDCTL_DSP_MAPOUTBUF:
-	case SNDCTL_DSP_SETSYNCRO:
-	case SOUND_PCM_WRITE_FILTER:
-	case SOUND_PCM_READ_FILTER:
-		YMFDBGX("ymf_ioctl: cmd 0x%x unsupported\n", cmd);
-		return -ENOTTY;
-
-	default:
-		/*
-		 * Some programs mix up audio devices and ioctls
-		 * or perhaps they expect "universal" ioctls,
-		 * for instance we get SNDCTL_TMR_CONTINUE here.
-		 * (mpg123 -g 100 ends here too - to be fixed.)
-		 */
-		YMFDBGX("ymf_ioctl: cmd 0x%x unknown\n", cmd);
-		break;
-	}
-	return -ENOTTY;
-}
-
-/*
- * open(2)
- * We use upper part of the minor to distinguish between soundcards.
- * Channels are opened with a clone open.
- */
-static int ymf_open(struct inode *inode, struct file *file)
-{
-	struct list_head *list;
-	ymfpci_t *unit = NULL;
-	int minor;
-	struct ymf_state *state;
-	int err;
-
-	minor = iminor(inode);
-	if ((minor & 0x0F) == 3) {	/* /dev/dspN */
-		;
-	} else {
-		return -ENXIO;
-	}
-
-	unit = NULL;	/* gcc warns */
-	spin_lock(&ymf_devs_lock);
-	list_for_each(list, &ymf_devs) {
-		unit = list_entry(list, ymfpci_t, ymf_devs);
-		if (((unit->dev_audio ^ minor) & ~0x0F) == 0)
-			break;
-	}
-	spin_unlock(&ymf_devs_lock);
-	if (unit == NULL)
-		return -ENODEV;
-
-	mutex_lock(&unit->open_mutex);
-
-	if ((state = ymf_state_alloc(unit)) == NULL) {
-		mutex_unlock(&unit->open_mutex);
-		return -ENOMEM;
-	}
-	list_add_tail(&state->chain, &unit->states);
-
-	file->private_data = state;
-
-	/*
-	 * ymf_read and ymf_write that we borrowed from cs46xx
-	 * allocate buffers with prog_dmabuf(). We call prog_dmabuf
-	 * here so that in case of DMA memory exhaustion open
-	 * fails rather than write.
-	 *
-	 * XXX prog_dmabuf allocates voice. Should allocate explicitly, above.
-	 */
-	if (file->f_mode & FMODE_WRITE) {
-		if (!state->wpcm.dmabuf.ready) {
-			if ((err = prog_dmabuf(state, 0)) != 0) {
-				goto out_nodma;
-			}
-		}
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!state->rpcm.dmabuf.ready) {
-			if ((err = prog_dmabuf(state, 1)) != 0) {
-				goto out_nodma;
-			}
-		}
-	}
-
-#if 0 /* test if interrupts work */
-	ymfpci_writew(unit, YDSXGR_TIMERCOUNT, 0xfffe);	/* ~ 680ms */
-	ymfpci_writeb(unit, YDSXGR_TIMERCTRL,
-	    (YDSXGR_TIMERCTRL_TEN|YDSXGR_TIMERCTRL_TIEN));
-#endif
-	mutex_unlock(&unit->open_mutex);
-
-	return nonseekable_open(inode, file);
-
-out_nodma:
-	/*
-	 * XXX Broken custom: "goto out_xxx" in other place is
-	 * a nestable exception, but here it is not nestable due to semaphore.
-	 * XXX Doubtful technique of self-describing objects....
-	 */
-	dealloc_dmabuf(unit, &state->wpcm.dmabuf);
-	dealloc_dmabuf(unit, &state->rpcm.dmabuf);
-	ymf_pcm_free_substream(&state->wpcm);
-	ymf_pcm_free_substream(&state->rpcm);
-
-	list_del(&state->chain);
-	kfree(state);
-
-	mutex_unlock(&unit->open_mutex);
-	return err;
-}
-
-static int ymf_release(struct inode *inode, struct file *file)
-{
-	struct ymf_state *state = (struct ymf_state *)file->private_data;
-	ymfpci_t *unit = state->unit;
-
-#if 0 /* test if interrupts work */
-	ymfpci_writeb(unit, YDSXGR_TIMERCTRL, 0);
-#endif
-
-	mutex_lock(&unit->open_mutex);
-
-	/*
-	 * XXX Solve the case of O_NONBLOCK close - don't deallocate here.
-	 * Deallocate when unloading the driver and we can wait.
-	 */
-	ymf_wait_dac(state);
-	ymf_stop_adc(state);		/* fortunately, it's immediate */
-	dealloc_dmabuf(unit, &state->wpcm.dmabuf);
-	dealloc_dmabuf(unit, &state->rpcm.dmabuf);
-	ymf_pcm_free_substream(&state->wpcm);
-	ymf_pcm_free_substream(&state->rpcm);
-
-	list_del(&state->chain);
-	file->private_data = NULL;	/* Can you tell I programmed Solaris */
-	kfree(state);
-
-	mutex_unlock(&unit->open_mutex);
-
-	return 0;
-}
-
-/*
- * Mixer operations are based on cs46xx.
- */
-static int ymf_open_mixdev(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	struct list_head *list;
-	ymfpci_t *unit;
-	int i;
-
-	spin_lock(&ymf_devs_lock);
-	list_for_each(list, &ymf_devs) {
-		unit = list_entry(list, ymfpci_t, ymf_devs);
-		for (i = 0; i < NR_AC97; i++) {
-			if (unit->ac97_codec[i] != NULL &&
-			    unit->ac97_codec[i]->dev_mixer == minor) {
-				spin_unlock(&ymf_devs_lock);
-				goto match;
-			}
-		}
-	}
-	spin_unlock(&ymf_devs_lock);
-	return -ENODEV;
-
- match:
-	file->private_data = unit->ac97_codec[i];
-
-	return nonseekable_open(inode, file);
-}
-
-static int ymf_ioctl_mixdev(struct inode *inode, struct file *file,
-    unsigned int cmd, unsigned long arg)
-{
-	struct ac97_codec *codec = (struct ac97_codec *)file->private_data;
-
-	return codec->mixer_ioctl(codec, cmd, arg);
-}
-
-static int ymf_release_mixdev(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static /*const*/ struct file_operations ymf_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= ymf_read,
-	.write		= ymf_write,
-	.poll		= ymf_poll,
-	.ioctl		= ymf_ioctl,
-	.mmap		= ymf_mmap,
-	.open		= ymf_open,
-	.release	= ymf_release,
-};
-
-static /*const*/ struct file_operations ymf_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= ymf_ioctl_mixdev,
-	.open		= ymf_open_mixdev,
-	.release	= ymf_release_mixdev,
-};
-
-/*
- */
-
-static int ymf_suspend(struct pci_dev *pcidev, pm_message_t unused)
-{
-	struct ymf_unit *unit = pci_get_drvdata(pcidev);
-	unsigned long flags;
-	struct ymf_dmabuf *dmabuf;
-	struct list_head *p;
-	struct ymf_state *state;
-	struct ac97_codec *codec;
-	int i;
-
-	spin_lock_irqsave(&unit->reg_lock, flags);
-
-	unit->suspended = 1;
-
-	for (i = 0; i < NR_AC97; i++) {
-		if ((codec = unit->ac97_codec[i]) != NULL)
-			ac97_save_state(codec);
-	}
-
-	list_for_each(p, &unit->states) {
-		state = list_entry(p, struct ymf_state, chain);
-
-		dmabuf = &state->wpcm.dmabuf;
-		dmabuf->hwptr = dmabuf->swptr = 0;
-		dmabuf->total_bytes = 0;
-		dmabuf->count = 0;
-
-		dmabuf = &state->rpcm.dmabuf;
-		dmabuf->hwptr = dmabuf->swptr = 0;
-		dmabuf->total_bytes = 0;
-		dmabuf->count = 0;
-	}
-
-	ymfpci_writel(unit, YDSXGR_NATIVEDACOUTVOL, 0);
-	ymfpci_disable_dsp(unit);
-
-	spin_unlock_irqrestore(&unit->reg_lock, flags);
-	
-	return 0;
-}
-
-static int ymf_resume(struct pci_dev *pcidev)
-{
-	struct ymf_unit *unit = pci_get_drvdata(pcidev);
-	unsigned long flags;
-	struct list_head *p;
-	struct ymf_state *state;
-	struct ac97_codec *codec;
-	int i;
-
-	ymfpci_aclink_reset(unit->pci);
-	ymfpci_codec_ready(unit, 0, 1);		/* prints diag if not ready. */
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-	/* XXX At this time the legacy registers are probably deprogrammed. */
-#endif
-
-	ymfpci_download_image(unit);
-
-	ymf_memload(unit);
-
-	spin_lock_irqsave(&unit->reg_lock, flags);
-
-	if (unit->start_count) {
-		ymfpci_writel(unit, YDSXGR_MODE, 3);
-		unit->active_bank = ymfpci_readl(unit, YDSXGR_CTRLSELECT) & 1;
-	}
-
-	for (i = 0; i < NR_AC97; i++) {
-		if ((codec = unit->ac97_codec[i]) != NULL)
-			ac97_restore_state(codec);
-	}
-
-	unit->suspended = 0;
-	list_for_each(p, &unit->states) {
-		state = list_entry(p, struct ymf_state, chain);
-		wake_up(&state->wpcm.dmabuf.wait);
-		wake_up(&state->rpcm.dmabuf.wait);
-	}
-
-	spin_unlock_irqrestore(&unit->reg_lock, flags);
-	return 0;
-}
-
-/*
- *  initialization routines
- */
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-
-static int ymfpci_setup_legacy(ymfpci_t *unit, struct pci_dev *pcidev)
-{
-	int v;
-	int mpuio = -1, oplio = -1;
-
-	switch (unit->iomidi) {
-	case 0x330:
-		mpuio = 0;
-		break;
-	case 0x300:
-		mpuio = 1;
-		break;
-	case 0x332:
-		mpuio = 2;
-		break;
-	case 0x334:
-		mpuio = 3;
-		break;
-	default: ;
-	}
-
-	switch (unit->iosynth) {
-	case 0x388:
-		oplio = 0;
-		break;
-	case 0x398:
-		oplio = 1;
-		break;
-	case 0x3a0:
-		oplio = 2;
-		break;
-	case 0x3a8:
-		oplio = 3;
-		break;
-	default: ;
-	}
-
-	if (mpuio >= 0 || oplio >= 0) {
-		/* 0x0020: 1 - 10 bits of I/O address decoded, 0 - 16 bits. */
-		v = 0x001e;
-		pci_write_config_word(pcidev, PCIR_LEGCTRL, v);
-
-		switch (pcidev->device) {
-		case PCI_DEVICE_ID_YAMAHA_724:
-		case PCI_DEVICE_ID_YAMAHA_740:
-		case PCI_DEVICE_ID_YAMAHA_724F:
-		case PCI_DEVICE_ID_YAMAHA_740C:
-			v = 0x8800;
-			if (mpuio >= 0) { v |= mpuio<<4; }
-			if (oplio >= 0) { v |= oplio; }
-			pci_write_config_word(pcidev, PCIR_ELEGCTRL, v);
-			break;
-
-		case PCI_DEVICE_ID_YAMAHA_744:
-		case PCI_DEVICE_ID_YAMAHA_754:
-			v = 0x8800;
-			pci_write_config_word(pcidev, PCIR_ELEGCTRL, v);
-			if (oplio >= 0) {
-				pci_write_config_word(pcidev, PCIR_OPLADR, unit->iosynth);
-			}
-			if (mpuio >= 0) {
-				pci_write_config_word(pcidev, PCIR_MPUADR, unit->iomidi);
-			}
-			break;
-
-		default:
-			printk(KERN_ERR "ymfpci: Unknown device ID: 0x%x\n",
-			    pcidev->device);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-#endif /* CONFIG_SOUND_YMFPCI_LEGACY */
-
-static void ymfpci_aclink_reset(struct pci_dev * pci)
-{
-	u8 cmd;
-
-	/*
-	 * In the 744, 754 only 0x01 exists, 0x02 is undefined.
-	 * It does not seem to hurt to trip both regardless of revision.
-	 */
-	pci_read_config_byte(pci, PCIR_DSXGCTRL, &cmd);
-	pci_write_config_byte(pci, PCIR_DSXGCTRL, cmd & 0xfc);
-	pci_write_config_byte(pci, PCIR_DSXGCTRL, cmd | 0x03);
-	pci_write_config_byte(pci, PCIR_DSXGCTRL, cmd & 0xfc);
-
-	pci_write_config_word(pci, PCIR_DSXPWRCTRL1, 0);
-	pci_write_config_word(pci, PCIR_DSXPWRCTRL2, 0);
-}
-
-static void ymfpci_enable_dsp(ymfpci_t *codec)
-{
-	ymfpci_writel(codec, YDSXGR_CONFIG, 0x00000001);
-}
-
-static void ymfpci_disable_dsp(ymfpci_t *codec)
-{
-	u32 val;
-	int timeout = 1000;
-
-	val = ymfpci_readl(codec, YDSXGR_CONFIG);
-	if (val)
-		ymfpci_writel(codec, YDSXGR_CONFIG, 0x00000000);
-	while (timeout-- > 0) {
-		val = ymfpci_readl(codec, YDSXGR_STATUS);
-		if ((val & 0x00000002) == 0)
-			break;
-	}
-}
-
-#include "ymfpci_image.h"
-
-static void ymfpci_download_image(ymfpci_t *codec)
-{
-	int i, ver_1e;
-	u16 ctrl;
-
-	ymfpci_writel(codec, YDSXGR_NATIVEDACOUTVOL, 0x00000000);
-	ymfpci_disable_dsp(codec);
-	ymfpci_writel(codec, YDSXGR_MODE, 0x00010000);
-	ymfpci_writel(codec, YDSXGR_MODE, 0x00000000);
-	ymfpci_writel(codec, YDSXGR_MAPOFREC, 0x00000000);
-	ymfpci_writel(codec, YDSXGR_MAPOFEFFECT, 0x00000000);
-	ymfpci_writel(codec, YDSXGR_PLAYCTRLBASE, 0x00000000);
-	ymfpci_writel(codec, YDSXGR_RECCTRLBASE, 0x00000000);
-	ymfpci_writel(codec, YDSXGR_EFFCTRLBASE, 0x00000000);
-	ctrl = ymfpci_readw(codec, YDSXGR_GLOBALCTRL);
-	ymfpci_writew(codec, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);
-
-	/* setup DSP instruction code */
-	for (i = 0; i < YDSXG_DSPLENGTH / 4; i++)
-		ymfpci_writel(codec, YDSXGR_DSPINSTRAM + (i << 2), DspInst[i]);
-
-	switch (codec->pci->device) {
-	case PCI_DEVICE_ID_YAMAHA_724F:
-	case PCI_DEVICE_ID_YAMAHA_740C:
-	case PCI_DEVICE_ID_YAMAHA_744:
-	case PCI_DEVICE_ID_YAMAHA_754:
-		ver_1e = 1;
-		break;
-	default:
-		ver_1e = 0;
-	}
-
-	if (ver_1e) {
-		/* setup control instruction code */
-		for (i = 0; i < YDSXG_CTRLLENGTH / 4; i++)
-			ymfpci_writel(codec, YDSXGR_CTRLINSTRAM + (i << 2), CntrlInst1E[i]);
-	} else {
-		for (i = 0; i < YDSXG_CTRLLENGTH / 4; i++)
-			ymfpci_writel(codec, YDSXGR_CTRLINSTRAM + (i << 2), CntrlInst[i]);
-	}
-
-	ymfpci_enable_dsp(codec);
-
-	/* 0.02s sounds not too bad, we may do schedule_timeout() later. */
-	mdelay(20); /* seems we need some delay after downloading image.. */
-}
-
-static int ymfpci_memalloc(ymfpci_t *codec)
-{
-	unsigned int playback_ctrl_size;
-	unsigned int bank_size_playback;
-	unsigned int bank_size_capture;
-	unsigned int bank_size_effect;
-	unsigned int size;
-	unsigned int off;
-	char *ptr;
-	dma_addr_t pba;
-	int voice, bank;
-
-	playback_ctrl_size = 4 + 4 * YDSXG_PLAYBACK_VOICES;
-	bank_size_playback = ymfpci_readl(codec, YDSXGR_PLAYCTRLSIZE) << 2;
-	bank_size_capture = ymfpci_readl(codec, YDSXGR_RECCTRLSIZE) << 2;
-	bank_size_effect = ymfpci_readl(codec, YDSXGR_EFFCTRLSIZE) << 2;
-	codec->work_size = YDSXG_DEFAULT_WORK_SIZE;
-
-	size = ((playback_ctrl_size + 0x00ff) & ~0x00ff) +
-	    ((bank_size_playback * 2 * YDSXG_PLAYBACK_VOICES + 0xff) & ~0xff) +
-	    ((bank_size_capture * 2 * YDSXG_CAPTURE_VOICES + 0xff) & ~0xff) +
-	    ((bank_size_effect * 2 * YDSXG_EFFECT_VOICES + 0xff) & ~0xff) +
-	    codec->work_size;
-
-	ptr = pci_alloc_consistent(codec->pci, size + 0xff, &pba);
-	if (ptr == NULL)
-		return -ENOMEM;
-	codec->dma_area_va = ptr;
-	codec->dma_area_ba = pba;
-	codec->dma_area_size = size + 0xff;
-
-	off = (unsigned long)ptr & 0xff;
-	if (off) {
-		ptr += 0x100 - off;
-		pba += 0x100 - off;
-	}
-
-	/*
-	 * Hardware requires only ptr[playback_ctrl_size] zeroed,
-	 * but in our judgement it is a wrong kind of savings, so clear it all.
-	 */
-	memset(ptr, 0, size);
-
-	codec->ctrl_playback = (u32 *)ptr;
-	codec->ctrl_playback_ba = pba;
-	codec->ctrl_playback[0] = cpu_to_le32(YDSXG_PLAYBACK_VOICES);
-	ptr += (playback_ctrl_size + 0x00ff) & ~0x00ff;
-	pba += (playback_ctrl_size + 0x00ff) & ~0x00ff;
-
-	off = 0;
-	for (voice = 0; voice < YDSXG_PLAYBACK_VOICES; voice++) {
-		codec->voices[voice].number = voice;
-		codec->voices[voice].bank =
-		    (ymfpci_playback_bank_t *) (ptr + off);
-		codec->voices[voice].bank_ba = pba + off;
-		off += 2 * bank_size_playback;		/* 2 banks */
-	}
-	off = (off + 0xff) & ~0xff;
-	ptr += off;
-	pba += off;
-
-	off = 0;
-	codec->bank_base_capture = pba;
-	for (voice = 0; voice < YDSXG_CAPTURE_VOICES; voice++)
-		for (bank = 0; bank < 2; bank++) {
-			codec->bank_capture[voice][bank] =
-			    (ymfpci_capture_bank_t *) (ptr + off);
-			off += bank_size_capture;
-		}
-	off = (off + 0xff) & ~0xff;
-	ptr += off;
-	pba += off;
-
-	off = 0;
-	codec->bank_base_effect = pba;
-	for (voice = 0; voice < YDSXG_EFFECT_VOICES; voice++)
-		for (bank = 0; bank < 2; bank++) {
-			codec->bank_effect[voice][bank] =
-			    (ymfpci_effect_bank_t *) (ptr + off);
-			off += bank_size_effect;
-		}
-	off = (off + 0xff) & ~0xff;
-	ptr += off;
-	pba += off;
-
-	codec->work_base = pba;
-
-	return 0;
-}
-
-static void ymfpci_memfree(ymfpci_t *codec)
-{
-	ymfpci_writel(codec, YDSXGR_PLAYCTRLBASE, 0);
-	ymfpci_writel(codec, YDSXGR_RECCTRLBASE, 0);
-	ymfpci_writel(codec, YDSXGR_EFFCTRLBASE, 0);
-	ymfpci_writel(codec, YDSXGR_WORKBASE, 0);
-	ymfpci_writel(codec, YDSXGR_WORKSIZE, 0);
-	pci_free_consistent(codec->pci,
-	    codec->dma_area_size, codec->dma_area_va, codec->dma_area_ba);
-}
-
-static void ymf_memload(ymfpci_t *unit)
-{
-
-	ymfpci_writel(unit, YDSXGR_PLAYCTRLBASE, unit->ctrl_playback_ba);
-	ymfpci_writel(unit, YDSXGR_RECCTRLBASE, unit->bank_base_capture);
-	ymfpci_writel(unit, YDSXGR_EFFCTRLBASE, unit->bank_base_effect);
-	ymfpci_writel(unit, YDSXGR_WORKBASE, unit->work_base);
-	ymfpci_writel(unit, YDSXGR_WORKSIZE, unit->work_size >> 2);
-
-	/* S/PDIF output initialization */
-	ymfpci_writew(unit, YDSXGR_SPDIFOUTCTRL, 0);
-	ymfpci_writew(unit, YDSXGR_SPDIFOUTSTATUS,
-		SND_PCM_AES0_CON_EMPHASIS_NONE |
-		(SND_PCM_AES1_CON_ORIGINAL << 8) |
-		(SND_PCM_AES1_CON_PCM_CODER << 8));
-
-	/* S/PDIF input initialization */
-	ymfpci_writew(unit, YDSXGR_SPDIFINCTRL, 0);
-
-	/* move this volume setup to mixer */
-	ymfpci_writel(unit, YDSXGR_NATIVEDACOUTVOL, 0x3fff3fff);
-	ymfpci_writel(unit, YDSXGR_BUF441OUTVOL, 0);
-	ymfpci_writel(unit, YDSXGR_NATIVEADCINVOL, 0x3fff3fff);
-	ymfpci_writel(unit, YDSXGR_NATIVEDACINVOL, 0x3fff3fff);
-}
-
-static int ymf_ac97_init(ymfpci_t *unit, int num_ac97)
-{
-	struct ac97_codec *codec;
-	u16 eid;
-
-	if ((codec = ac97_alloc_codec()) == NULL)
-		return -ENOMEM;
-
-	/* initialize some basic codec information, other fields will be filled
-	   in ac97_probe_codec */
-	codec->private_data = unit;
-	codec->id = num_ac97;
-
-	codec->codec_read = ymfpci_codec_read;
-	codec->codec_write = ymfpci_codec_write;
-
-	if (ac97_probe_codec(codec) == 0) {
-		printk(KERN_ERR "ymfpci: ac97_probe_codec failed\n");
-		goto out_kfree;
-	}
-
-	eid = ymfpci_codec_read(codec, AC97_EXTENDED_ID);
-	if (eid==0xFFFF) {
-		printk(KERN_WARNING "ymfpci: no codec attached ?\n");
-		goto out_kfree;
-	}
-
-	unit->ac97_features = eid;
-
-	if ((codec->dev_mixer = register_sound_mixer(&ymf_mixer_fops, -1)) < 0) {
-		printk(KERN_ERR "ymfpci: couldn't register mixer!\n");
-		goto out_kfree;
-	}
-
-	unit->ac97_codec[num_ac97] = codec;
-
-	return 0;
- out_kfree:
-	ac97_release_codec(codec);
-	return -ENODEV;
-}
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-# ifdef MODULE
-static int mpu_io;
-static int synth_io;
-module_param(mpu_io, int, 0);
-module_param(synth_io, int, 0);
-# else
-static int mpu_io     = 0x330;
-static int synth_io   = 0x388;
-# endif
-static int assigned;
-#endif /* CONFIG_SOUND_YMFPCI_LEGACY */
-
-static int __devinit ymf_probe_one(struct pci_dev *pcidev, const struct pci_device_id *ent)
-{
-	u16 ctrl;
-	unsigned long base;
-	ymfpci_t *codec;
-
-	int err;
-
-	if ((err = pci_enable_device(pcidev)) != 0) {
-		printk(KERN_ERR "ymfpci: pci_enable_device failed\n");
-		return err;
-	}
-	base = pci_resource_start(pcidev, 0);
-
-	if ((codec = kmalloc(sizeof(ymfpci_t), GFP_KERNEL)) == NULL) {
-		printk(KERN_ERR "ymfpci: no core\n");
-		return -ENOMEM;
-	}
-	memset(codec, 0, sizeof(*codec));
-
-	spin_lock_init(&codec->reg_lock);
-	spin_lock_init(&codec->voice_lock);
-	spin_lock_init(&codec->ac97_lock);
-	mutex_init(&codec->open_mutex);
-	INIT_LIST_HEAD(&codec->states);
-	codec->pci = pcidev;
-
-	pci_read_config_byte(pcidev, PCI_REVISION_ID, &codec->rev);
-
-	if (request_mem_region(base, 0x8000, "ymfpci") == NULL) {
-		printk(KERN_ERR "ymfpci: unable to request mem region\n");
-		goto out_free;
-	}
-
-	if ((codec->reg_area_virt = ioremap(base, 0x8000)) == NULL) {
-		printk(KERN_ERR "ymfpci: unable to map registers\n");
-		goto out_release_region;
-	}
-
-	pci_set_master(pcidev);
-
-	printk(KERN_INFO "ymfpci: %s at 0x%lx IRQ %d\n",
-	    (char *)ent->driver_data, base, pcidev->irq);
-
-	ymfpci_aclink_reset(pcidev);
-	if (ymfpci_codec_ready(codec, 0, 1) < 0)
-		goto out_unmap;
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-	if (assigned == 0) {
-		codec->iomidi = mpu_io;
-		codec->iosynth = synth_io;
-		if (ymfpci_setup_legacy(codec, pcidev) < 0)
-			goto out_unmap;
-		assigned = 1;
-	}
-#endif
-
-	ymfpci_download_image(codec);
-
-	if (ymfpci_memalloc(codec) < 0)
-		goto out_disable_dsp;
-	ymf_memload(codec);
-
-	if (request_irq(pcidev->irq, ymf_interrupt, IRQF_SHARED, "ymfpci", codec) != 0) {
-		printk(KERN_ERR "ymfpci: unable to request IRQ %d\n",
-		    pcidev->irq);
-		goto out_memfree;
-	}
-
-	/* register /dev/dsp */
-	if ((codec->dev_audio = register_sound_dsp(&ymf_fops, -1)) < 0) {
-		printk(KERN_ERR "ymfpci: unable to register dsp\n");
-		goto out_free_irq;
-	}
-
-	/*
-	 * Poke just the primary for the moment.
-	 */
-	if ((err = ymf_ac97_init(codec, 0)) != 0)
-		goto out_unregister_sound_dsp;
-
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-	codec->opl3_data.name = "ymfpci";
-	codec->mpu_data.name  = "ymfpci";
-
-	codec->opl3_data.io_base = codec->iosynth;
-	codec->opl3_data.irq     = -1;
-
-	codec->mpu_data.io_base  = codec->iomidi;
-	codec->mpu_data.irq      = -1;	/* May be different from our PCI IRQ. */
-
-	if (codec->iomidi) {
-		if (!probe_uart401(&codec->mpu_data, THIS_MODULE)) {
-			codec->iomidi = 0;	/* XXX kludge */
-		}
-	}
-#endif /* CONFIG_SOUND_YMFPCI_LEGACY */
-
-	/* put it into driver list */
-	spin_lock(&ymf_devs_lock);
-	list_add_tail(&codec->ymf_devs, &ymf_devs);
-	spin_unlock(&ymf_devs_lock);
-	pci_set_drvdata(pcidev, codec);
-
-	return 0;
-
- out_unregister_sound_dsp:
-	unregister_sound_dsp(codec->dev_audio);
- out_free_irq:
-	free_irq(pcidev->irq, codec);
- out_memfree:
-	ymfpci_memfree(codec);
- out_disable_dsp:
-	ymfpci_disable_dsp(codec);
-	ctrl = ymfpci_readw(codec, YDSXGR_GLOBALCTRL);
-	ymfpci_writew(codec, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);
-	ymfpci_writel(codec, YDSXGR_STATUS, ~0);
- out_unmap:
-	iounmap(codec->reg_area_virt);
- out_release_region:
-	release_mem_region(pci_resource_start(pcidev, 0), 0x8000);
- out_free:
-	if (codec->ac97_codec[0])
-		ac97_release_codec(codec->ac97_codec[0]);
-	return -ENODEV;
-}
-
-static void __devexit ymf_remove_one(struct pci_dev *pcidev)
-{
-	__u16 ctrl;
-	ymfpci_t *codec = pci_get_drvdata(pcidev);
-
-	/* remove from list of devices */
-	spin_lock(&ymf_devs_lock);
-	list_del(&codec->ymf_devs);
-	spin_unlock(&ymf_devs_lock);
-
-	unregister_sound_mixer(codec->ac97_codec[0]->dev_mixer);
-	ac97_release_codec(codec->ac97_codec[0]);
-	unregister_sound_dsp(codec->dev_audio);
-	free_irq(pcidev->irq, codec);
-	ymfpci_memfree(codec);
-	ymfpci_writel(codec, YDSXGR_STATUS, ~0);
-	ymfpci_disable_dsp(codec);
-	ctrl = ymfpci_readw(codec, YDSXGR_GLOBALCTRL);
-	ymfpci_writew(codec, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);
-	iounmap(codec->reg_area_virt);
-	release_mem_region(pci_resource_start(pcidev, 0), 0x8000);
-#ifdef CONFIG_SOUND_YMFPCI_LEGACY
-	if (codec->iomidi) {
-		unload_uart401(&codec->mpu_data);
-	}
-#endif /* CONFIG_SOUND_YMFPCI_LEGACY */
-}
-
-MODULE_AUTHOR("Jaroslav Kysela");
-MODULE_DESCRIPTION("Yamaha YMF7xx PCI Audio");
-MODULE_LICENSE("GPL");
-
-static struct pci_driver ymfpci_driver = {
-	.name		= "ymfpci",
-	.id_table	= ymf_id_tbl,
-	.probe		= ymf_probe_one,
-	.remove		= __devexit_p(ymf_remove_one),
-	.suspend	= ymf_suspend,
-	.resume		= ymf_resume
-};
-
-static int __init ymf_init_module(void)
-{
-	return pci_register_driver(&ymfpci_driver);
-}
-
-static void __exit ymf_cleanup_module (void)
-{
-	pci_unregister_driver(&ymfpci_driver);
-}
-
-module_init(ymf_init_module);
-module_exit(ymf_cleanup_module);
--- linux-2.6.18.noarch/sound/oss/audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/audio.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/audio.c
+ * sound/oss/audio.c
  *
  * Device file manager for /dev/audio
  */
--- linux-2.6.18.noarch/sound/oss/sound_calls.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sound_calls.h	2007-06-05 17:44:14.000000000 -0400
@@ -13,8 +13,6 @@
 void DMAbuf_init(int dev, int dma1, int dma2);
 void DMAbuf_deinit(int dev);
 int DMAbuf_start_dma (int dev, unsigned long physaddr, int count, int dma_mode);
-int DMAbuf_open_dma (int dev);
-void DMAbuf_close_dma (int dev);
 void DMAbuf_inputintr(int dev);
 void DMAbuf_outputintr(int dev, int underflow_flag);
 struct dma_buffparms;
@@ -73,7 +71,6 @@
 int MIDIbuf_avail(int dev);
 
 void MIDIbuf_bytes_received(int dev, unsigned char *buf, int count);
-void MIDIbuf_init(void);
 
 
 /*	From soundcard.c	*/
--- linux-2.6.18.noarch/sound/oss/trident.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/trident.c	2007-06-05 17:44:14.000000000 -0400
@@ -216,6 +216,7 @@
 #include <linux/gameport.h>
 #include <linux/kernel.h>
 #include <linux/mutex.h>
+#include <linux/mm.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -488,10 +489,6 @@
 static void ali_enable_special_channel(struct trident_state *stat);
 static struct trident_channel *ali_alloc_rec_pcm_channel(struct trident_card *card);
 static struct trident_channel *ali_alloc_pcm_channel(struct trident_card *card);
-static void ali_restore_regs(struct trident_card *card);
-static void ali_save_regs(struct trident_card *card);
-static int trident_suspend(struct pci_dev *dev, pm_message_t unused);
-static int trident_resume(struct pci_dev *dev);
 static void ali_free_pcm_channel(struct trident_card *card, unsigned int channel);
 static int ali_setup_multi_channels(struct trident_card *card, int chan_nums);
 static unsigned int ali_get_spdif_in_rate(struct trident_card *card);
@@ -507,13 +504,6 @@
 					       int chan_nums);
 static void ali_free_other_states_resources(struct trident_state *state);
 
-/* save registers for ALi Power Management */
-static struct ali_saved_registers {
-	unsigned long global_regs[ALI_GLOBAL_REGS];
-	unsigned long channel_regs[ALI_CHANNELS][ALI_CHANNEL_REGS];
-	unsigned mixer_regs[ALI_MIXER_REGS];
-} ali_registers;
-
 #define seek_offset(dma_ptr, buffer, cnt, offset, copy_count)	do { \
         (dma_ptr) += (offset);	  \
 	(buffer) += (offset);	  \
@@ -1822,7 +1812,7 @@
 }
 
 static irqreturn_t
-trident_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+trident_interrupt(int irq, void *dev_id)
 {
 	struct trident_card *card = (struct trident_card *) dev_id;
 	u32 event;
@@ -1873,7 +1863,7 @@
 	unsigned swptr;
 	int cnt;
 
-	pr_debug("trident: trident_read called, count = %d\n", count);
+	pr_debug("trident: trident_read called, count = %zd\n", count);
 
 	VALIDATE_STATE(state);
 
@@ -1989,7 +1979,7 @@
 	unsigned int copy_count;
 	int lret; /* for lock_set_fmt */
 
-	pr_debug("trident: trident_write called, count = %d\n", count);
+	pr_debug("trident: trident_write called, count = %zd\n", count);
 
 	VALIDATE_STATE(state);
 
@@ -2739,12 +2729,11 @@
 		}
 		for (i = 0; i < NR_HW_CH; i++) {
 			if (card->states[i] == NULL) {
-				state = card->states[i] = kmalloc(sizeof(*state), GFP_KERNEL);
+				state = card->states[i] = kzalloc(sizeof(*state), GFP_KERNEL);
 				if (state == NULL) {
 					mutex_unlock(&card->open_mutex);
 					return -ENOMEM;
 				}
-				memset(state, 0, sizeof(*state));
 				mutex_init(&state->sem);
 				dmabuf = &state->dmabuf;
 				goto found_virt;
@@ -3280,8 +3269,8 @@
 	char temp;
 	struct pci_dev *pci_dev = NULL;
 
-	pci_dev = pci_find_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, 
-				  pci_dev);
+	pci_dev = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,
+				 pci_dev);
 	if (pci_dev == NULL)
 		return;
 	pci_read_config_byte(pci_dev, 0x61, &temp);
@@ -3295,6 +3284,8 @@
 	temp |= 0x10;
 	pci_write_config_byte(pci_dev, 0x7e, temp);
 
+	pci_dev_put(pci_dev);
+
 	ch = inb(TRID_REG(card, ALI_SCTRL));
 	outb(ch | ALI_SPDIF_OUT_ENABLE, TRID_REG(card, ALI_SCTRL));
 	ch = inb(TRID_REG(card, ALI_SPDIF_CTRL));
@@ -3501,16 +3492,19 @@
 	char temp = 0;
 	struct pci_dev *pci_dev = NULL;
 
-	pci_dev = pci_find_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, 
-				  pci_dev);
+	pci_dev = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,
+				 pci_dev);
 	if (pci_dev == NULL)
 		return -1;
+
 	pci_read_config_byte(pci_dev, 0x59, &temp);
 	temp &= ~0x80;
 	pci_write_config_byte(pci_dev, 0x59, temp);
 
-	pci_dev = pci_find_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101, 
-				  pci_dev);
+	pci_dev_put(pci_dev);
+
+	pci_dev = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101,
+				 NULL);
 	if (pci_dev == NULL)
 		return -1;
 
@@ -3518,6 +3512,8 @@
 	temp &= ~0x20;
 	pci_write_config_byte(pci_dev, 0xB8, temp);
 
+	pci_dev_put(pci_dev);
+
 	return 0;
 }
 
@@ -3528,21 +3524,26 @@
 	char temp = 0;
 	struct pci_dev *pci_dev = NULL;
 
-	pci_dev = pci_find_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, 
-				  pci_dev);
+	pci_dev = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,
+				 pci_dev);
 	if (pci_dev == NULL)
 		return -1;
 	pci_read_config_byte(pci_dev, 0x59, &temp);
 	temp |= 0x80;
 	pci_write_config_byte(pci_dev, 0x59, temp);
 
-	pci_dev = pci_find_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101, 
-				  pci_dev);
+	pci_dev_put(pci_dev);
+
+	pci_dev = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101,
+				 NULL);
 	if (pci_dev == NULL)
 		return -1;
 	pci_read_config_byte(pci_dev, (int) 0xB8, &temp);
 	temp |= 0x20;
 	pci_write_config_byte(pci_dev, (int) 0xB8, (u8) temp);
+
+	pci_dev_put(pci_dev);
+
 	if (chan_nums == 6) {
 		dwValue = inl(TRID_REG(card, ALI_SCTRL)) | 0x000f0000;
 		outl(dwValue, TRID_REG(card, ALI_SCTRL));
@@ -3616,7 +3617,7 @@
 			}
 			return -EBUSY;
 		}
-		s = card->states[i] = kmalloc(sizeof(*state), GFP_KERNEL);
+		s = card->states[i] = kzalloc(sizeof(*state), GFP_KERNEL);
 		if (!s) {
 			num = ali_multi_channels_5_1[state_count];
 			ali_free_pcm_channel(card, num);
@@ -3628,7 +3629,6 @@
 			}
 			return -ENOMEM;
 		}
-		memset(s, 0, sizeof(*state));
 
 		s->dmabuf.channel = channel;
 		s->dmabuf.ossfragshift = s->dmabuf.ossmaxfrags =
@@ -3653,6 +3653,14 @@
 	return 0;
 }
 
+#ifdef CONFIG_PM
+/* save registers for ALi Power Management */
+static struct ali_saved_registers {
+	unsigned long global_regs[ALI_GLOBAL_REGS];
+	unsigned long channel_regs[ALI_CHANNELS][ALI_CHANNEL_REGS];
+	unsigned mixer_regs[ALI_MIXER_REGS];
+} ali_registers;
+
 static void
 ali_save_regs(struct trident_card *card)
 {
@@ -3746,6 +3754,7 @@
 	}
 	return 0;
 }
+#endif
 
 static struct trident_channel *
 ali_alloc_pcm_channel(struct trident_card *card)
@@ -4105,8 +4114,8 @@
 	unsigned int dwVal;
 	unsigned short wCount, wReg;
 
-	pci_dev = pci_find_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, 
-				  pci_dev);
+	pci_dev = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,
+				 pci_dev);
 	if (pci_dev == NULL)
 		return -1;
 
@@ -4116,6 +4125,7 @@
 	pci_read_config_dword(pci_dev, 0x7c, &dwVal);
 	pci_write_config_dword(pci_dev, 0x7c, dwVal & 0xf7ffffff);
 	udelay(5000);
+	pci_dev_put(pci_dev);
 
 	pci_dev = card->pci_dev;
 	if (pci_dev == NULL)
@@ -4387,15 +4397,14 @@
 	}
 
 	rc = -ENOMEM;
-	if ((card = kmalloc(sizeof(*card), GFP_KERNEL)) == NULL) {
+	if ((card = kzalloc(sizeof(*card), GFP_KERNEL)) == NULL) {
 		printk(KERN_ERR "trident: out of memory\n");
 		goto out_release_region;
 	}
-	memset(card, 0, sizeof (*card));
 
 	init_timer(&card->timer);
 	card->iobase = iobase;
-	card->pci_dev = pci_dev;
+	card->pci_dev = pci_dev_get(pci_dev);
 	card->pci_id = pci_id->device;
 	card->revision = revision;
 	card->irq = pci_dev->irq;
@@ -4549,6 +4558,7 @@
 out_free_irq:
 	free_irq(card->irq, card);
 out_proc_fs:
+	pci_dev_put(card->pci_dev);
 	if (res) {
 		remove_proc_entry("ALi5451", NULL);
 		res = NULL;
@@ -4599,9 +4609,9 @@
 		}
 	unregister_sound_dsp(card->dev_audio);
 
-	kfree(card);
-
 	pci_set_drvdata(pci_dev, NULL);
+	pci_dev_put(card->pci_dev);
+	kfree(card);
 }
 
 MODULE_AUTHOR("Alan Cox, Aaron Holtzman, Ollie Lho, Ching Ling Lee, Muli Ben-Yehuda");
@@ -4616,8 +4626,10 @@
 	.id_table = trident_pci_tbl,
 	.probe = trident_probe,
 	.remove = __devexit_p(trident_remove),
+#ifdef CONFIG_PM
 	.suspend = trident_suspend,
 	.resume = trident_resume
+#endif
 };
 
 static int __init
--- linux-2.6.18.noarch/sound/oss/ad1848.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ad1848.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/ad1848.c
+ * sound/oss/ad1848.c
  *
  * The low level driver for the AD1848/CS4248 codec chip which
  * is used for example in the MS Sound System.
@@ -195,6 +195,7 @@
 static void     ad1848_halt_input(int dev);
 static void     ad1848_halt_output(int dev);
 static void     ad1848_trigger(int dev, int bits);
+static irqreturn_t adintr(int irq, void *dev_id);
 
 #ifndef EXCLUDE_TIMERS
 static int ad1848_tmr_install(int dev);
@@ -1991,7 +1992,7 @@
 			devc->audio_flags |= DMA_DUPLEX;
 	}
 
-	portc = (ad1848_port_info *) kmalloc(sizeof(ad1848_port_info), GFP_KERNEL);
+	portc = kmalloc(sizeof(ad1848_port_info), GFP_KERNEL);
 	if(portc==NULL) {
 		release_region(devc->base, 4);
 		return -1;
@@ -2195,7 +2196,7 @@
 		printk(KERN_ERR "ad1848: Can't find device to be unloaded. Base=%x\n", io_base);
 }
 
-irqreturn_t adintr(int irq, void *dev_id, struct pt_regs *dummy)
+static irqreturn_t adintr(int irq, void *dev_id)
 {
 	unsigned char status;
 	ad1848_info *devc;
@@ -2802,7 +2803,6 @@
 EXPORT_SYMBOL(ad1848_init);
 EXPORT_SYMBOL(ad1848_unload);
 EXPORT_SYMBOL(ad1848_control);
-EXPORT_SYMBOL(adintr);
 EXPORT_SYMBOL(probe_ms_sound);
 EXPORT_SYMBOL(attach_ms_sound);
 EXPORT_SYMBOL(unload_ms_sound);
--- linux-2.6.18.noarch/sound/oss/midi_synth.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/midi_synth.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/midi_synth.c
+ * sound/oss/midi_synth.c
  *
  * High level midi sequencer manager for dumb MIDI interfaces.
  */
@@ -84,6 +84,7 @@
 		  ;
 	  }
 }
+EXPORT_SYMBOL(do_midi_msg);
 
 static void
 midi_outc(int midi_dev, int data)
@@ -276,6 +277,7 @@
 		return -EINVAL;
 	}
 }
+EXPORT_SYMBOL(midi_synth_ioctl);
 
 int
 midi_synth_kill_note(int dev, int channel, int note, int velocity)
@@ -342,6 +344,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(midi_synth_kill_note);
 
 int
 midi_synth_set_instr(int dev, int channel, int instr_no)
@@ -364,6 +367,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(midi_synth_set_instr);
 
 int
 midi_synth_start_note(int dev, int channel, int note, int velocity)
@@ -405,6 +409,7 @@
 	  }
 	return 0;
 }
+EXPORT_SYMBOL(midi_synth_start_note);
 
 void
 midi_synth_reset(int dev)
@@ -412,6 +417,7 @@
 
 	leave_sysex(dev);
 }
+EXPORT_SYMBOL(midi_synth_reset);
 
 int
 midi_synth_open(int dev, int mode)
@@ -444,6 +450,7 @@
 
 	return 1;
 }
+EXPORT_SYMBOL(midi_synth_open);
 
 void
 midi_synth_close(int dev)
@@ -459,11 +466,13 @@
 
 	midi_devs[orig_dev]->close(orig_dev);
 }
+EXPORT_SYMBOL(midi_synth_close);
 
 void
 midi_synth_hw_control(int dev, unsigned char *event)
 {
 }
+EXPORT_SYMBOL(midi_synth_hw_control);
 
 int
 midi_synth_load_patch(int dev, int format, const char __user *addr,
@@ -542,11 +551,13 @@
 		midi_outc(orig_dev, 0xf7);
 	return 0;
 }
-  
+EXPORT_SYMBOL(midi_synth_load_patch);
+
 void midi_synth_panning(int dev, int channel, int pressure)
 {
 }
-  
+EXPORT_SYMBOL(midi_synth_panning);
+
 void midi_synth_aftertouch(int dev, int channel, int pressure)
 {
 	int             orig_dev = synth_devs[dev]->midi_dev;
@@ -576,6 +587,7 @@
 
 	midi_outc(orig_dev, pressure);
 }
+EXPORT_SYMBOL(midi_synth_aftertouch);
 
 void
 midi_synth_controller(int dev, int channel, int ctrl_num, int value)
@@ -604,6 +616,7 @@
 	midi_outc(orig_dev, ctrl_num);
 	midi_outc(orig_dev, value & 0x7f);
 }
+EXPORT_SYMBOL(midi_synth_controller);
 
 void
 midi_synth_bender(int dev, int channel, int value)
@@ -635,11 +648,13 @@
 	midi_outc(orig_dev, value & 0x7f);
 	midi_outc(orig_dev, (value >> 7) & 0x7f);
 }
+EXPORT_SYMBOL(midi_synth_bender);
 
 void
 midi_synth_setup_voice(int dev, int voice, int channel)
 {
 }
+EXPORT_SYMBOL(midi_synth_setup_voice);
 
 int
 midi_synth_send_sysex(int dev, unsigned char *bytes, int len)
@@ -695,3 +710,5 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(midi_synth_send_sysex);
+
--- linux-2.6.18.noarch/sound/oss/ac97.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ac97.c	2007-06-05 17:44:14.000000000 -0400
@@ -112,25 +112,6 @@
     return 0;
 }
 
-/* Reset the mixer to the currently saved settings.  */
-int
-ac97_reset (struct ac97_hwint *dev)
-{
-    int x;
-
-    if (dev->reset_device (dev))
-	return -1;
-
-    /* Now set the registers back to their last-written values. */
-    for (x = 0; mixerRegs[x].ac97_regnum != -1; x++) {
-	int regnum = mixerRegs[x].ac97_regnum;
-	int value = dev->last_written_mixer_values [regnum / 2];
-	if (value >= 0)
-	    ac97_put_register (dev, regnum, value);
-    }
-    return 0;
-}
-
 /* Return the contents of register REG; use the cache if the value in it
    is valid.  Returns a negative error code on failure. */
 static int
@@ -441,7 +422,6 @@
 EXPORT_SYMBOL(ac97_set_values);
 EXPORT_SYMBOL(ac97_put_register);
 EXPORT_SYMBOL(ac97_mixer_ioctl);
-EXPORT_SYMBOL(ac97_reset);
 MODULE_LICENSE("GPL");
 
 
--- linux-2.6.18.noarch/sound/oss/ac97_plugin_ad1980.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ac97_plugin_ad1980.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,126 +0,0 @@
-/*
-    ac97_plugin_ad1980.c  Copyright (C) 2003 Red Hat, Inc. All rights reserved.
-
-   The contents of this file are subject to the Open Software License version 1.1
-   that can be found at http://www.opensource.org/licenses/osl-1.1.txt and is 
-   included herein by reference. 
-   
-   Alternatively, the contents of this file may be used under the
-   terms of the GNU General Public License version 2 (the "GPL") as 
-   distributed in the kernel source COPYING file, in which
-   case the provisions of the GPL are applicable instead of the
-   above.  If you wish to allow the use of your version of this file
-   only under the terms of the GPL and not to allow others to use
-   your version of this file under the OSL, indicate your decision
-   by deleting the provisions above and replace them with the notice
-   and other provisions required by the GPL.  If you do not delete
-   the provisions above, a recipient may use your version of this
-   file under either the OSL or the GPL.
-   
-   Authors: 	Alan Cox <alan@redhat.com>
-
-   This is an example codec plugin. This one switches the connections
-   around to match the setups some vendors use with audio switched to
-   non standard front connectors not the normal rear ones
-
-   This code primarily exists to demonstrate how to use the codec
-   interface
-
-*/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ac97_codec.h>
-
-/**
- *	ad1980_remove		-	codec remove callback
- *	@codec: The codec that is being removed
- *
- *	This callback occurs when an AC97 codec is being removed. A
- *	codec remove call will not occur for a codec during that codec
- *	probe callback.
- *
- *	Most drivers will need to lock their remove versus their 
- *	use of the codec after the probe function.
- */
- 
-static void __devexit ad1980_remove(struct ac97_codec *codec, struct ac97_driver *driver)
-{
-	/* Nothing to do in the simple example */
-}
-
-
-/**
- *	ad1980_probe		-	codec found callback
- *	@codec: ac97 codec matching the idents
- *	@driver: ac97_driver it matched
- *
- *	This entry point is called when a codec is found which matches
- *	the driver. At the point it is called the codec is basically
- *	operational, mixer operations have been initialised and can
- *	be overriden. Called in process context. The field driver_private
- *	is available for the driver to use to store stuff.
- *
- *	The caller can claim the device by returning zero, or return
- *	a negative error code. 
- */
- 
-static int ad1980_probe(struct ac97_codec *codec, struct ac97_driver *driver)
-{
-	u16 control;
-
-#define AC97_AD_MISC	0x76
-
-	/* Switch the inputs/outputs over (from Dell code) */
-	control = codec->codec_read(codec, AC97_AD_MISC);
-	codec->codec_write(codec, AC97_AD_MISC, control | 0x4420);
-	
-	/* We could refuse the device since we dont need to hang around,
-	   but we will claim it */
-	return 0;
-}
-	
- 
-static struct ac97_driver ad1980_driver = {
-	.codec_id	= 0x41445370,
-	.codec_mask	= 0xFFFFFFFF,
-	.name		= "AD1980 example",
-	.probe		= ad1980_probe,
-	.remove		= __devexit_p(ad1980_remove),
-};
-
-/**
- *	ad1980_exit		-	module exit path
- *
- *	Our module is being unloaded. At this point unregister_driver
- *	will call back our remove handler for any existing codecs. You
- *	may not unregister_driver from interrupt context or from a 
- *	probe/remove callback.
- */
-
-static void ad1980_exit(void)
-{
-	ac97_unregister_driver(&ad1980_driver);
-}
-
-/**
- *	ad1980_init		-	set up ad1980 handlers
- *
- *	After we call the register function it will call our probe
- *	function for each existing matching device before returning to us.
- *	Any devices appearing afterwards whose id's match the codec_id
- *	will also cause the probe function to be called.
- *	You may not register_driver from interrupt context or from a 
- *	probe/remove callback.
- */
- 
-static int ad1980_init(void)
-{
-	return ac97_register_driver(&ad1980_driver);
-}
-
-module_init(ad1980_init);
-module_exit(ad1980_exit);
-MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/oss/harmony.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/harmony.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,1330 +0,0 @@
-/*
- 	drivers/sound/harmony.c 
-
-	This is a sound driver for ASP's and Lasi's Harmony sound chip
-	and is unlikely to be used for anything other than on a HP PA-RISC.
-
-	Harmony is found in HP 712s, 715/new and many other GSC based machines.
-	On older 715 machines you'll find the technically identical chip 
-	called 'Vivace'. Both Harmony and Vicace are supported by this driver.
-
-	Copyright 2000 (c) Linuxcare Canada, Alex deVries <alex@onefishtwo.ca>
-	Copyright 2000-2003 (c) Helge Deller <deller@gmx.de>
-	Copyright 2001 (c) Matthieu Delahaye <delahaym@esiee.fr>
-	Copyright 2001 (c) Jean-Christophe Vaugeois <vaugeoij@esiee.fr>
-	Copyright 2004 (c) Stuart Brady <sdbrady@ntlworld.com>
-
-				
-TODO:
-	- fix SNDCTL_DSP_GETOSPACE and SNDCTL_DSP_GETISPACE ioctls to
-		return the real values
-	- add private ioctl for selecting line- or microphone input
-		(only one of them is available at the same time)
-	- add module parameters
-	- implement mmap functionality
-	- implement gain meter ?
-	- ...
-*/
-
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/pci.h>
-
-#include <asm/parisc-device.h>
-#include <asm/io.h>
-
-#include "sound_config.h"
-
-
-#define PFX "harmony: "
-#define HARMONY_VERSION "V0.9a"
-
-#undef DEBUG
-#ifdef DEBUG
-# define DPRINTK printk 
-#else
-# define DPRINTK(x,...)
-#endif
-
-
-#define MAX_BUFS 10		/* maximum number of rotating buffers */
-#define HARMONY_BUF_SIZE 4096	/* needs to be a multiple of PAGE_SIZE (4096)! */
-
-#define CNTL_C		0x80000000
-#define	CNTL_ST		0x00000020
-#define CNTL_44100	0x00000015	/* HARMONY_SR_44KHZ */
-#define CNTL_8000	0x00000008	/* HARMONY_SR_8KHZ */
-
-#define GAINCTL_HE	0x08000000
-#define GAINCTL_LE	0x04000000
-#define GAINCTL_SE	0x02000000
-
-#define DSTATUS_PN	0x00000200
-#define DSTATUS_RN	0x00000002
-
-#define DSTATUS_IE	0x80000000
-
-#define HARMONY_DF_16BIT_LINEAR	0
-#define HARMONY_DF_8BIT_ULAW	1
-#define HARMONY_DF_8BIT_ALAW	2
-
-#define HARMONY_SS_MONO		0
-#define HARMONY_SS_STEREO	1
-
-#define HARMONY_SR_8KHZ		0x08
-#define HARMONY_SR_16KHZ	0x09
-#define HARMONY_SR_27KHZ	0x0A
-#define HARMONY_SR_32KHZ	0x0B
-#define HARMONY_SR_48KHZ	0x0E
-#define HARMONY_SR_9KHZ		0x0F
-#define HARMONY_SR_5KHZ		0x10
-#define HARMONY_SR_11KHZ	0x11
-#define HARMONY_SR_18KHZ	0x12
-#define HARMONY_SR_22KHZ	0x13
-#define HARMONY_SR_37KHZ	0x14
-#define HARMONY_SR_44KHZ	0x15
-#define HARMONY_SR_33KHZ	0x16
-#define HARMONY_SR_6KHZ		0x17
-
-/*
- * Some magics numbers used to auto-detect file formats
- */
-
-#define HARMONY_MAGIC_8B_ULAW	1
-#define HARMONY_MAGIC_8B_ALAW	27
-#define HARMONY_MAGIC_16B_LINEAR 3
-#define HARMONY_MAGIC_MONO	1
-#define HARMONY_MAGIC_STEREO	2
-
-/*
- * Channels Positions in mixer register
- */
-
-#define GAIN_HE_SHIFT   27
-#define GAIN_HE_MASK    ( 1 << GAIN_HE_SHIFT) 
-#define GAIN_LE_SHIFT   26
-#define GAIN_LE_MASK    ( 1 << GAIN_LE_SHIFT) 
-#define GAIN_SE_SHIFT   25
-#define GAIN_SE_MASK    ( 1 << GAIN_SE_SHIFT) 
-#define GAIN_IS_SHIFT   24
-#define GAIN_IS_MASK    ( 1 << GAIN_IS_SHIFT) 
-#define GAIN_MA_SHIFT   20
-#define GAIN_MA_MASK    ( 0x0f << GAIN_MA_SHIFT) 
-#define GAIN_LI_SHIFT   16
-#define GAIN_LI_MASK    ( 0x0f << GAIN_LI_SHIFT) 
-#define GAIN_RI_SHIFT   12
-#define GAIN_RI_MASK    ( 0x0f << GAIN_RI_SHIFT) 
-#define GAIN_LO_SHIFT   6
-#define GAIN_LO_MASK    ( 0x3f << GAIN_LO_SHIFT) 
-#define GAIN_RO_SHIFT   0
-#define GAIN_RO_MASK    ( 0x3f << GAIN_RO_SHIFT) 
-
-
-#define MAX_OUTPUT_LEVEL  (GAIN_RO_MASK >> GAIN_RO_SHIFT)
-#define MAX_INPUT_LEVEL   (GAIN_RI_MASK >> GAIN_RI_SHIFT)
-#define MAX_MONITOR_LEVEL (GAIN_MA_MASK >> GAIN_MA_SHIFT)
-
-#define MIXER_INTERNAL   SOUND_MIXER_LINE1
-#define MIXER_LINEOUT    SOUND_MIXER_LINE2
-#define MIXER_HEADPHONES SOUND_MIXER_LINE3
-
-#define MASK_INTERNAL   SOUND_MASK_LINE1
-#define MASK_LINEOUT    SOUND_MASK_LINE2
-#define MASK_HEADPHONES SOUND_MASK_LINE3
-
-/*
- * Channels Mask in mixer register
- */
-
-#define GAIN_TOTAL_SILENCE 0x00F00FFF
-#define GAIN_DEFAULT       0x0FF00000
-
-
-struct harmony_hpa {
-	u8	unused000;
-	u8	id;
-	u8	teleshare_id;
-	u8	unused003;
-	u32	reset;
-	u32	cntl;
-	u32	gainctl;
-	u32	pnxtadd;
-	u32	pcuradd;
-	u32	rnxtadd;
-	u32	rcuradd;
-	u32	dstatus;
-	u32	ov;
-	u32	pio;
-	u32	unused02c;
-	u32	unused030[3];
-	u32	diag;
-};
-
-struct harmony_dev {
-	struct harmony_hpa *hpa;
-	struct parisc_device *dev;
-	u32 current_gain;
-	u32 dac_rate;		/* 8000 ... 48000 (Hz) */
-	u8 data_format;		/* HARMONY_DF_xx_BIT_xxx */
-	u8 sample_rate;		/* HARMONY_SR_xx_KHZ */
-	u8 stereo_select;	/* HARMONY_SS_MONO or HARMONY_SS_STEREO */
-	int format_initialized  :1;
-	int suspended_playing   :1;
-	int suspended_recording :1;
-	
-	int blocked_playing     :1;
-	int blocked_recording   :1;
-	int audio_open		:1;
-	int mixer_open		:1;
-	
-	wait_queue_head_t wq_play, wq_record;
-	int first_filled_play;	/* first buffer containing data (next to play) */
-	int nb_filled_play; 
-	int play_offset;
-	int first_filled_record;
-	int nb_filled_record;
-		
-	int dsp_unit, mixer_unit;
-};
-
-
-static struct harmony_dev harmony;
-
-
-/*
- * Dynamic sound buffer allocation and DMA memory
- */
-
-struct harmony_buffer {
-	unsigned char *addr;
-	dma_addr_t dma_handle;
-	int dma_coherent;	/* Zero if dma_alloc_coherent() fails */
-	unsigned int len;
-};
-
-/*
- * Harmony memory buffers
- */
-
-static struct harmony_buffer played_buf, recorded_buf, silent, graveyard;
-
-
-#define CHECK_WBACK_INV_OFFSET(b,offset,len) \
-        do { if (!b.dma_coherent) \
-		dma_cache_wback_inv((unsigned long)b.addr+offset,len); \
-	} while (0) 
-
-	
-static int __init harmony_alloc_buffer(struct harmony_buffer *b, 
-		unsigned int buffer_count)
-{
-	b->len = buffer_count * HARMONY_BUF_SIZE;
-	b->addr = dma_alloc_coherent(&harmony.dev->dev, 
-			  b->len, &b->dma_handle, GFP_KERNEL|GFP_DMA);
-	if (b->addr && b->dma_handle) {
-		b->dma_coherent = 1;
-		DPRINTK(KERN_INFO PFX "coherent memory: 0x%lx, played_buf: 0x%lx\n",
-				(unsigned long)b->dma_handle, (unsigned long)b->addr);
-	} else {
-		b->dma_coherent = 0;
-		/* kmalloc()ed memory will HPMC on ccio machines ! */
-		b->addr = kmalloc(b->len, GFP_KERNEL);
-		if (!b->addr) {
-			printk(KERN_ERR PFX "couldn't allocate memory\n");
-			return -EBUSY;
-		}
-		b->dma_handle = __pa(b->addr);
-	}
-	return 0;
-}
-
-static void __exit harmony_free_buffer(struct harmony_buffer *b)
-{
-	if (!b->addr)
-		return;
-
-	if (b->dma_coherent)
-		dma_free_coherent(&harmony.dev->dev,
-				b->len, b->addr, b->dma_handle);
-	else
-		kfree(b->addr);
-
-	memset(b, 0, sizeof(*b));
-}
-
-
-
-/*
- * Low-Level sound-chip programming
- */
-
-static void __inline__ harmony_wait_CNTL(void)
-{
-	/* Wait until we're out of control mode */
-	while (gsc_readl(&harmony.hpa->cntl) & CNTL_C)
-		/* wait */ ;
-}
-
-
-static void harmony_update_control(void) 
-{
-	u32 default_cntl;
-	
-	/* Set CNTL */
-	default_cntl = (CNTL_C |  		/* The C bit */
-		(harmony.data_format << 6) |	/* Set the data format */
-		(harmony.stereo_select << 5) |	/* Stereo select */
-		(harmony.sample_rate));		/* Set sample rate */
-	harmony.format_initialized = 1;
-	
-	/* initialize CNTL */
-	gsc_writel(default_cntl, &harmony.hpa->cntl);
-}
-
-static void harmony_set_control(u8 data_format, u8 sample_rate, u8 stereo_select) 
-{
-	harmony.sample_rate = sample_rate;
-	harmony.data_format = data_format;
-	harmony.stereo_select = stereo_select;
-	harmony_update_control();
-}
-
-static void harmony_set_rate(u8 data_rate) 
-{
-	harmony.sample_rate = data_rate;
-	harmony_update_control();
-}
-
-static int harmony_detect_rate(int *freq)
-{
-	int newrate;
-	switch (*freq) {
-	case 8000:	newrate = HARMONY_SR_8KHZ;	break;
-	case 16000:	newrate = HARMONY_SR_16KHZ;	break; 
-	case 27428:	newrate = HARMONY_SR_27KHZ;	break; 
-	case 32000:	newrate = HARMONY_SR_32KHZ;	break; 
-	case 48000:	newrate = HARMONY_SR_48KHZ;	break; 
-	case 9600:	newrate = HARMONY_SR_9KHZ;	break; 
-	case 5512:	newrate = HARMONY_SR_5KHZ;	break; 
-	case 11025:	newrate = HARMONY_SR_11KHZ;	break; 
-	case 18900:	newrate = HARMONY_SR_18KHZ;	break; 
-	case 22050:	newrate = HARMONY_SR_22KHZ;	break; 
-	case 37800:	newrate = HARMONY_SR_37KHZ;	break; 
-	case 44100:	newrate = HARMONY_SR_44KHZ;	break; 
-	case 33075:	newrate = HARMONY_SR_33KHZ;	break; 
-	case 6615:	newrate = HARMONY_SR_6KHZ;	break; 
-	default:	newrate = HARMONY_SR_8KHZ; 
-			*freq = 8000;			break;
-	}
-	return newrate;
-}
-
-static void harmony_set_format(u8 data_format) 
-{
-	harmony.data_format = data_format;
-	harmony_update_control();
-}
-
-static void harmony_set_stereo(u8 stereo_select) 
-{
-	harmony.stereo_select = stereo_select;
-	harmony_update_control();
-}
-
-static void harmony_disable_interrupts(void) 
-{
-	harmony_wait_CNTL();
-	gsc_writel(0, &harmony.hpa->dstatus); 
-}
-
-static void harmony_enable_interrupts(void) 
-{
-	harmony_wait_CNTL();
-	gsc_writel(DSTATUS_IE, &harmony.hpa->dstatus); 
-}
-
-/*
- * harmony_silence()
- *
- * This subroutine fills in a buffer starting at location start and
- * silences for length bytes.  This references the current
- * configuration of the audio format.
- *
- */
-
-static void harmony_silence(struct harmony_buffer *buffer, int start, int length) 
-{
-	u8 silence_char;
-
-	/* Despite what you hear, silence is different in
-	   different audio formats.  */
-	switch (harmony.data_format) {
-		case HARMONY_DF_8BIT_ULAW:	silence_char = 0x55; break;
-		case HARMONY_DF_8BIT_ALAW:	silence_char = 0xff; break;
-		case HARMONY_DF_16BIT_LINEAR:	/* fall through */
-		default:			silence_char = 0;
-	}
-
-	memset(buffer->addr+start, silence_char, length);
-}
-
-
-static int harmony_audio_open(struct inode *inode, struct file *file)
-{
-	if (harmony.audio_open) 
-		return -EBUSY;
-	
-	harmony.audio_open = 1;
-	harmony.suspended_playing = harmony.suspended_recording = 1;
-	harmony.blocked_playing   = harmony.blocked_recording   = 0;
-	harmony.first_filled_play = harmony.first_filled_record = 0;
-	harmony.nb_filled_play    = harmony.nb_filled_record    = 0;
-	harmony.play_offset = 0;
-	init_waitqueue_head(&harmony.wq_play);
-	init_waitqueue_head(&harmony.wq_record);
-	
-	/* Start off in a balanced mode. */
-	harmony_set_control(HARMONY_DF_8BIT_ULAW, HARMONY_SR_8KHZ, HARMONY_SS_MONO);
-	harmony_update_control();
-	harmony.format_initialized = 0;
-
-	/* Clear out all the buffers and flush to cache */
-	harmony_silence(&played_buf, 0, HARMONY_BUF_SIZE*MAX_BUFS);
-	CHECK_WBACK_INV_OFFSET(played_buf, 0, HARMONY_BUF_SIZE*MAX_BUFS);
-	
-	return 0;
-}
-
-/*
- * Release (close) the audio device.
- */
-
-static int harmony_audio_release(struct inode *inode, struct file *file)
-{
-	if (!harmony.audio_open) 
-		return -EBUSY;
-	
-	harmony.audio_open = 0;
-
-	return 0;
-}
-
-/*
- * Read recorded data off the audio device.
- */
-
-static ssize_t harmony_audio_read(struct file *file,
-                                char *buffer,
-                                size_t size_count,
-                                loff_t *ppos)
-{
-	int total_count = (int) size_count;
-	int count = 0;
-	int buf_to_read;
-
-	while (count<total_count) {
-		/* Wait until we're out of control mode */
-		harmony_wait_CNTL();
-		
-		/* Figure out which buffer to fill in */
-		if (harmony.nb_filled_record <= 2) {
-			harmony.blocked_recording = 1;
-		        if (harmony.suspended_recording) {
-				harmony.suspended_recording = 0;
-				harmony_enable_interrupts();
-			}
-							
-			interruptible_sleep_on(&harmony.wq_record);
-			harmony.blocked_recording = 0;
-		}
-		
-		if (harmony.nb_filled_record < 2)
-			return -EBUSY;
-		
-		buf_to_read = harmony.first_filled_record;
-
-		/* Copy the page to an aligned buffer */
-		if (copy_to_user(buffer+count, recorded_buf.addr +
-				 (HARMONY_BUF_SIZE*buf_to_read),
-				 HARMONY_BUF_SIZE)) {
-			count = -EFAULT;
-			break;
-		}
-		
-		harmony.nb_filled_record--;
-		harmony.first_filled_record++;
-		harmony.first_filled_record %= MAX_BUFS;
-				
-		count += HARMONY_BUF_SIZE;
-	}
-	return count;
-}
-
-
-
-
-/*
- * Here is the place where we try to recognize file format.
- * Sun/NeXT .au files begin with the string .snd
- * At offset 12 is specified the encoding.
- * At offset 16 is specified speed rate
- * At Offset 20 is specified the numbers of voices
- */
-
-#define four_bytes_to_u32(start) (file_header[start] << 24)|\
-                                  (file_header[start+1] << 16)|\
-                                  (file_header[start+2] << 8)|\
-                                  (file_header[start+3]);
-
-#define test_rate(tested,real_value,harmony_value) if ((tested)<=(real_value))\
-                                                    
-
-static int harmony_format_auto_detect(const char *buffer, int block_size)
-{
-	u8 file_header[24];
-	u32 start_string;
-	int ret = 0;
-	
-	if (block_size>24) {
-		if (copy_from_user(file_header, buffer, sizeof(file_header)))
-			ret = -EFAULT;
-			
-		start_string = four_bytes_to_u32(0);
-		
-		if ((file_header[4]==0) && (start_string==0x2E736E64)) {
-			u32 format;
-			u32 nb_voices;
-			u32 speed;
-			
-			format = four_bytes_to_u32(12);
-			nb_voices = four_bytes_to_u32(20);
-			speed = four_bytes_to_u32(16);
-			
-			switch (format) {
-			case HARMONY_MAGIC_8B_ULAW:
-				harmony.data_format = HARMONY_DF_8BIT_ULAW;
-				break;
-			case HARMONY_MAGIC_8B_ALAW:
-				harmony.data_format = HARMONY_DF_8BIT_ALAW;
-				break;
-			case HARMONY_MAGIC_16B_LINEAR:
-				harmony.data_format = HARMONY_DF_16BIT_LINEAR;
-				break;
-			default:
-				harmony_set_control(HARMONY_DF_16BIT_LINEAR,
-						HARMONY_SR_44KHZ, HARMONY_SS_STEREO);
-				goto out;
-			}
-			switch (nb_voices) {
-			case HARMONY_MAGIC_MONO:
-				harmony.stereo_select = HARMONY_SS_MONO;
-				break;
-			case HARMONY_MAGIC_STEREO:
-				harmony.stereo_select = HARMONY_SS_STEREO;
-				break;
-			default:
-				harmony.stereo_select = HARMONY_SS_MONO;
-				break;
-			}
-			harmony_set_rate(harmony_detect_rate(&speed));
-			harmony.dac_rate = speed;
-			goto out;
-		}
-	}
-	harmony_set_control(HARMONY_DF_8BIT_ULAW, HARMONY_SR_8KHZ, HARMONY_SS_MONO);
-out:
-	return ret;
-}
-#undef four_bytes_to_u32
-
-
-static ssize_t harmony_audio_write(struct file *file,
-                                 const char *buffer,
-                                 size_t size_count,
-                                 loff_t *ppos)
-{
-	int total_count = (int) size_count;
-	int count = 0;
-	int frame_size;
-	int buf_to_fill;
-	int fresh_buffer;
-
-	if (!harmony.format_initialized) {
-		if (harmony_format_auto_detect(buffer, total_count))
-			return -EFAULT;
-	}
-	
-	while (count<total_count) {
-		/* Wait until we're out of control mode */
-		harmony_wait_CNTL();
-
-		/* Figure out which buffer to fill in */
-		if (harmony.nb_filled_play+2 >= MAX_BUFS && !harmony.play_offset) {
-			harmony.blocked_playing = 1;
-			interruptible_sleep_on(&harmony.wq_play);
-			harmony.blocked_playing = 0;
-		}
-		if (harmony.nb_filled_play+2 >= MAX_BUFS && !harmony.play_offset)
-			return -EBUSY;
-		
-		
-		buf_to_fill = (harmony.first_filled_play+harmony.nb_filled_play); 
-		if (harmony.play_offset) {
-			buf_to_fill--;
-			buf_to_fill += MAX_BUFS;
-		}
-		buf_to_fill %= MAX_BUFS;
-		
-		fresh_buffer = (harmony.play_offset == 0);
-		
-		/* Figure out the size of the frame */
-		if ((total_count-count) >= HARMONY_BUF_SIZE - harmony.play_offset) {
-			frame_size = HARMONY_BUF_SIZE - harmony.play_offset;
-		} else {
-			frame_size = total_count - count;
-			/* Clear out the buffer, since there we'll only be 
-			   overlaying part of the old buffer with the new one */
-			harmony_silence(&played_buf, 
-				HARMONY_BUF_SIZE*buf_to_fill+frame_size+harmony.play_offset,
-				HARMONY_BUF_SIZE-frame_size-harmony.play_offset);
-		}
-
-		/* Copy the page to an aligned buffer */
-		if (copy_from_user(played_buf.addr +(HARMONY_BUF_SIZE*buf_to_fill) + harmony.play_offset, 
-				   buffer+count, frame_size))
-			return -EFAULT;
-		CHECK_WBACK_INV_OFFSET(played_buf, (HARMONY_BUF_SIZE*buf_to_fill + harmony.play_offset), 
-				frame_size);
-	
-		if (fresh_buffer)
-			harmony.nb_filled_play++;
-		
-		count += frame_size;
-		harmony.play_offset += frame_size;
-		harmony.play_offset %= HARMONY_BUF_SIZE;
-		if (harmony.suspended_playing && (harmony.nb_filled_play>=4))
-			harmony_enable_interrupts();
-	}
-	
-	return count;
-}
-
-static unsigned int harmony_audio_poll(struct file *file,
-                                     struct poll_table_struct *wait)
-{
-	unsigned int mask = 0;
-	
-	if (file->f_mode & FMODE_READ) {
-		if (!harmony.suspended_recording)
-			poll_wait(file, &harmony.wq_record, wait);
-		if (harmony.nb_filled_record)
-			mask |= POLLIN | POLLRDNORM;
-	}
-
-	if (file->f_mode & FMODE_WRITE) {
-		if (!harmony.suspended_playing)
-			poll_wait(file, &harmony.wq_play, wait);
-		if (harmony.nb_filled_play)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-
-	return mask;
-}
-
-static int harmony_audio_ioctl(struct inode *inode,
-                                struct file *file,
-				unsigned int cmd,
-                                unsigned long arg)
-{
-	int ival, new_format;
-	int frag_size, frag_buf;
-	struct audio_buf_info info;
-	
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, (int *) arg);
-
-	case SNDCTL_DSP_GETCAPS:
-		ival = DSP_CAP_DUPLEX;
-		return put_user(ival, (int *) arg);
-
-	case SNDCTL_DSP_GETFMTS:
-		ival = (AFMT_S16_BE | AFMT_MU_LAW | AFMT_A_LAW ); 
-		return put_user(ival, (int *) arg);
-	
-	case SNDCTL_DSP_SETFMT:
-		if (get_user(ival, (int *) arg)) 
-			return -EFAULT;
-		if (ival != AFMT_QUERY) {
-			switch (ival) {
-			case AFMT_MU_LAW:	new_format = HARMONY_DF_8BIT_ULAW; break;
-			case AFMT_A_LAW:	new_format = HARMONY_DF_8BIT_ALAW; break;
-			case AFMT_S16_BE:	new_format = HARMONY_DF_16BIT_LINEAR; break;
-			default: {
-				DPRINTK(KERN_WARNING PFX 
-					"unsupported sound format 0x%04x requested.\n",
-					ival);
-				ival = AFMT_S16_BE;
-				return put_user(ival, (int *) arg);
-			}
-			}
-			harmony_set_format(new_format);
-			return 0;
-		} else {
-			switch (harmony.data_format) {
-			case HARMONY_DF_8BIT_ULAW:	ival = AFMT_MU_LAW; break;
-			case HARMONY_DF_8BIT_ALAW:	ival = AFMT_A_LAW;  break;
-			case HARMONY_DF_16BIT_LINEAR:	ival = AFMT_U16_BE; break;
-			default: ival = 0;
-			}
-			return put_user(ival, (int *) arg);
-		}
-
-	case SOUND_PCM_READ_RATE:
-		ival = harmony.dac_rate;
-		return put_user(ival, (int *) arg);
-
-	case SNDCTL_DSP_SPEED:
-		if (get_user(ival, (int *) arg))
-			return -EFAULT;
-		harmony_set_rate(harmony_detect_rate(&ival));
-		harmony.dac_rate = ival;
-		return put_user(ival, (int*) arg);
-
-	case SNDCTL_DSP_STEREO:
-		if (get_user(ival, (int *) arg))
-			return -EFAULT;
-		if (ival != 0 && ival != 1)
-			return -EINVAL;
-		harmony_set_stereo(ival);
- 		return 0;
- 
- 	case SNDCTL_DSP_CHANNELS:
- 		if (get_user(ival, (int *) arg))
- 			return -EFAULT;
- 		if (ival != 1 && ival != 2) {
- 			ival = harmony.stereo_select == HARMONY_SS_MONO ? 1 : 2;
- 			return put_user(ival, (int *) arg);
- 		}
- 		harmony_set_stereo(ival-1);
- 		return 0;
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		ival = HARMONY_BUF_SIZE;
-		return put_user(ival, (int *) arg);
-		
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_RESET:
-		if (!harmony.suspended_recording) {
-			/* TODO: stop_recording() */
-		}
-		return 0;
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(ival, (int *)arg))
-			return -EFAULT;
-		frag_size = ival & 0xffff;
-		frag_buf = (ival>>16) & 0xffff;
-		/* TODO: We use hardcoded fragment sizes and numbers for now */
-		frag_size = 12;  /* 4096 == 2^12 */
-		frag_buf  = MAX_BUFS;
-		ival = (frag_buf << 16) + frag_size;
-		return put_user(ival, (int *) arg);
-		
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		info.fragstotal = MAX_BUFS;
-                info.fragments = MAX_BUFS - harmony.nb_filled_play;
-		info.fragsize = HARMONY_BUF_SIZE;
-                info.bytes = info.fragments * info.fragsize;
-		return copy_to_user((void *)arg, &info, sizeof(info)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		info.fragstotal = MAX_BUFS;
-                info.fragments = /*MAX_BUFS-*/ harmony.nb_filled_record;
-		info.fragsize = HARMONY_BUF_SIZE;
-                info.bytes = info.fragments * info.fragsize;
-		return copy_to_user((void *)arg, &info, sizeof(info)) ? -EFAULT : 0;
-	
-	case SNDCTL_DSP_SYNC:
-		return 0;
-	}
-	
-	return -EINVAL;
-}
-
-
-/*
- * harmony_interrupt()
- *
- * harmony interruption service routine
- * 
- */
-
-static irqreturn_t harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
-{
-	u32 dstatus;
-	struct harmony_hpa *hpa;
-
-	/* Setup the hpa */
-	hpa = ((struct harmony_dev *)dev)->hpa;
-	harmony_wait_CNTL();
-
-	/* Read dstatus and pcuradd (the current address) */
-	dstatus = gsc_readl(&hpa->dstatus);
-	
-	/* Turn off interrupts */
-	harmony_disable_interrupts();
-	
-	/* Check if this is a request to get the next play buffer */
-	if (dstatus & DSTATUS_PN) {
-		if (!harmony.nb_filled_play) {
-			harmony.suspended_playing = 1;
-			gsc_writel((unsigned long)silent.dma_handle, &hpa->pnxtadd);
-						
-			if (!harmony.suspended_recording)
-				harmony_enable_interrupts();
-		} else {
-			harmony.suspended_playing = 0;
-			gsc_writel((unsigned long)played_buf.dma_handle + 
-					(HARMONY_BUF_SIZE*harmony.first_filled_play),
-					&hpa->pnxtadd);
-			harmony.first_filled_play++;
-			harmony.first_filled_play %= MAX_BUFS;
-			harmony.nb_filled_play--;
-			
-		       	harmony_enable_interrupts();
-		}
-		
-		if (harmony.blocked_playing)
-			wake_up_interruptible(&harmony.wq_play);
-	}
-	
-	/* Check if we're being asked to fill in a recording buffer */
-	if (dstatus & DSTATUS_RN) {
-		if((harmony.nb_filled_record+2>=MAX_BUFS) || harmony.suspended_recording)
-		{
-			harmony.nb_filled_record = 0;
-			harmony.first_filled_record = 0;
-			harmony.suspended_recording = 1;
-			gsc_writel((unsigned long)graveyard.dma_handle, &hpa->rnxtadd);
-			if (!harmony.suspended_playing)
-				harmony_enable_interrupts();
-		} else {
-			int buf_to_fill;
-			buf_to_fill = (harmony.first_filled_record+harmony.nb_filled_record) % MAX_BUFS;
-			CHECK_WBACK_INV_OFFSET(recorded_buf, HARMONY_BUF_SIZE*buf_to_fill, HARMONY_BUF_SIZE);
-			gsc_writel((unsigned long)recorded_buf.dma_handle +
-					HARMONY_BUF_SIZE*buf_to_fill,
-					&hpa->rnxtadd);
-			harmony.nb_filled_record++;
-			harmony_enable_interrupts();
-		}
-
-		if (harmony.blocked_recording && harmony.nb_filled_record>3)
-			wake_up_interruptible(&harmony.wq_record);
-	}
-	return IRQ_HANDLED;
-}
-
-/*
- * Sound playing functions
- */
-
-static struct file_operations harmony_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= harmony_audio_read,
-	.write		= harmony_audio_write,
-	.poll		= harmony_audio_poll,
-	.ioctl		= harmony_audio_ioctl,
-	.open		= harmony_audio_open,
-	.release	= harmony_audio_release,
-};
-
-static int harmony_audio_init(void)
-{
-	/* Request that IRQ */
-	if (request_irq(harmony.dev->irq, harmony_interrupt, 0 ,"harmony", &harmony)) {
-		printk(KERN_ERR PFX "Error requesting irq %d.\n", harmony.dev->irq);
-		return -EFAULT;
-	}
-
-   	harmony.dsp_unit = register_sound_dsp(&harmony_audio_fops, -1);
-	if (harmony.dsp_unit < 0) {
-		printk(KERN_ERR PFX "Error registering dsp\n");
-		free_irq(harmony.dev->irq, &harmony);
-		return -EFAULT;
-	}
-	
-	/* Clear the buffers so you don't end up with crap in the buffers. */ 
-	harmony_silence(&played_buf, 0, HARMONY_BUF_SIZE*MAX_BUFS);
-
-	/* Make sure this makes it to cache */
-	CHECK_WBACK_INV_OFFSET(played_buf, 0, HARMONY_BUF_SIZE*MAX_BUFS);
-
-	/* Clear out the silent buffer and flush to cache */
-	harmony_silence(&silent, 0, HARMONY_BUF_SIZE);
-	CHECK_WBACK_INV_OFFSET(silent, 0, HARMONY_BUF_SIZE);
-	
-	harmony.audio_open = 0;
-	
-	return 0;
-}
-
-
-/*
- * mixer functions 
- */
-
-static void harmony_mixer_set_gain(void)
-{
-	harmony_wait_CNTL();
-	gsc_writel(harmony.current_gain, &harmony.hpa->gainctl);
-}
-
-/* 
- *  Read gain of selected channel.
- *  The OSS rate is from 0 (silent) to 100 -> need some conversions
- *
- *  The harmony gain are attenuation for output and monitor gain.
- *                   is amplifaction for input gain
- */
-#define to_harmony_level(level,max) ((level)*max/100)
-#define to_oss_level(level,max) ((level)*100/max)
-
-static int harmony_mixer_get_level(int channel)
-{
-	int left_level;
-	int right_level;
-
-	switch (channel) {
-		case SOUND_MIXER_VOLUME:
-			left_level  = (harmony.current_gain & GAIN_LO_MASK) >> GAIN_LO_SHIFT;
-			right_level = (harmony.current_gain & GAIN_RO_MASK) >> GAIN_RO_SHIFT;
-			left_level  = to_oss_level(MAX_OUTPUT_LEVEL - left_level, MAX_OUTPUT_LEVEL);
-			right_level = to_oss_level(MAX_OUTPUT_LEVEL - right_level, MAX_OUTPUT_LEVEL);
-			return (right_level << 8)+left_level;
-			
-		case SOUND_MIXER_IGAIN:
-			left_level = (harmony.current_gain & GAIN_LI_MASK) >> GAIN_LI_SHIFT;
-			right_level= (harmony.current_gain & GAIN_RI_MASK) >> GAIN_RI_SHIFT;
-			left_level = to_oss_level(left_level, MAX_INPUT_LEVEL);
-			right_level= to_oss_level(right_level, MAX_INPUT_LEVEL);
-			return (right_level << 8)+left_level;
-			
-		case SOUND_MIXER_MONITOR:
-			left_level = (harmony.current_gain & GAIN_MA_MASK) >> GAIN_MA_SHIFT;
-			left_level = to_oss_level(MAX_MONITOR_LEVEL-left_level, MAX_MONITOR_LEVEL);
-			return (left_level << 8)+left_level;
-	}
-	return -EINVAL;
-}
-
-
-
-/*
- * Some conversions for the same reasons.
- * We give back the new real value(s) due to
- * the rescale.
- */
-
-static int harmony_mixer_set_level(int channel, int value)
-{
-	int left_level;
-	int right_level;
-	int new_left_level;
-	int new_right_level;
-
-	right_level = (value & 0x0000ff00) >> 8;
-	left_level = value & 0x000000ff;
-	if (right_level > 100) right_level = 100;
-	if (left_level > 100) left_level = 100;
-  
-	switch (channel) {
-		case SOUND_MIXER_VOLUME:
-			right_level = to_harmony_level(100-right_level, MAX_OUTPUT_LEVEL);
-			left_level  = to_harmony_level(100-left_level, MAX_OUTPUT_LEVEL);
-			new_right_level = to_oss_level(MAX_OUTPUT_LEVEL - right_level, MAX_OUTPUT_LEVEL);
-			new_left_level  = to_oss_level(MAX_OUTPUT_LEVEL - left_level, MAX_OUTPUT_LEVEL);
-			harmony.current_gain = (harmony.current_gain & ~(GAIN_LO_MASK | GAIN_RO_MASK)) 
-					| (left_level << GAIN_LO_SHIFT) | (right_level << GAIN_RO_SHIFT);
-			harmony_mixer_set_gain();
-			return (new_right_level << 8) + new_left_level;
-			
-		case SOUND_MIXER_IGAIN:
-			right_level = to_harmony_level(right_level, MAX_INPUT_LEVEL);
-			left_level  = to_harmony_level(left_level, MAX_INPUT_LEVEL);
-			new_right_level = to_oss_level(right_level, MAX_INPUT_LEVEL);
-			new_left_level  = to_oss_level(left_level, MAX_INPUT_LEVEL);
-			harmony.current_gain = (harmony.current_gain & ~(GAIN_LI_MASK | GAIN_RI_MASK))
-					| (left_level << GAIN_LI_SHIFT) | (right_level << GAIN_RI_SHIFT);
-			harmony_mixer_set_gain();
-			return (new_right_level << 8) + new_left_level;
-	
-		case SOUND_MIXER_MONITOR:
-			left_level = to_harmony_level(100-left_level, MAX_MONITOR_LEVEL);
-			new_left_level = to_oss_level(MAX_MONITOR_LEVEL-left_level, MAX_MONITOR_LEVEL);
-			harmony.current_gain = (harmony.current_gain & ~GAIN_MA_MASK) | (left_level << GAIN_MA_SHIFT);
-			harmony_mixer_set_gain();
-			return (new_left_level << 8) + new_left_level;
-	}
-
-	return -EINVAL;
-}
-
-#undef to_harmony_level
-#undef to_oss_level
-
-/* 
- * Return the selected input device (mic or line)
- */
-
-static int harmony_mixer_get_recmask(void) 
-{
-	int current_input_line;
-	
-	current_input_line = (harmony.current_gain & GAIN_IS_MASK) 
-				    >> GAIN_IS_SHIFT;
-	if (current_input_line) 
-		return SOUND_MASK_MIC;
-
-	return SOUND_MASK_LINE;
-}
-
-/*
- * Set the input (only one at time, arbitrary priority to line in)
- */
-
-static int harmony_mixer_set_recmask(int recmask)
-{
-	int new_input_line;
-	int new_input_mask;
-	int current_input_line;
-	
-	current_input_line = (harmony.current_gain & GAIN_IS_MASK)
-				    >> GAIN_IS_SHIFT;
-	if ((current_input_line && ((recmask & SOUND_MASK_LINE) || !(recmask & SOUND_MASK_MIC))) ||
-		(!current_input_line && ((recmask & SOUND_MASK_LINE) && !(recmask & SOUND_MASK_MIC)))) {
-		new_input_line = 0;
-		new_input_mask = SOUND_MASK_LINE;
-	} else {
-		new_input_line = 1;
-		new_input_mask = SOUND_MASK_MIC;
-	}
-	harmony.current_gain = ((harmony.current_gain & ~GAIN_IS_MASK) | 
-				(new_input_line << GAIN_IS_SHIFT ));
-	harmony_mixer_set_gain();
-	return new_input_mask;
-}
-
-
-/* 
- * give the active outlines
- */
-
-static int harmony_mixer_get_outmask(void)
-{
-	int outmask = 0;
-	
-	if (harmony.current_gain & GAIN_SE_MASK) outmask |= MASK_INTERNAL;
-	if (harmony.current_gain & GAIN_LE_MASK) outmask |= MASK_LINEOUT;
-	if (harmony.current_gain & GAIN_HE_MASK) outmask |= MASK_HEADPHONES;
-	
-	return outmask;
-}
-
-
-static int harmony_mixer_set_outmask(int outmask)
-{
-	if (outmask & MASK_INTERNAL) 
-		harmony.current_gain |= GAIN_SE_MASK;
-	else 
-		harmony.current_gain &= ~GAIN_SE_MASK;
-	
-	if (outmask & MASK_LINEOUT) 
-		harmony.current_gain |= GAIN_LE_MASK;
-	else 
-		harmony.current_gain &= ~GAIN_LE_MASK;
-	
-	if (outmask & MASK_HEADPHONES) 
-		harmony.current_gain |= GAIN_HE_MASK; 
-	else 
-		harmony.current_gain &= ~GAIN_HE_MASK;
-	
-	harmony_mixer_set_gain();
-
-	return (outmask & (MASK_INTERNAL | MASK_LINEOUT | MASK_HEADPHONES));
-}
-
-/*
- * This code is inspired from sb_mixer.c
- */
-
-static int harmony_mixer_ioctl(struct inode * inode, struct file * file,
-		unsigned int cmd, unsigned long arg)
-{
-	int val;
-	int ret;
-
-	if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		memset(&info, 0, sizeof(info));
-                strncpy(info.id, "harmony", sizeof(info.id)-1);
-                strncpy(info.name, "Harmony audio", sizeof(info.name)-1);
-                info.modify_counter = 1; /* ? */
-                if (copy_to_user((void *)arg, &info, sizeof(info)))
-                        return -EFAULT;
-		return 0;
-	}
-	
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, (int *)arg);
-
-	/* read */
-	val = 0;
-	if (_SIOC_DIR(cmd) & _SIOC_WRITE)
-		if (get_user(val, (int *)arg))
-			return -EFAULT;
-
-	switch (cmd) {
-	case MIXER_READ(SOUND_MIXER_CAPS):
-		ret = SOUND_CAP_EXCL_INPUT;
-		break;
-	case MIXER_READ(SOUND_MIXER_STEREODEVS):
-		ret = SOUND_MASK_VOLUME | SOUND_MASK_IGAIN;
-		break;
-		
-	case MIXER_READ(SOUND_MIXER_RECMASK):
-		ret = SOUND_MASK_MIC | SOUND_MASK_LINE;
-		break;
-	case MIXER_READ(SOUND_MIXER_DEVMASK):
-		ret = SOUND_MASK_VOLUME | SOUND_MASK_IGAIN |
-			SOUND_MASK_MONITOR;
-		break;
-	case MIXER_READ(SOUND_MIXER_OUTMASK):
-		ret = MASK_INTERNAL | MASK_LINEOUT |
-			MASK_HEADPHONES;
-		break;
-		
-	case MIXER_WRITE(SOUND_MIXER_RECSRC):
-		ret = harmony_mixer_set_recmask(val);
-		break;
-	case MIXER_READ(SOUND_MIXER_RECSRC):
-		ret = harmony_mixer_get_recmask();
-		break;
-	      
-	case MIXER_WRITE(SOUND_MIXER_OUTSRC):
-		ret = harmony_mixer_set_outmask(val);
-		break;
-	case MIXER_READ(SOUND_MIXER_OUTSRC):
-		ret = harmony_mixer_get_outmask();
-		break;
-	
-	case MIXER_WRITE(SOUND_MIXER_VOLUME):
-	case MIXER_WRITE(SOUND_MIXER_IGAIN):
-	case MIXER_WRITE(SOUND_MIXER_MONITOR):
-		ret = harmony_mixer_set_level(cmd & 0xff, val);
-		break;
-
-	case MIXER_READ(SOUND_MIXER_VOLUME):
-	case MIXER_READ(SOUND_MIXER_IGAIN):
-	case MIXER_READ(SOUND_MIXER_MONITOR):
-		ret = harmony_mixer_get_level(cmd & 0xff);
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	if (put_user(ret, (int *)arg))
-		return -EFAULT;
-	return 0;
-}
-
-
-static int harmony_mixer_open(struct inode *inode, struct file *file)
-{
-	if (harmony.mixer_open) 
-		return -EBUSY;
-	harmony.mixer_open = 1;
-	return 0;
-}
-
-static int harmony_mixer_release(struct inode *inode, struct file *file)
-{
-	if (!harmony.mixer_open) 
-		return -EBUSY;
-	harmony.mixer_open = 0;
-	return 0;
-}
-
-static struct file_operations harmony_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.open		= harmony_mixer_open,
-	.release	= harmony_mixer_release,
-	.ioctl		= harmony_mixer_ioctl,
-};
-
-
-/*
- * Mute all the output and reset Harmony.
- */
-
-static void __init harmony_mixer_reset(void)
-{
-	harmony.current_gain = GAIN_TOTAL_SILENCE;
-	harmony_mixer_set_gain();
-	harmony_wait_CNTL();
-	gsc_writel(1, &harmony.hpa->reset);
-	mdelay(50);		/* wait 50 ms */
-	gsc_writel(0, &harmony.hpa->reset);
-	harmony.current_gain = GAIN_DEFAULT;
-	harmony_mixer_set_gain();
-}
-
-static int __init harmony_mixer_init(void)
-{
-	/* Register the device file operations */
-	harmony.mixer_unit = register_sound_mixer(&harmony_mixer_fops, -1);
-	if (harmony.mixer_unit < 0) {
-		printk(KERN_WARNING PFX "Error Registering Mixer Driver\n");
-		return -EFAULT;
-	}
-  
-	harmony_mixer_reset();
-	harmony.mixer_open = 0;
-	
-	return 0;
-}
-
-
-
-/* 
- * This is the callback that's called by the inventory hardware code 
- * if it finds a match to the registered driver. 
- */
-static int __devinit
-harmony_driver_probe(struct parisc_device *dev)
-{
-	u8	id;
-	u8	rev;
-	u32	cntl;
-	int	ret;
-
-	if (harmony.hpa) {
-		/* We only support one Harmony at this time */
-		printk(KERN_ERR PFX "driver already registered\n");
-		return -EBUSY;
-	}
-
-	if (!dev->irq) {
-		printk(KERN_ERR PFX "no irq found\n");
-		return -ENODEV;
-	}
-
-	/* Set the HPA of harmony */
-	harmony.hpa = (struct harmony_hpa *)dev->hpa.start;
-	harmony.dev = dev;
-
-	/* Grab the ID and revision from the device */
-	id = gsc_readb(&harmony.hpa->id);
-	if ((id | 1) != 0x15) {
-		printk(KERN_WARNING PFX "wrong harmony id 0x%02x\n", id);
-		return -EBUSY;
-	}
-	cntl = gsc_readl(&harmony.hpa->cntl);
-	rev = (cntl>>20) & 0xff;
-
-	printk(KERN_INFO "Lasi Harmony Audio driver " HARMONY_VERSION ", "
-			"h/w id %i, rev. %i at 0x%lx, IRQ %i\n",
-			id, rev, dev->hpa.start, harmony.dev->irq);
-	
-	/* Make sure the control bit isn't set, although I don't think it 
-	   ever is. */
-	if (cntl & CNTL_C) {
-		printk(KERN_WARNING PFX "CNTL busy\n");
-		harmony.hpa = 0;
-		return -EBUSY;
-	}
-
-	/* Initialize the memory buffers */
-	if (harmony_alloc_buffer(&played_buf, MAX_BUFS) || 
-	    harmony_alloc_buffer(&recorded_buf, MAX_BUFS) ||
-	    harmony_alloc_buffer(&graveyard, 1) ||
-	    harmony_alloc_buffer(&silent, 1)) {
-		ret = -EBUSY;
-		goto out_err;
-	}
-
-	/* Initialize /dev/mixer and /dev/audio  */
-	if ((ret=harmony_mixer_init())) 
-		goto out_err;
-	if ((ret=harmony_audio_init())) 
-		goto out_err;
-
-	return 0;
-
-out_err:
-	harmony.hpa = 0;
-	harmony_free_buffer(&played_buf);
-	harmony_free_buffer(&recorded_buf);
-	harmony_free_buffer(&graveyard);
-	harmony_free_buffer(&silent);
-	return ret;
-}
-
-
-static struct parisc_device_id harmony_tbl[] = {
- /* { HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007A }, Bushmaster/Flounder */
- { HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007B }, /* 712/715 Audio */
- { HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007E }, /* Pace Audio */
- { HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007F }, /* Outfield / Coral II */
- { 0, }
-};
-
-MODULE_DEVICE_TABLE(parisc, harmony_tbl);
-
-static struct parisc_driver harmony_driver = {
-	.name		= "Lasi Harmony",
-	.id_table	= harmony_tbl,
-	.probe		= harmony_driver_probe,
-};
-
-static int __init init_harmony(void)
-{
-	return register_parisc_driver(&harmony_driver);
-}
-
-static void __exit cleanup_harmony(void)
-{
-	free_irq(harmony.dev->irq, &harmony);
-	unregister_sound_mixer(harmony.mixer_unit);
-	unregister_sound_dsp(harmony.dsp_unit);
-	harmony_free_buffer(&played_buf);
-	harmony_free_buffer(&recorded_buf);
-	harmony_free_buffer(&graveyard);
-	harmony_free_buffer(&silent);
-	unregister_parisc_driver(&harmony_driver);
-}
-
-
-MODULE_AUTHOR("Alex DeVries <alex@onefishtwo.ca>");
-MODULE_DESCRIPTION("Harmony sound driver");
-MODULE_LICENSE("GPL");
-
-module_init(init_harmony);
-module_exit(cleanup_harmony);
-
--- linux-2.6.18.noarch/sound/oss/pas2_card.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/pas2_card.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/pas2_card.c
+ * sound/oss/pas2_card.c
  *
  * Detection routine for the Pro Audio Spectrum cards.
  */
@@ -88,7 +88,7 @@
 
 /******************* Begin of the Interrupt Handler ********************/
 
-static irqreturn_t pasintr(int irq, void *dev_id, struct pt_regs *dummy)
+static irqreturn_t pasintr(int irq, void *dev_id)
 {
 	int             status;
 
--- linux-2.6.18.noarch/sound/oss/pss.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/pss.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/pss.c
+ * sound/oss/pss.c
  *
  * The low level driver for the Personal Sound System (ECHO ESC614).
  *
--- linux-2.6.18.noarch/sound/oss/dmabuf.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmabuf.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/dmabuf.c
+ * sound/oss/dmabuf.c
  *
  * The DMA buffer manager for digitized voice applications
  */
@@ -25,6 +25,7 @@
 #define BE_CONSERVATIVE
 #define SAMPLE_ROUNDUP 0
 
+#include <linux/mm.h>
 #include "sound_config.h"
 
 #define DMAP_FREE_ON_CLOSE      0
@@ -926,6 +927,7 @@
 	sound_start_dma(dmap, physaddr, count, dma_mode);
 	return count;
 }
+EXPORT_SYMBOL(DMAbuf_start_dma);
 
 static int local_start_dma(struct audio_operations *adev, unsigned long physaddr, int count, int dma_mode)
 {
@@ -1055,6 +1057,8 @@
 		do_outputintr(dev, notify_only);
 	spin_unlock_irqrestore(&dmap->lock,flags);
 }
+EXPORT_SYMBOL(DMAbuf_outputintr);
+
 /* called with dmap->lock held in irq context */
 static void do_inputintr(int dev)
 {
@@ -1154,36 +1158,7 @@
 		do_inputintr(dev);
 	spin_unlock_irqrestore(&dmap->lock,flags);
 }
-
-int DMAbuf_open_dma(int dev)
-{
-	/*
-	 *    NOTE!  This routine opens only the primary DMA channel (output).
-	 */
-	struct audio_operations *adev = audio_devs[dev];
-	int err;
-
-	if ((err = open_dmap(adev, OPEN_READWRITE, adev->dmap_out)) < 0)
-		return -EBUSY;
-	dma_init_buffers(adev->dmap_out);
-	adev->dmap_out->flags |= DMA_ALLOC_DONE;
-	adev->dmap_out->fragment_size = adev->dmap_out->buffsize;
-
-	if (adev->dmap_out->dma >= 0) {
-		unsigned long flags;
-
-		flags=claim_dma_lock();
-		clear_dma_ff(adev->dmap_out->dma);
-		disable_dma(adev->dmap_out->dma);
-		release_dma_lock(flags);
-	}
-	return 0;
-}
-
-void DMAbuf_close_dma(int dev)
-{
-	close_dmap(audio_devs[dev], audio_devs[dev]->dmap_out);
-}
+EXPORT_SYMBOL(DMAbuf_inputintr);
 
 void DMAbuf_init(int dev, int dma1, int dma2)
 {
@@ -1192,12 +1167,6 @@
 	 * NOTE! This routine could be called several times.
 	 */
 
-	/* drag in audio_syms.o */
-	{
-		extern char audio_syms_symbol;
-		audio_syms_symbol = 0;
-	}
-
 	if (adev && adev->dmap_out == NULL) {
 		if (adev->d == NULL)
 			panic("OSS: audio_devs[%d]->d == NULL\n", dev);
--- linux-2.6.18.noarch/sound/oss/dmasound/tas3004.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/tas3004.c	2007-06-05 17:44:27.000000000 -0400
@@ -48,6 +48,7 @@
 	int output_id;
 	int speaker_id;
 	struct tas_drce_t drce_state;
+	struct work_struct change;
 };
 
 #define MAKE_TIME(sec,usec) (((sec)<<12) + (50000+(usec/10)*(1<<12))/100000)
@@ -914,15 +915,13 @@
 }
 
 static void
-tas3004_device_change_handler(void *self)
+tas3004_device_change_handler(struct work_struct *work)
 {
-	if (!self) return;
-
-	tas3004_update_device_parameters((struct tas3004_data_t *)self);
+	struct tas3004_data_t *self;
+	self = container_of(work, struct tas3004_data_t, change);
+	tas3004_update_device_parameters(self);
 }
 
-static struct work_struct device_change;
-
 static int
 tas3004_output_device_change(	struct tas3004_data_t *self,
 				int device_id,
@@ -933,7 +932,7 @@
 	self->output_id=output_id;
 	self->speaker_id=speaker_id;
 
-	schedule_work(&device_change);
+	schedule_work(&self->change);
 
 	return 0;
 }
@@ -1093,10 +1092,9 @@
 	char mcr2 = 0;
 	int i, j;
 
-	self = kmalloc(sz, GFP_KERNEL);
+	self = kzalloc(sz, GFP_KERNEL);
 	if (!self)
 		return -ENOMEM;
-	memset(self, 0, sz);
 
 	self->super.client = client;
 	self->super.shadow = (tas_shadow_t *)(self+1);
@@ -1112,7 +1110,7 @@
 	tas3004_write_register(self, TAS3004_REG_MCR2, &mcr2, WRITE_SHADOW);
 	tas3004_write_register(self, TAS3004_REG_DRC, drce_init, WRITE_SHADOW);
 
-	INIT_WORK(&device_change, tas3004_device_change_handler, self);
+	INIT_WORK(&self->change, tas3004_device_change_handler);
 	return 0;
 }
 
--- linux-2.6.18.noarch/sound/oss/dmasound/dac3550a.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/dac3550a.c	2007-06-05 17:44:27.000000000 -0400
@@ -163,10 +163,9 @@
 	struct i2c_client *new_client;
 	int rc = -ENODEV;
 
-	new_client = kmalloc(sizeof(*new_client), GFP_KERNEL);
+	new_client = kzalloc(sizeof(*new_client), GFP_KERNEL);
 	if (!new_client)
 		return -ENOMEM;
-	memset(new_client, 0, sizeof(*new_client));
 
 	new_client->addr = address;
 	new_client->adapter = adapter;
--- linux-2.6.18.noarch/sound/oss/dmasound/dmasound_awacs.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/dmasound_awacs.c	2007-06-05 17:44:27.000000000 -0400
@@ -281,9 +281,9 @@
 static int PMacSetVolume(int volume);
 static void PMacPlay(void);
 static void PMacRecord(void);
-static irqreturn_t pmac_awacs_tx_intr(int irq, void *devid, struct pt_regs *regs);
-static irqreturn_t pmac_awacs_rx_intr(int irq, void *devid, struct pt_regs *regs);
-static irqreturn_t pmac_awacs_intr(int irq, void *devid, struct pt_regs *regs);
+static irqreturn_t pmac_awacs_tx_intr(int irq, void *devid);
+static irqreturn_t pmac_awacs_rx_intr(int irq, void *devid);
+static irqreturn_t pmac_awacs_intr(int irq, void *devid);
 static void awacs_write(int val);
 static int awacs_get_volume(int reg, int lshift);
 static int awacs_volume_setter(int volume, int n, int mute, int lshift);
@@ -347,8 +347,8 @@
 setup_audio_gpio(const char *name, const char* compatible, int *gpio_addr, int* gpio_pol)
 {
 	struct device_node *np;
-	u32* pp;
-	
+	const u32* pp;
+
 	np = find_devices("gpio");
 	if (!np)
 		return -ENODEV;
@@ -356,7 +356,8 @@
 	np = np->child;
 	while(np != 0) {
 		if (name) {
-			char *property = get_property(np,"audio-gpio",NULL);
+			const char *property =
+				get_property(np,"audio-gpio",NULL);
 			if (property != 0 && strcmp(property,name) == 0)
 				break;
 		} else if (compatible && device_is_compatible(np, compatible))
@@ -365,11 +366,11 @@
 	}
 	if (!np)
 		return -ENODEV;
-	pp = (u32 *)get_property(np, "AAPL,address", NULL);
+	pp = get_property(np, "AAPL,address", NULL);
 	if (!pp)
 		return -ENODEV;
 	*gpio_addr = (*pp) & 0x0000ffff;
-	pp = (u32 *)get_property(np, "audio-gpio-active-state", NULL);
+	pp = get_property(np, "audio-gpio-active-state", NULL);
 	if (pp)
 		*gpio_pol = *pp;
 	else
@@ -397,7 +398,7 @@
  * Headphone interrupt via GPIO (Tumbler, Snapper, DACA)
  */
 static irqreturn_t
-headphone_intr(int irq, void *devid, struct pt_regs *regs)
+headphone_intr(int irq, void *devid)
 {
 	unsigned long flags;
 
@@ -464,7 +465,7 @@
 			val = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, gpio_headphone_detect, 0);
 			pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, gpio_headphone_detect, val | 0x80);
 			/* Trigger it */
-  			headphone_intr(0,NULL,NULL);
+  			headphone_intr(0, NULL);
   		}
   	}
   	if (!gpio_headphone_irq) {
@@ -1036,7 +1037,7 @@
 */
 
 static irqreturn_t
-pmac_awacs_tx_intr(int irq, void *devid, struct pt_regs *regs)
+pmac_awacs_tx_intr(int irq, void *devid)
 {
 	int i = write_sq.front;
 	int stat;
@@ -1128,7 +1129,7 @@
 
 
 static irqreturn_t
-pmac_awacs_rx_intr(int irq, void *devid, struct pt_regs *regs)
+pmac_awacs_rx_intr(int irq, void *devid)
 {
 	int stat ;
 	/* For some reason on my PowerBook G3, I get one interrupt
@@ -1211,7 +1212,7 @@
 
 
 static irqreturn_t
-pmac_awacs_intr(int irq, void *devid, struct pt_regs *regs)
+pmac_awacs_intr(int irq, void *devid)
 {
 	int ctrl;
 	int status;
@@ -1498,7 +1499,7 @@
 				write_audio_gpio(gpio_audio_reset, !gpio_audio_reset_pol);
 				msleep(150);
 				tas_leave_sleep(); /* Stub for now */
-				headphone_intr(0,NULL,NULL);
+				headphone_intr(0, NULL);
 				break;
 			case AWACS_DACA:
 				msleep(10); /* Check this !!! */
--- linux-2.6.18.noarch/sound/oss/dmasound/tas3001c.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/tas3001c.c	2007-06-05 17:44:27.000000000 -0400
@@ -50,6 +50,7 @@
 	int output_id;
 	int speaker_id;
 	struct tas_drce_t drce_state;
+	struct work_struct change;
 };
 
 
@@ -667,14 +668,13 @@
 }
 
 static void
-tas3001c_device_change_handler(void *self)
+tas3001c_device_change_handler(struct work_struct *work)
 {
-	if (self)
-		tas3001c_update_device_parameters(self);
+	struct tas3001c_data_t *self;
+	self = container_of(work, struct tas3001c_data_t, change);
+	tas3001c_update_device_parameters(self);
 }
 
-static struct work_struct device_change;
-
 static int
 tas3001c_output_device_change(	struct tas3001c_data_t *self,
 				int device_id,
@@ -685,7 +685,7 @@
 	self->output_id=output_id;
 	self->speaker_id=speaker_id;
 
-	schedule_work(&device_change);
+	schedule_work(&self->change);
 	return 0;
 }
 
@@ -807,10 +807,9 @@
 	size_t sz = sizeof(*self) + (TAS3001C_REG_MAX*sizeof(tas_shadow_t));
 	int i, j;
 
-	self = kmalloc(sz, GFP_KERNEL);
+	self = kzalloc(sz, GFP_KERNEL);
 	if (!self)
 		return -ENOMEM;
-	memset(self, 0, sz);
 
 	self->super.client = client;
 	self->super.shadow = (tas_shadow_t *)(self+1);
@@ -823,7 +822,7 @@
 			tas3001c_write_biquad_shadow(self, i, j,
 				&tas3001c_eq_unity);
 
-	INIT_WORK(&device_change, tas3001c_device_change_handler, self);
+	INIT_WORK(&self->change, tas3001c_device_change_handler);
 	return 0;
 }
 
--- linux-2.6.18.noarch/sound/oss/dmasound/dmasound_paula.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/dmasound_paula.c	2007-06-05 17:44:27.000000000 -0400
@@ -82,7 +82,7 @@
 static int AmiSetTreble(int treble);
 static void AmiPlayNextFrame(int index);
 static void AmiPlay(void);
-static irqreturn_t AmiInterrupt(int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t AmiInterrupt(int irq, void *dummy);
 
 #ifdef CONFIG_HEARTBEAT
 
@@ -556,7 +556,7 @@
 }
 
 
-static irqreturn_t AmiInterrupt(int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t AmiInterrupt(int irq, void *dummy)
 {
 	int minframes = 1;
 
--- linux-2.6.18.noarch/sound/oss/dmasound/dmasound_q40.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/dmasound_q40.c	2007-06-05 17:44:27.000000000 -0400
@@ -48,8 +48,8 @@
 static int Q40SetVolume(int volume);
 static void Q40PlayNextFrame(int index);
 static void Q40Play(void);
-static irqreturn_t Q40StereoInterrupt(int irq, void *dummy, struct pt_regs *fp);
-static irqreturn_t Q40MonoInterrupt(int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t Q40StereoInterrupt(int irq, void *dummy);
+static irqreturn_t Q40MonoInterrupt(int irq, void *dummy);
 static void Q40Interrupt(void);
 
 
@@ -451,7 +451,7 @@
 	spin_unlock_irqrestore(&dmasound.lock, flags);
 }
 
-static irqreturn_t Q40StereoInterrupt(int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t Q40StereoInterrupt(int irq, void *dummy)
 {
 	spin_lock(&dmasound.lock);
         if (q40_sc>1){
@@ -463,7 +463,7 @@
 	spin_unlock(&dmasound.lock);
 	return IRQ_HANDLED;
 }
-static irqreturn_t Q40MonoInterrupt(int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t Q40MonoInterrupt(int irq, void *dummy)
 {
 	spin_lock(&dmasound.lock);
         if (q40_sc>0){
--- linux-2.6.18.noarch/sound/oss/dmasound/dmasound_core.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/dmasound_core.c	2007-06-05 17:44:27.000000000 -0400
@@ -371,7 +371,7 @@
 	return -EINVAL;
 }
 
-static struct file_operations mixer_fops =
+static const struct file_operations mixer_fops =
 {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
@@ -1051,7 +1051,7 @@
 
 	if (file->f_mode & FMODE_WRITE) {
 		if (write_sq.busy)
-			rc = sq_fsync(file, file->f_dentry);
+			rc = sq_fsync(file, file->f_path.dentry);
 
 		sq_reset_output() ; /* make sure dma is stopped and all is quiet */
 		write_sq_release_buffers();
@@ -1217,7 +1217,7 @@
 		if ((file->f_mode & FMODE_READ) && dmasound.mach.record)
 			sq_reset_input() ;
 		if (file->f_mode & FMODE_WRITE) {
-			result = sq_fsync(file, file->f_dentry);
+			result = sq_fsync(file, file->f_path.dentry);
 			sq_reset_output() ;
 		}
 		/* if we are the shared resource owner then release them */
@@ -1337,7 +1337,7 @@
 	return -EINVAL;
 }
 
-static struct file_operations sq_fops =
+static const struct file_operations sq_fops =
 {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
@@ -1346,22 +1346,34 @@
 	.ioctl		= sq_ioctl,
 	.open		= sq_open,
 	.release	= sq_release,
+};
+
 #ifdef HAS_RECORD
-	.read		= NULL	/* default to no read for compat mode */
-#endif
+static const struct file_operations sq_fops_record =
+{
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= sq_write,
+	.poll		= sq_poll,
+	.ioctl		= sq_ioctl,
+	.open		= sq_open,
+	.release	= sq_release,
+	.read		= sq_read,
 };
+#endif
 
 static int sq_init(void)
 {
+	const struct file_operations *fops = &sq_fops;
 #ifndef MODULE
 	int sq_unit;
 #endif
 
 #ifdef HAS_RECORD
 	if (dmasound.mach.record)
-		sq_fops.read = sq_read ;
+		fops = &sq_fops_record;
 #endif
-	sq_unit = register_sound_dsp(&sq_fops, -1);
+	sq_unit = register_sound_dsp(fops, -1);
 	if (sq_unit < 0) {
 		printk(KERN_ERR "dmasound_core: couldn't register fops\n") ;
 		return sq_unit ;
@@ -1561,7 +1573,7 @@
 	return n;
 }
 
-static struct file_operations state_fops = {
+static const struct file_operations state_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= state_read,
--- linux-2.6.18.noarch/sound/oss/dmasound/dmasound_atari.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/dmasound_atari.c	2007-06-05 17:44:27.000000000 -0400
@@ -133,7 +133,7 @@
 static int FalconSetVolume(int volume);
 static void AtaPlayNextFrame(int index);
 static void AtaPlay(void);
-static irqreturn_t AtaInterrupt(int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t AtaInterrupt(int irq, void *dummy);
 
 /*** Mid level stuff *********************************************************/
 
@@ -1257,7 +1257,7 @@
 }
 
 
-static irqreturn_t AtaInterrupt(int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t AtaInterrupt(int irq, void *dummy)
 {
 #if 0
 	/* ++TeSche: if you should want to test this... */
--- linux-2.6.18.noarch/sound/oss/dmasound/Kconfig.orig	2007-06-05 16:07:55.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/Kconfig	2007-06-05 17:44:27.000000000 -0400
@@ -14,7 +14,7 @@
 
 config DMASOUND_PMAC
 	tristate "PowerMac DMA sound support"
-	depends on PPC32 && PPC_PMAC && SOUND && I2C
+	depends on PPC32 && PPC_PMAC && SOUND && I2C && OBSOLETE_OSS
  	select DMASOUND
 	help
 	  If you want to use the internal audio of your PowerMac in Linux,
--- linux-2.6.18.noarch/sound/oss/dmasound/tas_common.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dmasound/tas_common.c	2007-06-05 17:44:27.000000000 -0400
@@ -135,10 +135,9 @@
 		return -ENODEV;
 	}
 	
-	new_client = kmalloc(sizeof(*new_client), GFP_KERNEL);
+	new_client = kzalloc(sizeof(*new_client), GFP_KERNEL);
 	if (!new_client)
 		return -ENOMEM;
-	memset(new_client, 0, sizeof(*new_client));
 
 	new_client->addr = address;
 	new_client->adapter = adapter;
--- linux-2.6.18.noarch/sound/oss/audio_syms.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/audio_syms.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,16 +0,0 @@
-/*
- * Exported symbols for audio driver.
- */
-
-#include <linux/module.h>
-
-char audio_syms_symbol;
-
-#include "sound_config.h"
-#include "sound_calls.h"
-
-EXPORT_SYMBOL(DMAbuf_start_dma);
-EXPORT_SYMBOL(DMAbuf_open_dma);
-EXPORT_SYMBOL(DMAbuf_close_dma);
-EXPORT_SYMBOL(DMAbuf_inputintr);
-EXPORT_SYMBOL(DMAbuf_outputintr);
--- linux-2.6.18.noarch/sound/oss/gus_midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus_midi.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,256 +0,0 @@
-/*
- * sound/gus2_midi.c
- *
- * The low level driver for the GUS Midi Interface.
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- * Changes:
- * 11-10-2000	Bartlomiej Zolnierkiewicz <bkz@linux-ide.org>
- *		Added __init to gus_midi_init()
- */
-
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include "sound_config.h"
-
-#include "gus.h"
-#include "gus_hw.h"
-
-static int      midi_busy, input_opened;
-static int      my_dev;
-static int      output_used;
-static volatile unsigned char gus_midi_control;
-static void     (*midi_input_intr) (int dev, unsigned char data);
-
-static unsigned char tmp_queue[256];
-extern int      gus_pnp_flag;
-static volatile int qlen;
-static volatile unsigned char qhead, qtail;
-extern int      gus_base, gus_irq, gus_dma;
-extern int     *gus_osp;
-extern spinlock_t gus_lock;
-
-static int GUS_MIDI_STATUS(void)
-{
-	return inb(u_MidiStatus);
-}
-
-static int gus_midi_open(int dev, int mode, void (*input) (int dev, unsigned char data), void (*output) (int dev))
-{
-	if (midi_busy)
-	{
-/*		printk("GUS: Midi busy\n");*/
-		return -EBUSY;
-	}
-	outb((MIDI_RESET), u_MidiControl);
-	gus_delay();
-
-	gus_midi_control = 0;
-	input_opened = 0;
-
-	if (mode == OPEN_READ || mode == OPEN_READWRITE)
-		if (!gus_pnp_flag)
-		{
-			gus_midi_control |= MIDI_ENABLE_RCV;
-			input_opened = 1;
-		}
-	outb((gus_midi_control), u_MidiControl);	/* Enable */
-
-	midi_busy = 1;
-	qlen = qhead = qtail = output_used = 0;
-	midi_input_intr = input;
-
-	return 0;
-}
-
-static int dump_to_midi(unsigned char midi_byte)
-{
-	unsigned long   flags;
-	int             ok = 0;
-
-	output_used = 1;
-
-	spin_lock_irqsave(&gus_lock, flags);
-
-	if (GUS_MIDI_STATUS() & MIDI_XMIT_EMPTY)
-	{
-		ok = 1;
-		outb((midi_byte), u_MidiData);
-	}
-	else
-	{
-		/*
-		 * Enable Midi xmit interrupts (again)
-		 */
-		gus_midi_control |= MIDI_ENABLE_XMIT;
-		outb((gus_midi_control), u_MidiControl);
-	}
-
-	spin_unlock_irqrestore(&gus_lock,flags);
-	return ok;
-}
-
-static void gus_midi_close(int dev)
-{
-	/*
-	 * Reset FIFO pointers, disable intrs
-	 */
-
-	outb((MIDI_RESET), u_MidiControl);
-	midi_busy = 0;
-}
-
-static int gus_midi_out(int dev, unsigned char midi_byte)
-{
-	unsigned long   flags;
-
-	/*
-	 * Drain the local queue first
-	 */
-	spin_lock_irqsave(&gus_lock, flags);
-
-	while (qlen && dump_to_midi(tmp_queue[qhead]))
-	{
-		qlen--;
-		qhead++;
-	}
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-	/*
-	 *	Output the byte if the local queue is empty.
-	 */
-
-	if (!qlen)
-		if (dump_to_midi(midi_byte))
-			return 1;	/*
-					 * OK
-					 */
-
-	/*
-	 *	Put to the local queue
-	 */
-
-	if (qlen >= 256)
-		return 0;	/*
-				 * Local queue full
-				 */
-	spin_lock_irqsave(&gus_lock, flags);
-
-	tmp_queue[qtail] = midi_byte;
-	qlen++;
-	qtail++;
-
-	spin_unlock_irqrestore(&gus_lock,flags);
-	return 1;
-}
-
-static int gus_midi_start_read(int dev)
-{
-	return 0;
-}
-
-static int gus_midi_end_read(int dev)
-{
-	return 0;
-}
-
-static void gus_midi_kick(int dev)
-{
-}
-
-static int gus_midi_buffer_status(int dev)
-{
-	unsigned long   flags;
-
-	if (!output_used)
-		return 0;
-
-	spin_lock_irqsave(&gus_lock, flags);
-
-	if (qlen && dump_to_midi(tmp_queue[qhead]))
-	{
-		qlen--;
-		qhead++;
-	}
-	spin_unlock_irqrestore(&gus_lock,flags);
-	return (qlen > 0) || !(GUS_MIDI_STATUS() & MIDI_XMIT_EMPTY);
-}
-
-#define MIDI_SYNTH_NAME	"Gravis Ultrasound Midi"
-#define MIDI_SYNTH_CAPS	SYNTH_CAP_INPUT
-#include "midi_synth.h"
-
-static struct midi_operations gus_midi_operations =
-{
-	.owner		= THIS_MODULE,
-	.info		= {"Gravis UltraSound Midi", 0, 0, SNDCARD_GUS},
-	.converter	= &std_midi_synth,
-	.in_info	= {0},
-	.open		= gus_midi_open,
-	.close		= gus_midi_close,
-	.outputc	= gus_midi_out,
-	.start_read	= gus_midi_start_read,
-	.end_read	= gus_midi_end_read,
-	.kick		= gus_midi_kick,
-	.buffer_status	= gus_midi_buffer_status,
-};
-
-void __init gus_midi_init(struct address_info *hw_config)
-{
-	int dev = sound_alloc_mididev();
-
-	if (dev == -1)
-	{
-		printk(KERN_INFO "gus_midi: Too many midi devices detected\n");
-		return;
-	}
-	outb((MIDI_RESET), u_MidiControl);
-
-	std_midi_synth.midi_dev = my_dev = dev;
-	hw_config->slots[2] = dev;
-	midi_devs[dev] = &gus_midi_operations;
-	sequencer_init();
-	return;
-}
-
-void gus_midi_interrupt(int dummy)
-{
-	volatile unsigned char stat, data;
-	int timeout = 10;
-
-	spin_lock(&gus_lock);
-
-	while (timeout-- > 0 && (stat = GUS_MIDI_STATUS()) & (MIDI_RCV_FULL | MIDI_XMIT_EMPTY))
-	{
-		if (stat & MIDI_RCV_FULL)
-		{
-			data = inb(u_MidiData);
-			if (input_opened)
-				midi_input_intr(my_dev, data);
-		}
-		if (stat & MIDI_XMIT_EMPTY)
-		{
-			while (qlen && dump_to_midi(tmp_queue[qhead]))
-			{
-				qlen--;
-				qhead++;
-			}
-			if (!qlen)
-			{
-			      /*
-			       * Disable Midi output interrupts, since no data in the buffer
-			       */
-			      gus_midi_control &= ~MIDI_ENABLE_XMIT;
-			      outb((gus_midi_control), u_MidiControl);
-			      outb((gus_midi_control), u_MidiControl);
-			}
-		}
-	}
-	spin_unlock(&gus_lock);
-}
--- linux-2.6.18.noarch/sound/oss/btaudio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/btaudio.c	2007-06-05 17:44:14.000000000 -0400
@@ -429,7 +429,7 @@
 	return 0;
 }
 
-static struct file_operations btaudio_mixer_fops = {
+static const struct file_operations btaudio_mixer_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.open		= btaudio_mixer_open,
@@ -796,7 +796,7 @@
 	return mask;
 }
 
-static struct file_operations btaudio_digital_dsp_fops = {
+static const struct file_operations btaudio_digital_dsp_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.open		= btaudio_dsp_open_digital,
@@ -807,7 +807,7 @@
 	.poll		= btaudio_dsp_poll,
 };
 
-static struct file_operations btaudio_analog_dsp_fops = {
+static const struct file_operations btaudio_analog_dsp_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.open		= btaudio_dsp_open_analog,
@@ -824,7 +824,7 @@
 			    "RISCI", "FBUS", "FTRGT", "FDSR", "PPERR",
 			    "RIPERR", "PABORT", "OCERR", "SCERR" };
 
-static irqreturn_t btaudio_irq(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t btaudio_irq(int irq, void *dev_id)
 {
 	int count = 0;
 	u32 stat,astat;
@@ -915,12 +915,11 @@
 		return -EBUSY;
 	}
 
-	bta = kmalloc(sizeof(*bta),GFP_ATOMIC);
+	bta = kzalloc(sizeof(*bta),GFP_ATOMIC);
 	if (!bta) {
 		rc = -ENOMEM;
 		goto fail0;
 	}
-	memset(bta,0,sizeof(*bta));
 
 	bta->pci  = pci_dev;
 	bta->irq  = pci_dev->irq;
@@ -1020,6 +1019,7 @@
  fail2:
         free_irq(bta->irq,bta);	
  fail1:
+	iounmap(bta->mmio);
 	kfree(bta);
  fail0:
 	release_mem_region(pci_resource_start(pci_dev,0),
@@ -1051,6 +1051,7 @@
         free_irq(bta->irq,bta);
 	release_mem_region(pci_resource_start(pci_dev,0),
 			   pci_resource_len(pci_dev,0));
+	iounmap(bta->mmio);
 
 	/* remove from linked list */
 	if (bta == btaudios) {
--- linux-2.6.18.noarch/sound/oss/awe_wave.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/awe_wave.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,6149 +0,0 @@
-/*
- * sound/awe_wave.c
- *
- * The low level driver for the AWE32/SB32/AWE64 wave table synth.
- *   version 0.4.4; Jan. 4, 2000
- *
- * Copyright (C) 1996-2000 Takashi Iwai
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- * Changelog:
- * Aug 18, 2003, Adam Belay <ambx1@neo.rr.com>
- * - detection code rewrite
- */
-
-#include <linux/awe_voice.h>
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/pnp.h>
-
-#include "sound_config.h"
-
-#include "awe_wave.h"
-#include "awe_hw.h"
-
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-#include "tuning.h"
-#include <linux/ultrasound.h>
-#endif
-
-/*
- * debug message
- */
-
-#ifdef AWE_DEBUG_ON
-#define DEBUG(LVL,XXX)	{if (ctrls[AWE_MD_DEBUG_MODE] > LVL) { XXX; }}
-#define ERRMSG(XXX)	{if (ctrls[AWE_MD_DEBUG_MODE]) { XXX; }}
-#define FATALERR(XXX)	XXX
-#else
-#define DEBUG(LVL,XXX) /**/
-#define ERRMSG(XXX)	XXX
-#define FATALERR(XXX)	XXX
-#endif
-
-/*
- * bank and voice record
- */
-
-typedef struct _sf_list sf_list;
-typedef struct _awe_voice_list awe_voice_list;
-typedef struct _awe_sample_list awe_sample_list;
-
-/* soundfont record */
-struct _sf_list {
-	unsigned short sf_id;	/* id number */
-	unsigned short type;	/* lock & shared flags */
-	int num_info;		/* current info table index */
-	int num_sample;		/* current sample table index */
-	int mem_ptr;		/* current word byte pointer */
-	awe_voice_list *infos, *last_infos;	/* instruments */
-	awe_sample_list *samples, *last_samples;	/* samples */
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	sf_list *shared;	/* shared list */
-	unsigned char name[AWE_PATCH_NAME_LEN];	/* sharing id */
-#endif
-	sf_list *next, *prev;
-};
-
-/* instrument list */
-struct _awe_voice_list {
-	awe_voice_info v;	/* instrument information */
-	sf_list *holder;	/* parent sf_list of this record */
-	unsigned char bank, instr;	/* preset number information */
-	char type, disabled;	/* type=normal/mapped, disabled=boolean */
-	awe_voice_list *next;	/* linked list with same sf_id */
-	awe_voice_list *next_instr;	/* instrument list */
-	awe_voice_list *next_bank;	/* hash table list */
-};
-
-/* voice list type */
-#define V_ST_NORMAL	0
-#define V_ST_MAPPED	1
-
-/* sample list */
-struct _awe_sample_list {
-	awe_sample_info v;	/* sample information */
-	sf_list *holder;	/* parent sf_list of this record */
-	awe_sample_list *next;	/* linked list with same sf_id */
-};
-
-/* sample and information table */
-static int current_sf_id;	/* current number of fonts */
-static int locked_sf_id;	/* locked position */
-static sf_list *sfhead, *sftail;	/* linked-lists */
-
-#define awe_free_mem_ptr() (sftail ? sftail->mem_ptr : 0)
-#define awe_free_info() (sftail ? sftail->num_info : 0)
-#define awe_free_sample() (sftail ? sftail->num_sample : 0)
-
-#define AWE_MAX_PRESETS		256
-#define AWE_DEFAULT_PRESET	0
-#define AWE_DEFAULT_BANK	0
-#define AWE_DEFAULT_DRUM	0
-#define AWE_DRUM_BANK		128
-
-#define MAX_LAYERS	AWE_MAX_VOICES
-
-/* preset table index */
-static awe_voice_list *preset_table[AWE_MAX_PRESETS];
-
-/*
- * voice table
- */
-
-/* effects table */
-typedef	struct FX_Rec { /* channel effects */
-	unsigned char flags[AWE_FX_END];
-	short val[AWE_FX_END];
-} FX_Rec;
-
-
-/* channel parameters */
-typedef struct _awe_chan_info {
-	int channel;		/* channel number */
-	int bank;		/* current tone bank */
-	int instr;		/* current program */
-	int bender;		/* midi pitchbend (-8192 - 8192) */
-	int bender_range;	/* midi bender range (x100) */
-	int panning;		/* panning (0-127) */
-	int main_vol;		/* channel volume (0-127) */
-	int expression_vol;	/* midi expression (0-127) */
-	int chan_press;		/* channel pressure */
-	int sustained;		/* sustain status in MIDI */
-	FX_Rec fx;		/* effects */
-	FX_Rec fx_layer[MAX_LAYERS]; /* layer effects */
-} awe_chan_info;
-
-/* voice parameters */
-typedef struct _voice_info {
-	int state;
-#define AWE_ST_OFF		(1<<0)	/* no sound */
-#define AWE_ST_ON		(1<<1)	/* playing */
-#define AWE_ST_STANDBY		(1<<2)	/* stand by for playing */
-#define AWE_ST_SUSTAINED	(1<<3)	/* sustained */
-#define AWE_ST_MARK		(1<<4)	/* marked for allocation */
-#define AWE_ST_DRAM		(1<<5)	/* DRAM read/write */
-#define AWE_ST_FM		(1<<6)	/* reserved for FM */
-#define AWE_ST_RELEASED		(1<<7)	/* released */
-
-	int ch;			/* midi channel */
-	int key;		/* internal key for search */
-	int layer;		/* layer number (for channel mode only) */
-	int time;		/* allocated time */
-	awe_chan_info	*cinfo;	/* channel info */
-
-	int note;		/* midi key (0-127) */
-	int velocity;		/* midi velocity (0-127) */
-	int sostenuto;		/* sostenuto on/off */
-	awe_voice_info *sample;	/* assigned voice */
-
-	/* EMU8000 parameters */
-	int apitch;		/* pitch parameter */
-	int avol;		/* volume parameter */
-	int apan;		/* panning parameter */
-	int acutoff;		/* cutoff parameter */
-	short aaux;		/* aux word */
-} voice_info;
-
-/* voice information */
-static voice_info voices[AWE_MAX_VOICES];
-
-#define IS_NO_SOUND(v)	(voices[v].state & (AWE_ST_OFF|AWE_ST_RELEASED|AWE_ST_STANDBY|AWE_ST_SUSTAINED))
-#define IS_NO_EFFECT(v)	(voices[v].state != AWE_ST_ON)
-#define IS_PLAYING(v)	(voices[v].state & (AWE_ST_ON|AWE_ST_SUSTAINED|AWE_ST_RELEASED))
-#define IS_EMPTY(v)	(voices[v].state & (AWE_ST_OFF|AWE_ST_MARK|AWE_ST_DRAM|AWE_ST_FM))
-
-
-/* MIDI channel effects information (for hw control) */
-static awe_chan_info channels[AWE_MAX_CHANNELS];
-
-
-/*
- * global variables
- */
-
-#ifndef AWE_DEFAULT_BASE_ADDR
-#define AWE_DEFAULT_BASE_ADDR	0	/* autodetect */
-#endif
-
-#ifndef AWE_DEFAULT_MEM_SIZE
-#define AWE_DEFAULT_MEM_SIZE	-1	/* autodetect */
-#endif
-
-static int io = AWE_DEFAULT_BASE_ADDR; /* Emu8000 base address */
-static int memsize = AWE_DEFAULT_MEM_SIZE; /* memory size in Kbytes */
-#ifdef CONFIG_PNP
-static int isapnp = -1;
-#else
-static int isapnp;
-#endif
-
-MODULE_AUTHOR("Takashi Iwai <iwai@ww.uni-erlangen.de>");
-MODULE_DESCRIPTION("SB AWE32/64 WaveTable driver");
-MODULE_LICENSE("GPL");
-
-module_param(io, int, 0);
-MODULE_PARM_DESC(io, "base i/o port of Emu8000");
-module_param(memsize, int, 0);
-MODULE_PARM_DESC(memsize, "onboard DRAM size in Kbytes");
-module_param(isapnp, bool, 0);
-MODULE_PARM_DESC(isapnp, "use ISAPnP detection");
-
-/* DRAM start offset */
-static int awe_mem_start = AWE_DRAM_OFFSET;
-
-/* maximum channels for playing */
-static int awe_max_voices = AWE_MAX_VOICES;
-
-static int patch_opened;		/* sample already loaded? */
-
-static char atten_relative = FALSE;
-static short atten_offset;
-
-static int awe_present = FALSE;		/* awe device present? */
-static int awe_busy = FALSE;		/* awe device opened? */
-
-static int my_dev = -1;
-
-#define DEFAULT_DRUM_FLAGS	((1 << 9) | (1 << 25))
-#define IS_DRUM_CHANNEL(c)	(drum_flags & (1 << (c)))
-#define DRUM_CHANNEL_ON(c)	(drum_flags |= (1 << (c)))
-#define DRUM_CHANNEL_OFF(c)	(drum_flags &= ~(1 << (c)))
-static unsigned int drum_flags = DEFAULT_DRUM_FLAGS; /* channel flags */
-
-static int playing_mode = AWE_PLAY_INDIRECT;
-#define SINGLE_LAYER_MODE()	(playing_mode == AWE_PLAY_INDIRECT || playing_mode == AWE_PLAY_DIRECT)
-#define MULTI_LAYER_MODE()	(playing_mode == AWE_PLAY_MULTI || playing_mode == AWE_PLAY_MULTI2)
-
-static int current_alloc_time;  	/* voice allocation index for channel mode */
-
-static struct synth_info awe_info = {
-	"AWE32 Synth",		/* name */
-	0,			/* device */
-	SYNTH_TYPE_SAMPLE,	/* synth_type */
-	SAMPLE_TYPE_AWE32,	/* synth_subtype */
-	0,			/* perc_mode (obsolete) */
-	AWE_MAX_VOICES,		/* nr_voices */
-	0,			/* nr_drums (obsolete) */
-	400			/* instr_bank_size */
-};
-
-
-static struct voice_alloc_info *voice_alloc;	/* set at initialization */
-
-
-/*
- * function prototypes
- */
-
-static int awe_request_region(void);
-static void awe_release_region(void);
-
-static void awe_reset_samples(void);
-/* emu8000 chip i/o access */
-static void setup_ports(int p1, int p2, int p3);
-static void awe_poke(unsigned short cmd, unsigned short port, unsigned short data);
-static void awe_poke_dw(unsigned short cmd, unsigned short port, unsigned int data);
-static unsigned short awe_peek(unsigned short cmd, unsigned short port);
-static unsigned int awe_peek_dw(unsigned short cmd, unsigned short port);
-static void awe_wait(unsigned short delay);
-
-/* initialize emu8000 chip */
-static void awe_initialize(void);
-
-/* set voice parameters */
-static void awe_init_ctrl_parms(int init_all);
-static void awe_init_voice_info(awe_voice_info *vp);
-static void awe_init_voice_parm(awe_voice_parm *pp);
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-static int freq_to_note(int freq);
-static int calc_rate_offset(int Hz);
-/*static int calc_parm_delay(int msec);*/
-static int calc_parm_hold(int msec);
-static int calc_parm_attack(int msec);
-static int calc_parm_decay(int msec);
-static int calc_parm_search(int msec, short *table);
-#endif /* gus compat */
-
-/* turn on/off note */
-static void awe_note_on(int voice);
-static void awe_note_off(int voice);
-static void awe_terminate(int voice);
-static void awe_exclusive_off(int voice);
-static void awe_note_off_all(int do_sustain);
-
-/* calculate voice parameters */
-typedef void (*fx_affect_func)(int voice, int forced);
-static void awe_set_pitch(int voice, int forced);
-static void awe_set_voice_pitch(int voice, int forced);
-static void awe_set_volume(int voice, int forced);
-static void awe_set_voice_vol(int voice, int forced);
-static void awe_set_pan(int voice, int forced);
-static void awe_fx_fmmod(int voice, int forced);
-static void awe_fx_tremfrq(int voice, int forced);
-static void awe_fx_fm2frq2(int voice, int forced);
-static void awe_fx_filterQ(int voice, int forced);
-static void awe_calc_pitch(int voice);
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-static void awe_calc_pitch_from_freq(int voice, int freq);
-#endif
-static void awe_calc_volume(int voice);
-static void awe_update_volume(void);
-static void awe_change_master_volume(short val);
-static void awe_voice_init(int voice, int init_all);
-static void awe_channel_init(int ch, int init_all);
-static void awe_fx_init(int ch);
-static void awe_send_effect(int voice, int layer, int type, int val);
-static void awe_modwheel_change(int voice, int value);
-
-/* sequencer interface */
-static int awe_open(int dev, int mode);
-static void awe_close(int dev);
-static int awe_ioctl(int dev, unsigned int cmd, void __user * arg);
-static int awe_kill_note(int dev, int voice, int note, int velocity);
-static int awe_start_note(int dev, int v, int note_num, int volume);
-static int awe_set_instr(int dev, int voice, int instr_no);
-static int awe_set_instr_2(int dev, int voice, int instr_no);
-static void awe_reset(int dev);
-static void awe_hw_control(int dev, unsigned char *event);
-static int awe_load_patch(int dev, int format, const char __user *addr,
-			  int offs, int count, int pmgr_flag);
-static void awe_aftertouch(int dev, int voice, int pressure);
-static void awe_controller(int dev, int voice, int ctrl_num, int value);
-static void awe_panning(int dev, int voice, int value);
-static void awe_volume_method(int dev, int mode);
-static void awe_bender(int dev, int voice, int value);
-static int awe_alloc(int dev, int chn, int note, struct voice_alloc_info *alloc);
-static void awe_setup_voice(int dev, int voice, int chn);
-
-#define awe_key_pressure(dev,voice,key,press) awe_start_note(dev,voice,(key)+128,press)
-
-/* hardware controls */
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-static void awe_hw_gus_control(int dev, int cmd, unsigned char *event);
-#endif
-static void awe_hw_awe_control(int dev, int cmd, unsigned char *event);
-static void awe_voice_change(int voice, fx_affect_func func);
-static void awe_sostenuto_on(int voice, int forced);
-static void awe_sustain_off(int voice, int forced);
-static void awe_terminate_and_init(int voice, int forced);
-
-/* voice search */
-static int awe_search_key(int bank, int preset, int note);
-static awe_voice_list *awe_search_instr(int bank, int preset, int note);
-static int awe_search_multi_voices(awe_voice_list *rec, int note, int velocity, awe_voice_info **vlist);
-static void awe_alloc_multi_voices(int ch, int note, int velocity, int key);
-static void awe_alloc_one_voice(int voice, int note, int velocity);
-static int awe_clear_voice(void);
-
-/* load / remove patches */
-static int awe_open_patch(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_close_patch(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_unload_patch(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_load_info(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_remove_info(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_load_data(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_replace_data(awe_patch_info *patch, const char __user *addr, int count);
-static int awe_load_map(awe_patch_info *patch, const char __user *addr, int count);
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-static int awe_load_guspatch(const char __user *addr, int offs, int size, int pmgr_flag);
-#endif
-/*static int awe_probe_info(awe_patch_info *patch, const char __user *addr, int count);*/
-static int awe_probe_data(awe_patch_info *patch, const char __user *addr, int count);
-static sf_list *check_patch_opened(int type, char *name);
-static int awe_write_wave_data(const char __user *addr, int offset, awe_sample_list *sp, int channels);
-static int awe_create_sf(int type, char *name);
-static void awe_free_sf(sf_list *sf);
-static void add_sf_info(sf_list *sf, awe_voice_list *rec);
-static void add_sf_sample(sf_list *sf, awe_sample_list *smp);
-static void purge_old_list(awe_voice_list *rec, awe_voice_list *next);
-static void add_info_list(awe_voice_list *rec);
-static void awe_remove_samples(int sf_id);
-static void rebuild_preset_list(void);
-static short awe_set_sample(awe_voice_list *rec);
-static awe_sample_list *search_sample_index(sf_list *sf, int sample);
-
-static int is_identical_holder(sf_list *sf1, sf_list *sf2);
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-static int is_identical_name(unsigned char *name, sf_list *p);
-static int is_shared_sf(unsigned char *name);
-static int info_duplicated(sf_list *sf, awe_voice_list *rec);
-#endif /* allow sharing */
-
-/* lowlevel functions */
-static void awe_init_audio(void);
-static void awe_init_dma(void);
-static void awe_init_array(void);
-static void awe_send_array(unsigned short *data);
-static void awe_tweak_voice(int voice);
-static void awe_tweak(void);
-static void awe_init_fm(void);
-static int awe_open_dram_for_write(int offset, int channels);
-static void awe_open_dram_for_check(void);
-static void awe_close_dram(void);
-/*static void awe_write_dram(unsigned short c);*/
-static int awe_detect_base(int addr);
-static int awe_detect(void);
-static void awe_check_dram(void);
-static int awe_load_chorus_fx(awe_patch_info *patch, const char __user *addr, int count);
-static void awe_set_chorus_mode(int mode);
-static void awe_update_chorus_mode(void);
-static int awe_load_reverb_fx(awe_patch_info *patch, const char __user *addr, int count);
-static void awe_set_reverb_mode(int mode);
-static void awe_update_reverb_mode(void);
-static void awe_equalizer(int bass, int treble);
-static void awe_update_equalizer(void);
-
-#ifdef CONFIG_AWE32_MIXER
-static void attach_mixer(void);
-static void unload_mixer(void);
-#endif
-
-#ifdef CONFIG_AWE32_MIDIEMU
-static void attach_midiemu(void);
-static void unload_midiemu(void);
-#endif
-
-#define limitvalue(x, a, b) if ((x) < (a)) (x) = (a); else if ((x) > (b)) (x) = (b)
-
-/*
- * control parameters
- */
-
-
-#ifdef AWE_USE_NEW_VOLUME_CALC
-#define DEF_VOLUME_CALC	TRUE
-#else
-#define DEF_VOLUME_CALC	FALSE
-#endif /* new volume */
-
-#define DEF_ZERO_ATTEN		32	/* 12dB below */
-#define DEF_MOD_SENSE		18
-#define DEF_CHORUS_MODE		2
-#define DEF_REVERB_MODE		4
-#define DEF_BASS_LEVEL		5
-#define DEF_TREBLE_LEVEL	9
-
-static struct CtrlParmsDef {
-	int value;
-	int init_each_time;
-	void (*update)(void);
-} ctrl_parms[AWE_MD_END] = {
-	{0,0, NULL}, {0,0, NULL}, /* <-- not used */
-	{AWE_VERSION_NUMBER, FALSE, NULL},
-	{TRUE, FALSE, NULL}, /* exclusive */
-	{TRUE, FALSE, NULL}, /* realpan */
-	{AWE_DEFAULT_BANK, FALSE, NULL}, /* gusbank */
-	{FALSE, TRUE, NULL}, /* keep effect */
-	{DEF_ZERO_ATTEN, FALSE, awe_update_volume}, /* zero_atten */
-	{FALSE, FALSE, NULL}, /* chn_prior */
-	{DEF_MOD_SENSE, FALSE, NULL}, /* modwheel sense */
-	{AWE_DEFAULT_PRESET, FALSE, NULL}, /* def_preset */
-	{AWE_DEFAULT_BANK, FALSE, NULL}, /* def_bank */
-	{AWE_DEFAULT_DRUM, FALSE, NULL}, /* def_drum */
-	{FALSE, FALSE, NULL}, /* toggle_drum_bank */
-	{DEF_VOLUME_CALC, FALSE, awe_update_volume}, /* new_volume_calc */
-	{DEF_CHORUS_MODE, FALSE, awe_update_chorus_mode}, /* chorus mode */
-	{DEF_REVERB_MODE, FALSE, awe_update_reverb_mode}, /* reverb mode */
-	{DEF_BASS_LEVEL, FALSE, awe_update_equalizer}, /* bass level */
-	{DEF_TREBLE_LEVEL, FALSE, awe_update_equalizer}, /* treble level */
-	{0, FALSE, NULL},	/* debug mode */
-	{FALSE, FALSE, NULL}, /* pan exchange */
-};
-
-static int ctrls[AWE_MD_END];
-
-
-/*
- * synth operation table
- */
-
-static struct synth_operations awe_operations =
-{
-	.owner		= THIS_MODULE,
-	.id		= "EMU8K",
-	.info		= &awe_info,
-	.midi_dev	= 0,
-	.synth_type	= SYNTH_TYPE_SAMPLE,
-	.synth_subtype	= SAMPLE_TYPE_AWE32,
-	.open		= awe_open,
-	.close		= awe_close,
-	.ioctl		= awe_ioctl,
-	.kill_note	= awe_kill_note,
-	.start_note	= awe_start_note,
-	.set_instr	= awe_set_instr_2,
-	.reset		= awe_reset,
-	.hw_control	= awe_hw_control,
-	.load_patch	= awe_load_patch,
-	.aftertouch	= awe_aftertouch,
-	.controller	= awe_controller,
-	.panning	= awe_panning,
-	.volume_method	= awe_volume_method,
-	.bender		= awe_bender,
-	.alloc_voice	= awe_alloc,
-	.setup_voice	= awe_setup_voice
-};
-
-static void free_tables(void)
-{
-	if (sftail) {
-		sf_list *p, *prev;
-		for (p = sftail; p; p = prev) {
-			prev = p->prev;
-			awe_free_sf(p);
-		}
-	}
-	sfhead = sftail = NULL;
-}
-
-/*
- * clear sample tables 
- */
-
-static void
-awe_reset_samples(void)
-{
-	/* free all bank tables */
-	memset(preset_table, 0, sizeof(preset_table));
-	free_tables();
-
-	current_sf_id = 0;
-	locked_sf_id = 0;
-	patch_opened = 0;
-}
-
-
-/*
- * EMU register access
- */
-
-/* select a given AWE32 pointer */
-static int awe_ports[5];
-static int port_setuped = FALSE;
-static int awe_cur_cmd = -1;
-#define awe_set_cmd(cmd) \
-if (awe_cur_cmd != cmd) { outw(cmd, awe_ports[Pointer]); awe_cur_cmd = cmd; }
-
-/* write 16bit data */
-static void
-awe_poke(unsigned short cmd, unsigned short port, unsigned short data)
-{
-	awe_set_cmd(cmd);
-	outw(data, awe_ports[port]);
-}
-
-/* write 32bit data */
-static void
-awe_poke_dw(unsigned short cmd, unsigned short port, unsigned int data)
-{
-	unsigned short addr = awe_ports[port];
-	awe_set_cmd(cmd);
-	outw(data, addr);		/* write lower 16 bits */
-	outw(data >> 16, addr + 2);	/* write higher 16 bits */
-}
-
-/* read 16bit data */
-static unsigned short
-awe_peek(unsigned short cmd, unsigned short port)
-{
-	unsigned short k;
-	awe_set_cmd(cmd);
-	k = inw(awe_ports[port]);
-	return k;
-}
-
-/* read 32bit data */
-static unsigned int
-awe_peek_dw(unsigned short cmd, unsigned short port)
-{
-	unsigned int k1, k2;
-	unsigned short addr = awe_ports[port];
-	awe_set_cmd(cmd);
-	k1 = inw(addr);
-	k2 = inw(addr + 2);
-	k1 |= k2 << 16;
-	return k1;
-}
-
-/* wait delay number of AWE32 44100Hz clocks */
-#ifdef WAIT_BY_LOOP /* wait by loop -- that's not good.. */
-static void
-awe_wait(unsigned short delay)
-{
-	unsigned short clock, target;
-	unsigned short port = awe_ports[AWE_WC_Port];
-	int counter;
-  
-	/* sample counter */
-	awe_set_cmd(AWE_WC_Cmd);
-	clock = (unsigned short)inw(port);
-	target = clock + delay;
-	counter = 0;
-	if (target < clock) {
-		for (; (unsigned short)inw(port) > target; counter++)
-			if (counter > 65536)
-				break;
-	}
-	for (; (unsigned short)inw(port) < target; counter++)
-		if (counter > 65536)
-			break;
-}
-#else
-
-static void awe_wait(unsigned short delay)
-{
-	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout((HZ*(unsigned long)delay + 44099)/44100);
-}
-/*
-static void awe_wait(unsigned short delay)
-{
-	udelay(((unsigned long)delay * 1000000L + 44099) / 44100);
-}
-*/
-#endif /* wait by loop */
-
-/* write a word data */
-#define awe_write_dram(c)	awe_poke(AWE_SMLD, c)
-
-/*
- * AWE32 voice parameters
- */
-
-/* initialize voice_info record */
-static void
-awe_init_voice_info(awe_voice_info *vp)
-{
-	vp->sample = 0;
-	vp->rate_offset = 0;
-
-	vp->start = 0;
-	vp->end = 0;
-	vp->loopstart = 0;
-	vp->loopend = 0;
-	vp->mode = 0;
-	vp->root = 60;
-	vp->tune = 0;
-	vp->low = 0;
-	vp->high = 127;
-	vp->vellow = 0;
-	vp->velhigh = 127;
-
-	vp->fixkey = -1;
-	vp->fixvel = -1;
-	vp->fixpan = -1;
-	vp->pan = -1;
-
-	vp->exclusiveClass = 0;
-	vp->amplitude = 127;
-	vp->attenuation = 0;
-	vp->scaleTuning = 100;
-
-	awe_init_voice_parm(&vp->parm);
-}
-
-/* initialize voice_parm record:
- * Env1/2: delay=0, attack=0, hold=0, sustain=0, decay=0, release=0.
- * Vibrato and Tremolo effects are zero.
- * Cutoff is maximum.
- * Chorus and Reverb effects are zero.
- */
-static void
-awe_init_voice_parm(awe_voice_parm *pp)
-{
-	pp->moddelay = 0x8000;
-	pp->modatkhld = 0x7f7f;
-	pp->moddcysus = 0x7f7f;
-	pp->modrelease = 0x807f;
-	pp->modkeyhold = 0;
-	pp->modkeydecay = 0;
-
-	pp->voldelay = 0x8000;
-	pp->volatkhld = 0x7f7f;
-	pp->voldcysus = 0x7f7f;
-	pp->volrelease = 0x807f;
-	pp->volkeyhold = 0;
-	pp->volkeydecay = 0;
-
-	pp->lfo1delay = 0x8000;
-	pp->lfo2delay = 0x8000;
-	pp->pefe = 0;
-
-	pp->fmmod = 0;
-	pp->tremfrq = 0;
-	pp->fm2frq2 = 0;
-
-	pp->cutoff = 0xff;
-	pp->filterQ = 0;
-
-	pp->chorus = 0;
-	pp->reverb = 0;
-}	
-
-
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-
-/* convert frequency mHz to abstract cents (= midi key * 100) */
-static int
-freq_to_note(int mHz)
-{
-	/* abscents = log(mHz/8176) / log(2) * 1200 */
-	unsigned int max_val = (unsigned int)0xffffffff / 10000;
-	int i, times;
-	unsigned int base;
-	unsigned int freq;
-	int note, tune;
-
-	if (mHz == 0)
-		return 0;
-	if (mHz < 0)
-		return 12799; /* maximum */
-
-	freq = mHz;
-	note = 0;
-	for (base = 8176 * 2; freq >= base; base *= 2) {
-		note += 12;
-		if (note >= 128) /* over maximum */
-			return 12799;
-	}
-	base /= 2;
-
-	/* to avoid overflow... */
-	times = 10000;
-	while (freq > max_val) {
-		max_val *= 10;
-		times /= 10;
-		base /= 10;
-	}
-
-	freq = freq * times / base;
-	for (i = 0; i < 12; i++) {
-		if (freq < semitone_tuning[i+1])
-			break;
-		note++;
-	}
-
-	tune = 0;
-	freq = freq * 10000 / semitone_tuning[i];
-	for (i = 0; i < 100; i++) {
-		if (freq < cent_tuning[i+1])
-			break;
-		tune++;
-	}
-
-	return note * 100 + tune;
-}
-
-
-/* convert Hz to AWE32 rate offset:
- * sample pitch offset for the specified sample rate
- * rate=44100 is no offset, each 4096 is 1 octave (twice).
- * eg, when rate is 22050, this offset becomes -4096.
- */
-static int
-calc_rate_offset(int Hz)
-{
-	/* offset = log(Hz / 44100) / log(2) * 4096 */
-	int freq, base, i;
-
-	/* maybe smaller than max (44100Hz) */
-	if (Hz <= 0 || Hz >= 44100) return 0;
-
-	base = 0;
-	for (freq = Hz * 2; freq < 44100; freq *= 2)
-		base++;
-	base *= 1200;
-
-	freq = 44100 * 10000 / (freq/2);
-	for (i = 0; i < 12; i++) {
-		if (freq < semitone_tuning[i+1])
-			break;
-		base += 100;
-	}
-	freq = freq * 10000 / semitone_tuning[i];
-	for (i = 0; i < 100; i++) {
-		if (freq < cent_tuning[i+1])
-			break;
-		base++;
-	}
-	return -base * 4096 / 1200;
-}
-
-
-/*
- * convert envelope time parameter to AWE32 raw parameter
- */
-
-/* attack & decay/release time table (msec) */
-static short attack_time_tbl[128] = {
-32767, 32767, 5989, 4235, 2994, 2518, 2117, 1780, 1497, 1373, 1259, 1154, 1058, 970, 890, 816,
-707, 691, 662, 634, 607, 581, 557, 533, 510, 489, 468, 448, 429, 411, 393, 377,
-361, 345, 331, 317, 303, 290, 278, 266, 255, 244, 234, 224, 214, 205, 196, 188,
-180, 172, 165, 158, 151, 145, 139, 133, 127, 122, 117, 112, 107, 102, 98, 94,
-90, 86, 82, 79, 75, 72, 69, 66, 63, 61, 58, 56, 53, 51, 49, 47,
-45, 43, 41, 39, 37, 36, 34, 33, 31, 30, 29, 28, 26, 25, 24, 23,
-22, 21, 20, 19, 19, 18, 17, 16, 16, 15, 15, 14, 13, 13, 12, 12,
-11, 11, 10, 10, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 6, 0,
-};
-
-static short decay_time_tbl[128] = {
-32767, 32767, 22614, 15990, 11307, 9508, 7995, 6723, 5653, 5184, 4754, 4359, 3997, 3665, 3361, 3082,
-2828, 2765, 2648, 2535, 2428, 2325, 2226, 2132, 2042, 1955, 1872, 1793, 1717, 1644, 1574, 1507,
-1443, 1382, 1324, 1267, 1214, 1162, 1113, 1066, 978, 936, 897, 859, 822, 787, 754, 722,
-691, 662, 634, 607, 581, 557, 533, 510, 489, 468, 448, 429, 411, 393, 377, 361,
-345, 331, 317, 303, 290, 278, 266, 255, 244, 234, 224, 214, 205, 196, 188, 180,
-172, 165, 158, 151, 145, 139, 133, 127, 122, 117, 112, 107, 102, 98, 94, 90,
-86, 82, 79, 75, 72, 69, 66, 63, 61, 58, 56, 53, 51, 49, 47, 45,
-43, 41, 39, 37, 36, 34, 33, 31, 30, 29, 28, 26, 25, 24, 23, 22,
-};
-
-#define calc_parm_delay(msec) (0x8000 - (msec) * 1000 / 725);
-
-/* delay time = 0x8000 - msec/92 */
-static int
-calc_parm_hold(int msec)
-{
-	int val = (0x7f * 92 - msec) / 92;
-	if (val < 1) val = 1;
-	if (val > 127) val = 127;
-	return val;
-}
-
-/* attack time: search from time table */
-static int
-calc_parm_attack(int msec)
-{
-	return calc_parm_search(msec, attack_time_tbl);
-}
-
-/* decay/release time: search from time table */
-static int
-calc_parm_decay(int msec)
-{
-	return calc_parm_search(msec, decay_time_tbl);
-}
-
-/* search an index for specified time from given time table */
-static int
-calc_parm_search(int msec, short *table)
-{
-	int left = 1, right = 127, mid;
-	while (left < right) {
-		mid = (left + right) / 2;
-		if (msec < (int)table[mid])
-			left = mid + 1;
-		else
-			right = mid;
-	}
-	return left;
-}
-#endif /* AWE_HAS_GUS_COMPATIBILITY */
-
-
-/*
- * effects table
- */
-
-/* set an effect value */
-#define FX_FLAG_OFF	0
-#define FX_FLAG_SET	1
-#define FX_FLAG_ADD	2
-
-#define FX_SET(rec,type,value) \
-	((rec)->flags[type] = FX_FLAG_SET, (rec)->val[type] = (value))
-#define FX_ADD(rec,type,value) \
-	((rec)->flags[type] = FX_FLAG_ADD, (rec)->val[type] = (value))
-#define FX_UNSET(rec,type) \
-	((rec)->flags[type] = FX_FLAG_OFF, (rec)->val[type] = 0)
-
-/* check the effect value is set */
-#define FX_ON(rec,type)	((rec)->flags[type])
-
-#define PARM_BYTE	0
-#define PARM_WORD	1
-#define PARM_SIGN	2
-
-static struct PARM_DEFS {
-	int type;	/* byte or word */
-	int low, high;	/* value range */
-	fx_affect_func realtime;	/* realtime paramater change */
-} parm_defs[] = {
-	{PARM_WORD, 0, 0x8000, NULL},	/* env1 delay */
-	{PARM_BYTE, 1, 0x7f, NULL},	/* env1 attack */
-	{PARM_BYTE, 0, 0x7e, NULL},	/* env1 hold */
-	{PARM_BYTE, 1, 0x7f, NULL},	/* env1 decay */
-	{PARM_BYTE, 1, 0x7f, NULL},	/* env1 release */
-	{PARM_BYTE, 0, 0x7f, NULL},	/* env1 sustain */
-	{PARM_BYTE, 0, 0xff, NULL},	/* env1 pitch */
-	{PARM_BYTE, 0, 0xff, NULL},	/* env1 cutoff */
-
-	{PARM_WORD, 0, 0x8000, NULL},	/* env2 delay */
-	{PARM_BYTE, 1, 0x7f, NULL},	/* env2 attack */
-	{PARM_BYTE, 0, 0x7e, NULL},	/* env2 hold */
-	{PARM_BYTE, 1, 0x7f, NULL},	/* env2 decay */
-	{PARM_BYTE, 1, 0x7f, NULL},	/* env2 release */
-	{PARM_BYTE, 0, 0x7f, NULL},	/* env2 sustain */
-
-	{PARM_WORD, 0, 0x8000, NULL},	/* lfo1 delay */
-	{PARM_BYTE, 0, 0xff, awe_fx_tremfrq},	/* lfo1 freq */
-	{PARM_SIGN, -128, 127, awe_fx_tremfrq},	/* lfo1 volume */
-	{PARM_SIGN, -128, 127, awe_fx_fmmod},	/* lfo1 pitch */
-	{PARM_BYTE, 0, 0xff, awe_fx_fmmod},	/* lfo1 cutoff */
-
-	{PARM_WORD, 0, 0x8000, NULL},	/* lfo2 delay */
-	{PARM_BYTE, 0, 0xff, awe_fx_fm2frq2},	/* lfo2 freq */
-	{PARM_SIGN, -128, 127, awe_fx_fm2frq2},	/* lfo2 pitch */
-
-	{PARM_WORD, 0, 0xffff, awe_set_voice_pitch},	/* initial pitch */
-	{PARM_BYTE, 0, 0xff, NULL},	/* chorus */
-	{PARM_BYTE, 0, 0xff, NULL},	/* reverb */
-	{PARM_BYTE, 0, 0xff, awe_set_volume},	/* initial cutoff */
-	{PARM_BYTE, 0, 15, awe_fx_filterQ},	/* initial resonance */
-
-	{PARM_WORD, 0, 0xffff, NULL},	/* sample start */
-	{PARM_WORD, 0, 0xffff, NULL},	/* loop start */
-	{PARM_WORD, 0, 0xffff, NULL},	/* loop end */
-	{PARM_WORD, 0, 0xffff, NULL},	/* coarse sample start */
-	{PARM_WORD, 0, 0xffff, NULL},	/* coarse loop start */
-	{PARM_WORD, 0, 0xffff, NULL},	/* coarse loop end */
-	{PARM_BYTE, 0, 0xff, awe_set_volume},	/* initial attenuation */
-};
-
-
-static unsigned char
-FX_BYTE(FX_Rec *rec, FX_Rec *lay, int type, unsigned char value)
-{
-	int effect = 0;
-	int on = 0;
-	if (lay && (on = FX_ON(lay, type)) != 0)
-		effect = lay->val[type];
-	if (!on && (on = FX_ON(rec, type)) != 0)
-		effect = rec->val[type];
-	if (on == FX_FLAG_ADD) {
-		if (parm_defs[type].type == PARM_SIGN) {
-			if (value > 0x7f)
-				effect += (int)value - 0x100;
-			else
-				effect += (int)value;
-		} else {
-			effect += (int)value;
-		}
-	}
-	if (on) {
-		if (effect < parm_defs[type].low)
-			effect = parm_defs[type].low;
-		else if (effect > parm_defs[type].high)
-			effect = parm_defs[type].high;
-		return (unsigned char)effect;
-	}
-	return value;
-}
-
-/* get word effect value */
-static unsigned short
-FX_WORD(FX_Rec *rec, FX_Rec *lay, int type, unsigned short value)
-{
-	int effect = 0;
-	int on = 0;
-	if (lay && (on = FX_ON(lay, type)) != 0)
-		effect = lay->val[type];
-	if (!on && (on = FX_ON(rec, type)) != 0)
-		effect = rec->val[type];
-	if (on == FX_FLAG_ADD)
-		effect += (int)value;
-	if (on) {
-		if (effect < parm_defs[type].low)
-			effect = parm_defs[type].low;
-		else if (effect > parm_defs[type].high)
-			effect = parm_defs[type].high;
-		return (unsigned short)effect;
-	}
-	return value;
-}
-
-/* get word (upper=type1/lower=type2) effect value */
-static unsigned short
-FX_COMB(FX_Rec *rec, FX_Rec *lay, int type1, int type2, unsigned short value)
-{
-	unsigned short tmp;
-	tmp = FX_BYTE(rec, lay, type1, (unsigned char)(value >> 8));
-	tmp <<= 8;
-	tmp |= FX_BYTE(rec, lay, type2, (unsigned char)(value & 0xff));
-	return tmp;
-}
-
-/* address offset */
-static int
-FX_OFFSET(FX_Rec *rec, FX_Rec *lay, int lo, int hi, int mode)
-{
-	int addr = 0;
-	if (lay && FX_ON(lay, hi))
-		addr = (short)lay->val[hi];
-	else if (FX_ON(rec, hi))
-		addr = (short)rec->val[hi];
-	addr = addr << 15;
-	if (lay && FX_ON(lay, lo))
-		addr += (short)lay->val[lo];
-	else if (FX_ON(rec, lo))
-		addr += (short)rec->val[lo];
-	if (!(mode & AWE_SAMPLE_8BITS))
-		addr /= 2;
-	return addr;
-}
-
-
-/*
- * turn on/off sample
- */
-
-/* table for volume target calculation */
-static unsigned short voltarget[16] = { 
-   0xEAC0, 0XE0C8, 0XD740, 0XCE20, 0XC560, 0XBD08, 0XB500, 0XAD58,
-   0XA5F8, 0X9EF0, 0X9830, 0X91C0, 0X8B90, 0X85A8, 0X8000, 0X7A90
-};
-
-static void
-awe_note_on(int voice)
-{
-	unsigned int temp;
-	int addr;
-	int vtarget, ftarget, ptarget, pitch;
-	awe_voice_info *vp;
-	awe_voice_parm_block *parm;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	/* A voice sample must assigned before calling */
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-
-	parm = (awe_voice_parm_block*)&vp->parm;
-
-	/* channel to be silent and idle */
-	awe_poke(AWE_DCYSUSV(voice), 0x0080);
-	awe_poke(AWE_VTFT(voice), 0x0000FFFF);
-	awe_poke(AWE_CVCF(voice), 0x0000FFFF);
-	awe_poke(AWE_PTRX(voice), 0);
-	awe_poke(AWE_CPF(voice), 0);
-
-	/* set pitch offset */
-	awe_set_pitch(voice, TRUE);
-
-	/* modulation & volume envelope */
-	if (parm->modatk >= 0x80 && parm->moddelay >= 0x8000) {
-		awe_poke(AWE_ENVVAL(voice), 0xBFFF);
-		pitch = (parm->env1pit<<4) + voices[voice].apitch;
-		if (pitch > 0xffff) pitch = 0xffff;
-		/* calculate filter target */
-		ftarget = parm->cutoff + parm->env1fc;
-		limitvalue(ftarget, 0, 255);
-		ftarget <<= 8;
-	} else {
-		awe_poke(AWE_ENVVAL(voice),
-			 FX_WORD(fx, fx_lay, AWE_FX_ENV1_DELAY, parm->moddelay));
-		ftarget = parm->cutoff;
-		ftarget <<= 8;
-		pitch = voices[voice].apitch;
-	}
-
-	/* calcualte pitch target */
-	if (pitch != 0xffff) {
-		ptarget = 1 << (pitch >> 12);
-		if (pitch & 0x800) ptarget += (ptarget*0x102e)/0x2710;
-		if (pitch & 0x400) ptarget += (ptarget*0x764)/0x2710;
-		if (pitch & 0x200) ptarget += (ptarget*0x389)/0x2710;
-		ptarget += (ptarget>>1);
-		if (ptarget > 0xffff) ptarget = 0xffff;
-
-	} else ptarget = 0xffff;
-	if (parm->modatk >= 0x80)
-		awe_poke(AWE_ATKHLD(voice),
-			 FX_BYTE(fx, fx_lay, AWE_FX_ENV1_HOLD, parm->modhld) << 8 | 0x7f);
-	else
-		awe_poke(AWE_ATKHLD(voice),
-			 FX_COMB(fx, fx_lay, AWE_FX_ENV1_HOLD, AWE_FX_ENV1_ATTACK,
-				 vp->parm.modatkhld));
-	awe_poke(AWE_DCYSUS(voice),
-		 FX_COMB(fx, fx_lay, AWE_FX_ENV1_SUSTAIN, AWE_FX_ENV1_DECAY,
-			  vp->parm.moddcysus));
-
-	if (parm->volatk >= 0x80 && parm->voldelay >= 0x8000) {
-		awe_poke(AWE_ENVVOL(voice), 0xBFFF);
-		vtarget = voltarget[voices[voice].avol%0x10]>>(voices[voice].avol>>4);
-	} else {
-		awe_poke(AWE_ENVVOL(voice),
-			 FX_WORD(fx, fx_lay, AWE_FX_ENV2_DELAY, vp->parm.voldelay));
-		vtarget = 0;
-	}
-	if (parm->volatk >= 0x80)
-		awe_poke(AWE_ATKHLDV(voice),
-			 FX_BYTE(fx, fx_lay, AWE_FX_ENV2_HOLD, parm->volhld) << 8 | 0x7f);
-	else
-		awe_poke(AWE_ATKHLDV(voice),
-			 FX_COMB(fx, fx_lay, AWE_FX_ENV2_HOLD, AWE_FX_ENV2_ATTACK,
-			 vp->parm.volatkhld));
-	/* decay/sustain parameter for volume envelope must be set at last */
-
-	/* cutoff and volume */
-	awe_set_volume(voice, TRUE);
-
-	/* modulation envelope heights */
-	awe_poke(AWE_PEFE(voice),
-		 FX_COMB(fx, fx_lay, AWE_FX_ENV1_PITCH, AWE_FX_ENV1_CUTOFF,
-			 vp->parm.pefe));
-
-	/* lfo1/2 delay */
-	awe_poke(AWE_LFO1VAL(voice),
-		 FX_WORD(fx, fx_lay, AWE_FX_LFO1_DELAY, vp->parm.lfo1delay));
-	awe_poke(AWE_LFO2VAL(voice),
-		 FX_WORD(fx, fx_lay, AWE_FX_LFO2_DELAY, vp->parm.lfo2delay));
-
-	/* lfo1 pitch & cutoff shift */
-	awe_fx_fmmod(voice, TRUE);
-	/* lfo1 volume & freq */
-	awe_fx_tremfrq(voice, TRUE);
-	/* lfo2 pitch & freq */
-	awe_fx_fm2frq2(voice, TRUE);
-	/* pan & loop start */
-	awe_set_pan(voice, TRUE);
-
-	/* chorus & loop end (chorus 8bit, MSB) */
-	addr = vp->loopend - 1;
-	addr += FX_OFFSET(fx, fx_lay, AWE_FX_LOOP_END,
-			  AWE_FX_COARSE_LOOP_END, vp->mode);
-	temp = FX_BYTE(fx, fx_lay, AWE_FX_CHORUS, vp->parm.chorus);
-	temp = (temp <<24) | (unsigned int)addr;
-	awe_poke_dw(AWE_CSL(voice), temp);
-	DEBUG(4,printk("AWE32: [-- loopend=%x/%x]\n", vp->loopend, addr));
-
-	/* Q & current address (Q 4bit value, MSB) */
-	addr = vp->start - 1;
-	addr += FX_OFFSET(fx, fx_lay, AWE_FX_SAMPLE_START,
-			  AWE_FX_COARSE_SAMPLE_START, vp->mode);
-	temp = FX_BYTE(fx, fx_lay, AWE_FX_FILTERQ, vp->parm.filterQ);
-	temp = (temp<<28) | (unsigned int)addr;
-	awe_poke_dw(AWE_CCCA(voice), temp);
-	DEBUG(4,printk("AWE32: [-- startaddr=%x/%x]\n", vp->start, addr));
-
-	/* clear unknown registers */
-	awe_poke_dw(AWE_00A0(voice), 0);
-	awe_poke_dw(AWE_0080(voice), 0);
-
-	/* reset volume */
-	awe_poke_dw(AWE_VTFT(voice), (vtarget<<16)|ftarget);
-	awe_poke_dw(AWE_CVCF(voice), (vtarget<<16)|ftarget);
-
-	/* set reverb */
-	temp = FX_BYTE(fx, fx_lay, AWE_FX_REVERB, vp->parm.reverb);
-	temp = (temp << 8) | (ptarget << 16) | voices[voice].aaux;
-	awe_poke_dw(AWE_PTRX(voice), temp);
-	awe_poke_dw(AWE_CPF(voice), ptarget << 16);
-	/* turn on envelope */
-	awe_poke(AWE_DCYSUSV(voice),
-		 FX_COMB(fx, fx_lay, AWE_FX_ENV2_SUSTAIN, AWE_FX_ENV2_DECAY,
-			  vp->parm.voldcysus));
-
-	voices[voice].state = AWE_ST_ON;
-
-	/* clear voice position for the next note on this channel */
-	if (SINGLE_LAYER_MODE()) {
-		FX_UNSET(fx, AWE_FX_SAMPLE_START);
-		FX_UNSET(fx, AWE_FX_COARSE_SAMPLE_START);
-	}
-}
-
-
-/* turn off the voice */
-static void
-awe_note_off(int voice)
-{
-	awe_voice_info *vp;
-	unsigned short tmp;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if ((vp = voices[voice].sample) == NULL) {
-		voices[voice].state = AWE_ST_OFF;
-		return;
-	}
-
-	tmp = 0x8000 | FX_BYTE(fx, fx_lay, AWE_FX_ENV1_RELEASE,
-			       (unsigned char)vp->parm.modrelease);
-	awe_poke(AWE_DCYSUS(voice), tmp);
-	tmp = 0x8000 | FX_BYTE(fx, fx_lay, AWE_FX_ENV2_RELEASE,
-			       (unsigned char)vp->parm.volrelease);
-	awe_poke(AWE_DCYSUSV(voice), tmp);
-	voices[voice].state = AWE_ST_RELEASED;
-}
-
-/* force to terminate the voice (no releasing echo) */
-static void
-awe_terminate(int voice)
-{
-	awe_poke(AWE_DCYSUSV(voice), 0x807F);
-	awe_tweak_voice(voice);
-	voices[voice].state = AWE_ST_OFF;
-}
-
-/* turn off other voices with the same exclusive class (for drums) */
-static void
-awe_exclusive_off(int voice)
-{
-	int i, exclass;
-
-	if (voices[voice].sample == NULL)
-		return;
-	if ((exclass = voices[voice].sample->exclusiveClass) == 0)
-		return;	/* not exclusive */
-
-	/* turn off voices with the same class */
-	for (i = 0; i < awe_max_voices; i++) {
-		if (i != voice && IS_PLAYING(i) &&
-		    voices[i].sample && voices[i].ch == voices[voice].ch &&
-		    voices[i].sample->exclusiveClass == exclass) {
-			DEBUG(4,printk("AWE32: [exoff(%d)]\n", i));
-			awe_terminate(i);
-			awe_voice_init(i, TRUE);
-		}
-	}
-}
-
-
-/*
- * change the parameters of an audible voice
- */
-
-/* change pitch */
-static void
-awe_set_pitch(int voice, int forced)
-{
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	awe_poke(AWE_IP(voice), voices[voice].apitch);
-	DEBUG(3,printk("AWE32: [-- pitch=%x]\n", voices[voice].apitch));
-}
-
-/* calculate & change pitch */
-static void
-awe_set_voice_pitch(int voice, int forced)
-{
-	awe_calc_pitch(voice);
-	awe_set_pitch(voice, forced);
-}
-
-/* change volume & cutoff */
-static void
-awe_set_volume(int voice, int forced)
-{
-	awe_voice_info *vp;
-	unsigned short tmp2;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if (!IS_PLAYING(voice) && !forced) return;
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-
-	tmp2 = FX_BYTE(fx, fx_lay, AWE_FX_CUTOFF,
-		       (unsigned char)voices[voice].acutoff);
-	tmp2 = (tmp2 << 8);
-	tmp2 |= FX_BYTE(fx, fx_lay, AWE_FX_ATTEN,
-			(unsigned char)voices[voice].avol);
-	awe_poke(AWE_IFATN(voice), tmp2);
-}
-
-/* calculate & change volume */
-static void
-awe_set_voice_vol(int voice, int forced)
-{
-	if (IS_EMPTY(voice))
-		return;
-	awe_calc_volume(voice);
-	awe_set_volume(voice, forced);
-}
-
-
-/* change pan; this could make a click noise.. */
-static void
-awe_set_pan(int voice, int forced)
-{
-	unsigned int temp;
-	int addr;
-	awe_voice_info *vp;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-
-	/* pan & loop start (pan 8bit, MSB, 0:right, 0xff:left) */
-	if (vp->fixpan > 0)	/* 0-127 */
-		temp = 255 - (int)vp->fixpan * 2;
-	else {
-		int pos = 0;
-		if (vp->pan >= 0) /* 0-127 */
-			pos = (int)vp->pan * 2 - 128;
-		pos += voices[voice].cinfo->panning; /* -128 - 127 */
-		temp = 127 - pos;
-	}
-	limitvalue(temp, 0, 255);
-	if (ctrls[AWE_MD_PAN_EXCHANGE]) {
-		temp = 255 - temp;
-	}
-	if (forced || temp != voices[voice].apan) {
-		voices[voice].apan = temp;
-		if (temp == 0)
-			voices[voice].aaux = 0xff;
-		else
-			voices[voice].aaux = (-temp) & 0xff;
-		addr = vp->loopstart - 1;
-		addr += FX_OFFSET(fx, fx_lay, AWE_FX_LOOP_START,
-				  AWE_FX_COARSE_LOOP_START, vp->mode);
-		temp = (temp<<24) | (unsigned int)addr;
-		awe_poke_dw(AWE_PSST(voice), temp);
-		DEBUG(4,printk("AWE32: [-- loopstart=%x/%x]\n", vp->loopstart, addr));
-	}
-}
-
-/* effects change during playing */
-static void
-awe_fx_fmmod(int voice, int forced)
-{
-	awe_voice_info *vp;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-	awe_poke(AWE_FMMOD(voice),
-		 FX_COMB(fx, fx_lay, AWE_FX_LFO1_PITCH, AWE_FX_LFO1_CUTOFF,
-			 vp->parm.fmmod));
-}
-
-/* set tremolo (lfo1) volume & frequency */
-static void
-awe_fx_tremfrq(int voice, int forced)
-{
-	awe_voice_info *vp;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-	awe_poke(AWE_TREMFRQ(voice),
-		 FX_COMB(fx, fx_lay, AWE_FX_LFO1_VOLUME, AWE_FX_LFO1_FREQ,
-			 vp->parm.tremfrq));
-}
-
-/* set lfo2 pitch & frequency */
-static void
-awe_fx_fm2frq2(int voice, int forced)
-{
-	awe_voice_info *vp;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-	awe_poke(AWE_FM2FRQ2(voice),
-		 FX_COMB(fx, fx_lay, AWE_FX_LFO2_PITCH, AWE_FX_LFO2_FREQ,
-			 vp->parm.fm2frq2));
-}
-
-
-/* Q & current address (Q 4bit value, MSB) */
-static void
-awe_fx_filterQ(int voice, int forced)
-{
-	unsigned int addr;
-	awe_voice_info *vp;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	if ((vp = voices[voice].sample) == NULL || vp->index == 0)
-		return;
-
-	addr = awe_peek_dw(AWE_CCCA(voice)) & 0xffffff;
-	addr |= (FX_BYTE(fx, fx_lay, AWE_FX_FILTERQ, vp->parm.filterQ) << 28);
-	awe_poke_dw(AWE_CCCA(voice), addr);
-}
-
-/*
- * calculate pitch offset
- *
- * 0xE000 is no pitch offset at 44100Hz sample.
- * Every 4096 is one octave.
- */
-
-static void
-awe_calc_pitch(int voice)
-{
-	voice_info *vp = &voices[voice];
-	awe_voice_info *ap;
-	awe_chan_info *cp = voices[voice].cinfo;
-	int offset;
-
-	/* search voice information */
-	if ((ap = vp->sample) == NULL)
-			return;
-	if (ap->index == 0) {
-		DEBUG(3,printk("AWE32: set sample (%d)\n", ap->sample));
-		if (awe_set_sample((awe_voice_list*)ap) == 0)
-			return;
-	}
-
-	/* calculate offset */
-	if (ap->fixkey >= 0) {
-		DEBUG(3,printk("AWE32: p-> fixkey(%d) tune(%d)\n", ap->fixkey, ap->tune));
-		offset = (ap->fixkey - ap->root) * 4096 / 12;
-	} else {
-		DEBUG(3,printk("AWE32: p(%d)-> root(%d) tune(%d)\n", vp->note, ap->root, ap->tune));
-		offset = (vp->note - ap->root) * 4096 / 12;
-		DEBUG(4,printk("AWE32: p-> ofs=%d\n", offset));
-	}
-	offset = (offset * ap->scaleTuning) / 100;
-	DEBUG(4,printk("AWE32: p-> scale* ofs=%d\n", offset));
-	offset += ap->tune * 4096 / 1200;
-	DEBUG(4,printk("AWE32: p-> tune+ ofs=%d\n", offset));
-	if (cp->bender != 0) {
-		DEBUG(3,printk("AWE32: p-> bend(%d) %d\n", voice, cp->bender));
-		/* (819200: 1 semitone) ==> (4096: 12 semitones) */
-		offset += cp->bender * cp->bender_range / 2400;
-	}
-
-	/* add initial pitch correction */
-	if (FX_ON(&cp->fx_layer[vp->layer], AWE_FX_INIT_PITCH))
-		offset += cp->fx_layer[vp->layer].val[AWE_FX_INIT_PITCH];
-	else if (FX_ON(&cp->fx, AWE_FX_INIT_PITCH))
-		offset += cp->fx.val[AWE_FX_INIT_PITCH];
-
-	/* 0xe000: root pitch */
-	vp->apitch = 0xe000 + ap->rate_offset + offset;
-	DEBUG(4,printk("AWE32: p-> sum aofs=%x, rate_ofs=%d\n", vp->apitch, ap->rate_offset));
-	if (vp->apitch > 0xffff)
-		vp->apitch = 0xffff;
-	if (vp->apitch < 0)
-		vp->apitch = 0;
-}
-
-
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-/* calculate MIDI key and semitone from the specified frequency */
-static void
-awe_calc_pitch_from_freq(int voice, int freq)
-{
-	voice_info *vp = &voices[voice];
-	awe_voice_info *ap;
-	FX_Rec *fx = &voices[voice].cinfo->fx;
-	FX_Rec *fx_lay = NULL;
-	int offset;
-	int note;
-
-	if (voices[voice].layer < MAX_LAYERS)
-		fx_lay = &voices[voice].cinfo->fx_layer[voices[voice].layer];
-
-	/* search voice information */
-	if ((ap = vp->sample) == NULL)
-		return;
-	if (ap->index == 0) {
-		DEBUG(3,printk("AWE32: set sample (%d)\n", ap->sample));
-		if (awe_set_sample((awe_voice_list*)ap) == 0)
-			return;
-	}
-	note = freq_to_note(freq);
-	offset = (note - ap->root * 100 + ap->tune) * 4096 / 1200;
-	offset = (offset * ap->scaleTuning) / 100;
-	if (fx_lay && FX_ON(fx_lay, AWE_FX_INIT_PITCH))
-		offset += fx_lay->val[AWE_FX_INIT_PITCH];
-	else if (FX_ON(fx, AWE_FX_INIT_PITCH))
-		offset += fx->val[AWE_FX_INIT_PITCH];
-	vp->apitch = 0xe000 + ap->rate_offset + offset;
-	if (vp->apitch > 0xffff)
-		vp->apitch = 0xffff;
-	if (vp->apitch < 0)
-		vp->apitch = 0;
-}
-#endif /* AWE_HAS_GUS_COMPATIBILITY */
-
-
-/*
- * calculate volume attenuation
- *
- * Voice volume is controlled by volume attenuation parameter.
- * So volume becomes maximum when avol is 0 (no attenuation), and
- * minimum when 255 (-96dB or silence).
- */
-
-static int vol_table[128] = {
-	255,111,95,86,79,74,70,66,63,61,58,56,54,52,50,49,
-	47,46,45,43,42,41,40,39,38,37,36,35,34,34,33,32,
-	31,31,30,29,29,28,27,27,26,26,25,24,24,23,23,22,
-	22,21,21,21,20,20,19,19,18,18,18,17,17,16,16,16,
-	15,15,15,14,14,14,13,13,13,12,12,12,11,11,11,10,
-	10,10,10,9,9,9,8,8,8,8,7,7,7,7,6,6,
-	6,6,5,5,5,5,5,4,4,4,4,3,3,3,3,3,
-	2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,
-};
-
-/* tables for volume->attenuation calculation */
-static unsigned char voltab1[128] = {
-   0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
-   0x63, 0x2b, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22,
-   0x21, 0x20, 0x1f, 0x1e, 0x1e, 0x1d, 0x1c, 0x1b, 0x1b, 0x1a,
-   0x19, 0x19, 0x18, 0x17, 0x17, 0x16, 0x16, 0x15, 0x15, 0x14,
-   0x14, 0x13, 0x13, 0x13, 0x12, 0x12, 0x11, 0x11, 0x11, 0x10,
-   0x10, 0x10, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0e, 0x0d,
-   0x0d, 0x0d, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0b, 0x0b, 0x0b,
-   0x0b, 0x0a, 0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09, 0x09,
-   0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06,
-   0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x04,
-   0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02,
-   0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
-   0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-static unsigned char voltab2[128] = {
-   0x32, 0x31, 0x30, 0x2f, 0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x2a,
-   0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x24, 0x23, 0x22, 0x21,
-   0x21, 0x20, 0x1f, 0x1e, 0x1e, 0x1d, 0x1c, 0x1c, 0x1b, 0x1a,
-   0x1a, 0x19, 0x19, 0x18, 0x18, 0x17, 0x16, 0x16, 0x15, 0x15,
-   0x14, 0x14, 0x13, 0x13, 0x13, 0x12, 0x12, 0x11, 0x11, 0x10,
-   0x10, 0x10, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0d, 0x0d,
-   0x0d, 0x0c, 0x0c, 0x0c, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x0a,
-   0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x08, 0x08,
-   0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06,
-   0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
-   0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03,
-   0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01,
-   0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-static unsigned char expressiontab[128] = {
-   0x7f, 0x6c, 0x62, 0x5a, 0x54, 0x50, 0x4b, 0x48, 0x45, 0x42,
-   0x40, 0x3d, 0x3b, 0x39, 0x38, 0x36, 0x34, 0x33, 0x31, 0x30,
-   0x2f, 0x2d, 0x2c, 0x2b, 0x2a, 0x29, 0x28, 0x27, 0x26, 0x25,
-   0x24, 0x24, 0x23, 0x22, 0x21, 0x21, 0x20, 0x1f, 0x1e, 0x1e,
-   0x1d, 0x1d, 0x1c, 0x1b, 0x1b, 0x1a, 0x1a, 0x19, 0x18, 0x18,
-   0x17, 0x17, 0x16, 0x16, 0x15, 0x15, 0x15, 0x14, 0x14, 0x13,
-   0x13, 0x12, 0x12, 0x11, 0x11, 0x11, 0x10, 0x10, 0x0f, 0x0f,
-   0x0f, 0x0e, 0x0e, 0x0e, 0x0d, 0x0d, 0x0d, 0x0c, 0x0c, 0x0c,
-   0x0b, 0x0b, 0x0b, 0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09,
-   0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06,
-   0x06, 0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03,
-   0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01,
-   0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-static void
-awe_calc_volume(int voice)
-{
-	voice_info *vp = &voices[voice];
-	awe_voice_info *ap;
-	awe_chan_info *cp = voices[voice].cinfo;
-	int vol;
-
-	/* search voice information */
-	if ((ap = vp->sample) == NULL)
-		return;
-
-	ap = vp->sample;
-	if (ap->index == 0) {
-		DEBUG(3,printk("AWE32: set sample (%d)\n", ap->sample));
-		if (awe_set_sample((awe_voice_list*)ap) == 0)
-			return;
-	}
-	
-	if (ctrls[AWE_MD_NEW_VOLUME_CALC]) {
-		int main_vol = cp->main_vol * ap->amplitude / 127;
-		limitvalue(vp->velocity, 0, 127);
-		limitvalue(main_vol, 0, 127);
-		limitvalue(cp->expression_vol, 0, 127);
-
-		vol = voltab1[main_vol] + voltab2[vp->velocity];
-		vol = (vol * 8) / 3;
-		vol += ap->attenuation;
-		if (cp->expression_vol < 127)
-			vol += ((0x100 - vol) * expressiontab[cp->expression_vol])/128;
-		vol += atten_offset;
-		if (atten_relative)
-			vol += ctrls[AWE_MD_ZERO_ATTEN];
-		limitvalue(vol, 0, 255);
-		vp->avol = vol;
-		
-	} else {
-		/* 0 - 127 */
-		vol = (vp->velocity * cp->main_vol * cp->expression_vol) / (127*127);
-		vol = vol * ap->amplitude / 127;
-
-		if (vol < 0) vol = 0;
-		if (vol > 127) vol = 127;
-
-		/* calc to attenuation */
-		vol = vol_table[vol];
-		vol += (int)ap->attenuation;
-		vol += atten_offset;
-		if (atten_relative)
-			vol += ctrls[AWE_MD_ZERO_ATTEN];
-		if (vol > 255) vol = 255;
-
-		vp->avol = vol;
-	}
-	if (cp->bank !=  AWE_DRUM_BANK && ((awe_voice_parm_block*)(&ap->parm))->volatk < 0x7d) {
-		int atten;
-		if (vp->velocity < 70) atten = 70;
-		else atten = vp->velocity;
-		vp->acutoff = (atten * ap->parm.cutoff + 0xa0) >> 7;
-	} else {
-		vp->acutoff = ap->parm.cutoff;
-	}
-	DEBUG(3,printk("AWE32: [-- voice(%d) vol=%x]\n", voice, vol));
-}
-
-/* change master volume */
-static void
-awe_change_master_volume(short val)
-{
-	limitvalue(val, 0, 127);
-	atten_offset = vol_table[val];
-	atten_relative = TRUE;
-	awe_update_volume();
-}
-
-/* update volumes of all available channels */
-static void awe_update_volume(void)
-{
-	int i;
-	for (i = 0; i < awe_max_voices; i++)
-		awe_set_voice_vol(i, TRUE);
-}
-
-/* set sostenuto on */
-static void awe_sostenuto_on(int voice, int forced)
-{
-	if (IS_NO_EFFECT(voice) && !forced) return;
-	voices[voice].sostenuto = 127;
-}
-
-
-/* drop sustain */
-static void awe_sustain_off(int voice, int forced)
-{
-	if (voices[voice].state == AWE_ST_SUSTAINED) {
-		awe_note_off(voice);
-		awe_fx_init(voices[voice].ch);
-		awe_voice_init(voice, FALSE);
-	}
-}
-
-
-/* terminate and initialize voice */
-static void awe_terminate_and_init(int voice, int forced)
-{
-	awe_terminate(voice);
-	awe_fx_init(voices[voice].ch);
-	awe_voice_init(voice, TRUE);
-}
-
-
-/*
- * synth operation routines
- */
-
-#define AWE_VOICE_KEY(v)	(0x8000 | (v))
-#define AWE_CHAN_KEY(c,n)	(((c) << 8) | ((n) + 1))
-#define KEY_CHAN_MATCH(key,c)	(((key) >> 8) == (c))
-
-/* initialize the voice */
-static void
-awe_voice_init(int voice, int init_all)
-{
-	voice_info *vp = &voices[voice];
-
-	/* reset voice search key */
-	if (playing_mode == AWE_PLAY_DIRECT)
-		vp->key = AWE_VOICE_KEY(voice);
-	else
-		vp->key = 0;
-
-	/* clear voice mapping */
-	voice_alloc->map[voice] = 0;
-
-	/* touch the timing flag */
-	vp->time = current_alloc_time;
-
-	/* initialize other parameters if necessary */
-	if (init_all) {
-		vp->note = -1;
-		vp->velocity = 0;
-		vp->sostenuto = 0;
-
-		vp->sample = NULL;
-		vp->cinfo = &channels[voice];
-		vp->ch = voice;
-		vp->state = AWE_ST_OFF;
-
-		/* emu8000 parameters */
-		vp->apitch = 0;
-		vp->avol = 255;
-		vp->apan = -1;
-	}
-}
-
-/* clear effects */
-static void awe_fx_init(int ch)
-{
-	if (SINGLE_LAYER_MODE() && !ctrls[AWE_MD_KEEP_EFFECT]) {
-		memset(&channels[ch].fx, 0, sizeof(channels[ch].fx));
-		memset(&channels[ch].fx_layer, 0, sizeof(&channels[ch].fx_layer));
-	}
-}
-
-/* initialize channel info */
-static void awe_channel_init(int ch, int init_all)
-{
-	awe_chan_info *cp = &channels[ch];
-	cp->channel = ch;
-	if (init_all) {
-		cp->panning = 0; /* zero center */
-		cp->bender_range = 200; /* sense * 100 */
-		cp->main_vol = 127;
-		if (MULTI_LAYER_MODE() && IS_DRUM_CHANNEL(ch)) {
-			cp->instr = ctrls[AWE_MD_DEF_DRUM];
-			cp->bank = AWE_DRUM_BANK;
-		} else {
-			cp->instr = ctrls[AWE_MD_DEF_PRESET];
-			cp->bank = ctrls[AWE_MD_DEF_BANK];
-		}
-	}
-
-	cp->bender = 0; /* zero tune skew */
-	cp->expression_vol = 127;
-	cp->chan_press = 0;
-	cp->sustained = 0;
-
-	if (! ctrls[AWE_MD_KEEP_EFFECT]) {
-		memset(&cp->fx, 0, sizeof(cp->fx));
-		memset(&cp->fx_layer, 0, sizeof(cp->fx_layer));
-	}
-}
-
-
-/* change the voice parameters; voice = channel */
-static void awe_voice_change(int voice, fx_affect_func func)
-{
-	int i; 
-	switch (playing_mode) {
-	case AWE_PLAY_DIRECT:
-		func(voice, FALSE);
-		break;
-	case AWE_PLAY_INDIRECT:
-		for (i = 0; i < awe_max_voices; i++)
-			if (voices[i].key == AWE_VOICE_KEY(voice))
-				func(i, FALSE);
-		break;
-	default:
-		for (i = 0; i < awe_max_voices; i++)
-			if (KEY_CHAN_MATCH(voices[i].key, voice))
-				func(i, FALSE);
-		break;
-	}
-}
-
-
-/*
- * device open / close
- */
-
-/* open device:
- *   reset status of all voices, and clear sample position flag
- */
-static int
-awe_open(int dev, int mode)
-{
-	if (awe_busy)
-		return -EBUSY;
-
-	awe_busy = TRUE;
-
-	/* set default mode */
-	awe_init_ctrl_parms(FALSE);
-	atten_relative = TRUE;
-	atten_offset = 0;
-	drum_flags = DEFAULT_DRUM_FLAGS;
-	playing_mode = AWE_PLAY_INDIRECT;
-
-	/* reset voices & channels */
-	awe_reset(dev);
-
-	patch_opened = 0;
-
-	return 0;
-}
-
-
-/* close device:
- *   reset all voices again (terminate sounds)
- */
-static void
-awe_close(int dev)
-{
-	awe_reset(dev);
-	awe_busy = FALSE;
-}
-
-
-/* set miscellaneous mode parameters
- */
-static void
-awe_init_ctrl_parms(int init_all)
-{
-	int i;
-	for (i = 0; i < AWE_MD_END; i++) {
-		if (init_all || ctrl_parms[i].init_each_time)
-			ctrls[i] = ctrl_parms[i].value;
-	}
-}
-
-
-/* sequencer I/O control:
- */
-static int
-awe_ioctl(int dev, unsigned int cmd, void __user *arg)
-{
-	switch (cmd) {
-	case SNDCTL_SYNTH_INFO:
-		if (playing_mode == AWE_PLAY_DIRECT)
-			awe_info.nr_voices = awe_max_voices;
-		else
-			awe_info.nr_voices = AWE_MAX_CHANNELS;
-		if (copy_to_user(arg, &awe_info, sizeof(awe_info)))
-			return -EFAULT;
-		return 0;
-		break;
-
-	case SNDCTL_SEQ_RESETSAMPLES:
-		awe_reset(dev);
-		awe_reset_samples();
-		return 0;
-		break;
-
-	case SNDCTL_SEQ_PERCMODE:
-		/* what's this? */
-		return 0;
-		break;
-
-	case SNDCTL_SYNTH_MEMAVL:
-		return memsize - awe_free_mem_ptr() * 2;
-		break;
-
-	default:
-		printk(KERN_WARNING "AWE32: unsupported ioctl %d\n", cmd);
-		return -EINVAL;
-		break;
-	}
-}
-
-
-static int voice_in_range(int voice)
-{
-	if (playing_mode == AWE_PLAY_DIRECT) {
-		if (voice < 0 || voice >= awe_max_voices)
-			return FALSE;
-	} else {
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return FALSE;
-	}
-	return TRUE;
-}
-
-static void release_voice(int voice, int do_sustain)
-{
-	if (IS_NO_SOUND(voice))
-		return;
-	if (do_sustain && (voices[voice].cinfo->sustained == 127 ||
-			    voices[voice].sostenuto == 127))
-		voices[voice].state = AWE_ST_SUSTAINED;
-	else {
-		awe_note_off(voice);
-		awe_fx_init(voices[voice].ch);
-		awe_voice_init(voice, FALSE);
-	}
-}
-
-/* release all notes */
-static void awe_note_off_all(int do_sustain)
-{
-	int i;
-	for (i = 0; i < awe_max_voices; i++)
-		release_voice(i, do_sustain);
-}
-
-/* kill a voice:
- *   not terminate, just release the voice.
- */
-static int
-awe_kill_note(int dev, int voice, int note, int velocity)
-{
-	int i, v2, key;
-
-	DEBUG(2,printk("AWE32: [off(%d) nt=%d vl=%d]\n", voice, note, velocity));
-	if (! voice_in_range(voice))
-		return -EINVAL;
-
-	switch (playing_mode) {
-	case AWE_PLAY_DIRECT:
-	case AWE_PLAY_INDIRECT:
-		key = AWE_VOICE_KEY(voice);
-		break;
-
-	case AWE_PLAY_MULTI2:
-		v2 = voice_alloc->map[voice] >> 8;
-		voice_alloc->map[voice] = 0;
-		voice = v2;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return -EINVAL;
-		/* continue to below */
-	default:
-		key = AWE_CHAN_KEY(voice, note);
-		break;
-	}
-
-	for (i = 0; i < awe_max_voices; i++) {
-		if (voices[i].key == key)
-			release_voice(i, TRUE);
-	}
-	return 0;
-}
-
-
-static void start_or_volume_change(int voice, int velocity)
-{
-	voices[voice].velocity = velocity;
-	awe_calc_volume(voice);
-	if (voices[voice].state == AWE_ST_STANDBY)
-		awe_note_on(voice);
-	else if (voices[voice].state == AWE_ST_ON)
-		awe_set_volume(voice, FALSE);
-}
-
-static void set_and_start_voice(int voice, int state)
-{
-	/* calculate pitch & volume parameters */
-	voices[voice].state = state;
-	awe_calc_pitch(voice);
-	awe_calc_volume(voice);
-	if (state == AWE_ST_ON)
-		awe_note_on(voice);
-}
-
-/* start a voice:
- *   if note is 255, identical with aftertouch function.
- *   Otherwise, start a voice with specified not and volume.
- */
-static int
-awe_start_note(int dev, int voice, int note, int velocity)
-{
-	int i, key, state, volonly;
-
-	DEBUG(2,printk("AWE32: [on(%d) nt=%d vl=%d]\n", voice, note, velocity));
-	if (! voice_in_range(voice))
-		return -EINVAL;
-	    
-	if (velocity == 0)
-		state = AWE_ST_STANDBY; /* stand by for playing */
-	else
-		state = AWE_ST_ON;	/* really play */
-	volonly = FALSE;
-
-	switch (playing_mode) {
-	case AWE_PLAY_DIRECT:
-	case AWE_PLAY_INDIRECT:
-		key = AWE_VOICE_KEY(voice);
-		if (note == 255)
-			volonly = TRUE;
-		break;
-
-	case AWE_PLAY_MULTI2:
-		voice = voice_alloc->map[voice] >> 8;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return -EINVAL;
-		/* continue to below */
-	default:
-		if (note >= 128) { /* key volume mode */
-			note -= 128;
-			volonly = TRUE;
-		}
-		key = AWE_CHAN_KEY(voice, note);
-		break;
-	}
-
-	/* dynamic volume change */
-	if (volonly) {
-		for (i = 0; i < awe_max_voices; i++) {
-			if (voices[i].key == key)
-				start_or_volume_change(i, velocity);
-		}
-		return 0;
-	}
-
-	/* if the same note still playing, stop it */
-	if (playing_mode != AWE_PLAY_DIRECT || ctrls[AWE_MD_EXCLUSIVE_SOUND]) {
-		for (i = 0; i < awe_max_voices; i++)
-			if (voices[i].key == key) {
-				if (voices[i].state == AWE_ST_ON) {
-					awe_note_off(i);
-					awe_voice_init(i, FALSE);
-				} else if (voices[i].state == AWE_ST_STANDBY)
-					awe_voice_init(i, TRUE);
-			}
-	}
-
-	/* allocate voices */
-	if (playing_mode == AWE_PLAY_DIRECT)
-		awe_alloc_one_voice(voice, note, velocity);
-	else
-		awe_alloc_multi_voices(voice, note, velocity, key);
-
-	/* turn off other voices exlusively (for drums) */
-	for (i = 0; i < awe_max_voices; i++)
-		if (voices[i].key == key)
-			awe_exclusive_off(i);
-
-	/* set up pitch and volume parameters */
-	for (i = 0; i < awe_max_voices; i++) {
-		if (voices[i].key == key && voices[i].state == AWE_ST_OFF)
-			set_and_start_voice(i, state);
-	}
-
-	return 0;
-}
-
-
-/* calculate hash key */
-static int
-awe_search_key(int bank, int preset, int note)
-{
-	unsigned int key;
-
-#if 1 /* new hash table */
-	if (bank == AWE_DRUM_BANK)
-		key = preset + note + 128;
-	else
-		key = bank + preset;
-#else
-	key = preset;
-#endif
-	key %= AWE_MAX_PRESETS;
-
-	return (int)key;
-}
-
-
-/* search instrument from hash table */
-static awe_voice_list *
-awe_search_instr(int bank, int preset, int note)
-{
-	awe_voice_list *p;
-	int key, key2;
-
-	key = awe_search_key(bank, preset, note);
-	for (p = preset_table[key]; p; p = p->next_bank) {
-		if (p->instr == preset && p->bank == bank)
-			return p;
-	}
-	key2 = awe_search_key(bank, preset, 0); /* search default */
-	if (key == key2)
-		return NULL;
-	for (p = preset_table[key2]; p; p = p->next_bank) {
-		if (p->instr == preset && p->bank == bank)
-			return p;
-	}
-	return NULL;
-}
-
-
-/* assign the instrument to a voice */
-static int
-awe_set_instr_2(int dev, int voice, int instr_no)
-{
-	if (playing_mode == AWE_PLAY_MULTI2) {
-		voice = voice_alloc->map[voice] >> 8;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return -EINVAL;
-	}
-	return awe_set_instr(dev, voice, instr_no);
-}
-
-/* assign the instrument to a channel; voice is the channel number */
-static int
-awe_set_instr(int dev, int voice, int instr_no)
-{
-	awe_chan_info *cinfo;
-
-	if (! voice_in_range(voice))
-		return -EINVAL;
-
-	if (instr_no < 0 || instr_no >= AWE_MAX_PRESETS)
-		return -EINVAL;
-
-	cinfo = &channels[voice];
-	cinfo->instr = instr_no;
-	DEBUG(2,printk("AWE32: [program(%d) %d]\n", voice, instr_no));
-
-	return 0;
-}
-
-
-/* reset all voices; terminate sounds and initialize parameters */
-static void
-awe_reset(int dev)
-{
-	int i;
-	current_alloc_time = 0;
-	/* don't turn off voice 31 and 32.  they are used also for FM voices */
-	for (i = 0; i < awe_max_voices; i++) {
-		awe_terminate(i);
-		awe_voice_init(i, TRUE);
-	}
-	for (i = 0; i < AWE_MAX_CHANNELS; i++)
-		awe_channel_init(i, TRUE);
-	for (i = 0; i < 16; i++) {
-		awe_operations.chn_info[i].controllers[CTL_MAIN_VOLUME] = 127;
-		awe_operations.chn_info[i].controllers[CTL_EXPRESSION] = 127;
-	}
-	awe_init_fm();
-	awe_tweak();
-}
-
-
-/* hardware specific control:
- *   GUS specific and AWE32 specific controls are available.
- */
-static void
-awe_hw_control(int dev, unsigned char *event)
-{
-	int cmd = event[2];
-	if (cmd & _AWE_MODE_FLAG)
-		awe_hw_awe_control(dev, cmd & _AWE_MODE_VALUE_MASK, event);
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-	else
-		awe_hw_gus_control(dev, cmd & _AWE_MODE_VALUE_MASK, event);
-#endif
-}
-
-
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-
-/* GUS compatible controls */
-static void
-awe_hw_gus_control(int dev, int cmd, unsigned char *event)
-{
-	int voice, i, key;
-	unsigned short p1;
-	short p2;
-	int plong;
-
-	if (MULTI_LAYER_MODE())
-		return;
-	if (cmd == _GUS_NUMVOICES)
-		return;
-
-	voice = event[3];
-	if (! voice_in_range(voice))
-		return;
-
-	p1 = *(unsigned short *) &event[4];
-	p2 = *(short *) &event[6];
-	plong = *(int*) &event[4];
-
-	switch (cmd) {
-	case _GUS_VOICESAMPLE:
-		awe_set_instr(dev, voice, p1);
-		return;
-
-	case _GUS_VOICEBALA:
-		/* 0 to 15 --> -128 to 127 */
-		awe_panning(dev, voice, ((int)p1 << 4) - 128);
-		return;
-
-	case _GUS_VOICEVOL:
-	case _GUS_VOICEVOL2:
-		/* not supported yet */
-		return;
-
-	case _GUS_RAMPRANGE:
-	case _GUS_RAMPRATE:
-	case _GUS_RAMPMODE:
-	case _GUS_RAMPON:
-	case _GUS_RAMPOFF:
-		/* volume ramping not supported */
-		return;
-
-	case _GUS_VOLUME_SCALE:
-		return;
-
-	case _GUS_VOICE_POS:
-		FX_SET(&channels[voice].fx, AWE_FX_SAMPLE_START,
-		       (short)(plong & 0x7fff));
-		FX_SET(&channels[voice].fx, AWE_FX_COARSE_SAMPLE_START,
-		       (plong >> 15) & 0xffff);
-		return;
-	}
-
-	key = AWE_VOICE_KEY(voice);
-	for (i = 0; i < awe_max_voices; i++) {
-		if (voices[i].key == key) {
-			switch (cmd) {
-			case _GUS_VOICEON:
-				awe_note_on(i);
-				break;
-
-			case _GUS_VOICEOFF:
-				awe_terminate(i);
-				awe_fx_init(voices[i].ch);
-				awe_voice_init(i, TRUE);
-				break;
-
-			case _GUS_VOICEFADE:
-				awe_note_off(i);
-				awe_fx_init(voices[i].ch);
-				awe_voice_init(i, FALSE);
-				break;
-
-			case _GUS_VOICEFREQ:
-				awe_calc_pitch_from_freq(i, plong);
-				break;
-			}
-		}
-	}
-}
-
-#endif /* gus_compat */
-
-
-/* AWE32 specific controls */
-static void
-awe_hw_awe_control(int dev, int cmd, unsigned char *event)
-{
-	int voice;
-	unsigned short p1;
-	short p2;
-	int i;
-
-	voice = event[3];
-	if (! voice_in_range(voice))
-		return;
-
-	if (playing_mode == AWE_PLAY_MULTI2) {
-		voice = voice_alloc->map[voice] >> 8;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return;
-	}
-
-	p1 = *(unsigned short *) &event[4];
-	p2 = *(short *) &event[6];
-
-	switch (cmd) {
-	case _AWE_DEBUG_MODE:
-		ctrls[AWE_MD_DEBUG_MODE] = p1;
-		printk(KERN_DEBUG "AWE32: debug mode = %d\n", ctrls[AWE_MD_DEBUG_MODE]);
-		break;
-	case _AWE_REVERB_MODE:
-		ctrls[AWE_MD_REVERB_MODE] = p1;
-		awe_update_reverb_mode();
-		break;
-
-	case _AWE_CHORUS_MODE:
-		ctrls[AWE_MD_CHORUS_MODE] = p1;
-		awe_update_chorus_mode();
-		break;
-		      
-	case _AWE_REMOVE_LAST_SAMPLES:
-		DEBUG(0,printk("AWE32: remove last samples\n"));
-		awe_reset(0);
-		if (locked_sf_id > 0)
-			awe_remove_samples(locked_sf_id);
-		break;
-
-	case _AWE_INITIALIZE_CHIP:
-		awe_initialize();
-		break;
-
-	case _AWE_SEND_EFFECT:
-		i = -1;
-		if (p1 >= 0x100) {
-			i = (p1 >> 8);
-			if (i < 0 || i >= MAX_LAYERS)
-				break;
-		}
-		awe_send_effect(voice, i, p1, p2);
-		break;
-
-	case _AWE_RESET_CHANNEL:
-		awe_channel_init(voice, !p1);
-		break;
-		
-	case _AWE_TERMINATE_ALL:
-		awe_reset(0);
-		break;
-
-	case _AWE_TERMINATE_CHANNEL:
-		awe_voice_change(voice, awe_terminate_and_init);
-		break;
-
-	case _AWE_RELEASE_ALL:
-		awe_note_off_all(FALSE);
-		break;
-	case _AWE_NOTEOFF_ALL:
-		awe_note_off_all(TRUE);
-		break;
-
-	case _AWE_INITIAL_VOLUME:
-		DEBUG(0,printk("AWE32: init attenuation %d\n", p1));
-		atten_relative = (char)p2;
-		atten_offset = (short)p1;
-		awe_update_volume();
-		break;
-
-	case _AWE_CHN_PRESSURE:
-		channels[voice].chan_press = p1;
-		awe_modwheel_change(voice, p1);
-		break;
-
-	case _AWE_CHANNEL_MODE:
-		DEBUG(0,printk("AWE32: channel mode = %d\n", p1));
-		playing_mode = p1;
-		awe_reset(0);
-		break;
-
-	case _AWE_DRUM_CHANNELS:
-		DEBUG(0,printk("AWE32: drum flags = %x\n", p1));
-		drum_flags = *(unsigned int*)&event[4];
-		break;
-
-	case _AWE_MISC_MODE:
-		DEBUG(0,printk("AWE32: ctrl parms = %d %d\n", p1, p2));
-		if (p1 > AWE_MD_VERSION && p1 < AWE_MD_END) {
-			ctrls[p1] = p2;
-			if (ctrl_parms[p1].update)
-				ctrl_parms[p1].update();
-		}
-		break;
-
-	case _AWE_EQUALIZER:
-		ctrls[AWE_MD_BASS_LEVEL] = p1;
-		ctrls[AWE_MD_TREBLE_LEVEL] = p2;
-		awe_update_equalizer();
-		break;
-
-	default:
-		DEBUG(0,printk("AWE32: hw control cmd=%d voice=%d\n", cmd, voice));
-		break;
-	}
-}
-
-
-/* change effects */
-static void
-awe_send_effect(int voice, int layer, int type, int val)
-{
-	awe_chan_info *cinfo;
-	FX_Rec *fx;
-	int mode;
-
-	cinfo = &channels[voice];
-	if (layer >= 0 && layer < MAX_LAYERS)
-		fx = &cinfo->fx_layer[layer];
-	else
-		fx = &cinfo->fx;
-
-	if (type & 0x40)
-		mode = FX_FLAG_OFF;
-	else if (type & 0x80)
-		mode = FX_FLAG_ADD;
-	else
-		mode = FX_FLAG_SET;
-	type &= 0x3f;
-
-	if (type >= 0 && type < AWE_FX_END) {
-		DEBUG(2,printk("AWE32: effects (%d) %d %d\n", voice, type, val));
-		if (mode == FX_FLAG_SET)
-			FX_SET(fx, type, val);
-		else if (mode == FX_FLAG_ADD)
-			FX_ADD(fx, type, val);
-		else
-			FX_UNSET(fx, type);
-		if (mode != FX_FLAG_OFF && parm_defs[type].realtime) {
-			DEBUG(2,printk("AWE32: fx_realtime (%d)\n", voice));
-			awe_voice_change(voice, parm_defs[type].realtime);
-		}
-	}
-}
-
-
-/* change modulation wheel; voice is already mapped on multi2 mode */
-static void
-awe_modwheel_change(int voice, int value)
-{
-	int i;
-	awe_chan_info *cinfo;
-
-	cinfo = &channels[voice];
-	i = value * ctrls[AWE_MD_MOD_SENSE] / 1200;
-	FX_ADD(&cinfo->fx, AWE_FX_LFO1_PITCH, i);
-	awe_voice_change(voice, awe_fx_fmmod);
-	FX_ADD(&cinfo->fx, AWE_FX_LFO2_PITCH, i);
-	awe_voice_change(voice, awe_fx_fm2frq2);
-}
-
-
-/* voice pressure change */
-static void
-awe_aftertouch(int dev, int voice, int pressure)
-{
-	int note;
-
-	DEBUG(2,printk("AWE32: [after(%d) %d]\n", voice, pressure));
-	if (! voice_in_range(voice))
-		return;
-
-	switch (playing_mode) {
-	case AWE_PLAY_DIRECT:
-	case AWE_PLAY_INDIRECT:
-		awe_start_note(dev, voice, 255, pressure);
-		break;
-	case AWE_PLAY_MULTI2:
-		note = (voice_alloc->map[voice] & 0xff) - 1;
-		awe_key_pressure(dev, voice, note + 0x80, pressure);
-		break;
-	}
-}
-
-
-/* voice control change */
-static void
-awe_controller(int dev, int voice, int ctrl_num, int value)
-{
-	awe_chan_info *cinfo;
-
-	if (! voice_in_range(voice))
-		return;
-
-	if (playing_mode == AWE_PLAY_MULTI2) {
-		voice = voice_alloc->map[voice] >> 8;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return;
-	}
-
-	cinfo = &channels[voice];
-
-	switch (ctrl_num) {
-	case CTL_BANK_SELECT: /* MIDI control #0 */
-		DEBUG(2,printk("AWE32: [bank(%d) %d]\n", voice, value));
-		if (MULTI_LAYER_MODE() && IS_DRUM_CHANNEL(voice) &&
-		    !ctrls[AWE_MD_TOGGLE_DRUM_BANK])
-			break;
-		if (value < 0 || value > 255)
-			break;
-		cinfo->bank = value;
-		if (cinfo->bank == AWE_DRUM_BANK)
-			DRUM_CHANNEL_ON(cinfo->channel);
-		else
-			DRUM_CHANNEL_OFF(cinfo->channel);
-		awe_set_instr(dev, voice, cinfo->instr);
-		break;
-
-	case CTL_MODWHEEL: /* MIDI control #1 */
-		DEBUG(2,printk("AWE32: [modwheel(%d) %d]\n", voice, value));
-		awe_modwheel_change(voice, value);
-		break;
-
-	case CTRL_PITCH_BENDER: /* SEQ1 V2 contorl */
-		DEBUG(2,printk("AWE32: [bend(%d) %d]\n", voice, value));
-		/* zero centered */
-		cinfo->bender = value;
-		awe_voice_change(voice, awe_set_voice_pitch);
-		break;
-
-	case CTRL_PITCH_BENDER_RANGE: /* SEQ1 V2 control */
-		DEBUG(2,printk("AWE32: [range(%d) %d]\n", voice, value));
-		/* value = sense x 100 */
-		cinfo->bender_range = value;
-		/* no audible pitch change yet.. */
-		break;
-
-	case CTL_EXPRESSION: /* MIDI control #11 */
-		if (SINGLE_LAYER_MODE())
-			value /= 128;
-	case CTRL_EXPRESSION: /* SEQ1 V2 control */
-		DEBUG(2,printk("AWE32: [expr(%d) %d]\n", voice, value));
-		/* 0 - 127 */
-		cinfo->expression_vol = value;
-		awe_voice_change(voice, awe_set_voice_vol);
-		break;
-
-	case CTL_PAN:	/* MIDI control #10 */
-		DEBUG(2,printk("AWE32: [pan(%d) %d]\n", voice, value));
-		/* (0-127) -> signed 8bit */
-		cinfo->panning = value * 2 - 128;
-		if (ctrls[AWE_MD_REALTIME_PAN])
-			awe_voice_change(voice, awe_set_pan);
-		break;
-
-	case CTL_MAIN_VOLUME:	/* MIDI control #7 */
-		if (SINGLE_LAYER_MODE())
-			value = (value * 100) / 16383;
-	case CTRL_MAIN_VOLUME:	/* SEQ1 V2 control */
-		DEBUG(2,printk("AWE32: [mainvol(%d) %d]\n", voice, value));
-		/* 0 - 127 */
-		cinfo->main_vol = value;
-		awe_voice_change(voice, awe_set_voice_vol);
-		break;
-
-	case CTL_EXT_EFF_DEPTH: /* reverb effects: 0-127 */
-		DEBUG(2,printk("AWE32: [reverb(%d) %d]\n", voice, value));
-		FX_SET(&cinfo->fx, AWE_FX_REVERB, value * 2);
-		break;
-
-	case CTL_CHORUS_DEPTH: /* chorus effects: 0-127 */
-		DEBUG(2,printk("AWE32: [chorus(%d) %d]\n", voice, value));
-		FX_SET(&cinfo->fx, AWE_FX_CHORUS, value * 2);
-		break;
-
-	case 120:  /* all sounds off */
-		awe_note_off_all(FALSE);
-		break;
-	case 123:  /* all notes off */
-		awe_note_off_all(TRUE);
-		break;
-
-	case CTL_SUSTAIN: /* MIDI control #64 */
-		cinfo->sustained = value;
-		if (value != 127)
-			awe_voice_change(voice, awe_sustain_off);
-		break;
-
-	case CTL_SOSTENUTO: /* MIDI control #66 */
-		if (value == 127)
-			awe_voice_change(voice, awe_sostenuto_on);
-		else
-			awe_voice_change(voice, awe_sustain_off);
-		break;
-
-	default:
-		DEBUG(0,printk("AWE32: [control(%d) ctrl=%d val=%d]\n",
-			   voice, ctrl_num, value));
-		break;
-	}
-}
-
-
-/* voice pan change (value = -128 - 127) */
-static void
-awe_panning(int dev, int voice, int value)
-{
-	awe_chan_info *cinfo;
-
-	if (! voice_in_range(voice))
-		return;
-
-	if (playing_mode == AWE_PLAY_MULTI2) {
-		voice = voice_alloc->map[voice] >> 8;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return;
-	}
-
-	cinfo = &channels[voice];
-	cinfo->panning = value;
-	DEBUG(2,printk("AWE32: [pan(%d) %d]\n", voice, cinfo->panning));
-	if (ctrls[AWE_MD_REALTIME_PAN])
-		awe_voice_change(voice, awe_set_pan);
-}
-
-
-/* volume mode change */
-static void
-awe_volume_method(int dev, int mode)
-{
-	/* not impremented */
-	DEBUG(0,printk("AWE32: [volmethod mode=%d]\n", mode));
-}
-
-
-/* pitch wheel change: 0-16384 */
-static void
-awe_bender(int dev, int voice, int value)
-{
-	awe_chan_info *cinfo;
-
-	if (! voice_in_range(voice))
-		return;
-
-	if (playing_mode == AWE_PLAY_MULTI2) {
-		voice = voice_alloc->map[voice] >> 8;
-		if (voice < 0 || voice >= AWE_MAX_CHANNELS)
-			return;
-	}
-
-	/* convert to zero centered value */
-	cinfo = &channels[voice];
-	cinfo->bender = value - 8192;
-	DEBUG(2,printk("AWE32: [bend(%d) %d]\n", voice, cinfo->bender));
-	awe_voice_change(voice, awe_set_voice_pitch);
-}
-
-
-/*
- * load a sound patch:
- *   three types of patches are accepted: AWE, GUS, and SYSEX.
- */
-
-static int
-awe_load_patch(int dev, int format, const char __user *addr,
-	       int offs, int count, int pmgr_flag)
-{
-	awe_patch_info patch;
-	int rc = 0;
-
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-	if (format == GUS_PATCH) {
-		return awe_load_guspatch(addr, offs, count, pmgr_flag);
-	} else
-#endif
-	if (format == SYSEX_PATCH) {
-		/* no system exclusive message supported yet */
-		return 0;
-	} else if (format != AWE_PATCH) {
-		printk(KERN_WARNING "AWE32 Error: Invalid patch format (key) 0x%x\n", format);
-		return -EINVAL;
-	}
-	
-	if (count < AWE_PATCH_INFO_SIZE) {
-		printk(KERN_WARNING "AWE32 Error: Patch header too short\n");
-		return -EINVAL;
-	}
-	if (copy_from_user(((char*)&patch) + offs, addr + offs, 
-			   AWE_PATCH_INFO_SIZE - offs))
-		return -EFAULT;
-
-	count -= AWE_PATCH_INFO_SIZE;
-	if (count < patch.len) {
-		printk(KERN_WARNING "AWE32: sample: Patch record too short (%d<%d)\n",
-		       count, patch.len);
-		return -EINVAL;
-	}
-	
-	switch (patch.type) {
-	case AWE_LOAD_INFO:
-		rc = awe_load_info(&patch, addr, count);
-		break;
-	case AWE_LOAD_DATA:
-		rc = awe_load_data(&patch, addr, count);
-		break;
-	case AWE_OPEN_PATCH:
-		rc = awe_open_patch(&patch, addr, count);
-		break;
-	case AWE_CLOSE_PATCH:
-		rc = awe_close_patch(&patch, addr, count);
-		break;
-	case AWE_UNLOAD_PATCH:
-		rc = awe_unload_patch(&patch, addr, count);
-		break;
-	case AWE_REPLACE_DATA:
-		rc = awe_replace_data(&patch, addr, count);
-		break;
-	case AWE_MAP_PRESET:
-		rc = awe_load_map(&patch, addr, count);
-		break;
-	/* case AWE_PROBE_INFO:
-		rc = awe_probe_info(&patch, addr, count);
-		break;*/
-	case AWE_PROBE_DATA:
-		rc = awe_probe_data(&patch, addr, count);
-		break;
-	case AWE_REMOVE_INFO:
-		rc = awe_remove_info(&patch, addr, count);
-		break;
-	case AWE_LOAD_CHORUS_FX:
-		rc = awe_load_chorus_fx(&patch, addr, count);
-		break;
-	case AWE_LOAD_REVERB_FX:
-		rc = awe_load_reverb_fx(&patch, addr, count);
-		break;
-
-	default:
-		printk(KERN_WARNING "AWE32 Error: unknown patch format type %d\n",
-		       patch.type);
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-
-/* create an sf list record */
-static int
-awe_create_sf(int type, char *name)
-{
-	sf_list *rec;
-
-	/* terminate sounds */
-	awe_reset(0);
-	rec = (sf_list *)kmalloc(sizeof(*rec), GFP_KERNEL);
-	if (rec == NULL)
-		return 1; /* no memory */
-	rec->sf_id = current_sf_id + 1;
-	rec->type = type;
-	if (/*current_sf_id == 0 ||*/ (type & AWE_PAT_LOCKED) != 0)
-		locked_sf_id = current_sf_id + 1;
-	rec->num_info = awe_free_info();
-	rec->num_sample = awe_free_sample();
-	rec->mem_ptr = awe_free_mem_ptr();
-	rec->infos = rec->last_infos = NULL;
-	rec->samples = rec->last_samples = NULL;
-
-	/* add to linked-list */
-	rec->next = NULL;
-	rec->prev = sftail;
-	if (sftail)
-		sftail->next = rec;
-	else
-		sfhead = rec;
-	sftail = rec;
-	current_sf_id++;
-
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	rec->shared = NULL;
-	if (name)
-		memcpy(rec->name, name, AWE_PATCH_NAME_LEN);
-	else
-		strcpy(rec->name, "*TEMPORARY*");
-	if (current_sf_id > 1 && name && (type & AWE_PAT_SHARED) != 0) {
-		/* is the current font really a shared font? */
-		if (is_shared_sf(rec->name)) {
-			/* check if the shared font is already installed */
-			sf_list *p;
-			for (p = rec->prev; p; p = p->prev) {
-				if (is_identical_name(rec->name, p)) {
-					rec->shared = p;
-					break;
-				}
-			}
-		}
-	}
-#endif /* allow sharing */
-
-	return 0;
-}
-
-
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-
-/* check if the given name is a valid shared name */
-#define ASC_TO_KEY(c) ((c) - 'A' + 1)
-static int is_shared_sf(unsigned char *name)
-{
-	static unsigned char id_head[4] = {
-		ASC_TO_KEY('A'), ASC_TO_KEY('W'), ASC_TO_KEY('E'),
-		AWE_MAJOR_VERSION,
-	};
-	if (memcmp(name, id_head, 4) == 0)
-		return TRUE;
-	return FALSE;
-}
-
-/* check if the given name matches to the existing list */
-static int is_identical_name(unsigned char *name, sf_list *p) 
-{
-	char *id = p->name;
-	if (is_shared_sf(id) && memcmp(id, name, AWE_PATCH_NAME_LEN) == 0)
-		return TRUE;
-	return FALSE;
-}
-
-/* check if the given voice info exists */
-static int info_duplicated(sf_list *sf, awe_voice_list *rec)
-{
-	/* search for all sharing lists */
-	for (; sf; sf = sf->shared) {
-		awe_voice_list *p;
-		for (p = sf->infos; p; p = p->next) {
-			if (p->type == V_ST_NORMAL &&
-			    p->bank == rec->bank &&
-			    p->instr == rec->instr &&
-			    p->v.low == rec->v.low &&
-			    p->v.high == rec->v.high &&
-			    p->v.sample == rec->v.sample)
-				return TRUE;
-		}
-	}
-	return FALSE;
-}
-
-#endif /* AWE_ALLOW_SAMPLE_SHARING */
-
-
-/* free sf_list record */
-/* linked-list in this function is not cared */
-static void
-awe_free_sf(sf_list *sf)
-{
-	if (sf->infos) {
-		awe_voice_list *p, *next;
-		for (p = sf->infos; p; p = next) {
-			next = p->next;
-			kfree(p);
-		}
-	}
-	if (sf->samples) {
-		awe_sample_list *p, *next;
-		for (p = sf->samples; p; p = next) {
-			next = p->next;
-			kfree(p);
-		}
-	}
-	kfree(sf);
-}
-
-
-/* open patch; create sf list and set opened flag */
-static int
-awe_open_patch(awe_patch_info *patch, const char __user *addr, int count)
-{
-	awe_open_parm parm;
-	int shared;
-
-	if (copy_from_user(&parm, addr + AWE_PATCH_INFO_SIZE, sizeof(parm)))
-		return -EFAULT;
-	shared = FALSE;
-
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	if (sftail && (parm.type & AWE_PAT_SHARED) != 0) {
-		/* is the previous font the same font? */
-		if (is_identical_name(parm.name, sftail)) {
-			/* then append to the previous */
-			shared = TRUE;
-			awe_reset(0);
-			if (parm.type & AWE_PAT_LOCKED)
-				locked_sf_id = current_sf_id;
-		}
-	}
-#endif /* allow sharing */
-	if (! shared) {
-		if (awe_create_sf(parm.type, parm.name)) {
-			printk(KERN_ERR "AWE32: can't open: failed to alloc new list\n");
-			return -ENOMEM;
-		}
-	}
-	patch_opened = TRUE;
-	return current_sf_id;
-}
-
-/* check if the patch is already opened */
-static sf_list *
-check_patch_opened(int type, char *name)
-{
-	if (! patch_opened) {
-		if (awe_create_sf(type, name)) {
-			printk(KERN_ERR "AWE32: failed to alloc new list\n");
-			return NULL;
-		}
-		patch_opened = TRUE;
-		return sftail;
-	}
-	return sftail;
-}
-
-/* close the patch; if no voice is loaded, remove the patch */
-static int
-awe_close_patch(awe_patch_info *patch, const char __user *addr, int count)
-{
-	if (patch_opened && sftail) {
-		/* if no voice is loaded, release the current patch */
-		if (sftail->infos == NULL) {
-			awe_reset(0);
-			awe_remove_samples(current_sf_id - 1);
-		}
-	}
-	patch_opened = 0;
-	return 0;
-}
-
-
-/* remove the latest patch */
-static int
-awe_unload_patch(awe_patch_info *patch, const char __user *addr, int count)
-{
-	if (current_sf_id > 0 && current_sf_id > locked_sf_id) {
-		awe_reset(0);
-		awe_remove_samples(current_sf_id - 1);
-	}
-	return 0;
-}
-
-/* allocate voice info list records */
-static awe_voice_list *
-alloc_new_info(void)
-{
-	awe_voice_list *newlist;
-	
-	newlist = kmalloc(sizeof(*newlist), GFP_KERNEL);
-	if (newlist == NULL) {
-		printk(KERN_ERR "AWE32: can't alloc info table\n");
-		return NULL;
-	}
-	return newlist;
-}
-
-/* allocate sample info list records */
-static awe_sample_list *
-alloc_new_sample(void)
-{
-	awe_sample_list *newlist;
-	
-	newlist = (awe_sample_list *)kmalloc(sizeof(*newlist), GFP_KERNEL);
-	if (newlist == NULL) {
-		printk(KERN_ERR "AWE32: can't alloc sample table\n");
-		return NULL;
-	}
-	return newlist;
-}
-
-/* load voice map */
-static int
-awe_load_map(awe_patch_info *patch, const char __user *addr, int count)
-{
-	awe_voice_map map;
-	awe_voice_list *rec, *p;
-	sf_list *sf;
-
-	/* get the link info */
-	if (count < sizeof(map)) {
-		printk(KERN_WARNING "AWE32 Error: invalid patch info length\n");
-		return -EINVAL;
-	}
-	if (copy_from_user(&map, addr + AWE_PATCH_INFO_SIZE, sizeof(map)))
-		return -EFAULT;
-	
-	/* check if the identical mapping already exists */
-	p = awe_search_instr(map.map_bank, map.map_instr, map.map_key);
-	for (; p; p = p->next_instr) {
-		if (p->type == V_ST_MAPPED &&
-		    p->v.start == map.src_instr &&
-		    p->v.end == map.src_bank &&
-		    p->v.fixkey == map.src_key)
-			return 0; /* already present! */
-	}
-
-	if ((sf = check_patch_opened(AWE_PAT_TYPE_MAP, NULL)) == NULL)
-		return -ENOMEM;
-
-	if ((rec = alloc_new_info()) == NULL)
-		return -ENOMEM;
-
-	rec->bank = map.map_bank;
-	rec->instr = map.map_instr;
-	rec->type = V_ST_MAPPED;
-	rec->disabled = FALSE;
-	awe_init_voice_info(&rec->v);
-	if (map.map_key >= 0) {
-		rec->v.low = map.map_key;
-		rec->v.high = map.map_key;
-	}
-	rec->v.start = map.src_instr;
-	rec->v.end = map.src_bank;
-	rec->v.fixkey = map.src_key;
-	add_sf_info(sf, rec);
-	add_info_list(rec);
-
-	return 0;
-}
-
-#if 0
-/* probe preset in the current list -- nothing to be loaded */
-static int
-awe_probe_info(awe_patch_info *patch, const char __user *addr, int count)
-{
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	awe_voice_map map;
-	awe_voice_list *p;
-
-	if (! patch_opened)
-		return -EINVAL;
-
-	/* get the link info */
-	if (count < sizeof(map)) {
-		printk(KERN_WARNING "AWE32 Error: invalid patch info length\n");
-		return -EINVAL;
-	}
-	if (copy_from_user(&map, addr + AWE_PATCH_INFO_SIZE, sizeof(map)))
-		return -EFAULT;
-	
-	/* check if the identical mapping already exists */
-	if (sftail == NULL)
-		return -EINVAL;
-	p = awe_search_instr(map.src_bank, map.src_instr, map.src_key);
-	for (; p; p = p->next_instr) {
-		if (p->type == V_ST_NORMAL &&
-		    is_identical_holder(p->holder, sftail) &&
-		    p->v.low <= map.src_key &&
-		    p->v.high >= map.src_key)
-			return 0; /* already present! */
-	}
-#endif /* allow sharing */
-	return -EINVAL;
-}
-#endif
-
-/* probe sample in the current list -- nothing to be loaded */
-static int
-awe_probe_data(awe_patch_info *patch, const char __user *addr, int count)
-{
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	if (! patch_opened)
-		return -EINVAL;
-
-	/* search the specified sample by optarg */
-	if (search_sample_index(sftail, patch->optarg) != NULL)
-		return 0;
-#endif /* allow sharing */
-	return -EINVAL;
-}
-
-		
-/* remove the present instrument layers */
-static int
-remove_info(sf_list *sf, int bank, int instr)
-{
-	awe_voice_list *prev, *next, *p;
-	int removed = 0;
-
-	prev = NULL;
-	for (p = sf->infos; p; p = next) {
-		next = p->next;
-		if (p->type == V_ST_NORMAL &&
-		    p->bank == bank && p->instr == instr) {
-			/* remove this layer */
-			if (prev)
-				prev->next = next;
-			else
-				sf->infos = next;
-			if (p == sf->last_infos)
-				sf->last_infos = prev;
-			sf->num_info--;
-			removed++;
-			kfree(p);
-		} else
-			prev = p;
-	}
-	if (removed)
-		rebuild_preset_list();
-	return removed;
-}
-
-/* load voice information data */
-static int
-awe_load_info(awe_patch_info *patch, const char __user *addr, int count)
-{
-	int offset;
-	awe_voice_rec_hdr hdr;
-	int i;
-	int total_size;
-	sf_list *sf;
-	awe_voice_list *rec;
-
-	if (count < AWE_VOICE_REC_SIZE) {
-		printk(KERN_WARNING "AWE32 Error: invalid patch info length\n");
-		return -EINVAL;
-	}
-
-	offset = AWE_PATCH_INFO_SIZE;
-	if (copy_from_user((char*)&hdr, addr + offset, AWE_VOICE_REC_SIZE))
-		return -EFAULT;
-	offset += AWE_VOICE_REC_SIZE;
-
-	if (hdr.nvoices <= 0 || hdr.nvoices >= 100) {
-		printk(KERN_WARNING "AWE32 Error: Invalid voice number %d\n", hdr.nvoices);
-		return -EINVAL;
-	}
-	total_size = AWE_VOICE_REC_SIZE + AWE_VOICE_INFO_SIZE * hdr.nvoices;
-	if (count < total_size) {
-		printk(KERN_WARNING "AWE32 Error: patch length(%d) is smaller than nvoices(%d)\n",
-		       count, hdr.nvoices);
-		return -EINVAL;
-	}
-
-	if ((sf = check_patch_opened(AWE_PAT_TYPE_MISC, NULL)) == NULL)
-		return -ENOMEM;
-
-	switch (hdr.write_mode) {
-	case AWE_WR_EXCLUSIVE:
-		/* exclusive mode - if the instrument already exists,
-		   return error */
-		for (rec = sf->infos; rec; rec = rec->next) {
-			if (rec->type == V_ST_NORMAL &&
-			    rec->bank == hdr.bank &&
-			    rec->instr == hdr.instr)
-				return -EINVAL;
-		}
-		break;
-	case AWE_WR_REPLACE:
-		/* replace mode - remove the instrument if it already exists */
-		remove_info(sf, hdr.bank, hdr.instr);
-		break;
-	}
-
-	/* append new layers */
-	for (i = 0; i < hdr.nvoices; i++) {
-		rec = alloc_new_info();
-		if (rec == NULL)
-			return -ENOMEM;
-
-		rec->bank = hdr.bank;
-		rec->instr = hdr.instr;
-		rec->type = V_ST_NORMAL;
-		rec->disabled = FALSE;
-
-		/* copy awe_voice_info parameters */
-		if (copy_from_user(&rec->v, addr + offset, AWE_VOICE_INFO_SIZE)) {
-			kfree(rec);
-			return -EFAULT;
-		}
-		offset += AWE_VOICE_INFO_SIZE;
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-		if (sf && sf->shared) {
-			if (info_duplicated(sf, rec)) {
-				kfree(rec);
-				continue;
-			}
-		}
-#endif /* allow sharing */
-		if (rec->v.mode & AWE_MODE_INIT_PARM)
-			awe_init_voice_parm(&rec->v.parm);
-		add_sf_info(sf, rec);
-		awe_set_sample(rec);
-		add_info_list(rec);
-	}
-
-	return 0;
-}
-
-
-/* remove instrument layers */
-static int
-awe_remove_info(awe_patch_info *patch, const char __user *addr, int count)
-{
-	unsigned char bank, instr;
-	sf_list *sf;
-
-	if (! patch_opened || (sf = sftail) == NULL) {
-		printk(KERN_WARNING "AWE32: remove_info: patch not opened\n");
-		return -EINVAL;
-	}
-
-	bank = ((unsigned short)patch->optarg >> 8) & 0xff;
-	instr = (unsigned short)patch->optarg & 0xff;
-	if (! remove_info(sf, bank, instr))
-		return -EINVAL;
-	return 0;
-}
-
-
-/* load wave sample data */
-static int
-awe_load_data(awe_patch_info *patch, const char __user *addr, int count)
-{
-	int offset, size;
-	int rc;
-	awe_sample_info tmprec;
-	awe_sample_list *rec;
-	sf_list *sf;
-
-	if ((sf = check_patch_opened(AWE_PAT_TYPE_MISC, NULL)) == NULL)
-		return -ENOMEM;
-
-	size = (count - AWE_SAMPLE_INFO_SIZE) / 2;
-	offset = AWE_PATCH_INFO_SIZE;
-	if (copy_from_user(&tmprec, addr + offset, AWE_SAMPLE_INFO_SIZE))
-		return -EFAULT;
-	offset += AWE_SAMPLE_INFO_SIZE;
-	if (size != tmprec.size) {
-		printk(KERN_WARNING "AWE32: load: sample size differed (%d != %d)\n",
-		       tmprec.size, size);
-		return -EINVAL;
-	}
-
-	if (search_sample_index(sf, tmprec.sample) != NULL) {
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-		/* if shared sample, skip this data */
-		if (sf->type & AWE_PAT_SHARED)
-			return 0;
-#endif /* allow sharing */
-		DEBUG(1,printk("AWE32: sample data %d already present\n", tmprec.sample));
-		return -EINVAL;
-	}
-
-	if ((rec = alloc_new_sample()) == NULL)
-		return -ENOMEM;
-
-	memcpy(&rec->v, &tmprec, sizeof(tmprec));
-
-	if (rec->v.size > 0) {
-		if ((rc = awe_write_wave_data(addr, offset, rec, -1)) < 0) {
-			kfree(rec);
-			return rc;
-		}
-		sf->mem_ptr += rc;
-	}
-
-	add_sf_sample(sf, rec);
-	return 0;
-}
-
-
-/* replace wave sample data */
-static int
-awe_replace_data(awe_patch_info *patch, const char __user *addr, int count)
-{
-	int offset;
-	int size;
-	int rc;
-	int channels;
-	awe_sample_info cursmp;
-	int save_mem_ptr;
-	sf_list *sf;
-	awe_sample_list *rec;
-
-	if (! patch_opened || (sf = sftail) == NULL) {
-		printk(KERN_WARNING "AWE32: replace: patch not opened\n");
-		return -EINVAL;
-	}
-
-	size = (count - AWE_SAMPLE_INFO_SIZE) / 2;
-	offset = AWE_PATCH_INFO_SIZE;
-	if (copy_from_user(&cursmp, addr + offset, AWE_SAMPLE_INFO_SIZE))
-		return -EFAULT;
-	offset += AWE_SAMPLE_INFO_SIZE;
-	if (cursmp.size == 0 || size != cursmp.size) {
-		printk(KERN_WARNING "AWE32: replace: invalid sample size (%d!=%d)\n",
-		       cursmp.size, size);
-		return -EINVAL;
-	}
-	channels = patch->optarg;
-	if (channels <= 0 || channels > AWE_NORMAL_VOICES) {
-		printk(KERN_WARNING "AWE32: replace: invalid channels %d\n", channels);
-		return -EINVAL;
-	}
-
-	for (rec = sf->samples; rec; rec = rec->next) {
-		if (rec->v.sample == cursmp.sample)
-			break;
-	}
-	if (rec == NULL) {
-		printk(KERN_WARNING "AWE32: replace: cannot find existing sample data %d\n",
-		       cursmp.sample);
-		return -EINVAL;
-	}
-		
-	if (rec->v.size != cursmp.size) {
-		printk(KERN_WARNING "AWE32: replace: exiting size differed (%d!=%d)\n",
-		       rec->v.size, cursmp.size);
-		return -EINVAL;
-	}
-
-	save_mem_ptr = awe_free_mem_ptr();
-	sftail->mem_ptr = rec->v.start - awe_mem_start;
-	memcpy(&rec->v, &cursmp, sizeof(cursmp));
-	rec->v.sf_id = current_sf_id;
-	if ((rc = awe_write_wave_data(addr, offset, rec, channels)) < 0)
-		return rc;
-	sftail->mem_ptr = save_mem_ptr;
-
-	return 0;
-}
-
-
-/*----------------------------------------------------------------*/
-
-static const char __user *readbuf_addr;
-static int readbuf_offs;
-static int readbuf_flags;
-
-/* initialize read buffer */
-static int
-readbuf_init(const char __user *addr, int offset, awe_sample_info *sp)
-{
-	readbuf_addr = addr;
-	readbuf_offs = offset;
-	readbuf_flags = sp->mode_flags;
-	return 0;
-}
-
-/* read directly from user buffer */
-static unsigned short
-readbuf_word(int pos)
-{
-	unsigned short c;
-	/* read from user buffer */
-	if (readbuf_flags & AWE_SAMPLE_8BITS) {
-		unsigned char cc;
-		get_user(cc, (unsigned char __user *)(readbuf_addr + readbuf_offs + pos));
-		c = (unsigned short)cc << 8; /* convert 8bit -> 16bit */
-	} else {
-		get_user(c, (unsigned short __user *)(readbuf_addr + readbuf_offs + pos * 2));
-	}
-	if (readbuf_flags & AWE_SAMPLE_UNSIGNED)
-		c ^= 0x8000; /* unsigned -> signed */
-	return c;
-}
-
-#define readbuf_word_cache	readbuf_word
-#define readbuf_end()		/**/
-
-/*----------------------------------------------------------------*/
-
-#define BLANK_LOOP_START	8
-#define BLANK_LOOP_END		40
-#define BLANK_LOOP_SIZE		48
-
-/* loading onto memory - return the actual written size */
-static int 
-awe_write_wave_data(const char __user *addr, int offset, awe_sample_list *list, int channels)
-{
-	int i, truesize, dram_offset;
-	awe_sample_info *sp = &list->v;
-	int rc;
-
-	/* be sure loop points start < end */
-	if (sp->loopstart > sp->loopend) {
-		int tmp = sp->loopstart;
-		sp->loopstart = sp->loopend;
-		sp->loopend = tmp;
-	}
-
-	/* compute true data size to be loaded */
-	truesize = sp->size;
-	if (sp->mode_flags & (AWE_SAMPLE_BIDIR_LOOP|AWE_SAMPLE_REVERSE_LOOP))
-		truesize += sp->loopend - sp->loopstart;
-	if (sp->mode_flags & AWE_SAMPLE_NO_BLANK)
-		truesize += BLANK_LOOP_SIZE;
-	if (awe_free_mem_ptr() + truesize >= memsize/2) {
-		DEBUG(-1,printk("AWE32 Error: Sample memory full\n"));
-		return -ENOSPC;
-	}
-
-	/* recalculate address offset */
-	sp->end -= sp->start;
-	sp->loopstart -= sp->start;
-	sp->loopend -= sp->start;
-
-	dram_offset = awe_free_mem_ptr() + awe_mem_start;
-	sp->start = dram_offset;
-	sp->end += dram_offset;
-	sp->loopstart += dram_offset;
-	sp->loopend += dram_offset;
-
-	/* set the total size (store onto obsolete checksum value) */
-	if (sp->size == 0)
-		sp->checksum = 0;
-	else
-		sp->checksum = truesize;
-
-	if ((rc = awe_open_dram_for_write(dram_offset, channels)) != 0)
-		return rc;
-
-	if (readbuf_init(addr, offset, sp) < 0)
-		return -ENOSPC;
-
-	for (i = 0; i < sp->size; i++) {
-		unsigned short c;
-		c = readbuf_word(i);
-		awe_write_dram(c);
-		if (i == sp->loopend &&
-		    (sp->mode_flags & (AWE_SAMPLE_BIDIR_LOOP|AWE_SAMPLE_REVERSE_LOOP))) {
-			int looplen = sp->loopend - sp->loopstart;
-			/* copy reverse loop */
-			int k;
-			for (k = 1; k <= looplen; k++) {
-				c = readbuf_word_cache(i - k);
-				awe_write_dram(c);
-			}
-			if (sp->mode_flags & AWE_SAMPLE_BIDIR_LOOP) {
-				sp->end += looplen;
-			} else {
-				sp->start += looplen;
-				sp->end += looplen;
-			}
-		}
-	}
-	readbuf_end();
-
-	/* if no blank loop is attached in the sample, add it */
-	if (sp->mode_flags & AWE_SAMPLE_NO_BLANK) {
-		for (i = 0; i < BLANK_LOOP_SIZE; i++)
-			awe_write_dram(0);
-		if (sp->mode_flags & AWE_SAMPLE_SINGLESHOT) {
-			sp->loopstart = sp->end + BLANK_LOOP_START;
-			sp->loopend = sp->end + BLANK_LOOP_END;
-		}
-	}
-
-	awe_close_dram();
-
-	/* initialize FM */
-	awe_init_fm();
-
-	return truesize;
-}
-
-
-/*----------------------------------------------------------------*/
-
-#ifdef AWE_HAS_GUS_COMPATIBILITY
-
-/* calculate GUS envelope time:
- * is this correct?  i have no idea..
- */
-static int
-calc_gus_envelope_time(int rate, int start, int end)
-{
-	int r, p, t;
-	r = (3 - ((rate >> 6) & 3)) * 3;
-	p = rate & 0x3f;
-	t = end - start;
-	if (t < 0) t = -t;
-	if (13 > r)
-		t = t << (13 - r);
-	else
-		t = t >> (r - 13);
-	return (t * 10) / (p * 441);
-}
-
-#define calc_gus_sustain(val)  (0x7f - vol_table[(val)/2])
-#define calc_gus_attenuation(val)	vol_table[(val)/2]
-
-/* load GUS patch */
-static int
-awe_load_guspatch(const char __user *addr, int offs, int size, int pmgr_flag)
-{
-	struct patch_info patch;
-	awe_voice_info *rec;
-	awe_sample_info *smp;
-	awe_voice_list *vrec;
-	awe_sample_list *smprec;
-	int sizeof_patch;
-	int note, rc;
-	sf_list *sf;
-
-	sizeof_patch = (int)((long)&patch.data[0] - (long)&patch); /* header size */
-	if (size < sizeof_patch) {
-		printk(KERN_WARNING "AWE32 Error: Patch header too short\n");
-		return -EINVAL;
-	}
-	if (copy_from_user(((char*)&patch) + offs, addr + offs, sizeof_patch - offs))
-		return -EFAULT;
-	size -= sizeof_patch;
-	if (size < patch.len) {
-		printk(KERN_WARNING "AWE32 Error: Patch record too short (%d<%d)\n",
-		       size, patch.len);
-		return -EINVAL;
-	}
-	if ((sf = check_patch_opened(AWE_PAT_TYPE_GUS, NULL)) == NULL)
-		return -ENOMEM;
-	if ((smprec = alloc_new_sample()) == NULL)
-		return -ENOMEM;
-	if ((vrec = alloc_new_info()) == NULL) {
-		kfree(smprec);
-		return -ENOMEM;
-	}
-
-	smp = &smprec->v;
-	smp->sample = sf->num_sample;
-	smp->start = 0;
-	smp->end = patch.len;
-	smp->loopstart = patch.loop_start;
-	smp->loopend = patch.loop_end;
-	smp->size = patch.len;
-
-	/* set up mode flags */
-	smp->mode_flags = 0;
-	if (!(patch.mode & WAVE_16_BITS))
-		smp->mode_flags |= AWE_SAMPLE_8BITS;
-	if (patch.mode & WAVE_UNSIGNED)
-		smp->mode_flags |= AWE_SAMPLE_UNSIGNED;
-	smp->mode_flags |= AWE_SAMPLE_NO_BLANK;
-	if (!(patch.mode & (WAVE_LOOPING|WAVE_BIDIR_LOOP|WAVE_LOOP_BACK)))
-		smp->mode_flags |= AWE_SAMPLE_SINGLESHOT;
-	if (patch.mode & WAVE_BIDIR_LOOP)
-		smp->mode_flags |= AWE_SAMPLE_BIDIR_LOOP;
-	if (patch.mode & WAVE_LOOP_BACK)
-		smp->mode_flags |= AWE_SAMPLE_REVERSE_LOOP;
-
-	DEBUG(0,printk("AWE32: [sample %d mode %x]\n", patch.instr_no, smp->mode_flags));
-	if (patch.mode & WAVE_16_BITS) {
-		/* convert to word offsets */
-		smp->size /= 2;
-		smp->end /= 2;
-		smp->loopstart /= 2;
-		smp->loopend /= 2;
-	}
-	smp->checksum_flag = 0;
-	smp->checksum = 0;
-
-	if ((rc = awe_write_wave_data(addr, sizeof_patch, smprec, -1)) < 0) {
-		kfree(vrec);
-		return rc;
-	}
-	sf->mem_ptr += rc;
-	add_sf_sample(sf, smprec);
-
-	/* set up voice info */
-	rec = &vrec->v;
-	awe_init_voice_info(rec);
-	rec->sample = sf->num_info; /* the last sample */
-	rec->rate_offset = calc_rate_offset(patch.base_freq);
-	note = freq_to_note(patch.base_note);
-	rec->root = note / 100;
-	rec->tune = -(note % 100);
-	rec->low = freq_to_note(patch.low_note) / 100;
-	rec->high = freq_to_note(patch.high_note) / 100;
-	DEBUG(1,printk("AWE32: [gus base offset=%d, note=%d, range=%d-%d(%d-%d)]\n",
-		       rec->rate_offset, note,
-		       rec->low, rec->high,
-	      patch.low_note, patch.high_note));
-	/* panning position; -128 - 127 => 0-127 */
-	rec->pan = (patch.panning + 128) / 2;
-
-	/* detuning is ignored */
-	/* 6points volume envelope */
-	if (patch.mode & WAVE_ENVELOPES) {
-		int attack, hold, decay, release;
-		attack = calc_gus_envelope_time
-			(patch.env_rate[0], 0, patch.env_offset[0]);
-		hold = calc_gus_envelope_time
-			(patch.env_rate[1], patch.env_offset[0],
-			 patch.env_offset[1]);
-		decay = calc_gus_envelope_time
-			(patch.env_rate[2], patch.env_offset[1],
-			 patch.env_offset[2]);
-		release = calc_gus_envelope_time
-			(patch.env_rate[3], patch.env_offset[1],
-			 patch.env_offset[4]);
-		release += calc_gus_envelope_time
-			(patch.env_rate[4], patch.env_offset[3],
-			 patch.env_offset[4]);
-		release += calc_gus_envelope_time
-			(patch.env_rate[5], patch.env_offset[4],
-			 patch.env_offset[5]);
-		rec->parm.volatkhld = (calc_parm_hold(hold) << 8) |
-			calc_parm_attack(attack);
-		rec->parm.voldcysus = (calc_gus_sustain(patch.env_offset[2]) << 8) |
-			calc_parm_decay(decay);
-		rec->parm.volrelease = 0x8000 | calc_parm_decay(release);
-		DEBUG(2,printk("AWE32: [gusenv atk=%d, hld=%d, dcy=%d, rel=%d]\n", attack, hold, decay, release));
-		rec->attenuation = calc_gus_attenuation(patch.env_offset[0]);
-	}
-
-	/* tremolo effect */
-	if (patch.mode & WAVE_TREMOLO) {
-		int rate = (patch.tremolo_rate * 1000 / 38) / 42;
-		rec->parm.tremfrq = ((patch.tremolo_depth / 2) << 8) | rate;
-		DEBUG(2,printk("AWE32: [gusenv tremolo rate=%d, dep=%d, tremfrq=%x]\n",
-			       patch.tremolo_rate, patch.tremolo_depth,
-			       rec->parm.tremfrq));
-	}
-	/* vibrato effect */
-	if (patch.mode & WAVE_VIBRATO) {
-		int rate = (patch.vibrato_rate * 1000 / 38) / 42;
-		rec->parm.fm2frq2 = ((patch.vibrato_depth / 6) << 8) | rate;
-		DEBUG(2,printk("AWE32: [gusenv vibrato rate=%d, dep=%d, tremfrq=%x]\n",
-			       patch.tremolo_rate, patch.tremolo_depth,
-			       rec->parm.tremfrq));
-	}
-	
-	/* scale_freq, scale_factor, volume, and fractions not implemented */
-
-	/* append to the tail of the list */
-	vrec->bank = ctrls[AWE_MD_GUS_BANK];
-	vrec->instr = patch.instr_no;
-	vrec->disabled = FALSE;
-	vrec->type = V_ST_NORMAL;
-
-	add_sf_info(sf, vrec);
-	add_info_list(vrec);
-
-	/* set the voice index */
-	awe_set_sample(vrec);
-
-	return 0;
-}
-
-#endif  /* AWE_HAS_GUS_COMPATIBILITY */
-
-/*
- * sample and voice list handlers
- */
-
-/* append this to the current sf list */
-static void add_sf_info(sf_list *sf, awe_voice_list *rec)
-{
-	if (sf == NULL)
-		return;
-	rec->holder = sf;
-	rec->v.sf_id = sf->sf_id;
-	if (sf->last_infos)
-		sf->last_infos->next = rec;
-	else
-		sf->infos = rec;
-	sf->last_infos = rec;
-	rec->next = NULL;
-	sf->num_info++;
-}
-
-/* prepend this sample to sf list */
-static void add_sf_sample(sf_list *sf, awe_sample_list *rec)
-{
-	if (sf == NULL)
-		return;
-	rec->holder = sf;
-	rec->v.sf_id = sf->sf_id;
-	if (sf->last_samples)
-		sf->last_samples->next = rec;
-	else
-		sf->samples = rec;
-	sf->last_samples = rec;
-	rec->next = NULL;
-	sf->num_sample++;
-}
-
-/* purge the old records which don't belong with the same file id */
-static void purge_old_list(awe_voice_list *rec, awe_voice_list *next)
-{
-	rec->next_instr = next;
-	if (rec->bank == AWE_DRUM_BANK) {
-		/* remove samples with the same note range */
-		awe_voice_list *cur, *prev = rec;
-		int low = rec->v.low;
-		int high = rec->v.high;
-		for (cur = next; cur; cur = cur->next_instr) {
-			if (cur->v.low == low &&
-			    cur->v.high == high &&
-			    ! is_identical_holder(cur->holder, rec->holder))
-				prev->next_instr = cur->next_instr;
-			else
-				prev = cur;
-		}
-	} else {
-		if (! is_identical_holder(next->holder, rec->holder))
-			/* remove all samples */
-			rec->next_instr = NULL;
-	}
-}
-
-/* prepend to top of the preset table */
-static void add_info_list(awe_voice_list *rec)
-{
-	awe_voice_list *prev, *cur;
-	int key;
-
-	if (rec->disabled)
-		return;
-
-	key = awe_search_key(rec->bank, rec->instr, rec->v.low);
-	prev = NULL;
-	for (cur = preset_table[key]; cur; cur = cur->next_bank) {
-		/* search the first record with the same bank number */
-		if (cur->instr == rec->instr && cur->bank == rec->bank) {
-			/* replace the list with the new record */
-			rec->next_bank = cur->next_bank;
-			if (prev)
-				prev->next_bank = rec;
-			else
-				preset_table[key] = rec;
-			purge_old_list(rec, cur);
-			return;
-		}
-		prev = cur;
-	}
-
-	/* this is the first bank record.. just add this */
-	rec->next_instr = NULL;
-	rec->next_bank = preset_table[key];
-	preset_table[key] = rec;
-}
-
-/* remove samples later than the specified sf_id */
-static void
-awe_remove_samples(int sf_id)
-{
-	sf_list *p, *prev;
-
-	if (sf_id <= 0) {
-		awe_reset_samples();
-		return;
-	}
-	/* already removed? */
-	if (current_sf_id <= sf_id)
-		return;
-
-	for (p = sftail; p; p = prev) {
-		if (p->sf_id <= sf_id)
-			break;
-		prev = p->prev;
-		awe_free_sf(p);
-	}
-	sftail = p;
-	if (sftail) {
-		sf_id = sftail->sf_id;
-		sftail->next = NULL;
-	} else {
-		sf_id = 0;
-		sfhead = NULL;
-	}
-	current_sf_id = sf_id;
-	if (locked_sf_id > sf_id)
-		locked_sf_id = sf_id;
-
-	rebuild_preset_list();
-}
-
-/* rebuild preset search list */
-static void rebuild_preset_list(void)
-{
-	sf_list *p;
-	awe_voice_list *rec;
-
-	memset(preset_table, 0, sizeof(preset_table));
-
-	for (p = sfhead; p; p = p->next) {
-		for (rec = p->infos; rec; rec = rec->next)
-			add_info_list(rec);
-	}
-}
-
-/* compare the given sf_id pair */
-static int is_identical_holder(sf_list *sf1, sf_list *sf2)
-{
-	if (sf1 == NULL || sf2 == NULL)
-		return FALSE;
-	if (sf1 == sf2)
-		return TRUE;
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	{
-		/* compare with the sharing id */
-		sf_list *p;
-		int counter = 0;
-		if (sf1->sf_id < sf2->sf_id) { /* make sure id1 > id2 */
-			sf_list *tmp; tmp = sf1; sf1 = sf2; sf2 = tmp;
-		}
-		for (p = sf1->shared; p; p = p->shared) {
-			if (counter++ > current_sf_id)
-				break; /* strange sharing loop.. quit */
-			if (p == sf2)
-				return TRUE;
-		}
-	}
-#endif /* allow sharing */
-	return FALSE;
-}
-
-/* search the sample index matching with the given sample id */
-static awe_sample_list *
-search_sample_index(sf_list *sf, int sample)
-{
-	awe_sample_list *p;
-#ifdef AWE_ALLOW_SAMPLE_SHARING
-	int counter = 0;
-	while (sf) {
-		for (p = sf->samples; p; p = p->next) {
-			if (p->v.sample == sample)
-				return p;
-		}
-		sf = sf->shared;
-		if (counter++ > current_sf_id)
-			break; /* strange sharing loop.. quit */
-	}
-#else
-	if (sf) {
-		for (p = sf->samples; p; p = p->next) {
-			if (p->v.sample == sample)
-				return p;
-		}
-	}
-#endif
-	return NULL;
-}
-
-/* search the specified sample */
-/* non-zero = found */
-static short
-awe_set_sample(awe_voice_list *rec)
-{
-	awe_sample_list *smp;
-	awe_voice_info *vp = &rec->v;
-
-	vp->index = 0;
-	if ((smp = search_sample_index(rec->holder, vp->sample)) == NULL)
-		return 0;
-
-	/* set the actual sample offsets */
-	vp->start += smp->v.start;
-	vp->end += smp->v.end;
-	vp->loopstart += smp->v.loopstart;
-	vp->loopend += smp->v.loopend;
-	/* copy mode flags */
-	vp->mode = smp->v.mode_flags;
-	/* set flag */
-	vp->index = 1;
-
-	return 1;
-}
-
-
-/*
- * voice allocation
- */
-
-/* look for all voices associated with the specified note & velocity */
-static int
-awe_search_multi_voices(awe_voice_list *rec, int note, int velocity,
-			awe_voice_info **vlist)
-{
-	int nvoices;
-
-	nvoices = 0;
-	for (; rec; rec = rec->next_instr) {
-		if (note >= rec->v.low &&
-		    note <= rec->v.high &&
-		    velocity >= rec->v.vellow &&
-		    velocity <= rec->v.velhigh) {
-			if (rec->type == V_ST_MAPPED) {
-				/* mapper */
-				vlist[0] = &rec->v;
-				return -1;
-			}
-			vlist[nvoices++] = &rec->v;
-			if (nvoices >= AWE_MAX_VOICES)
-				break;
-		}
-	}
-	return nvoices;	
-}
-
-/* store the voice list from the specified note and velocity.
-   if the preset is mapped, seek for the destination preset, and rewrite
-   the note number if necessary.
-   */
-static int
-really_alloc_voices(int bank, int instr, int *note, int velocity, awe_voice_info **vlist)
-{
-	int nvoices;
-	awe_voice_list *vrec;
-	int level = 0;
-
-	for (;;) {
-		vrec = awe_search_instr(bank, instr, *note);
-		nvoices = awe_search_multi_voices(vrec, *note, velocity, vlist);
-		if (nvoices == 0) {
-			if (bank == AWE_DRUM_BANK)
-				/* search default drumset */
-				vrec = awe_search_instr(bank, ctrls[AWE_MD_DEF_DRUM], *note);
-			else
-				/* search default preset */
-				vrec = awe_search_instr(ctrls[AWE_MD_DEF_BANK], instr, *note);
-			nvoices = awe_search_multi_voices(vrec, *note, velocity, vlist);
-		}
-		if (nvoices == 0) {
-			if (bank == AWE_DRUM_BANK && ctrls[AWE_MD_DEF_DRUM] != 0)
-				/* search default drumset */
-				vrec = awe_search_instr(bank, 0, *note);
-			else if (bank != AWE_DRUM_BANK && ctrls[AWE_MD_DEF_BANK] != 0)
-				/* search default preset */
-				vrec = awe_search_instr(0, instr, *note);
-			nvoices = awe_search_multi_voices(vrec, *note, velocity, vlist);
-		}
-		if (nvoices < 0) { /* mapping */
-			int key = vlist[0]->fixkey;
-			instr = vlist[0]->start;
-			bank = vlist[0]->end;
-			if (level++ > 5) {
-				printk(KERN_ERR "AWE32: too deep mapping level\n");
-				return 0;
-			}
-			if (key >= 0)
-				*note = key;
-		} else
-			break;
-	}
-
-	return nvoices;
-}
-
-/* allocate voices corresponding note and velocity; supports multiple insts. */
-static void
-awe_alloc_multi_voices(int ch, int note, int velocity, int key)
-{
-	int i, v, nvoices, bank;
-	awe_voice_info *vlist[AWE_MAX_VOICES];
-
-	if (MULTI_LAYER_MODE() && IS_DRUM_CHANNEL(ch))
-		bank = AWE_DRUM_BANK; /* always search drumset */
-	else
-		bank = channels[ch].bank;
-
-	/* check the possible voices; note may be changeable if mapped */
-	nvoices = really_alloc_voices(bank, channels[ch].instr,
-				      &note, velocity, vlist);
-
-	/* set the voices */
-	current_alloc_time++;
-	for (i = 0; i < nvoices; i++) {
-		v = awe_clear_voice();
-		voices[v].key = key;
-		voices[v].ch = ch;
-		voices[v].note = note;
-		voices[v].velocity = velocity;
-		voices[v].time = current_alloc_time;
-		voices[v].cinfo = &channels[ch];
-		voices[v].sample = vlist[i];
-		voices[v].state = AWE_ST_MARK;
-		voices[v].layer = nvoices - i - 1;  /* in reverse order */
-	}
-
-	/* clear the mark in allocated voices */
-	for (i = 0; i < awe_max_voices; i++) {
-		if (voices[i].state == AWE_ST_MARK)
-			voices[i].state = AWE_ST_OFF;
-			
-	}
-}
-
-
-/* search an empty voice.
-   if no empty voice is found, at least terminate a voice
-   */
-static int
-awe_clear_voice(void)
-{
-	enum {
-		OFF=0, RELEASED, SUSTAINED, PLAYING, END
-	};
-	struct voice_candidate_t {
-		int best;
-		int time;
-		int vtarget;
-	} candidate[END];
-	int i, type, vtarget;
-
-	vtarget = 0xffff;
-	for (type = OFF; type < END; type++) {
-		candidate[type].best = -1;
-		candidate[type].time = current_alloc_time + 1;
-		candidate[type].vtarget = vtarget;
-	}
-
-	for (i = 0; i < awe_max_voices; i++) {
-		if (voices[i].state & AWE_ST_OFF)
-			type = OFF;
-		else if (voices[i].state & AWE_ST_RELEASED)
-			type = RELEASED;
-		else if (voices[i].state & AWE_ST_SUSTAINED)
-			type = SUSTAINED;
-		else if (voices[i].state & ~AWE_ST_MARK)
-			type = PLAYING;
-		else
-			continue;
-#ifdef AWE_CHECK_VTARGET
-		/* get current volume */
-		vtarget = (awe_peek_dw(AWE_VTFT(i)) >> 16) & 0xffff;
-#endif
-		if (candidate[type].best < 0 ||
-		    vtarget < candidate[type].vtarget ||
-		    (vtarget == candidate[type].vtarget &&
-		     voices[i].time < candidate[type].time)) {
-			candidate[type].best = i;
-			candidate[type].time = voices[i].time;
-			candidate[type].vtarget = vtarget;
-		}
-	}
-
-	for (type = OFF; type < END; type++) {
-		if ((i = candidate[type].best) >= 0) {
-			if (voices[i].state != AWE_ST_OFF)
-				awe_terminate(i);
-			awe_voice_init(i, TRUE);
-			return i;
-		}
-	}
-	return 0;
-}
-
-
-/* search sample for the specified note & velocity and set it on the voice;
- * note that voice is the voice index (not channel index)
- */
-static void
-awe_alloc_one_voice(int voice, int note, int velocity)
-{
-	int ch, nvoices, bank;
-	awe_voice_info *vlist[AWE_MAX_VOICES];
-
-	ch = voices[voice].ch;
-	if (MULTI_LAYER_MODE() && IS_DRUM_CHANNEL(voice))
-		bank = AWE_DRUM_BANK; /* always search drumset */
-	else
-		bank = voices[voice].cinfo->bank;
-
-	nvoices = really_alloc_voices(bank, voices[voice].cinfo->instr,
-				      &note, velocity, vlist);
-	if (nvoices > 0) {
-		voices[voice].time = ++current_alloc_time;
-		voices[voice].sample = vlist[0]; /* use the first one */
-		voices[voice].layer = 0;
-		voices[voice].note = note;
-		voices[voice].velocity = velocity;
-	}
-}
-
-
-/*
- * sequencer2 functions
- */
-
-/* search an empty voice; used by sequencer2 */
-static int
-awe_alloc(int dev, int chn, int note, struct voice_alloc_info *alloc)
-{
-	playing_mode = AWE_PLAY_MULTI2;
-	awe_info.nr_voices = AWE_MAX_CHANNELS;
-	return awe_clear_voice();
-}
-
-
-/* set up voice; used by sequencer2 */
-static void
-awe_setup_voice(int dev, int voice, int chn)
-{
-	struct channel_info *info;
-	if (synth_devs[dev] == NULL ||
-	    (info = &synth_devs[dev]->chn_info[chn]) == NULL)
-		return;
-
-	if (voice < 0 || voice >= awe_max_voices)
-		return;
-
-	DEBUG(2,printk("AWE32: [setup(%d) ch=%d]\n", voice, chn));
-	channels[chn].expression_vol = info->controllers[CTL_EXPRESSION];
-	channels[chn].main_vol = info->controllers[CTL_MAIN_VOLUME];
-	channels[chn].panning =
-		info->controllers[CTL_PAN] * 2 - 128; /* signed 8bit */
-	channels[chn].bender = info->bender_value; /* zero center */
-	channels[chn].bank = info->controllers[CTL_BANK_SELECT];
-	channels[chn].sustained = info->controllers[CTL_SUSTAIN];
-	if (info->controllers[CTL_EXT_EFF_DEPTH]) {
-		FX_SET(&channels[chn].fx, AWE_FX_REVERB,
-		       info->controllers[CTL_EXT_EFF_DEPTH] * 2);
-	}
-	if (info->controllers[CTL_CHORUS_DEPTH]) {
-		FX_SET(&channels[chn].fx, AWE_FX_CHORUS,
-		       info->controllers[CTL_CHORUS_DEPTH] * 2);
-	}
-	awe_set_instr(dev, chn, info->pgm_num);
-}
-
-
-#ifdef CONFIG_AWE32_MIXER
-/*
- * AWE32 mixer device control
- */
-
-static int awe_mixer_ioctl(int dev, unsigned int cmd, void __user *arg);
-
-static int my_mixerdev = -1;
-
-static struct mixer_operations awe_mixer_operations = {
-	.owner	= THIS_MODULE,
-	.id	= "AWE",
-	.name	= "AWE32 Equalizer",
-	.ioctl	= awe_mixer_ioctl,
-};
-
-static void __init attach_mixer(void)
-{
-	if ((my_mixerdev = sound_alloc_mixerdev()) >= 0) {
-		mixer_devs[my_mixerdev] = &awe_mixer_operations;
-	}
-}
-
-static void unload_mixer(void)
-{
-	if (my_mixerdev >= 0)
-		sound_unload_mixerdev(my_mixerdev);
-}
-
-static int
-awe_mixer_ioctl(int dev, unsigned int cmd, void __user * arg)
-{
-	int i, level, value;
-
-	if (((cmd >> 8) & 0xff) != 'M')
-		return -EINVAL;
-
-	if (get_user(level, (int __user *)arg))
-		return -EFAULT;
-	level = ((level & 0xff) + (level >> 8)) / 2;
-	DEBUG(0,printk("AWEMix: cmd=%x val=%d\n", cmd & 0xff, level));
-
-	if (_SIOC_DIR(cmd) & _SIOC_WRITE) {
-		switch (cmd & 0xff) {
-		case SOUND_MIXER_BASS:
-			value = level * 12 / 100;
-			if (value >= 12)
-				value = 11;
-			ctrls[AWE_MD_BASS_LEVEL] = value;
-			awe_update_equalizer();
-			break;
-		case SOUND_MIXER_TREBLE:
-			value = level * 12 / 100;
-			if (value >= 12)
-				value = 11;
-			ctrls[AWE_MD_TREBLE_LEVEL] = value;
-			awe_update_equalizer();
-			break;
-		case SOUND_MIXER_VOLUME:
-			level = level * 127 / 100;
-			if (level >= 128) level = 127;
-			atten_relative = FALSE;
-			atten_offset = vol_table[level];
-			awe_update_volume();
-			break;
-		}
-	}
-	switch (cmd & 0xff) {
-	case SOUND_MIXER_BASS:
-		level = ctrls[AWE_MD_BASS_LEVEL] * 100 / 24;
-		level = (level << 8) | level;
-		break;
-	case SOUND_MIXER_TREBLE:
-		level = ctrls[AWE_MD_TREBLE_LEVEL] * 100 / 24;
-		level = (level << 8) | level;
-		break;
-	case SOUND_MIXER_VOLUME:
-		value = atten_offset;
-		if (atten_relative)
-			value += ctrls[AWE_MD_ZERO_ATTEN];
-		for (i = 127; i > 0; i--) {
-			if (value <= vol_table[i])
-				break;
-		}
-		level = i * 100 / 127;
-		level = (level << 8) | level;
-		break;
-	case SOUND_MIXER_DEVMASK:
-		level = SOUND_MASK_BASS|SOUND_MASK_TREBLE|SOUND_MASK_VOLUME;
-		break;
-	default:
-		level = 0;
-		break;
-	}
-	if (put_user(level, (int __user *)arg))
-		return -EFAULT;
-	return level;
-}
-#endif /* CONFIG_AWE32_MIXER */
-
-
-/*
- * initialization of Emu8000
- */
-
-/* intiailize audio channels */
-static void
-awe_init_audio(void)
-{
-	int ch;
-
-	/* turn off envelope engines */
-	for (ch = 0; ch < AWE_MAX_VOICES; ch++) {
-		awe_poke(AWE_DCYSUSV(ch), 0x80);
-	}
-  
-	/* reset all other parameters to zero */
-	for (ch = 0; ch < AWE_MAX_VOICES; ch++) {
-		awe_poke(AWE_ENVVOL(ch), 0);
-		awe_poke(AWE_ENVVAL(ch), 0);
-		awe_poke(AWE_DCYSUS(ch), 0);
-		awe_poke(AWE_ATKHLDV(ch), 0);
-		awe_poke(AWE_LFO1VAL(ch), 0);
-		awe_poke(AWE_ATKHLD(ch), 0);
-		awe_poke(AWE_LFO2VAL(ch), 0);
-		awe_poke(AWE_IP(ch), 0);
-		awe_poke(AWE_IFATN(ch), 0);
-		awe_poke(AWE_PEFE(ch), 0);
-		awe_poke(AWE_FMMOD(ch), 0);
-		awe_poke(AWE_TREMFRQ(ch), 0);
-		awe_poke(AWE_FM2FRQ2(ch), 0);
-		awe_poke_dw(AWE_PTRX(ch), 0);
-		awe_poke_dw(AWE_VTFT(ch), 0);
-		awe_poke_dw(AWE_PSST(ch), 0);
-		awe_poke_dw(AWE_CSL(ch), 0);
-		awe_poke_dw(AWE_CCCA(ch), 0);
-	}
-
-	for (ch = 0; ch < AWE_MAX_VOICES; ch++) {
-		awe_poke_dw(AWE_CPF(ch), 0);
-		awe_poke_dw(AWE_CVCF(ch), 0);
-	}
-}
-
-
-/* initialize DMA address */
-static void
-awe_init_dma(void)
-{
-	awe_poke_dw(AWE_SMALR, 0);
-	awe_poke_dw(AWE_SMARR, 0);
-	awe_poke_dw(AWE_SMALW, 0);
-	awe_poke_dw(AWE_SMARW, 0);
-}
-
-
-/* initialization arrays; from ADIP */
-
-static unsigned short init1[128] = {
-	0x03ff, 0x0030,  0x07ff, 0x0130, 0x0bff, 0x0230,  0x0fff, 0x0330,
-	0x13ff, 0x0430,  0x17ff, 0x0530, 0x1bff, 0x0630,  0x1fff, 0x0730,
-	0x23ff, 0x0830,  0x27ff, 0x0930, 0x2bff, 0x0a30,  0x2fff, 0x0b30,
-	0x33ff, 0x0c30,  0x37ff, 0x0d30, 0x3bff, 0x0e30,  0x3fff, 0x0f30,
-
-	0x43ff, 0x0030,  0x47ff, 0x0130, 0x4bff, 0x0230,  0x4fff, 0x0330,
-	0x53ff, 0x0430,  0x57ff, 0x0530, 0x5bff, 0x0630,  0x5fff, 0x0730,
-	0x63ff, 0x0830,  0x67ff, 0x0930, 0x6bff, 0x0a30,  0x6fff, 0x0b30,
-	0x73ff, 0x0c30,  0x77ff, 0x0d30, 0x7bff, 0x0e30,  0x7fff, 0x0f30,
-
-	0x83ff, 0x0030,  0x87ff, 0x0130, 0x8bff, 0x0230,  0x8fff, 0x0330,
-	0x93ff, 0x0430,  0x97ff, 0x0530, 0x9bff, 0x0630,  0x9fff, 0x0730,
-	0xa3ff, 0x0830,  0xa7ff, 0x0930, 0xabff, 0x0a30,  0xafff, 0x0b30,
-	0xb3ff, 0x0c30,  0xb7ff, 0x0d30, 0xbbff, 0x0e30,  0xbfff, 0x0f30,
-
-	0xc3ff, 0x0030,  0xc7ff, 0x0130, 0xcbff, 0x0230,  0xcfff, 0x0330,
-	0xd3ff, 0x0430,  0xd7ff, 0x0530, 0xdbff, 0x0630,  0xdfff, 0x0730,
-	0xe3ff, 0x0830,  0xe7ff, 0x0930, 0xebff, 0x0a30,  0xefff, 0x0b30,
-	0xf3ff, 0x0c30,  0xf7ff, 0x0d30, 0xfbff, 0x0e30,  0xffff, 0x0f30,
-};
-
-static unsigned short init2[128] = {
-	0x03ff, 0x8030, 0x07ff, 0x8130, 0x0bff, 0x8230, 0x0fff, 0x8330,
-	0x13ff, 0x8430, 0x17ff, 0x8530, 0x1bff, 0x8630, 0x1fff, 0x8730,
-	0x23ff, 0x8830, 0x27ff, 0x8930, 0x2bff, 0x8a30, 0x2fff, 0x8b30,
-	0x33ff, 0x8c30, 0x37ff, 0x8d30, 0x3bff, 0x8e30, 0x3fff, 0x8f30,
-
-	0x43ff, 0x8030, 0x47ff, 0x8130, 0x4bff, 0x8230, 0x4fff, 0x8330,
-	0x53ff, 0x8430, 0x57ff, 0x8530, 0x5bff, 0x8630, 0x5fff, 0x8730,
-	0x63ff, 0x8830, 0x67ff, 0x8930, 0x6bff, 0x8a30, 0x6fff, 0x8b30,
-	0x73ff, 0x8c30, 0x77ff, 0x8d30, 0x7bff, 0x8e30, 0x7fff, 0x8f30,
-
-	0x83ff, 0x8030, 0x87ff, 0x8130, 0x8bff, 0x8230, 0x8fff, 0x8330,
-	0x93ff, 0x8430, 0x97ff, 0x8530, 0x9bff, 0x8630, 0x9fff, 0x8730,
-	0xa3ff, 0x8830, 0xa7ff, 0x8930, 0xabff, 0x8a30, 0xafff, 0x8b30,
-	0xb3ff, 0x8c30, 0xb7ff, 0x8d30, 0xbbff, 0x8e30, 0xbfff, 0x8f30,
-
-	0xc3ff, 0x8030, 0xc7ff, 0x8130, 0xcbff, 0x8230, 0xcfff, 0x8330,
-	0xd3ff, 0x8430, 0xd7ff, 0x8530, 0xdbff, 0x8630, 0xdfff, 0x8730,
-	0xe3ff, 0x8830, 0xe7ff, 0x8930, 0xebff, 0x8a30, 0xefff, 0x8b30,
-	0xf3ff, 0x8c30, 0xf7ff, 0x8d30, 0xfbff, 0x8e30, 0xffff, 0x8f30,
-};
-
-static unsigned short init3[128] = {
-	0x0C10, 0x8470, 0x14FE, 0xB488, 0x167F, 0xA470, 0x18E7, 0x84B5,
-	0x1B6E, 0x842A, 0x1F1D, 0x852A, 0x0DA3, 0x8F7C, 0x167E, 0xF254,
-	0x0000, 0x842A, 0x0001, 0x852A, 0x18E6, 0x8BAA, 0x1B6D, 0xF234,
-	0x229F, 0x8429, 0x2746, 0x8529, 0x1F1C, 0x86E7, 0x229E, 0xF224,
-
-	0x0DA4, 0x8429, 0x2C29, 0x8529, 0x2745, 0x87F6, 0x2C28, 0xF254,
-	0x383B, 0x8428, 0x320F, 0x8528, 0x320E, 0x8F02, 0x1341, 0xF264,
-	0x3EB6, 0x8428, 0x3EB9, 0x8528, 0x383A, 0x8FA9, 0x3EB5, 0xF294,
-	0x3EB7, 0x8474, 0x3EBA, 0x8575, 0x3EB8, 0xC4C3, 0x3EBB, 0xC5C3,
-
-	0x0000, 0xA404, 0x0001, 0xA504, 0x141F, 0x8671, 0x14FD, 0x8287,
-	0x3EBC, 0xE610, 0x3EC8, 0x8C7B, 0x031A, 0x87E6, 0x3EC8, 0x86F7,
-	0x3EC0, 0x821E, 0x3EBE, 0xD208, 0x3EBD, 0x821F, 0x3ECA, 0x8386,
-	0x3EC1, 0x8C03, 0x3EC9, 0x831E, 0x3ECA, 0x8C4C, 0x3EBF, 0x8C55,
-
-	0x3EC9, 0xC208, 0x3EC4, 0xBC84, 0x3EC8, 0x8EAD, 0x3EC8, 0xD308,
-	0x3EC2, 0x8F7E, 0x3ECB, 0x8219, 0x3ECB, 0xD26E, 0x3EC5, 0x831F,
-	0x3EC6, 0xC308, 0x3EC3, 0xB2FF, 0x3EC9, 0x8265, 0x3EC9, 0x8319,
-	0x1342, 0xD36E, 0x3EC7, 0xB3FF, 0x0000, 0x8365, 0x1420, 0x9570,
-};
-
-static unsigned short init4[128] = {
-	0x0C10, 0x8470, 0x14FE, 0xB488, 0x167F, 0xA470, 0x18E7, 0x84B5,
-	0x1B6E, 0x842A, 0x1F1D, 0x852A, 0x0DA3, 0x0F7C, 0x167E, 0x7254,
-	0x0000, 0x842A, 0x0001, 0x852A, 0x18E6, 0x0BAA, 0x1B6D, 0x7234,
-	0x229F, 0x8429, 0x2746, 0x8529, 0x1F1C, 0x06E7, 0x229E, 0x7224,
-
-	0x0DA4, 0x8429, 0x2C29, 0x8529, 0x2745, 0x07F6, 0x2C28, 0x7254,
-	0x383B, 0x8428, 0x320F, 0x8528, 0x320E, 0x0F02, 0x1341, 0x7264,
-	0x3EB6, 0x8428, 0x3EB9, 0x8528, 0x383A, 0x0FA9, 0x3EB5, 0x7294,
-	0x3EB7, 0x8474, 0x3EBA, 0x8575, 0x3EB8, 0x44C3, 0x3EBB, 0x45C3,
-
-	0x0000, 0xA404, 0x0001, 0xA504, 0x141F, 0x0671, 0x14FD, 0x0287,
-	0x3EBC, 0xE610, 0x3EC8, 0x0C7B, 0x031A, 0x07E6, 0x3EC8, 0x86F7,
-	0x3EC0, 0x821E, 0x3EBE, 0xD208, 0x3EBD, 0x021F, 0x3ECA, 0x0386,
-	0x3EC1, 0x0C03, 0x3EC9, 0x031E, 0x3ECA, 0x8C4C, 0x3EBF, 0x0C55,
-
-	0x3EC9, 0xC208, 0x3EC4, 0xBC84, 0x3EC8, 0x0EAD, 0x3EC8, 0xD308,
-	0x3EC2, 0x8F7E, 0x3ECB, 0x0219, 0x3ECB, 0xD26E, 0x3EC5, 0x031F,
-	0x3EC6, 0xC308, 0x3EC3, 0x32FF, 0x3EC9, 0x0265, 0x3EC9, 0x8319,
-	0x1342, 0xD36E, 0x3EC7, 0x33FF, 0x0000, 0x8365, 0x1420, 0x9570,
-};
-
-
-/* send initialization arrays to start up */
-static void
-awe_init_array(void)
-{
-	awe_send_array(init1);
-	awe_wait(1024);
-	awe_send_array(init2);
-	awe_send_array(init3);
-	awe_poke_dw(AWE_HWCF4, 0);
-	awe_poke_dw(AWE_HWCF5, 0x83);
-	awe_poke_dw(AWE_HWCF6, 0x8000);
-	awe_send_array(init4);
-}
-
-/* send an initialization array */
-static void
-awe_send_array(unsigned short *data)
-{
-	int i;
-	unsigned short *p;
-
-	p = data;
-	for (i = 0; i < AWE_MAX_VOICES; i++, p++)
-		awe_poke(AWE_INIT1(i), *p);
-	for (i = 0; i < AWE_MAX_VOICES; i++, p++)
-		awe_poke(AWE_INIT2(i), *p);
-	for (i = 0; i < AWE_MAX_VOICES; i++, p++)
-		awe_poke(AWE_INIT3(i), *p);
-	for (i = 0; i < AWE_MAX_VOICES; i++, p++)
-		awe_poke(AWE_INIT4(i), *p);
-}
-
-
-/*
- * set up awe32 channels to some known state.
- */
-
-/* set the envelope & LFO parameters to the default values; see ADIP */
-static void
-awe_tweak_voice(int i)
-{
-	/* set all mod/vol envelope shape to minimum */
-	awe_poke(AWE_ENVVOL(i), 0x8000);
-	awe_poke(AWE_ENVVAL(i), 0x8000);
-	awe_poke(AWE_DCYSUS(i), 0x7F7F);
-	awe_poke(AWE_ATKHLDV(i), 0x7F7F);
-	awe_poke(AWE_ATKHLD(i), 0x7F7F);
-	awe_poke(AWE_PEFE(i), 0);  /* mod envelope height to zero */
-	awe_poke(AWE_LFO1VAL(i), 0x8000); /* no delay for LFO1 */
-	awe_poke(AWE_LFO2VAL(i), 0x8000);
-	awe_poke(AWE_IP(i), 0xE000);	/* no pitch shift */
-	awe_poke(AWE_IFATN(i), 0xFF00);	/* volume to minimum */
-	awe_poke(AWE_FMMOD(i), 0);
-	awe_poke(AWE_TREMFRQ(i), 0);
-	awe_poke(AWE_FM2FRQ2(i), 0);
-}
-
-static void
-awe_tweak(void)
-{
-	int i;
-	/* reset all channels */
-	for (i = 0; i < awe_max_voices; i++)
-		awe_tweak_voice(i);
-}
-
-
-/*
- *  initializes the FM section of AWE32;
- *   see Vince Vu's unofficial AWE32 programming guide
- */
-
-static void
-awe_init_fm(void)
-{
-#ifndef AWE_ALWAYS_INIT_FM
-	/* if no extended memory is on board.. */
-	if (memsize <= 0)
-		return;
-#endif
-	DEBUG(3,printk("AWE32: initializing FM\n"));
-
-	/* Initialize the last two channels for DRAM refresh and producing
-	   the reverb and chorus effects for Yamaha OPL-3 synthesizer */
-
-	/* 31: FM left channel, 0xffffe0-0xffffe8 */
-	awe_poke(AWE_DCYSUSV(30), 0x80);
-	awe_poke_dw(AWE_PSST(30), 0xFFFFFFE0); /* full left */
-	awe_poke_dw(AWE_CSL(30), 0x00FFFFE8 |
-		    (DEF_FM_CHORUS_DEPTH << 24));
-	awe_poke_dw(AWE_PTRX(30), (DEF_FM_REVERB_DEPTH << 8));
-	awe_poke_dw(AWE_CPF(30), 0);
-	awe_poke_dw(AWE_CCCA(30), 0x00FFFFE3);
-
-	/* 32: FM right channel, 0xfffff0-0xfffff8 */
-	awe_poke(AWE_DCYSUSV(31), 0x80);
-	awe_poke_dw(AWE_PSST(31), 0x00FFFFF0); /* full right */
-	awe_poke_dw(AWE_CSL(31), 0x00FFFFF8 |
-		    (DEF_FM_CHORUS_DEPTH << 24));
-	awe_poke_dw(AWE_PTRX(31), (DEF_FM_REVERB_DEPTH << 8));
-	awe_poke_dw(AWE_CPF(31), 0x8000);
-	awe_poke_dw(AWE_CCCA(31), 0x00FFFFF3);
-
-	/* skew volume & cutoff */
-	awe_poke_dw(AWE_VTFT(30), 0x8000FFFF);
-	awe_poke_dw(AWE_VTFT(31), 0x8000FFFF);
-
-	voices[30].state = AWE_ST_FM;
-	voices[31].state = AWE_ST_FM;
-
-	/* change maximum channels to 30 */
-	awe_max_voices = AWE_NORMAL_VOICES;
-	if (playing_mode == AWE_PLAY_DIRECT)
-		awe_info.nr_voices = awe_max_voices;
-	else
-		awe_info.nr_voices = AWE_MAX_CHANNELS;
-	voice_alloc->max_voice = awe_max_voices;
-}
-
-/*
- *  AWE32 DRAM access routines
- */
-
-/* open DRAM write accessing mode */
-static int
-awe_open_dram_for_write(int offset, int channels)
-{
-	int vidx[AWE_NORMAL_VOICES];
-	int i;
-
-	if (channels < 0 || channels >= AWE_NORMAL_VOICES) {
-		channels = AWE_NORMAL_VOICES;
-		for (i = 0; i < AWE_NORMAL_VOICES; i++)
-			vidx[i] = i;
-	} else {
-		for (i = 0; i < channels; i++) {
-			vidx[i] = awe_clear_voice();
-			voices[vidx[i]].state = AWE_ST_MARK;
-		}
-	}
-
-	/* use all channels for DMA transfer */
-	for (i = 0; i < channels; i++) {
-		if (vidx[i] < 0) continue;
-		awe_poke(AWE_DCYSUSV(vidx[i]), 0x80);
-		awe_poke_dw(AWE_VTFT(vidx[i]), 0);
-		awe_poke_dw(AWE_CVCF(vidx[i]), 0);
-		awe_poke_dw(AWE_PTRX(vidx[i]), 0x40000000);
-		awe_poke_dw(AWE_CPF(vidx[i]), 0x40000000);
-		awe_poke_dw(AWE_PSST(vidx[i]), 0);
-		awe_poke_dw(AWE_CSL(vidx[i]), 0);
-		awe_poke_dw(AWE_CCCA(vidx[i]), 0x06000000);
-		voices[vidx[i]].state = AWE_ST_DRAM;
-	}
-	/* point channels 31 & 32 to ROM samples for DRAM refresh */
-	awe_poke_dw(AWE_VTFT(30), 0);
-	awe_poke_dw(AWE_PSST(30), 0x1d8);
-	awe_poke_dw(AWE_CSL(30), 0x1e0);
-	awe_poke_dw(AWE_CCCA(30), 0x1d8);
-	awe_poke_dw(AWE_VTFT(31), 0);
-	awe_poke_dw(AWE_PSST(31), 0x1d8);
-	awe_poke_dw(AWE_CSL(31), 0x1e0);
-	awe_poke_dw(AWE_CCCA(31), 0x1d8);
-	voices[30].state = AWE_ST_FM;
-	voices[31].state = AWE_ST_FM;
-
-	/* if full bit is on, not ready to write on */
-	if (awe_peek_dw(AWE_SMALW) & 0x80000000) {
-		for (i = 0; i < channels; i++) {
-			awe_poke_dw(AWE_CCCA(vidx[i]), 0);
-			voices[vidx[i]].state = AWE_ST_OFF;
-		}
-		printk("awe: not ready to write..\n");
-		return -EPERM;
-	}
-
-	/* set address to write */
-	awe_poke_dw(AWE_SMALW, offset);
-
-	return 0;
-}
-
-/* open DRAM for RAM size detection */
-static void
-awe_open_dram_for_check(void)
-{
-	int i;
-	for (i = 0; i < AWE_NORMAL_VOICES; i++) {
-		awe_poke(AWE_DCYSUSV(i), 0x80);
-		awe_poke_dw(AWE_VTFT(i), 0);
-		awe_poke_dw(AWE_CVCF(i), 0);
-		awe_poke_dw(AWE_PTRX(i), 0x40000000);
-		awe_poke_dw(AWE_CPF(i), 0x40000000);
-		awe_poke_dw(AWE_PSST(i), 0);
-		awe_poke_dw(AWE_CSL(i), 0);
-		if (i & 1) /* DMA write */
-			awe_poke_dw(AWE_CCCA(i), 0x06000000);
-		else	   /* DMA read */
-			awe_poke_dw(AWE_CCCA(i), 0x04000000);
-		voices[i].state = AWE_ST_DRAM;
-	}
-}
-
-
-/* close dram access */
-static void
-awe_close_dram(void)
-{
-	int i;
-	/* wait until FULL bit in SMAxW register be false */
-	for (i = 0; i < 10000; i++) {
-		if (!(awe_peek_dw(AWE_SMALW) & 0x80000000))
-			break;
-		awe_wait(10);
-	}
-
-	for (i = 0; i < AWE_NORMAL_VOICES; i++) {
-		if (voices[i].state == AWE_ST_DRAM) {
-			awe_poke_dw(AWE_CCCA(i), 0);
-			awe_poke(AWE_DCYSUSV(i), 0x807F);
-			voices[i].state = AWE_ST_OFF;
-		}
-	}
-}
-
-
-/*
- * check dram size on AWE board
- */
-
-/* any three numbers you like */
-#define UNIQUE_ID1	0x1234
-#define UNIQUE_ID2	0x4321
-#define UNIQUE_ID3	0xABCD
-
-static void __init
-awe_check_dram(void)
-{
-	if (awe_present) /* already initialized */
-		return;
-
-	if (memsize >= 0) { /* given by config file or module option */
-		memsize *= 1024; /* convert to Kbytes */
-		return;
-	}
-
-	awe_open_dram_for_check();
-
-	memsize = 0;
-
-	/* set up unique two id numbers */
-	awe_poke_dw(AWE_SMALW, AWE_DRAM_OFFSET);
-	awe_poke(AWE_SMLD, UNIQUE_ID1);
-	awe_poke(AWE_SMLD, UNIQUE_ID2);
-
-	while (memsize < AWE_MAX_DRAM_SIZE) {
-		awe_wait(5);
-		/* read a data on the DRAM start address */
-		awe_poke_dw(AWE_SMALR, AWE_DRAM_OFFSET);
-		awe_peek(AWE_SMLD); /* discard stale data  */
-		if (awe_peek(AWE_SMLD) != UNIQUE_ID1)
-			break;
-		if (awe_peek(AWE_SMLD) != UNIQUE_ID2)
-			break;
-		memsize += 512;  /* increment 512kbytes */
-		/* Write a unique data on the test address;
-		 * if the address is out of range, the data is written on
-		 * 0x200000(=AWE_DRAM_OFFSET).  Then the two id words are
-		 * broken by this data.
-		 */
-		awe_poke_dw(AWE_SMALW, AWE_DRAM_OFFSET + memsize*512L);
-		awe_poke(AWE_SMLD, UNIQUE_ID3);
-		awe_wait(5);
-		/* read a data on the just written DRAM address */
-		awe_poke_dw(AWE_SMALR, AWE_DRAM_OFFSET + memsize*512L);
-		awe_peek(AWE_SMLD); /* discard stale data  */
-		if (awe_peek(AWE_SMLD) != UNIQUE_ID3)
-			break;
-	}
-	awe_close_dram();
-
-	DEBUG(0,printk("AWE32: %d Kbytes memory detected\n", memsize));
-
-	/* convert to Kbytes */
-	memsize *= 1024;
-}
-
-
-/*----------------------------------------------------------------*/
-
-/*
- * chorus and reverb controls; from VV's guide
- */
-
-/* 5 parameters for each chorus mode; 3 x 16bit, 2 x 32bit */
-static char chorus_defined[AWE_CHORUS_NUMBERS];
-static awe_chorus_fx_rec chorus_parm[AWE_CHORUS_NUMBERS] = {
-	{0xE600, 0x03F6, 0xBC2C ,0x00000000, 0x0000006D}, /* chorus 1 */
-	{0xE608, 0x031A, 0xBC6E, 0x00000000, 0x0000017C}, /* chorus 2 */
-	{0xE610, 0x031A, 0xBC84, 0x00000000, 0x00000083}, /* chorus 3 */
-	{0xE620, 0x0269, 0xBC6E, 0x00000000, 0x0000017C}, /* chorus 4 */
-	{0xE680, 0x04D3, 0xBCA6, 0x00000000, 0x0000005B}, /* feedback */
-	{0xE6E0, 0x044E, 0xBC37, 0x00000000, 0x00000026}, /* flanger */
-	{0xE600, 0x0B06, 0xBC00, 0x0000E000, 0x00000083}, /* short delay */
-	{0xE6C0, 0x0B06, 0xBC00, 0x0000E000, 0x00000083}, /* short delay + feedback */
-};
-
-static int
-awe_load_chorus_fx(awe_patch_info *patch, const char __user *addr, int count)
-{
-	if (patch->optarg < AWE_CHORUS_PREDEFINED || patch->optarg >= AWE_CHORUS_NUMBERS) {
-		printk(KERN_WARNING "AWE32 Error: invalid chorus mode %d for uploading\n", patch->optarg);
-		return -EINVAL;
-	}
-	if (count < sizeof(awe_chorus_fx_rec)) {
-		printk(KERN_WARNING "AWE32 Error: too short chorus fx parameters\n");
-		return -EINVAL;
-	}
-	if (copy_from_user(&chorus_parm[patch->optarg], addr + AWE_PATCH_INFO_SIZE,
-			   sizeof(awe_chorus_fx_rec)))
-		return -EFAULT;
-	chorus_defined[patch->optarg] = TRUE;
-	return 0;
-}
-
-static void
-awe_set_chorus_mode(int effect)
-{
-	if (effect < 0 || effect >= AWE_CHORUS_NUMBERS ||
-	    (effect >= AWE_CHORUS_PREDEFINED && !chorus_defined[effect]))
-		return;
-	awe_poke(AWE_INIT3(9), chorus_parm[effect].feedback);
-	awe_poke(AWE_INIT3(12), chorus_parm[effect].delay_offset);
-	awe_poke(AWE_INIT4(3), chorus_parm[effect].lfo_depth);
-	awe_poke_dw(AWE_HWCF4, chorus_parm[effect].delay);
-	awe_poke_dw(AWE_HWCF5, chorus_parm[effect].lfo_freq);
-	awe_poke_dw(AWE_HWCF6, 0x8000);
-	awe_poke_dw(AWE_HWCF7, 0x0000);
-}
-
-static void
-awe_update_chorus_mode(void)
-{
-	awe_set_chorus_mode(ctrls[AWE_MD_CHORUS_MODE]);
-}
-
-/*----------------------------------------------------------------*/
-
-/* reverb mode settings; write the following 28 data of 16 bit length
- *   on the corresponding ports in the reverb_cmds array
- */
-static char reverb_defined[AWE_CHORUS_NUMBERS];
-static awe_reverb_fx_rec reverb_parm[AWE_REVERB_NUMBERS] = {
-{{  /* room 1 */
-	0xB488, 0xA450, 0x9550, 0x84B5, 0x383A, 0x3EB5, 0x72F4,
-	0x72A4, 0x7254, 0x7204, 0x7204, 0x7204, 0x4416, 0x4516,
-	0xA490, 0xA590, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,
-	0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,
-}},
-{{  /* room 2 */
-	0xB488, 0xA458, 0x9558, 0x84B5, 0x383A, 0x3EB5, 0x7284,
-	0x7254, 0x7224, 0x7224, 0x7254, 0x7284, 0x4448, 0x4548,
-	0xA440, 0xA540, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,
-	0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,
-}},
-{{  /* room 3 */
-	0xB488, 0xA460, 0x9560, 0x84B5, 0x383A, 0x3EB5, 0x7284,
-	0x7254, 0x7224, 0x7224, 0x7254, 0x7284, 0x4416, 0x4516,
-	0xA490, 0xA590, 0x842C, 0x852C, 0x842C, 0x852C, 0x842B,
-	0x852B, 0x842B, 0x852B, 0x842A, 0x852A, 0x842A, 0x852A,
-}},
-{{  /* hall 1 */
-	0xB488, 0xA470, 0x9570, 0x84B5, 0x383A, 0x3EB5, 0x7284,
-	0x7254, 0x7224, 0x7224, 0x7254, 0x7284, 0x4448, 0x4548,
-	0xA440, 0xA540, 0x842B, 0x852B, 0x842B, 0x852B, 0x842A,
-	0x852A, 0x842A, 0x852A, 0x8429, 0x8529, 0x8429, 0x8529,
-}},
-{{  /* hall 2 */
-	0xB488, 0xA470, 0x9570, 0x84B5, 0x383A, 0x3EB5, 0x7254,
-	0x7234, 0x7224, 0x7254, 0x7264, 0x7294, 0x44C3, 0x45C3,
-	0xA404, 0xA504, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,
-	0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,
-}},
-{{  /* plate */
-	0xB4FF, 0xA470, 0x9570, 0x84B5, 0x383A, 0x3EB5, 0x7234,
-	0x7234, 0x7234, 0x7234, 0x7234, 0x7234, 0x4448, 0x4548,
-	0xA440, 0xA540, 0x842A, 0x852A, 0x842A, 0x852A, 0x8429,
-	0x8529, 0x8429, 0x8529, 0x8428, 0x8528, 0x8428, 0x8528,
-}},
-{{  /* delay */
-	0xB4FF, 0xA470, 0x9500, 0x84B5, 0x333A, 0x39B5, 0x7204,
-	0x7204, 0x7204, 0x7204, 0x7204, 0x72F4, 0x4400, 0x4500,
-	0xA4FF, 0xA5FF, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420,
-	0x8520, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420, 0x8520,
-}},
-{{  /* panning delay */
-	0xB4FF, 0xA490, 0x9590, 0x8474, 0x333A, 0x39B5, 0x7204,
-	0x7204, 0x7204, 0x7204, 0x7204, 0x72F4, 0x4400, 0x4500,
-	0xA4FF, 0xA5FF, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420,
-	0x8520, 0x8420, 0x8520, 0x8420, 0x8520, 0x8420, 0x8520,
-}},
-};
-
-static struct ReverbCmdPair {
-	unsigned short cmd, port;
-} reverb_cmds[28] = {
-  {AWE_INIT1(0x03)}, {AWE_INIT1(0x05)}, {AWE_INIT4(0x1F)}, {AWE_INIT1(0x07)},
-  {AWE_INIT2(0x14)}, {AWE_INIT2(0x16)}, {AWE_INIT1(0x0F)}, {AWE_INIT1(0x17)},
-  {AWE_INIT1(0x1F)}, {AWE_INIT2(0x07)}, {AWE_INIT2(0x0F)}, {AWE_INIT2(0x17)},
-  {AWE_INIT2(0x1D)}, {AWE_INIT2(0x1F)}, {AWE_INIT3(0x01)}, {AWE_INIT3(0x03)},
-  {AWE_INIT1(0x09)}, {AWE_INIT1(0x0B)}, {AWE_INIT1(0x11)}, {AWE_INIT1(0x13)},
-  {AWE_INIT1(0x19)}, {AWE_INIT1(0x1B)}, {AWE_INIT2(0x01)}, {AWE_INIT2(0x03)},
-  {AWE_INIT2(0x09)}, {AWE_INIT2(0x0B)}, {AWE_INIT2(0x11)}, {AWE_INIT2(0x13)},
-};
-
-static int
-awe_load_reverb_fx(awe_patch_info *patch, const char __user *addr, int count)
-{
-	if (patch->optarg < AWE_REVERB_PREDEFINED || patch->optarg >= AWE_REVERB_NUMBERS) {
-		printk(KERN_WARNING "AWE32 Error: invalid reverb mode %d for uploading\n", patch->optarg);
-		return -EINVAL;
-	}
-	if (count < sizeof(awe_reverb_fx_rec)) {
-		printk(KERN_WARNING "AWE32 Error: too short reverb fx parameters\n");
-		return -EINVAL;
-	}
-	if (copy_from_user(&reverb_parm[patch->optarg], addr + AWE_PATCH_INFO_SIZE,
-			   sizeof(awe_reverb_fx_rec)))
-		return -EFAULT;
-	reverb_defined[patch->optarg] = TRUE;
-	return 0;
-}
-
-static void
-awe_set_reverb_mode(int effect)
-{
-	int i;
-	if (effect < 0 || effect >= AWE_REVERB_NUMBERS ||
-	    (effect >= AWE_REVERB_PREDEFINED && !reverb_defined[effect]))
-		return;
-	for (i = 0; i < 28; i++)
-		awe_poke(reverb_cmds[i].cmd, reverb_cmds[i].port,
-			 reverb_parm[effect].parms[i]);
-}
-
-static void
-awe_update_reverb_mode(void)
-{
-	awe_set_reverb_mode(ctrls[AWE_MD_REVERB_MODE]);
-}
-
-/*
- * treble/bass equalizer control
- */
-
-static unsigned short bass_parm[12][3] = {
-	{0xD26A, 0xD36A, 0x0000}, /* -12 dB */
-	{0xD25B, 0xD35B, 0x0000}, /*  -8 */
-	{0xD24C, 0xD34C, 0x0000}, /*  -6 */
-	{0xD23D, 0xD33D, 0x0000}, /*  -4 */
-	{0xD21F, 0xD31F, 0x0000}, /*  -2 */
-	{0xC208, 0xC308, 0x0001}, /*   0 (HW default) */
-	{0xC219, 0xC319, 0x0001}, /*  +2 */
-	{0xC22A, 0xC32A, 0x0001}, /*  +4 */
-	{0xC24C, 0xC34C, 0x0001}, /*  +6 */
-	{0xC26E, 0xC36E, 0x0001}, /*  +8 */
-	{0xC248, 0xC348, 0x0002}, /* +10 */
-	{0xC26A, 0xC36A, 0x0002}, /* +12 dB */
-};
-
-static unsigned short treble_parm[12][9] = {
-	{0x821E, 0xC26A, 0x031E, 0xC36A, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001}, /* -12 dB */
-	{0x821E, 0xC25B, 0x031E, 0xC35B, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},
-	{0x821E, 0xC24C, 0x031E, 0xC34C, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},
-	{0x821E, 0xC23D, 0x031E, 0xC33D, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},
-	{0x821E, 0xC21F, 0x031E, 0xC31F, 0x021E, 0xD208, 0x831E, 0xD308, 0x0001},
-	{0x821E, 0xD208, 0x031E, 0xD308, 0x021E, 0xD208, 0x831E, 0xD308, 0x0002},
-	{0x821E, 0xD208, 0x031E, 0xD308, 0x021D, 0xD219, 0x831D, 0xD319, 0x0002},
-	{0x821E, 0xD208, 0x031E, 0xD308, 0x021C, 0xD22A, 0x831C, 0xD32A, 0x0002},
-	{0x821E, 0xD208, 0x031E, 0xD308, 0x021A, 0xD24C, 0x831A, 0xD34C, 0x0002},
-	{0x821E, 0xD208, 0x031E, 0xD308, 0x0219, 0xD26E, 0x8319, 0xD36E, 0x0002}, /* +8 (HW default) */
-	{0x821D, 0xD219, 0x031D, 0xD319, 0x0219, 0xD26E, 0x8319, 0xD36E, 0x0002},
-	{0x821C, 0xD22A, 0x031C, 0xD32A, 0x0219, 0xD26E, 0x8319, 0xD36E, 0x0002}, /* +12 dB */
-};
-
-
-/*
- * set Emu8000 digital equalizer; from 0 to 11 [-12dB - 12dB]
- */
-static void
-awe_equalizer(int bass, int treble)
-{
-	unsigned short w;
-
-	if (bass < 0 || bass > 11 || treble < 0 || treble > 11)
-		return;
-	awe_poke(AWE_INIT4(0x01), bass_parm[bass][0]);
-	awe_poke(AWE_INIT4(0x11), bass_parm[bass][1]);
-	awe_poke(AWE_INIT3(0x11), treble_parm[treble][0]);
-	awe_poke(AWE_INIT3(0x13), treble_parm[treble][1]);
-	awe_poke(AWE_INIT3(0x1B), treble_parm[treble][2]);
-	awe_poke(AWE_INIT4(0x07), treble_parm[treble][3]);
-	awe_poke(AWE_INIT4(0x0B), treble_parm[treble][4]);
-	awe_poke(AWE_INIT4(0x0D), treble_parm[treble][5]);
-	awe_poke(AWE_INIT4(0x17), treble_parm[treble][6]);
-	awe_poke(AWE_INIT4(0x19), treble_parm[treble][7]);
-	w = bass_parm[bass][2] + treble_parm[treble][8];
-	awe_poke(AWE_INIT4(0x15), (unsigned short)(w + 0x0262));
-	awe_poke(AWE_INIT4(0x1D), (unsigned short)(w + 0x8362));
-}
-
-static void awe_update_equalizer(void)
-{
-	awe_equalizer(ctrls[AWE_MD_BASS_LEVEL], ctrls[AWE_MD_TREBLE_LEVEL]);
-}
-
-
-/*----------------------------------------------------------------*/
-
-#ifdef CONFIG_AWE32_MIDIEMU
-
-/*
- * Emu8000 MIDI Emulation
- */
-
-/*
- * midi queue record
- */
-
-/* queue type */
-enum { Q_NONE, Q_VARLEN, Q_READ, Q_SYSEX, };
-
-#define MAX_MIDIBUF	64
-
-/* midi status */
-typedef struct MidiStatus {
-	int queue;	/* queue type */
-	int qlen;	/* queue length */
-	int read;	/* chars read */
-	int status;	/* current status */
-	int chan;	/* current channel */
-	unsigned char buf[MAX_MIDIBUF];
-} MidiStatus;
-
-/* MIDI mode type */
-enum { MODE_GM, MODE_GS, MODE_XG, };
-
-/* NRPN / CC -> Emu8000 parameter converter */
-typedef struct {
-	int control;
-	int awe_effect;
-	unsigned short (*convert)(int val);
-} ConvTable;
-
-
-/*
- * prototypes
- */
-
-static int awe_midi_open(int dev, int mode, void (*input)(int,unsigned char), void (*output)(int));
-static void awe_midi_close(int dev);
-static int awe_midi_ioctl(int dev, unsigned cmd, void __user * arg);
-static int awe_midi_outputc(int dev, unsigned char midi_byte);
-
-static void init_midi_status(MidiStatus *st);
-static void clear_rpn(void);
-static void get_midi_char(MidiStatus *st, int c);
-/*static void queue_varlen(MidiStatus *st, int c);*/
-static void special_event(MidiStatus *st, int c);
-static void queue_read(MidiStatus *st, int c);
-static void midi_note_on(MidiStatus *st);
-static void midi_note_off(MidiStatus *st);
-static void midi_key_pressure(MidiStatus *st);
-static void midi_channel_pressure(MidiStatus *st);
-static void midi_pitch_wheel(MidiStatus *st);
-static void midi_program_change(MidiStatus *st);
-static void midi_control_change(MidiStatus *st);
-static void midi_select_bank(MidiStatus *st, int val);
-static void midi_nrpn_event(MidiStatus *st);
-static void midi_rpn_event(MidiStatus *st);
-static void midi_detune(int chan, int coarse, int fine);
-static void midi_system_exclusive(MidiStatus *st);
-static int send_converted_effect(ConvTable *table, int num_tables, MidiStatus *st, int type, int val);
-static int add_converted_effect(ConvTable *table, int num_tables, MidiStatus *st, int type, int val);
-static int xg_control_change(MidiStatus *st, int cmd, int val);
-
-#define numberof(ary)	(sizeof(ary)/sizeof(ary[0]))
-
-
-/*
- * OSS Midi device record
- */
-
-static struct midi_operations awe_midi_operations =
-{
-	.owner		= THIS_MODULE,
-	.info		= {"AWE Midi Emu", 0, 0, SNDCARD_SB},
-	.in_info	= {0},
-	.open		= awe_midi_open, /*open*/
-	.close		= awe_midi_close, /*close*/
-	.ioctl		= awe_midi_ioctl, /*ioctl*/
-	.outputc	= awe_midi_outputc, /*outputc*/
-};
-
-static int my_mididev = -1;
-
-static void __init attach_midiemu(void)
-{
-	if ((my_mididev = sound_alloc_mididev()) < 0)
-		printk ("Sound: Too many midi devices detected\n");
-	else
-		midi_devs[my_mididev] = &awe_midi_operations;
-}
-
-static void unload_midiemu(void)
-{
-	if (my_mididev >= 0)
-		sound_unload_mididev(my_mididev);
-}
-
-
-/*
- * open/close midi device
- */
-
-static int midi_opened = FALSE;
-
-static int midi_mode;
-static int coarsetune, finetune;
-
-static int xg_mapping = TRUE;
-static int xg_bankmode;
-
-/* effect sensitivity */
-
-#define FX_CUTOFF	0
-#define FX_RESONANCE	1
-#define FX_ATTACK	2
-#define FX_RELEASE	3
-#define FX_VIBRATE	4
-#define FX_VIBDEPTH	5
-#define FX_VIBDELAY	6
-#define FX_NUMS		7
-
-#define DEF_FX_CUTOFF		170
-#define DEF_FX_RESONANCE	6
-#define DEF_FX_ATTACK		50
-#define DEF_FX_RELEASE		50
-#define DEF_FX_VIBRATE		30
-#define DEF_FX_VIBDEPTH		4
-#define DEF_FX_VIBDELAY		1500
-
-/* effect sense: */
-static int gs_sense[] = 
-{
-	DEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,
-	DEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY
-};
-static int xg_sense[] = 
-{
-	DEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,
-	DEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY
-};
-
-
-/* current status */
-static MidiStatus curst;
-
-
-static int
-awe_midi_open (int dev, int mode,
-	       void (*input)(int,unsigned char),
-	       void (*output)(int))
-{
-	if (midi_opened)
-		return -EBUSY;
-
-	midi_opened = TRUE;
-
-	midi_mode = MODE_GM;
-
-	curst.queue = Q_NONE;
-	curst.qlen = 0;
-	curst.read = 0;
-	curst.status = 0;
-	curst.chan = 0;
-	memset(curst.buf, 0, sizeof(curst.buf));
-
-	init_midi_status(&curst);
-
-	return 0;
-}
-
-static void
-awe_midi_close (int dev)
-{
-	midi_opened = FALSE;
-}
-
-
-static int
-awe_midi_ioctl (int dev, unsigned cmd, void __user *arg)
-{
-	return -EPERM;
-}
-
-static int
-awe_midi_outputc (int dev, unsigned char midi_byte)
-{
-	if (! midi_opened)
-		return 1;
-
-	/* force to change playing mode */
-	playing_mode = AWE_PLAY_MULTI;
-
-	get_midi_char(&curst, midi_byte);
-	return 1;
-}
-
-
-/*
- * initialize
- */
-
-static void init_midi_status(MidiStatus *st)
-{
-	clear_rpn();
-	coarsetune = 0;
-	finetune = 0;
-}
-
-
-/*
- * RPN & NRPN
- */
-
-#define MAX_MIDI_CHANNELS	16
-
-/* RPN & NRPN */
-static unsigned char nrpn[MAX_MIDI_CHANNELS];  /* current event is NRPN? */
-static int msb_bit;  /* current event is msb for RPN/NRPN */
-/* RPN & NRPN indeces */
-static unsigned char rpn_msb[MAX_MIDI_CHANNELS], rpn_lsb[MAX_MIDI_CHANNELS];
-/* RPN & NRPN values */
-static int rpn_val[MAX_MIDI_CHANNELS];
-
-static void clear_rpn(void)
-{
-	int i;
-	for (i = 0; i < MAX_MIDI_CHANNELS; i++) {
-		nrpn[i] = 0;
-		rpn_msb[i] = 127;
-		rpn_lsb[i] = 127;
-		rpn_val[i] = 0;
-	}
-	msb_bit = 0;
-}
-
-
-/*
- * process midi queue
- */
-
-/* status event types */
-typedef void (*StatusEvent)(MidiStatus *st);
-static struct StatusEventList {
-	StatusEvent process;
-	int qlen;
-} status_event[8] = {
-	{midi_note_off, 2},
-	{midi_note_on, 2},
-	{midi_key_pressure, 2},
-	{midi_control_change, 2},
-	{midi_program_change, 1},
-	{midi_channel_pressure, 1},
-	{midi_pitch_wheel, 2},
-	{NULL, 0},
-};
-
-
-/* read a char from fifo and process it */
-static void get_midi_char(MidiStatus *st, int c)
-{
-	if (c == 0xfe) {
-		/* ignore active sense */
-		st->queue = Q_NONE;
-		return;
-	}
-
-	switch (st->queue) {
-	/* case Q_VARLEN: queue_varlen(st, c); break;*/
-	case Q_READ:
-	case Q_SYSEX:
-		queue_read(st, c);
-		break;
-	case Q_NONE:
-		st->read = 0;
-		if ((c & 0xf0) == 0xf0) {
-			special_event(st, c);
-		} else if (c & 0x80) { /* status change */
-			st->status = (c >> 4) & 0x07;
-			st->chan = c & 0x0f;
-			st->queue = Q_READ;
-			st->qlen = status_event[st->status].qlen;
-			if (st->qlen == 0)
-				st->queue = Q_NONE;
-		}
-		break;
-	}
-}
-
-/* 0xfx events */
-static void special_event(MidiStatus *st, int c)
-{
-	switch (c) {
-	case 0xf0: /* system exclusive */
-		st->queue = Q_SYSEX;
-		st->qlen = 0;
-		break;
-	case 0xf1: /* MTC quarter frame */
-	case 0xf3: /* song select */
-		st->queue = Q_READ;
-		st->qlen = 1;
-		break;
-	case 0xf2: /* song position */
-		st->queue = Q_READ;
-		st->qlen = 2;
-		break;
-	}
-}
-
-#if 0
-/* read variable length value */
-static void queue_varlen(MidiStatus *st, int c)
-{
-	st->qlen += (c & 0x7f);
-	if (c & 0x80) {
-		st->qlen <<= 7;
-		return;
-	}
-	if (st->qlen <= 0) {
-		st->qlen = 0;
-		st->queue = Q_NONE;
-	}
-	st->queue = Q_READ;
-	st->read = 0;
-}
-#endif
-
-
-/* read a char */
-static void queue_read(MidiStatus *st, int c)
-{
-	if (st->read < MAX_MIDIBUF) {
-		if (st->queue != Q_SYSEX)
-			c &= 0x7f;
-		st->buf[st->read] = (unsigned char)c;
-	}
-	st->read++;
-	if (st->queue == Q_SYSEX && c == 0xf7) {
-		midi_system_exclusive(st);
-		st->queue = Q_NONE;
-	} else if (st->queue == Q_READ && st->read >= st->qlen) {
-		if (status_event[st->status].process)
-			status_event[st->status].process(st);
-		st->queue = Q_NONE;
-	}
-}
-
-
-/*
- * status events
- */
-
-/* note on */
-static void midi_note_on(MidiStatus *st)
-{
-	DEBUG(2,printk("midi: note_on (%d) %d %d\n", st->chan, st->buf[0], st->buf[1]));
-	if (st->buf[1] == 0)
-		midi_note_off(st);
-	else
-		awe_start_note(0, st->chan, st->buf[0], st->buf[1]);
-}
-
-/* note off */
-static void midi_note_off(MidiStatus *st)
-{
-	DEBUG(2,printk("midi: note_off (%d) %d %d\n", st->chan, st->buf[0], st->buf[1]));
-	awe_kill_note(0, st->chan, st->buf[0], st->buf[1]);
-}
-
-/* key pressure change */
-static void midi_key_pressure(MidiStatus *st)
-{
-	awe_key_pressure(0, st->chan, st->buf[0], st->buf[1]);
-}
-
-/* channel pressure change */
-static void midi_channel_pressure(MidiStatus *st)
-{
-	channels[st->chan].chan_press = st->buf[0];
-	awe_modwheel_change(st->chan, st->buf[0]);
-}
-
-/* pitch wheel change */
-static void midi_pitch_wheel(MidiStatus *st)
-{
-	int val = (int)st->buf[1] * 128 + st->buf[0];
-	awe_bender(0, st->chan, val);
-}
-
-/* program change */
-static void midi_program_change(MidiStatus *st)
-{
-	int preset;
-	preset = st->buf[0];
-	if (midi_mode == MODE_GS && IS_DRUM_CHANNEL(st->chan) && preset == 127)
-		preset = 0;
-	else if (midi_mode == MODE_XG && xg_mapping && IS_DRUM_CHANNEL(st->chan))
-		preset += 64;
-
-	awe_set_instr(0, st->chan, preset);
-}
-
-#define send_effect(chan,type,val) awe_send_effect(chan,-1,type,val)
-#define add_effect(chan,type,val) awe_send_effect(chan,-1,(type)|0x80,val)
-#define unset_effect(chan,type) awe_send_effect(chan,-1,(type)|0x40,0)
-
-/* midi control change */
-static void midi_control_change(MidiStatus *st)
-{
-	int cmd = st->buf[0];
-	int val = st->buf[1];
-
-	DEBUG(2,printk("midi: control (%d) %d %d\n", st->chan, cmd, val));
-	if (midi_mode == MODE_XG) {
-		if (xg_control_change(st, cmd, val))
-			return;
-	}
-
-	/* controls #31 - #64 are LSB of #0 - #31 */
-	msb_bit = 1;
-	if (cmd >= 0x20 && cmd < 0x40) {
-		msb_bit = 0;
-		cmd -= 0x20;
-	}
-
-	switch (cmd) {
-	case CTL_SOFT_PEDAL:
-		if (val == 127)
-			add_effect(st->chan, AWE_FX_CUTOFF, -160);
-		else
-			unset_effect(st->chan, AWE_FX_CUTOFF);
-		break;
-
-	case CTL_BANK_SELECT:
-		midi_select_bank(st, val);
-		break;
-		
-	/* set RPN/NRPN parameter */
-	case CTL_REGIST_PARM_NUM_MSB:
-		nrpn[st->chan]=0; rpn_msb[st->chan]=val;
-		break;
-	case CTL_REGIST_PARM_NUM_LSB:
-		nrpn[st->chan]=0; rpn_lsb[st->chan]=val;
-		break;
-	case CTL_NONREG_PARM_NUM_MSB:
-		nrpn[st->chan]=1; rpn_msb[st->chan]=val;
-		break;
-	case CTL_NONREG_PARM_NUM_LSB:
-		nrpn[st->chan]=1; rpn_lsb[st->chan]=val;
-		break;
-
-	/* send RPN/NRPN entry */
-	case CTL_DATA_ENTRY:
-		if (msb_bit)
-			rpn_val[st->chan] = val * 128;
-		else
-			rpn_val[st->chan] |= val;
-		if (nrpn[st->chan])
-			midi_nrpn_event(st);
-		else
-			midi_rpn_event(st);
-		break;
-
-	/* increase/decrease data entry */
-	case CTL_DATA_INCREMENT:
-		rpn_val[st->chan]++;
-		midi_rpn_event(st);
-		break;
-	case CTL_DATA_DECREMENT:
-		rpn_val[st->chan]--;
-		midi_rpn_event(st);
-		break;
-
-	/* default */
-	default:
-		awe_controller(0, st->chan, cmd, val);
-		break;
-	}
-}
-
-/* tone bank change */
-static void midi_select_bank(MidiStatus *st, int val)
-{
-	if (midi_mode == MODE_XG && msb_bit) {
-		xg_bankmode = val;
-		/* XG MSB value; not normal bank selection */
-		switch (val) {
-		case 127: /* remap to drum channel */
-			awe_controller(0, st->chan, CTL_BANK_SELECT, 128);
-			break;
-		default: /* remap to normal channel */
-			awe_controller(0, st->chan, CTL_BANK_SELECT, val);
-			break;
-		}
-		return;
-	} else if (midi_mode == MODE_GS && !msb_bit)
-		/* ignore LSB bank in GS mode (used for mapping) */
-		return;
-
-	/* normal bank controls; accept both MSB and LSB */
-	if (! IS_DRUM_CHANNEL(st->chan)) {
-		if (midi_mode == MODE_XG) {
-			if (xg_bankmode) return;
-			if (val == 64 || val == 126)
-				val = 0;
-		} else if (midi_mode == MODE_GS && val == 127)
-			val = 0;
-		awe_controller(0, st->chan, CTL_BANK_SELECT, val);
-	}
-}
-
-
-/*
- * RPN events
- */
-
-static void midi_rpn_event(MidiStatus *st)
-{
-	int type;
-	type = (rpn_msb[st->chan]<<8) | rpn_lsb[st->chan];
-	switch (type) {
-	case 0x0000: /* Pitch bend sensitivity */
-		/* MSB only / 1 semitone per 128 */
-		if (msb_bit) {
-			channels[st->chan].bender_range = 
-				rpn_val[st->chan] * 100 / 128;
-		}
-		break;
-					
-	case 0x0001: /* fine tuning: */
-		/* MSB/LSB, 8192=center, 100/8192 cent step */
-		finetune = rpn_val[st->chan] - 8192;
-		midi_detune(st->chan, coarsetune, finetune);
-		break;
-
-	case 0x0002: /* coarse tuning */
-		/* MSB only / 8192=center, 1 semitone per 128 */
-		if (msb_bit) {
-			coarsetune = rpn_val[st->chan] - 8192;
-			midi_detune(st->chan, coarsetune, finetune);
-		}
-		break;
-
-	case 0x7F7F: /* "lock-in" RPN */
-		break;
-	}
-}
-
-
-/* tuning:
- *   coarse = -8192 to 8192 (100 cent per 128)
- *   fine = -8192 to 8192 (max=100cent)
- */
-static void midi_detune(int chan, int coarse, int fine)
-{
-	/* 4096 = 1200 cents in AWE parameter */
-	int val;
-	val = coarse * 4096 / (12 * 128);
-	val += fine / 24;
-	if (val)
-		send_effect(chan, AWE_FX_INIT_PITCH, val);
-	else
-		unset_effect(chan, AWE_FX_INIT_PITCH);
-}
-
-
-/*
- * system exclusive message
- * GM/GS/XG macros are accepted
- */
-
-static void midi_system_exclusive(MidiStatus *st)
-{
-	/* GM on */
-	static unsigned char gm_on_macro[] = {
-		0x7e,0x7f,0x09,0x01,
-	};
-	/* XG on */
-	static unsigned char xg_on_macro[] = {
-		0x43,0x10,0x4c,0x00,0x00,0x7e,0x00,
-	};
-	/* GS prefix
-	 * drum channel: XX=0x1?(channel), YY=0x15, ZZ=on/off
-	 * reverb mode: XX=0x01, YY=0x30, ZZ=0-7
-	 * chorus mode: XX=0x01, YY=0x38, ZZ=0-7
-	 */
-	static unsigned char gs_pfx_macro[] = {
-		0x41,0x10,0x42,0x12,0x40,/*XX,YY,ZZ*/
-	};
-
-#if 0
-	/* SC88 system mode set
-	 * single module mode: XX=1
-	 * double module mode: XX=0
-	 */
-	static unsigned char gs_mode_macro[] = {
-		0x41,0x10,0x42,0x12,0x00,0x00,0x7F,/*ZZ*/
-	};
-	/* SC88 display macro: XX=01:bitmap, 00:text
-	 */
-	static unsigned char gs_disp_macro[] = {
-		0x41,0x10,0x45,0x12,0x10,/*XX,00*/
-	};
-#endif
-
-	/* GM on */
-	if (memcmp(st->buf, gm_on_macro, sizeof(gm_on_macro)) == 0) {
-		if (midi_mode != MODE_GS && midi_mode != MODE_XG)
-			midi_mode = MODE_GM;
-		init_midi_status(st);
-	}
-
-	/* GS macros */
-	else if (memcmp(st->buf, gs_pfx_macro, sizeof(gs_pfx_macro)) == 0) {
-		if (midi_mode != MODE_GS && midi_mode != MODE_XG)
-			midi_mode = MODE_GS;
-
-		if (st->buf[5] == 0x00 && st->buf[6] == 0x7f && st->buf[7] == 0x00) {
-			/* GS reset */
-			init_midi_status(st);
-		}
-
-		else if ((st->buf[5] & 0xf0) == 0x10 && st->buf[6] == 0x15) {
-			/* drum pattern */
-			int p = st->buf[5] & 0x0f;
-			if (p == 0) p = 9;
-			else if (p < 10) p--;
-			if (st->buf[7] == 0)
-				DRUM_CHANNEL_OFF(p);
-			else
-				DRUM_CHANNEL_ON(p);
-
-		} else if ((st->buf[5] & 0xf0) == 0x10 && st->buf[6] == 0x21) {
-			/* program */
-			int p = st->buf[5] & 0x0f;
-			if (p == 0) p = 9;
-			else if (p < 10) p--;
-			if (! IS_DRUM_CHANNEL(p))
-				awe_set_instr(0, p, st->buf[7]);
-
-		} else if (st->buf[5] == 0x01 && st->buf[6] == 0x30) {
-			/* reverb mode */
-			awe_set_reverb_mode(st->buf[7]);
-
-		} else if (st->buf[5] == 0x01 && st->buf[6] == 0x38) {
-			/* chorus mode */
-			awe_set_chorus_mode(st->buf[7]);
-
-		} else if (st->buf[5] == 0x00 && st->buf[6] == 0x04) {
-			/* master volume */
-			awe_change_master_volume(st->buf[7]);
-
-		}
-	}
-
-	/* XG on */
-	else if (memcmp(st->buf, xg_on_macro, sizeof(xg_on_macro)) == 0) {
-		midi_mode = MODE_XG;
-		xg_mapping = TRUE;
-		xg_bankmode = 0;
-	}
-}
-
-
-/*----------------------------------------------------------------*/
-
-/*
- * convert NRPN/control values
- */
-
-static int send_converted_effect(ConvTable *table, int num_tables, MidiStatus *st, int type, int val)
-{
-	int i, cval;
-	for (i = 0; i < num_tables; i++) {
-		if (table[i].control == type) {
-			cval = table[i].convert(val);
-			send_effect(st->chan, table[i].awe_effect, cval);
-			return TRUE;
-		}
-	}
-	return FALSE;
-}
-
-static int add_converted_effect(ConvTable *table, int num_tables, MidiStatus *st, int type, int val)
-{
-	int i, cval;
-	for (i = 0; i < num_tables; i++) {
-		if (table[i].control == type) {
-			cval = table[i].convert(val);
-			add_effect(st->chan, table[i].awe_effect|0x80, cval);
-			return TRUE;
-		}
-	}
-	return FALSE;
-}
-
-
-/*
- * AWE32 NRPN effects
- */
-
-static unsigned short fx_delay(int val);
-static unsigned short fx_attack(int val);
-static unsigned short fx_hold(int val);
-static unsigned short fx_decay(int val);
-static unsigned short fx_the_value(int val);
-static unsigned short fx_twice_value(int val);
-static unsigned short fx_conv_pitch(int val);
-static unsigned short fx_conv_Q(int val);
-
-/* function for each NRPN */		/* [range]  units */
-#define fx_env1_delay	fx_delay	/* [0,5900] 4msec */
-#define fx_env1_attack	fx_attack	/* [0,5940] 1msec */
-#define fx_env1_hold	fx_hold		/* [0,8191] 1msec */
-#define fx_env1_decay	fx_decay	/* [0,5940] 4msec */
-#define fx_env1_release	fx_decay	/* [0,5940] 4msec */
-#define fx_env1_sustain	fx_the_value	/* [0,127] 0.75dB */
-#define fx_env1_pitch	fx_the_value	/* [-127,127] 9.375cents */
-#define fx_env1_cutoff	fx_the_value	/* [-127,127] 56.25cents */
-
-#define fx_env2_delay	fx_delay	/* [0,5900] 4msec */
-#define fx_env2_attack	fx_attack	/* [0,5940] 1msec */
-#define fx_env2_hold	fx_hold		/* [0,8191] 1msec */
-#define fx_env2_decay	fx_decay	/* [0,5940] 4msec */
-#define fx_env2_release	fx_decay	/* [0,5940] 4msec */
-#define fx_env2_sustain	fx_the_value	/* [0,127] 0.75dB */
-
-#define fx_lfo1_delay	fx_delay	/* [0,5900] 4msec */
-#define fx_lfo1_freq	fx_twice_value	/* [0,127] 84mHz */
-#define fx_lfo1_volume	fx_twice_value	/* [0,127] 0.1875dB */
-#define fx_lfo1_pitch	fx_the_value	/* [-127,127] 9.375cents */
-#define fx_lfo1_cutoff	fx_twice_value	/* [-64,63] 56.25cents */
-
-#define fx_lfo2_delay	fx_delay	/* [0,5900] 4msec */
-#define fx_lfo2_freq	fx_twice_value	/* [0,127] 84mHz */
-#define fx_lfo2_pitch	fx_the_value	/* [-127,127] 9.375cents */
-
-#define fx_init_pitch	fx_conv_pitch	/* [-8192,8192] cents */
-#define fx_chorus	fx_the_value	/* [0,255] -- */
-#define fx_reverb	fx_the_value	/* [0,255] -- */
-#define fx_cutoff	fx_twice_value	/* [0,127] 62Hz */
-#define fx_filterQ	fx_conv_Q	/* [0,127] -- */
-
-static unsigned short fx_delay(int val)
-{
-	return (unsigned short)calc_parm_delay(val);
-}
-
-static unsigned short fx_attack(int val)
-{
-	return (unsigned short)calc_parm_attack(val);
-}
-
-static unsigned short fx_hold(int val)
-{
-	return (unsigned short)calc_parm_hold(val);
-}
-
-static unsigned short fx_decay(int val)
-{
-	return (unsigned short)calc_parm_decay(val);
-}
-
-static unsigned short fx_the_value(int val)
-{
-	return (unsigned short)(val & 0xff);
-}
-
-static unsigned short fx_twice_value(int val)
-{
-	return (unsigned short)((val * 2) & 0xff);
-}
-
-static unsigned short fx_conv_pitch(int val)
-{
-	return (short)(val * 4096 / 1200);
-}
-
-static unsigned short fx_conv_Q(int val)
-{
-	return (unsigned short)((val / 8) & 0xff);
-}
-
-
-static ConvTable awe_effects[] =
-{
-	{ 0, AWE_FX_LFO1_DELAY,	fx_lfo1_delay},
-	{ 1, AWE_FX_LFO1_FREQ,	fx_lfo1_freq},
-	{ 2, AWE_FX_LFO2_DELAY,	fx_lfo2_delay},
-	{ 3, AWE_FX_LFO2_FREQ,	fx_lfo2_freq},
-
-	{ 4, AWE_FX_ENV1_DELAY,	fx_env1_delay},
-	{ 5, AWE_FX_ENV1_ATTACK,fx_env1_attack},
-	{ 6, AWE_FX_ENV1_HOLD,	fx_env1_hold},
-	{ 7, AWE_FX_ENV1_DECAY,	fx_env1_decay},
-	{ 8, AWE_FX_ENV1_SUSTAIN,	fx_env1_sustain},
-	{ 9, AWE_FX_ENV1_RELEASE,	fx_env1_release},
-
-	{10, AWE_FX_ENV2_DELAY,	fx_env2_delay},
-	{11, AWE_FX_ENV2_ATTACK,	fx_env2_attack},
-	{12, AWE_FX_ENV2_HOLD,	fx_env2_hold},
-	{13, AWE_FX_ENV2_DECAY,	fx_env2_decay},
-	{14, AWE_FX_ENV2_SUSTAIN,	fx_env2_sustain},
-	{15, AWE_FX_ENV2_RELEASE,	fx_env2_release},
-
-	{16, AWE_FX_INIT_PITCH,	fx_init_pitch},
-	{17, AWE_FX_LFO1_PITCH,	fx_lfo1_pitch},
-	{18, AWE_FX_LFO2_PITCH,	fx_lfo2_pitch},
-	{19, AWE_FX_ENV1_PITCH,	fx_env1_pitch},
-	{20, AWE_FX_LFO1_VOLUME,	fx_lfo1_volume},
-	{21, AWE_FX_CUTOFF,		fx_cutoff},
-	{22, AWE_FX_FILTERQ,	fx_filterQ},
-	{23, AWE_FX_LFO1_CUTOFF,	fx_lfo1_cutoff},
-	{24, AWE_FX_ENV1_CUTOFF,	fx_env1_cutoff},
-	{25, AWE_FX_CHORUS,		fx_chorus},
-	{26, AWE_FX_REVERB,		fx_reverb},
-};
-
-static int num_awe_effects = numberof(awe_effects);
-
-
-/*
- * GS(SC88) NRPN effects; still experimental
- */
-
-/* cutoff: quarter semitone step, max=255 */
-static unsigned short gs_cutoff(int val)
-{
-	return (val - 64) * gs_sense[FX_CUTOFF] / 50;
-}
-
-/* resonance: 0 to 15(max) */
-static unsigned short gs_filterQ(int val)
-{
-	return (val - 64) * gs_sense[FX_RESONANCE] / 50;
-}
-
-/* attack: */
-static unsigned short gs_attack(int val)
-{
-	return -(val - 64) * gs_sense[FX_ATTACK] / 50;
-}
-
-/* decay: */
-static unsigned short gs_decay(int val)
-{
-	return -(val - 64) * gs_sense[FX_RELEASE] / 50;
-}
-
-/* release: */
-static unsigned short gs_release(int val)
-{
-	return -(val - 64) * gs_sense[FX_RELEASE] / 50;
-}
-
-/* vibrato freq: 0.042Hz step, max=255 */
-static unsigned short gs_vib_rate(int val)
-{
-	return (val - 64) * gs_sense[FX_VIBRATE] / 50;
-}
-
-/* vibrato depth: max=127, 1 octave */
-static unsigned short gs_vib_depth(int val)
-{
-	return (val - 64) * gs_sense[FX_VIBDEPTH] / 50;
-}
-
-/* vibrato delay: -0.725msec step */
-static unsigned short gs_vib_delay(int val)
-{
-	return -(val - 64) * gs_sense[FX_VIBDELAY] / 50;
-}
-
-static ConvTable gs_effects[] =
-{
-	{32, AWE_FX_CUTOFF,	gs_cutoff},
-	{33, AWE_FX_FILTERQ,	gs_filterQ},
-	{99, AWE_FX_ENV2_ATTACK, gs_attack},
-	{100, AWE_FX_ENV2_DECAY, gs_decay},
-	{102, AWE_FX_ENV2_RELEASE, gs_release},
-	{8, AWE_FX_LFO1_FREQ, gs_vib_rate},
-	{9, AWE_FX_LFO1_VOLUME, gs_vib_depth},
-	{10, AWE_FX_LFO1_DELAY, gs_vib_delay},
-};
-
-static int num_gs_effects = numberof(gs_effects);
-
-
-/*
- * NRPN events: accept as AWE32/SC88 specific controls
- */
-
-static void midi_nrpn_event(MidiStatus *st)
-{
-	if (rpn_msb[st->chan] == 127 && rpn_lsb[st->chan] <= 26) {
-		if (! msb_bit) /* both MSB/LSB necessary */
-			send_converted_effect(awe_effects, num_awe_effects,
-					      st, rpn_lsb[st->chan],
-					      rpn_val[st->chan] - 8192);
-	} else if (rpn_msb[st->chan] == 1) {
-		if (msb_bit) /* only MSB is valid */
-			add_converted_effect(gs_effects, num_gs_effects,
-					     st, rpn_lsb[st->chan],
-					     rpn_val[st->chan] / 128);
-	}
-}
-
-
-/*
- * XG control effects; still experimental
- */
-
-/* cutoff: quarter semitone step, max=255 */
-static unsigned short xg_cutoff(int val)
-{
-	return (val - 64) * xg_sense[FX_CUTOFF] / 64;
-}
-
-/* resonance: 0(open) to 15(most nasal) */
-static unsigned short xg_filterQ(int val)
-{
-	return (val - 64) * xg_sense[FX_RESONANCE] / 64;
-}
-
-/* attack: */
-static unsigned short xg_attack(int val)
-{
-	return -(val - 64) * xg_sense[FX_ATTACK] / 64;
-}
-
-/* release: */
-static unsigned short xg_release(int val)
-{
-	return -(val - 64) * xg_sense[FX_RELEASE] / 64;
-}
-
-static ConvTable xg_effects[] =
-{
-	{71, AWE_FX_CUTOFF,	xg_cutoff},
-	{74, AWE_FX_FILTERQ,	xg_filterQ},
-	{72, AWE_FX_ENV2_RELEASE, xg_release},
-	{73, AWE_FX_ENV2_ATTACK, xg_attack},
-};
-
-static int num_xg_effects = numberof(xg_effects);
-
-static int xg_control_change(MidiStatus *st, int cmd, int val)
-{
-	return add_converted_effect(xg_effects, num_xg_effects, st, cmd, val);
-}
-
-#endif /* CONFIG_AWE32_MIDIEMU */
-
-
-/*----------------------------------------------------------------*/
-
-
-/*
- * initialization of AWE driver
- */
-
-static void
-awe_initialize(void)
-{
-	DEBUG(0,printk("AWE32: initializing..\n"));
-
-	/* initialize hardware configuration */
-	awe_poke(AWE_HWCF1, 0x0059);
-	awe_poke(AWE_HWCF2, 0x0020);
-
-	/* disable audio; this seems to reduce a clicking noise a bit.. */
-	awe_poke(AWE_HWCF3, 0);
-
-	/* initialize audio channels */
-	awe_init_audio();
-
-	/* initialize DMA */
-	awe_init_dma();
-
-	/* initialize init array */
-	awe_init_array();
-
-	/* check DRAM memory size */
-	awe_check_dram();
-
-	/* initialize the FM section of the AWE32 */
-	awe_init_fm();
-
-	/* set up voice envelopes */
-	awe_tweak();
-
-	/* enable audio */
-	awe_poke(AWE_HWCF3, 0x0004);
-
-	/* set default values */
-	awe_init_ctrl_parms(TRUE);
-
-	/* set equalizer */
-	awe_update_equalizer();
-
-	/* set reverb & chorus modes */
-	awe_update_reverb_mode();
-	awe_update_chorus_mode();
-}
-
-
-/*
- * Core Device Management Functions
- */
-
-/* store values to i/o port array */
-static void setup_ports(int port1, int port2, int port3)
-{
-	awe_ports[0] = port1;
-	if (port2 == 0)
-		port2 = port1 + 0x400;
-	awe_ports[1] = port2;
-	awe_ports[2] = port2 + 2;
-	if (port3 == 0)
-		port3 = port1 + 0x800;
-	awe_ports[3] = port3;
-	awe_ports[4] = port3 + 2;
-
-	port_setuped = TRUE;
-}
-
-/*
- * port request
- *  0x620-623, 0xA20-A23, 0xE20-E23
- */
-
-static int
-awe_request_region(void)
-{
-	if (! port_setuped)
-		return 0;
-	if (! request_region(awe_ports[0], 4, "sound driver (AWE32)"))
-		return 0;
-	if (! request_region(awe_ports[1], 4, "sound driver (AWE32)"))
-		goto err_out;
-	if (! request_region(awe_ports[3], 4, "sound driver (AWE32)"))
-		goto err_out1;
-	return 1;
-err_out1:
-	release_region(awe_ports[1], 4);
-err_out:
-	release_region(awe_ports[0], 4);
-	return 0;
-}
-
-static void
-awe_release_region(void)
-{
-	if (! port_setuped) return;
-	release_region(awe_ports[0], 4);
-	release_region(awe_ports[1], 4);
-	release_region(awe_ports[3], 4);
-}
-
-static int awe_attach_device(void)
-{
-	if (awe_present) return 0; /* for OSS38.. called twice? */
-
-	/* reserve I/O ports for awedrv */
-	if (! awe_request_region()) {
-		printk(KERN_ERR "AWE32: I/O area already used.\n");
-		return 0;
-	}
-
-	/* set buffers to NULL */
-	sfhead = sftail = NULL;
-
-	my_dev = sound_alloc_synthdev();
-	if (my_dev == -1) {
-		printk(KERN_ERR "AWE32 Error: too many synthesizers\n");
-		awe_release_region();
-		return 0;
-	}
-
-	voice_alloc = &awe_operations.alloc;
-	voice_alloc->max_voice = awe_max_voices;
-	synth_devs[my_dev] = &awe_operations;
-
-#ifdef CONFIG_AWE32_MIXER
-	attach_mixer();
-#endif
-#ifdef CONFIG_AWE32_MIDIEMU
-	attach_midiemu();
-#endif
-
-	/* clear all samples */
-	awe_reset_samples();
-
-	/* initialize AWE32 hardware */
-	awe_initialize();
-
-	sprintf(awe_info.name, "AWE32-%s (RAM%dk)",
-		AWEDRV_VERSION, memsize/1024);
-	printk(KERN_INFO "<SoundBlaster EMU8000 (RAM%dk)>\n", memsize/1024);
-
-	awe_present = TRUE;
-
-	return 1;
-}
-
-static void awe_dettach_device(void)
-{
-	if (awe_present) {
-		awe_reset_samples();
-		awe_release_region();
-		free_tables();
-#ifdef CONFIG_AWE32_MIXER
-		unload_mixer();
-#endif
-#ifdef CONFIG_AWE32_MIDIEMU
-		unload_midiemu();
-#endif
-		sound_unload_synthdev(my_dev);
-		awe_present = FALSE;
-	}
-}
-
-
-/*
- * Legacy device Probing
- */
-
-/* detect emu8000 chip on the specified address; from VV's guide */
-
-static int __init
-awe_detect_base(int addr)
-{
-	setup_ports(addr, 0, 0);
-	if ((awe_peek(AWE_U1) & 0x000F) != 0x000C)
-		return 0;
-	if ((awe_peek(AWE_HWCF1) & 0x007E) != 0x0058)
-		return 0;
-	if ((awe_peek(AWE_HWCF2) & 0x0003) != 0x0003)
-		return 0;
-        DEBUG(0,printk("AWE32 found at %x\n", addr));
-	return 1;
-}
-
-static int __init awe_detect_legacy_devices(void)
-{
-	int base;
-	for (base = 0x620; base <= 0x680; base += 0x20)
-		if (awe_detect_base(base)) {
-			awe_attach_device();
-			return 1;
-			}
-	DEBUG(0,printk("AWE32 Legacy detection failed\n"));
-	return 0;
-}
-
-
-/*
- * PnP device Probing
- */
-
-static struct pnp_device_id awe_pnp_ids[] = {
-	{.id = "CTL0021", .driver_data = 0}, /* AWE32 WaveTable */
-	{.id = "CTL0022", .driver_data = 0}, /* AWE64 WaveTable */
-	{.id = "CTL0023", .driver_data = 0}, /* AWE64 Gold WaveTable */
-	{ } /* terminator */
-};
-
-MODULE_DEVICE_TABLE(pnp, awe_pnp_ids);
-
-static int awe_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)
-{
-	int io1, io2, io3;
-
-	if (awe_present) {
-		printk(KERN_ERR "AWE32: This driver only supports one AWE32 device, skipping.\n");
-	}
-
-	if (!pnp_port_valid(dev,0) ||
-	    !pnp_port_valid(dev,1) ||
-	    !pnp_port_valid(dev,2)) {
-		printk(KERN_ERR "AWE32: The PnP device does not have the required resources.\n");
-		return -EINVAL;
-	}
-	io1 = pnp_port_start(dev,0);
-	io2 = pnp_port_start(dev,1);
-	io3 = pnp_port_start(dev,2);
-	printk(KERN_INFO "AWE32: A PnP Wave Table was detected at IO's %#x,%#x,%#x.\n",
-	       io1, io2, io3);
-	setup_ports(io1, io2, io3);
-
-	awe_attach_device();
-	return 0;
-}
-
-static void awe_pnp_remove(struct pnp_dev *dev)
-{
-	awe_dettach_device();
-}
-
-static struct pnp_driver awe_pnp_driver = {
-	.name		= "AWE32",
-	.id_table	= awe_pnp_ids,
-	.probe		= awe_pnp_probe,
-	.remove		= awe_pnp_remove,
-};
-
-static int __init awe_detect_pnp_devices(void)
-{
-	int ret;
-
-	ret = pnp_register_driver(&awe_pnp_driver);
-	if (ret<0)
-		printk(KERN_ERR "AWE32: PnP support is unavailable.\n");
-	return ret;
-}
-
-
-/*
- * device / lowlevel (module) interface
- */
-
-static int __init
-awe_detect(void)
-{
-	printk(KERN_INFO "AWE32: Probing for WaveTable...\n");
-	if (isapnp) {
-		if (awe_detect_pnp_devices()>=0)
-			return 1;
-	} else
-		printk(KERN_INFO "AWE32: Skipping PnP detection.\n");
-
-	if (awe_detect_legacy_devices())
-		return 1;
-
-	return 0;
-}
-
-static int __init attach_awe(void)
-{
-	return awe_detect() ? 0 : -ENODEV;
-}
-
-static void __exit unload_awe(void)
-{
-	pnp_unregister_driver(&awe_pnp_driver);
-	awe_dettach_device();
-}
-
-
-module_init(attach_awe);
-module_exit(unload_awe);
-
-#ifndef MODULE
-static int __init setup_awe(char *str)
-{
-	/* io, memsize, isapnp */
-	int ints[4];
-
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-
-	io = ints[1];
-	memsize = ints[2];
-	isapnp = ints[3];
-
-	return 1;
-}
-
-__setup("awe=", setup_awe);
-#endif
--- linux-2.6.18.noarch/sound/oss/dm.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dm.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,79 +0,0 @@
-#ifndef _DRIVERS_SOUND_DM_H
-#define _DRIVERS_SOUND_DM_H
-
-/*
- *	Definitions of the 'direct midi sound' interface used
- *	by the newer commercial OSS package. We should export
- *	this to userland somewhere in glibc later.
- */
-
-/*
- * Data structure composing an FM "note" or sound event.
- */
-
-struct dm_fm_voice
-{
-	u8 op;
-	u8 voice;
-	u8 am;
-	u8 vibrato;
-	u8 do_sustain;
-	u8 kbd_scale;
-	u8 harmonic;
-	u8 scale_level;
-	u8 volume;
-	u8 attack;
-	u8 decay;
-	u8 sustain;
-	u8 release;
-	u8 feedback;
-	u8 connection;
-	u8 left;
-	u8 right;
-	u8 waveform;
-};
-
-/*
- *	This describes an FM note by its voice, octave, frequency number (10bit)
- *	and key on/off.
- */
-
-struct dm_fm_note
-{
-	u8 voice;
-	u8 octave;
-	u32 fnum;
-	u8 key_on;
-};
-
-/*
- * FM parameters that apply globally to all voices, and thus are not "notes"
- */
-
-struct dm_fm_params
-{
-	u8 am_depth;
-	u8 vib_depth;
-	u8 kbd_split;
-	u8 rhythm;
-
-	/* This block is the percussion instrument data */
-	u8 bass;
-	u8 snare;
-	u8 tomtom;
-	u8 cymbal;
-	u8 hihat;
-};
-
-/*
- *	FM mode ioctl settings
- */
- 
-#define FM_IOCTL_RESET        0x20
-#define FM_IOCTL_PLAY_NOTE    0x21
-#define FM_IOCTL_SET_VOICE    0x22
-#define FM_IOCTL_SET_PARAMS   0x23
-#define FM_IOCTL_SET_MODE     0x24
-#define FM_IOCTL_SET_OPL      0x25
-
-#endif
--- linux-2.6.18.noarch/sound/oss/dev_table.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dev_table.h	2007-06-05 17:44:14.000000000 -0400
@@ -352,22 +352,8 @@
 	void (*arm_timer)(int dev, long time);
 };
 
-#ifdef _DEV_TABLE_C_   
-struct audio_operations *audio_devs[MAX_AUDIO_DEV];
-int num_audiodevs;
-struct mixer_operations *mixer_devs[MAX_MIXER_DEV];
-int num_mixers;
-struct synth_operations *synth_devs[MAX_SYNTH_DEV+MAX_MIDI_DEV];
-int num_synths;
-struct midi_operations *midi_devs[MAX_MIDI_DEV];
-int num_midis;
-
 extern struct sound_timer_operations default_sound_timer;
-struct sound_timer_operations *sound_timer_devs[MAX_TIMER_DEV] = {
-	&default_sound_timer, NULL
-}; 
-int num_sound_timers = 1;
-#else
+
 extern struct audio_operations *audio_devs[MAX_AUDIO_DEV];
 extern int num_audiodevs;
 extern struct mixer_operations *mixer_devs[MAX_MIXER_DEV];
@@ -378,7 +364,6 @@
 extern int num_midis;
 extern struct sound_timer_operations * sound_timer_devs[MAX_TIMER_DEV];
 extern int num_sound_timers;
-#endif	/* _DEV_TABLE_C_ */
 
 extern int sound_map_buffer (int dev, struct dma_buffparms *dmap, buffmem_desc *info);
 void sound_timer_init (struct sound_lowlev_timer *t, char *name);
--- linux-2.6.18.noarch/sound/oss/cs4232.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4232.c	2007-06-05 17:44:14.000000000 -0400
@@ -408,7 +408,7 @@
 {
 	struct address_info *isapnpcfg;
 
-	isapnpcfg=(struct address_info*)kmalloc(sizeof(*isapnpcfg),GFP_KERNEL);
+	isapnpcfg = kmalloc(sizeof(*isapnpcfg),GFP_KERNEL);
 	if (!isapnpcfg)
 		return -ENOMEM;
 
--- linux-2.6.18.noarch/sound/oss/awe_wave.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/awe_wave.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,77 +0,0 @@
-/*
- * sound/awe_config.h
- *
- * Configuration of AWE32/SB32/AWE64 wave table synth driver.
- *   version 0.4.4; Jan. 4, 2000
- *
- * Copyright (C) 1996-1998 Takashi Iwai
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- * chorus & reverb effects send for FM chip: from 0 to 0xff
- * larger numbers often cause weird sounds.
- */
-
-#define DEF_FM_CHORUS_DEPTH	0x10
-#define DEF_FM_REVERB_DEPTH	0x10
-
-
-/*
- * other compile conditions
- */
-
-/* initialize FM passthrough even without extended RAM */
-#undef AWE_ALWAYS_INIT_FM
-
-/* debug on */
-#define AWE_DEBUG_ON
-
-/* GUS compatible mode */
-#define AWE_HAS_GUS_COMPATIBILITY
-
-/* add MIDI emulation by wavetable */
-#define CONFIG_AWE32_MIDIEMU
-
-/* add mixer control of emu8000 equalizer */
-#undef CONFIG_AWE32_MIXER
-
-/* use new volume calculation method as default */
-#define AWE_USE_NEW_VOLUME_CALC
-
-/* check current volume target for searching empty voices */
-#define AWE_CHECK_VTARGET
-
-/* allow sample sharing */
-#define AWE_ALLOW_SAMPLE_SHARING
-
-/*
- * AWE32 card configuration:
- * uncomment the following lines *ONLY* when auto detection doesn't
- * work properly on your machine.
- */
-
-/*#define AWE_DEFAULT_BASE_ADDR	0x620*/	/* base port address */
-/*#define AWE_DEFAULT_MEM_SIZE	512*/	/* kbytes */
-
-/*
- * AWE driver version number
- */
-#define AWE_MAJOR_VERSION	0
-#define AWE_MINOR_VERSION	4
-#define AWE_TINY_VERSION	4
-#define AWE_VERSION_NUMBER	((AWE_MAJOR_VERSION<<16)|(AWE_MINOR_VERSION<<8)|AWE_TINY_VERSION)
-#define AWEDRV_VERSION		"0.4.4"
--- linux-2.6.18.noarch/sound/oss/ymfpci_image.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ymfpci_image.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,1565 +0,0 @@
-#ifndef _HWMCODE_
-#define _HWMCODE_
-
-static u32 DspInst[YDSXG_DSPLENGTH / 4] = {
-	0x00000081, 0x000001a4, 0x0000000a, 0x0000002f,
-	0x00080253, 0x01800317, 0x0000407b, 0x0000843f,
-	0x0001483c, 0x0001943c, 0x0005d83c, 0x00001c3c,
-	0x0000c07b, 0x00050c3f, 0x0121503c, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000
-};
-
-static u32 CntrlInst[YDSXG_CTRLLENGTH / 4] = {
-	0x000007, 0x240007, 0x0C0007, 0x1C0007,
-	0x060007, 0x700002, 0x000020, 0x030040,
-	0x007104, 0x004286, 0x030040, 0x000F0D,
-	0x000810, 0x20043A, 0x000282, 0x00020D,
-	0x000810, 0x20043A, 0x001282, 0x200E82,
-	0x001A82, 0x032D0D, 0x000810, 0x10043A,
-	0x02D38D, 0x000810, 0x18043A, 0x00010D,
-	0x020015, 0x0000FD, 0x000020, 0x038860,
-	0x039060, 0x038060, 0x038040, 0x038040,
-	0x038040, 0x018040, 0x000A7D, 0x038040,
-	0x038040, 0x018040, 0x200402, 0x000882,
-	0x08001A, 0x000904, 0x015986, 0x000007,
-	0x260007, 0x000007, 0x000007, 0x018A06,
-	0x000007, 0x030C8D, 0x000810, 0x18043A,
-	0x260007, 0x00087D, 0x018042, 0x00160A,
-	0x04A206, 0x000007, 0x00218D, 0x000810,
-	0x08043A, 0x21C206, 0x000007, 0x0007FD,
-	0x018042, 0x08000A, 0x000904, 0x029386,
-	0x000195, 0x090D04, 0x000007, 0x000820,
-	0x0000F5, 0x000B7D, 0x01F060, 0x0000FD,
-	0x032206, 0x018040, 0x000A7D, 0x038042,
-	0x13804A, 0x18000A, 0x001820, 0x059060,
-	0x058860, 0x018040, 0x0000FD, 0x018042,
-	0x70000A, 0x000115, 0x071144, 0x032386,
-	0x030000, 0x007020, 0x034A06, 0x018040,
-	0x00348D, 0x000810, 0x08043A, 0x21EA06,
-	0x000007, 0x02D38D, 0x000810, 0x18043A,
-	0x018206, 0x000007, 0x240007, 0x000F8D,
-	0x000810, 0x00163A, 0x002402, 0x005C02,
-	0x0028FD, 0x000020, 0x018040, 0x08000D,
-	0x000815, 0x510984, 0x000007, 0x00004D,
-	0x000E5D, 0x000E02, 0x00418D, 0x000810,
-	0x08043A, 0x2C8A06, 0x000007, 0x00008D,
-	0x000924, 0x000F02, 0x00458D, 0x000810,
-	0x08043A, 0x2C8A06, 0x000007, 0x00387D,
-	0x018042, 0x08000A, 0x001015, 0x010984,
-	0x018386, 0x000007, 0x01AA06, 0x000007,
-	0x0008FD, 0x018042, 0x18000A, 0x001904,
-	0x218086, 0x280007, 0x001810, 0x28043A,
-	0x280C02, 0x00000D, 0x000810, 0x28143A,
-	0x08808D, 0x000820, 0x0002FD, 0x018040,
-	0x200007, 0x00020D, 0x189904, 0x000007,
-	0x00402D, 0x0000BD, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x055A86, 0x000007,
-	0x000100, 0x000A20, 0x00047D, 0x018040,
-	0x018042, 0x20000A, 0x003015, 0x012144,
-	0x034986, 0x000007, 0x002104, 0x034986,
-	0x000007, 0x000F8D, 0x000810, 0x280C3A,
-	0x023944, 0x06C986, 0x000007, 0x001810,
-	0x28043A, 0x08810D, 0x000820, 0x0002FD,
-	0x018040, 0x200007, 0x002810, 0x78003A,
-	0x00688D, 0x000810, 0x08043A, 0x288A06,
-	0x000007, 0x00400D, 0x001015, 0x189904,
-	0x292904, 0x393904, 0x000007, 0x060206,
-	0x000007, 0x0004F5, 0x00007D, 0x000020,
-	0x00008D, 0x010860, 0x018040, 0x00047D,
-	0x038042, 0x21804A, 0x18000A, 0x021944,
-	0x215886, 0x000007, 0x004075, 0x71F104,
-	0x000007, 0x010042, 0x28000A, 0x002904,
-	0x212086, 0x000007, 0x003C0D, 0x30A904,
-	0x000007, 0x00077D, 0x018042, 0x08000A,
-	0x000904, 0x07DA86, 0x00057D, 0x002820,
-	0x03B060, 0x07F206, 0x018040, 0x003020,
-	0x03A860, 0x018040, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x07FA86, 0x000007,
-	0x00057D, 0x018042, 0x28040A, 0x000E8D,
-	0x000810, 0x280C3A, 0x00000D, 0x000810,
-	0x28143A, 0x09000D, 0x000820, 0x0002FD,
-	0x018040, 0x200007, 0x003DFD, 0x000020,
-	0x018040, 0x00107D, 0x008D8D, 0x000810,
-	0x08043A, 0x288A06, 0x000007, 0x000815,
-	0x08001A, 0x010984, 0x095186, 0x00137D,
-	0x200500, 0x280F20, 0x338F60, 0x3B8F60,
-	0x438F60, 0x4B8F60, 0x538F60, 0x5B8F60,
-	0x038A60, 0x018040, 0x007FBD, 0x383DC4,
-	0x000007, 0x001A7D, 0x001375, 0x018042,
-	0x09004A, 0x10000A, 0x0B8D04, 0x139504,
-	0x000007, 0x000820, 0x019060, 0x001104,
-	0x212086, 0x010040, 0x0017FD, 0x018042,
-	0x08000A, 0x000904, 0x212286, 0x000007,
-	0x00197D, 0x038042, 0x09804A, 0x10000A,
-	0x000924, 0x001664, 0x0011FD, 0x038042,
-	0x2B804A, 0x19804A, 0x00008D, 0x218944,
-	0x000007, 0x002244, 0x0AE186, 0x000007,
-	0x001A64, 0x002A24, 0x00197D, 0x080102,
-	0x100122, 0x000820, 0x039060, 0x018040,
-	0x003DFD, 0x00008D, 0x000820, 0x018040,
-	0x001375, 0x001A7D, 0x010042, 0x09804A,
-	0x10000A, 0x00021D, 0x0189E4, 0x2992E4,
-	0x309144, 0x000007, 0x00060D, 0x000A15,
-	0x000C1D, 0x001025, 0x00A9E4, 0x012BE4,
-	0x000464, 0x01B3E4, 0x0232E4, 0x000464,
-	0x000464, 0x000464, 0x000464, 0x00040D,
-	0x08B1C4, 0x000007, 0x000820, 0x000BF5,
-	0x030040, 0x00197D, 0x038042, 0x09804A,
-	0x000A24, 0x08000A, 0x080E64, 0x000007,
-	0x100122, 0x000820, 0x031060, 0x010040,
-	0x0064AC, 0x00027D, 0x000020, 0x018040,
-	0x00107D, 0x018042, 0x0011FD, 0x3B804A,
-	0x09804A, 0x20000A, 0x000095, 0x1A1144,
-	0x00A144, 0x0D2086, 0x00040D, 0x00B984,
-	0x0D2186, 0x0018FD, 0x018042, 0x0010FD,
-	0x09804A, 0x28000A, 0x000095, 0x010924,
-	0x002A64, 0x0D1186, 0x000007, 0x002904,
-	0x0D2286, 0x000007, 0x0D2A06, 0x080002,
-	0x00008D, 0x00387D, 0x000820, 0x018040,
-	0x00127D, 0x018042, 0x10000A, 0x003904,
-	0x0DD186, 0x00080D, 0x7FFFB5, 0x00B984,
-	0x0DA186, 0x000025, 0x0E7A06, 0x00002D,
-	0x000015, 0x00082D, 0x02C78D, 0x000820,
-	0x0EC206, 0x00000D, 0x7F8035, 0x00B984,
-	0x0E7186, 0x400025, 0x00008D, 0x110944,
-	0x000007, 0x00018D, 0x109504, 0x000007,
-	0x009164, 0x000424, 0x000424, 0x000424,
-	0x100102, 0x280002, 0x02C68D, 0x000820,
-	0x0EC206, 0x00018D, 0x00042D, 0x00008D,
-	0x109504, 0x000007, 0x00020D, 0x109184,
-	0x000007, 0x02C70D, 0x000820, 0x00008D,
-	0x0038FD, 0x018040, 0x003BFD, 0x001020,
-	0x03A860, 0x000815, 0x313184, 0x212184,
-	0x000007, 0x03B060, 0x03A060, 0x018040,
-	0x0022FD, 0x000095, 0x010924, 0x000424,
-	0x000424, 0x001264, 0x100102, 0x000820,
-	0x039060, 0x018040, 0x001924, 0x00FB8D,
-	0x00397D, 0x000820, 0x058040, 0x038042,
-	0x09844A, 0x000606, 0x08040A, 0x000424,
-	0x000424, 0x00117D, 0x018042, 0x08000A,
-	0x000A24, 0x280502, 0x280C02, 0x09800D,
-	0x000820, 0x0002FD, 0x018040, 0x200007,
-	0x0022FD, 0x018042, 0x08000A, 0x000095,
-	0x280DC4, 0x011924, 0x00197D, 0x018042,
-	0x0011FD, 0x09804A, 0x10000A, 0x0000B5,
-	0x113144, 0x0A8D04, 0x000007, 0x080A44,
-	0x129504, 0x000007, 0x0023FD, 0x001020,
-	0x038040, 0x101244, 0x000007, 0x000820,
-	0x039060, 0x018040, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x10FA86, 0x000007,
-	0x003BFD, 0x000100, 0x000A10, 0x0B807A,
-	0x13804A, 0x090984, 0x000007, 0x000095,
-	0x013D04, 0x118086, 0x10000A, 0x100002,
-	0x090984, 0x000007, 0x038042, 0x11804A,
-	0x090D04, 0x000007, 0x10000A, 0x090D84,
-	0x000007, 0x00257D, 0x000820, 0x018040,
-	0x00010D, 0x000810, 0x28143A, 0x00127D,
-	0x018042, 0x20000A, 0x00197D, 0x018042,
-	0x00117D, 0x31804A, 0x10000A, 0x003124,
-	0x01280D, 0x00397D, 0x000820, 0x058040,
-	0x038042, 0x09844A, 0x000606, 0x08040A,
-	0x300102, 0x003124, 0x000424, 0x000424,
-	0x001224, 0x280502, 0x001A4C, 0x130186,
-	0x700002, 0x00002D, 0x030000, 0x00387D,
-	0x018042, 0x10000A, 0x132A06, 0x002124,
-	0x0000AD, 0x100002, 0x00010D, 0x000924,
-	0x006B24, 0x01368D, 0x00397D, 0x000820,
-	0x058040, 0x038042, 0x09844A, 0x000606,
-	0x08040A, 0x003264, 0x00008D, 0x000A24,
-	0x001020, 0x00227D, 0x018040, 0x013C0D,
-	0x000810, 0x08043A, 0x29D206, 0x000007,
-	0x002820, 0x00207D, 0x018040, 0x00117D,
-	0x038042, 0x13804A, 0x33800A, 0x00387D,
-	0x018042, 0x08000A, 0x000904, 0x163A86,
-	0x000007, 0x00008D, 0x030964, 0x01478D,
-	0x00397D, 0x000820, 0x058040, 0x038042,
-	0x09844A, 0x000606, 0x08040A, 0x380102,
-	0x000424, 0x000424, 0x001224, 0x0002FD,
-	0x018042, 0x08000A, 0x000904, 0x14A286,
-	0x000007, 0x280502, 0x001A4C, 0x163986,
-	0x000007, 0x032164, 0x00632C, 0x003DFD,
-	0x018042, 0x08000A, 0x000095, 0x090904,
-	0x000007, 0x000820, 0x001A4C, 0x156186,
-	0x018040, 0x030000, 0x157A06, 0x002124,
-	0x00010D, 0x000924, 0x006B24, 0x015B8D,
-	0x00397D, 0x000820, 0x058040, 0x038042,
-	0x09844A, 0x000606, 0x08040A, 0x003A64,
-	0x000095, 0x001224, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x15DA86, 0x000007,
-	0x01628D, 0x000810, 0x08043A, 0x29D206,
-	0x000007, 0x14D206, 0x000007, 0x007020,
-	0x08010A, 0x10012A, 0x0020FD, 0x038860,
-	0x039060, 0x018040, 0x00227D, 0x018042,
-	0x003DFD, 0x08000A, 0x31844A, 0x000904,
-	0x16D886, 0x18008B, 0x00008D, 0x189904,
-	0x00312C, 0x17AA06, 0x000007, 0x00324C,
-	0x173386, 0x000007, 0x001904, 0x173086,
-	0x000007, 0x000095, 0x199144, 0x00222C,
-	0x003124, 0x00636C, 0x000E3D, 0x001375,
-	0x000BFD, 0x010042, 0x09804A, 0x10000A,
-	0x038AEC, 0x0393EC, 0x00224C, 0x17A986,
-	0x000007, 0x00008D, 0x189904, 0x00226C,
-	0x00322C, 0x30050A, 0x301DAB, 0x002083,
-	0x0018FD, 0x018042, 0x08000A, 0x018924,
-	0x300502, 0x001083, 0x001875, 0x010042,
-	0x10000A, 0x00008D, 0x010924, 0x001375,
-	0x330542, 0x330CCB, 0x332CCB, 0x3334CB,
-	0x333CCB, 0x3344CB, 0x334CCB, 0x3354CB,
-	0x305C8B, 0x006083, 0x0002F5, 0x010042,
-	0x08000A, 0x000904, 0x187A86, 0x000007,
-	0x001E2D, 0x0005FD, 0x018042, 0x08000A,
-	0x028924, 0x280502, 0x00060D, 0x000810,
-	0x280C3A, 0x00008D, 0x000810, 0x28143A,
-	0x0A808D, 0x000820, 0x0002F5, 0x010040,
-	0x220007, 0x001275, 0x030042, 0x21004A,
-	0x00008D, 0x1A0944, 0x000007, 0x01980D,
-	0x000810, 0x08043A, 0x2B2206, 0x000007,
-	0x0001F5, 0x030042, 0x0D004A, 0x10000A,
-	0x089144, 0x000007, 0x000820, 0x010040,
-	0x0025F5, 0x0A3144, 0x000007, 0x000820,
-	0x032860, 0x030040, 0x00217D, 0x038042,
-	0x0B804A, 0x10000A, 0x000820, 0x031060,
-	0x030040, 0x00008D, 0x000124, 0x00012C,
-	0x000E64, 0x001A64, 0x00636C, 0x08010A,
-	0x10012A, 0x000820, 0x031060, 0x030040,
-	0x0020FD, 0x018042, 0x08000A, 0x00227D,
-	0x018042, 0x10000A, 0x000820, 0x031060,
-	0x030040, 0x00197D, 0x018042, 0x08000A,
-	0x0022FD, 0x038042, 0x10000A, 0x000820,
-	0x031060, 0x030040, 0x090D04, 0x000007,
-	0x000820, 0x030040, 0x038042, 0x0B804A,
-	0x10000A, 0x000820, 0x031060, 0x030040,
-	0x038042, 0x13804A, 0x19804A, 0x110D04,
-	0x198D04, 0x000007, 0x08000A, 0x001020,
-	0x031860, 0x030860, 0x030040, 0x00008D,
-	0x0B0944, 0x000007, 0x000820, 0x010040,
-	0x0005F5, 0x030042, 0x08000A, 0x000820,
-	0x010040, 0x0000F5, 0x010042, 0x08000A,
-	0x000904, 0x1C6086, 0x001E75, 0x030042,
-	0x01044A, 0x000C0A, 0x1C7206, 0x000007,
-	0x000402, 0x000C02, 0x00177D, 0x001AF5,
-	0x018042, 0x03144A, 0x031C4A, 0x03244A,
-	0x032C4A, 0x03344A, 0x033C4A, 0x03444A,
-	0x004C0A, 0x00043D, 0x0013F5, 0x001AFD,
-	0x030042, 0x0B004A, 0x1B804A, 0x13804A,
-	0x20000A, 0x089144, 0x19A144, 0x0389E4,
-	0x0399EC, 0x005502, 0x005D0A, 0x030042,
-	0x0B004A, 0x1B804A, 0x13804A, 0x20000A,
-	0x089144, 0x19A144, 0x0389E4, 0x0399EC,
-	0x006502, 0x006D0A, 0x030042, 0x0B004A,
-	0x19004A, 0x2B804A, 0x13804A, 0x21804A,
-	0x30000A, 0x089144, 0x19A144, 0x2AB144,
-	0x0389E4, 0x0399EC, 0x007502, 0x007D0A,
-	0x03A9E4, 0x000702, 0x00107D, 0x000415,
-	0x018042, 0x08000A, 0x0109E4, 0x000F02,
-	0x002AF5, 0x0019FD, 0x010042, 0x09804A,
-	0x10000A, 0x000934, 0x001674, 0x0029F5,
-	0x010042, 0x10000A, 0x00917C, 0x002075,
-	0x010042, 0x08000A, 0x000904, 0x1ED286,
-	0x0026F5, 0x0027F5, 0x030042, 0x09004A,
-	0x10000A, 0x000A3C, 0x00167C, 0x001A75,
-	0x000BFD, 0x010042, 0x51804A, 0x48000A,
-	0x160007, 0x001075, 0x010042, 0x282C0A,
-	0x281D12, 0x282512, 0x001F32, 0x1E0007,
-	0x0E0007, 0x001975, 0x010042, 0x002DF5,
-	0x0D004A, 0x10000A, 0x009144, 0x1FB286,
-	0x010042, 0x28340A, 0x000E5D, 0x00008D,
-	0x000375, 0x000820, 0x010040, 0x05D2F4,
-	0x54D104, 0x00735C, 0x205386, 0x000007,
-	0x0C0007, 0x080007, 0x0A0007, 0x02040D,
-	0x000810, 0x08043A, 0x332206, 0x000007,
-	0x205A06, 0x000007, 0x080007, 0x002275,
-	0x010042, 0x20000A, 0x002104, 0x212086,
-	0x001E2D, 0x0002F5, 0x010042, 0x08000A,
-	0x000904, 0x209286, 0x000007, 0x002010,
-	0x30043A, 0x00057D, 0x0180C3, 0x08000A,
-	0x028924, 0x280502, 0x280C02, 0x0A810D,
-	0x000820, 0x0002F5, 0x010040, 0x220007,
-	0x0004FD, 0x018042, 0x70000A, 0x030000,
-	0x007020, 0x06FA06, 0x018040, 0x02180D,
-	0x000810, 0x08043A, 0x2B2206, 0x000007,
-	0x0002FD, 0x018042, 0x08000A, 0x000904,
-	0x218A86, 0x000007, 0x01F206, 0x000007,
-	0x000875, 0x0009FD, 0x00010D, 0x220A06,
-	0x000295, 0x000B75, 0x00097D, 0x00000D,
-	0x000515, 0x010042, 0x18000A, 0x001904,
-	0x287886, 0x0006F5, 0x001020, 0x010040,
-	0x0004F5, 0x000820, 0x010040, 0x000775,
-	0x010042, 0x09804A, 0x10000A, 0x001124,
-	0x000904, 0x22BA86, 0x000815, 0x080102,
-	0x101204, 0x22DA06, 0x000575, 0x081204,
-	0x000007, 0x100102, 0x000575, 0x000425,
-	0x021124, 0x100102, 0x000820, 0x031060,
-	0x010040, 0x001924, 0x287886, 0x00008D,
-	0x000464, 0x009D04, 0x278886, 0x180102,
-	0x000575, 0x010042, 0x28040A, 0x00018D,
-	0x000924, 0x280D02, 0x00000D, 0x000924,
-	0x281502, 0x10000D, 0x000820, 0x0002F5,
-	0x010040, 0x200007, 0x001175, 0x0002FD,
-	0x018042, 0x08000A, 0x000904, 0x23C286,
-	0x000007, 0x000100, 0x080B20, 0x130B60,
-	0x1B0B60, 0x030A60, 0x010040, 0x050042,
-	0x3D004A, 0x35004A, 0x2D004A, 0x20000A,
-	0x0006F5, 0x010042, 0x28140A, 0x0004F5,
-	0x010042, 0x08000A, 0x000315, 0x010D04,
-	0x24CA86, 0x004015, 0x000095, 0x010D04,
-	0x24B886, 0x100022, 0x10002A, 0x24E206,
-	0x000007, 0x333104, 0x2AA904, 0x000007,
-	0x032124, 0x280502, 0x001124, 0x000424,
-	0x000424, 0x003224, 0x00292C, 0x00636C,
-	0x25F386, 0x000007, 0x02B164, 0x000464,
-	0x000464, 0x00008D, 0x000A64, 0x280D02,
-	0x10008D, 0x000820, 0x0002F5, 0x010040,
-	0x220007, 0x00008D, 0x38B904, 0x000007,
-	0x03296C, 0x30010A, 0x0002F5, 0x010042,
-	0x08000A, 0x000904, 0x25BA86, 0x000007,
-	0x02312C, 0x28050A, 0x00008D, 0x01096C,
-	0x280D0A, 0x10010D, 0x000820, 0x0002F5,
-	0x010040, 0x220007, 0x001124, 0x000424,
-	0x000424, 0x003224, 0x300102, 0x032944,
-	0x267A86, 0x000007, 0x300002, 0x0004F5,
-	0x010042, 0x08000A, 0x000315, 0x010D04,
-	0x26C086, 0x003124, 0x000464, 0x300102,
-	0x0002F5, 0x010042, 0x08000A, 0x000904,
-	0x26CA86, 0x000007, 0x003124, 0x300502,
-	0x003924, 0x300583, 0x000883, 0x0005F5,
-	0x010042, 0x28040A, 0x00008D, 0x008124,
-	0x280D02, 0x00008D, 0x008124, 0x281502,
-	0x10018D, 0x000820, 0x0002F5, 0x010040,
-	0x220007, 0x001025, 0x000575, 0x030042,
-	0x09004A, 0x10000A, 0x0A0904, 0x121104,
-	0x000007, 0x001020, 0x050860, 0x050040,
-	0x0006FD, 0x018042, 0x09004A, 0x10000A,
-	0x0000A5, 0x0A0904, 0x121104, 0x000007,
-	0x000820, 0x019060, 0x010040, 0x0002F5,
-	0x010042, 0x08000A, 0x000904, 0x284286,
-	0x000007, 0x230A06, 0x000007, 0x000606,
-	0x000007, 0x0002F5, 0x010042, 0x08000A,
-	0x000904, 0x289286, 0x000007, 0x000100,
-	0x080B20, 0x138B60, 0x1B8B60, 0x238B60,
-	0x2B8B60, 0x338B60, 0x3B8B60, 0x438B60,
-	0x4B8B60, 0x538B60, 0x5B8B60, 0x638B60,
-	0x6B8B60, 0x738B60, 0x7B8B60, 0x038F60,
-	0x0B8F60, 0x138F60, 0x1B8F60, 0x238F60,
-	0x2B8F60, 0x338F60, 0x3B8F60, 0x438F60,
-	0x4B8F60, 0x538F60, 0x5B8F60, 0x638F60,
-	0x6B8F60, 0x738F60, 0x7B8F60, 0x038A60,
-	0x000606, 0x018040, 0x00008D, 0x000A64,
-	0x280D02, 0x000A24, 0x00027D, 0x018042,
-	0x10000A, 0x001224, 0x0003FD, 0x018042,
-	0x08000A, 0x000904, 0x2A8286, 0x000007,
-	0x00018D, 0x000A24, 0x000464, 0x000464,
-	0x080102, 0x000924, 0x000424, 0x000424,
-	0x100102, 0x02000D, 0x009144, 0x2AD986,
-	0x000007, 0x0001FD, 0x018042, 0x08000A,
-	0x000A44, 0x2ABB86, 0x018042, 0x0A000D,
-	0x000820, 0x0002FD, 0x018040, 0x200007,
-	0x00027D, 0x001020, 0x000606, 0x018040,
-	0x0002F5, 0x010042, 0x08000A, 0x000904,
-	0x2B2A86, 0x000007, 0x00037D, 0x018042,
-	0x08000A, 0x000904, 0x2B5A86, 0x000007,
-	0x000075, 0x002E7D, 0x010042, 0x0B804A,
-	0x000020, 0x000904, 0x000686, 0x010040,
-	0x31844A, 0x30048B, 0x000883, 0x00008D,
-	0x000810, 0x28143A, 0x00008D, 0x000810,
-	0x280C3A, 0x000675, 0x010042, 0x08000A,
-	0x003815, 0x010924, 0x280502, 0x0B000D,
-	0x000820, 0x0002F5, 0x010040, 0x000606,
-	0x220007, 0x000464, 0x000464, 0x000606,
-	0x000007, 0x000134, 0x007F8D, 0x00093C,
-	0x281D12, 0x282512, 0x001F32, 0x0E0007,
-	0x00010D, 0x00037D, 0x000820, 0x018040,
-	0x05D2F4, 0x000007, 0x080007, 0x00037D,
-	0x018042, 0x08000A, 0x000904, 0x2D0286,
-	0x000007, 0x000606, 0x000007, 0x000007,
-	0x000012, 0x100007, 0x320007, 0x600007,
-	0x100080, 0x48001A, 0x004904, 0x2D6186,
-	0x000007, 0x001210, 0x58003A, 0x000145,
-	0x5C5D04, 0x000007, 0x000080, 0x48001A,
-	0x004904, 0x2DB186, 0x000007, 0x001210,
-	0x50003A, 0x005904, 0x2E0886, 0x000045,
-	0x0000C5, 0x7FFFF5, 0x7FFF7D, 0x07D524,
-	0x004224, 0x500102, 0x200502, 0x000082,
-	0x40001A, 0x004104, 0x2E3986, 0x000007,
-	0x003865, 0x40001A, 0x004020, 0x00104D,
-	0x04C184, 0x301B86, 0x000040, 0x040007,
-	0x000165, 0x000145, 0x004020, 0x000040,
-	0x000765, 0x080080, 0x40001A, 0x004104,
-	0x2EC986, 0x000007, 0x001210, 0x40003A,
-	0x004104, 0x2F2286, 0x00004D, 0x0000CD,
-	0x004810, 0x20043A, 0x000882, 0x40001A,
-	0x004104, 0x2F3186, 0x000007, 0x004820,
-	0x005904, 0x300886, 0x000040, 0x0007E5,
-	0x200480, 0x2816A0, 0x3216E0, 0x3A16E0,
-	0x4216E0, 0x021260, 0x000040, 0x000032,
-	0x400075, 0x00007D, 0x07D574, 0x200512,
-	0x000082, 0x40001A, 0x004104, 0x2FE186,
-	0x000007, 0x037206, 0x640007, 0x060007,
-	0x0000E5, 0x000020, 0x000040, 0x000A65,
-	0x000020, 0x020040, 0x020040, 0x000040,
-	0x000165, 0x000042, 0x70000A, 0x007104,
-	0x30A286, 0x000007, 0x018206, 0x640007,
-	0x050000, 0x007020, 0x000040, 0x037206,
-	0x640007, 0x000007, 0x00306D, 0x028860,
-	0x029060, 0x08000A, 0x028860, 0x008040,
-	0x100012, 0x00100D, 0x009184, 0x314186,
-	0x000E0D, 0x009184, 0x325186, 0x000007,
-	0x300007, 0x001020, 0x003B6D, 0x008040,
-	0x000080, 0x08001A, 0x000904, 0x316186,
-	0x000007, 0x001220, 0x000DED, 0x008040,
-	0x008042, 0x10000A, 0x40000D, 0x109544,
-	0x000007, 0x001020, 0x000DED, 0x008040,
-	0x008042, 0x20040A, 0x000082, 0x08001A,
-	0x000904, 0x31F186, 0x000007, 0x003B6D,
-	0x008042, 0x08000A, 0x000E15, 0x010984,
-	0x329B86, 0x600007, 0x08001A, 0x000C15,
-	0x010984, 0x328386, 0x000020, 0x1A0007,
-	0x0002ED, 0x008040, 0x620007, 0x00306D,
-	0x028042, 0x0A804A, 0x000820, 0x0A804A,
-	0x000606, 0x10804A, 0x000007, 0x282512,
-	0x001F32, 0x05D2F4, 0x54D104, 0x00735C,
-	0x000786, 0x000007, 0x0C0007, 0x0A0007,
-	0x1C0007, 0x003465, 0x020040, 0x004820,
-	0x025060, 0x40000A, 0x024060, 0x000040,
-	0x454944, 0x000007, 0x004020, 0x003AE5,
-	0x000040, 0x0028E5, 0x000042, 0x48000A,
-	0x004904, 0x386886, 0x002C65, 0x000042,
-	0x40000A, 0x0000D5, 0x454104, 0x000007,
-	0x000655, 0x054504, 0x34F286, 0x0001D5,
-	0x054504, 0x34F086, 0x002B65, 0x000042,
-	0x003AE5, 0x50004A, 0x40000A, 0x45C3D4,
-	0x000007, 0x454504, 0x000007, 0x0000CD,
-	0x444944, 0x000007, 0x454504, 0x000007,
-	0x00014D, 0x554944, 0x000007, 0x045144,
-	0x34E986, 0x002C65, 0x000042, 0x48000A,
-	0x4CD104, 0x000007, 0x04C144, 0x34F386,
-	0x000007, 0x160007, 0x002CE5, 0x040042,
-	0x40000A, 0x004020, 0x000040, 0x002965,
-	0x000042, 0x40000A, 0x004104, 0x356086,
-	0x000007, 0x002402, 0x36A206, 0x005C02,
-	0x0025E5, 0x000042, 0x40000A, 0x004274,
-	0x002AE5, 0x000042, 0x40000A, 0x004274,
-	0x500112, 0x0029E5, 0x000042, 0x40000A,
-	0x004234, 0x454104, 0x000007, 0x004020,
-	0x000040, 0x003EE5, 0x000020, 0x000040,
-	0x002DE5, 0x400152, 0x50000A, 0x045144,
-	0x364A86, 0x0000C5, 0x003EE5, 0x004020,
-	0x000040, 0x002BE5, 0x000042, 0x40000A,
-	0x404254, 0x000007, 0x002AE5, 0x004020,
-	0x000040, 0x500132, 0x040134, 0x005674,
-	0x0029E5, 0x020042, 0x42000A, 0x000042,
-	0x50000A, 0x05417C, 0x0028E5, 0x000042,
-	0x48000A, 0x0000C5, 0x4CC144, 0x371086,
-	0x0026E5, 0x0027E5, 0x020042, 0x40004A,
-	0x50000A, 0x00423C, 0x00567C, 0x0028E5,
-	0x004820, 0x000040, 0x281D12, 0x282512,
-	0x001F72, 0x002965, 0x000042, 0x40000A,
-	0x004104, 0x37AA86, 0x0E0007, 0x160007,
-	0x1E0007, 0x003EE5, 0x000042, 0x40000A,
-	0x004104, 0x37E886, 0x002D65, 0x000042,
-	0x28340A, 0x003465, 0x020042, 0x42004A,
-	0x004020, 0x4A004A, 0x50004A, 0x05D2F4,
-	0x54D104, 0x00735C, 0x385186, 0x000007,
-	0x000606, 0x080007, 0x0C0007, 0x080007,
-	0x0A0007, 0x0001E5, 0x020045, 0x004020,
-	0x000060, 0x000365, 0x000040, 0x002E65,
-	0x001A20, 0x0A1A60, 0x000040, 0x003465,
-	0x020042, 0x42004A, 0x004020, 0x4A004A,
-	0x000606, 0x50004A, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000
-};
-
-// --------------------------------------------
-//  DS-1E Controller InstructionRAM Code
-//	1999/06/21
-//	Buf441 slot is Enabled.
-// --------------------------------------------
-// 04/09  creat
-// 04/12  stop nise fix
-// 06/21  WorkingOff timming
-static u32 CntrlInst1E[YDSXG_CTRLLENGTH / 4] = {
-	0x000007, 0x240007, 0x0C0007, 0x1C0007,
-	0x060007, 0x700002, 0x000020, 0x030040,
-	0x007104, 0x004286, 0x030040, 0x000F0D,
-	0x000810, 0x20043A, 0x000282, 0x00020D,
-	0x000810, 0x20043A, 0x001282, 0x200E82,
-	0x00800D, 0x000810, 0x20043A, 0x001A82,
-	0x03460D, 0x000810, 0x10043A, 0x02EC0D,
-	0x000810, 0x18043A, 0x00010D, 0x020015,
-	0x0000FD, 0x000020, 0x038860, 0x039060,
-	0x038060, 0x038040, 0x038040, 0x038040,
-	0x018040, 0x000A7D, 0x038040, 0x038040,
-	0x018040, 0x200402, 0x000882, 0x08001A,
-	0x000904, 0x017186, 0x000007, 0x260007,
-	0x400007, 0x000007, 0x03258D, 0x000810,
-	0x18043A, 0x260007, 0x284402, 0x00087D,
-	0x018042, 0x00160A, 0x05A206, 0x000007,
-	0x440007, 0x00230D, 0x000810, 0x08043A,
-	0x22FA06, 0x000007, 0x0007FD, 0x018042,
-	0x08000A, 0x000904, 0x02AB86, 0x000195,
-	0x090D04, 0x000007, 0x000820, 0x0000F5,
-	0x000B7D, 0x01F060, 0x0000FD, 0x033A06,
-	0x018040, 0x000A7D, 0x038042, 0x13804A,
-	0x18000A, 0x001820, 0x059060, 0x058860,
-	0x018040, 0x0000FD, 0x018042, 0x70000A,
-	0x000115, 0x071144, 0x033B86, 0x030000,
-	0x007020, 0x036206, 0x018040, 0x00360D,
-	0x000810, 0x08043A, 0x232206, 0x000007,
-	0x02EC0D, 0x000810, 0x18043A, 0x019A06,
-	0x000007, 0x240007, 0x000F8D, 0x000810,
-	0x00163A, 0x002402, 0x005C02, 0x0028FD,
-	0x000020, 0x018040, 0x08000D, 0x000815,
-	0x510984, 0x000007, 0x00004D, 0x000E5D,
-	0x000E02, 0x00430D, 0x000810, 0x08043A,
-	0x2E1206, 0x000007, 0x00008D, 0x000924,
-	0x000F02, 0x00470D, 0x000810, 0x08043A,
-	0x2E1206, 0x000007, 0x480480, 0x001210,
-	0x28043A, 0x00778D, 0x000810, 0x280C3A,
-	0x00068D, 0x000810, 0x28143A, 0x284402,
-	0x03258D, 0x000810, 0x18043A, 0x07FF8D,
-	0x000820, 0x0002FD, 0x018040, 0x260007,
-	0x200007, 0x0002FD, 0x018042, 0x08000A,
-	0x000904, 0x051286, 0x000007, 0x240007,
-	0x02EC0D, 0x000810, 0x18043A, 0x00387D,
-	0x018042, 0x08000A, 0x001015, 0x010984,
-	0x019B86, 0x000007, 0x01B206, 0x000007,
-	0x0008FD, 0x018042, 0x18000A, 0x001904,
-	0x22B886, 0x280007, 0x001810, 0x28043A,
-	0x280C02, 0x00000D, 0x000810, 0x28143A,
-	0x08808D, 0x000820, 0x0002FD, 0x018040,
-	0x200007, 0x00020D, 0x189904, 0x000007,
-	0x00402D, 0x0000BD, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x065A86, 0x000007,
-	0x000100, 0x000A20, 0x00047D, 0x018040,
-	0x018042, 0x20000A, 0x003015, 0x012144,
-	0x036186, 0x000007, 0x002104, 0x036186,
-	0x000007, 0x000F8D, 0x000810, 0x280C3A,
-	0x023944, 0x07C986, 0x000007, 0x001810,
-	0x28043A, 0x08810D, 0x000820, 0x0002FD,
-	0x018040, 0x200007, 0x002810, 0x78003A,
-	0x00788D, 0x000810, 0x08043A, 0x2A1206,
-	0x000007, 0x00400D, 0x001015, 0x189904,
-	0x292904, 0x393904, 0x000007, 0x070206,
-	0x000007, 0x0004F5, 0x00007D, 0x000020,
-	0x00008D, 0x010860, 0x018040, 0x00047D,
-	0x038042, 0x21804A, 0x18000A, 0x021944,
-	0x229086, 0x000007, 0x004075, 0x71F104,
-	0x000007, 0x010042, 0x28000A, 0x002904,
-	0x225886, 0x000007, 0x003C0D, 0x30A904,
-	0x000007, 0x00077D, 0x018042, 0x08000A,
-	0x000904, 0x08DA86, 0x00057D, 0x002820,
-	0x03B060, 0x08F206, 0x018040, 0x003020,
-	0x03A860, 0x018040, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x08FA86, 0x000007,
-	0x00057D, 0x018042, 0x28040A, 0x000E8D,
-	0x000810, 0x280C3A, 0x00000D, 0x000810,
-	0x28143A, 0x09000D, 0x000820, 0x0002FD,
-	0x018040, 0x200007, 0x003DFD, 0x000020,
-	0x018040, 0x00107D, 0x009D8D, 0x000810,
-	0x08043A, 0x2A1206, 0x000007, 0x000815,
-	0x08001A, 0x010984, 0x0A5186, 0x00137D,
-	0x200500, 0x280F20, 0x338F60, 0x3B8F60,
-	0x438F60, 0x4B8F60, 0x538F60, 0x5B8F60,
-	0x038A60, 0x018040, 0x00107D, 0x018042,
-	0x08000A, 0x000215, 0x010984, 0x3A8186,
-	0x000007, 0x007FBD, 0x383DC4, 0x000007,
-	0x001A7D, 0x001375, 0x018042, 0x09004A,
-	0x10000A, 0x0B8D04, 0x139504, 0x000007,
-	0x000820, 0x019060, 0x001104, 0x225886,
-	0x010040, 0x0017FD, 0x018042, 0x08000A,
-	0x000904, 0x225A86, 0x000007, 0x00197D,
-	0x038042, 0x09804A, 0x10000A, 0x000924,
-	0x001664, 0x0011FD, 0x038042, 0x2B804A,
-	0x19804A, 0x00008D, 0x218944, 0x000007,
-	0x002244, 0x0C1986, 0x000007, 0x001A64,
-	0x002A24, 0x00197D, 0x080102, 0x100122,
-	0x000820, 0x039060, 0x018040, 0x003DFD,
-	0x00008D, 0x000820, 0x018040, 0x001375,
-	0x001A7D, 0x010042, 0x09804A, 0x10000A,
-	0x00021D, 0x0189E4, 0x2992E4, 0x309144,
-	0x000007, 0x00060D, 0x000A15, 0x000C1D,
-	0x001025, 0x00A9E4, 0x012BE4, 0x000464,
-	0x01B3E4, 0x0232E4, 0x000464, 0x000464,
-	0x000464, 0x000464, 0x00040D, 0x08B1C4,
-	0x000007, 0x000820, 0x000BF5, 0x030040,
-	0x00197D, 0x038042, 0x09804A, 0x000A24,
-	0x08000A, 0x080E64, 0x000007, 0x100122,
-	0x000820, 0x031060, 0x010040, 0x0064AC,
-	0x00027D, 0x000020, 0x018040, 0x00107D,
-	0x018042, 0x0011FD, 0x3B804A, 0x09804A,
-	0x20000A, 0x000095, 0x1A1144, 0x00A144,
-	0x0E5886, 0x00040D, 0x00B984, 0x0E5986,
-	0x0018FD, 0x018042, 0x0010FD, 0x09804A,
-	0x28000A, 0x000095, 0x010924, 0x002A64,
-	0x0E4986, 0x000007, 0x002904, 0x0E5A86,
-	0x000007, 0x0E6206, 0x080002, 0x00008D,
-	0x00387D, 0x000820, 0x018040, 0x00127D,
-	0x018042, 0x10000A, 0x003904, 0x0F0986,
-	0x00080D, 0x7FFFB5, 0x00B984, 0x0ED986,
-	0x000025, 0x0FB206, 0x00002D, 0x000015,
-	0x00082D, 0x02E00D, 0x000820, 0x0FFA06,
-	0x00000D, 0x7F8035, 0x00B984, 0x0FA986,
-	0x400025, 0x00008D, 0x110944, 0x000007,
-	0x00018D, 0x109504, 0x000007, 0x009164,
-	0x000424, 0x000424, 0x000424, 0x100102,
-	0x280002, 0x02DF0D, 0x000820, 0x0FFA06,
-	0x00018D, 0x00042D, 0x00008D, 0x109504,
-	0x000007, 0x00020D, 0x109184, 0x000007,
-	0x02DF8D, 0x000820, 0x00008D, 0x0038FD,
-	0x018040, 0x003BFD, 0x001020, 0x03A860,
-	0x000815, 0x313184, 0x212184, 0x000007,
-	0x03B060, 0x03A060, 0x018040, 0x0022FD,
-	0x000095, 0x010924, 0x000424, 0x000424,
-	0x001264, 0x100102, 0x000820, 0x039060,
-	0x018040, 0x001924, 0x010F0D, 0x00397D,
-	0x000820, 0x058040, 0x038042, 0x09844A,
-	0x000606, 0x08040A, 0x000424, 0x000424,
-	0x00117D, 0x018042, 0x08000A, 0x000A24,
-	0x280502, 0x280C02, 0x09800D, 0x000820,
-	0x0002FD, 0x018040, 0x200007, 0x0022FD,
-	0x018042, 0x08000A, 0x000095, 0x280DC4,
-	0x011924, 0x00197D, 0x018042, 0x0011FD,
-	0x09804A, 0x10000A, 0x0000B5, 0x113144,
-	0x0A8D04, 0x000007, 0x080A44, 0x129504,
-	0x000007, 0x0023FD, 0x001020, 0x038040,
-	0x101244, 0x000007, 0x000820, 0x039060,
-	0x018040, 0x0002FD, 0x018042, 0x08000A,
-	0x000904, 0x123286, 0x000007, 0x003BFD,
-	0x000100, 0x000A10, 0x0B807A, 0x13804A,
-	0x090984, 0x000007, 0x000095, 0x013D04,
-	0x12B886, 0x10000A, 0x100002, 0x090984,
-	0x000007, 0x038042, 0x11804A, 0x090D04,
-	0x000007, 0x10000A, 0x090D84, 0x000007,
-	0x00257D, 0x000820, 0x018040, 0x00010D,
-	0x000810, 0x28143A, 0x00127D, 0x018042,
-	0x20000A, 0x00197D, 0x018042, 0x00117D,
-	0x31804A, 0x10000A, 0x003124, 0x013B8D,
-	0x00397D, 0x000820, 0x058040, 0x038042,
-	0x09844A, 0x000606, 0x08040A, 0x300102,
-	0x003124, 0x000424, 0x000424, 0x001224,
-	0x280502, 0x001A4C, 0x143986, 0x700002,
-	0x00002D, 0x030000, 0x00387D, 0x018042,
-	0x10000A, 0x146206, 0x002124, 0x0000AD,
-	0x100002, 0x00010D, 0x000924, 0x006B24,
-	0x014A0D, 0x00397D, 0x000820, 0x058040,
-	0x038042, 0x09844A, 0x000606, 0x08040A,
-	0x003264, 0x00008D, 0x000A24, 0x001020,
-	0x00227D, 0x018040, 0x014F8D, 0x000810,
-	0x08043A, 0x2B5A06, 0x000007, 0x002820,
-	0x00207D, 0x018040, 0x00117D, 0x038042,
-	0x13804A, 0x33800A, 0x00387D, 0x018042,
-	0x08000A, 0x000904, 0x177286, 0x000007,
-	0x00008D, 0x030964, 0x015B0D, 0x00397D,
-	0x000820, 0x058040, 0x038042, 0x09844A,
-	0x000606, 0x08040A, 0x380102, 0x000424,
-	0x000424, 0x001224, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x15DA86, 0x000007,
-	0x280502, 0x001A4C, 0x177186, 0x000007,
-	0x032164, 0x00632C, 0x003DFD, 0x018042,
-	0x08000A, 0x000095, 0x090904, 0x000007,
-	0x000820, 0x001A4C, 0x169986, 0x018040,
-	0x030000, 0x16B206, 0x002124, 0x00010D,
-	0x000924, 0x006B24, 0x016F0D, 0x00397D,
-	0x000820, 0x058040, 0x038042, 0x09844A,
-	0x000606, 0x08040A, 0x003A64, 0x000095,
-	0x001224, 0x0002FD, 0x018042, 0x08000A,
-	0x000904, 0x171286, 0x000007, 0x01760D,
-	0x000810, 0x08043A, 0x2B5A06, 0x000007,
-	0x160A06, 0x000007, 0x007020, 0x08010A,
-	0x10012A, 0x0020FD, 0x038860, 0x039060,
-	0x018040, 0x00227D, 0x018042, 0x003DFD,
-	0x08000A, 0x31844A, 0x000904, 0x181086,
-	0x18008B, 0x00008D, 0x189904, 0x00312C,
-	0x18E206, 0x000007, 0x00324C, 0x186B86,
-	0x000007, 0x001904, 0x186886, 0x000007,
-	0x000095, 0x199144, 0x00222C, 0x003124,
-	0x00636C, 0x000E3D, 0x001375, 0x000BFD,
-	0x010042, 0x09804A, 0x10000A, 0x038AEC,
-	0x0393EC, 0x00224C, 0x18E186, 0x000007,
-	0x00008D, 0x189904, 0x00226C, 0x00322C,
-	0x30050A, 0x301DAB, 0x002083, 0x0018FD,
-	0x018042, 0x08000A, 0x018924, 0x300502,
-	0x001083, 0x001875, 0x010042, 0x10000A,
-	0x00008D, 0x010924, 0x001375, 0x330542,
-	0x330CCB, 0x332CCB, 0x3334CB, 0x333CCB,
-	0x3344CB, 0x334CCB, 0x3354CB, 0x305C8B,
-	0x006083, 0x0002F5, 0x010042, 0x08000A,
-	0x000904, 0x19B286, 0x000007, 0x001E2D,
-	0x0005FD, 0x018042, 0x08000A, 0x028924,
-	0x280502, 0x00060D, 0x000810, 0x280C3A,
-	0x00008D, 0x000810, 0x28143A, 0x0A808D,
-	0x000820, 0x0002F5, 0x010040, 0x220007,
-	0x001275, 0x030042, 0x21004A, 0x00008D,
-	0x1A0944, 0x000007, 0x01AB8D, 0x000810,
-	0x08043A, 0x2CAA06, 0x000007, 0x0001F5,
-	0x030042, 0x0D004A, 0x10000A, 0x089144,
-	0x000007, 0x000820, 0x010040, 0x0025F5,
-	0x0A3144, 0x000007, 0x000820, 0x032860,
-	0x030040, 0x00217D, 0x038042, 0x0B804A,
-	0x10000A, 0x000820, 0x031060, 0x030040,
-	0x00008D, 0x000124, 0x00012C, 0x000E64,
-	0x001A64, 0x00636C, 0x08010A, 0x10012A,
-	0x000820, 0x031060, 0x030040, 0x0020FD,
-	0x018042, 0x08000A, 0x00227D, 0x018042,
-	0x10000A, 0x000820, 0x031060, 0x030040,
-	0x00197D, 0x018042, 0x08000A, 0x0022FD,
-	0x038042, 0x10000A, 0x000820, 0x031060,
-	0x030040, 0x090D04, 0x000007, 0x000820,
-	0x030040, 0x038042, 0x0B804A, 0x10000A,
-	0x000820, 0x031060, 0x030040, 0x038042,
-	0x13804A, 0x19804A, 0x110D04, 0x198D04,
-	0x000007, 0x08000A, 0x001020, 0x031860,
-	0x030860, 0x030040, 0x00008D, 0x0B0944,
-	0x000007, 0x000820, 0x010040, 0x0005F5,
-	0x030042, 0x08000A, 0x000820, 0x010040,
-	0x0000F5, 0x010042, 0x08000A, 0x000904,
-	0x1D9886, 0x001E75, 0x030042, 0x01044A,
-	0x000C0A, 0x1DAA06, 0x000007, 0x000402,
-	0x000C02, 0x00177D, 0x001AF5, 0x018042,
-	0x03144A, 0x031C4A, 0x03244A, 0x032C4A,
-	0x03344A, 0x033C4A, 0x03444A, 0x004C0A,
-	0x00043D, 0x0013F5, 0x001AFD, 0x030042,
-	0x0B004A, 0x1B804A, 0x13804A, 0x20000A,
-	0x089144, 0x19A144, 0x0389E4, 0x0399EC,
-	0x005502, 0x005D0A, 0x030042, 0x0B004A,
-	0x1B804A, 0x13804A, 0x20000A, 0x089144,
-	0x19A144, 0x0389E4, 0x0399EC, 0x006502,
-	0x006D0A, 0x030042, 0x0B004A, 0x19004A,
-	0x2B804A, 0x13804A, 0x21804A, 0x30000A,
-	0x089144, 0x19A144, 0x2AB144, 0x0389E4,
-	0x0399EC, 0x007502, 0x007D0A, 0x03A9E4,
-	0x000702, 0x00107D, 0x000415, 0x018042,
-	0x08000A, 0x0109E4, 0x000F02, 0x002AF5,
-	0x0019FD, 0x010042, 0x09804A, 0x10000A,
-	0x000934, 0x001674, 0x0029F5, 0x010042,
-	0x10000A, 0x00917C, 0x002075, 0x010042,
-	0x08000A, 0x000904, 0x200A86, 0x0026F5,
-	0x0027F5, 0x030042, 0x09004A, 0x10000A,
-	0x000A3C, 0x00167C, 0x001A75, 0x000BFD,
-	0x010042, 0x51804A, 0x48000A, 0x160007,
-	0x001075, 0x010042, 0x282C0A, 0x281D12,
-	0x282512, 0x001F32, 0x1E0007, 0x0E0007,
-	0x001975, 0x010042, 0x002DF5, 0x0D004A,
-	0x10000A, 0x009144, 0x20EA86, 0x010042,
-	0x28340A, 0x000E5D, 0x00008D, 0x000375,
-	0x000820, 0x010040, 0x05D2F4, 0x54D104,
-	0x00735C, 0x218B86, 0x000007, 0x0C0007,
-	0x080007, 0x0A0007, 0x02178D, 0x000810,
-	0x08043A, 0x34B206, 0x000007, 0x219206,
-	0x000007, 0x080007, 0x002275, 0x010042,
-	0x20000A, 0x002104, 0x225886, 0x001E2D,
-	0x0002F5, 0x010042, 0x08000A, 0x000904,
-	0x21CA86, 0x000007, 0x002010, 0x30043A,
-	0x00057D, 0x0180C3, 0x08000A, 0x028924,
-	0x280502, 0x280C02, 0x0A810D, 0x000820,
-	0x0002F5, 0x010040, 0x220007, 0x0004FD,
-	0x018042, 0x70000A, 0x030000, 0x007020,
-	0x07FA06, 0x018040, 0x022B8D, 0x000810,
-	0x08043A, 0x2CAA06, 0x000007, 0x0002FD,
-	0x018042, 0x08000A, 0x000904, 0x22C286,
-	0x000007, 0x020206, 0x000007, 0x000875,
-	0x0009FD, 0x00010D, 0x234206, 0x000295,
-	0x000B75, 0x00097D, 0x00000D, 0x000515,
-	0x010042, 0x18000A, 0x001904, 0x2A0086,
-	0x0006F5, 0x001020, 0x010040, 0x0004F5,
-	0x000820, 0x010040, 0x000775, 0x010042,
-	0x09804A, 0x10000A, 0x001124, 0x000904,
-	0x23F286, 0x000815, 0x080102, 0x101204,
-	0x241206, 0x000575, 0x081204, 0x000007,
-	0x100102, 0x000575, 0x000425, 0x021124,
-	0x100102, 0x000820, 0x031060, 0x010040,
-	0x001924, 0x2A0086, 0x00008D, 0x000464,
-	0x009D04, 0x291086, 0x180102, 0x000575,
-	0x010042, 0x28040A, 0x00018D, 0x000924,
-	0x280D02, 0x00000D, 0x000924, 0x281502,
-	0x10000D, 0x000820, 0x0002F5, 0x010040,
-	0x200007, 0x001175, 0x0002FD, 0x018042,
-	0x08000A, 0x000904, 0x24FA86, 0x000007,
-	0x000100, 0x080B20, 0x130B60, 0x1B0B60,
-	0x030A60, 0x010040, 0x050042, 0x3D004A,
-	0x35004A, 0x2D004A, 0x20000A, 0x0006F5,
-	0x010042, 0x28140A, 0x0004F5, 0x010042,
-	0x08000A, 0x000315, 0x010D04, 0x260286,
-	0x004015, 0x000095, 0x010D04, 0x25F086,
-	0x100022, 0x10002A, 0x261A06, 0x000007,
-	0x333104, 0x2AA904, 0x000007, 0x032124,
-	0x280502, 0x284402, 0x001124, 0x400102,
-	0x000424, 0x000424, 0x003224, 0x00292C,
-	0x00636C, 0x277386, 0x000007, 0x02B164,
-	0x000464, 0x000464, 0x00008D, 0x000A64,
-	0x280D02, 0x10008D, 0x000820, 0x0002F5,
-	0x010040, 0x220007, 0x00008D, 0x38B904,
-	0x000007, 0x03296C, 0x30010A, 0x0002F5,
-	0x010042, 0x08000A, 0x000904, 0x270286,
-	0x000007, 0x00212C, 0x28050A, 0x00316C,
-	0x00046C, 0x00046C, 0x28450A, 0x001124,
-	0x006B64, 0x100102, 0x00008D, 0x01096C,
-	0x280D0A, 0x10010D, 0x000820, 0x0002F5,
-	0x010040, 0x220007, 0x004124, 0x000424,
-	0x000424, 0x003224, 0x300102, 0x032944,
-	0x27FA86, 0x000007, 0x300002, 0x0004F5,
-	0x010042, 0x08000A, 0x000315, 0x010D04,
-	0x284086, 0x003124, 0x000464, 0x300102,
-	0x0002F5, 0x010042, 0x08000A, 0x000904,
-	0x284A86, 0x000007, 0x284402, 0x003124,
-	0x300502, 0x003924, 0x300583, 0x000883,
-	0x0005F5, 0x010042, 0x28040A, 0x00008D,
-	0x008124, 0x280D02, 0x00008D, 0x008124,
-	0x281502, 0x10018D, 0x000820, 0x0002F5,
-	0x010040, 0x220007, 0x001025, 0x000575,
-	0x030042, 0x09004A, 0x10000A, 0x0A0904,
-	0x121104, 0x000007, 0x001020, 0x050860,
-	0x050040, 0x0006FD, 0x018042, 0x09004A,
-	0x10000A, 0x0000A5, 0x0A0904, 0x121104,
-	0x000007, 0x000820, 0x019060, 0x010040,
-	0x0002F5, 0x010042, 0x08000A, 0x000904,
-	0x29CA86, 0x000007, 0x244206, 0x000007,
-	0x000606, 0x000007, 0x0002F5, 0x010042,
-	0x08000A, 0x000904, 0x2A1A86, 0x000007,
-	0x000100, 0x080B20, 0x138B60, 0x1B8B60,
-	0x238B60, 0x2B8B60, 0x338B60, 0x3B8B60,
-	0x438B60, 0x4B8B60, 0x538B60, 0x5B8B60,
-	0x638B60, 0x6B8B60, 0x738B60, 0x7B8B60,
-	0x038F60, 0x0B8F60, 0x138F60, 0x1B8F60,
-	0x238F60, 0x2B8F60, 0x338F60, 0x3B8F60,
-	0x438F60, 0x4B8F60, 0x538F60, 0x5B8F60,
-	0x638F60, 0x6B8F60, 0x738F60, 0x7B8F60,
-	0x038A60, 0x000606, 0x018040, 0x00008D,
-	0x000A64, 0x280D02, 0x000A24, 0x00027D,
-	0x018042, 0x10000A, 0x001224, 0x0003FD,
-	0x018042, 0x08000A, 0x000904, 0x2C0A86,
-	0x000007, 0x00018D, 0x000A24, 0x000464,
-	0x000464, 0x080102, 0x000924, 0x000424,
-	0x000424, 0x100102, 0x02000D, 0x009144,
-	0x2C6186, 0x000007, 0x0001FD, 0x018042,
-	0x08000A, 0x000A44, 0x2C4386, 0x018042,
-	0x0A000D, 0x000820, 0x0002FD, 0x018040,
-	0x200007, 0x00027D, 0x001020, 0x000606,
-	0x018040, 0x0002F5, 0x010042, 0x08000A,
-	0x000904, 0x2CB286, 0x000007, 0x00037D,
-	0x018042, 0x08000A, 0x000904, 0x2CE286,
-	0x000007, 0x000075, 0x002E7D, 0x010042,
-	0x0B804A, 0x000020, 0x000904, 0x000686,
-	0x010040, 0x31844A, 0x30048B, 0x000883,
-	0x00008D, 0x000810, 0x28143A, 0x00008D,
-	0x000810, 0x280C3A, 0x000675, 0x010042,
-	0x08000A, 0x003815, 0x010924, 0x280502,
-	0x0B000D, 0x000820, 0x0002F5, 0x010040,
-	0x000606, 0x220007, 0x000464, 0x000464,
-	0x000606, 0x000007, 0x000134, 0x007F8D,
-	0x00093C, 0x281D12, 0x282512, 0x001F32,
-	0x0E0007, 0x00010D, 0x00037D, 0x000820,
-	0x018040, 0x05D2F4, 0x000007, 0x080007,
-	0x00037D, 0x018042, 0x08000A, 0x000904,
-	0x2E8A86, 0x000007, 0x000606, 0x000007,
-	0x000007, 0x000012, 0x100007, 0x320007,
-	0x600007, 0x460007, 0x100080, 0x48001A,
-	0x004904, 0x2EF186, 0x000007, 0x001210,
-	0x58003A, 0x000145, 0x5C5D04, 0x000007,
-	0x000080, 0x48001A, 0x004904, 0x2F4186,
-	0x000007, 0x001210, 0x50003A, 0x005904,
-	0x2F9886, 0x000045, 0x0000C5, 0x7FFFF5,
-	0x7FFF7D, 0x07D524, 0x004224, 0x500102,
-	0x200502, 0x000082, 0x40001A, 0x004104,
-	0x2FC986, 0x000007, 0x003865, 0x40001A,
-	0x004020, 0x00104D, 0x04C184, 0x31AB86,
-	0x000040, 0x040007, 0x000165, 0x000145,
-	0x004020, 0x000040, 0x000765, 0x080080,
-	0x40001A, 0x004104, 0x305986, 0x000007,
-	0x001210, 0x40003A, 0x004104, 0x30B286,
-	0x00004D, 0x0000CD, 0x004810, 0x20043A,
-	0x000882, 0x40001A, 0x004104, 0x30C186,
-	0x000007, 0x004820, 0x005904, 0x319886,
-	0x000040, 0x0007E5, 0x200480, 0x2816A0,
-	0x3216E0, 0x3A16E0, 0x4216E0, 0x021260,
-	0x000040, 0x000032, 0x400075, 0x00007D,
-	0x07D574, 0x200512, 0x000082, 0x40001A,
-	0x004104, 0x317186, 0x000007, 0x038A06,
-	0x640007, 0x0000E5, 0x000020, 0x000040,
-	0x000A65, 0x000020, 0x020040, 0x020040,
-	0x000040, 0x000165, 0x000042, 0x70000A,
-	0x007104, 0x323286, 0x000007, 0x060007,
-	0x019A06, 0x640007, 0x050000, 0x007020,
-	0x000040, 0x038A06, 0x640007, 0x000007,
-	0x00306D, 0x028860, 0x029060, 0x08000A,
-	0x028860, 0x008040, 0x100012, 0x00100D,
-	0x009184, 0x32D186, 0x000E0D, 0x009184,
-	0x33E186, 0x000007, 0x300007, 0x001020,
-	0x003B6D, 0x008040, 0x000080, 0x08001A,
-	0x000904, 0x32F186, 0x000007, 0x001220,
-	0x000DED, 0x008040, 0x008042, 0x10000A,
-	0x40000D, 0x109544, 0x000007, 0x001020,
-	0x000DED, 0x008040, 0x008042, 0x20040A,
-	0x000082, 0x08001A, 0x000904, 0x338186,
-	0x000007, 0x003B6D, 0x008042, 0x08000A,
-	0x000E15, 0x010984, 0x342B86, 0x600007,
-	0x08001A, 0x000C15, 0x010984, 0x341386,
-	0x000020, 0x1A0007, 0x0002ED, 0x008040,
-	0x620007, 0x00306D, 0x028042, 0x0A804A,
-	0x000820, 0x0A804A, 0x000606, 0x10804A,
-	0x000007, 0x282512, 0x001F32, 0x05D2F4,
-	0x54D104, 0x00735C, 0x000786, 0x000007,
-	0x0C0007, 0x0A0007, 0x1C0007, 0x003465,
-	0x020040, 0x004820, 0x025060, 0x40000A,
-	0x024060, 0x000040, 0x454944, 0x000007,
-	0x004020, 0x003AE5, 0x000040, 0x0028E5,
-	0x000042, 0x48000A, 0x004904, 0x39F886,
-	0x002C65, 0x000042, 0x40000A, 0x0000D5,
-	0x454104, 0x000007, 0x000655, 0x054504,
-	0x368286, 0x0001D5, 0x054504, 0x368086,
-	0x002B65, 0x000042, 0x003AE5, 0x50004A,
-	0x40000A, 0x45C3D4, 0x000007, 0x454504,
-	0x000007, 0x0000CD, 0x444944, 0x000007,
-	0x454504, 0x000007, 0x00014D, 0x554944,
-	0x000007, 0x045144, 0x367986, 0x002C65,
-	0x000042, 0x48000A, 0x4CD104, 0x000007,
-	0x04C144, 0x368386, 0x000007, 0x160007,
-	0x002CE5, 0x040042, 0x40000A, 0x004020,
-	0x000040, 0x002965, 0x000042, 0x40000A,
-	0x004104, 0x36F086, 0x000007, 0x002402,
-	0x383206, 0x005C02, 0x0025E5, 0x000042,
-	0x40000A, 0x004274, 0x002AE5, 0x000042,
-	0x40000A, 0x004274, 0x500112, 0x0029E5,
-	0x000042, 0x40000A, 0x004234, 0x454104,
-	0x000007, 0x004020, 0x000040, 0x003EE5,
-	0x000020, 0x000040, 0x002DE5, 0x400152,
-	0x50000A, 0x045144, 0x37DA86, 0x0000C5,
-	0x003EE5, 0x004020, 0x000040, 0x002BE5,
-	0x000042, 0x40000A, 0x404254, 0x000007,
-	0x002AE5, 0x004020, 0x000040, 0x500132,
-	0x040134, 0x005674, 0x0029E5, 0x020042,
-	0x42000A, 0x000042, 0x50000A, 0x05417C,
-	0x0028E5, 0x000042, 0x48000A, 0x0000C5,
-	0x4CC144, 0x38A086, 0x0026E5, 0x0027E5,
-	0x020042, 0x40004A, 0x50000A, 0x00423C,
-	0x00567C, 0x0028E5, 0x004820, 0x000040,
-	0x281D12, 0x282512, 0x001F72, 0x002965,
-	0x000042, 0x40000A, 0x004104, 0x393A86,
-	0x0E0007, 0x160007, 0x1E0007, 0x003EE5,
-	0x000042, 0x40000A, 0x004104, 0x397886,
-	0x002D65, 0x000042, 0x28340A, 0x003465,
-	0x020042, 0x42004A, 0x004020, 0x4A004A,
-	0x50004A, 0x05D2F4, 0x54D104, 0x00735C,
-	0x39E186, 0x000007, 0x000606, 0x080007,
-	0x0C0007, 0x080007, 0x0A0007, 0x0001E5,
-	0x020045, 0x004020, 0x000060, 0x000365,
-	0x000040, 0x002E65, 0x001A20, 0x0A1A60,
-	0x000040, 0x003465, 0x020042, 0x42004A,
-	0x004020, 0x4A004A, 0x000606, 0x50004A,
-	0x0017FD, 0x018042, 0x08000A, 0x000904,
-	0x225A86, 0x000007, 0x00107D, 0x018042,
-	0x0011FD, 0x33804A, 0x19804A, 0x20000A,
-	0x000095, 0x2A1144, 0x01A144, 0x3B9086,
-	0x00040D, 0x00B184, 0x3B9186, 0x0018FD,
-	0x018042, 0x0010FD, 0x09804A, 0x38000A,
-	0x000095, 0x010924, 0x003A64, 0x3B8186,
-	0x000007, 0x003904, 0x3B9286, 0x000007,
-	0x3B9A06, 0x00000D, 0x00008D, 0x000820,
-	0x00387D, 0x018040, 0x700002, 0x00117D,
-	0x018042, 0x00197D, 0x29804A, 0x30000A,
-	0x380002, 0x003124, 0x000424, 0x000424,
-	0x002A24, 0x280502, 0x00068D, 0x000810,
-	0x28143A, 0x00750D, 0x00B124, 0x002264,
-	0x3D0386, 0x284402, 0x000810, 0x280C3A,
-	0x0B800D, 0x000820, 0x0002FD, 0x018040,
-	0x200007, 0x00758D, 0x00B124, 0x100102,
-	0x012144, 0x3E4986, 0x001810, 0x10003A,
-	0x00387D, 0x018042, 0x08000A, 0x000904,
-	0x3E4886, 0x030000, 0x3E4A06, 0x0000BD,
-	0x00008D, 0x023164, 0x000A64, 0x280D02,
-	0x0B808D, 0x000820, 0x0002FD, 0x018040,
-	0x200007, 0x00387D, 0x018042, 0x08000A,
-	0x000904, 0x3E3286, 0x030000, 0x0002FD,
-	0x018042, 0x08000A, 0x000904, 0x3D8286,
-	0x000007, 0x002810, 0x28043A, 0x00750D,
-	0x030924, 0x002264, 0x280D02, 0x02316C,
-	0x28450A, 0x0B810D, 0x000820, 0x0002FD,
-	0x018040, 0x200007, 0x00008D, 0x000A24,
-	0x3E4A06, 0x100102, 0x001810, 0x10003A,
-	0x0000BD, 0x003810, 0x30043A, 0x00187D,
-	0x018042, 0x0018FD, 0x09804A, 0x20000A,
-	0x0000AD, 0x028924, 0x07212C, 0x001010,
-	0x300583, 0x300D8B, 0x3014BB, 0x301C83,
-	0x002083, 0x00137D, 0x038042, 0x33844A,
-	0x33ACCB, 0x33B4CB, 0x33BCCB, 0x33C4CB,
-	0x33CCCB, 0x33D4CB, 0x305C8B, 0x006083,
-	0x001E0D, 0x0005FD, 0x018042, 0x20000A,
-	0x020924, 0x00068D, 0x00A96C, 0x00009D,
-	0x0002FD, 0x018042, 0x08000A, 0x000904,
-	0x3F6A86, 0x000007, 0x280502, 0x280D0A,
-	0x284402, 0x001810, 0x28143A, 0x0C008D,
-	0x000820, 0x0002FD, 0x018040, 0x220007,
-	0x003904, 0x225886, 0x001E0D, 0x00057D,
-	0x018042, 0x20000A, 0x020924, 0x0000A5,
-	0x0002FD, 0x018042, 0x08000A, 0x000904,
-	0x402A86, 0x000007, 0x280502, 0x280C02,
-	0x002010, 0x28143A, 0x0C010D, 0x000820,
-	0x0002FD, 0x018040, 0x225A06, 0x220007,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000,
-	0x000000, 0x000000, 0x000000, 0x000000
-};
-
-#endif	//_HWMCODE_
--- linux-2.6.18.noarch/sound/oss/uart401.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/uart401.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/uart401.c
+ * sound/oss/uart401.c
  *
  * MPU-401 UART driver (formerly uart401_midi.c)
  *
@@ -96,7 +96,7 @@
 		printk(KERN_WARNING "Too much work in interrupt on uart401 (0x%X). UART jabbering ??\n", devc->base);
 }
 
-irqreturn_t uart401intr(int irq, void *dev_id, struct pt_regs *dummy)
+irqreturn_t uart401intr(int irq, void *dev_id)
 {
 	uart401_devc *devc = dev_id;
 
--- linux-2.6.18.noarch/sound/oss/esssolo1.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/esssolo1.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2516 +0,0 @@
-/****************************************************************************/
-
-/*
- *      esssolo1.c  --  ESS Technology Solo1 (ES1946) audio driver.
- *
- *      Copyright (C) 1998-2001, 2003  Thomas Sailer (t.sailer@alumni.ethz.ch)
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Module command line parameters:
- *   none so far
- *
- *  Supported devices:
- *  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible
- *  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
- *  /dev/midi   simple MIDI UART interface, no ioctl
- *
- *  Revision history
- *    10.11.1998   0.1   Initial release (without any hardware)
- *    22.03.1999   0.2   cinfo.blocks should be reset after GETxPTR ioctl.
- *                       reported by Johan Maes <joma@telindus.be>
- *                       return EAGAIN instead of EBUSY when O_NONBLOCK
- *                       read/write cannot be executed
- *    07.04.1999   0.3   implemented the following ioctl's: SOUND_PCM_READ_RATE, 
- *                       SOUND_PCM_READ_CHANNELS, SOUND_PCM_READ_BITS; 
- *                       Alpha fixes reported by Peter Jones <pjones@redhat.com>
- *    15.06.1999   0.4   Fix bad allocation bug.
- *                       Thanks to Deti Fliegl <fliegl@in.tum.de>
- *    28.06.1999   0.5   Add pci_set_master
- *    12.08.1999   0.6   Fix MIDI UART crashing the driver
- *                       Changed mixer semantics from OSS documented
- *                       behaviour to OSS "code behaviour".
- *                       Recording might actually work now.
- *                       The real DDMA controller address register is at PCI config
- *                       0x60, while the register at 0x18 is used as a placeholder
- *                       register for BIOS address allocation. This register
- *                       is supposed to be copied into 0x60, according
- *                       to the Solo1 datasheet. When I do that, I can access
- *                       the DDMA registers except the mask bit, which
- *                       is stuck at 1. When I copy the contents of 0x18 +0x10
- *                       to the DDMA base register, everything seems to work.
- *                       The fun part is that the Windows Solo1 driver doesn't
- *                       seem to do these tricks.
- *                       Bugs remaining: plops and clicks when starting/stopping playback
- *    31.08.1999   0.7   add spin_lock_init
- *                       replaced current->state = x with set_current_state(x)
- *    03.09.1999   0.8   change read semantics for MIDI to match
- *                       OSS more closely; remove possible wakeup race
- *    07.10.1999   0.9   Fix initialization; complain if sequencer writes time out
- *                       Revised resource grabbing for the FM synthesizer
- *    28.10.1999   0.10  More waitqueue races fixed
- *    09.12.1999   0.11  Work around stupid Alpha port issue (virt_to_bus(kmalloc(GFP_DMA)) > 16M)
- *                       Disabling recording on Alpha
- *    12.01.2000   0.12  Prevent some ioctl's from returning bad count values on underrun/overrun;
- *                       Tim Janik's BSE (Bedevilled Sound Engine) found this
- *                       Integrated (aka redid 8-)) APM support patch by Zach Brown
- *    07.02.2000   0.13  Use pci_alloc_consistent and pci_register_driver
- *    19.02.2000   0.14  Use pci_dma_supported to determine if recording should be disabled
- *    13.03.2000   0.15  Reintroduce initialization of a couple of PCI config space registers
- *    21.11.2000   0.16  Initialize dma buffers in poll, otherwise poll may return a bogus mask
- *    12.12.2000   0.17  More dma buffer initializations, patch from
- *                       Tjeerd Mulder <tjeerd.mulder@fujitsu-siemens.com>
- *    31.01.2001   0.18  Register/Unregister gameport, original patch from
- *                       Nathaniel Daw <daw@cs.cmu.edu>
- *                       Fix SETTRIGGER non OSS API conformity
- *    10.03.2001         provide abs function, prevent picking up a bogus kernel macro
- *                       for abs. Bug report by Andrew Morton <andrewm@uow.edu.au>
- *    15.05.2001         pci_enable_device moved, return values in probe cleaned
- *                       up. Marcus Meissner <mm@caldera.de>
- *    22.05.2001   0.19  more cleanups, changed PM to PCI 2.4 style, got rid
- *                       of global list of devices, using pci device data.
- *                       Marcus Meissner <mm@caldera.de>
- *    03.01.2003   0.20  open_mode fixes from Georg Acher <acher@in.tum.de>
- */
-
-/*****************************************************************************/
-      
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/bitops.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/spinlock.h>
-#include <linux/smp_lock.h>
-#include <linux/gameport.h>
-#include <linux/wait.h>
-#include <linux/dma-mapping.h>
-#include <linux/mutex.h>
-
-
-#include <asm/io.h>
-#include <asm/page.h>
-#include <asm/uaccess.h>
-
-#include "dm.h"
-
-/* --------------------------------------------------------------------- */
-
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-
-/* --------------------------------------------------------------------- */
-
-#ifndef PCI_VENDOR_ID_ESS
-#define PCI_VENDOR_ID_ESS         0x125d
-#endif
-#ifndef PCI_DEVICE_ID_ESS_SOLO1
-#define PCI_DEVICE_ID_ESS_SOLO1   0x1969
-#endif
-
-#define SOLO1_MAGIC  ((PCI_VENDOR_ID_ESS<<16)|PCI_DEVICE_ID_ESS_SOLO1)
-
-#define DDMABASE_OFFSET           0    /* chip bug workaround kludge */
-#define DDMABASE_EXTENT           16
-
-#define IOBASE_EXTENT             16
-#define SBBASE_EXTENT             16
-#define VCBASE_EXTENT             (DDMABASE_EXTENT+DDMABASE_OFFSET)
-#define MPUBASE_EXTENT            4
-#define GPBASE_EXTENT             4
-#define GAMEPORT_EXTENT		  4
-
-#define FMSYNTH_EXTENT            4
-
-/* MIDI buffer sizes */
-
-#define MIDIINBUF  256
-#define MIDIOUTBUF 256
-
-#define FMODE_MIDI_SHIFT 3
-#define FMODE_MIDI_READ  (FMODE_READ << FMODE_MIDI_SHIFT)
-#define FMODE_MIDI_WRITE (FMODE_WRITE << FMODE_MIDI_SHIFT)
-
-#define FMODE_DMFM 0x10
-
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
-#define SUPPORT_JOYSTICK 1
-#endif
-
-static struct pci_driver solo1_driver;
-
-/* --------------------------------------------------------------------- */
-
-struct solo1_state {
-	/* magic */
-	unsigned int magic;
-
-	/* the corresponding pci_dev structure */
-	struct pci_dev *dev;
-
-	/* soundcore stuff */
-	int dev_audio;
-	int dev_mixer;
-	int dev_midi;
-	int dev_dmfm;
-
-	/* hardware resources */
-	unsigned long iobase, sbbase, vcbase, ddmabase, mpubase; /* long for SPARC */
-	unsigned int irq;
-
-	/* mixer registers */
-	struct {
-		unsigned short vol[10];
-		unsigned int recsrc;
-		unsigned int modcnt;
-		unsigned short micpreamp;
-	} mix;
-
-	/* wave stuff */
-	unsigned fmt;
-	unsigned channels;
-	unsigned rate;
-	unsigned char clkdiv;
-	unsigned ena;
-
-	spinlock_t lock;
-	struct mutex open_mutex;
-	mode_t open_mode;
-	wait_queue_head_t open_wait;
-
-	struct dmabuf {
-		void *rawbuf;
-		dma_addr_t dmaaddr;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-		unsigned hwptr, swptr;
-		unsigned total_bytes;
-		int count;
-		unsigned error; /* over/underrun */
-		wait_queue_head_t wait;
-		/* redundant, but makes calculations easier */
-		unsigned fragsize;
-		unsigned dmasize;
-		unsigned fragsamples;
-		/* OSS stuff */
-		unsigned mapped:1;
-		unsigned ready:1;
-		unsigned endcleared:1;
-		unsigned enabled:1;
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-	} dma_dac, dma_adc;
-
-	/* midi stuff */
-	struct {
-		unsigned ird, iwr, icnt;
-		unsigned ord, owr, ocnt;
-		wait_queue_head_t iwait;
-		wait_queue_head_t owait;
-		struct timer_list timer;
-		unsigned char ibuf[MIDIINBUF];
-		unsigned char obuf[MIDIOUTBUF];
-	} midi;
-
-#if SUPPORT_JOYSTICK
-	struct gameport *gameport;
-#endif
-};
-
-/* --------------------------------------------------------------------- */
-
-static inline void write_seq(struct solo1_state *s, unsigned char data)
-{
-        int i;
-	unsigned long flags;
-
-	/* the local_irq_save stunt is to send the data within the command window */
-        for (i = 0; i < 0xffff; i++) {
-		local_irq_save(flags);
-                if (!(inb(s->sbbase+0xc) & 0x80)) {
-                        outb(data, s->sbbase+0xc);
-			local_irq_restore(flags);
-                        return;
-                }
-		local_irq_restore(flags);
-	}
-	printk(KERN_ERR "esssolo1: write_seq timeout\n");
-	outb(data, s->sbbase+0xc);
-}
-
-static inline int read_seq(struct solo1_state *s, unsigned char *data)
-{
-        int i;
-
-        if (!data)
-                return 0;
-        for (i = 0; i < 0xffff; i++)
-                if (inb(s->sbbase+0xe) & 0x80) {
-                        *data = inb(s->sbbase+0xa);
-                        return 1;
-                }
-	printk(KERN_ERR "esssolo1: read_seq timeout\n");
-        return 0;
-}
-
-static inline int reset_ctrl(struct solo1_state *s)
-{
-        int i;
-
-        outb(3, s->sbbase+6); /* clear sequencer and FIFO */
-        udelay(10);
-        outb(0, s->sbbase+6);
-        for (i = 0; i < 0xffff; i++)
-                if (inb(s->sbbase+0xe) & 0x80)
-                        if (inb(s->sbbase+0xa) == 0xaa) {
-				write_seq(s, 0xc6); /* enter enhanced mode */
-                                return 1;
-			}
-        return 0;
-}
-
-static void write_ctrl(struct solo1_state *s, unsigned char reg, unsigned char data)
-{
-	write_seq(s, reg);
-	write_seq(s, data);
-}
-
-#if 0 /* unused */
-static unsigned char read_ctrl(struct solo1_state *s, unsigned char reg)
-{
-        unsigned char r;
-
-	write_seq(s, 0xc0);
-	write_seq(s, reg);
-	read_seq(s, &r);
-	return r;
-}
-#endif /* unused */
-
-static void write_mixer(struct solo1_state *s, unsigned char reg, unsigned char data)
-{
-	outb(reg, s->sbbase+4);
-	outb(data, s->sbbase+5);
-}
-
-static unsigned char read_mixer(struct solo1_state *s, unsigned char reg)
-{
-	outb(reg, s->sbbase+4);
-	return inb(s->sbbase+5);
-}
-
-/* --------------------------------------------------------------------- */
-
-static inline unsigned ld2(unsigned int x)
-{
-	unsigned r = 0;
-	
-	if (x >= 0x10000) {
-		x >>= 16;
-		r += 16;
-	}
-	if (x >= 0x100) {
-		x >>= 8;
-		r += 8;
-	}
-	if (x >= 0x10) {
-		x >>= 4;
-		r += 4;
-	}
-	if (x >= 4) {
-		x >>= 2;
-		r += 2;
-	}
-	if (x >= 2)
-		r++;
-	return r;
-}
-
-/* --------------------------------------------------------------------- */
-
-static inline void stop_dac(struct solo1_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->ena &= ~FMODE_WRITE;
-	write_mixer(s, 0x78, 0x10);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void start_dac(struct solo1_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->ena & FMODE_WRITE) && (s->dma_dac.mapped || s->dma_dac.count > 0) && s->dma_dac.ready) {
-		s->ena |= FMODE_WRITE;
-		write_mixer(s, 0x78, 0x12);
-		udelay(10);
-		write_mixer(s, 0x78, 0x13);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static inline void stop_adc(struct solo1_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->ena &= ~FMODE_READ;
-	write_ctrl(s, 0xb8, 0xe);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void start_adc(struct solo1_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->ena & FMODE_READ) && (s->dma_adc.mapped || s->dma_adc.count < (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize))
-	    && s->dma_adc.ready) {
-		s->ena |= FMODE_READ;
-		write_ctrl(s, 0xb8, 0xf);
-#if 0
-		printk(KERN_DEBUG "solo1: DMAbuffer: 0x%08lx\n", (long)s->dma_adc.rawbuf);
-		printk(KERN_DEBUG "solo1: DMA: mask: 0x%02x cnt: 0x%04x addr: 0x%08x  stat: 0x%02x\n", 
-		       inb(s->ddmabase+0xf), inw(s->ddmabase+4), inl(s->ddmabase), inb(s->ddmabase+8));
-#endif
-                outb(0, s->ddmabase+0xd); /* master reset */
-		outb(1, s->ddmabase+0xf);  /* mask */
-		outb(0x54/*0x14*/, s->ddmabase+0xb);  /* DMA_MODE_READ | DMA_MODE_AUTOINIT */
-		outl(virt_to_bus(s->dma_adc.rawbuf), s->ddmabase);
-		outw(s->dma_adc.dmasize-1, s->ddmabase+4);
-		outb(0, s->ddmabase+0xf);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-#if 0
-	printk(KERN_DEBUG "solo1: start DMA: reg B8: 0x%02x  SBstat: 0x%02x\n"
-	       KERN_DEBUG "solo1: DMA: stat: 0x%02x  cnt: 0x%04x  mask: 0x%02x\n", 
-	       read_ctrl(s, 0xb8), inb(s->sbbase+0xc), 
-	       inb(s->ddmabase+8), inw(s->ddmabase+4), inb(s->ddmabase+0xf));
-	printk(KERN_DEBUG "solo1: A1: 0x%02x  A2: 0x%02x  A4: 0x%02x  A5: 0x%02x  A8: 0x%02x\n"  
-	       KERN_DEBUG "solo1: B1: 0x%02x  B2: 0x%02x  B4: 0x%02x  B7: 0x%02x  B8: 0x%02x  B9: 0x%02x\n",
-	       read_ctrl(s, 0xa1), read_ctrl(s, 0xa2), read_ctrl(s, 0xa4), read_ctrl(s, 0xa5), read_ctrl(s, 0xa8), 
-	       read_ctrl(s, 0xb1), read_ctrl(s, 0xb2), read_ctrl(s, 0xb4), read_ctrl(s, 0xb7), read_ctrl(s, 0xb8), 
-	       read_ctrl(s, 0xb9));
-#endif
-}
-
-/* --------------------------------------------------------------------- */
-
-#define DMABUF_DEFAULTORDER (15-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-static inline void dealloc_dmabuf(struct solo1_state *s, struct dmabuf *db)
-{
-	struct page *page, *pend;
-
-	if (db->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			ClearPageReserved(page);
-		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder, db->rawbuf, db->dmaaddr);
-	}
-	db->rawbuf = NULL;
-	db->mapped = db->ready = 0;
-}
-
-static int prog_dmabuf(struct solo1_state *s, struct dmabuf *db)
-{
-	int order;
-	unsigned bytespersec;
-	unsigned bufs, sample_shift = 0;
-	struct page *page, *pend;
-
-	db->hwptr = db->swptr = db->total_bytes = db->count = db->error = db->endcleared = 0;
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-                for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = pci_alloc_consistent(s->dev, PAGE_SIZE << order, &db->dmaaddr)))
-				break;
-		if (!db->rawbuf)
-			return -ENOMEM;
-		db->buforder = order;
-		/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			SetPageReserved(page);
-	}
-	if (s->fmt & (AFMT_S16_LE | AFMT_U16_LE))
-		sample_shift++;
-	if (s->channels > 1)
-		sample_shift++;
-	bytespersec = s->rate << sample_shift;
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < bytespersec)
-			db->fragshift = ld2(bytespersec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(bytespersec/100/(db->subdivision ? db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3;
-	}
-	db->numfrag = bufs >> db->fragshift;
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->numfrag = bufs >> db->fragshift;
-	}
-	db->fragsize = 1 << db->fragshift;
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
-	db->fragsamples = db->fragsize >> sample_shift;
-	db->dmasize = db->numfrag << db->fragshift;
-	db->enabled = 1;
-	return 0;
-}
-
-static inline int prog_dmabuf_adc(struct solo1_state *s)
-{
-	unsigned long va;
-	int c;
-
-	stop_adc(s);
-	/* check if PCI implementation supports 24bit busmaster DMA */
-	if (s->dev->dma_mask > 0xffffff)
-		return -EIO;
-	if ((c = prog_dmabuf(s, &s->dma_adc)))
-		return c;
-	va = s->dma_adc.dmaaddr;
-	if ((va & ~((1<<24)-1)))
-		panic("solo1: buffer above 16M boundary");
-	outb(0, s->ddmabase+0xd);  /* clear */
-	outb(1, s->ddmabase+0xf); /* mask */
-	/*outb(0, s->ddmabase+8);*/  /* enable (enable is active low!) */
-	outb(0x54, s->ddmabase+0xb);  /* DMA_MODE_READ | DMA_MODE_AUTOINIT */
-	outl(va, s->ddmabase);
-	outw(s->dma_adc.dmasize-1, s->ddmabase+4);
-	c = - s->dma_adc.fragsamples;
-	write_ctrl(s, 0xa4, c);
-	write_ctrl(s, 0xa5, c >> 8);
-	outb(0, s->ddmabase+0xf);
-	s->dma_adc.ready = 1;
-	return 0;
-}
-
-static int prog_dmabuf_dac(struct solo1_state *s)
-{
-	unsigned long va;
-	int c;
-
-	stop_dac(s);
-	if ((c = prog_dmabuf(s, &s->dma_dac)))
-		return c;
-	memset(s->dma_dac.rawbuf, (s->fmt & (AFMT_U8 | AFMT_U16_LE)) ? 0 : 0x80, s->dma_dac.dmasize); /* almost correct for U16 */
-	va = s->dma_dac.dmaaddr;
-	if ((va ^ (va + s->dma_dac.dmasize - 1)) & ~((1<<20)-1))
-		panic("solo1: buffer crosses 1M boundary");
-	outl(va, s->iobase);
-	/* warning: s->dma_dac.dmasize & 0xffff must not be zero! i.e. this limits us to a 32k buffer */
-	outw(s->dma_dac.dmasize, s->iobase+4);
-	c = - s->dma_dac.fragsamples;
-	write_mixer(s, 0x74, c);
-	write_mixer(s, 0x76, c >> 8);
-	outb(0xa, s->iobase+6);
-	s->dma_dac.ready = 1;
-	return 0;
-}
-
-static inline void clear_advance(void *buf, unsigned bsize, unsigned bptr, unsigned len, unsigned char c)
-{
-	if (bptr + len > bsize) {
-		unsigned x = bsize - bptr;
-		memset(((char *)buf) + bptr, c, x);
-		bptr = 0;
-		len -= x;
-	}
-	memset(((char *)buf) + bptr, c, len);
-}
-
-/* call with spinlock held! */
-
-static void solo1_update_ptr(struct solo1_state *s)
-{
-	int diff;
-	unsigned hwptr;
-
-	/* update ADC pointer */
-	if (s->ena & FMODE_READ) {
-		hwptr = (s->dma_adc.dmasize - 1 - inw(s->ddmabase+4)) % s->dma_adc.dmasize;
-                diff = (s->dma_adc.dmasize + hwptr - s->dma_adc.hwptr) % s->dma_adc.dmasize;
-                s->dma_adc.hwptr = hwptr;
-		s->dma_adc.total_bytes += diff;
-		s->dma_adc.count += diff;
-#if 0
-		printk(KERN_DEBUG "solo1: rd: hwptr %u swptr %u dmasize %u count %u\n",
-		       s->dma_adc.hwptr, s->dma_adc.swptr, s->dma_adc.dmasize, s->dma_adc.count);
-#endif
-		if (s->dma_adc.mapped) {
-			if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-				wake_up(&s->dma_adc.wait);
-		} else {
-			if (s->dma_adc.count > (signed)(s->dma_adc.dmasize - ((3 * s->dma_adc.fragsize) >> 1))) {
-				s->ena &= ~FMODE_READ;
-				write_ctrl(s, 0xb8, 0xe);
-				s->dma_adc.error++;
-			}
-			if (s->dma_adc.count > 0)
-				wake_up(&s->dma_adc.wait);
-		}
-	}
-	/* update DAC pointer */
-	if (s->ena & FMODE_WRITE) {
-                hwptr = (s->dma_dac.dmasize - inw(s->iobase+4)) % s->dma_dac.dmasize;
-                diff = (s->dma_dac.dmasize + hwptr - s->dma_dac.hwptr) % s->dma_dac.dmasize;
-                s->dma_dac.hwptr = hwptr;
-		s->dma_dac.total_bytes += diff;
-#if 0
-		printk(KERN_DEBUG "solo1: wr: hwptr %u swptr %u dmasize %u count %u\n",
-		       s->dma_dac.hwptr, s->dma_dac.swptr, s->dma_dac.dmasize, s->dma_dac.count);
-#endif
-		if (s->dma_dac.mapped) {
-			s->dma_dac.count += diff;
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize)
-				wake_up(&s->dma_dac.wait);
-		} else {
-			s->dma_dac.count -= diff;
-			if (s->dma_dac.count <= 0) {
-				s->ena &= ~FMODE_WRITE;
-				write_mixer(s, 0x78, 0x12);
-				s->dma_dac.error++;
-			} else if (s->dma_dac.count <= (signed)s->dma_dac.fragsize && !s->dma_dac.endcleared) {
-				clear_advance(s->dma_dac.rawbuf, s->dma_dac.dmasize, s->dma_dac.swptr,
-					      s->dma_dac.fragsize, (s->fmt & (AFMT_U8 | AFMT_U16_LE)) ? 0 : 0x80);
-				s->dma_dac.endcleared = 1;
-			}
-			if (s->dma_dac.count < (signed)s->dma_dac.dmasize)
-				wake_up(&s->dma_dac.wait);
-		}
-	}
-}
-
-/* --------------------------------------------------------------------- */
-
-static void prog_codec(struct solo1_state *s)
-{
-	unsigned long flags;
-	int fdiv, filter;
-	unsigned char c;
-
-	reset_ctrl(s);
-	write_seq(s, 0xd3);
-	/* program sampling rates */
-	filter = s->rate * 9 / 20; /* Set filter roll-off to 90% of rate/2 */
-	fdiv = 256 - 7160000 / (filter * 82);
-	spin_lock_irqsave(&s->lock, flags);
-	write_ctrl(s, 0xa1, s->clkdiv);
-	write_ctrl(s, 0xa2, fdiv);
-	write_mixer(s, 0x70, s->clkdiv);
-	write_mixer(s, 0x72, fdiv);
-	/* program ADC parameters */
-	write_ctrl(s, 0xb8, 0xe);
-	write_ctrl(s, 0xb9, /*0x1*/0);
-	write_ctrl(s, 0xa8, (s->channels > 1) ? 0x11 : 0x12);
-	c = 0xd0;
-	if (s->fmt & (AFMT_S16_LE | AFMT_U16_LE))
-		c |= 0x04;
-	if (s->fmt & (AFMT_S16_LE | AFMT_S8))
-		c |= 0x20;
-	if (s->channels > 1)
-		c ^= 0x48;
-	write_ctrl(s, 0xb7, (c & 0x70) | 1);
-	write_ctrl(s, 0xb7, c);
-	write_ctrl(s, 0xb1, 0x50);
-	write_ctrl(s, 0xb2, 0x50);
-	/* program DAC parameters */
-	c = 0x40;
-	if (s->fmt & (AFMT_S16_LE | AFMT_U16_LE))
-		c |= 1;
-	if (s->fmt & (AFMT_S16_LE | AFMT_S8))
-		c |= 4;
-	if (s->channels > 1)
-		c |= 2;
-	write_mixer(s, 0x7a, c);
-	write_mixer(s, 0x78, 0x10);
-	s->ena = 0;
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT "solo1: invalid magic value\n";
-
-#define VALIDATE_STATE(s)                         \
-({                                                \
-	if (!(s) || (s)->magic != SOLO1_MAGIC) { \
-		printk(invalid_magic);            \
-		return -ENXIO;                    \
-	}                                         \
-})
-
-/* --------------------------------------------------------------------- */
-
-static int mixer_ioctl(struct solo1_state *s, unsigned int cmd, unsigned long arg)
-{
-	static const unsigned int mixer_src[8] = {
-		SOUND_MASK_MIC, SOUND_MASK_MIC, SOUND_MASK_CD, SOUND_MASK_VOLUME,
-		SOUND_MASK_MIC, 0, SOUND_MASK_LINE, 0
-	};
-	static const unsigned char mixtable1[SOUND_MIXER_NRDEVICES] = {
-		[SOUND_MIXER_PCM]     = 1,   /* voice */
-		[SOUND_MIXER_SYNTH]   = 2,   /* FM */
-		[SOUND_MIXER_CD]      = 3,   /* CD */
-		[SOUND_MIXER_LINE]    = 4,   /* Line */
-		[SOUND_MIXER_LINE1]   = 5,   /* AUX */
-		[SOUND_MIXER_MIC]     = 6,   /* Mic */
-		[SOUND_MIXER_LINE2]   = 7,   /* Mono in */
-		[SOUND_MIXER_SPEAKER] = 8,   /* Speaker */
-		[SOUND_MIXER_RECLEV]  = 9,   /* Recording level */
-		[SOUND_MIXER_VOLUME]  = 10   /* Master Volume */
-	};
-	static const unsigned char mixreg[] = {
-		0x7c,   /* voice */
-		0x36,   /* FM */
-		0x38,   /* CD */
-		0x3e,   /* Line */
-		0x3a,   /* AUX */
-		0x1a,   /* Mic */
-		0x6d    /* Mono in */
-	};
-	unsigned char l, r, rl, rr, vidx;
-	int i, val;
-	int __user *p = (int __user *)arg;
-
-	VALIDATE_STATE(s);
-
-	if (cmd == SOUND_MIXER_PRIVATE1) {
-		/* enable/disable/query mixer preamp */
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != -1) {
-			val = val ? 0xff : 0xf7;
-			write_mixer(s, 0x7d, (read_mixer(s, 0x7d) | 0x08) & val);
-		}
-		val = (read_mixer(s, 0x7d) & 0x08) ? 1 : 0;
-		return put_user(val, p);
-	}
-	if (cmd == SOUND_MIXER_PRIVATE2) {
-		/* enable/disable/query spatializer */
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != -1) {
-			val &= 0x3f;
-			write_mixer(s, 0x52, val);
-			write_mixer(s, 0x50, val ? 0x08 : 0);
-		}
-		return put_user(read_mixer(s, 0x52), p);
-	}
-        if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		strncpy(info.id, "Solo1", sizeof(info.id));
-		strncpy(info.name, "ESS Solo1", sizeof(info.name));
-		info.modify_counter = s->mix.modcnt;
-		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == SOUND_OLD_MIXER_INFO) {
-		_old_mixer_info info;
-		strncpy(info.id, "Solo1", sizeof(info.id));
-		strncpy(info.name, "ESS Solo1", sizeof(info.name));
-		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, p);
-	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
-                return -EINVAL;
-        if (_SIOC_DIR(cmd) == _SIOC_READ) {
-                switch (_IOC_NR(cmd)) {
-                case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-			return put_user(mixer_src[read_mixer(s, 0x1c) & 7], p);
-
-                case SOUND_MIXER_DEVMASK: /* Arg contains a bit for each supported device */
-			return put_user(SOUND_MASK_PCM | SOUND_MASK_SYNTH | SOUND_MASK_CD |
-					SOUND_MASK_LINE | SOUND_MASK_LINE1 | SOUND_MASK_MIC |
-					SOUND_MASK_VOLUME | SOUND_MASK_LINE2 | SOUND_MASK_RECLEV |
-					SOUND_MASK_SPEAKER, p);
-
-                case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
-			return put_user(SOUND_MASK_LINE | SOUND_MASK_MIC | SOUND_MASK_CD | SOUND_MASK_VOLUME, p);
-
-                case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
-			return put_user(SOUND_MASK_PCM | SOUND_MASK_SYNTH | SOUND_MASK_CD |
-					SOUND_MASK_LINE | SOUND_MASK_LINE1 | SOUND_MASK_MIC |
-					SOUND_MASK_VOLUME | SOUND_MASK_LINE2 | SOUND_MASK_RECLEV, p);
-			
-                case SOUND_MIXER_CAPS:
-			return put_user(SOUND_CAP_EXCL_INPUT, p);
-
-		default:
-			i = _IOC_NR(cmd);
-                        if (i >= SOUND_MIXER_NRDEVICES || !(vidx = mixtable1[i]))
-                                return -EINVAL;
-			return put_user(s->mix.vol[vidx-1], p);
-		}
-	}
-        if (_SIOC_DIR(cmd) != (_SIOC_READ|_SIOC_WRITE)) 
-		return -EINVAL;
-	s->mix.modcnt++;
-	switch (_IOC_NR(cmd)) {
-	case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-#if 0
-	        {
-			static const unsigned char regs[] = {
-				0x1c, 0x1a, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x60, 0x62, 0x6d, 0x7c
-			};
-			int i;
-			
-			for (i = 0; i < sizeof(regs); i++)
-				printk(KERN_DEBUG "solo1: mixer reg 0x%02x: 0x%02x\n",
-				       regs[i], read_mixer(s, regs[i]));
-			printk(KERN_DEBUG "solo1: ctrl reg 0x%02x: 0x%02x\n",
-			       0xb4, read_ctrl(s, 0xb4));
-		}
-#endif
-	        if (get_user(val, p))
-			return -EFAULT;
-                i = hweight32(val);
-                if (i == 0)
-                        return 0;
-                else if (i > 1) 
-                        val &= ~mixer_src[read_mixer(s, 0x1c) & 7];
-		for (i = 0; i < 8; i++) {
-			if (mixer_src[i] & val)
-				break;
-		}
-		if (i > 7)
-			return 0;
-		write_mixer(s, 0x1c, i);
-		return 0;
-
-	case SOUND_MIXER_VOLUME:
-		if (get_user(val, p))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		r = (val >> 8) & 0xff;
-		if (r > 100)
-			r = 100;
-		if (l < 6) {
-			rl = 0x40;
-			l = 0;
-		} else {
-			rl = (l * 2 - 11) / 3;
-			l = (rl * 3 + 11) / 2;
-		}
-		if (r < 6) {
-			rr = 0x40;
-			r = 0;
-		} else {
-			rr = (r * 2 - 11) / 3;
-			r = (rr * 3 + 11) / 2;
-		}
-		write_mixer(s, 0x60, rl);
-		write_mixer(s, 0x62, rr);
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-                s->mix.vol[9] = ((unsigned int)r << 8) | l;
-#else
-                s->mix.vol[9] = val;
-#endif
-		return put_user(s->mix.vol[9], p);
-
-	case SOUND_MIXER_SPEAKER:
-		if (get_user(val, p))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		else if (l < 2)
-			l = 2;
-		rl = (l - 2) / 14;
-		l = rl * 14 + 2;
-		write_mixer(s, 0x3c, rl);
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-                s->mix.vol[7] = l * 0x101;
-#else
-                s->mix.vol[7] = val;
-#endif
-		return put_user(s->mix.vol[7], p);
-
-	case SOUND_MIXER_RECLEV:
-		if (get_user(val, p))
-			return -EFAULT;
-		l = (val << 1) & 0x1fe;
-		if (l > 200)
-			l = 200;
-		else if (l < 5)
-			l = 5;
-		r = (val >> 7) & 0x1fe;
-		if (r > 200)
-			r = 200;
-		else if (r < 5)
-			r = 5;
-		rl = (l - 5) / 13;
-		rr = (r - 5) / 13;
-		r = (rl * 13 + 5) / 2;
-		l = (rr * 13 + 5) / 2;
-		write_ctrl(s, 0xb4, (rl << 4) | rr);
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-                s->mix.vol[8] = ((unsigned int)r << 8) | l;
-#else
-                s->mix.vol[8] = val;
-#endif
-		return put_user(s->mix.vol[8], p);
-
-	default:
-		i = _IOC_NR(cmd);
-		if (i >= SOUND_MIXER_NRDEVICES || !(vidx = mixtable1[i]))
-			return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		l = (val << 1) & 0x1fe;
-		if (l > 200)
-			l = 200;
-		else if (l < 5)
-			l = 5;
-		r = (val >> 7) & 0x1fe;
-		if (r > 200)
-			r = 200;
-		else if (r < 5)
-			r = 5;
-		rl = (l - 5) / 13;
-		rr = (r - 5) / 13;
-		r = (rl * 13 + 5) / 2;
-		l = (rr * 13 + 5) / 2;
-		write_mixer(s, mixreg[vidx-1], (rl << 4) | rr);
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-                s->mix.vol[vidx-1] = ((unsigned int)r << 8) | l;
-#else
-                s->mix.vol[vidx-1] = val;
-#endif
-		return put_user(s->mix.vol[vidx-1], p);
-	}
-}
-
-/* --------------------------------------------------------------------- */
-
-static int solo1_open_mixdev(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	struct solo1_state *s = NULL;
-	struct pci_dev *pci_dev = NULL;
-
-	while ((pci_dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) != NULL) {
-		struct pci_driver *drvr;
-		drvr = pci_dev_driver (pci_dev);
-		if (drvr != &solo1_driver)
-			continue;
-		s = (struct solo1_state*)pci_get_drvdata(pci_dev);
-		if (!s)
-			continue;
-		if (s->dev_mixer == minor)
-			break;
-	}
-	if (!s)
-		return -ENODEV;
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	return nonseekable_open(inode, file);
-}
-
-static int solo1_release_mixdev(struct inode *inode, struct file *file)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	return 0;
-}
-
-static int solo1_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	return mixer_ioctl((struct solo1_state *)file->private_data, cmd, arg);
-}
-
-static /*const*/ struct file_operations solo1_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= solo1_ioctl_mixdev,
-	.open		= solo1_open_mixdev,
-	.release	= solo1_release_mixdev,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct solo1_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count;
-	unsigned tmo;
-	
-	if (s->dma_dac.mapped)
-		return 0;
-        add_wait_queue(&s->dma_dac.wait, &wait);
-        for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
-                spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-                spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-                        break;
-                if (nonblock) {
-                        remove_wait_queue(&s->dma_dac.wait, &wait);
-                        set_current_state(TASK_RUNNING);
-                        return -EBUSY;
-                }
-		tmo = 3 * HZ * (count + s->dma_dac.fragsize) / 2 / s->rate;
-		if (s->fmt & (AFMT_S16_LE | AFMT_U16_LE))
-			tmo >>= 1;
-		if (s->channels > 1)
-			tmo >>= 1;
-                if (!schedule_timeout(tmo + 1))
-                        printk(KERN_DEBUG "solo1: dma timed out??\n");
-        }
-        remove_wait_queue(&s->dma_dac.wait, &wait);
-        set_current_state(TASK_RUNNING);
-        if (signal_pending(current))
-                return -ERESTARTSYS;
-        return 0;
-}
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t solo1_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_adc.mapped)
-		return -ENXIO;
-	if (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))
-		return ret;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-	add_wait_queue(&s->dma_adc.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		swptr = s->dma_adc.swptr;
-		cnt = s->dma_adc.dmasize-swptr;
-		if (s->dma_adc.count < cnt)
-			cnt = s->dma_adc.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-#ifdef DEBUGREC
-		printk(KERN_DEBUG "solo1_read: reg B8: 0x%02x  DMAstat: 0x%02x  DMAcnt: 0x%04x  SBstat: 0x%02x  cnt: %u\n", 
-		       read_ctrl(s, 0xb8), inb(s->ddmabase+8), inw(s->ddmabase+4), inb(s->sbbase+0xc), cnt);
-#endif
-		if (cnt <= 0) {
-			if (s->dma_adc.enabled)
-				start_adc(s);
-#ifdef DEBUGREC
-			printk(KERN_DEBUG "solo1_read: regs: A1: 0x%02x  A2: 0x%02x  A4: 0x%02x  A5: 0x%02x  A8: 0x%02x\n"
-			       KERN_DEBUG "solo1_read: regs: B1: 0x%02x  B2: 0x%02x  B7: 0x%02x  B8: 0x%02x  B9: 0x%02x\n"
-			       KERN_DEBUG "solo1_read: DMA: addr: 0x%08x cnt: 0x%04x stat: 0x%02x mask: 0x%02x\n"  
-			       KERN_DEBUG "solo1_read: SBstat: 0x%02x  cnt: %u\n",
-			       read_ctrl(s, 0xa1), read_ctrl(s, 0xa2), read_ctrl(s, 0xa4), read_ctrl(s, 0xa5), read_ctrl(s, 0xa8), 
-			       read_ctrl(s, 0xb1), read_ctrl(s, 0xb2), read_ctrl(s, 0xb7), read_ctrl(s, 0xb8), read_ctrl(s, 0xb9), 
-			       inl(s->ddmabase), inw(s->ddmabase+4), inb(s->ddmabase+8), inb(s->ddmabase+15), inb(s->sbbase+0xc), cnt);
-#endif
-			if (inb(s->ddmabase+15) & 1)
-				printk(KERN_ERR "solo1: cannot start recording, DDMA mask bit stuck at 1\n");
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-#ifdef DEBUGREC
-			printk(KERN_DEBUG "solo1_read: regs: A1: 0x%02x  A2: 0x%02x  A4: 0x%02x  A5: 0x%02x  A8: 0x%02x\n"
-			       KERN_DEBUG "solo1_read: regs: B1: 0x%02x  B2: 0x%02x  B7: 0x%02x  B8: 0x%02x  B9: 0x%02x\n"
-			       KERN_DEBUG "solo1_read: DMA: addr: 0x%08x cnt: 0x%04x stat: 0x%02x mask: 0x%02x\n"  
-			       KERN_DEBUG "solo1_read: SBstat: 0x%02x  cnt: %u\n",
-			       read_ctrl(s, 0xa1), read_ctrl(s, 0xa2), read_ctrl(s, 0xa4), read_ctrl(s, 0xa5), read_ctrl(s, 0xa8), 
-			       read_ctrl(s, 0xb1), read_ctrl(s, 0xb2), read_ctrl(s, 0xb7), read_ctrl(s, 0xb8), read_ctrl(s, 0xb9), 
-			       inl(s->ddmabase), inw(s->ddmabase+4), inb(s->ddmabase+8), inb(s->ddmabase+15), inb(s->sbbase+0xc), cnt);
-#endif
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		swptr = (swptr + cnt) % s->dma_adc.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_adc.swptr = swptr;
-		s->dma_adc.count -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_adc.enabled)
-			start_adc(s);
-#ifdef DEBUGREC
-		printk(KERN_DEBUG "solo1_read: reg B8: 0x%02x  DMAstat: 0x%02x  DMAcnt: 0x%04x  SBstat: 0x%02x\n", 
-		       read_ctrl(s, 0xb8), inb(s->ddmabase+8), inw(s->ddmabase+4), inb(s->sbbase+0xc));
-#endif
-	}
-	remove_wait_queue(&s->dma_adc.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-static ssize_t solo1_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_dac.mapped)
-		return -ENXIO;
-	if (!s->dma_dac.ready && (ret = prog_dmabuf_dac(s)))
-		return ret;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-#if 0
-	printk(KERN_DEBUG "solo1_write: reg 70: 0x%02x  71: 0x%02x  72: 0x%02x  74: 0x%02x  76: 0x%02x  78: 0x%02x  7A: 0x%02x\n"
-	       KERN_DEBUG "solo1_write: DMA: addr: 0x%08x  cnt: 0x%04x  stat: 0x%02x  SBstat: 0x%02x\n", 
-	       read_mixer(s, 0x70), read_mixer(s, 0x71), read_mixer(s, 0x72), read_mixer(s, 0x74), read_mixer(s, 0x76),
-	       read_mixer(s, 0x78), read_mixer(s, 0x7a), inl(s->iobase), inw(s->iobase+4), inb(s->iobase+6), inb(s->sbbase+0xc));
-	printk(KERN_DEBUG "solo1_write: reg 78: 0x%02x  reg 7A: 0x%02x  DMAcnt: 0x%04x  DMAstat: 0x%02x  SBstat: 0x%02x\n", 
-	       read_mixer(s, 0x78), read_mixer(s, 0x7a), inw(s->iobase+4), inb(s->iobase+6), inb(s->sbbase+0xc));
-#endif
-	ret = 0;
-	add_wait_queue(&s->dma_dac.wait, &wait);	
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		if (s->dma_dac.count < 0) {
-			s->dma_dac.count = 0;
-			s->dma_dac.swptr = s->dma_dac.hwptr;
-		}
-		swptr = s->dma_dac.swptr;
-		cnt = s->dma_dac.dmasize-swptr;
-		if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
-			cnt = s->dma_dac.dmasize - s->dma_dac.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_dac.enabled)
-				start_dac(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac.swptr = swptr;
-		s->dma_dac.count += cnt;
-		s->dma_dac.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_dac.enabled)
-			start_dac(s);
-	}
-	remove_wait_queue(&s->dma_dac.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int solo1_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac.ready && prog_dmabuf_dac(s))
-			return 0;
-		poll_wait(file, &s->dma_dac.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!s->dma_adc.ready && prog_dmabuf_adc(s))
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	solo1_update_ptr(s);
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.mapped) {
-			if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-				mask |= POLLIN | POLLRDNORM;
-		} else {
-			if (s->dma_adc.count > 0)
-				mask |= POLLIN | POLLRDNORM;
-		}
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) 
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed)s->dma_dac.dmasize > s->dma_dac.count)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-
-static int solo1_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	struct dmabuf *db;
-	int ret = -EINVAL;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf_dac(s)) != 0)
-			goto out;
-		db = &s->dma_dac;
-	} else if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf_adc(s)) != 0)
-			goto out;
-		db = &s->dma_adc;
-	} else 
-		goto out;
-	ret = -EINVAL;
-	if (vma->vm_pgoff != 0)
-		goto out;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder))
-		goto out;
-	ret = -EAGAIN;
-	if (remap_pfn_range(vma, vma->vm_start,
-				virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-				size, vma->vm_page_prot))
-		goto out;
-	db->mapped = 1;
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-static int solo1_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int val, mapped, ret, count;
-        int div1, div2;
-        unsigned rate1, rate2;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_STATE(s);
-        mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s, 0/*file->f_flags & O_NONBLOCK*/);
-		return 0;
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-		
-        case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq(s->irq);
-			s->dma_dac.swptr = s->dma_dac.hwptr = s->dma_dac.count = s->dma_dac.total_bytes = 0;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->irq);
-			s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-		}
-		prog_codec(s);
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			stop_adc(s);
-			stop_dac(s);
-			s->dma_adc.ready = s->dma_dac.ready = 0;
-			/* program sampling rates */
-			if (val > 48000)
-				val = 48000;
-			if (val < 6300)
-				val = 6300;
-			div1 = (768000 + val / 2) / val;
-			rate1 = (768000 + div1 / 2) / div1;
-			div1 = -div1;
-			div2 = (793800 + val / 2) / val;
-			rate2 = (793800 + div2 / 2) / div2;
-			div2 = (-div2) & 0x7f;
-			if (abs(val - rate2) < abs(val - rate1)) {
-				rate1 = rate2;
-				div1 = div2;
-			}
-			s->rate = rate1;
-			s->clkdiv = div1;
-			prog_codec(s);
-		}
-		return put_user(s->rate, p);
-		
-        case SNDCTL_DSP_STEREO:
-                if (get_user(val, p))
-			return -EFAULT;
-		stop_adc(s);
-		stop_dac(s);
-		s->dma_adc.ready = s->dma_dac.ready = 0;
-		/* program channels */
-		s->channels = val ? 2 : 1;
-		prog_codec(s);
-		return 0;
-
-        case SNDCTL_DSP_CHANNELS:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 0) {
-			stop_adc(s);
-			stop_dac(s);
-			s->dma_adc.ready = s->dma_dac.ready = 0;
-			/* program channels */
-			s->channels = (val >= 2) ? 2 : 1;
-			prog_codec(s);
-		}
-		return put_user(s->channels, p);
-
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(AFMT_S16_LE|AFMT_U16_LE|AFMT_S8|AFMT_U8, p);
-
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			stop_adc(s);
-			stop_dac(s);
-			s->dma_adc.ready = s->dma_dac.ready = 0;
-			/* program format */
-			if (val != AFMT_S16_LE && val != AFMT_U16_LE && 
-			    val != AFMT_S8 && val != AFMT_U8)
-				val = AFMT_U8;
-			s->fmt = val;
-			prog_codec(s);
-		}
-		return put_user(s->fmt, p);
-
-	case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if (file->f_mode & s->ena & FMODE_READ)
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & s->ena & FMODE_WRITE)
-			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, p);
-
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))
-					return ret;
-				s->dma_dac.enabled = 1;
-				start_adc(s);
-				if (inb(s->ddmabase+15) & 1)
-					printk(KERN_ERR "solo1: cannot start recording, DDMA mask bit stuck at 1\n");
-			} else {
-				s->dma_dac.enabled = 0;
-				stop_adc(s);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac.ready && (ret = prog_dmabuf_dac(s)))
-					return ret;
-				s->dma_dac.enabled = 1;
-				start_dac(s);
-			} else {
-				s->dma_dac.enabled = 0;
-				stop_dac(s);
-			}
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf_dac(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		solo1_update_ptr(s);
-		abinfo.fragsize = s->dma_dac.fragsize;
-		count = s->dma_dac.count;
-		if (count < 0)
-			count = 0;
-                abinfo.bytes = s->dma_dac.dmasize - count;
-                abinfo.fragstotal = s->dma_dac.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf_adc(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		solo1_update_ptr(s);
-		abinfo.fragsize = s->dma_adc.fragsize;
-                abinfo.bytes = s->dma_adc.count;
-                abinfo.fragstotal = s->dma_adc.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf_dac(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		solo1_update_ptr(s);
-                count = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		return put_user(count, p);
-
-        case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf_adc(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		solo1_update_ptr(s);
-                cinfo.bytes = s->dma_adc.total_bytes;
-                cinfo.blocks = s->dma_adc.count >> s->dma_adc.fragshift;
-                cinfo.ptr = s->dma_adc.hwptr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf_dac(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		solo1_update_ptr(s);
-                cinfo.bytes = s->dma_dac.total_bytes;
-		count = s->dma_dac.count;
-		if (count < 0)
-			count = 0;
-                cinfo.blocks = count >> s->dma_dac.fragshift;
-                cinfo.ptr = s->dma_dac.hwptr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= s->dma_dac.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-#if 0
-		printk(KERN_DEBUG "esssolo1: GETOPTR: bytes %u blocks %u ptr %u, buforder %u numfrag %u fragshift %u\n"
-		       KERN_DEBUG "esssolo1: swptr %u count %u fragsize %u dmasize %u fragsamples %u\n",
-		       cinfo.bytes, cinfo.blocks, cinfo.ptr, s->dma_dac.buforder, s->dma_dac.numfrag, s->dma_dac.fragshift,
-		       s->dma_dac.swptr, s->dma_dac.count, s->dma_dac.fragsize, s->dma_dac.dmasize, s->dma_dac.fragsamples);
-#endif
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf_dac(s)))
-				return val;
-			return put_user(s->dma_dac.fragsize, p);
-		}
-		if ((val = prog_dmabuf_adc(s)))
-			return val;
-		return put_user(s->dma_adc.fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			s->dma_dac.ossfragshift = val & 0xffff;
-			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac.ossfragshift < 4)
-				s->dma_dac.ossfragshift = 4;
-			if (s->dma_dac.ossfragshift > 15)
-				s->dma_dac.ossfragshift = 15;
-			if (s->dma_dac.ossmaxfrags < 4)
-				s->dma_dac.ossmaxfrags = 4;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-			return -EINVAL;
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		if (file->f_mode & FMODE_WRITE)
-			s->dma_dac.subdivision = val;
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		return put_user(s->rate, p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user(s->channels, p);
-
-        case SOUND_PCM_READ_BITS:
-		return put_user((s->fmt & (AFMT_S8|AFMT_U8)) ? 8 : 16, p);
-
-        case SOUND_PCM_WRITE_FILTER:
-        case SNDCTL_DSP_SETSYNCRO:
-        case SOUND_PCM_READ_FILTER:
-                return -EINVAL;
-		
-	}
-	return mixer_ioctl(s, cmd, arg);
-}
-
-static int solo1_release(struct inode *inode, struct file *file)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE)
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac(s);
-		outb(0, s->iobase+6);  /* disable DMA */
-		dealloc_dmabuf(s, &s->dma_dac);
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-		outb(1, s->ddmabase+0xf); /* mask DMA channel */
-		outb(0, s->ddmabase+0xd); /* DMA master clear */
-		dealloc_dmabuf(s, &s->dma_adc);
-	}
-	s->open_mode &= ~(FMODE_READ | FMODE_WRITE);
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static int solo1_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	struct solo1_state *s = NULL;
-	struct pci_dev *pci_dev = NULL;
-	
-	while ((pci_dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) != NULL) {
-		struct pci_driver *drvr;
-
-		drvr = pci_dev_driver(pci_dev);
-		if (drvr != &solo1_driver)
-			continue;
-		s = (struct solo1_state*)pci_get_drvdata(pci_dev);
-		if (!s)
-			continue;
-		if (!((s->dev_audio ^ minor) & ~0xf))
-			break;
-	}
-	if (!s)
-		return -ENODEV;
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & (FMODE_READ | FMODE_WRITE)) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	s->fmt = AFMT_U8;
-	s->channels = 1;
-	s->rate = 8000;
-	s->clkdiv = 96 | 0x80;
-	s->ena = 0;
-	s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
-	s->dma_adc.enabled = 1;
-	s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags = s->dma_dac.subdivision = 0;
-	s->dma_dac.enabled = 1;
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	mutex_unlock(&s->open_mutex);
-	prog_codec(s);
-	return nonseekable_open(inode, file);
-}
-
-static /*const*/ struct file_operations solo1_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= solo1_read,
-	.write		= solo1_write,
-	.poll		= solo1_poll,
-	.ioctl		= solo1_ioctl,
-	.mmap		= solo1_mmap,
-	.open		= solo1_open,
-	.release	= solo1_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-/* hold spinlock for the following! */
-static void solo1_handle_midi(struct solo1_state *s)
-{
-	unsigned char ch;
-	int wake;
-
-	if (!(s->mpubase))
-		return;
-	wake = 0;
-	while (!(inb(s->mpubase+1) & 0x80)) {
-		ch = inb(s->mpubase);
-		if (s->midi.icnt < MIDIINBUF) {
-			s->midi.ibuf[s->midi.iwr] = ch;
-			s->midi.iwr = (s->midi.iwr + 1) % MIDIINBUF;
-			s->midi.icnt++;
-		}
-		wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.iwait);
-	wake = 0;
-	while (!(inb(s->mpubase+1) & 0x40) && s->midi.ocnt > 0) {
-		outb(s->midi.obuf[s->midi.ord], s->mpubase);
-		s->midi.ord = (s->midi.ord + 1) % MIDIOUTBUF;
-		s->midi.ocnt--;
-		if (s->midi.ocnt < MIDIOUTBUF-16)
-			wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.owait);
-}
-
-static irqreturn_t solo1_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-        struct solo1_state *s = (struct solo1_state *)dev_id;
-	unsigned int intsrc;
-	
-	/* fastpath out, to ease interrupt sharing */
-	intsrc = inb(s->iobase+7); /* get interrupt source(s) */
-	if (!intsrc)
-		return IRQ_NONE;
-	(void)inb(s->sbbase+0xe);  /* clear interrupt */
-	spin_lock(&s->lock);
-	/* clear audio interrupts first */
-	if (intsrc & 0x20)
-		write_mixer(s, 0x7a, read_mixer(s, 0x7a) & 0x7f);
-	solo1_update_ptr(s);
-	solo1_handle_midi(s);
-	spin_unlock(&s->lock);
-	return IRQ_HANDLED;
-}
-
-static void solo1_midi_timer(unsigned long data)
-{
-	struct solo1_state *s = (struct solo1_state *)data;
-	unsigned long flags;
-	
-	spin_lock_irqsave(&s->lock, flags);
-	solo1_handle_midi(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->midi.timer.expires = jiffies+1;
-	add_timer(&s->midi.timer);
-}
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t solo1_midi_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	if (count == 0)
-		return 0;
-	ret = 0;
-	add_wait_queue(&s->midi.iwait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.ird;
-		cnt = MIDIINBUF - ptr;
-		if (s->midi.icnt < cnt)
-			cnt = s->midi.icnt;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_to_user(buffer, s->midi.ibuf + ptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		ptr = (ptr + cnt) % MIDIINBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.ird = ptr;
-		s->midi.icnt -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		break;
-	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&s->midi.iwait, &wait);
-	return ret;
-}
-
-static ssize_t solo1_midi_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	if (count == 0)
-		return 0;
-	ret = 0;
-        add_wait_queue(&s->midi.owait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.owr;
-		cnt = MIDIOUTBUF - ptr;
-		if (s->midi.ocnt + cnt > MIDIOUTBUF)
-			cnt = MIDIOUTBUF - s->midi.ocnt;
-		if (cnt <= 0) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			solo1_handle_midi(s);
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(s->midi.obuf + ptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		ptr = (ptr + cnt) % MIDIOUTBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.owr = ptr;
-		s->midi.ocnt += cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		spin_lock_irqsave(&s->lock, flags);
-		solo1_handle_midi(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&s->midi.owait, &wait);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int solo1_midi_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_flags & FMODE_WRITE)
-		poll_wait(file, &s->midi.owait, wait);
-	if (file->f_flags & FMODE_READ)
-		poll_wait(file, &s->midi.iwait, wait);
-	spin_lock_irqsave(&s->lock, flags);
-	if (file->f_flags & FMODE_READ) {
-		if (s->midi.icnt > 0)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_flags & FMODE_WRITE) {
-		if (s->midi.ocnt < MIDIOUTBUF)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int solo1_midi_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	struct solo1_state *s = NULL;
-	struct pci_dev *pci_dev = NULL;
-
-	while ((pci_dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) != NULL) {
-		struct pci_driver *drvr;
-
-		drvr = pci_dev_driver(pci_dev);
-		if (drvr != &solo1_driver)
-			continue;
-		s = (struct solo1_state*)pci_get_drvdata(pci_dev);
-		if (!s)
-			continue;
-		if (s->dev_midi == minor)
-			break;
-	}
-	if (!s)
-		return -ENODEV;
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & (file->f_mode << FMODE_MIDI_SHIFT)) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-		outb(0xff, s->mpubase+1); /* reset command */
-		outb(0x3f, s->mpubase+1); /* uart command */
-		if (!(inb(s->mpubase+1) & 0x80))
-			inb(s->mpubase);
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		outb(0xb0, s->iobase + 7); /* enable A1, A2, MPU irq's */
-		init_timer(&s->midi.timer);
-		s->midi.timer.expires = jiffies+1;
-		s->midi.timer.data = (unsigned long)s;
-		s->midi.timer.function = solo1_midi_timer;
-		add_timer(&s->midi.timer);
-	}
-	if (file->f_mode & FMODE_READ) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->open_mode |= (file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ | FMODE_MIDI_WRITE);
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int solo1_midi_release(struct inode *inode, struct file *file)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	unsigned count, tmo;
-
-	VALIDATE_STATE(s);
-
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE) {
-		add_wait_queue(&s->midi.owait, &wait);
-		for (;;) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			spin_lock_irqsave(&s->lock, flags);
-			count = s->midi.ocnt;
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (count <= 0)
-				break;
-			if (signal_pending(current))
-				break;
-			if (file->f_flags & O_NONBLOCK)
-				break;
-			tmo = (count * HZ) / 3100;
-			if (!schedule_timeout(tmo ? : 1) && tmo)
-				printk(KERN_DEBUG "solo1: midi timed out??\n");
-		}
-		remove_wait_queue(&s->midi.owait, &wait);
-		set_current_state(TASK_RUNNING);
-	}
-	mutex_lock(&s->open_mutex);
-	s->open_mode &= ~((file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ|FMODE_MIDI_WRITE));
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		outb(0x30, s->iobase + 7); /* enable A1, A2 irq's */
-		del_timer(&s->midi.timer);		
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations solo1_midi_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= solo1_midi_read,
-	.write		= solo1_midi_write,
-	.poll		= solo1_midi_poll,
-	.open		= solo1_midi_open,
-	.release	= solo1_midi_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int solo1_dmfm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	static const unsigned char op_offset[18] = {
-		0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
-		0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
-		0x10, 0x11, 0x12, 0x13, 0x14, 0x15
-	};
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	struct dm_fm_voice v;
-	struct dm_fm_note n;
-	struct dm_fm_params p;
-	unsigned int io;
-	unsigned int regb;
-
-	switch (cmd) {		
-	case FM_IOCTL_RESET:
-		for (regb = 0xb0; regb < 0xb9; regb++) {
-			outb(regb, s->sbbase);
-			outb(0, s->sbbase+1);
-			outb(regb, s->sbbase+2);
-			outb(0, s->sbbase+3);
-		}
-		return 0;
-
-	case FM_IOCTL_PLAY_NOTE:
-		if (copy_from_user(&n, (void __user *)arg, sizeof(n)))
-			return -EFAULT;
-		if (n.voice >= 18)
-			return -EINVAL;
-		if (n.voice >= 9) {
-			regb = n.voice - 9;
-			io = s->sbbase+2;
-		} else {
-			regb = n.voice;
-			io = s->sbbase;
-		}
-		outb(0xa0 + regb, io);
-		outb(n.fnum & 0xff, io+1);
-		outb(0xb0 + regb, io);
-		outb(((n.fnum >> 8) & 3) | ((n.octave & 7) << 2) | ((n.key_on & 1) << 5), io+1);
-		return 0;
-
-	case FM_IOCTL_SET_VOICE:
-		if (copy_from_user(&v, (void __user *)arg, sizeof(v)))
-			return -EFAULT;
-		if (v.voice >= 18)
-			return -EINVAL;
-		regb = op_offset[v.voice];
-		io = s->sbbase + ((v.op & 1) << 1);
-		outb(0x20 + regb, io);
-		outb(((v.am & 1) << 7) | ((v.vibrato & 1) << 6) | ((v.do_sustain & 1) << 5) | 
-		     ((v.kbd_scale & 1) << 4) | (v.harmonic & 0xf), io+1);
-		outb(0x40 + regb, io);
-		outb(((v.scale_level & 0x3) << 6) | (v.volume & 0x3f), io+1);
-		outb(0x60 + regb, io);
-		outb(((v.attack & 0xf) << 4) | (v.decay & 0xf), io+1);
-		outb(0x80 + regb, io);
-		outb(((v.sustain & 0xf) << 4) | (v.release & 0xf), io+1);
-		outb(0xe0 + regb, io);
-		outb(v.waveform & 0x7, io+1);
-		if (n.voice >= 9) {
-			regb = n.voice - 9;
-			io = s->sbbase+2;
-		} else {
-			regb = n.voice;
-			io = s->sbbase;
-		}
-		outb(0xc0 + regb, io);
-		outb(((v.right & 1) << 5) | ((v.left & 1) << 4) | ((v.feedback & 7) << 1) |
-		     (v.connection & 1), io+1);
-		return 0;
-		
-	case FM_IOCTL_SET_PARAMS:
-		if (copy_from_user(&p, (void __user *)arg, sizeof(p)))
-			return -EFAULT;
-		outb(0x08, s->sbbase);
-		outb((p.kbd_split & 1) << 6, s->sbbase+1);
-		outb(0xbd, s->sbbase);
-		outb(((p.am_depth & 1) << 7) | ((p.vib_depth & 1) << 6) | ((p.rhythm & 1) << 5) | ((p.bass & 1) << 4) |
-		     ((p.snare & 1) << 3) | ((p.tomtom & 1) << 2) | ((p.cymbal & 1) << 1) | (p.hihat & 1), s->sbbase+1);
-		return 0;
-
-	case FM_IOCTL_SET_OPL:
-		outb(4, s->sbbase+2);
-		outb(arg, s->sbbase+3);
-		return 0;
-
-	case FM_IOCTL_SET_MODE:
-		outb(5, s->sbbase+2);
-		outb(arg & 1, s->sbbase+3);
-		return 0;
-
-	default:
-		return -EINVAL;
-	}
-}
-
-static int solo1_dmfm_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	struct solo1_state *s = NULL;
-	struct pci_dev *pci_dev = NULL;
-
-	while ((pci_dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) != NULL) {
-		struct pci_driver *drvr;
-
-		drvr = pci_dev_driver(pci_dev);
-		if (drvr != &solo1_driver)
-			continue;
-		s = (struct solo1_state*)pci_get_drvdata(pci_dev);
-		if (!s)
-			continue;
-		if (s->dev_dmfm == minor)
-			break;
-	}
-	if (!s)
-		return -ENODEV;
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & FMODE_DMFM) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	if (!request_region(s->sbbase, FMSYNTH_EXTENT, "ESS Solo1")) {
-		mutex_unlock(&s->open_mutex);
-		printk(KERN_ERR "solo1: FM synth io ports in use, opl3 loaded?\n");
-		return -EBUSY;
-	}
-	/* init the stuff */
-	outb(1, s->sbbase);
-	outb(0x20, s->sbbase+1); /* enable waveforms */
-	outb(4, s->sbbase+2);
-	outb(0, s->sbbase+3);  /* no 4op enabled */
-	outb(5, s->sbbase+2);
-	outb(1, s->sbbase+3);  /* enable OPL3 */
-	s->open_mode |= FMODE_DMFM;
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int solo1_dmfm_release(struct inode *inode, struct file *file)
-{
-	struct solo1_state *s = (struct solo1_state *)file->private_data;
-	unsigned int regb;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	mutex_lock(&s->open_mutex);
-	s->open_mode &= ~FMODE_DMFM;
-	for (regb = 0xb0; regb < 0xb9; regb++) {
-		outb(regb, s->sbbase);
-		outb(0, s->sbbase+1);
-		outb(regb, s->sbbase+2);
-		outb(0, s->sbbase+3);
-	}
-	release_region(s->sbbase, FMSYNTH_EXTENT);
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations solo1_dmfm_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= solo1_dmfm_ioctl,
-	.open		= solo1_dmfm_open,
-	.release	= solo1_dmfm_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-static struct initvol {
-	int mixch;
-	int vol;
-} initvol[] __devinitdata = {
-	{ SOUND_MIXER_WRITE_VOLUME, 0x4040 },
-	{ SOUND_MIXER_WRITE_PCM, 0x4040 },
-	{ SOUND_MIXER_WRITE_SYNTH, 0x4040 },
-	{ SOUND_MIXER_WRITE_CD, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE1, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE2, 0x4040 },
-	{ SOUND_MIXER_WRITE_RECLEV, 0x4040 },
-	{ SOUND_MIXER_WRITE_SPEAKER, 0x4040 },
-	{ SOUND_MIXER_WRITE_MIC, 0x4040 }
-};
-
-static int setup_solo1(struct solo1_state *s)
-{
-	struct pci_dev *pcidev = s->dev;
-	mm_segment_t fs;
-	int i, val;
-
-	/* initialize DDMA base address */
-	printk(KERN_DEBUG "solo1: ddma base address: 0x%lx\n", s->ddmabase);
-	pci_write_config_word(pcidev, 0x60, (s->ddmabase & (~0xf)) | 1);
-	/* set DMA policy to DDMA, IRQ emulation off (CLKRUN disabled for now) */
-	pci_write_config_dword(pcidev, 0x50, 0);
-	/* disable legacy audio address decode */
-	pci_write_config_word(pcidev, 0x40, 0x907f);
-
-	/* initialize the chips */
-	if (!reset_ctrl(s)) {
-		printk(KERN_ERR "esssolo1: cannot reset controller\n");
-		return -1;
-	}
-	outb(0xb0, s->iobase+7); /* enable A1, A2, MPU irq's */
-	
-	/* initialize mixer regs */
-	write_mixer(s, 0x7f, 0); /* disable music digital recording */
-	write_mixer(s, 0x7d, 0x0c); /* enable mic preamp, MONO_OUT is 2nd DAC right channel */
-	write_mixer(s, 0x64, 0x45); /* volume control */
-	write_mixer(s, 0x48, 0x10); /* enable music DAC/ES6xx interface */
-	write_mixer(s, 0x50, 0);  /* disable spatializer */
-	write_mixer(s, 0x52, 0);
-	write_mixer(s, 0x14, 0);  /* DAC1 minimum volume */
-	write_mixer(s, 0x71, 0x20); /* enable new 0xA1 reg format */
-	outb(0, s->ddmabase+0xd); /* DMA master clear */
-	outb(1, s->ddmabase+0xf); /* mask channel */
-	/*outb(0, s->ddmabase+0x8);*/ /* enable controller (enable is low active!!) */
-
-	pci_set_master(pcidev);  /* enable bus mastering */
-	
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	val = SOUND_MASK_LINE;
-	mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
-	for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
-		val = initvol[i].vol;
-		mixer_ioctl(s, initvol[i].mixch, (unsigned long)&val);
-	}
-	val = 1; /* enable mic preamp */
-	mixer_ioctl(s, SOUND_MIXER_PRIVATE1, (unsigned long)&val);
-	set_fs(fs);
-	return 0;
-}
-
-static int
-solo1_suspend(struct pci_dev *pci_dev, pm_message_t state) {
-	struct solo1_state *s = (struct solo1_state*)pci_get_drvdata(pci_dev);
-	if (!s)
-		return 1;
-	outb(0, s->iobase+6);
-	/* DMA master clear */
-	outb(0, s->ddmabase+0xd); 
-	/* reset sequencer and FIFO */
-	outb(3, s->sbbase+6); 
-	/* turn off DDMA controller address space */
-	pci_write_config_word(s->dev, 0x60, 0); 
-	return 0;
-}
-
-static int
-solo1_resume(struct pci_dev *pci_dev) {
-	struct solo1_state *s = (struct solo1_state*)pci_get_drvdata(pci_dev);
-	if (!s)
-		return 1;
-	setup_solo1(s);
-	return 0;
-}
-
-#ifdef SUPPORT_JOYSTICK
-static int __devinit solo1_register_gameport(struct solo1_state *s, int io_port)
-{
-	struct gameport *gp;
-
-	if (!request_region(io_port, GAMEPORT_EXTENT, "ESS Solo1")) {
-		printk(KERN_ERR "solo1: gameport io ports are in use\n");
-		return -EBUSY;
-	}
-
-	s->gameport = gp = gameport_allocate_port();
-	if (!gp) {
-		printk(KERN_ERR "solo1: can not allocate memory for gameport\n");
-		release_region(io_port, GAMEPORT_EXTENT);
-		return -ENOMEM;
-	}
-
-	gameport_set_name(gp, "ESS Solo1 Gameport");
-	gameport_set_phys(gp, "isa%04x/gameport0", io_port);
-	gp->dev.parent = &s->dev->dev;
-	gp->io = io_port;
-
-	gameport_register_port(gp);
-
-	return 0;
-}
-
-static inline void solo1_unregister_gameport(struct solo1_state *s)
-{
-	if (s->gameport) {
-		int gpio = s->gameport->io;
-		gameport_unregister_port(s->gameport);
-		release_region(gpio, GAMEPORT_EXTENT);
-	}
-}
-#else
-static inline int solo1_register_gameport(struct solo1_state *s, int io_port) { return -ENOSYS; }
-static inline void solo1_unregister_gameport(struct solo1_state *s) { }
-#endif /* SUPPORT_JOYSTICK */
-
-static int __devinit solo1_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
-{
-	struct solo1_state *s;
-	int gpio;
-	int ret;
-
- 	if ((ret=pci_enable_device(pcidev)))
-		return ret;
-	if (!(pci_resource_flags(pcidev, 0) & IORESOURCE_IO) ||
-	    !(pci_resource_flags(pcidev, 1) & IORESOURCE_IO) ||
-	    !(pci_resource_flags(pcidev, 2) & IORESOURCE_IO) ||
-	    !(pci_resource_flags(pcidev, 3) & IORESOURCE_IO))
-		return -ENODEV;
-	if (pcidev->irq == 0)
-		return -ENODEV;
-
-	/* Recording requires 24-bit DMA, so attempt to set dma mask
-	 * to 24 bits first, then 32 bits (playback only) if that fails.
-	 */
-	if (pci_set_dma_mask(pcidev, DMA_24BIT_MASK) &&
-	    pci_set_dma_mask(pcidev, DMA_32BIT_MASK)) {
-		printk(KERN_WARNING "solo1: architecture does not support 24bit or 32bit PCI busmaster DMA\n");
-		return -ENODEV;
-	}
-
-	if (!(s = kmalloc(sizeof(struct solo1_state), GFP_KERNEL))) {
-		printk(KERN_WARNING "solo1: out of memory\n");
-		return -ENOMEM;
-	}
-	memset(s, 0, sizeof(struct solo1_state));
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac.wait);
-	init_waitqueue_head(&s->open_wait);
-	init_waitqueue_head(&s->midi.iwait);
-	init_waitqueue_head(&s->midi.owait);
-	mutex_init(&s->open_mutex);
-	spin_lock_init(&s->lock);
-	s->magic = SOLO1_MAGIC;
-	s->dev = pcidev;
-	s->iobase = pci_resource_start(pcidev, 0);
-	s->sbbase = pci_resource_start(pcidev, 1);
-	s->vcbase = pci_resource_start(pcidev, 2);
-	s->ddmabase = s->vcbase + DDMABASE_OFFSET;
-	s->mpubase = pci_resource_start(pcidev, 3);
-	gpio = pci_resource_start(pcidev, 4);
-	s->irq = pcidev->irq;
-	ret = -EBUSY;
-	if (!request_region(s->iobase, IOBASE_EXTENT, "ESS Solo1")) {
-		printk(KERN_ERR "solo1: io ports in use\n");
-		goto err_region1;
-	}
-	if (!request_region(s->sbbase+FMSYNTH_EXTENT, SBBASE_EXTENT-FMSYNTH_EXTENT, "ESS Solo1")) {
-		printk(KERN_ERR "solo1: io ports in use\n");
-		goto err_region2;
-	}
-	if (!request_region(s->ddmabase, DDMABASE_EXTENT, "ESS Solo1")) {
-		printk(KERN_ERR "solo1: io ports in use\n");
-		goto err_region3;
-	}
-	if (!request_region(s->mpubase, MPUBASE_EXTENT, "ESS Solo1")) {
-		printk(KERN_ERR "solo1: io ports in use\n");
-		goto err_region4;
-	}
-	if ((ret=request_irq(s->irq,solo1_interrupt,IRQF_SHARED,"ESS Solo1",s))) {
-		printk(KERN_ERR "solo1: irq %u in use\n", s->irq);
-		goto err_irq;
-	}
-	/* register devices */
-	if ((s->dev_audio = register_sound_dsp(&solo1_audio_fops, -1)) < 0) {
-		ret = s->dev_audio;
-		goto err_dev1;
-	}
-	if ((s->dev_mixer = register_sound_mixer(&solo1_mixer_fops, -1)) < 0) {
-		ret = s->dev_mixer;
-		goto err_dev2;
-	}
-	if ((s->dev_midi = register_sound_midi(&solo1_midi_fops, -1)) < 0) {
-		ret = s->dev_midi;
-		goto err_dev3;
-	}
-	if ((s->dev_dmfm = register_sound_special(&solo1_dmfm_fops, 15 /* ?? */)) < 0) {
-		ret = s->dev_dmfm;
-		goto err_dev4;
-	}
-	if (setup_solo1(s)) {
-		ret = -EIO;
-		goto err;
-	}
-	/* register gameport */
-	solo1_register_gameport(s, gpio);
-	/* store it in the driver field */
-	pci_set_drvdata(pcidev, s);
-	return 0;
-
- err:
-	unregister_sound_special(s->dev_dmfm);
- err_dev4:
-	unregister_sound_midi(s->dev_midi);
- err_dev3:
-	unregister_sound_mixer(s->dev_mixer);
- err_dev2:
-	unregister_sound_dsp(s->dev_audio);
- err_dev1:
-	printk(KERN_ERR "solo1: initialisation error\n");
-	free_irq(s->irq, s);
- err_irq:
-	release_region(s->mpubase, MPUBASE_EXTENT);
- err_region4:
-	release_region(s->ddmabase, DDMABASE_EXTENT);
- err_region3:
-	release_region(s->sbbase+FMSYNTH_EXTENT, SBBASE_EXTENT-FMSYNTH_EXTENT);
- err_region2:
-	release_region(s->iobase, IOBASE_EXTENT);
- err_region1:
-	kfree(s);
-	return ret;
-}
-
-static void __devexit solo1_remove(struct pci_dev *dev)
-{
-	struct solo1_state *s = pci_get_drvdata(dev);
-	
-	if (!s)
-		return;
-	/* stop DMA controller */
-	outb(0, s->iobase+6);
-	outb(0, s->ddmabase+0xd); /* DMA master clear */
-	outb(3, s->sbbase+6); /* reset sequencer and FIFO */
-	synchronize_irq(s->irq);
-	pci_write_config_word(s->dev, 0x60, 0); /* turn off DDMA controller address space */
-	free_irq(s->irq, s);
-	solo1_unregister_gameport(s);
-	release_region(s->iobase, IOBASE_EXTENT);
-	release_region(s->sbbase+FMSYNTH_EXTENT, SBBASE_EXTENT-FMSYNTH_EXTENT);
-	release_region(s->ddmabase, DDMABASE_EXTENT);
-	release_region(s->mpubase, MPUBASE_EXTENT);
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->dev_mixer);
-	unregister_sound_midi(s->dev_midi);
-	unregister_sound_special(s->dev_dmfm);
-	kfree(s);
-	pci_set_drvdata(dev, NULL);
-}
-
-static struct pci_device_id id_table[] = {
-	{ PCI_VENDOR_ID_ESS, PCI_DEVICE_ID_ESS_SOLO1, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
-	{ 0, }
-};
-
-MODULE_DEVICE_TABLE(pci, id_table);
-
-static struct pci_driver solo1_driver = {
-	.name		= "ESS Solo1",
-	.id_table	= id_table,
-	.probe		= solo1_probe,
-	.remove		= __devexit_p(solo1_remove),
-	.suspend	= solo1_suspend,
-	.resume		= solo1_resume,
-};
-
-
-static int __init init_solo1(void)
-{
-	printk(KERN_INFO "solo1: version v0.20 time " __TIME__ " " __DATE__ "\n");
-	return pci_register_driver(&solo1_driver);
-}
-
-/* --------------------------------------------------------------------- */
-
-MODULE_AUTHOR("Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu");
-MODULE_DESCRIPTION("ESS Solo1 Driver");
-MODULE_LICENSE("GPL");
-
-
-static void __exit cleanup_solo1(void)
-{
-	printk(KERN_INFO "solo1: unloading\n");
-	pci_unregister_driver(&solo1_driver);
-}
-
-/* --------------------------------------------------------------------- */
-
-module_init(init_solo1);
-module_exit(cleanup_solo1);
-
--- linux-2.6.18.noarch/sound/oss/cmpci.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cmpci.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,3381 +0,0 @@
-/*
- *      cmpci.c  --  C-Media PCI audio driver.
- *
- *      Copyright (C) 1999  C-media support (support@cmedia.com.tw)
- *
- *      Based on the PCI drivers by Thomas Sailer (sailer@ife.ee.ethz.ch)
- *
- * 	For update, visit:
- * 		http://www.cmedia.com.tw
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Special thanks to David C. Niemi, Jan Pfeifer
- *
- *
- * Module command line parameters:
- *   none so far
- *
- *
- *  Supported devices:
- *  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible
- *  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
- *  /dev/midi   simple MIDI UART interface, no ioctl
- *
- *  The card has both an FM and a Wavetable synth, but I have to figure
- *  out first how to drive them...
- *
- *  Revision history
- *    06.05.98   0.1   Initial release
- *    10.05.98   0.2   Fixed many bugs, esp. ADC rate calculation
- *                     First stab at a simple midi interface (no bells&whistles)
- *    13.05.98   0.3   Fix stupid cut&paste error: set_adc_rate was called instead of
- *                     set_dac_rate in the FMODE_WRITE case in cm_open
- *                     Fix hwptr out of bounds (now mpg123 works)
- *    14.05.98   0.4   Don't allow excessive interrupt rates
- *    08.06.98   0.5   First release using Alan Cox' soundcore instead of miscdevice
- *    03.08.98   0.6   Do not include modversions.h
- *                     Now mixer behaviour can basically be selected between
- *                     "OSS documented" and "OSS actual" behaviour
- *    31.08.98   0.7   Fix realplayer problems - dac.count issues
- *    10.12.98   0.8   Fix drain_dac trying to wait on not yet initialized DMA
- *    16.12.98   0.9   Fix a few f_file & FMODE_ bugs
- *    06.01.99   0.10  remove the silly SA_INTERRUPT flag.
- *                     hopefully killed the egcs section type conflict
- *    12.03.99   0.11  cinfo.blocks should be reset after GETxPTR ioctl.
- *                     reported by Johan Maes <joma@telindus.be>
- *    22.03.99   0.12  return EAGAIN instead of EBUSY when O_NONBLOCK
- *                     read/write cannot be executed
- *    18.08.99   1.5   Only deallocate DMA buffer when unloading.
- *    02.09.99   1.6   Enable SPDIF LOOP
- *                     Change the mixer read back
- *    21.09.99   2.33  Use RCS version as driver version.
- *                     Add support for modem, S/PDIF loop and 4 channels.
- *                     (8738 only)
- *                     Fix bug cause x11amp cannot play.
- *
- *    Fixes:
- *    Arnaldo Carvalho de Melo <acme@conectiva.com.br>
- *    18/05/2001 - .bss nitpicks, fix a bug in set_dac_channels where it
- *    		   was calling prog_dmabuf with s->lock held, call missing
- *    		   unlock_kernel in cm_midi_release
- *    08/10/2001 - use set_current_state in some more places
- *
- *	Carlos Eduardo Gorges <carlos@techlinux.com.br>
- *	Fri May 25 2001
- *	- SMP support ( spin[un]lock* revision )
- *	- speaker mixer support
- *	Mon Aug 13 2001
- *	- optimizations and cleanups
- *
- *    03/01/2003 - open_mode fixes from Georg Acher <acher@in.tum.de>
- *	Simon Braunschmidt <brasimon@web.de>
- *     Sat Jan 31 2004
- *	- provide support for opl3 FM by releasing IO range after initialization
- *
- *    ChenLi Tien <cltien@cmedia.com.tw>
- *    Mar 9 2004
- *	- Fix S/PDIF out if spdif_loop enabled
- *	- Load opl3 driver if enabled (fmio in proper range)
- *	- Load mpu401 if enabled (mpuio in proper range)
- *    Apr 5 2004
- *	- Fix DUAL_DAC dma synchronization bug
- *	- Check exist FM/MPU401 I/O before activate.
- *	- Add AFTM_S16_BE format support, so MPlayer/Xine can play AC3/mutlichannel
- *	  on Mac
- *	- Change to support kernel 2.6 so only small patch needed
- *	- All parameters default to 0
- *	- Add spdif_out to send PCM through S/PDIF out jack
- *	- Add hw_copy to get 4-spaker output for general PCM/analog output
- *
- *    Stefan Thater <stefan.thaeter@gmx.de>
- *    Apr 5 2004
- *	- Fix mute single channel for CD/Line-in/AUX-in
- */
-/*****************************************************************************/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/spinlock.h>
-#include <linux/smp_lock.h>
-#include <linux/bitops.h>
-#include <linux/wait.h>
-#include <linux/dma-mapping.h>
-
-#include <asm/io.h>
-#include <asm/page.h>
-#include <asm/uaccess.h>
-
-#ifdef CONFIG_SOUND_CMPCI_MIDI
-#include "sound_config.h"
-#include "mpu401.h"
-#endif
-#ifdef CONFIG_SOUND_CMPCI_FM
-#include "opl3.h"
-#endif
-#ifdef CONFIG_SOUND_CMPCI_JOYSTICK
-#include <linux/gameport.h>
-#include <linux/mutex.h>
-
-#endif
-
-/* --------------------------------------------------------------------- */
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-#undef DMABYTEIO
-#define	DBG(x) {}
-/* --------------------------------------------------------------------- */
-
-#define CM_MAGIC  ((PCI_VENDOR_ID_CMEDIA<<16)|PCI_DEVICE_ID_CMEDIA_CM8338A)
-
-/* CM8338 registers definition ****************/
-
-#define CODEC_CMI_FUNCTRL0		(0x00)
-#define CODEC_CMI_FUNCTRL1		(0x04)
-#define CODEC_CMI_CHFORMAT		(0x08)
-#define CODEC_CMI_INT_HLDCLR		(0x0C)
-#define CODEC_CMI_INT_STATUS		(0x10)
-#define CODEC_CMI_LEGACY_CTRL		(0x14)
-#define CODEC_CMI_MISC_CTRL		(0x18)
-#define CODEC_CMI_TDMA_POS		(0x1C)
-#define CODEC_CMI_MIXER			(0x20)
-#define CODEC_SB16_DATA			(0x22)
-#define CODEC_SB16_ADDR			(0x23)
-#define CODEC_CMI_MIXER1		(0x24)
-#define CODEC_CMI_MIXER2		(0x25)
-#define CODEC_CMI_AUX_VOL		(0x26)
-#define CODEC_CMI_MISC			(0x27)
-#define CODEC_CMI_AC97			(0x28)
-
-#define CODEC_CMI_CH0_FRAME1		(0x80)
-#define CODEC_CMI_CH0_FRAME2		(0x84)
-#define CODEC_CMI_CH1_FRAME1		(0x88)
-#define CODEC_CMI_CH1_FRAME2		(0x8C)
-
-#define CODEC_CMI_SPDIF_CTRL		(0x90)
-#define CODEC_CMI_MISC_CTRL2		(0x92)
-
-#define CODEC_CMI_EXT_REG		(0xF0)
-
-/*  Mixer registers for SB16 ******************/
-
-#define DSP_MIX_DATARESETIDX		((unsigned char)(0x00))
-
-#define DSP_MIX_MASTERVOLIDX_L		((unsigned char)(0x30))
-#define DSP_MIX_MASTERVOLIDX_R		((unsigned char)(0x31))
-#define DSP_MIX_VOICEVOLIDX_L		((unsigned char)(0x32))
-#define DSP_MIX_VOICEVOLIDX_R		((unsigned char)(0x33))
-#define DSP_MIX_FMVOLIDX_L		((unsigned char)(0x34))
-#define DSP_MIX_FMVOLIDX_R		((unsigned char)(0x35))
-#define DSP_MIX_CDVOLIDX_L		((unsigned char)(0x36))
-#define DSP_MIX_CDVOLIDX_R		((unsigned char)(0x37))
-#define DSP_MIX_LINEVOLIDX_L		((unsigned char)(0x38))
-#define DSP_MIX_LINEVOLIDX_R		((unsigned char)(0x39))
-
-#define DSP_MIX_MICVOLIDX		((unsigned char)(0x3A))
-#define DSP_MIX_SPKRVOLIDX		((unsigned char)(0x3B))
-
-#define DSP_MIX_OUTMIXIDX		((unsigned char)(0x3C))
-
-#define DSP_MIX_ADCMIXIDX_L		((unsigned char)(0x3D))
-#define DSP_MIX_ADCMIXIDX_R		((unsigned char)(0x3E))
-
-#define DSP_MIX_INGAINIDX_L		((unsigned char)(0x3F))
-#define DSP_MIX_INGAINIDX_R		((unsigned char)(0x40))
-#define DSP_MIX_OUTGAINIDX_L		((unsigned char)(0x41))
-#define DSP_MIX_OUTGAINIDX_R		((unsigned char)(0x42))
-
-#define DSP_MIX_AGCIDX			((unsigned char)(0x43))
-
-#define DSP_MIX_TREBLEIDX_L		((unsigned char)(0x44))
-#define DSP_MIX_TREBLEIDX_R		((unsigned char)(0x45))
-#define DSP_MIX_BASSIDX_L		((unsigned char)(0x46))
-#define DSP_MIX_BASSIDX_R		((unsigned char)(0x47))
-#define DSP_MIX_EXTENSION		((unsigned char)(0xf0))
-// pseudo register for AUX
-#define	DSP_MIX_AUXVOL_L		((unsigned char)(0x50))
-#define	DSP_MIX_AUXVOL_R		((unsigned char)(0x51))
-
-// I/O length
-#define CM_EXTENT_CODEC	  0x100
-#define CM_EXTENT_MIDI	  0x2
-#define CM_EXTENT_SYNTH	  0x4
-#define CM_EXTENT_GAME	  0x8
-
-// Function Control Register 0 (00h)
-#define CHADC0    	0x01
-#define CHADC1    	0x02
-#define PAUSE0	  	0x04
-#define PAUSE1	  	0x08
-
-// Function Control Register 0+2 (02h)
-#define CHEN0     	0x01
-#define CHEN1     	0x02
-#define RST_CH0	  	0x04
-#define RST_CH1	  	0x08
-
-// Function Control Register 1 (04h)
-#define JYSTK_EN	0x02
-#define UART_EN		0x04
-#define	SPDO2DAC	0x40
-#define	SPDFLOOP	0x80
-
-// Function Control Register 1+1 (05h)
-#define	SPDF_0		0x01
-#define	SPDF_1		0x02
-#define	ASFC		0x1c
-#define	DSFC		0xe0
-#define	SPDIF2DAC	(SPDF_1 << 8 | SPDO2DAC)
-
-// Channel Format Register (08h)
-#define CM_CFMT_STEREO	0x01
-#define CM_CFMT_16BIT	0x02
-#define CM_CFMT_MASK	0x03
-#define	POLVALID	0x20
-#define	INVSPDIFI	0x80
-
-// Channel Format Register+2 (0ah)
-#define SPD24SEL	0x20
-
-// Channel Format Register+3 (0bh)
-#define CHB3D		0x20
-#define CHB3D5C		0x80
-
-// Interrupt Hold/Clear Register+2 (0eh)
-#define	CH0_INT_EN	0x01
-#define	CH1_INT_EN	0x02
-
-// Interrupt Register (10h)
-#define CHINT0		0x01
-#define CHINT1		0x02
-#define	CH0BUSY		0x04
-#define	CH1BUSY		0x08
-
-// Legacy Control/Status Register+1 (15h)
-#define	EXBASEN		0x10
-#define	BASE2LIN	0x20
-#define	CENTR2LIN	0x40
-#define	CB2LIN		(BASE2LIN | CENTR2LIN)
-#define	CHB3D6C		0x80
-
-// Legacy Control/Status Register+2 (16h)
-#define	DAC2SPDO	0x20
-#define	SPDCOPYRHT	0x40
-#define	ENSPDOUT	0x80
-
-// Legacy Control/Status Register+3 (17h)
-#define	FMSEL		0x03
-#define	VSBSEL		0x0c
-#define	VMPU		0x60
-#define	NXCHG		0x80
-
-// Miscellaneous Control Register (18h)
-#define	REAR2LIN	0x20
-#define	MUTECH1		0x40
-#define	ENCENTER	0x80
-
-// Miscellaneous Control Register+1 (19h)
-#define	SELSPDIFI2	0x01
-#define	SPDF_AC97	0x80
-
-// Miscellaneous Control Register+2 (1ah)
-#define	AC3_EN		0x04
-#define	FM_EN		0x08
-#define	SPD32SEL	0x20
-#define	XCHGDAC		0x40
-#define	ENDBDAC		0x80
-
-// Miscellaneous Control Register+3 (1bh)
-#define	SPDIFI48K	0x01
-#define	SPDO5V		0x02
-#define	N4SPK3D		0x04
-#define	RESET		0x40
-#define	PWD		0x80
-#define	SPDIF48K	(SPDIFI48K << 24 | SPDF_AC97 << 8)
-
-// Mixer1 (24h)
-#define	CDPLAY		0x01
-#define	X3DEN		0x02
-#define	REAR2FRONT	0x10
-#define	SPK4		0x20
-#define	WSMUTE		0x40
-#define	FMMUTE		0x80
-
-// Miscellaneous Register (27h)
-#define	SPDVALID	0x02
-#define	CENTR2MIC	0x04
-
-// Miscellaneous Register2 (92h)
-#define	SPD32KFMT	0x10
-
-#define CM_CFMT_DACSHIFT   2
-#define CM_CFMT_ADCSHIFT   0
-#define CM_FREQ_DACSHIFT   5
-#define CM_FREQ_ADCSHIFT   2
-#define	RSTDAC	RST_CH1
-#define	RSTADC	RST_CH0
-#define	ENDAC	CHEN1
-#define	ENADC	CHEN0
-#define	PAUSEDAC	PAUSE1
-#define	PAUSEADC	PAUSE0
-#define CODEC_CMI_ADC_FRAME1	CODEC_CMI_CH0_FRAME1
-#define CODEC_CMI_ADC_FRAME2	CODEC_CMI_CH0_FRAME2
-#define CODEC_CMI_DAC_FRAME1	CODEC_CMI_CH1_FRAME1
-#define CODEC_CMI_DAC_FRAME2	CODEC_CMI_CH1_FRAME2
-#define	DACINT	CHINT1
-#define	ADCINT	CHINT0
-#define	DACBUSY	CH1BUSY
-#define	ADCBUSY	CH0BUSY
-#define	ENDACINT	CH1_INT_EN
-#define	ENADCINT	CH0_INT_EN
-
-static const unsigned sample_size[] = { 1, 2, 2, 4 };
-static const unsigned sample_shift[]	= { 0, 1, 1, 2 };
-
-#define SND_DEV_DSP16   5
-
-#define NR_DEVICE 3		/* maximum number of devices */
-
-#define	set_dac1_rate	set_adc_rate
-#define	set_dac1_rate_unlocked	set_adc_rate_unlocked
-#define	stop_dac1	stop_adc
-#define	stop_dac1_unlocked	stop_adc_unlocked
-#define	get_dmadac1	get_dmaadc
-
-static unsigned int devindex = 0;
-
-//*********************************************/
-
-struct cm_state {
-	/* magic */
-	unsigned int magic;
-
-	/* list of cmedia devices */
-	struct list_head devs;
-
-	/* the corresponding pci_dev structure */
-	struct pci_dev *dev;
-
-	int dev_audio;			/* soundcore stuff */
-	int dev_mixer;
-
-	unsigned int iosb, iobase, iosynth,
-			 iomidi, iogame, irq;	/* hardware resources */
-	unsigned short deviceid;		/* pci_id */
-
-        struct {				/* mixer stuff */
-                unsigned int modcnt;
-		unsigned short vol[13];
-        } mix;
-
-	unsigned int rateadc, ratedac;		/* wave stuff */
-	unsigned char fmt, enable;
-
-	spinlock_t lock;
-	struct mutex open_mutex;
-	mode_t open_mode;
-	wait_queue_head_t open_wait;
-
-	struct dmabuf {
-		void *rawbuf;
-		dma_addr_t dmaaddr;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-		unsigned hwptr, swptr;
-		unsigned total_bytes;
-		int count;
-		unsigned error;		/* over/underrun */
-		wait_queue_head_t wait;
-
-		unsigned fragsize;	/* redundant, but makes calculations easier */
-		unsigned dmasize;
-		unsigned fragsamples;
-		unsigned dmasamples;
-
-		unsigned mapped:1;	/* OSS stuff */
-		unsigned ready:1;
-		unsigned endcleared:1;
-		unsigned enabled:1;
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-	} dma_dac, dma_adc;
-
-#ifdef CONFIG_SOUND_CMPCI_MIDI
-	int midi_devc;
-	struct address_info mpu_data;
-#endif
-#ifdef CONFIG_SOUND_CMPCI_JOYSTICK
-	struct gameport *gameport;
-#endif
-
-	int	chip_version;
-	int	max_channels;
-	int	curr_channels;
-	int	capability;		/* HW capability, various for chip versions */
-
-	int	status;			/* HW or SW state */
-
-	int	spdif_counter;		/* spdif frame counter */
-};
-
-/* flags used for capability */
-#define	CAN_AC3_HW		0x00000001		/* 037 or later */
-#define	CAN_AC3_SW		0x00000002		/* 033 or later */
-#define	CAN_AC3			(CAN_AC3_HW | CAN_AC3_SW)
-#define CAN_DUAL_DAC		0x00000004		/* 033 or later */
-#define	CAN_MULTI_CH_HW		0x00000008		/* 039 or later */
-#define	CAN_MULTI_CH		(CAN_MULTI_CH_HW | CAN_DUAL_DAC)
-#define	CAN_LINE_AS_REAR	0x00000010		/* 033 or later */
-#define	CAN_LINE_AS_BASS	0x00000020		/* 039 or later */
-#define	CAN_MIC_AS_BASS		0x00000040		/* 039 or later */
-
-/* flags used for status */
-#define	DO_AC3_HW		0x00000001
-#define	DO_AC3_SW		0x00000002
-#define	DO_AC3			(DO_AC3_HW | DO_AC3_SW)
-#define	DO_DUAL_DAC		0x00000004
-#define	DO_MULTI_CH_HW		0x00000008
-#define	DO_MULTI_CH		(DO_MULTI_CH_HW | DO_DUAL_DAC)
-#define	DO_LINE_AS_REAR		0x00000010		/* 033 or later */
-#define	DO_LINE_AS_BASS		0x00000020		/* 039 or later */
-#define	DO_MIC_AS_BASS		0x00000040		/* 039 or later */
-#define	DO_SPDIF_OUT		0x00000100
-#define	DO_SPDIF_IN		0x00000200
-#define	DO_SPDIF_LOOP		0x00000400
-#define	DO_BIGENDIAN_W		0x00001000		/* used in PowerPC */
-#define	DO_BIGENDIAN_R		0x00002000		/* used in PowerPC */
-
-static LIST_HEAD(devs);
-
-static	int	mpuio;
-static	int	fmio;
-static	int	joystick;
-static	int	spdif_inverse;
-static	int	spdif_loop;
-static	int	spdif_out;
-static	int	use_line_as_rear;
-static	int	use_line_as_bass;
-static	int	use_mic_as_bass;
-static	int	mic_boost;
-static	int	hw_copy;
-module_param(mpuio, int, 0);
-module_param(fmio, int, 0);
-module_param(joystick, bool, 0);
-module_param(spdif_inverse, bool, 0);
-module_param(spdif_loop, bool, 0);
-module_param(spdif_out, bool, 0);
-module_param(use_line_as_rear, bool, 0);
-module_param(use_line_as_bass, bool, 0);
-module_param(use_mic_as_bass, bool, 0);
-module_param(mic_boost, bool, 0);
-module_param(hw_copy, bool, 0);
-MODULE_PARM_DESC(mpuio, "(0x330, 0x320, 0x310, 0x300) Base of MPU-401, 0 to disable");
-MODULE_PARM_DESC(fmio, "(0x388, 0x3C8, 0x3E0) Base of OPL3, 0 to disable");
-MODULE_PARM_DESC(joystick, "(1/0) Enable joystick interface, still need joystick driver");
-MODULE_PARM_DESC(spdif_inverse, "(1/0) Invert S/PDIF-in signal");
-MODULE_PARM_DESC(spdif_loop, "(1/0) Route S/PDIF-in to S/PDIF-out directly");
-MODULE_PARM_DESC(spdif_out, "(1/0) Send PCM to S/PDIF-out (PCM volume will not function)");
-MODULE_PARM_DESC(use_line_as_rear, "(1/0) Use line-in jack as rear-out");
-MODULE_PARM_DESC(use_line_as_bass, "(1/0) Use line-in jack as bass/center");
-MODULE_PARM_DESC(use_mic_as_bass, "(1/0) Use mic-in jack as bass/center");
-MODULE_PARM_DESC(mic_boost, "(1/0) Enable microphone boost");
-MODULE_PARM_DESC(hw_copy, "Copy front channel to surround channel");
-
-/* --------------------------------------------------------------------- */
-
-static inline unsigned ld2(unsigned int x)
-{
-	unsigned exp=16,l=5,r=0;
-	static const unsigned num[]={0x2,0x4,0x10,0x100,0x10000};
-
-	/* num: 2, 4, 16, 256, 65536 */
-	/* exp: 1, 2,  4,   8,    16 */
-
-	while(l--) {
-		if( x >= num[l] ) {
-			if(num[l]>2) x >>= exp;
-			r+=exp;
-		}
-		exp>>=1;
-	}
-
-	return r;
-}
-
-/* --------------------------------------------------------------------- */
-
-static void maskb(unsigned int addr, unsigned int mask, unsigned int value)
-{
-	outb((inb(addr) & mask) | value, addr);
-}
-
-static void maskw(unsigned int addr, unsigned int mask, unsigned int value)
-{
-	outw((inw(addr) & mask) | value, addr);
-}
-
-static void maskl(unsigned int addr, unsigned int mask, unsigned int value)
-{
-	outl((inl(addr) & mask) | value, addr);
-}
-
-static void set_dmadac1(struct cm_state *s, unsigned int addr, unsigned int count)
-{
-	if (addr)
-	    outl(addr, s->iobase + CODEC_CMI_ADC_FRAME1);
-	outw(count - 1, s->iobase + CODEC_CMI_ADC_FRAME2);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~CHADC0, 0);
-}
-
-static void set_dmaadc(struct cm_state *s, unsigned int addr, unsigned int count)
-{
-	outl(addr, s->iobase + CODEC_CMI_ADC_FRAME1);
-	outw(count - 1, s->iobase + CODEC_CMI_ADC_FRAME2);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, CHADC0);
-}
-
-static void set_dmadac(struct cm_state *s, unsigned int addr, unsigned int count)
-{
-	outl(addr, s->iobase + CODEC_CMI_DAC_FRAME1);
-	outw(count - 1, s->iobase + CODEC_CMI_DAC_FRAME2);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~CHADC1, 0);
-	if (s->status & DO_DUAL_DAC)
-		set_dmadac1(s, 0, count);
-}
-
-static void set_countadc(struct cm_state *s, unsigned count)
-{
-	outw(count - 1, s->iobase + CODEC_CMI_ADC_FRAME2 + 2);
-}
-
-static void set_countdac(struct cm_state *s, unsigned count)
-{
-	outw(count - 1, s->iobase + CODEC_CMI_DAC_FRAME2 + 2);
-	if (s->status & DO_DUAL_DAC)
-	    set_countadc(s, count);
-}
-
-static unsigned get_dmadac(struct cm_state *s)
-{
-	unsigned int curr_addr;
-
-	curr_addr = inw(s->iobase + CODEC_CMI_DAC_FRAME2) + 1;
-	curr_addr <<= sample_shift[(s->fmt >> CM_CFMT_DACSHIFT) & CM_CFMT_MASK];
-	curr_addr = s->dma_dac.dmasize - curr_addr;
-
-	return curr_addr;
-}
-
-static unsigned get_dmaadc(struct cm_state *s)
-{
-	unsigned int curr_addr;
-
-	curr_addr = inw(s->iobase + CODEC_CMI_ADC_FRAME2) + 1;
-	curr_addr <<= sample_shift[(s->fmt >> CM_CFMT_ADCSHIFT) & CM_CFMT_MASK];
-	curr_addr = s->dma_adc.dmasize - curr_addr;
-
-	return curr_addr;
-}
-
-static void wrmixer(struct cm_state *s, unsigned char idx, unsigned char data)
-{
-	unsigned char regval, pseudo;
-
-	// pseudo register
-	if (idx == DSP_MIX_AUXVOL_L) {
-		data >>= 4;
-		data &= 0x0f;
-		regval = inb(s->iobase + CODEC_CMI_AUX_VOL) & ~0x0f;
-		outb(regval | data, s->iobase + CODEC_CMI_AUX_VOL);
-		return;
-	}
-	if (idx == DSP_MIX_AUXVOL_R) {
-		data &= 0xf0;
-		regval = inb(s->iobase + CODEC_CMI_AUX_VOL) & ~0xf0;
-		outb(regval | data, s->iobase + CODEC_CMI_AUX_VOL);
-		return;
-	}
-	outb(idx, s->iobase + CODEC_SB16_ADDR);
-	udelay(10);
-	// pseudo bits
-	if (idx == DSP_MIX_OUTMIXIDX) {
-		pseudo = data & ~0x1f;
-		pseudo >>= 1;
-		regval = inb(s->iobase + CODEC_CMI_MIXER2) & ~0x30;
-		outb(regval | pseudo, s->iobase + CODEC_CMI_MIXER2);
-	}
-	if (idx == DSP_MIX_ADCMIXIDX_L) {
-		pseudo = data & 0x80;
-		pseudo >>= 1;
-		regval = inb(s->iobase + CODEC_CMI_MIXER2) & ~0x40;
-		outb(regval | pseudo, s->iobase + CODEC_CMI_MIXER2);
-	}
-	if (idx == DSP_MIX_ADCMIXIDX_R) {
-		pseudo = data & 0x80;
-		regval = inb(s->iobase + CODEC_CMI_MIXER2) & ~0x80;
-		outb(regval | pseudo, s->iobase + CODEC_CMI_MIXER2);
-	}
-	outb(data, s->iobase + CODEC_SB16_DATA);
-	udelay(10);
-}
-
-static unsigned char rdmixer(struct cm_state *s, unsigned char idx)
-{
-	unsigned char v, pseudo;
-
-	// pseudo register
-	if (idx == DSP_MIX_AUXVOL_L) {
-		v = inb(s->iobase + CODEC_CMI_AUX_VOL) & 0x0f;
-		v <<= 4;
-		return v;
-	}
-	if (idx == DSP_MIX_AUXVOL_L) {
-		v = inb(s->iobase + CODEC_CMI_AUX_VOL) & 0xf0;
-		return v;
-	}
-	outb(idx, s->iobase + CODEC_SB16_ADDR);
-	udelay(10);
-	v = inb(s->iobase + CODEC_SB16_DATA);
-	udelay(10);
-	// pseudo bits
-	if (idx == DSP_MIX_OUTMIXIDX) {
-		pseudo = inb(s->iobase + CODEC_CMI_MIXER2) & 0x30;
-		pseudo <<= 1;
-		v |= pseudo;
-	}
-	if (idx == DSP_MIX_ADCMIXIDX_L) {
-		pseudo = inb(s->iobase + CODEC_CMI_MIXER2) & 0x40;
-		pseudo <<= 1;
-		v |= pseudo;
-	}
-	if (idx == DSP_MIX_ADCMIXIDX_R) {
-		pseudo = inb(s->iobase + CODEC_CMI_MIXER2) & 0x80;
-		v |= pseudo;
-	}
-	return v;
-}
-
-static void set_fmt_unlocked(struct cm_state *s, unsigned char mask, unsigned char data)
-{
-	if (mask && s->chip_version > 0) {	/* 8338 cannot keep this */
-		s->fmt = inb(s->iobase + CODEC_CMI_CHFORMAT);
-		udelay(10);
-	}
-	s->fmt = (s->fmt & mask) | data;
-	outb(s->fmt, s->iobase + CODEC_CMI_CHFORMAT);
-	udelay(10);
-}
-
-static void set_fmt(struct cm_state *s, unsigned char mask, unsigned char data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	set_fmt_unlocked(s,mask,data);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void frobindir(struct cm_state *s, unsigned char idx, unsigned char mask, unsigned char data)
-{
-	outb(idx, s->iobase + CODEC_SB16_ADDR);
-	udelay(10);
-	outb((inb(s->iobase + CODEC_SB16_DATA) & mask) | data, s->iobase + CODEC_SB16_DATA);
-	udelay(10);
-}
-
-static struct {
-	unsigned	rate;
-	unsigned	lower;
-	unsigned	upper;
-	unsigned char	freq;
-} rate_lookup[] =
-{
-	{ 5512,		(0 + 5512) / 2,		(5512 + 8000) / 2,	0 },
-	{ 8000,		(5512 + 8000) / 2,	(8000 + 11025) / 2,	4 },
-	{ 11025,	(8000 + 11025) / 2,	(11025 + 16000) / 2,	1 },
-	{ 16000,	(11025 + 16000) / 2,	(16000 + 22050) / 2,	5 },
-	{ 22050,	(16000 + 22050) / 2,	(22050 + 32000) / 2,	2 },
-	{ 32000,	(22050 + 32000) / 2,	(32000 + 44100) / 2,	6 },
-	{ 44100,	(32000 + 44100) / 2,	(44100 + 48000) / 2,	3 },
-	{ 48000,	(44100 + 48000) / 2,	48000,			7 }
-};
-
-static void set_spdif_copyright(struct cm_state *s, int spdif_copyright)
-{
-	/* enable SPDIF-in Copyright */
-	maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~SPDCOPYRHT, spdif_copyright ? SPDCOPYRHT : 0);
-}
-
-static void set_spdif_loop(struct cm_state *s, int spdif_loop)
-{
-	/* enable SPDIF loop */
-	if (spdif_loop) {
-		s->status |= DO_SPDIF_LOOP;
-		/* turn on spdif-in to spdif-out */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, SPDFLOOP);
-	} else {
-		s->status &= ~DO_SPDIF_LOOP;
-		/* turn off spdif-in to spdif-out */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~SPDFLOOP, 0);
-	}
-}
-
-static void set_spdif_monitor(struct cm_state *s, int channel)
-{
-	// SPDO2DAC
-	maskw(s->iobase + CODEC_CMI_FUNCTRL1, ~SPDO2DAC, channel == 2 ? SPDO2DAC : 0);
-	// CDPLAY
-	if (s->chip_version >= 39)
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~CDPLAY, channel ? CDPLAY : 0);
-}
-
-static void set_spdifout_level(struct cm_state *s, int level5v)
-{
-	/* SPDO5V */
-	if (s->chip_version > 0)
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~SPDO5V, level5v ? SPDO5V : 0);
-}
-
-static void set_spdifin_inverse(struct cm_state *s, int spdif_inverse)
-{
-	if (s->chip_version == 0)	/* 8338 has not this feature */
-		return;
-	if (spdif_inverse) {
-		/* turn on spdif-in inverse */
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_CHFORMAT, ~0, INVSPDIFI);
-		else
-			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 1);
-	} else {
-		/* turn off spdif-ininverse */
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_CHFORMAT, ~INVSPDIFI, 0);
-		else
-			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~1, 0);
-	}
-}
-
-static void set_spdifin_channel2(struct cm_state *s, int channel2)
-{
-	/* SELSPDIFI2 */
-	if (s->chip_version >= 39)
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 1, ~SELSPDIFI2, channel2 ? SELSPDIFI2 : 0);
-}
-
-static void set_spdifin_valid(struct cm_state *s, int valid)
-{
-	/* SPDVALID */
-	maskb(s->iobase + CODEC_CMI_MISC, ~SPDVALID, valid ? SPDVALID : 0);
-}
-
-static void set_spdifout_unlocked(struct cm_state *s, unsigned rate)
-{
-	if (rate != 48000 && rate != 44100)
-		rate = 0;
-	if (rate == 48000 || rate == 44100) {
-		set_spdif_loop(s, 0);
-		// SPDF_1
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~0, SPDF_1);
-		// SPDIFI48K SPDF_AC97
-		maskl(s->iobase + CODEC_CMI_MISC_CTRL, ~SPDIF48K, rate == 48000 ? SPDIF48K : 0);
-		if (s->chip_version >= 55)
-		// SPD32KFMT
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL2, ~SPD32KFMT, rate == 48000 ? SPD32KFMT : 0);
-		if (s->chip_version > 0)
-		// ENSPDOUT
-			maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~0, ENSPDOUT);
-		// monitor SPDIF out
-		set_spdif_monitor(s, 2);
-		s->status |= DO_SPDIF_OUT;
-	} else {
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~SPDF_1, 0);
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 2, ~ENSPDOUT, 0);
-		// monitor none
-		set_spdif_monitor(s, 0);
-		s->status &= ~DO_SPDIF_OUT;
-	}
-}
-
-static void set_spdifout(struct cm_state *s, unsigned rate)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	set_spdifout_unlocked(s,rate);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void set_spdifin_unlocked(struct cm_state *s, unsigned rate)
-{
-	if (rate == 48000 || rate == 44100) {
-		// SPDF_1
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~0, SPDF_1);
-		// SPDIFI48K SPDF_AC97
-		maskl(s->iobase + CODEC_CMI_MISC_CTRL, ~SPDIF48K, rate == 48000 ? SPDIF48K : 0);
-		s->status |= DO_SPDIF_IN;
-	} else {
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~SPDF_1, 0);
-		s->status &= ~DO_SPDIF_IN;
-	}
-}
-
-static void set_spdifin(struct cm_state *s, unsigned rate)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	set_spdifin_unlocked(s,rate);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-/* find parity for bit 4~30 */
-static unsigned parity(unsigned data)
-{
-	unsigned parity = 0;
-	int counter = 4;
-
-	data >>= 4;	// start from bit 4
-	while (counter <= 30) {
-		if (data & 1)
-			parity++;
-		data >>= 1;
-		counter++;
-	}
-	return parity & 1;
-}
-
-static void set_ac3_unlocked(struct cm_state *s, unsigned rate)
-{
-	if (!(s->capability & CAN_AC3))
-		return;
-	/* enable AC3 */
-	if (rate && rate != 44100)
-		rate = 48000;
-	if (rate == 48000 || rate == 44100) {
-		// mute DAC
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~0, WSMUTE);
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL, ~0, MUTECH1);
-		// AC3EN for 039, 0x04
-		if (s->chip_version >= 39) {
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, AC3_EN);
-			if (s->chip_version == 55)
-				maskb(s->iobase + CODEC_CMI_SPDIF_CTRL, ~2, 0);
-		// AC3EN for 037, 0x10
-		} else if (s->chip_version == 37)
-			maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 0x10);
-		if (s->capability & CAN_AC3_HW) {
-			// SPD24SEL for 039, 0x20, but cannot be set
-			if (s->chip_version == 39)
-				maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, SPD24SEL);
-			// SPD24SEL for 037, 0x02
-			else if (s->chip_version == 37)
-				maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~0, 0x02);
-			if (s->chip_version >= 39)
-				maskb(s->iobase + CODEC_CMI_MIXER1, ~CDPLAY, 0);
-
-			s->status |= DO_AC3_HW;
-		 } else {
-			// SPD32SEL for 037 & 039
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, SPD32SEL);
-			// set 176K sample rate to fix 033 HW bug
-			if (s->chip_version == 33) {
-				if (rate == 48000)
-					maskb(s->iobase + CODEC_CMI_CHFORMAT + 1, ~0, 0x08);
-				else
-					maskb(s->iobase + CODEC_CMI_CHFORMAT + 1, ~0x08, 0);
-			}
-			s->status |= DO_AC3_SW;
-		}
-	} else {
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~WSMUTE, 0);
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL, ~MUTECH1, 0);
-		maskb(s->iobase + CODEC_CMI_CHFORMAT + 2, ~(SPD24SEL|0x12), 0);
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~(SPD32SEL|AC3_EN), 0);
-		if (s->chip_version == 33)
-			maskb(s->iobase + CODEC_CMI_CHFORMAT + 1, ~0x08, 0);
-		if (s->chip_version >= 39)
-			maskb(s->iobase + CODEC_CMI_MIXER1, ~0, CDPLAY);
-		s->status &= ~DO_AC3;
-	}
-	s->spdif_counter = 0;
-}
-
-static void set_line_as_rear(struct cm_state *s, int use_line_as_rear)
-{
-	if (!(s->capability & CAN_LINE_AS_REAR))
-		return;
-	if (use_line_as_rear) {
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~0, SPK4);
-		s->status |= DO_LINE_AS_REAR;
-	} else {
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~SPK4, 0);
-		s->status &= ~DO_LINE_AS_REAR;
-	}
-}
-
-static void set_line_as_bass(struct cm_state *s, int use_line_as_bass)
-{
-	if (!(s->capability & CAN_LINE_AS_BASS))
-		return;
-	if (use_line_as_bass) {
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~0, CB2LIN);
-		s->status |= DO_LINE_AS_BASS;
-	} else {
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~CB2LIN, 0);
-		s->status &= ~DO_LINE_AS_BASS;
-	}
-}
-
-static void set_mic_as_bass(struct cm_state *s, int use_mic_as_bass)
-{
-	if (!(s->capability & CAN_MIC_AS_BASS))
-		return;
-	if (use_mic_as_bass) {
-		maskb(s->iobase + CODEC_CMI_MISC, ~0, 0x04);
-		s->status |= DO_MIC_AS_BASS;
-	} else {
-		maskb(s->iobase + CODEC_CMI_MISC, ~0x04, 0);
-		s->status &= ~DO_MIC_AS_BASS;
-	}
-}
-
-static void set_hw_copy(struct cm_state *s, int hw_copy)
-{
-    	if (s->max_channels > 2 && hw_copy)
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~0, N4SPK3D);
-    	else
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 3, ~N4SPK3D, 0);
-}
-
-static void set_ac3(struct cm_state *s, unsigned rate)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	set_spdifout_unlocked(s, rate);
-	set_ac3_unlocked(s, rate);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static int trans_ac3(struct cm_state *s, void *dest, const char __user *source, int size)
-{
-	int   i = size / 2;
-	unsigned long data;
-	unsigned short data16;
-	unsigned long *dst = (unsigned long *) dest;
-	unsigned short __user *src = (unsigned short __user *)source;
-	int err;
-
-	do {
-		if ((err = __get_user(data16, src++)))
-			return err;
-		data = (unsigned long)le16_to_cpu(data16);
-		data <<= 12;			// ok for 16-bit data
-		if (s->spdif_counter == 2 || s->spdif_counter == 3)
-			data |= 0x40000000;	// indicate AC-3 raw data
-		if (parity(data))
-			data |= 0x80000000;	// parity
-		if (s->spdif_counter == 0)
-			data |= 3;		// preamble 'M'
-		else if (s->spdif_counter & 1)
-			data |= 5;		// odd, 'W'
-		else
-			data |= 9;		// even, 'M'
-		*dst++ = cpu_to_le32(data);
-		s->spdif_counter++;
-		if (s->spdif_counter == 384)
-			s->spdif_counter = 0;
-	} while (--i);
-
-	return 0;
-}
-
-static void set_adc_rate_unlocked(struct cm_state *s, unsigned rate)
-{
-	unsigned char freq = 4;
-	int	i;
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 8000)
-		rate = 8000;
-	for (i = 0; i < sizeof(rate_lookup) / sizeof(rate_lookup[0]); i++) {
-		if (rate > rate_lookup[i].lower && rate <= rate_lookup[i].upper) {
-			rate = rate_lookup[i].rate;
-			freq = rate_lookup[i].freq;
-			break;
-	    	}
-	}
-	s->rateadc = rate;
-	freq <<= CM_FREQ_ADCSHIFT;
-
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~ASFC, freq);
-}
-
-static void set_adc_rate(struct cm_state *s, unsigned rate)
-{
-	unsigned long flags;
-	unsigned char freq = 4;
-	int	i;
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 8000)
-		rate = 8000;
-	for (i = 0; i < sizeof(rate_lookup) / sizeof(rate_lookup[0]); i++) {
-		if (rate > rate_lookup[i].lower && rate <= rate_lookup[i].upper) {
-			rate = rate_lookup[i].rate;
-			freq = rate_lookup[i].freq;
-			break;
-	    	}
-	}
-	s->rateadc = rate;
-	freq <<= CM_FREQ_ADCSHIFT;
-
-	spin_lock_irqsave(&s->lock, flags);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~ASFC, freq);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void set_dac_rate(struct cm_state *s, unsigned rate)
-{
-	unsigned long flags;
-	unsigned char freq = 4;
-	int	i;
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 8000)
-		rate = 8000;
-	for (i = 0; i < sizeof(rate_lookup) / sizeof(rate_lookup[0]); i++) {
-		if (rate > rate_lookup[i].lower && rate <= rate_lookup[i].upper) {
-			rate = rate_lookup[i].rate;
-			freq = rate_lookup[i].freq;
-			break;
-	    	}
-	}
-	s->ratedac = rate;
-	freq <<= CM_FREQ_DACSHIFT;
-
-	spin_lock_irqsave(&s->lock, flags);
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1 + 1, ~DSFC, freq);
-	spin_unlock_irqrestore(&s->lock, flags);
-
-	if (s->curr_channels <= 2 && spdif_out)
-		set_spdifout(s, rate);
-	if (s->status & DO_DUAL_DAC)
-		set_dac1_rate(s, rate);
-}
-
-/* --------------------------------------------------------------------- */
-static inline void reset_adc(struct cm_state *s)
-{
-	/* reset bus master */
-	outb(s->enable | RSTADC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	udelay(10);
-	outb(s->enable & ~RSTADC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-}
-
-static inline void reset_dac(struct cm_state *s)
-{
-	/* reset bus master */
-	outb(s->enable | RSTDAC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	udelay(10);
-	outb(s->enable & ~RSTDAC, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	if (s->status & DO_DUAL_DAC)
-		reset_adc(s);
-}
-
-static inline void pause_adc(struct cm_state *s)
-{
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, PAUSEADC);
-}
-
-static inline void pause_dac(struct cm_state *s)
-{
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~0, PAUSEDAC);
-	if (s->status & DO_DUAL_DAC)
-		pause_adc(s);
-}
-
-static inline void disable_adc(struct cm_state *s)
-{
-	/* disable channel */
-	s->enable &= ~ENADC;
-	outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	reset_adc(s);
-}
-
-static inline void disable_dac(struct cm_state *s)
-{
-	/* disable channel */
-	s->enable &= ~ENDAC;
-	outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	reset_dac(s);
-	if (s->status & DO_DUAL_DAC)
-		disable_adc(s);
-}
-
-static inline void enable_adc(struct cm_state *s)
-{
-	if (!(s->enable & ENADC)) {
-		/* enable channel */
-		s->enable |= ENADC;
-		outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	}
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~PAUSEADC, 0);
-}
-
-static inline void enable_dac_unlocked(struct cm_state *s)
-{
-	if (!(s->enable & ENDAC)) {
-		/* enable channel */
-		s->enable |= ENDAC;
-		outb(s->enable, s->iobase + CODEC_CMI_FUNCTRL0 + 2);
-	}
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~PAUSEDAC, 0);
-
-	if (s->status & DO_DUAL_DAC)
-		enable_adc(s);
-}
-
-static inline void stop_adc_unlocked(struct cm_state *s)
-{
-	if (s->enable & ENADC) {
-		/* disable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~ENADCINT, 0);
-		disable_adc(s);
-	}
-}
-
-static inline void stop_adc(struct cm_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	stop_adc_unlocked(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-
-}
-
-static inline void stop_dac_unlocked(struct cm_state *s)
-{
-	if (s->enable & ENDAC) {
-		/* disable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~ENDACINT, 0);
-		disable_dac(s);
-	}
-	if (s->status & DO_DUAL_DAC)
-		stop_dac1_unlocked(s);
-}
-
-static inline void stop_dac(struct cm_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	stop_dac_unlocked(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static inline void start_adc_unlocked(struct cm_state *s)
-{
-	if ((s->dma_adc.mapped || s->dma_adc.count < (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize))
-	    && s->dma_adc.ready) {
-		/* enable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, ENADCINT);
-		enable_adc(s);
-	}
-}
-
-static void start_adc(struct cm_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	start_adc_unlocked(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static void start_dac1_unlocked(struct cm_state *s)
-{
-	if ((s->dma_adc.mapped || s->dma_adc.count > 0) && s->dma_adc.ready) {
-		/* enable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, ENADCINT);
- 		enable_dac_unlocked(s);
-	}
-}
-
-static void start_dac_unlocked(struct cm_state *s)
-{
-	if ((s->dma_dac.mapped || s->dma_dac.count > 0) && s->dma_dac.ready) {
-		/* enable interrupt */
-		maskb(s->iobase + CODEC_CMI_INT_HLDCLR + 2, ~0, ENDACINT);
-		enable_dac_unlocked(s);
-	}
-	if (s->status & DO_DUAL_DAC)
-		start_dac1_unlocked(s);
-}
-
-static void start_dac(struct cm_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	start_dac_unlocked(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-static int prog_dmabuf(struct cm_state *s, unsigned rec);
-
-static int set_dac_channels(struct cm_state *s, int channels)
-{
-	unsigned long flags;
-	static unsigned int fmmute = 0;
-
-	spin_lock_irqsave(&s->lock, flags);
-
-	if ((channels > 2) && (channels <= s->max_channels)
-	 && (((s->fmt >> CM_CFMT_DACSHIFT) & CM_CFMT_MASK) == (CM_CFMT_STEREO | CM_CFMT_16BIT))) {
-	    set_spdifout_unlocked(s, 0);
-	    if (s->capability & CAN_MULTI_CH_HW) {
-		// NXCHG
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0, NXCHG);
-		// CHB3D or CHB3D5C
-	       	maskb(s->iobase + CODEC_CMI_CHFORMAT + 3, ~(CHB3D5C|CHB3D), channels > 4 ? CHB3D5C : CHB3D);
-		// CHB3D6C
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~CHB3D6C, channels == 6 ? CHB3D6C : 0);
-		// ENCENTER
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL, ~ENCENTER, channels == 6 ? ENCENTER : 0);
-		s->status |= DO_MULTI_CH_HW;
-	    } else if (s->capability & CAN_DUAL_DAC) {
-		unsigned char fmtm = ~0, fmts = 0;
-		ssize_t ret;
-
-		// ENDBDAC, turn on double DAC mode
-		// XCHGDAC, CH0 -> back, CH1->front
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, ENDBDAC|XCHGDAC);
-		// mute FM
-		fmmute = inb(s->iobase + CODEC_CMI_MIXER1) & FMMUTE;
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~0, FMMUTE);
-		s->status |= DO_DUAL_DAC;
-		// prepare secondary buffer
-		spin_unlock_irqrestore(&s->lock, flags);
-		ret = prog_dmabuf(s, 1);
-		if (ret) return ret;
-		spin_lock_irqsave(&s->lock, flags);
-
-		// copy the hw state
-		fmtm &= ~((CM_CFMT_STEREO | CM_CFMT_16BIT) << CM_CFMT_DACSHIFT);
-		fmtm &= ~((CM_CFMT_STEREO | CM_CFMT_16BIT) << CM_CFMT_ADCSHIFT);
-		// the HW only support 16-bit stereo
-		fmts |= CM_CFMT_16BIT << CM_CFMT_DACSHIFT;
-		fmts |= CM_CFMT_16BIT << CM_CFMT_ADCSHIFT;
-		fmts |= CM_CFMT_STEREO << CM_CFMT_DACSHIFT;
-		fmts |= CM_CFMT_STEREO << CM_CFMT_ADCSHIFT;
-
-		set_fmt_unlocked(s, fmtm, fmts);
-		set_adc_rate_unlocked(s, s->ratedac);
-	    }
-	    // disable 4 speaker mode (analog duplicate)
-	    set_hw_copy(s, 0);
-	    s->curr_channels = channels;
-
-	    // enable jack redirect
-	    set_line_as_rear(s, use_line_as_rear);
-	    if (channels > 4) {
-		    set_line_as_bass(s, use_line_as_bass);
-		    set_mic_as_bass(s, use_mic_as_bass);
-	    }
-	} else {
-	    if (s->status & DO_MULTI_CH_HW) {
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~NXCHG, 0);
-		maskb(s->iobase + CODEC_CMI_CHFORMAT + 3, ~(CHB3D5C|CHB3D), 0);
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 1, ~CHB3D6C, 0);
-	    } else if (s->status & DO_DUAL_DAC) {
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~ENDBDAC, 0);
-		maskb(s->iobase + CODEC_CMI_MIXER1, ~FMMUTE, fmmute);
-	    }
-	    // enable 4 speaker mode (analog duplicate)
-	    set_hw_copy(s, hw_copy);
-	    s->status &= ~DO_MULTI_CH;
-	    s->curr_channels = s->fmt & (CM_CFMT_STEREO << CM_CFMT_DACSHIFT) ? 2 : 1;
-	    // disable jack redirect
-	    set_line_as_rear(s, hw_copy ? use_line_as_rear : 0);
-	    set_line_as_bass(s, 0);
-	    set_mic_as_bass(s, 0);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return s->curr_channels;
-}
-
-/* --------------------------------------------------------------------- */
-
-#define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-static void dealloc_dmabuf(struct cm_state *s, struct dmabuf *db)
-{
-	struct page *pstart, *pend;
-
-	if (db->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (pstart = virt_to_page(db->rawbuf); pstart <= pend; pstart++)
-			ClearPageReserved(pstart);
-		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder, db->rawbuf, db->dmaaddr);
-	}
-	db->rawbuf = NULL;
-	db->mapped = db->ready = 0;
-}
-
-/* Ch1 is used for playback, Ch0 is used for recording */
-
-static int prog_dmabuf(struct cm_state *s, unsigned rec)
-{
-	struct dmabuf *db = rec ? &s->dma_adc : &s->dma_dac;
-	unsigned rate = rec ? s->rateadc : s->ratedac;
-	int order;
-	unsigned bytepersec;
-	unsigned bufs;
-	struct page *pstart, *pend;
-	unsigned char fmt;
-	unsigned long flags;
-
-	fmt = s->fmt;
-	if (rec) {
-		stop_adc(s);
-		fmt >>= CM_CFMT_ADCSHIFT;
-	} else {
-		stop_dac(s);
-		fmt >>= CM_CFMT_DACSHIFT;
-	}
-
-	fmt &= CM_CFMT_MASK;
-	db->hwptr = db->swptr = db->total_bytes = db->count = db->error = db->endcleared = 0;
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-		for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = pci_alloc_consistent(s->dev, PAGE_SIZE << order, &db->dmaaddr)))
-				break;
-		if (!db->rawbuf || !db->dmaaddr)
-			return -ENOMEM;
-		db->buforder = order;
-		/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (pstart = virt_to_page(db->rawbuf); pstart <= pend; pstart++)
-			SetPageReserved(pstart);
-	}
-	bytepersec = rate << sample_shift[fmt];
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < bytepersec)
-			db->fragshift = ld2(bytepersec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(bytepersec/100/(db->subdivision ? db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3;
-	}
-	db->numfrag = bufs >> db->fragshift;
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->numfrag = bufs >> db->fragshift;
-	}
-	db->fragsize = 1 << db->fragshift;
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
- 	/* to make fragsize >= 4096 */
-	db->fragsamples = db->fragsize >> sample_shift[fmt];
-	db->dmasize = db->numfrag << db->fragshift;
-	db->dmasamples = db->dmasize >> sample_shift[fmt];
-	memset(db->rawbuf, (fmt & CM_CFMT_16BIT) ? 0 : 0x80, db->dmasize);
-	spin_lock_irqsave(&s->lock, flags);
-	if (rec) {
-		if (s->status & DO_DUAL_DAC)
-		    set_dmadac1(s, db->dmaaddr, db->dmasize >> sample_shift[fmt]);
-		else
-		    set_dmaadc(s, db->dmaaddr, db->dmasize >> sample_shift[fmt]);
-		/* program sample counts */
-		set_countdac(s, db->fragsamples);
-	} else {
-		set_dmadac(s, db->dmaaddr, db->dmasize >> sample_shift[fmt]);
-		/* program sample counts */
-		set_countdac(s, db->fragsamples);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	db->enabled = 1;
-	db->ready = 1;
-	return 0;
-}
-
-static inline void clear_advance(struct cm_state *s)
-{
-	unsigned char c = (s->fmt & (CM_CFMT_16BIT << CM_CFMT_DACSHIFT)) ? 0 : 0x80;
-	unsigned char *buf = s->dma_dac.rawbuf;
-	unsigned char *buf1 = s->dma_adc.rawbuf;
-	unsigned bsize = s->dma_dac.dmasize;
-	unsigned bptr = s->dma_dac.swptr;
-	unsigned len = s->dma_dac.fragsize;
-
-	if (bptr + len > bsize) {
-		unsigned x = bsize - bptr;
-		memset(buf + bptr, c, x);
-		if (s->status & DO_DUAL_DAC)
-			memset(buf1 + bptr, c, x);
-		bptr = 0;
-		len -= x;
-	}
-	memset(buf + bptr, c, len);
-	if (s->status & DO_DUAL_DAC)
-		memset(buf1 + bptr, c, len);
-}
-
-/* call with spinlock held! */
-static void cm_update_ptr(struct cm_state *s)
-{
-	unsigned hwptr;
-	int diff;
-
-	/* update ADC pointer */
-	if (s->dma_adc.ready) {
-	    if (s->status & DO_DUAL_DAC) {
-		    /* the dac part will finish for this */
-	    } else {
-		hwptr = get_dmaadc(s) % s->dma_adc.dmasize;
-		diff = (s->dma_adc.dmasize + hwptr - s->dma_adc.hwptr) % s->dma_adc.dmasize;
-		s->dma_adc.hwptr = hwptr;
-		s->dma_adc.total_bytes += diff;
-		s->dma_adc.count += diff;
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-			wake_up(&s->dma_adc.wait);
-		if (!s->dma_adc.mapped) {
-			if (s->dma_adc.count > (signed)(s->dma_adc.dmasize - ((3 * s->dma_adc.fragsize) >> 1))) {
-				pause_adc(s);
-				s->dma_adc.error++;
-			}
-		}
-	    }
-	}
-	/* update DAC pointer */
-	if (s->dma_dac.ready) {
-		hwptr = get_dmadac(s) % s->dma_dac.dmasize;
-		diff = (s->dma_dac.dmasize + hwptr - s->dma_dac.hwptr) % s->dma_dac.dmasize;
-		s->dma_dac.hwptr = hwptr;
-		s->dma_dac.total_bytes += diff;
-		if (s->status & DO_DUAL_DAC) {
-			s->dma_adc.hwptr = hwptr;
-			s->dma_adc.total_bytes += diff;
-		}
-		if (s->dma_dac.mapped) {
-			s->dma_dac.count += diff;
-			if (s->status & DO_DUAL_DAC)
-				s->dma_adc.count += diff;
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize)
-				wake_up(&s->dma_dac.wait);
-		} else {
-			s->dma_dac.count -= diff;
-			if (s->status & DO_DUAL_DAC)
-				s->dma_adc.count -= diff;
-			if (s->dma_dac.count <= 0) {
-				pause_dac(s);
-				s->dma_dac.error++;
-			} else if (s->dma_dac.count <= (signed)s->dma_dac.fragsize && !s->dma_dac.endcleared) {
-				clear_advance(s);
-				s->dma_dac.endcleared = 1;
-				if (s->status & DO_DUAL_DAC)
-					s->dma_adc.endcleared = 1;
-			}
-			if (s->dma_dac.count + (signed)s->dma_dac.fragsize <= (signed)s->dma_dac.dmasize)
-				wake_up(&s->dma_dac.wait);
-		}
-	}
-}
-
-static irqreturn_t cm_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-        struct cm_state *s = (struct cm_state *)dev_id;
-	unsigned int intsrc, intstat;
-	unsigned char mask = 0;
-
-	/* fastpath out, to ease interrupt sharing */
-	intsrc = inl(s->iobase + CODEC_CMI_INT_STATUS);
-	if (!(intsrc & 0x80000000))
-		return IRQ_NONE;
-	spin_lock(&s->lock);
-	intstat = inb(s->iobase + CODEC_CMI_INT_HLDCLR + 2);
-	/* acknowledge interrupt */
-	if (intsrc & ADCINT)
-		mask |= ENADCINT;
-	if (intsrc & DACINT)
-		mask |= ENDACINT;
-	outb(intstat & ~mask, s->iobase + CODEC_CMI_INT_HLDCLR + 2);
-	outb(intstat | mask, s->iobase + CODEC_CMI_INT_HLDCLR + 2);
-	cm_update_ptr(s);
-	spin_unlock(&s->lock);
-#ifdef CONFIG_SOUND_CMPCI_MIDI
-	if (intsrc & 0x00010000) {	// UART interrupt
-		if (s->midi_devc && intchk_mpu401((void *)s->midi_devc))
-			mpuintr(irq, (void *)s->midi_devc, regs);
-		else
-			inb(s->iomidi);// dummy read
-	}
-#endif
-	return IRQ_HANDLED;
-}
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT "cmpci: invalid magic value\n";
-
-#define VALIDATE_STATE(s)                         \
-({                                                \
-	if (!(s) || (s)->magic != CM_MAGIC) { \
-		printk(invalid_magic);            \
-		return -ENXIO;                    \
-	}                                         \
-})
-
-/* --------------------------------------------------------------------- */
-
-#define MT_4          1
-#define MT_5MUTE      2
-#define MT_4MUTEMONO  3
-#define MT_6MUTE      4
-#define MT_5MUTEMONO  5
-
-static const struct {
-	unsigned left;
-	unsigned right;
-	unsigned type;
-	unsigned rec;
-	unsigned play;
-} mixtable[SOUND_MIXER_NRDEVICES] = {
-	[SOUND_MIXER_CD]     = { DSP_MIX_CDVOLIDX_L,     DSP_MIX_CDVOLIDX_R,     MT_5MUTE,     0x04, 0x06 },
-	[SOUND_MIXER_LINE]   = { DSP_MIX_LINEVOLIDX_L,   DSP_MIX_LINEVOLIDX_R,   MT_5MUTE,     0x10, 0x18 },
-	[SOUND_MIXER_MIC]    = { DSP_MIX_MICVOLIDX,      DSP_MIX_MICVOLIDX,      MT_5MUTEMONO, 0x01, 0x01 },
-	[SOUND_MIXER_SYNTH]  = { DSP_MIX_FMVOLIDX_L,  	 DSP_MIX_FMVOLIDX_R,     MT_5MUTE,     0x40, 0x00 },
-	[SOUND_MIXER_VOLUME] = { DSP_MIX_MASTERVOLIDX_L, DSP_MIX_MASTERVOLIDX_R, MT_5MUTE,     0x00, 0x00 },
-	[SOUND_MIXER_PCM]    = { DSP_MIX_VOICEVOLIDX_L,  DSP_MIX_VOICEVOLIDX_R,  MT_5MUTE,     0x00, 0x00 },
-	[SOUND_MIXER_LINE1]  = { DSP_MIX_AUXVOL_L,       DSP_MIX_AUXVOL_R,       MT_5MUTE,     0x80, 0x60 },
-	[SOUND_MIXER_SPEAKER]= { DSP_MIX_SPKRVOLIDX,	 DSP_MIX_SPKRVOLIDX,	 MT_5MUTEMONO, 0x00, 0x01 }
-};
-
-static const unsigned char volidx[SOUND_MIXER_NRDEVICES] =
-{
-	[SOUND_MIXER_CD]     = 1,
-	[SOUND_MIXER_LINE]   = 2,
-	[SOUND_MIXER_MIC]    = 3,
-	[SOUND_MIXER_SYNTH]  = 4,
-	[SOUND_MIXER_VOLUME] = 5,
-	[SOUND_MIXER_PCM]    = 6,
-	[SOUND_MIXER_LINE1]  = 7,
-	[SOUND_MIXER_SPEAKER]= 8
-};
-
-static unsigned mixer_outmask(struct cm_state *s)
-{
-	unsigned long flags;
-	int i, j, k;
-
-	spin_lock_irqsave(&s->lock, flags);
-	j = rdmixer(s, DSP_MIX_OUTMIXIDX);
-	spin_unlock_irqrestore(&s->lock, flags);
-	for (k = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-		if (j & mixtable[i].play)
-			k |= 1 << i;
-	return k;
-}
-
-static unsigned mixer_recmask(struct cm_state *s)
-{
-	unsigned long flags;
-	int i, j, k;
-
-	spin_lock_irqsave(&s->lock, flags);
-	j = rdmixer(s, DSP_MIX_ADCMIXIDX_L);
-	spin_unlock_irqrestore(&s->lock, flags);
-	for (k = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-		if (j & mixtable[i].rec)
-			k |= 1 << i;
-	return k;
-}
-
-static int mixer_ioctl(struct cm_state *s, unsigned int cmd, unsigned long arg)
-{
-	unsigned long flags;
-	int i, val, j;
-	unsigned char l, r, rl, rr;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_STATE(s);
-        if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		memset(&info, 0, sizeof(info));
-		strlcpy(info.id, "cmpci", sizeof(info.id));
-		strlcpy(info.name, "C-Media PCI", sizeof(info.name));
-		info.modify_counter = s->mix.modcnt;
-		if (copy_to_user(argp, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == SOUND_OLD_MIXER_INFO) {
-		_old_mixer_info info;
-		memset(&info, 0, sizeof(info));
-		strlcpy(info.id, "cmpci", sizeof(info.id));
-		strlcpy(info.name, "C-Media cmpci", sizeof(info.name));
-		if (copy_to_user(argp, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, p);
-	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
-                return -EINVAL;
-        if (_SIOC_DIR(cmd) == _SIOC_READ) {
-                switch (_IOC_NR(cmd)) {
-                case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-			val = mixer_recmask(s);
-			return put_user(val, p);
-
-                case SOUND_MIXER_OUTSRC: /* Arg contains a bit for each recording source */
-			val = mixer_outmask(s);
-			return put_user(val, p);
-
-                case SOUND_MIXER_DEVMASK: /* Arg contains a bit for each supported device */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].type)
-					val |= 1 << i;
-			return put_user(val, p);
-
-                case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].rec)
-					val |= 1 << i;
-			return put_user(val, p);
-
-                case SOUND_MIXER_OUTMASK: /* Arg contains a bit for each supported recording source */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].play)
-					val |= 1 << i;
-			return put_user(val, p);
-
-                 case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].type && mixtable[i].type != MT_4MUTEMONO)
-					val |= 1 << i;
-			return put_user(val, p);
-
-                case SOUND_MIXER_CAPS:
-			return put_user(0, p);
-
-		default:
-			i = _IOC_NR(cmd);
-                        if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].type)
-                                return -EINVAL;
-			if (!volidx[i])
-				return -EINVAL;
-			return put_user(s->mix.vol[volidx[i]-1], p);
-		}
-	}
-        if (_SIOC_DIR(cmd) != (_SIOC_READ|_SIOC_WRITE))
-		return -EINVAL;
-	s->mix.modcnt++;
-	switch (_IOC_NR(cmd)) {
-	case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-		if (get_user(val, p))
-			return -EFAULT;
-		i = hweight32(val);
-		for (j = i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-			if (!(val & (1 << i)))
-				continue;
-			if (!mixtable[i].rec) {
-				val &= ~(1 << i);
-				continue;
-			}
-			j |= mixtable[i].rec;
-		}
-		spin_lock_irqsave(&s->lock, flags);
-		wrmixer(s, DSP_MIX_ADCMIXIDX_L, j);
-		wrmixer(s, DSP_MIX_ADCMIXIDX_R, (j & 1) | (j>>1) | (j & 0x80));
-		spin_unlock_irqrestore(&s->lock, flags);
-		return 0;
-
-	case SOUND_MIXER_OUTSRC: /* Arg contains a bit for each recording source */
-		if (get_user(val, p))
-			return -EFAULT;
-		for (j = i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-			if (!(val & (1 << i)))
-				continue;
-			if (!mixtable[i].play) {
-				val &= ~(1 << i);
-				continue;
-			}
-			j |= mixtable[i].play;
-		}
-		spin_lock_irqsave(&s->lock, flags);
-		wrmixer(s, DSP_MIX_OUTMIXIDX, j);
-		spin_unlock_irqrestore(&s->lock, flags);
-		return 0;
-
-	default:
-		i = _IOC_NR(cmd);
-		if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].type)
-			return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		l = val & 0xff;
-		r = (val >> 8) & 0xff;
-		if (l > 100)
-			l = 100;
-		if (r > 100)
-			r = 100;
-		spin_lock_irqsave(&s->lock, flags);
-		switch (mixtable[i].type) {
-		case MT_4:
-			if (l >= 10)
-				l -= 10;
-			if (r >= 10)
-				r -= 10;
-			frobindir(s, mixtable[i].left, 0xf0, l / 6);
-			frobindir(s, mixtable[i].right, 0xf0, l / 6);
-			break;
-
-		case MT_4MUTEMONO:
-			rl = (l < 4 ? 0 : (l - 5) / 3) & 31;
-			rr = (rl >> 2) & 7;
-			wrmixer(s, mixtable[i].left, rl<<3);
-			if (i == SOUND_MIXER_MIC)
-				maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, rr<<1);
-			break;
-
-		case MT_5MUTEMONO:
-			rl = l < 4 ? 0 : (l - 5) / 3;
- 			wrmixer(s, mixtable[i].left, rl<<3);
-			l = rdmixer(s, DSP_MIX_OUTMIXIDX) & ~mixtable[i].play;
-			r = rl ? mixtable[i].play : 0;
-			wrmixer(s, DSP_MIX_OUTMIXIDX, l | r);
-			/* for recording */
-			if (i == SOUND_MIXER_MIC) {
-				if (s->chip_version >= 37) {
-					rr = rl >> 1;
-					maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, (rr&0x07)<<1);
-					frobindir(s, DSP_MIX_EXTENSION, ~0x01, rr>>3);
-				} else {
-					rr = rl >> 2;
-					maskb(s->iobase + CODEC_CMI_MIXER2, ~0x0e, rr<<1);
-				}
-			}
-			break;
-
-		case MT_5MUTE:
-			rl = l < 4 ? 0 : (l - 5) / 3;
-			rr = r < 4 ? 0 : (r - 5) / 3;
- 			wrmixer(s, mixtable[i].left, rl<<3);
-			wrmixer(s, mixtable[i].right, rr<<3);
-			l = rdmixer(s, DSP_MIX_OUTMIXIDX);
-			l &= ~mixtable[i].play;
-			r = (rl|rr) ? mixtable[i].play : 0;
-			wrmixer(s, DSP_MIX_OUTMIXIDX, l | r);
-			break;
-
-		case MT_6MUTE:
-			if (l < 6)
-				rl = 0x00;
-			else
-				rl = l * 2 / 3;
-			if (r < 6)
-				rr = 0x00;
-			else
-				rr = r * 2 / 3;
-			wrmixer(s, mixtable[i].left, rl);
-			wrmixer(s, mixtable[i].right, rr);
-			break;
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		if (!volidx[i])
-			return -EINVAL;
-		s->mix.vol[volidx[i]-1] = val;
-		return put_user(s->mix.vol[volidx[i]-1], p);
-	}
-}
-
-/* --------------------------------------------------------------------- */
-
-static int cm_open_mixdev(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	struct list_head *list;
-	struct cm_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct cm_state, devs);
-		if (s->dev_mixer == minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	return nonseekable_open(inode, file);
-}
-
-static int cm_release_mixdev(struct inode *inode, struct file *file)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	return 0;
-}
-
-static int cm_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	return mixer_ioctl((struct cm_state *)file->private_data, cmd, arg);
-}
-
-static /*const*/ struct file_operations cm_mixer_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek	 = no_llseek,
-	.ioctl	 = cm_ioctl_mixdev,
-	.open	 = cm_open_mixdev,
-	.release = cm_release_mixdev,
-};
-
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct cm_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count, tmo;
-
-	if (s->dma_dac.mapped || !s->dma_dac.ready)
-		return 0;
-        add_wait_queue(&s->dma_dac.wait, &wait);
-        for (;;) {
-        	__set_current_state(TASK_INTERRUPTIBLE);
-                spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-                spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-                        break;
-                if (nonblock) {
-                        remove_wait_queue(&s->dma_dac.wait, &wait);
-                        set_current_state(TASK_RUNNING);
-                        return -EBUSY;
-                }
-		tmo = 3 * HZ * (count + s->dma_dac.fragsize) / 2 / s->ratedac;
-		tmo >>= sample_shift[(s->fmt >> CM_CFMT_DACSHIFT) & CM_CFMT_MASK];
-		if (!schedule_timeout(tmo + 1))
-			DBG(printk(KERN_DEBUG "cmpci: dma timed out??\n");)
-        }
-        remove_wait_queue(&s->dma_dac.wait, &wait);
-        set_current_state(TASK_RUNNING);
-        if (signal_pending(current))
-                return -ERESTARTSYS;
-        return 0;
-}
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t cm_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_adc.mapped)
-		return -ENXIO;
-	if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-		return ret;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-
-        add_wait_queue(&s->dma_adc.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		swptr = s->dma_adc.swptr;
-		cnt = s->dma_adc.dmasize-swptr;
-		if (s->dma_adc.count < cnt)
-			cnt = s->dma_adc.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_adc.enabled)
-				start_adc(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				goto out;
-			}
-			if (!schedule_timeout(HZ)) {
-				printk(KERN_DEBUG "cmpci: read: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       s->dma_adc.dmasize, s->dma_adc.fragsize, s->dma_adc.count,
-				       s->dma_adc.hwptr, s->dma_adc.swptr);
-				spin_lock_irqsave(&s->lock, flags);
-				stop_adc_unlocked(s);
-				set_dmaadc(s, s->dma_adc.dmaaddr, s->dma_adc.dmasamples);
-				/* program sample counts */
-				set_countadc(s, s->dma_adc.fragsamples);
-				s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				goto out;
-			}
-			continue;
-		}
-		if (s->status & DO_BIGENDIAN_R) {
-			int	i, err;
-			unsigned char *src;
-			char __user *dst = buffer;
-			unsigned char data[2];
-
-			src = (unsigned char *) (s->dma_adc.rawbuf + swptr);
-			// copy left/right sample at one time
-			for (i = 0; i < cnt / 2; i++) {
-				data[0] = src[1];
-				data[1] = src[0];
-				if ((err = __put_user(data[0], dst++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __put_user(data[1], dst++))) {
-					ret = err;
-					goto out;
-				}
-				src += 2;
-			}
-		} else if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			goto out;
-		}
-		swptr = (swptr + cnt) % s->dma_adc.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_adc.swptr = swptr;
-		s->dma_adc.count -= cnt;
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_adc.enabled)
-			start_adc_unlocked(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-	}
-out:
-        remove_wait_queue(&s->dma_adc.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-static ssize_t cm_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_dac.mapped)
-		return -ENXIO;
-	if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-		return ret;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	if (s->status & DO_DUAL_DAC) {
-		if (s->dma_adc.mapped)
-			return -ENXIO;
-		if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-			return ret;
-	}
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-
-        add_wait_queue(&s->dma_dac.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		if (s->dma_dac.count < 0) {
-			s->dma_dac.count = 0;
-			s->dma_dac.swptr = s->dma_dac.hwptr;
-		}
-		if (s->status & DO_DUAL_DAC) {
-			s->dma_adc.swptr = s->dma_dac.swptr;
-			s->dma_adc.count = s->dma_dac.count;
-			s->dma_adc.endcleared = s->dma_dac.endcleared;
-		}
-		swptr = s->dma_dac.swptr;
-		cnt = s->dma_dac.dmasize-swptr;
-		if (s->status & DO_AC3_SW) {
-			if (s->dma_dac.count + 2 * cnt > s->dma_dac.dmasize)
-				cnt = (s->dma_dac.dmasize - s->dma_dac.count) / 2;
-		} else {
-			if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
-				cnt = s->dma_dac.dmasize - s->dma_dac.count;
-		}
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if ((s->status & DO_DUAL_DAC) && (cnt > count / 2))
-		    cnt = count / 2;
-		if (cnt <= 0) {
-			if (s->dma_dac.enabled)
-				start_dac(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				goto out;
-			}
-			if (!schedule_timeout(HZ)) {
-				printk(KERN_DEBUG "cmpci: write: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       s->dma_dac.dmasize, s->dma_dac.fragsize, s->dma_dac.count,
-				       s->dma_dac.hwptr, s->dma_dac.swptr);
-				spin_lock_irqsave(&s->lock, flags);
-				stop_dac_unlocked(s);
-				set_dmadac(s, s->dma_dac.dmaaddr, s->dma_dac.dmasamples);
-				/* program sample counts */
-				set_countdac(s, s->dma_dac.fragsamples);
-				s->dma_dac.count = s->dma_dac.hwptr = s->dma_dac.swptr = 0;
-				if (s->status & DO_DUAL_DAC)  {
-					set_dmadac1(s, s->dma_adc.dmaaddr, s->dma_adc.dmasamples);
-					s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
-				}
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				goto out;
-			}
-			continue;
-		}
-		if (s->status & DO_AC3_SW) {
-			int err;
-
-			// clip exceeded data, caught by 033 and 037
-			if (swptr + 2 * cnt > s->dma_dac.dmasize)
-				cnt = (s->dma_dac.dmasize - swptr) / 2;
-			if ((err = trans_ac3(s, s->dma_dac.rawbuf + swptr, buffer, cnt))) {
-				ret = err;
-				goto out;
-			}
-			swptr = (swptr + 2 * cnt) % s->dma_dac.dmasize;
-		} else if ((s->status & DO_DUAL_DAC) && (s->status & DO_BIGENDIAN_W)) {
-			int	i, err;
-			const char __user *src = buffer;
-			unsigned char *dst0, *dst1;
-			unsigned char data[8];
-
-			dst0 = (unsigned char *) (s->dma_dac.rawbuf + swptr);
-			dst1 = (unsigned char *) (s->dma_adc.rawbuf + swptr);
-			// copy left/right sample at one time
-			for (i = 0; i < cnt / 4; i++) {
-				if ((err = __get_user(data[0], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[1], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[2], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[3], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[4], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[5], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[6], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[7], src++))) {
-					ret = err;
-					goto out;
-				}
-				dst0[0] = data[1];
-				dst0[1] = data[0];
-				dst0[2] = data[3];
-				dst0[3] = data[2];
-				dst1[0] = data[5];
-				dst1[1] = data[4];
-				dst1[2] = data[7];
-				dst1[3] = data[6];
-				dst0 += 4;
-				dst1 += 4;
-			}
-			swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		} else if (s->status & DO_DUAL_DAC) {
-			int	i, err;
-			unsigned long __user *src = (unsigned long __user *) buffer;
-			unsigned long *dst0, *dst1;
-
-			dst0 = (unsigned long *) (s->dma_dac.rawbuf + swptr);
-			dst1 = (unsigned long *) (s->dma_adc.rawbuf + swptr);
-			// copy left/right sample at one time
-			for (i = 0; i < cnt / 4; i++) {
-				if ((err = __get_user(*dst0++, src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(*dst1++, src++))) {
-					ret = err;
-					goto out;
-				}
-			}
-			swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		} else if (s->status & DO_BIGENDIAN_W) {
-			int	i, err;
-			const char __user *src = buffer;
-			unsigned char *dst;
-			unsigned char data[2];
-
-			dst = (unsigned char *) (s->dma_dac.rawbuf + swptr);
-			// swap hi/lo bytes for each sample
-			for (i = 0; i < cnt / 2; i++) {
-				if ((err = __get_user(data[0], src++))) {
-					ret = err;
-					goto out;
-				}
-				if ((err = __get_user(data[1], src++))) {
-					ret = err;
-					goto out;
-				}
-				dst[0] = data[1];
-				dst[1] = data[0];
-				dst += 2;
-			}
-			swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		} else {
-			if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt)) {
-				if (!ret)
-					ret = -EFAULT;
-				goto out;
-			}
-			swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		}
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac.swptr = swptr;
-		s->dma_dac.count += cnt;
-		if (s->status & DO_AC3_SW)
-			s->dma_dac.count += cnt;
-		s->dma_dac.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->status & DO_DUAL_DAC) {
-			count -= cnt;
-			buffer += cnt;
-			ret += cnt;
-		}
-		if (s->dma_dac.enabled)
-			start_dac(s);
-	}
-out:
-        remove_wait_queue(&s->dma_dac.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-static unsigned int cm_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac.ready && prog_dmabuf(s, 0))
-			return 0;
-		poll_wait(file, &s->dma_dac.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!s->dma_adc.ready && prog_dmabuf(s, 1))
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	cm_update_ptr(s);
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed)s->dma_dac.dmasize >= s->dma_dac.count + (signed)s->dma_dac.fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int cm_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-	struct dmabuf *db;
-	int ret = -EINVAL;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf(s, 0)) != 0)
-			goto out;
-		db = &s->dma_dac;
-	} else if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf(s, 1)) != 0)
-			goto out;
-		db = &s->dma_adc;
-	} else
-		goto out;
-	ret = -EINVAL;
-	if (vma->vm_pgoff != 0)
-		goto out;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder))
-		goto out;
-	ret = -EINVAL;
-	if (remap_pfn_range(vma, vma->vm_start,
-				virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-				size, vma->vm_page_prot))
-		goto out;
-	db->mapped = 1;
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-#define SNDCTL_SPDIF_COPYRIGHT	_SIOW('S',  0, int)       // set/reset S/PDIF copy protection
-#define SNDCTL_SPDIF_LOOP	_SIOW('S',  1, int)       // set/reset S/PDIF loop
-#define SNDCTL_SPDIF_MONITOR	_SIOW('S',  2, int)       // set S/PDIF monitor
-#define SNDCTL_SPDIF_LEVEL	_SIOW('S',  3, int)       // set/reset S/PDIF out level
-#define SNDCTL_SPDIF_INV	_SIOW('S',  4, int)       // set/reset S/PDIF in inverse
-#define SNDCTL_SPDIF_SEL2	_SIOW('S',  5, int)       // set S/PDIF in #2
-#define SNDCTL_SPDIF_VALID	_SIOW('S',  6, int)       // set S/PDIF valid
-#define SNDCTL_SPDIFOUT		_SIOW('S',  7, int)       // set S/PDIF out
-#define SNDCTL_SPDIFIN		_SIOW('S',  8, int)       // set S/PDIF out
-
-static int cm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int val, mapped, ret;
-	unsigned char fmtm, fmtd;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_STATE(s);
-        mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s, 0/*file->f_flags & O_NONBLOCK*/);
-		return 0;
-
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP | DSP_CAP_BIND, p);
-
-        case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq(s->irq);
-			s->dma_dac.swptr = s->dma_dac.hwptr = s->dma_dac.count = s->dma_dac.total_bytes = 0;
-			if (s->status & DO_DUAL_DAC)
-				s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->irq);
-			s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			if (file->f_mode & FMODE_READ) {
-			 	spin_lock_irqsave(&s->lock, flags);
-				stop_adc_unlocked(s);
-				s->dma_adc.ready = 0;
-				set_adc_rate_unlocked(s, val);
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (s->status & DO_DUAL_DAC)
-					s->dma_adc.ready = 0;
-				set_dac_rate(s, val);
-			}
-		}
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-
-        case SNDCTL_DSP_STEREO:
-		if (get_user(val, p))
-			return -EFAULT;
-		fmtd = 0;
-		fmtm = ~0;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ready = 0;
-			if (val)
-				fmtd |= CM_CFMT_STEREO << CM_CFMT_ADCSHIFT;
-			else
-				fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_ADCSHIFT);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.ready = 0;
-			if (val)
-				fmtd |= CM_CFMT_STEREO << CM_CFMT_DACSHIFT;
-			else
-				fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_DACSHIFT);
-			if (s->status & DO_DUAL_DAC) {
-				s->dma_adc.ready = 0;
-				if (val)
-					fmtd |= CM_CFMT_STEREO << CM_CFMT_ADCSHIFT;
-				else
-					fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_ADCSHIFT);
-			}
-		}
-		set_fmt(s, fmtm, fmtd);
-		return 0;
-
-        case SNDCTL_DSP_CHANNELS:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != 0) {
-			fmtd = 0;
-			fmtm = ~0;
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val >= 2)
-					fmtd |= CM_CFMT_STEREO << CM_CFMT_ADCSHIFT;
-				else
-					fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_ADCSHIFT);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val >= 2)
-					fmtd |= CM_CFMT_STEREO << CM_CFMT_DACSHIFT;
-				else
-					fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_DACSHIFT);
-				if (s->status & DO_DUAL_DAC) {
-					s->dma_adc.ready = 0;
-					if (val >= 2)
-						fmtd |= CM_CFMT_STEREO << CM_CFMT_ADCSHIFT;
-					else
-						fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_ADCSHIFT);
-				}
-			}
-			set_fmt(s, fmtm, fmtd);
-			if ((s->capability & CAN_MULTI_CH)
-			     && (file->f_mode & FMODE_WRITE)) {
-				val = set_dac_channels(s, val);
-				return put_user(val, p);
-			}
-		}
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (CM_CFMT_STEREO << CM_CFMT_ADCSHIFT)
-					   : (CM_CFMT_STEREO << CM_CFMT_DACSHIFT))) ? 2 : 1, p);
-
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(AFMT_S16_BE|AFMT_S16_LE|AFMT_U8|
-			((s->capability & CAN_AC3) ? AFMT_AC3 : 0), p);
-
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			fmtd = 0;
-			fmtm = ~0;
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val == AFMT_S16_BE || val == AFMT_S16_LE)
-					fmtd |= CM_CFMT_16BIT << CM_CFMT_ADCSHIFT;
-				else
-					fmtm &= ~(CM_CFMT_16BIT << CM_CFMT_ADCSHIFT);
-				if (val == AFMT_S16_BE)
-					s->status |= DO_BIGENDIAN_R;
-				else
-					s->status &= ~DO_BIGENDIAN_R;
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val == AFMT_S16_BE || val == AFMT_S16_LE || val == AFMT_AC3)
-					fmtd |= CM_CFMT_16BIT << CM_CFMT_DACSHIFT;
-				else
-					fmtm &= ~(CM_CFMT_16BIT << CM_CFMT_DACSHIFT);
-				if (val == AFMT_AC3) {
-					fmtd |= CM_CFMT_STEREO << CM_CFMT_DACSHIFT;
-					set_ac3(s, 48000);
-				} else
-					set_ac3(s, 0);
-				if (s->status & DO_DUAL_DAC) {
-					s->dma_adc.ready = 0;
-					if (val == AFMT_S16_BE || val == AFMT_S16_LE)
-						fmtd |= CM_CFMT_STEREO << CM_CFMT_ADCSHIFT;
-					else
-						fmtm &= ~(CM_CFMT_STEREO << CM_CFMT_ADCSHIFT);
-				}
-				if (val == AFMT_S16_BE)
-					s->status |= DO_BIGENDIAN_W;
-				else
-					s->status &= ~DO_BIGENDIAN_W;
-			}
-			set_fmt(s, fmtm, fmtd);
-		}
-		if (s->status & DO_AC3) return put_user(AFMT_AC3, p);
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (CM_CFMT_16BIT << CM_CFMT_ADCSHIFT)
-					   : (CM_CFMT_16BIT << CM_CFMT_DACSHIFT))) ? val : AFMT_U8, p);
-
-	case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if (s->status & DO_DUAL_DAC) {
-			if (file->f_mode & FMODE_WRITE &&
-			 (s->enable & ENDAC) &&
-			 (s->enable & ENADC))
-				val |= PCM_ENABLE_OUTPUT;
-			return put_user(val, p);
-		}
-		if (file->f_mode & FMODE_READ && s->enable & ENADC)
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && s->enable & ENDAC)
-			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, p);
-
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-					return ret;
-				s->dma_adc.enabled = 1;
-				start_adc(s);
-			} else {
-				s->dma_adc.enabled = 0;
-				stop_adc(s);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-					return ret;
-				if (s->status & DO_DUAL_DAC) {
-					if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-						return ret;
-				}
-				s->dma_dac.enabled = 1;
-				start_dac(s);
-			} else {
-				s->dma_dac.enabled = 0;
-				stop_dac(s);
-			}
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!(s->enable & ENDAC) && (val = prog_dmabuf(s, 0)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		cm_update_ptr(s);
-		abinfo.fragsize = s->dma_dac.fragsize;
-                abinfo.bytes = s->dma_dac.dmasize - s->dma_dac.count;
-                abinfo.fragstotal = s->dma_dac.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!(s->enable & ENADC) && (val = prog_dmabuf(s, 1)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		cm_update_ptr(s);
-		abinfo.fragsize = s->dma_adc.fragsize;
-                abinfo.bytes = s->dma_adc.count;
-                abinfo.fragstotal = s->dma_adc.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cm_update_ptr(s);
-                val = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return put_user(val, p);
-
-        case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cm_update_ptr(s);
-                cinfo.bytes = s->dma_adc.total_bytes;
-                cinfo.blocks = s->dma_adc.count >> s->dma_adc.fragshift;
-                cinfo.ptr = s->dma_adc.hwptr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-                return copy_to_user(argp, &cinfo, sizeof(cinfo))  ? -EFAULT : 0;
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		spin_lock_irqsave(&s->lock, flags);
-		cm_update_ptr(s);
-                cinfo.bytes = s->dma_dac.total_bytes;
-                cinfo.blocks = s->dma_dac.count >> s->dma_dac.fragshift;
-                cinfo.ptr = s->dma_dac.hwptr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= s->dma_dac.fragsize-1;
-		if (s->status & DO_DUAL_DAC) {
-			if (s->dma_adc.mapped)
-				s->dma_adc.count &= s->dma_adc.fragsize-1;
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-                return copy_to_user(argp, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
-
-        case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf(s, 0)))
-				return val;
-			if (s->status & DO_DUAL_DAC) {
-				if ((val = prog_dmabuf(s, 1)))
-					return val;
-				return put_user(2 * s->dma_dac.fragsize, p);
-			}
-			return put_user(s->dma_dac.fragsize, p);
-		}
-		if ((val = prog_dmabuf(s, 1)))
-			return val;
-		return put_user(s->dma_adc.fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			s->dma_dac.ossfragshift = val & 0xffff;
-			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac.ossfragshift < 4)
-				s->dma_dac.ossfragshift = 4;
-			if (s->dma_dac.ossfragshift > 15)
-				s->dma_dac.ossfragshift = 15;
-			if (s->dma_dac.ossmaxfrags < 4)
-				s->dma_dac.ossmaxfrags = 4;
-			if (s->status & DO_DUAL_DAC) {
-				s->dma_adc.ossfragshift = s->dma_dac.ossfragshift;
-				s->dma_adc.ossmaxfrags = s->dma_dac.ossmaxfrags;
-			}
-		}
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-			return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		if (file->f_mode & FMODE_WRITE) {
-			s->dma_dac.subdivision = val;
-			if (s->status & DO_DUAL_DAC)
-				s->dma_adc.subdivision = val;
-		}
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (CM_CFMT_STEREO << CM_CFMT_ADCSHIFT) : (CM_CFMT_STEREO << CM_CFMT_DACSHIFT))) ? 2 : 1, p);
-
-        case SOUND_PCM_READ_BITS:
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (CM_CFMT_16BIT << CM_CFMT_ADCSHIFT) : (CM_CFMT_16BIT << CM_CFMT_DACSHIFT))) ? 16 : 8, p);
-
-        case SOUND_PCM_READ_FILTER:
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-
-	case SNDCTL_DSP_GETCHANNELMASK:
-		return put_user(DSP_BIND_FRONT|DSP_BIND_SURR|DSP_BIND_CENTER_LFE|DSP_BIND_SPDIF, p);
-
-	case SNDCTL_DSP_BIND_CHANNEL:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val == DSP_BIND_QUERY) {
-			val = DSP_BIND_FRONT;
-			if (s->status & DO_SPDIF_OUT)
-				val |= DSP_BIND_SPDIF;
-			else {
-				if (s->curr_channels == 4)
-					val |= DSP_BIND_SURR;
-				if (s->curr_channels > 4)
-					val |= DSP_BIND_CENTER_LFE;
-			}
-		} else {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val & DSP_BIND_SPDIF) {
-					set_spdifin(s, s->rateadc);
-					if (!(s->status & DO_SPDIF_OUT))
-						val &= ~DSP_BIND_SPDIF;
-				}
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val & DSP_BIND_SPDIF) {
-					set_spdifout(s, s->ratedac);
-					set_dac_channels(s, s->fmt & (CM_CFMT_STEREO << CM_CFMT_DACSHIFT) ? 2 : 1);
-					if (!(s->status & DO_SPDIF_OUT))
-						val &= ~DSP_BIND_SPDIF;
-				} else {
-					int channels;
-					int mask;
-
-					mask = val & (DSP_BIND_FRONT|DSP_BIND_SURR|DSP_BIND_CENTER_LFE);
-					switch (mask) {
-					    case DSP_BIND_FRONT:
-						channels = 2;
-						break;
-					    case DSP_BIND_FRONT|DSP_BIND_SURR:
-						channels = 4;
-						break;
-					    case DSP_BIND_FRONT|DSP_BIND_SURR|DSP_BIND_CENTER_LFE:
-						channels = 6;
-						break;
-					    default:
-						channels = s->fmt & (CM_CFMT_STEREO << CM_CFMT_DACSHIFT) ? 2 : 1;
-						break;
-					}
-					set_dac_channels(s, channels);
-				}
-			}
-		}
-		return put_user(val, p);
-
-	case SOUND_PCM_WRITE_FILTER:
-	case SNDCTL_DSP_MAPINBUF:
-	case SNDCTL_DSP_MAPOUTBUF:
-        case SNDCTL_DSP_SETSYNCRO:
-                return -EINVAL;
-	case SNDCTL_SPDIF_COPYRIGHT:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdif_copyright(s, val);
-                return 0;
-	case SNDCTL_SPDIF_LOOP:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdif_loop(s, val);
-                return 0;
-	case SNDCTL_SPDIF_MONITOR:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdif_monitor(s, val);
-                return 0;
-	case SNDCTL_SPDIF_LEVEL:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdifout_level(s, val);
-                return 0;
-	case SNDCTL_SPDIF_INV:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdifin_inverse(s, val);
-                return 0;
-	case SNDCTL_SPDIF_SEL2:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdifin_channel2(s, val);
-                return 0;
-	case SNDCTL_SPDIF_VALID:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdifin_valid(s, val);
-                return 0;
-	case SNDCTL_SPDIFOUT:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdifout(s, val ? s->ratedac : 0);
-                return 0;
-	case SNDCTL_SPDIFIN:
-		if (get_user(val, p))
-			return -EFAULT;
-		set_spdifin(s, val ? s->rateadc : 0);
-                return 0;
-	}
-	return mixer_ioctl(s, cmd, arg);
-}
-
-static int cm_open(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned char fmtm = ~0, fmts = 0;
-	struct list_head *list;
-	struct cm_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct cm_state, devs);
-		if (!((s->dev_audio ^ minor) & ~0xf))
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & file->f_mode) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	if (file->f_mode & FMODE_READ) {
-		s->status &= ~DO_BIGENDIAN_R;
-		fmtm &= ~((CM_CFMT_STEREO | CM_CFMT_16BIT) << CM_CFMT_ADCSHIFT);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			fmts |= CM_CFMT_16BIT << CM_CFMT_ADCSHIFT;
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
-		s->dma_adc.enabled = 1;
-		set_adc_rate(s, 8000);
-		// spdif-in is turnned off by default
-		set_spdifin(s, 0);
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->status &= ~DO_BIGENDIAN_W;
-		fmtm &= ~((CM_CFMT_STEREO | CM_CFMT_16BIT) << CM_CFMT_DACSHIFT);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			fmts |= CM_CFMT_16BIT << CM_CFMT_DACSHIFT;
-		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags = s->dma_dac.subdivision = 0;
-		s->dma_dac.enabled = 1;
-		set_dac_rate(s, 8000);
-		// clear previous multichannel, spdif, ac3 state
-		set_spdifout(s, 0);
-		set_ac3(s, 0);
-		set_dac_channels(s, 1);
-	}
-	set_fmt(s, fmtm, fmts);
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int cm_release(struct inode *inode, struct file *file)
-{
-	struct cm_state *s = (struct cm_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE)
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac(s);
-
-		dealloc_dmabuf(s, &s->dma_dac);
-		if (s->status & DO_DUAL_DAC)
-			dealloc_dmabuf(s, &s->dma_adc);
-
-		if (s->status & DO_MULTI_CH)
-			set_dac_channels(s, 1);
-		if (s->status & DO_AC3)
-			set_ac3(s, 0);
-		if (s->status & DO_SPDIF_OUT)
-			set_spdifout(s, 0);
-		/* enable SPDIF loop */
-		set_spdif_loop(s, spdif_loop);
-		s->status &= ~DO_BIGENDIAN_W;
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-		dealloc_dmabuf(s, &s->dma_adc);
-		s->status &= ~DO_BIGENDIAN_R;
-	}
-	s->open_mode &= ~(file->f_mode & (FMODE_READ|FMODE_WRITE));
-	mutex_unlock(&s->open_mutex);
-	wake_up(&s->open_wait);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations cm_audio_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek	 = no_llseek,
-	.read	 = cm_read,
-	.write	 = cm_write,
-	.poll	 = cm_poll,
-	.ioctl	 = cm_ioctl,
-	.mmap	 = cm_mmap,
-	.open	 = cm_open,
-	.release = cm_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-static struct initvol {
-	int mixch;
-	int vol;
-} initvol[] __devinitdata = {
-	{ SOUND_MIXER_WRITE_CD, 0x4f4f },
-	{ SOUND_MIXER_WRITE_LINE, 0x4f4f },
-	{ SOUND_MIXER_WRITE_MIC, 0x4f4f },
-	{ SOUND_MIXER_WRITE_SYNTH, 0x4f4f },
-	{ SOUND_MIXER_WRITE_VOLUME, 0x4f4f },
-	{ SOUND_MIXER_WRITE_PCM, 0x4f4f }
-};
-
-/* check chip version and capability */
-static int query_chip(struct cm_state *s)
-{
-	int ChipVersion = -1;
-	unsigned char RegValue;
-
-	// check reg 0Ch, bit 24-31
-	RegValue = inb(s->iobase + CODEC_CMI_INT_HLDCLR + 3);
-	if (RegValue == 0) {
-	    // check reg 08h, bit 24-28
-	    RegValue = inb(s->iobase + CODEC_CMI_CHFORMAT + 3);
-	    RegValue &= 0x1f;
-	    if (RegValue == 0) {
-		ChipVersion = 33;
-		s->max_channels = 4;
-		s->capability |= CAN_AC3_SW;
-		s->capability |= CAN_DUAL_DAC;
-	    } else {
-		ChipVersion = 37;
-		s->max_channels = 4;
-		s->capability |= CAN_AC3_HW;
-		s->capability |= CAN_DUAL_DAC;
-	    }
-	} else {
-	    // check reg 0Ch, bit 26
-	    if (RegValue & (1 << (26-24))) {
-		ChipVersion = 39;
-	    	if (RegValue & (1 << (24-24)))
-		    s->max_channels = 6;
-	    	else
-		    s->max_channels = 4;
-		s->capability |= CAN_AC3_HW;
-		s->capability |= CAN_DUAL_DAC;
-		s->capability |= CAN_MULTI_CH_HW;
-		s->capability |= CAN_LINE_AS_BASS;
-		s->capability |= CAN_MIC_AS_BASS;
-	    } else {
-		ChipVersion = 55; // 4 or 6 channels
-		s->max_channels = 6;
-		s->capability |= CAN_AC3_HW;
-		s->capability |= CAN_DUAL_DAC;
-		s->capability |= CAN_MULTI_CH_HW;
-		s->capability |= CAN_LINE_AS_BASS;
-		s->capability |= CAN_MIC_AS_BASS;
-	    }
-	}
-	s->capability |= CAN_LINE_AS_REAR;
-	return ChipVersion;
-}
-
-#ifdef CONFIG_SOUND_CMPCI_JOYSTICK
-static int __devinit cm_create_gameport(struct cm_state *s, int io_port)
-{
-	struct gameport *gp;
-
-	if (!request_region(io_port, CM_EXTENT_GAME, "cmpci GAME")) {
-		printk(KERN_ERR "cmpci: gameport io ports 0x%#x in use\n", io_port);
-		return -EBUSY;
-	}
-
-	if (!(s->gameport = gp = gameport_allocate_port())) {
-		printk(KERN_ERR "cmpci: can not allocate memory for gameport\n");
-		release_region(io_port, CM_EXTENT_GAME);
-		return -ENOMEM;
-	}
-
-	gameport_set_name(gp, "C-Media GP");
-	gameport_set_phys(gp, "pci%s/gameport0", pci_name(s->dev));
-	gp->dev.parent = &s->dev->dev;
-	gp->io = io_port;
-
-	/* enable joystick */
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x02);
-
-	gameport_register_port(gp);
-
-	return 0;
-}
-
-static void __devexit cm_free_gameport(struct cm_state *s)
-{
-	if (s->gameport) {
-		int gpio = s->gameport->io;
-
-		gameport_unregister_port(s->gameport);
-		s->gameport = NULL;
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x02, 0);
-		release_region(gpio, CM_EXTENT_GAME);
-	}
-}
-#else
-static inline int cm_create_gameport(struct cm_state *s, int io_port) { return -ENOSYS; }
-static inline void cm_free_gameport(struct cm_state *s) { }
-#endif
-
-#define	echo_option(x)\
-if (x) strcat(options, "" #x " ")
-
-static int __devinit cm_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
-{
-	struct cm_state *s;
-	mm_segment_t fs;
-	int i, val, ret;
-	unsigned char reg_mask;
-	int timeout;
-	struct resource *ports;
-	struct {
-		unsigned short	deviceid;
-		char		*devicename;
-	} devicetable[] = {
-		{ PCI_DEVICE_ID_CMEDIA_CM8338A, "CM8338A" },
-		{ PCI_DEVICE_ID_CMEDIA_CM8338B, "CM8338B" },
-		{ PCI_DEVICE_ID_CMEDIA_CM8738,  "CM8738" },
-		{ PCI_DEVICE_ID_CMEDIA_CM8738B, "CM8738B" },
-	};
-	char	*devicename = "unknown";
-	char	options[256];
-
-	if ((ret = pci_enable_device(pcidev)))
-		return ret;
-	if (!(pci_resource_flags(pcidev, 0) & IORESOURCE_IO))
-		return -ENODEV;
-	if (pcidev->irq == 0)
-		return -ENODEV;
-	i = pci_set_dma_mask(pcidev, DMA_32BIT_MASK);
-	if (i) {
-		printk(KERN_WARNING "cmpci: architecture does not support 32bit PCI busmaster DMA\n");
-		return i;
-	}
-	s = kmalloc(sizeof(*s), GFP_KERNEL);
-	if (!s) {
-		printk(KERN_WARNING "cmpci: out of memory\n");
-		return -ENOMEM;
-	}
-	/* search device name */
-	for (i = 0; i < sizeof(devicetable) / sizeof(devicetable[0]); i++) {
-		if (devicetable[i].deviceid == pcidev->device) {
-			devicename = devicetable[i].devicename;
-			break;
-		}
-	}
-	memset(s, 0, sizeof(struct cm_state));
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac.wait);
-	init_waitqueue_head(&s->open_wait);
-	mutex_init(&s->open_mutex);
-	spin_lock_init(&s->lock);
-	s->magic = CM_MAGIC;
-	s->dev = pcidev;
-	s->iobase = pci_resource_start(pcidev, 0);
-	s->iosynth = fmio;
-	s->iomidi = mpuio;
-#ifdef CONFIG_SOUND_CMPCI_MIDI
-	s->midi_devc = 0;
-#endif
-	s->status = 0;
-	if (s->iobase == 0)
-		return -ENODEV;
-	s->irq = pcidev->irq;
-
-	if (!request_region(s->iobase, CM_EXTENT_CODEC, "cmpci")) {
-		printk(KERN_ERR "cmpci: io ports %#x-%#x in use\n", s->iobase, s->iobase+CM_EXTENT_CODEC-1);
-		ret = -EBUSY;
-		goto err_region5;
-	}
-	/* dump parameters */
-	strcpy(options, "cmpci: ");
-	echo_option(joystick);
-	echo_option(spdif_inverse);
-	echo_option(spdif_loop);
-	echo_option(spdif_out);
-	echo_option(use_line_as_rear);
-	echo_option(use_line_as_bass);
-	echo_option(use_mic_as_bass);
-	echo_option(mic_boost);
-	echo_option(hw_copy);
-	printk(KERN_INFO "%s\n", options);
-
-	/* initialize codec registers */
-	outb(0, s->iobase + CODEC_CMI_INT_HLDCLR + 2);  /* disable ints */
-	outb(0, s->iobase + CODEC_CMI_FUNCTRL0 + 2); /* disable channels */
-	/* reset mixer */
-	wrmixer(s, DSP_MIX_DATARESETIDX, 0);
-
-	/* request irq */
-	if ((ret = request_irq(s->irq, cm_interrupt, IRQF_SHARED, "cmpci", s))) {
-		printk(KERN_ERR "cmpci: irq %u in use\n", s->irq);
-		goto err_irq;
-	}
-	printk(KERN_INFO "cmpci: found %s adapter at io %#x irq %u\n",
-	       devicename, s->iobase, s->irq);
-	/* register devices */
-	if ((s->dev_audio = register_sound_dsp(&cm_audio_fops, -1)) < 0) {
-		ret = s->dev_audio;
-		goto err_dev1;
-	}
-	if ((s->dev_mixer = register_sound_mixer(&cm_mixer_fops, -1)) < 0) {
-		ret = s->dev_mixer;
-		goto err_dev2;
-	}
-	pci_set_master(pcidev);	/* enable bus mastering */
-	/* initialize the chips */
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	/* set mixer output */
-	frobindir(s, DSP_MIX_OUTMIXIDX, 0x1f, 0x1f);
-	/* set mixer input */
-	val = SOUND_MASK_LINE|SOUND_MASK_SYNTH|SOUND_MASK_CD|SOUND_MASK_MIC;
-	mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
-	for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
-		val = initvol[i].vol;
-		mixer_ioctl(s, initvol[i].mixch, (unsigned long)&val);
-	}
-	set_fs(fs);
-	/* use channel 1 for playback, channel 0 for record */
-	maskb(s->iobase + CODEC_CMI_FUNCTRL0, ~CHADC1, CHADC0);
-	/* turn off VMIC3 - mic boost */
-	if (mic_boost)
-		maskb(s->iobase + CODEC_CMI_MIXER2, ~1, 0);
-	else
-		maskb(s->iobase + CODEC_CMI_MIXER2, ~0, 1);
-	s->deviceid = pcidev->device;
-
-	if (pcidev->device == PCI_DEVICE_ID_CMEDIA_CM8738
-	 || pcidev->device == PCI_DEVICE_ID_CMEDIA_CM8738B) {
-
-		/* chip version and hw capability check */
-		s->chip_version = query_chip(s);
-		printk(KERN_INFO "cmpci: chip version = 0%d\n", s->chip_version);
-
-		/* set SPDIF-in inverse before enable SPDIF loop */
-		set_spdifin_inverse(s, spdif_inverse);
-
-		/* use SPDIF in #1 */
-		set_spdifin_channel2(s, 0);
-	} else {
-		s->chip_version = 0;
-		/* 8338 will fall here */
-		s->max_channels = 4;
-		s->capability |= CAN_DUAL_DAC;
-		s->capability |= CAN_LINE_AS_REAR;
-	}
-	/* enable SPDIF loop */
-	set_spdif_loop(s, spdif_loop);
-
-	// enable 4 speaker mode (analog duplicate)
-	set_hw_copy(s, hw_copy);
-
-	reg_mask = 0;
-#ifdef CONFIG_SOUND_CMPCI_FM
-	/* disable FM */
-	maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~8, 0);
-	if (s->iosynth) {
-	    /* don't enable OPL3 if there is one */
-	    if (opl3_detect(s->iosynth, NULL)) {
-	    	s->iosynth = 0;
-	    } else {
-		/* set IO based at 0x388 */
-		switch (s->iosynth) {
-		    case 0x388:
-			reg_mask = 0;
-			break;
-		    case 0x3C8:
-			reg_mask = 0x01;
-			break;
-		    case 0x3E0:
-			reg_mask = 0x02;
-			break;
-		    case 0x3E8:
-			reg_mask = 0x03;
-			break;
-		    default:
-			s->iosynth = 0;
-			break;
-		}
-		maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0x03, reg_mask);
-		/* enable FM */
-		if (s->iosynth) {
-			maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~0, 8);
-			if (opl3_detect(s->iosynth, NULL))
-				ret = opl3_init(s->iosynth, NULL, THIS_MODULE);
-			else {
-				maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~8, 0);
-				s->iosynth = 0;
-			}
-		}
-	    }
-	}
-#endif
-#ifdef CONFIG_SOUND_CMPCI_MIDI
-	switch (s->iomidi) {
-	    case 0x330:
-		reg_mask = 0;
-		break;
-	    case 0x320:
-		reg_mask = 0x20;
-		break;
-	    case 0x310:
-		reg_mask = 0x40;
-		break;
-	    case 0x300:
-		reg_mask = 0x60;
-		break;
-	    default:
-		s->iomidi = 0;
-		goto skip_mpu;
-	}
-	ports = request_region(s->iomidi, 2, "mpu401");
-	if (!ports)
-		goto skip_mpu;
-	/* disable MPU-401 */
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x04, 0);
-	s->mpu_data.name = "cmpci mpu";
-	s->mpu_data.io_base = s->iomidi;
-	s->mpu_data.irq = -s->irq;	// tell mpu401 to share irq
-	if (probe_mpu401(&s->mpu_data, ports)) {
-		release_region(s->iomidi, 2);
-		s->iomidi = 0;
-		goto skip_mpu;
-	}
-	maskb(s->iobase + CODEC_CMI_LEGACY_CTRL + 3, ~0x60, reg_mask);
-	/* enable MPU-401 */
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x04);
-	/* clear all previously received interrupt */
-	for (timeout = 900000; timeout > 0; timeout--) {
-		if ((inb(s->iomidi + 1) && 0x80) == 0)
-			inb(s->iomidi);
-		else
-			break;
-	}
-	if (!probe_mpu401(&s->mpu_data, ports)) {
-		release_region(s->iomidi, 2);
-		s->iomidi = 0;
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0, 0x04);
-	} else {
-		attach_mpu401(&s->mpu_data, THIS_MODULE);
-		s->midi_devc = s->mpu_data.slots[1];
-	}
-skip_mpu:
-#endif
-	/* disable joystick port */
-	maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x02, 0);
-	if (joystick)
-		cm_create_gameport(s, 0x200);
-
-	/* store it in the driver field */
-	pci_set_drvdata(pcidev, s);
-	/* put it into driver list */
-	list_add_tail(&s->devs, &devs);
-	/* increment devindex */
-	if (devindex < NR_DEVICE-1)
-		devindex++;
-	return 0;
-
-err_dev2:
-	unregister_sound_dsp(s->dev_audio);
-err_dev1:
-	printk(KERN_ERR "cmpci: cannot register misc device\n");
-	free_irq(s->irq, s);
-err_irq:
-	release_region(s->iobase, CM_EXTENT_CODEC);
-err_region5:
-	kfree(s);
-	return ret;
-}
-
-/* --------------------------------------------------------------------- */
-
-MODULE_AUTHOR("ChenLi Tien, cltien@cmedia.com.tw");
-MODULE_DESCRIPTION("CM8x38 Audio Driver");
-MODULE_LICENSE("GPL");
-
-static void __devexit cm_remove(struct pci_dev *dev)
-{
-	struct cm_state *s = pci_get_drvdata(dev);
-
-	if (!s)
-		return;
-
-	cm_free_gameport(s);
-
-#ifdef CONFIG_SOUND_CMPCI_FM
-	if (s->iosynth) {
-		/* disable FM */
-		maskb(s->iobase + CODEC_CMI_MISC_CTRL + 2, ~8, 0);
-	}
-#endif
-#ifdef CONFIG_SOUND_CMPCI_MIDI
-	if (s->iomidi) {
-		unload_mpu401(&s->mpu_data);
-		/* disable MPU-401 */
-		maskb(s->iobase + CODEC_CMI_FUNCTRL1, ~0x04, 0);
-	}
-#endif
-	set_spdif_loop(s, 0);
-	list_del(&s->devs);
-	outb(0, s->iobase + CODEC_CMI_INT_HLDCLR + 2);  /* disable ints */
-	synchronize_irq(s->irq);
-	outb(0, s->iobase + CODEC_CMI_FUNCTRL0 + 2); /* disable channels */
-	free_irq(s->irq, s);
-
-	/* reset mixer */
-	wrmixer(s, DSP_MIX_DATARESETIDX, 0);
-
-	release_region(s->iobase, CM_EXTENT_CODEC);
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->dev_mixer);
-	kfree(s);
-	pci_set_drvdata(dev, NULL);
-}
-
-static struct pci_device_id id_table[] __devinitdata = {
-	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738B, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
-	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
- 	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
-	{ PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
-	{ 0, }
-};
-
-MODULE_DEVICE_TABLE(pci, id_table);
-
-static struct pci_driver cm_driver = {
-       .name	 = "cmpci",
-       .id_table = id_table,
-       .probe	 = cm_probe,
-       .remove	 = __devexit_p(cm_remove)
-};
-
-static int __init init_cmpci(void)
-{
-	printk(KERN_INFO "cmpci: version $Revision: 6.82 $ time " __TIME__ " " __DATE__ "\n");
-	return pci_register_driver(&cm_driver);
-}
-
-static void __exit cleanup_cmpci(void)
-{
-	printk(KERN_INFO "cmpci: unloading\n");
-	pci_unregister_driver(&cm_driver);
-}
-
-module_init(init_cmpci);
-module_exit(cleanup_cmpci);
--- linux-2.6.18.noarch/sound/oss/gus_wave.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus_wave.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,3464 +0,0 @@
-/*
- * sound/gus_wave.c
- *
- * Driver for the Gravis UltraSound wave table synth.
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- *
- * Thomas Sailer    : ioctl code reworked (vmalloc/vfree removed)
- * Frank van de Pol : Fixed GUS MAX interrupt handling. Enabled simultanious
- *                    usage of CS4231A codec, GUS wave and MIDI for GUS MAX.
- * Bartlomiej Zolnierkiewicz : added some __init/__exit
- */
- 
-#include <linux/init.h> 
-#include <linux/config.h>
-#include <linux/spinlock.h>
-
-#define GUSPNP_AUTODETECT
-
-#include "sound_config.h"
-#include <linux/ultrasound.h>
-
-#include "gus.h"
-#include "gus_hw.h"
-
-#define GUS_BANK_SIZE (((iw_mode) ? 256*1024*1024 : 256*1024))
-
-#define MAX_SAMPLE	150
-#define MAX_PATCH	256
-
-#define NOT_SAMPLE	0xffff
-
-struct voice_info
-{
-	unsigned long   orig_freq;
-	unsigned long   current_freq;
-	unsigned long   mode;
-	int             fixed_pitch;
-	int             bender;
-	int             bender_range;
-	int             panning;
-	int             midi_volume;
-	unsigned int    initial_volume;
-	unsigned int    current_volume;
-	int             loop_irq_mode, loop_irq_parm;
-#define LMODE_FINISH		1
-#define LMODE_PCM		2
-#define LMODE_PCM_STOP		3
-	int             volume_irq_mode, volume_irq_parm;
-#define VMODE_HALT		1
-#define VMODE_ENVELOPE		2
-#define VMODE_START_NOTE	3
-
-	int             env_phase;
-	unsigned char   env_rate[6];
-	unsigned char   env_offset[6];
-
-	/*
-	 * Volume computation parameters for gus_adagio_vol()
-	 */
-	int		main_vol, expression_vol, patch_vol;
-
-	/* Variables for "Ultraclick" removal */
-	int             dev_pending, note_pending, volume_pending,
-	                sample_pending;
-	char            kill_pending;
-	long            offset_pending;
-
-};
-
-static struct voice_alloc_info *voice_alloc;
-static struct address_info *gus_hw_config;
-extern int      gus_base;
-extern int      gus_irq, gus_dma;
-extern int      gus_pnp_flag;
-extern int      gus_no_wave_dma;
-static int      gus_dma2 = -1;
-static int      dual_dma_mode;
-static long     gus_mem_size;
-static long     free_mem_ptr;
-static int      gus_busy;
-static int      gus_no_dma;
-static int      nr_voices;
-static int      gus_devnum;
-static int      volume_base, volume_scale, volume_method;
-static int      gus_recmask = SOUND_MASK_MIC;
-static int      recording_active;
-static int      only_read_access;
-static int      only_8_bits;
-
-static int      iw_mode = 0;
-int             gus_wave_volume = 60;
-int             gus_pcm_volume = 80;
-int             have_gus_max = 0;
-static int      gus_line_vol = 100, gus_mic_vol;
-static unsigned char mix_image = 0x00;
-
-int             gus_timer_enabled = 0;
-
-/*
- * Current version of this driver doesn't allow synth and PCM functions
- * at the same time. The active_device specifies the active driver
- */
-
-static int      active_device;
-
-#define GUS_DEV_WAVE		1	/* Wave table synth */
-#define GUS_DEV_PCM_DONE	2	/* PCM device, transfer done */
-#define GUS_DEV_PCM_CONTINUE	3	/* PCM device, transfer done ch. 1/2 */
-
-static int      gus_audio_speed;
-static int      gus_audio_channels;
-static int      gus_audio_bits;
-static int      gus_audio_bsize;
-static char     bounce_buf[8 * 1024];	/* Must match value set to max_fragment */
-
-static DECLARE_WAIT_QUEUE_HEAD(dram_sleeper);
-
-/*
- * Variables and buffers for PCM output
- */
-
-#define MAX_PCM_BUFFERS		(128*MAX_REALTIME_FACTOR)	/* Don't change */
-
-static int      pcm_bsize, pcm_nblk, pcm_banksize;
-static int      pcm_datasize[MAX_PCM_BUFFERS];
-static volatile int pcm_head, pcm_tail, pcm_qlen;
-static volatile int pcm_active;
-static volatile int dma_active;
-static int      pcm_opened;
-static int      pcm_current_dev;
-static int      pcm_current_block;
-static unsigned long pcm_current_buf;
-static int      pcm_current_count;
-static int      pcm_current_intrflag;
-DEFINE_SPINLOCK(gus_lock);
-
-extern int     *gus_osp;
-
-static struct voice_info voices[32];
-
-static int      freq_div_table[] =
-{
-	44100,			/* 14 */
-	41160,			/* 15 */
-	38587,			/* 16 */
-	36317,			/* 17 */
-	34300,			/* 18 */
-	32494,			/* 19 */
-	30870,			/* 20 */
-	29400,			/* 21 */
-	28063,			/* 22 */
-	26843,			/* 23 */
-	25725,			/* 24 */
-	24696,			/* 25 */
-	23746,			/* 26 */
-	22866,			/* 27 */
-	22050,			/* 28 */
-	21289,			/* 29 */
-	20580,			/* 30 */
-	19916,			/* 31 */
-	19293			/* 32 */
-};
-
-static struct patch_info *samples;
-static long     sample_ptrs[MAX_SAMPLE + 1];
-static int      sample_map[32];
-static int      free_sample;
-static int      mixer_type;
-
-
-static int      patch_table[MAX_PATCH];
-static int      patch_map[32];
-
-static struct synth_info gus_info = {
-	"Gravis UltraSound", 0, SYNTH_TYPE_SAMPLE, SAMPLE_TYPE_GUS, 
-	0, 16, 0, MAX_PATCH
-};
-
-static void     gus_poke(long addr, unsigned char data);
-static void     compute_and_set_volume(int voice, int volume, int ramp_time);
-extern unsigned short gus_adagio_vol(int vel, int mainv, int xpn, int voicev);
-extern unsigned short gus_linear_vol(int vol, int mainvol);
-static void     compute_volume(int voice, int volume);
-static void     do_volume_irq(int voice);
-static void     set_input_volumes(void);
-static void     gus_tmr_install(int io_base);
-
-#define	INSTANT_RAMP		-1	/* Instant change. No ramping */
-#define FAST_RAMP		0	/* Fastest possible ramp */
-
-static void reset_sample_memory(void)
-{
-	int i;
-
-	for (i = 0; i <= MAX_SAMPLE; i++)
-		sample_ptrs[i] = -1;
-	for (i = 0; i < 32; i++)
-		sample_map[i] = -1;
-	for (i = 0; i < 32; i++)
-		patch_map[i] = -1;
-
-	gus_poke(0, 0);		/* Put a silent sample to the beginning */
-	gus_poke(1, 0);
-	free_mem_ptr = 2;
-
-	free_sample = 0;
-
-	for (i = 0; i < MAX_PATCH; i++)
-		patch_table[i] = NOT_SAMPLE;
-}
-
-void gus_delay(void)
-{
-	int i;
-
-	for (i = 0; i < 7; i++)
-		inb(u_DRAMIO);
-}
-
-static void gus_poke(long addr, unsigned char data)
-{				/* Writes a byte to the DRAM */
-	outb((0x43), u_Command);
-	outb((addr & 0xff), u_DataLo);
-	outb(((addr >> 8) & 0xff), u_DataHi);
-
-	outb((0x44), u_Command);
-	outb(((addr >> 16) & 0xff), u_DataHi);
-	outb((data), u_DRAMIO);
-}
-
-static unsigned char gus_peek(long addr)
-{				/* Reads a byte from the DRAM */
-	unsigned char   tmp;
-
-	outb((0x43), u_Command);
-	outb((addr & 0xff), u_DataLo);
-	outb(((addr >> 8) & 0xff), u_DataHi);
-
-	outb((0x44), u_Command);
-	outb(((addr >> 16) & 0xff), u_DataHi);
-	tmp = inb(u_DRAMIO);
-
-	return tmp;
-}
-
-void gus_write8(int reg, unsigned int data)
-{				/* Writes to an indirect register (8 bit) */
-	outb((reg), u_Command);
-	outb(((unsigned char) (data & 0xff)), u_DataHi);
-}
-
-static unsigned char gus_read8(int reg)
-{				
-	/* Reads from an indirect register (8 bit). Offset 0x80. */
-	unsigned char   val;
-
-	outb((reg | 0x80), u_Command);
-	val = inb(u_DataHi);
-
-	return val;
-}
-
-static unsigned char gus_look8(int reg)
-{
-	/* Reads from an indirect register (8 bit). No additional offset. */
-	unsigned char   val;
-
-	outb((reg), u_Command);
-	val = inb(u_DataHi);
-
-	return val;
-}
-
-static void gus_write16(int reg, unsigned int data)
-{
-	/* Writes to an indirect register (16 bit) */
-	outb((reg), u_Command);
-
-	outb(((unsigned char) (data & 0xff)), u_DataLo);
-	outb(((unsigned char) ((data >> 8) & 0xff)), u_DataHi);
-}
-
-static unsigned short gus_read16(int reg)
-{
-	/* Reads from an indirect register (16 bit). Offset 0x80. */
-	unsigned char   hi, lo;
-
-	outb((reg | 0x80), u_Command);
-
-	lo = inb(u_DataLo);
-	hi = inb(u_DataHi);
-
-	return ((hi << 8) & 0xff00) | lo;
-}
-
-static unsigned short gus_look16(int reg)
-{		
-	/* Reads from an indirect register (16 bit). No additional offset. */
-	unsigned char   hi, lo;
-
-	outb((reg), u_Command);
-
-	lo = inb(u_DataLo);
-	hi = inb(u_DataHi);
-
-	return ((hi << 8) & 0xff00) | lo;
-}
-
-static void gus_write_addr(int reg, unsigned long address, int frac, int is16bit)
-{
-	/* Writes an 24 bit memory address */
-	unsigned long   hold_address;
-
-	if (is16bit)
-	{
-		if (iw_mode)
-		{
-			/* Interwave spesific address translations */
-			address >>= 1;
-		}
-		else
-		{
-			/*
-			 * Special processing required for 16 bit patches
-			 */
-
-			hold_address = address;
-			address = address >> 1;
-			address &= 0x0001ffffL;
-			address |= (hold_address & 0x000c0000L);
-		}
-	}
-	gus_write16(reg, (unsigned short) ((address >> 7) & 0xffff));
-	gus_write16(reg + 1, (unsigned short) ((address << 9) & 0xffff)
-		    + (frac << 5));
-	/* Could writing twice fix problems with GUS_VOICE_POS()? Let's try. */
-	gus_delay();
-	gus_write16(reg, (unsigned short) ((address >> 7) & 0xffff));
-	gus_write16(reg + 1, (unsigned short) ((address << 9) & 0xffff)
-		    + (frac << 5));
-}
-
-static void gus_select_voice(int voice)
-{
-	if (voice < 0 || voice > 31)
-		return;
-	outb((voice), u_Voice);
-}
-
-static void gus_select_max_voices(int nvoices)
-{
-	if (iw_mode)
-		nvoices = 32;
-	if (nvoices < 14)
-		nvoices = 14;
-	if (nvoices > 32)
-		nvoices = 32;
-
-	voice_alloc->max_voice = nr_voices = nvoices;
-	gus_write8(0x0e, (nvoices - 1) | 0xc0);
-}
-
-static void gus_voice_on(unsigned int mode)
-{
-	gus_write8(0x00, (unsigned char) (mode & 0xfc));
-	gus_delay();
-	gus_write8(0x00, (unsigned char) (mode & 0xfc));
-}
-
-static void gus_voice_off(void)
-{
-	gus_write8(0x00, gus_read8(0x00) | 0x03);
-}
-
-static void gus_voice_mode(unsigned int m)
-{
-	unsigned char   mode = (unsigned char) (m & 0xff);
-
-	gus_write8(0x00, (gus_read8(0x00) & 0x03) |
-		   (mode & 0xfc));	/* Don't touch last two bits */
-	gus_delay();
-	gus_write8(0x00, (gus_read8(0x00) & 0x03) | (mode & 0xfc));
-}
-
-static void gus_voice_freq(unsigned long freq)
-{
-	unsigned long   divisor = freq_div_table[nr_voices - 14];
-	unsigned short  fc;
-
-	/* Interwave plays at 44100 Hz with any number of voices */
-	if (iw_mode)
-		fc = (unsigned short) (((freq << 9) + (44100 >> 1)) / 44100);
-	else
-		fc = (unsigned short) (((freq << 9) + (divisor >> 1)) / divisor);
-	fc = fc << 1;
-
-	gus_write16(0x01, fc);
-}
-
-static void gus_voice_volume(unsigned int vol)
-{
-	gus_write8(0x0d, 0x03);	/* Stop ramp before setting volume */
-	gus_write16(0x09, (unsigned short) (vol << 4));
-}
-
-static void gus_voice_balance(unsigned int balance)
-{
-	gus_write8(0x0c, (unsigned char) (balance & 0xff));
-}
-
-static void gus_ramp_range(unsigned int low, unsigned int high)
-{
-	gus_write8(0x07, (unsigned char) ((low >> 4) & 0xff));
-	gus_write8(0x08, (unsigned char) ((high >> 4) & 0xff));
-}
-
-static void gus_ramp_rate(unsigned int scale, unsigned int rate)
-{
-	gus_write8(0x06, (unsigned char) (((scale & 0x03) << 6) | (rate & 0x3f)));
-}
-
-static void gus_rampon(unsigned int m)
-{
-	unsigned char   mode = (unsigned char) (m & 0xff);
-
-	gus_write8(0x0d, mode & 0xfc);
-	gus_delay();
-	gus_write8(0x0d, mode & 0xfc);
-}
-
-static void gus_ramp_mode(unsigned int m)
-{
-	unsigned char mode = (unsigned char) (m & 0xff);
-
-	gus_write8(0x0d, (gus_read8(0x0d) & 0x03) |
-		   (mode & 0xfc));	/* Leave the last 2 bits alone */
-	gus_delay();
-	gus_write8(0x0d, (gus_read8(0x0d) & 0x03) | (mode & 0xfc));
-}
-
-static void gus_rampoff(void)
-{
-	gus_write8(0x0d, 0x03);
-}
-
-static void gus_set_voice_pos(int voice, long position)
-{
-	int sample_no;
-
-	if ((sample_no = sample_map[voice]) != -1) {
-		if (position < samples[sample_no].len) {
-			if (voices[voice].volume_irq_mode == VMODE_START_NOTE)
-				voices[voice].offset_pending = position;
-			else
-				gus_write_addr(0x0a, sample_ptrs[sample_no] + position, 0,
-				 samples[sample_no].mode & WAVE_16_BITS);
-		}
-	}
-}
-
-static void gus_voice_init(int voice)
-{
-	unsigned long   flags;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-	gus_voice_volume(0);
-	gus_voice_off();
-	gus_write_addr(0x0a, 0, 0, 0);	/* Set current position to 0 */
-	gus_write8(0x00, 0x03);	/* Voice off */
-	gus_write8(0x0d, 0x03);	/* Ramping off */
-	voice_alloc->map[voice] = 0;
-	voice_alloc->alloc_times[voice] = 0;
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-}
-
-static void gus_voice_init2(int voice)
-{
-	voices[voice].panning = 0;
-	voices[voice].mode = 0;
-	voices[voice].orig_freq = 20000;
-	voices[voice].current_freq = 20000;
-	voices[voice].bender = 0;
-	voices[voice].bender_range = 200;
-	voices[voice].initial_volume = 0;
-	voices[voice].current_volume = 0;
-	voices[voice].loop_irq_mode = 0;
-	voices[voice].loop_irq_parm = 0;
-	voices[voice].volume_irq_mode = 0;
-	voices[voice].volume_irq_parm = 0;
-	voices[voice].env_phase = 0;
-	voices[voice].main_vol = 127;
-	voices[voice].patch_vol = 127;
-	voices[voice].expression_vol = 127;
-	voices[voice].sample_pending = -1;
-	voices[voice].fixed_pitch = 0;
-}
-
-static void step_envelope(int voice)
-{
-	unsigned        vol, prev_vol, phase;
-	unsigned char   rate;
-	unsigned long flags;
-
-	if (voices[voice].mode & WAVE_SUSTAIN_ON && voices[voice].env_phase == 2)
-	{
-		spin_lock_irqsave(&gus_lock,flags);
-		gus_select_voice(voice);
-		gus_rampoff();
-		spin_unlock_irqrestore(&gus_lock,flags);
-		return;
-		/*
-		 * Sustain phase begins. Continue envelope after receiving note off.
-		 */
-	}
-	if (voices[voice].env_phase >= 5)
-	{
-		/* Envelope finished. Shoot the voice down */
-		gus_voice_init(voice);
-		return;
-	}
-	prev_vol = voices[voice].current_volume;
-	phase = ++voices[voice].env_phase;
-	compute_volume(voice, voices[voice].midi_volume);
-	vol = voices[voice].initial_volume * voices[voice].env_offset[phase] / 255;
-	rate = voices[voice].env_rate[phase];
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-
-	gus_voice_volume(prev_vol);
-
-
-	gus_write8(0x06, rate);	/* Ramping rate */
-
-	voices[voice].volume_irq_mode = VMODE_ENVELOPE;
-
-	if (((vol - prev_vol) / 64) == 0)	/* No significant volume change */
-	{
-		spin_unlock_irqrestore(&gus_lock,flags);
-		step_envelope(voice);		/* Continue the envelope on the next step */
-		return;
-	}
-	if (vol > prev_vol)
-	{
-		if (vol >= (4096 - 64))
-			vol = 4096 - 65;
-		gus_ramp_range(0, vol);
-		gus_rampon(0x20);	/* Increasing volume, with IRQ */
-	}
-	else
-	{
-		if (vol <= 64)
-			vol = 65;
-		gus_ramp_range(vol, 4030);
-		gus_rampon(0x60);	/* Decreasing volume, with IRQ */
-	}
-	voices[voice].current_volume = vol;
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static void init_envelope(int voice)
-{
-	voices[voice].env_phase = -1;
-	voices[voice].current_volume = 64;
-
-	step_envelope(voice);
-}
-
-static void start_release(int voice)
-{
-	if (gus_read8(0x00) & 0x03)
-		return;		/* Voice already stopped */
-
-	voices[voice].env_phase = 2;	/* Will be incremented by step_envelope */
-
-	voices[voice].current_volume = voices[voice].initial_volume =
-						gus_read16(0x09) >> 4;	/* Get current volume */
-
-	voices[voice].mode &= ~WAVE_SUSTAIN_ON;
-	gus_rampoff();
-	step_envelope(voice);
-}
-
-static void gus_voice_fade(int voice)
-{
-	int instr_no = sample_map[voice], is16bits;
-	unsigned long flags;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-
-	if (instr_no < 0 || instr_no > MAX_SAMPLE)
-	{
-		gus_write8(0x00, 0x03);	/* Hard stop */
-		voice_alloc->map[voice] = 0;
-		spin_unlock_irqrestore(&gus_lock,flags);
-		return;
-	}
-	is16bits = (samples[instr_no].mode & WAVE_16_BITS) ? 1 : 0;	/* 8 or 16 bits */
-
-	if (voices[voice].mode & WAVE_ENVELOPES)
-	{
-		start_release(voice);
-		spin_unlock_irqrestore(&gus_lock,flags);
-		return;
-	}
-	/*
-	 * Ramp the volume down but not too quickly.
-	 */
-	if ((int) (gus_read16(0x09) >> 4) < 100)	/* Get current volume */
-	{
-		gus_voice_off();
-		gus_rampoff();
-		gus_voice_init(voice);
-		spin_unlock_irqrestore(&gus_lock,flags);
-		return;
-	}
-	gus_ramp_range(65, 4030);
-	gus_ramp_rate(2, 4);
-	gus_rampon(0x40 | 0x20);	/* Down, once, with IRQ */
-	voices[voice].volume_irq_mode = VMODE_HALT;
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static void gus_reset(void)
-{
-	int i;
-
-	gus_select_max_voices(24);
-	volume_base = 3071;
-	volume_scale = 4;
-	volume_method = VOL_METHOD_ADAGIO;
-
-	for (i = 0; i < 32; i++)
-	{
-		gus_voice_init(i);	/* Turn voice off */
-		gus_voice_init2(i);
-	}
-}
-
-static void gus_initialize(void)
-{
-	unsigned long flags;
-	unsigned char dma_image, irq_image, tmp;
-
-	static unsigned char gus_irq_map[16] = 	{
-		0, 0, 0, 3, 0, 2, 0, 4, 0, 1, 0, 5, 6, 0, 0, 7
-	};
-
-	static unsigned char gus_dma_map[8] = {
-		0, 1, 0, 2, 0, 3, 4, 5
-	};
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_write8(0x4c, 0);	/* Reset GF1 */
-	gus_delay();
-	gus_delay();
-
-	gus_write8(0x4c, 1);	/* Release Reset */
-	gus_delay();
-	gus_delay();
-
-	/*
-	 * Clear all interrupts
-	 */
-
-	gus_write8(0x41, 0);	/* DMA control */
-	gus_write8(0x45, 0);	/* Timer control */
-	gus_write8(0x49, 0);	/* Sample control */
-
-	gus_select_max_voices(24);
-
-	inb(u_Status);		/* Touch the status register */
-
-	gus_look8(0x41);	/* Clear any pending DMA IRQs */
-	gus_look8(0x49);	/* Clear any pending sample IRQs */
-	gus_read8(0x0f);	/* Clear pending IRQs */
-
-	gus_reset();		/* Resets all voices */
-
-	gus_look8(0x41);	/* Clear any pending DMA IRQs */
-	gus_look8(0x49);	/* Clear any pending sample IRQs */
-	gus_read8(0x0f);	/* Clear pending IRQs */
-
-	gus_write8(0x4c, 7);	/* Master reset | DAC enable | IRQ enable */
-
-	/*
-	 * Set up for Digital ASIC
-	 */
-
-	outb((0x05), gus_base + 0x0f);
-
-	mix_image |= 0x02;	/* Disable line out (for a moment) */
-	outb((mix_image), u_Mixer);
-
-	outb((0x00), u_IRQDMAControl);
-
-	outb((0x00), gus_base + 0x0f);
-
-	/*
-	 * Now set up the DMA and IRQ interface
-	 *
-	 * The GUS supports two IRQs and two DMAs.
-	 *
-	 * Just one DMA channel is used. This prevents simultaneous ADC and DAC.
-	 * Adding this support requires significant changes to the dmabuf.c, dsp.c
-	 * and audio.c also.
-	 */
-
-	irq_image = 0;
-	tmp = gus_irq_map[gus_irq];
-	if (!gus_pnp_flag && !tmp)
-		printk(KERN_WARNING "Warning! GUS IRQ not selected\n");
-	irq_image |= tmp;
-	irq_image |= 0x40;	/* Combine IRQ1 (GF1) and IRQ2 (Midi) */
-
-	dual_dma_mode = 1;
-	if (gus_dma2 == gus_dma || gus_dma2 == -1)
-	{
-		dual_dma_mode = 0;
-		dma_image = 0x40;	/* Combine DMA1 (DRAM) and IRQ2 (ADC) */
-
-		tmp = gus_dma_map[gus_dma];
-		if (!tmp)
-			printk(KERN_WARNING "Warning! GUS DMA not selected\n");
-
-		dma_image |= tmp;
-	}
-	else
-	{
-		/* Setup dual DMA channel mode for GUS MAX */
-
-		dma_image = gus_dma_map[gus_dma];
-		if (!dma_image)
-			printk(KERN_WARNING "Warning! GUS DMA not selected\n");
-
-		tmp = gus_dma_map[gus_dma2] << 3;
-		if (!tmp)
-		{
-			printk(KERN_WARNING "Warning! Invalid GUS MAX DMA\n");
-			tmp = 0x40;		/* Combine DMA channels */
-			    dual_dma_mode = 0;
-		}
-		dma_image |= tmp;
-	}
-
-	/*
-	 * For some reason the IRQ and DMA addresses must be written twice
-	 */
-
-	/*
-	 * Doing it first time
-	 */
-
-	outb((mix_image), u_Mixer);	/* Select DMA control */
-	outb((dma_image | 0x80), u_IRQDMAControl);	/* Set DMA address */
-
-	outb((mix_image | 0x40), u_Mixer);	/* Select IRQ control */
-	outb((irq_image), u_IRQDMAControl);	/* Set IRQ address */
-
-	/*
-	 * Doing it second time
-	 */
-
-	outb((mix_image), u_Mixer);	/* Select DMA control */
-	outb((dma_image), u_IRQDMAControl);	/* Set DMA address */
-
-	outb((mix_image | 0x40), u_Mixer);	/* Select IRQ control */
-	outb((irq_image), u_IRQDMAControl);	/* Set IRQ address */
-
-	gus_select_voice(0);	/* This disables writes to IRQ/DMA reg */
-
-	mix_image &= ~0x02;	/* Enable line out */
-	mix_image |= 0x08;	/* Enable IRQ */
-	outb((mix_image), u_Mixer);	/*
-					 * Turn mixer channels on
-					 * Note! Mic in is left off.
-					 */
-
-	gus_select_voice(0);	/* This disables writes to IRQ/DMA reg */
-
-	gusintr(gus_irq, (void *)gus_hw_config, NULL);	/* Serve pending interrupts */
-
-	inb(u_Status);		/* Touch the status register */
-
-	gus_look8(0x41);	/* Clear any pending DMA IRQs */
-	gus_look8(0x49);	/* Clear any pending sample IRQs */
-
-	gus_read8(0x0f);	/* Clear pending IRQs */
-
-	if (iw_mode)
-		gus_write8(0x19, gus_read8(0x19) | 0x01);
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-
-static void __init pnp_mem_init(void)
-{
-#include "iwmem.h"
-#define CHUNK_SIZE (256*1024)
-#define BANK_SIZE (4*1024*1024)
-#define CHUNKS_PER_BANK (BANK_SIZE/CHUNK_SIZE)
-
-	int bank, chunk, addr, total = 0;
-	int bank_sizes[4];
-	int i, j, bits = -1, testbits = -1, nbanks = 0;
-
-	/*
-	 * This routine determines what kind of RAM is installed in each of the four
-	 * SIMM banks and configures the DRAM address decode logic accordingly.
-	 */
-
-	/*
-	 *    Place the chip into enhanced mode
-	 */
-	gus_write8(0x19, gus_read8(0x19) | 0x01);
-	gus_write8(0x53, gus_look8(0x53) & ~0x02);	/* Select DRAM I/O access */
-
-	/*
-	 * Set memory configuration to 4 DRAM banks of 4M in each (16M total).
-	 */
-
-	gus_write16(0x52, (gus_look16(0x52) & 0xfff0) | 0x000c);
-
-	/*
-	 * Perform the DRAM size detection for each bank individually.
-	 */
-	for (bank = 0; bank < 4; bank++)
-	{
-		int size = 0;
-
-		addr = bank * BANK_SIZE;
-
-		/* Clean check points of each chunk */
-		for (chunk = 0; chunk < CHUNKS_PER_BANK; chunk++)
-		{
-			gus_poke(addr + chunk * CHUNK_SIZE + 0L, 0x00);
-			gus_poke(addr + chunk * CHUNK_SIZE + 1L, 0x00);
-		}
-
-		/* Write a value to each chunk point and verify the result */
-		for (chunk = 0; chunk < CHUNKS_PER_BANK; chunk++)
-		{
-			gus_poke(addr + chunk * CHUNK_SIZE + 0L, 0x55);
-			gus_poke(addr + chunk * CHUNK_SIZE + 1L, 0xAA);
-
-			if (gus_peek(addr + chunk * CHUNK_SIZE + 0L) == 0x55 &&
-				gus_peek(addr + chunk * CHUNK_SIZE + 1L) == 0xAA)
-			{
-				/* OK. There is RAM. Now check for possible shadows */
-				int ok = 1, chunk2;
-
-				for (chunk2 = 0; ok && chunk2 < chunk; chunk2++)
-					if (gus_peek(addr + chunk2 * CHUNK_SIZE + 0L) ||
-							gus_peek(addr + chunk2 * CHUNK_SIZE + 1L))
-						ok = 0;	/* Addressing wraps */
-
-				if (ok)
-					size = (chunk + 1) * CHUNK_SIZE;
-			}
-			gus_poke(addr + chunk * CHUNK_SIZE + 0L, 0x00);
-			gus_poke(addr + chunk * CHUNK_SIZE + 1L, 0x00);
-		}
-		bank_sizes[bank] = size;
-		if (size)
-			nbanks = bank + 1;
-		DDB(printk("Interwave: Bank %d, size=%dk\n", bank, size / 1024));
-	}
-
-	if (nbanks == 0)	/* No RAM - Give up */
-	{
-		printk(KERN_ERR "Sound: An Interwave audio chip detected but no DRAM\n");
-		printk(KERN_ERR "Sound: Unable to work with this card.\n");
-		gus_write8(0x19, gus_read8(0x19) & ~0x01);
-		gus_mem_size = 0;
-		return;
-	}
-
-	/*
-	 * Now we know how much DRAM there is in each bank. The next step is
-	 * to find a DRAM size encoding (0 to 12) which is best for the combination
-	 * we have.
-	 *
-	 * First try if any of the possible alternatives matches exactly the amount
-	 * of memory we have.
-	 */
-
-	for (i = 0; bits == -1 && i < 13; i++)
-	{
-		bits = i;
-
-		for (j = 0; bits != -1 && j < 4; j++)
-			if (mem_decode[i][j] != bank_sizes[j])
-				bits = -1;	/* No hit */
-	}
-
-	/*
-	 * If necessary, try to find a combination where other than the last
-	 * bank matches our configuration and the last bank is left oversized.
-	 * In this way we don't leave holes in the middle of memory.
-	 */
-
-	if (bits == -1)		/* No luck yet */
-	{
-		for (i = 0; bits == -1 && i < 13; i++)
-		{
-			bits = i;
-
-			for (j = 0; bits != -1 && j < nbanks - 1; j++)
-				if (mem_decode[i][j] != bank_sizes[j])
-					bits = -1;	/* No hit */
-			if (mem_decode[i][nbanks - 1] < bank_sizes[nbanks - 1])
-				bits = -1;	/* The last bank is too small */
-		}
-	}
-	/*
- 	 * The last resort is to search for a combination where the banks are
- 	 * smaller than the actual SIMMs. This leaves some memory in the banks
- 	 * unused but doesn't leave holes in the DRAM address space.
- 	 */
- 	if (bits == -1)		/* No luck yet */
- 	{
- 		for (i = 0; i < 13; i++)
- 		{
- 			testbits = i;
- 			for (j = 0; testbits != -1 && j < nbanks - 1; j++)
- 				if (mem_decode[i][j] > bank_sizes[j]) {
- 					testbits = -1;
- 				}
- 			if(testbits > bits) bits = testbits;
- 		}
- 		if (bits != -1)
- 		{
-			printk(KERN_INFO "Interwave: Can't use all installed RAM.\n");
-			printk(KERN_INFO "Interwave: Try reordering SIMMS.\n");
-		}
-		printk(KERN_INFO "Interwave: Can't find working DRAM encoding.\n");
-		printk(KERN_INFO "Interwave: Defaulting to 256k. Try reordering SIMMS.\n");
-		bits = 0;
-	}
-	DDB(printk("Interwave: Selecting DRAM addressing mode %d\n", bits));
-
-	for (bank = 0; bank < 4; bank++)
-	{
-		DDB(printk("  Bank %d, mem=%dk (limit %dk)\n", bank, bank_sizes[bank] / 1024, mem_decode[bits][bank] / 1024));
-
-		if (bank_sizes[bank] > mem_decode[bits][bank])
-			total += mem_decode[bits][bank];
-		else
-			total += bank_sizes[bank];
-	}
-
-	DDB(printk("Total %dk of DRAM (enhanced mode)\n", total / 1024));
-
-	/*
-	 *    Set the memory addressing mode.
-	 */
-	gus_write16(0x52, (gus_look16(0x52) & 0xfff0) | bits);
-
-/*      Leave the chip into enhanced mode. Disable LFO  */
-	gus_mem_size = total;
-	iw_mode = 1;
-	gus_write8(0x19, (gus_read8(0x19) | 0x01) & ~0x02);
-}
-
-int __init gus_wave_detect(int baseaddr)
-{
-	unsigned long   i, max_mem = 1024L;
-	unsigned long   loc;
-	unsigned char   val;
-
-	if (!request_region(baseaddr, 16, "GUS"))
-		return 0;
-	if (!request_region(baseaddr + 0x100, 12, "GUS")) { /* 0x10c-> is MAX */
-		release_region(baseaddr, 16);
-		return 0;
-	}
-
-	gus_base = baseaddr;
-
-	gus_write8(0x4c, 0);	/* Reset GF1 */
-	gus_delay();
-	gus_delay();
-
-	gus_write8(0x4c, 1);	/* Release Reset */
-	gus_delay();
-	gus_delay();
-
-#ifdef GUSPNP_AUTODETECT
-	val = gus_look8(0x5b);	/* Version number register */
-	gus_write8(0x5b, ~val);	/* Invert all bits */
-
-	if ((gus_look8(0x5b) & 0xf0) == (val & 0xf0))	/* No change */
-	{
-		if ((gus_look8(0x5b) & 0x0f) == ((~val) & 0x0f))	/* Change */
-		{
-			DDB(printk("Interwave chip version %d detected\n", (val & 0xf0) >> 4));
-			gus_pnp_flag = 1;
-		}
-		else
-		{
-			DDB(printk("Not an Interwave chip (%x)\n", gus_look8(0x5b)));
-			gus_pnp_flag = 0;
-		}
-	}
-	gus_write8(0x5b, val);	/* Restore all bits */
-#endif
-
-	if (gus_pnp_flag)
-		pnp_mem_init();
-	if (iw_mode)
-		return 1;
-
-	/* See if there is first block there.... */
-	gus_poke(0L, 0xaa);
-	if (gus_peek(0L) != 0xaa) {
-		release_region(baseaddr + 0x100, 12);
-		release_region(baseaddr, 16);
-		return 0;
-	}
-
-	/* Now zero it out so that I can check for mirroring .. */
-	gus_poke(0L, 0x00);
-	for (i = 1L; i < max_mem; i++)
-	{
-		int n, failed;
-
-		/* check for mirroring ... */
-		if (gus_peek(0L) != 0)
-			break;
-		loc = i << 10;
-
-		for (n = loc - 1, failed = 0; n <= loc; n++)
-		{
-			gus_poke(loc, 0xaa);
-			if (gus_peek(loc) != 0xaa)
-				failed = 1;
-			gus_poke(loc, 0x55);
-			if (gus_peek(loc) != 0x55)
-				failed = 1;
-		}
-		if (failed)
-			break;
-	}
-	gus_mem_size = i << 10;
-	return 1;
-}
-
-static int guswave_ioctl(int dev, unsigned int cmd, void __user *arg)
-{
-
-	switch (cmd) 
-	{
-		case SNDCTL_SYNTH_INFO:
-			gus_info.nr_voices = nr_voices;
-			if (copy_to_user(arg, &gus_info, sizeof(gus_info)))
-				return -EFAULT;
-			return 0;
-
-		case SNDCTL_SEQ_RESETSAMPLES:
-			reset_sample_memory();
-			return 0;
-
-		case SNDCTL_SEQ_PERCMODE:
-			return 0;
-
-		case SNDCTL_SYNTH_MEMAVL:
-			return (gus_mem_size == 0) ? 0 : gus_mem_size - free_mem_ptr - 32;
-
-		default:
-			return -EINVAL;
-	}
-}
-
-static int guswave_set_instr(int dev, int voice, int instr_no)
-{
-	int sample_no;
-
-	if (instr_no < 0 || instr_no > MAX_PATCH)
-		instr_no = 0;	/* Default to acoustic piano */
-
-	if (voice < 0 || voice > 31)
-		return -EINVAL;
-
-	if (voices[voice].volume_irq_mode == VMODE_START_NOTE)
-	{
-		voices[voice].sample_pending = instr_no;
-		return 0;
-	}
-	sample_no = patch_table[instr_no];
-	patch_map[voice] = -1;
-
-	if (sample_no == NOT_SAMPLE)
-	{
-/*		printk("GUS: Undefined patch %d for voice %d\n", instr_no, voice);*/
-		return -EINVAL;	/* Patch not defined */
-	}
-	if (sample_ptrs[sample_no] == -1)	/* Sample not loaded */
-	{
-/*		printk("GUS: Sample #%d not loaded for patch %d (voice %d)\n", sample_no, instr_no, voice);*/
-		return -EINVAL;
-	}
-	sample_map[voice] = sample_no;
-	patch_map[voice] = instr_no;
-	return 0;
-}
-
-static int guswave_kill_note(int dev, int voice, int note, int velocity)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	/* voice_alloc->map[voice] = 0xffff; */
-	if (voices[voice].volume_irq_mode == VMODE_START_NOTE)
-	{
-		voices[voice].kill_pending = 1;
-		spin_unlock_irqrestore(&gus_lock,flags);
-	}
-	else
-	{
-		spin_unlock_irqrestore(&gus_lock,flags);
-		gus_voice_fade(voice);
-	}
-
-	return 0;
-}
-
-static void guswave_aftertouch(int dev, int voice, int pressure)
-{
-}
-
-static void guswave_panning(int dev, int voice, int value)
-{
-	if (voice >= 0 || voice < 32)
-		voices[voice].panning = value;
-}
-
-static void guswave_volume_method(int dev, int mode)
-{
-	if (mode == VOL_METHOD_LINEAR || mode == VOL_METHOD_ADAGIO)
-		volume_method = mode;
-}
-
-static void compute_volume(int voice, int volume)
-{
-	if (volume < 128)
-		voices[voice].midi_volume = volume;
-
-	switch (volume_method)
-	{
-		case VOL_METHOD_ADAGIO:
-			voices[voice].initial_volume =
-				gus_adagio_vol(voices[voice].midi_volume, voices[voice].main_vol,
-					voices[voice].expression_vol,
-					voices[voice].patch_vol);
-			break;
-
-		case VOL_METHOD_LINEAR:	/* Totally ignores patch-volume and expression */
-			voices[voice].initial_volume = gus_linear_vol(volume, voices[voice].main_vol);
-			break;
-
-		default:
-			voices[voice].initial_volume = volume_base +
-				(voices[voice].midi_volume * volume_scale);
-	}
-
-	if (voices[voice].initial_volume > 4030)
-		voices[voice].initial_volume = 4030;
-}
-
-static void compute_and_set_volume(int voice, int volume, int ramp_time)
-{
-	int curr, target, rate;
-	unsigned long flags;
-
-	compute_volume(voice, volume);
-	voices[voice].current_volume = voices[voice].initial_volume;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	/*
-	 * CAUTION! Interrupts disabled. Enable them before returning
-	 */
-
-	gus_select_voice(voice);
-
-	curr = gus_read16(0x09) >> 4;
-	target = voices[voice].initial_volume;
-
-	if (ramp_time == INSTANT_RAMP)
-	{
-		gus_rampoff();
-		gus_voice_volume(target);
-		spin_unlock_irqrestore(&gus_lock,flags);
-		return;
-	}
-	if (ramp_time == FAST_RAMP)
-		rate = 63;
-	else
-		rate = 16;
-	gus_ramp_rate(0, rate);
-
-	if ((target - curr) / 64 == 0)	/* Close enough to target. */
-	{
-		gus_rampoff();
-		gus_voice_volume(target);
-		spin_unlock_irqrestore(&gus_lock,flags);
-		return;
-	}
-	if (target > curr)
-	{
-		if (target > (4095 - 65))
-			target = 4095 - 65;
-		gus_ramp_range(curr, target);
-		gus_rampon(0x00);	/* Ramp up, once, no IRQ */
-	}
-	else
-	{
-		if (target < 65)
-			target = 65;
-
-		gus_ramp_range(target, curr);
-		gus_rampon(0x40);	/* Ramp down, once, no irq */
-	}
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static void dynamic_volume_change(int voice)
-{
-	unsigned char status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-	status = gus_read8(0x00);	/* Get voice status */
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-	if (status & 0x03)
-		return;		/* Voice was not running */
-
-	if (!(voices[voice].mode & WAVE_ENVELOPES))
-	{
-		compute_and_set_volume(voice, voices[voice].midi_volume, 1);
-		return;
-	}
-	
-	/*
-	 * Voice is running and has envelopes.
-	 */
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-	status = gus_read8(0x0d);	/* Ramping status */
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-	if (status & 0x03)	/* Sustain phase? */
-	{
-		compute_and_set_volume(voice, voices[voice].midi_volume, 1);
-		return;
-	}
-	if (voices[voice].env_phase < 0)
-		return;
-
-	compute_volume(voice, voices[voice].midi_volume);
-
-}
-
-static void guswave_controller(int dev, int voice, int ctrl_num, int value)
-{
-	unsigned long   flags;
-	unsigned long   freq;
-
-	if (voice < 0 || voice > 31)
-		return;
-
-	switch (ctrl_num)
-	{
-		case CTRL_PITCH_BENDER:
-			voices[voice].bender = value;
-
-			if (voices[voice].volume_irq_mode != VMODE_START_NOTE)
-			{
-				freq = compute_finetune(voices[voice].orig_freq, value, voices[voice].bender_range, 0);
-				voices[voice].current_freq = freq;
-
-				spin_lock_irqsave(&gus_lock,flags);
-				gus_select_voice(voice);
-				gus_voice_freq(freq);
-				spin_unlock_irqrestore(&gus_lock,flags);
-			}
-			break;
-
-		case CTRL_PITCH_BENDER_RANGE:
-			voices[voice].bender_range = value;
-			break;
-		case CTL_EXPRESSION:
-			value /= 128;
-		case CTRL_EXPRESSION:
-			if (volume_method == VOL_METHOD_ADAGIO)
-			{
-				voices[voice].expression_vol = value;
-				if (voices[voice].volume_irq_mode != VMODE_START_NOTE)
-					dynamic_volume_change(voice);
-			}
-			break;
-
-		case CTL_PAN:
-			voices[voice].panning = (value * 2) - 128;
-			break;
-
-		case CTL_MAIN_VOLUME:
-			value = (value * 100) / 16383;
-
-		case CTRL_MAIN_VOLUME:
-			voices[voice].main_vol = value;
-			if (voices[voice].volume_irq_mode != VMODE_START_NOTE)
-				dynamic_volume_change(voice);
-			break;
-
-		default:
-			break;
-	}
-}
-
-static int guswave_start_note2(int dev, int voice, int note_num, int volume)
-{
-	int sample, best_sample, best_delta, delta_freq;
-	int is16bits, samplep, patch, pan;
-	unsigned long   note_freq, base_note, freq, flags;
-	unsigned char   mode = 0;
-
-	if (voice < 0 || voice > 31)
-	{
-/*		printk("GUS: Invalid voice\n");*/
-		return -EINVAL;
-	}
-	if (note_num == 255)
-	{
-		if (voices[voice].mode & WAVE_ENVELOPES)
-		{
-			voices[voice].midi_volume = volume;
-			dynamic_volume_change(voice);
-			return 0;
-		}
-		compute_and_set_volume(voice, volume, 1);
-		return 0;
-	}
-	if ((patch = patch_map[voice]) == -1)
-		return -EINVAL;
-	if ((samplep = patch_table[patch]) == NOT_SAMPLE)
-	{
-		return -EINVAL;
-	}
-	note_freq = note_to_freq(note_num);
-
-	/*
-	 * Find a sample within a patch so that the note_freq is between low_note
-	 * and high_note.
-	 */
-	sample = -1;
-
-	best_sample = samplep;
-	best_delta = 1000000;
-	while (samplep != 0 && samplep != NOT_SAMPLE && sample == -1)
-	{
-		delta_freq = note_freq - samples[samplep].base_note;
-		if (delta_freq < 0)
-			delta_freq = -delta_freq;
-		if (delta_freq < best_delta)
-		{
-			best_sample = samplep;
-			best_delta = delta_freq;
-		}
-		if (samples[samplep].low_note <= note_freq &&
-			note_freq <= samples[samplep].high_note)
-		{
-			sample = samplep;
-		}
-		else
-			samplep = samples[samplep].key;	/* Link to next sample */
-	  }
-	if (sample == -1)
-		sample = best_sample;
-
-	if (sample == -1)
-	{
-/*		printk("GUS: Patch %d not defined for note %d\n", patch, note_num);*/
-		return 0;	/* Should play default patch ??? */
-	}
-	is16bits = (samples[sample].mode & WAVE_16_BITS) ? 1 : 0;
-	voices[voice].mode = samples[sample].mode;
-	voices[voice].patch_vol = samples[sample].volume;
-
-	if (iw_mode)
-		gus_write8(0x15, 0x00);		/* RAM, Reset voice deactivate bit of SMSI */
-
-	if (voices[voice].mode & WAVE_ENVELOPES)
-	{
-		int i;
-
-		for (i = 0; i < 6; i++)
-		{
-			voices[voice].env_rate[i] = samples[sample].env_rate[i];
-			voices[voice].env_offset[i] = samples[sample].env_offset[i];
-		}
-	}
-	sample_map[voice] = sample;
-
-	if (voices[voice].fixed_pitch)	/* Fixed pitch */
-	{
-		  freq = samples[sample].base_freq;
-	}
-	else
-	{
-		base_note = samples[sample].base_note / 100;
-		note_freq /= 100;
-
-		freq = samples[sample].base_freq * note_freq / base_note;
-	}
-
-	voices[voice].orig_freq = freq;
-
-	/*
-	 * Since the pitch bender may have been set before playing the note, we
-	 * have to calculate the bending now.
-	 */
-
-	freq = compute_finetune(voices[voice].orig_freq, voices[voice].bender,
-				voices[voice].bender_range, 0);
-	voices[voice].current_freq = freq;
-
-	pan = (samples[sample].panning + voices[voice].panning) / 32;
-	pan += 7;
-	if (pan < 0)
-		pan = 0;
-	if (pan > 15)
-		pan = 15;
-
-	if (samples[sample].mode & WAVE_16_BITS)
-	{
-		mode |= 0x04;	/* 16 bits */
-		if ((sample_ptrs[sample] / GUS_BANK_SIZE) !=
-			((sample_ptrs[sample] + samples[sample].len) / GUS_BANK_SIZE))
-				printk(KERN_ERR "GUS: Sample address error\n");
-	}
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-	gus_voice_off();
-	gus_rampoff();
-
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-	if (voices[voice].mode & WAVE_ENVELOPES)
-	{
-		compute_volume(voice, volume);
-		init_envelope(voice);
-	}
-	else
-	{
-		compute_and_set_volume(voice, volume, 0);
-	}
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-
-	if (samples[sample].mode & WAVE_LOOP_BACK)
-		gus_write_addr(0x0a, sample_ptrs[sample] + samples[sample].len -
-			voices[voice].offset_pending, 0, is16bits);	/* start=end */
-	else
-		gus_write_addr(0x0a, sample_ptrs[sample] + voices[voice].offset_pending, 0, is16bits);	/* Sample start=begin */
-
-	if (samples[sample].mode & WAVE_LOOPING)
-	{
-		mode |= 0x08;
-
-		if (samples[sample].mode & WAVE_BIDIR_LOOP)
-			mode |= 0x10;
-
-		if (samples[sample].mode & WAVE_LOOP_BACK)
-		{
-			gus_write_addr(0x0a, sample_ptrs[sample] + samples[sample].loop_end -
-					   voices[voice].offset_pending,
-					   (samples[sample].fractions >> 4) & 0x0f, is16bits);
-			mode |= 0x40;
-		}
-		gus_write_addr(0x02, sample_ptrs[sample] + samples[sample].loop_start,
-			samples[sample].fractions & 0x0f, is16bits);	/* Loop start location */
-		gus_write_addr(0x04, sample_ptrs[sample] + samples[sample].loop_end,
-			(samples[sample].fractions >> 4) & 0x0f, is16bits);	/* Loop end location */
-	}
-	else
-	{
-		mode |= 0x20;	/* Loop IRQ at the end */
-		voices[voice].loop_irq_mode = LMODE_FINISH;	/* Ramp down at the end */
-		voices[voice].loop_irq_parm = 1;
-		gus_write_addr(0x02, sample_ptrs[sample], 0, is16bits);	/* Loop start location */
-		gus_write_addr(0x04, sample_ptrs[sample] + samples[sample].len - 1,
-			(samples[sample].fractions >> 4) & 0x0f, is16bits);	/* Loop end location */
-	}
-	gus_voice_freq(freq);
-	gus_voice_balance(pan);
-	gus_voice_on(mode);
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-	return 0;
-}
-
-/*
- * New guswave_start_note by Andrew J. Robinson attempts to minimize clicking
- * when the note playing on the voice is changed.  It uses volume
- * ramping.
- */
-
-static int guswave_start_note(int dev, int voice, int note_num, int volume)
-{
-	unsigned long flags;
-	int mode;
-	int ret_val = 0;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	if (note_num == 255)
-	{
-		if (voices[voice].volume_irq_mode == VMODE_START_NOTE)
-		{
-			voices[voice].volume_pending = volume;
-		}
-		else
-		{
-			ret_val = guswave_start_note2(dev, voice, note_num, volume);
-		}
-	}
-	else
-	{
-		gus_select_voice(voice);
-		mode = gus_read8(0x00);
-		if (mode & 0x20)
-			gus_write8(0x00, mode & 0xdf);	/* No interrupt! */
-
-		voices[voice].offset_pending = 0;
-		voices[voice].kill_pending = 0;
-		voices[voice].volume_irq_mode = 0;
-		voices[voice].loop_irq_mode = 0;
-
-		if (voices[voice].sample_pending >= 0)
-		{
-			spin_unlock_irqrestore(&gus_lock,flags);	/* Run temporarily with interrupts enabled */
-			guswave_set_instr(voices[voice].dev_pending, voice, voices[voice].sample_pending);
-			voices[voice].sample_pending = -1;
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);	/* Reselect the voice (just to be sure) */
-		}
-		if ((mode & 0x01) || (int) ((gus_read16(0x09) >> 4) < (unsigned) 2065))
-		{
-			ret_val = guswave_start_note2(dev, voice, note_num, volume);
-		}
-		else
-		{
-			voices[voice].dev_pending = dev;
-			voices[voice].note_pending = note_num;
-			voices[voice].volume_pending = volume;
-			voices[voice].volume_irq_mode = VMODE_START_NOTE;
-
-			gus_rampoff();
-			gus_ramp_range(2000, 4065);
-			gus_ramp_rate(0, 63);	/* Fastest possible rate */
-			gus_rampon(0x20 | 0x40);	/* Ramp down, once, irq */
-		}
-	}
-	spin_unlock_irqrestore(&gus_lock,flags);
-	return ret_val;
-}
-
-static void guswave_reset(int dev)
-{
-	int i;
-
-	for (i = 0; i < 32; i++)
-	{
-		gus_voice_init(i);
-		gus_voice_init2(i);
-	}
-}
-
-static int guswave_open(int dev, int mode)
-{
-	int err;
-
-	if (gus_busy)
-		return -EBUSY;
-
-	voice_alloc->timestamp = 0;
-
-	if (gus_no_wave_dma) {
-		gus_no_dma = 1;
-	} else {
-		if ((err = DMAbuf_open_dma(gus_devnum)) < 0)
-		{
-			/* printk( "GUS: Loading samples without DMA\n"); */
-			gus_no_dma = 1;	/* Upload samples using PIO */
-		}
-		else
-			gus_no_dma = 0;
-	}
-
-	init_waitqueue_head(&dram_sleeper);
-	gus_busy = 1;
-	active_device = GUS_DEV_WAVE;
-
-	gusintr(gus_irq, (void *)gus_hw_config, NULL);	/* Serve pending interrupts */
-	gus_initialize();
-	gus_reset();
-	gusintr(gus_irq, (void *)gus_hw_config, NULL);	/* Serve pending interrupts */
-
-	return 0;
-}
-
-static void guswave_close(int dev)
-{
-	gus_busy = 0;
-	active_device = 0;
-	gus_reset();
-
-	if (!gus_no_dma)
-		DMAbuf_close_dma(gus_devnum);
-}
-
-static int guswave_load_patch(int dev, int format, const char __user *addr,
-		   int offs, int count, int pmgr_flag)
-{
-	struct patch_info patch;
-	int instr;
-	long sizeof_patch;
-
-	unsigned long blk_sz, blk_end, left, src_offs, target;
-
-	sizeof_patch = (long) &patch.data[0] - (long) &patch;	/* Header size */
-
-	if (format != GUS_PATCH)
-	{
-/*		printk("GUS Error: Invalid patch format (key) 0x%x\n", format);*/
-		return -EINVAL;
-	}
-	if (count < sizeof_patch)
-	{
-/*		  printk("GUS Error: Patch header too short\n");*/
-		  return -EINVAL;
-	}
-	count -= sizeof_patch;
-
-	if (free_sample >= MAX_SAMPLE)
-	{
-/*		  printk("GUS: Sample table full\n");*/
-		  return -ENOSPC;
-	}
-	/*
-	 * Copy the header from user space but ignore the first bytes which have
-	 * been transferred already.
-	 */
-
-	if (copy_from_user(&((char *) &patch)[offs], &(addr)[offs],
-			   sizeof_patch - offs))
-		return -EFAULT;
-
-	if (patch.mode & WAVE_ROM)
-		return -EINVAL;
-	if (gus_mem_size == 0)
-		return -ENOSPC;
-
-	instr = patch.instr_no;
-
-	if (instr < 0 || instr > MAX_PATCH)
-	{
-/*		printk(KERN_ERR "GUS: Invalid patch number %d\n", instr);*/
-		return -EINVAL;
-	}
-	if (count < patch.len)
-	{
-/*		printk(KERN_ERR "GUS Warning: Patch record too short (%d<%d)\n", count, (int) patch.len);*/
-		patch.len = count;
-	}
-	if (patch.len <= 0 || patch.len > gus_mem_size)
-	{
-/*		printk(KERN_ERR "GUS: Invalid sample length %d\n", (int) patch.len);*/
-		return -EINVAL;
-	}
-	if (patch.mode & WAVE_LOOPING)
-	{
-		if (patch.loop_start < 0 || patch.loop_start >= patch.len)
-		{
-/*			printk(KERN_ERR "GUS: Invalid loop start\n");*/
-			return -EINVAL;
-		}
-		if (patch.loop_end < patch.loop_start || patch.loop_end > patch.len)
-		{
-/*			printk(KERN_ERR "GUS: Invalid loop end\n");*/
-			return -EINVAL;
-		}
-	}
-	free_mem_ptr = (free_mem_ptr + 31) & ~31;	/* 32 byte alignment */
-
-	if (patch.mode & WAVE_16_BITS)
-	{
-		/*
-		 * 16 bit samples must fit one 256k bank.
-		 */
-		if (patch.len >= GUS_BANK_SIZE)
-		{
-/*			 printk("GUS: Sample (16 bit) too long %d\n", (int) patch.len);*/
-			return -ENOSPC;
-		}
-		if ((free_mem_ptr / GUS_BANK_SIZE) !=
-			((free_mem_ptr + patch.len) / GUS_BANK_SIZE))
-		{
-			unsigned long   tmp_mem =	
-				/* Align to 256K */
-					((free_mem_ptr / GUS_BANK_SIZE) + 1) * GUS_BANK_SIZE;
-
-			if ((tmp_mem + patch.len) > gus_mem_size)
-				return -ENOSPC;
-
-			free_mem_ptr = tmp_mem;		/* This leaves unusable memory */
-		}
-	}
-	if ((free_mem_ptr + patch.len) > gus_mem_size)
-		return -ENOSPC;
-
-	sample_ptrs[free_sample] = free_mem_ptr;
-
-	/*
-	 * Tremolo is not possible with envelopes
-	 */
-
-	if (patch.mode & WAVE_ENVELOPES)
-		patch.mode &= ~WAVE_TREMOLO;
-
-	if (!(patch.mode & WAVE_FRACTIONS))
-	{
-		  patch.fractions = 0;
-	}
-	memcpy((char *) &samples[free_sample], &patch, sizeof_patch);
-
-	/*
-	 * Link this_one sample to the list of samples for patch 'instr'.
-	 */
-
-	samples[free_sample].key = patch_table[instr];
-	patch_table[instr] = free_sample;
-
-	/*
-	 * Use DMA to transfer the wave data to the DRAM
-	 */
-
-	left = patch.len;
-	src_offs = 0;
-	target = free_mem_ptr;
-
-	while (left)		/* Not completely transferred yet */
-	{
-		blk_sz = audio_devs[gus_devnum]->dmap_out->bytes_in_use;
-		if (blk_sz > left)
-			blk_sz = left;
-
-		/*
-		 * DMA cannot cross bank (256k) boundaries. Check for that.
-		 */
-		 
-		blk_end = target + blk_sz;
-
-		if ((target / GUS_BANK_SIZE) != (blk_end / GUS_BANK_SIZE))
-		{
-			/* Split the block */
-			blk_end &= ~(GUS_BANK_SIZE - 1);
-			blk_sz = blk_end - target;
-		}
-		if (gus_no_dma)
-		{
-			/*
-			 * For some reason the DMA is not possible. We have to use PIO.
-			 */
-			long i;
-			unsigned char data;
-
-			for (i = 0; i < blk_sz; i++)
-			{
-				get_user(*(unsigned char *) &data, (unsigned char __user *) &((addr)[sizeof_patch + i]));
-				if (patch.mode & WAVE_UNSIGNED)
-					if (!(patch.mode & WAVE_16_BITS) || (i & 0x01))
-						data ^= 0x80;	/* Convert to signed */
-				gus_poke(target + i, data);
-			}
-		}
-		else
-		{
-			unsigned long address, hold_address;
-			unsigned char dma_command;
-			unsigned long flags;
-
-			if (audio_devs[gus_devnum]->dmap_out->raw_buf == NULL)
-			{
-				printk(KERN_ERR "GUS: DMA buffer == NULL\n");
-				return -ENOSPC;
-			}
-			/*
-			 * OK, move now. First in and then out.
-			 */
-
-			if (copy_from_user(audio_devs[gus_devnum]->dmap_out->raw_buf,
-					   &(addr)[sizeof_patch + src_offs],
-					   blk_sz))
-				return -EFAULT;
-
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_write8(0x41, 0);	/* Disable GF1 DMA */
-			DMAbuf_start_dma(gus_devnum, audio_devs[gus_devnum]->dmap_out->raw_buf_phys,
-				blk_sz, DMA_MODE_WRITE);
-
-			/*
-			 * Set the DRAM address for the wave data
-			 */
-
-			if (iw_mode)
-			{
-				/* Different address translation in enhanced mode */
-
-				unsigned char   hi;
-
-				if (gus_dma > 4)
-					address = target >> 1;	/* Convert to 16 bit word address */
-				else
-					address = target;
-
-				hi = (unsigned char) ((address >> 16) & 0xf0);
-				hi += (unsigned char) (address & 0x0f);
-
-				gus_write16(0x42, (address >> 4) & 0xffff);	/* DMA address (low) */
-				gus_write8(0x50, hi);
-			}
-			else
-			{
-				address = target;
-				if (audio_devs[gus_devnum]->dmap_out->dma > 3)
-				{
-					hold_address = address;
-					address = address >> 1;
-					address &= 0x0001ffffL;
-					address |= (hold_address & 0x000c0000L);
-				}
-				gus_write16(0x42, (address >> 4) & 0xffff);	/* DRAM DMA address */
-			}
-
-			/*
-			 * Start the DMA transfer
-			 */
-
-			dma_command = 0x21;		/* IRQ enable, DMA start */
-			if (patch.mode & WAVE_UNSIGNED)
-				dma_command |= 0x80;	/* Invert MSB */
-			if (patch.mode & WAVE_16_BITS)
-				dma_command |= 0x40;	/* 16 bit _DATA_ */
-			if (audio_devs[gus_devnum]->dmap_out->dma > 3)
-				dma_command |= 0x04;	/* 16 bit DMA _channel_ */
-			
-			/*
-			 * Sleep here until the DRAM DMA done interrupt is served
-			 */
-			active_device = GUS_DEV_WAVE;
-			gus_write8(0x41, dma_command);	/* Lets go luteet (=bugs) */
-
-			spin_unlock_irqrestore(&gus_lock,flags); /* opens a race */
-			if (!interruptible_sleep_on_timeout(&dram_sleeper, HZ))
-				printk("GUS: DMA Transfer timed out\n");
-		}
-
-		/*
-		 * Now the next part
-		 */
-
-		left -= blk_sz;
-		src_offs += blk_sz;
-		target += blk_sz;
-
-		gus_write8(0x41, 0);	/* Stop DMA */
-	}
-
-	free_mem_ptr += patch.len;
-	free_sample++;
-	return 0;
-}
-
-static void guswave_hw_control(int dev, unsigned char *event_rec)
-{
-	int voice, cmd;
-	unsigned short p1, p2;
-	unsigned int plong;
-	unsigned long flags;
-
-	cmd = event_rec[2];
-	voice = event_rec[3];
-	p1 = *(unsigned short *) &event_rec[4];
-	p2 = *(unsigned short *) &event_rec[6];
-	plong = *(unsigned int *) &event_rec[4];
-
-	if ((voices[voice].volume_irq_mode == VMODE_START_NOTE) &&
-		(cmd != _GUS_VOICESAMPLE) && (cmd != _GUS_VOICE_POS))
-		do_volume_irq(voice);
-
-	switch (cmd)
-	{
-		case _GUS_NUMVOICES:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_select_max_voices(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICESAMPLE:
-			guswave_set_instr(dev, voice, p1);
-			break;
-
-		case _GUS_VOICEON:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			p1 &= ~0x20;	/* Don't allow interrupts */
-			gus_voice_on(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICEOFF:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_voice_off();
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICEFADE:
-			gus_voice_fade(voice);
-			break;
-
-		case _GUS_VOICEMODE:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			p1 &= ~0x20;	/* Don't allow interrupts */
-			gus_voice_mode(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICEBALA:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_voice_balance(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICEFREQ:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_voice_freq(plong);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICEVOL:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_voice_volume(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOICEVOL2:	/* Just update the software voice level */
-			voices[voice].initial_volume = voices[voice].current_volume = p1;
-			break;
-
-		case _GUS_RAMPRANGE:
-			if (voices[voice].mode & WAVE_ENVELOPES)
-				break;	/* NO-NO */
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_ramp_range(p1, p2);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_RAMPRATE:
-			if (voices[voice].mode & WAVE_ENVELOPES)
-				break;	/* NJET-NJET */
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_ramp_rate(p1, p2);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_RAMPMODE:
-			if (voices[voice].mode & WAVE_ENVELOPES)
-				break;	/* NO-NO */
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			p1 &= ~0x20;	/* Don't allow interrupts */
-			gus_ramp_mode(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_RAMPON:
-			if (voices[voice].mode & WAVE_ENVELOPES)
-				break;	/* EI-EI */
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			p1 &= ~0x20;	/* Don't allow interrupts */
-			gus_rampon(p1);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_RAMPOFF:
-			if (voices[voice].mode & WAVE_ENVELOPES)
-				break;	/* NEJ-NEJ */
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_rampoff();
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		case _GUS_VOLUME_SCALE:
-			volume_base = p1;
-			volume_scale = p2;
-			break;
-
-		case _GUS_VOICE_POS:
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_set_voice_pos(voice, plong);
-			spin_unlock_irqrestore(&gus_lock,flags);
-			break;
-
-		default:
-			break;
-	}
-}
-
-static int gus_audio_set_speed(int speed)
-{
-	if (speed <= 0)
-		speed = gus_audio_speed;
-
-	if (speed < 4000)
-		speed = 4000;
-
-	if (speed > 44100)
-		speed = 44100;
-
-	gus_audio_speed = speed;
-
-	if (only_read_access)
-	{
-		/* Compute nearest valid recording speed  and return it */
-
-		/* speed = (9878400 / (gus_audio_speed + 2)) / 16; */
-		speed = (((9878400 + gus_audio_speed / 2) / (gus_audio_speed + 2)) + 8) / 16;
-		speed = (9878400 / (speed * 16)) - 2;
-	}
-	return speed;
-}
-
-static int gus_audio_set_channels(int channels)
-{
-	if (!channels)
-		return gus_audio_channels;
-	if (channels > 2)
-		channels = 2;
-	if (channels < 1)
-		channels = 1;
-	gus_audio_channels = channels;
-	return channels;
-}
-
-static int gus_audio_set_bits(int bits)
-{
-	if (!bits)
-		return gus_audio_bits;
-
-	if (bits != 8 && bits != 16)
-		bits = 8;
-
-	if (only_8_bits)
-		bits = 8;
-
-	gus_audio_bits = bits;
-	return bits;
-}
-
-static int gus_audio_ioctl(int dev, unsigned int cmd, void __user *arg)
-{
-	int val;
-
-	switch (cmd) 
-	{
-		case SOUND_PCM_WRITE_RATE:
-			if (get_user(val, (int __user*)arg))
-				return -EFAULT;
-			val = gus_audio_set_speed(val);
-			break;
-
-		case SOUND_PCM_READ_RATE:
-			val = gus_audio_speed;
-			break;
-
-		case SNDCTL_DSP_STEREO:
-			if (get_user(val, (int __user *)arg))
-				return -EFAULT;
-			val = gus_audio_set_channels(val + 1) - 1;
-			break;
-
-		case SOUND_PCM_WRITE_CHANNELS:
-			if (get_user(val, (int __user *)arg))
-				return -EFAULT;
-			val = gus_audio_set_channels(val);
-			break;
-
-		case SOUND_PCM_READ_CHANNELS:
-			val = gus_audio_channels;
-			break;
-		
-		case SNDCTL_DSP_SETFMT:
-			if (get_user(val, (int __user *)arg))
-				return -EFAULT;
-			val = gus_audio_set_bits(val);
-			break;
-		
-		case SOUND_PCM_READ_BITS:
-			val = gus_audio_bits;
-			break;
-		
-		case SOUND_PCM_WRITE_FILTER:		/* NOT POSSIBLE */
-		case SOUND_PCM_READ_FILTER:
-			val = -EINVAL;
-			break;
-		default:
-			return -EINVAL;
-	}
-	return put_user(val, (int __user *)arg);
-}
-
-static void gus_audio_reset(int dev)
-{
-	if (recording_active)
-	{
-		gus_write8(0x49, 0x00);	/* Halt recording */
-		set_input_volumes();
-	}
-}
-
-static int saved_iw_mode;	/* A hack hack hack */
-
-static int gus_audio_open(int dev, int mode)
-{
-	if (gus_busy)
-		return -EBUSY;
-
-	if (gus_pnp_flag && mode & OPEN_READ)
-	{
-/*		printk(KERN_ERR "GUS: Audio device #%d is playback only.\n", dev);*/
-		return -EIO;
-	}
-	gus_initialize();
-
-	gus_busy = 1;
-	active_device = 0;
-
-	saved_iw_mode = iw_mode;
-	if (iw_mode)
-	{
-		/* There are some problems with audio in enhanced mode so disable it */
-		gus_write8(0x19, gus_read8(0x19) & ~0x01);	/* Disable enhanced mode */
-		iw_mode = 0;
-	}
-
-	gus_reset();
-	reset_sample_memory();
-	gus_select_max_voices(14);
-
-	pcm_active = 0;
-	dma_active = 0;
-	pcm_opened = 1;
-	if (mode & OPEN_READ)
-	{
-		recording_active = 1;
-		set_input_volumes();
-	}
-	only_read_access = !(mode & OPEN_WRITE);
-	only_8_bits = mode & OPEN_READ;
-	if (only_8_bits)
-		audio_devs[dev]->format_mask = AFMT_U8;
-	else
-		audio_devs[dev]->format_mask = AFMT_U8 | AFMT_S16_LE;
-
-	return 0;
-}
-
-static void gus_audio_close(int dev)
-{
-	iw_mode = saved_iw_mode;
-	gus_reset();
-	gus_busy = 0;
-	pcm_opened = 0;
-	active_device = 0;
-
-	if (recording_active)
-	{
-		gus_write8(0x49, 0x00);	/* Halt recording */
-		set_input_volumes();
-	}
-	recording_active = 0;
-}
-
-static void gus_audio_update_volume(void)
-{
-	unsigned long flags;
-	int voice;
-
-	if (pcm_active && pcm_opened)
-		for (voice = 0; voice < gus_audio_channels; voice++)
-		{
-			spin_lock_irqsave(&gus_lock,flags);
-			gus_select_voice(voice);
-			gus_rampoff();
-			gus_voice_volume(1530 + (25 * gus_pcm_volume));
-			gus_ramp_range(65, 1530 + (25 * gus_pcm_volume));
-			spin_unlock_irqrestore(&gus_lock,flags);
-		}
-}
-
-static void play_next_pcm_block(void)
-{
-	unsigned long flags;
-	int speed = gus_audio_speed;
-	int this_one, is16bits, chn;
-	unsigned long dram_loc;
-	unsigned char mode[2], ramp_mode[2];
-
-	if (!pcm_qlen)
-		return;
-
-	this_one = pcm_head;
-
-	for (chn = 0; chn < gus_audio_channels; chn++)
-	{
-		mode[chn] = 0x00;
-		ramp_mode[chn] = 0x03;	/* Ramping and rollover off */
-
-		if (chn == 0)
-		{
-			mode[chn] |= 0x20;	/* Loop IRQ */
-			voices[chn].loop_irq_mode = LMODE_PCM;
-		}
-		if (gus_audio_bits != 8)
-		{
-			is16bits = 1;
-			mode[chn] |= 0x04;	/* 16 bit data */
-		}
-		else
-			is16bits = 0;
-
-		dram_loc = this_one * pcm_bsize;
-		dram_loc += chn * pcm_banksize;
-
-		if (this_one == (pcm_nblk - 1))	/* Last fragment of the DRAM buffer */
-		{
-			mode[chn] |= 0x08;	/* Enable loop */
-			ramp_mode[chn] = 0x03;	/* Disable rollover bit */
-		}
-		else
-		{
-			if (chn == 0)
-				ramp_mode[chn] = 0x04;	/* Enable rollover bit */
-		}
-		spin_lock_irqsave(&gus_lock,flags);
-		gus_select_voice(chn);
-		gus_voice_freq(speed);
-
-		if (gus_audio_channels == 1)
-			gus_voice_balance(7);		/* mono */
-		else if (chn == 0)
-			gus_voice_balance(0);		/* left */
-		else
-			gus_voice_balance(15);		/* right */
-
-		if (!pcm_active)	/* Playback not already active */
-		{
-			/*
-			 * The playback was not started yet (or there has been a pause).
-			 * Start the voice (again) and ask for a rollover irq at the end of
-			 * this_one block. If this_one one is last of the buffers, use just
-			 * the normal loop with irq.
-			 */
-
-			gus_voice_off();
-			gus_rampoff();
-			gus_voice_volume(1530 + (25 * gus_pcm_volume));
-			gus_ramp_range(65, 1530 + (25 * gus_pcm_volume));
-
-			gus_write_addr(0x0a, chn * pcm_banksize, 0, is16bits);	/* Starting position */
-			gus_write_addr(0x02, chn * pcm_banksize, 0, is16bits);	/* Loop start */
-
-			if (chn != 0)
-				gus_write_addr(0x04, pcm_banksize + (pcm_bsize * pcm_nblk) - 1,
-						   0, is16bits);	/* Loop end location */
-		}
-		if (chn == 0)
-			gus_write_addr(0x04, dram_loc + pcm_bsize - 1,
-					 0, is16bits);	/* Loop end location */
-		else
-			mode[chn] |= 0x08;	/* Enable looping */
-		spin_unlock_irqrestore(&gus_lock,flags);
-	}
-	for (chn = 0; chn < gus_audio_channels; chn++)
-	{
-		spin_lock_irqsave(&gus_lock,flags);
-		gus_select_voice(chn);
-		gus_write8(0x0d, ramp_mode[chn]);
-		if (iw_mode)
-			gus_write8(0x15, 0x00);	/* Reset voice deactivate bit of SMSI */
-		gus_voice_on(mode[chn]);
-		spin_unlock_irqrestore(&gus_lock,flags);
-	}
-	pcm_active = 1;
-}
-
-static void gus_transfer_output_block(int dev, unsigned long buf,
-			  int total_count, int intrflag, int chn)
-{
-	/*
-	 * This routine transfers one block of audio data to the DRAM. In mono mode
-	 * it's called just once. When in stereo mode, this_one routine is called
-	 * once for both channels.
-	 *
-	 * The left/mono channel data is transferred to the beginning of dram and the
-	 * right data to the area pointed by gus_page_size.
-	 */
-
-	int this_one, count;
-	unsigned long flags;
-	unsigned char dma_command;
-	unsigned long address, hold_address;
-
-	spin_lock_irqsave(&gus_lock,flags);
-
-	count = total_count / gus_audio_channels;
-
-	if (chn == 0)
-	{
-		if (pcm_qlen >= pcm_nblk)
-			printk(KERN_WARNING "GUS Warning: PCM buffers out of sync\n");
-
-		this_one = pcm_current_block = pcm_tail;
-		pcm_qlen++;
-		pcm_tail = (pcm_tail + 1) % pcm_nblk;
-		pcm_datasize[this_one] = count;
-	}
-	else
-		this_one = pcm_current_block;
-
-	gus_write8(0x41, 0);	/* Disable GF1 DMA */
-	DMAbuf_start_dma(dev, buf + (chn * count), count, DMA_MODE_WRITE);
-
-	address = this_one * pcm_bsize;
-	address += chn * pcm_banksize;
-
-	if (audio_devs[dev]->dmap_out->dma > 3)
-	{
-		hold_address = address;
-		address = address >> 1;
-		address &= 0x0001ffffL;
-		address |= (hold_address & 0x000c0000L);
-	}
-	gus_write16(0x42, (address >> 4) & 0xffff);	/* DRAM DMA address */
-
-	dma_command = 0x21;	/* IRQ enable, DMA start */
-
-	if (gus_audio_bits != 8)
-		dma_command |= 0x40;	/* 16 bit _DATA_ */
-	else
-		dma_command |= 0x80;	/* Invert MSB */
-
-	if (audio_devs[dev]->dmap_out->dma > 3)
-		dma_command |= 0x04;	/* 16 bit DMA channel */
-
-	gus_write8(0x41, dma_command);	/* Kick start */
-
-	if (chn == (gus_audio_channels - 1))	/* Last channel */
-	{
-		/*
-		 * Last (right or mono) channel data
-		 */
-		dma_active = 1;	/* DMA started. There is a unacknowledged buffer */
-		active_device = GUS_DEV_PCM_DONE;
-		if (!pcm_active && (pcm_qlen > 1 || count < pcm_bsize))
-		{
-			play_next_pcm_block();
-		}
-	}
-	else
-	{
-		/*
-		 * Left channel data. The right channel
-		 * is transferred after DMA interrupt
-		 */
-		active_device = GUS_DEV_PCM_CONTINUE;
-	}
-
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static void gus_uninterleave8(char *buf, int l)
-{
-/* This routine uninterleaves 8 bit stereo output (LRLRLR->LLLRRR) */
-	int i, p = 0, halfsize = l / 2;
-	char *buf2 = buf + halfsize, *src = bounce_buf;
-
-	memcpy(bounce_buf, buf, l);
-
-	for (i = 0; i < halfsize; i++)
-	{
-		buf[i] = src[p++];	/* Left channel */
-		buf2[i] = src[p++];	/* Right channel */
-	}
-}
-
-static void gus_uninterleave16(short *buf, int l)
-{
-/* This routine uninterleaves 16 bit stereo output (LRLRLR->LLLRRR) */
-	int i, p = 0, halfsize = l / 2;
-	short *buf2 = buf + halfsize, *src = (short *) bounce_buf;
-
-	memcpy(bounce_buf, (char *) buf, l * 2);
-
-	for (i = 0; i < halfsize; i++)
-	{
-		buf[i] = src[p++];	/* Left channel */
-		buf2[i] = src[p++];	/* Right channel */
-	}
-}
-
-static void gus_audio_output_block(int dev, unsigned long buf, int total_count,
-		       int intrflag)
-{
-	struct dma_buffparms *dmap = audio_devs[dev]->dmap_out;
-
-	dmap->flags |= DMA_NODMA | DMA_NOTIMEOUT;
-
-	pcm_current_buf = buf;
-	pcm_current_count = total_count;
-	pcm_current_intrflag = intrflag;
-	pcm_current_dev = dev;
-	if (gus_audio_channels == 2)
-	{
-		char *b = dmap->raw_buf + (buf - dmap->raw_buf_phys);
-
-		if (gus_audio_bits == 8)
-			gus_uninterleave8(b, total_count);
-		else
-			gus_uninterleave16((short *) b, total_count / 2);
-	}
-	gus_transfer_output_block(dev, buf, total_count, intrflag, 0);
-}
-
-static void gus_audio_start_input(int dev, unsigned long buf, int count,
-		      int intrflag)
-{
-	unsigned long flags;
-	unsigned char mode;
-
-	spin_lock_irqsave(&gus_lock,flags);
-
-	DMAbuf_start_dma(dev, buf, count, DMA_MODE_READ);
-	mode = 0xa0;		/* DMA IRQ enabled, invert MSB */
-
-	if (audio_devs[dev]->dmap_in->dma > 3)
-		mode |= 0x04;	/* 16 bit DMA channel */
-	if (gus_audio_channels > 1)
-		mode |= 0x02;	/* Stereo */
-	mode |= 0x01;		/* DMA enable */
-
-	gus_write8(0x49, mode);
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static int gus_audio_prepare_for_input(int dev, int bsize, int bcount)
-{
-	unsigned int rate;
-
-	gus_audio_bsize = bsize;
-	audio_devs[dev]->dmap_in->flags |= DMA_NODMA;
-	rate = (((9878400 + gus_audio_speed / 2) / (gus_audio_speed + 2)) + 8) / 16;
-
-	gus_write8(0x48, rate & 0xff);	/* Set sampling rate */
-
-	if (gus_audio_bits != 8)
-	{
-/*		printk("GUS Error: 16 bit recording not supported\n");*/
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int gus_audio_prepare_for_output(int dev, int bsize, int bcount)
-{
-	int i;
-
-	long mem_ptr, mem_size;
-
-	audio_devs[dev]->dmap_out->flags |= DMA_NODMA | DMA_NOTIMEOUT;
-	mem_ptr = 0;
-	mem_size = gus_mem_size / gus_audio_channels;
-
-	if (mem_size > (256 * 1024))
-		mem_size = 256 * 1024;
-
-	pcm_bsize = bsize / gus_audio_channels;
-	pcm_head = pcm_tail = pcm_qlen = 0;
-
-	pcm_nblk = 2;		/* MAX_PCM_BUFFERS; */
-	if ((pcm_bsize * pcm_nblk) > mem_size)
-		pcm_nblk = mem_size / pcm_bsize;
-
-	for (i = 0; i < pcm_nblk; i++)
-		pcm_datasize[i] = 0;
-
-	pcm_banksize = pcm_nblk * pcm_bsize;
-
-	if (gus_audio_bits != 8 && pcm_banksize == (256 * 1024))
-		pcm_nblk--;
-	gus_write8(0x41, 0);	/* Disable GF1 DMA */
-	return 0;
-}
-
-static int gus_local_qlen(int dev)
-{
-	return pcm_qlen;
-}
-
-
-static struct audio_driver gus_audio_driver =
-{
-	.owner			= THIS_MODULE,
-	.open			= gus_audio_open,
-	.close			= gus_audio_close,
-	.output_block		= gus_audio_output_block,
-	.start_input		= gus_audio_start_input,
-	.ioctl			= gus_audio_ioctl,
-	.prepare_for_input	= gus_audio_prepare_for_input,
-	.prepare_for_output	= gus_audio_prepare_for_output,
-	.halt_io		= gus_audio_reset,
-	.local_qlen		= gus_local_qlen,
-};
-
-static void guswave_setup_voice(int dev, int voice, int chn)
-{
-	struct channel_info *info = &synth_devs[dev]->chn_info[chn];
-
-	guswave_set_instr(dev, voice, info->pgm_num);
-	voices[voice].expression_vol = info->controllers[CTL_EXPRESSION];	/* Just MSB */
-	voices[voice].main_vol = (info->controllers[CTL_MAIN_VOLUME] * 100) / (unsigned) 128;
-	voices[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;
-	voices[voice].bender = 0;
-	voices[voice].bender_range = info->bender_range;
-
-	if (chn == 9)
-		voices[voice].fixed_pitch = 1;
-}
-
-static void guswave_bender(int dev, int voice, int value)
-{
-	int freq;
-	unsigned long   flags;
-
-	voices[voice].bender = value - 8192;
-	freq = compute_finetune(voices[voice].orig_freq, value - 8192, voices[voice].bender_range, 0);
-	voices[voice].current_freq = freq;
-
-	spin_lock_irqsave(&gus_lock,flags);
-	gus_select_voice(voice);
-	gus_voice_freq(freq);
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-static int guswave_alloc(int dev, int chn, int note, struct voice_alloc_info *alloc)
-{
-	int i, p, best = -1, best_time = 0x7fffffff;
-
-	p = alloc->ptr;
-	/*
-	 * First look for a completely stopped voice
-	 */
-
-	for (i = 0; i < alloc->max_voice; i++)
-	{
-		if (alloc->map[p] == 0)
-		{
-			alloc->ptr = p;
-			return p;
-		}
-		if (alloc->alloc_times[p] < best_time)
-		{
-			best = p;
-			best_time = alloc->alloc_times[p];
-		}
-		p = (p + 1) % alloc->max_voice;
-	}
-
-	/*
-	 * Then look for a releasing voice
-	 */
-
-	for (i = 0; i < alloc->max_voice; i++)
-	{
-		if (alloc->map[p] == 0xffff)
-		{
-			alloc->ptr = p;
-			return p;
-		}
-		p = (p + 1) % alloc->max_voice;
-	}
-	if (best >= 0)
-		p = best;
-
-	alloc->ptr = p;
-	return p;
-}
-
-static struct synth_operations guswave_operations =
-{
-	.owner		= THIS_MODULE,
-	.id		= "GUS",
-	.info		= &gus_info,
-	.midi_dev	= 0,
-	.synth_type	= SYNTH_TYPE_SAMPLE,
-	.synth_subtype	= SAMPLE_TYPE_GUS,
-	.open		= guswave_open,
-	.close		= guswave_close,
-	.ioctl		= guswave_ioctl,
-	.kill_note	= guswave_kill_note,
-	.start_note	= guswave_start_note,
-	.set_instr	= guswave_set_instr,
-	.reset		= guswave_reset,
-	.hw_control	= guswave_hw_control,
-	.load_patch	= guswave_load_patch,
-	.aftertouch	= guswave_aftertouch,
-	.controller	= guswave_controller,
-	.panning	= guswave_panning,
-	.volume_method	= guswave_volume_method,
-	.bender		= guswave_bender,
-	.alloc_voice	= guswave_alloc,
-	.setup_voice	= guswave_setup_voice
-};
-
-static void set_input_volumes(void)
-{
-	unsigned long flags;
-	unsigned char mask = 0xff & ~0x06;	/* Just line out enabled */
-
-	if (have_gus_max)	/* Don't disturb GUS MAX */
-		return;
-
-	spin_lock_irqsave(&gus_lock,flags);
-
-	/*
-	 *    Enable channels having vol > 10%
-	 *      Note! bit 0x01 means the line in DISABLED while 0x04 means
-	 *            the mic in ENABLED.
-	 */
-	if (gus_line_vol > 10)
-		mask &= ~0x01;
-	if (gus_mic_vol > 10)
-		mask |= 0x04;
-
-	if (recording_active)
-	{
-		/*
-		 *    Disable channel, if not selected for recording
-		 */
-		if (!(gus_recmask & SOUND_MASK_LINE))
-			mask |= 0x01;
-		if (!(gus_recmask & SOUND_MASK_MIC))
-			mask &= ~0x04;
-	}
-	mix_image &= ~0x07;
-	mix_image |= mask & 0x07;
-	outb((mix_image), u_Mixer);
-
-	spin_unlock_irqrestore(&gus_lock,flags);
-}
-
-#define MIX_DEVS	(SOUND_MASK_MIC|SOUND_MASK_LINE| \
-			 SOUND_MASK_SYNTH|SOUND_MASK_PCM)
-
-int gus_default_mixer_ioctl(int dev, unsigned int cmd, void __user *arg)
-{
-	int vol, val;
-
-	if (((cmd >> 8) & 0xff) != 'M')
-		return -EINVAL;
-
-	if (!access_ok(VERIFY_WRITE, arg, sizeof(int)))
-		return -EFAULT;
-
-	if (_SIOC_DIR(cmd) & _SIOC_WRITE) 
-	{
-		if (__get_user(val, (int __user *) arg))
-			return -EFAULT;
-
-		switch (cmd & 0xff) 
-		{
-			case SOUND_MIXER_RECSRC:
-				gus_recmask = val & MIX_DEVS;
-				if (!(gus_recmask & (SOUND_MASK_MIC | SOUND_MASK_LINE)))
-					gus_recmask = SOUND_MASK_MIC;
-				/* Note! Input volumes are updated during next open for recording */
-				val = gus_recmask;
-				break;
-
-			case SOUND_MIXER_MIC:
-				vol = val & 0xff;
-				if (vol < 0)
-					vol = 0;
-				if (vol > 100)
-					vol = 100;
-				gus_mic_vol = vol;
-				set_input_volumes();
-				val = vol | (vol << 8);
-				break;
-				
-			case SOUND_MIXER_LINE:
-				vol = val & 0xff;
-				if (vol < 0)
-					vol = 0;
-				if (vol > 100)
-					vol = 100;
-				gus_line_vol = vol;
-				set_input_volumes();
-				val = vol | (vol << 8);
-				break;
-
-			case SOUND_MIXER_PCM:
-				gus_pcm_volume = val & 0xff;
-				if (gus_pcm_volume < 0)
-					gus_pcm_volume = 0;
-				if (gus_pcm_volume > 100)
-					gus_pcm_volume = 100;
-				gus_audio_update_volume();
-				val = gus_pcm_volume | (gus_pcm_volume << 8);
-				break;
-
-			case SOUND_MIXER_SYNTH:
-				gus_wave_volume = val & 0xff;
-				if (gus_wave_volume < 0)
-					gus_wave_volume = 0;
-				if (gus_wave_volume > 100)
-					gus_wave_volume = 100;
-				if (active_device == GUS_DEV_WAVE) 
-				{
-					int voice;
-					for (voice = 0; voice < nr_voices; voice++)
-					dynamic_volume_change(voice);	/* Apply the new vol */
-				}
-				val = gus_wave_volume | (gus_wave_volume << 8);
-				break;
-
-			default:
-				return -EINVAL;
-		}
-	}
-	else
-	{
-		switch (cmd & 0xff) 
-		{
-			/*
-			 * Return parameters
-			 */
-			case SOUND_MIXER_RECSRC:
-				val = gus_recmask;
-				break;
-					
-			case SOUND_MIXER_DEVMASK:
-				val = MIX_DEVS;
-				break;
-
-			case SOUND_MIXER_STEREODEVS:
-				val = 0;
-				break;
-
-			case SOUND_MIXER_RECMASK:
-				val = SOUND_MASK_MIC | SOUND_MASK_LINE;
-				break;
-
-			case SOUND_MIXER_CAPS:
-				val = 0;
-				break;
-
-			case SOUND_MIXER_MIC:
-				val = gus_mic_vol | (gus_mic_vol << 8);
-				break;
-
-			case SOUND_MIXER_LINE:
-				val = gus_line_vol | (gus_line_vol << 8);
-				break;
-
-			case SOUND_MIXER_PCM:
-				val = gus_pcm_volume | (gus_pcm_volume << 8);
-				break;
-
-			case SOUND_MIXER_SYNTH:
-				val = gus_wave_volume | (gus_wave_volume << 8);
-				break;
-
-			default:
-				return -EINVAL;
-		}
-	}
-	return __put_user(val, (int __user *)arg);
-}
-
-static struct mixer_operations gus_mixer_operations =
-{
-	.owner	= THIS_MODULE,
-	.id	= "GUS",
-	.name	= "Gravis Ultrasound",
-	.ioctl	= gus_default_mixer_ioctl
-};
-
-static int __init gus_default_mixer_init(void)
-{
-	int n;
-
-	if ((n = sound_alloc_mixerdev()) != -1)
-	{	
-		/*
-		 * Don't install if there is another
-		 * mixer
-		 */
-		mixer_devs[n] = &gus_mixer_operations;
-	}
-	if (have_gus_max)
-	{
-		/*
-		 *  Enable all mixer channels on the GF1 side. Otherwise recording will
-		 *  not be possible using GUS MAX.
-		 */
-		mix_image &= ~0x07;
-		mix_image |= 0x04;	/* All channels enabled */
-		outb((mix_image), u_Mixer);
-	}
-	return n;
-}
-
-void __init gus_wave_init(struct address_info *hw_config)
-{
-	unsigned long flags;
-	unsigned char val;
-	char *model_num = "2.4";
-	char tmp[64];
-	int gus_type = 0x24;	/* 2.4 */
-
-	int irq = hw_config->irq, dma = hw_config->dma, dma2 = hw_config->dma2;
-	int sdev;
-
-	hw_config->slots[0] = -1;	/* No wave */
-	hw_config->slots[1] = -1;	/* No ad1848 */
-	hw_config->slots[4] = -1;	/* No audio */
-	hw_config->slots[5] = -1;	/* No mixer */
-
-	if (!gus_pnp_flag)
-	{
-		if (irq < 0 || irq > 15)
-		{
-			printk(KERN_ERR "ERROR! Invalid IRQ#%d. GUS Disabled", irq);
-			return;
-		}
-	}
-	
-	if (dma < 0 || dma > 7 || dma == 4)
-	{
-		printk(KERN_ERR "ERROR! Invalid DMA#%d. GUS Disabled", dma);
-		return;
-	}
-	gus_irq = irq;
-	gus_dma = dma;
-	gus_dma2 = dma2;
-	gus_hw_config = hw_config;
-
-	if (gus_dma2 == -1)
-		gus_dma2 = dma;
-
-	/*
-	 * Try to identify the GUS model.
-	 *
-	 *  Versions < 3.6 don't have the digital ASIC. Try to probe it first.
-	 */
-
-	spin_lock_irqsave(&gus_lock,flags);
-	outb((0x20), gus_base + 0x0f);
-	val = inb(gus_base + 0x0f);
-	spin_unlock_irqrestore(&gus_lock,flags);
-
-	if (gus_pnp_flag || (val != 0xff && (val & 0x06)))	/* Should be 0x02?? */
-	{
-		int             ad_flags = 0;
-
-		if (gus_pnp_flag)
-			ad_flags = 0x12345678;	/* Interwave "magic" */
-		/*
-		 * It has the digital ASIC so the card is at least v3.4.
-		 * Next try to detect the true model.
-		 */
-
-		if (gus_pnp_flag)	/* Hack hack hack */
-			val = 10;
-		else
-			val = inb(u_MixSelect);
-
-		/*
-		 * Value 255 means pre-3.7 which don't have mixer.
-		 * Values 5 thru 9 mean v3.7 which has a ICS2101 mixer.
-		 * 10 and above is GUS MAX which has the CS4231 codec/mixer.
-		 *
-		 */
-
-		if (val == 255 || val < 5)
-		{
-			model_num = "3.4";
-			gus_type = 0x34;
-		}
-		else if (val < 10)
-		{
-			model_num = "3.7";
-			gus_type = 0x37;
-			mixer_type = ICS2101;
-			request_region(u_MixSelect, 1, "GUS mixer");
-		}
-		else
-		{
-			struct resource *ports;
-			ports = request_region(gus_base + 0x10c, 4, "ad1848");
-			model_num = "MAX";
-			gus_type = 0x40;
-			mixer_type = CS4231;
-#ifdef CONFIG_SOUND_GUSMAX
-			{
-				unsigned char   max_config = 0x40;	/* Codec enable */
-
-				if (gus_dma2 == -1)
-					gus_dma2 = gus_dma;
-
-				if (gus_dma > 3)
-					max_config |= 0x10;		/* 16 bit capture DMA */
-
-				if (gus_dma2 > 3)
-					max_config |= 0x20;		/* 16 bit playback DMA */
-
-				max_config |= (gus_base >> 4) & 0x0f;	/* Extract the X from 2X0 */
-
-				outb((max_config), gus_base + 0x106);	/* UltraMax control */
-			}
-
-			if (!ports)
-				goto no_cs4231;
-
-			if (ad1848_detect(ports, &ad_flags, hw_config->osp))
-			{
-				char           *name = "GUS MAX";
-				int             old_num_mixers = num_mixers;
-
-				if (gus_pnp_flag)
-					name = "GUS PnP";
-
-				gus_mic_vol = gus_line_vol = gus_pcm_volume = 100;
-				gus_wave_volume = 90;
-				have_gus_max = 1;
-				if (hw_config->name)
-					name = hw_config->name;
-
-				hw_config->slots[1] = ad1848_init(name, ports,
-							-irq, gus_dma2,	/* Playback DMA */
-							gus_dma,	/* Capture DMA */
-							1,		/* Share DMA channels with GF1 */
-							hw_config->osp,
-							THIS_MODULE);
-
-				if (num_mixers > old_num_mixers)
-				{
-					/* GUS has it's own mixer map */
-					AD1848_REROUTE(SOUND_MIXER_LINE1, SOUND_MIXER_SYNTH);
-					AD1848_REROUTE(SOUND_MIXER_LINE2, SOUND_MIXER_CD);
-					AD1848_REROUTE(SOUND_MIXER_LINE3, SOUND_MIXER_LINE);
-				}
-			}
-			else {
-				release_region(gus_base + 0x10c, 4);
-			no_cs4231:
-				printk(KERN_WARNING "GUS: No CS4231 ??");
-			}
-#else
-			printk(KERN_ERR "GUS MAX found, but not compiled in\n");
-#endif
-		}
-	}
-	else
-	{
-		/*
-		 * ASIC not detected so the card must be 2.2 or 2.4.
-		 * There could still be the 16-bit/mixer daughter card.
-		 */
-	}
-
-	if (hw_config->name)
-		snprintf(tmp, sizeof(tmp), "%s (%dk)", hw_config->name,
-			 (int) gus_mem_size / 1024);
-	else if (gus_pnp_flag)
-		snprintf(tmp, sizeof(tmp), "Gravis UltraSound PnP (%dk)",
-			 (int) gus_mem_size / 1024);
-	else
-		snprintf(tmp, sizeof(tmp), "Gravis UltraSound %s (%dk)", model_num,
-			 (int) gus_mem_size / 1024);
-
-
-	samples = (struct patch_info *)vmalloc((MAX_SAMPLE + 1) * sizeof(*samples));
-	if (samples == NULL)
-	{
-		printk(KERN_WARNING "gus_init: Cant allocate memory for instrument tables\n");
-		return;
-	}
-	conf_printf(tmp, hw_config);
-	strlcpy(gus_info.name, tmp, sizeof(gus_info.name));
-
-	if ((sdev = sound_alloc_synthdev()) == -1)
-		printk(KERN_WARNING "gus_init: Too many synthesizers\n");
-	else
-	{
-		voice_alloc = &guswave_operations.alloc;
-		if (iw_mode)
-			guswave_operations.id = "IWAVE";
-		hw_config->slots[0] = sdev;
-		synth_devs[sdev] = &guswave_operations;
-		sequencer_init();
-		gus_tmr_install(gus_base + 8);
-	}
-
-	reset_sample_memory();
-
-	gus_initialize();
-	
-	if ((gus_mem_size > 0) && !gus_no_wave_dma)
-	{
-		hw_config->slots[4] = -1;
-		if ((gus_devnum = sound_install_audiodrv(AUDIO_DRIVER_VERSION,
-					"Ultrasound",
-					&gus_audio_driver,
-					sizeof(struct audio_driver),
-					NEEDS_RESTART |
-		                   	((!iw_mode && dma2 != dma && dma2 != -1) ?
-						DMA_DUPLEX : 0),
-					AFMT_U8 | AFMT_S16_LE,
-					NULL, dma, dma2)) < 0)
-		{
-			return;
-		}
-
-		hw_config->slots[4] = gus_devnum;
-		audio_devs[gus_devnum]->min_fragment = 9;	/* 512k */
-		audio_devs[gus_devnum]->max_fragment = 11;	/* 8k (must match size of bounce_buf */
-		audio_devs[gus_devnum]->mixer_dev = -1;	/* Next mixer# */
-		audio_devs[gus_devnum]->flags |= DMA_HARDSTOP;
-	}
-	
-	/*
-	 *  Mixer dependent initialization.
-	 */
-
-	switch (mixer_type)
-	{
-		case ICS2101:
-			gus_mic_vol = gus_line_vol = gus_pcm_volume = 100;
-			gus_wave_volume = 90;
-			request_region(u_MixSelect, 1, "GUS mixer");
-			hw_config->slots[5] = ics2101_mixer_init();
-			audio_devs[gus_devnum]->mixer_dev = hw_config->slots[5];	/* Next mixer# */
-			return;
-
-		case CS4231:
-			/* Initialized elsewhere (ad1848.c) */
-		default:
-			hw_config->slots[5] = gus_default_mixer_init();
-			audio_devs[gus_devnum]->mixer_dev = hw_config->slots[5];	/* Next mixer# */
-			return;
-	}
-}
-
-void __exit gus_wave_unload(struct address_info *hw_config)
-{
-#ifdef CONFIG_SOUND_GUSMAX
-	if (have_gus_max)
-	{
-		ad1848_unload(gus_base + 0x10c,
-				-gus_irq,
-				gus_dma2,	/* Playback DMA */
-				gus_dma,	/* Capture DMA */
-				1);	/* Share DMA channels with GF1 */
-	}
-#endif
-
-	if (mixer_type == ICS2101)
-	{
-		release_region(u_MixSelect, 1);
-	}
-	if (hw_config->slots[0] != -1)
-		sound_unload_synthdev(hw_config->slots[0]);
-	if (hw_config->slots[1] != -1)
-		sound_unload_audiodev(hw_config->slots[1]);
-	if (hw_config->slots[2] != -1)
-		sound_unload_mididev(hw_config->slots[2]);
-	if (hw_config->slots[4] != -1)
-		sound_unload_audiodev(hw_config->slots[4]);
-	if (hw_config->slots[5] != -1)
-		sound_unload_mixerdev(hw_config->slots[5]);
-	
-	vfree(samples);
-	samples=NULL;
-}
-/* called in interrupt context */
-static void do_loop_irq(int voice)
-{
-	unsigned char   tmp;
-	int             mode, parm;
-
-	spin_lock(&gus_lock);
-	gus_select_voice(voice);
-
-	tmp = gus_read8(0x00);
-	tmp &= ~0x20;		/*
-				 * Disable wave IRQ for this_one voice
-				 */
-	gus_write8(0x00, tmp);
-
-	if (tmp & 0x03)		/* Voice stopped */
-		voice_alloc->map[voice] = 0;
-
-	mode = voices[voice].loop_irq_mode;
-	voices[voice].loop_irq_mode = 0;
-	parm = voices[voice].loop_irq_parm;
-
-	switch (mode)
-	{
-		case LMODE_FINISH:	/*
-					 * Final loop finished, shoot volume down
-					 */
-
-			if ((int) (gus_read16(0x09) >> 4) < 100)	/*
-									 * Get current volume
-									 */
-			{
-				gus_voice_off();
-				gus_rampoff();
-				gus_voice_init(voice);
-				break;
-			}
-			gus_ramp_range(65, 4065);
-			gus_ramp_rate(0, 63);		/*
-							 * Fastest possible rate
-							 */
-			gus_rampon(0x20 | 0x40);	/*
-							 * Ramp down, once, irq
-							 */
-			voices[voice].volume_irq_mode = VMODE_HALT;
-			break;
-
-		case LMODE_PCM_STOP:
-			pcm_active = 0;	/* Signal to the play_next_pcm_block routine */
-		case LMODE_PCM:
-		{
-			pcm_qlen--;
-			pcm_head = (pcm_head + 1) % pcm_nblk;
-			if (pcm_qlen && pcm_active)
-			{
-				play_next_pcm_block();
-			}
-			else
-			{
-				/* Underrun. Just stop the voice */
-				gus_select_voice(0);	/* Left channel */
-				gus_voice_off();
-				gus_rampoff();
-				gus_select_voice(1);	/* Right channel */
-				gus_voice_off();
-				gus_rampoff();
-				pcm_active = 0;
-			}
-
-			/*
-			 * If the queue was full before this interrupt, the DMA transfer was
-			 * suspended. Let it continue now.
-			 */
-			
-			if (audio_devs[gus_devnum]->dmap_out->qlen > 0)
-				DMAbuf_outputintr(gus_devnum, 0);
-		}
-		break;
-
-		default:
-			break;
-	}
-	spin_unlock(&gus_lock);
-}
-
-static void do_volume_irq(int voice)
-{
-	unsigned char tmp;
-	int mode, parm;
-	unsigned long flags;
-
-	spin_lock_irqsave(&gus_lock,flags);
-
-	gus_select_voice(voice);
-	tmp = gus_read8(0x0d);
-	tmp &= ~0x20;		/*
-				 * Disable volume ramp IRQ
-				 */
-	gus_write8(0x0d, tmp);
-
-	mode = voices[voice].volume_irq_mode;
-	voices[voice].volume_irq_mode = 0;
-	parm = voices[voice].volume_irq_parm;
-
-	switch (mode)
-	{
-		case VMODE_HALT:	/* Decay phase finished */
-			if (iw_mode)
-				gus_write8(0x15, 0x02);	/* Set voice deactivate bit of SMSI */
-			spin_unlock_irqrestore(&gus_lock,flags);
-			gus_voice_init(voice);
-			break;
-
-		case VMODE_ENVELOPE:
-			gus_rampoff();
-			spin_unlock_irqrestore(&gus_lock,flags);
-			step_envelope(voice);
-			break;
-
-		case VMODE_START_NOTE:
-			spin_unlock_irqrestore(&gus_lock,flags);
-			guswave_start_note2(voices[voice].dev_pending, voice,
-				      voices[voice].note_pending, voices[voice].volume_pending);
-			if (voices[voice].kill_pending)
-				guswave_kill_note(voices[voice].dev_pending, voice,
-					  voices[voice].note_pending, 0);
-
-			if (voices[voice].sample_pending >= 0)
-			{
-				guswave_set_instr(voices[voice].dev_pending, voice,
-					voices[voice].sample_pending);
-				voices[voice].sample_pending = -1;
-			}
-			break;
-
-		default:
-			spin_unlock_irqrestore(&gus_lock,flags);
-	}
-}
-/* called in irq context */
-void gus_voice_irq(void)
-{
-	unsigned long wave_ignore = 0, volume_ignore = 0;
-	unsigned long voice_bit;
-
-	unsigned char src, voice;
-
-	while (1)
-	{
-		src = gus_read8(0x0f);	/*
-					 * Get source info
-					 */
-		voice = src & 0x1f;
-		src &= 0xc0;
-
-		if (src == (0x80 | 0x40))
-			return;	/*
-				 * No interrupt
-				 */
-
-		voice_bit = 1 << voice;
-
-		if (!(src & 0x80))	/*
-					 * Wave IRQ pending
-					 */
-			if (!(wave_ignore & voice_bit) && (int) voice < nr_voices)	/*
-											 * Not done
-											 * yet
-											 */
-			{
-				wave_ignore |= voice_bit;
-				do_loop_irq(voice);
-			}
-		if (!(src & 0x40))	/*
-					 * Volume IRQ pending
-					 */
-			if (!(volume_ignore & voice_bit) && (int) voice < nr_voices)	/*
-											   * Not done
-											   * yet
-											 */
-			{
-				volume_ignore |= voice_bit;
-				do_volume_irq(voice);
-			}
-	}
-}
-
-void guswave_dma_irq(void)
-{
-	unsigned char   status;
-
-	status = gus_look8(0x41);	/* Get DMA IRQ Status */
-	if (status & 0x40)	/* DMA interrupt pending */
-		switch (active_device)
-		{
-			case GUS_DEV_WAVE:
-				wake_up(&dram_sleeper);
-				break;
-
-			case GUS_DEV_PCM_CONTINUE:	/* Left channel data transferred */
-				gus_write8(0x41, 0);	/* Disable GF1 DMA */
-				gus_transfer_output_block(pcm_current_dev, pcm_current_buf,
-						pcm_current_count,
-						pcm_current_intrflag, 1);
-				break;
-
-			case GUS_DEV_PCM_DONE:	/* Right or mono channel data transferred */
-				gus_write8(0x41, 0);	/* Disable GF1 DMA */
-				if (pcm_qlen < pcm_nblk)
-				{
-					dma_active = 0;
-					if (gus_busy)
-					{
-						if (audio_devs[gus_devnum]->dmap_out->qlen > 0)
-							DMAbuf_outputintr(gus_devnum, 0);
-					}
-				}
-				break;
-
-			default:
-				break;
-	}
-	status = gus_look8(0x49);	/*
-					 * Get Sampling IRQ Status
-					 */
-	if (status & 0x40)	/*
-				 * Sampling Irq pending
-				 */
-	{
-		DMAbuf_inputintr(gus_devnum);
-	}
-}
-
-/*
- * Timer stuff
- */
-
-static volatile int select_addr, data_addr;
-static volatile int curr_timer;
-
-void gus_timer_command(unsigned int addr, unsigned int val)
-{
-	int i;
-
-	outb(((unsigned char) (addr & 0xff)), select_addr);
-
-	for (i = 0; i < 2; i++)
-		inb(select_addr);
-
-	outb(((unsigned char) (val & 0xff)), data_addr);
-
-	for (i = 0; i < 2; i++)
-		inb(select_addr);
-}
-
-static void arm_timer(int timer, unsigned int interval)
-{
-	curr_timer = timer;
-
-	if (timer == 1)
-	{
-		gus_write8(0x46, 256 - interval);	/* Set counter for timer 1 */
-		gus_write8(0x45, 0x04);			/* Enable timer 1 IRQ */
-		gus_timer_command(0x04, 0x01);		/* Start timer 1 */
-	}
-	else
-	{
-		gus_write8(0x47, 256 - interval);	/* Set counter for timer 2 */
-		gus_write8(0x45, 0x08);			/* Enable timer 2 IRQ */
-		gus_timer_command(0x04, 0x02);		/* Start timer 2 */
-	}
-
-	gus_timer_enabled = 1;
-}
-
-static unsigned int gus_tmr_start(int dev, unsigned int usecs_per_tick)
-{
-	int timer_no, resolution;
-	int divisor;
-
-	if (usecs_per_tick > (256 * 80))
-	{
-		timer_no = 2;
-		resolution = 320;	/* usec */
-	}
-	else
-	{
-		timer_no = 1;
-		resolution = 80;	/* usec */
-	}
-	divisor = (usecs_per_tick + (resolution / 2)) / resolution;
-	arm_timer(timer_no, divisor);
-
-	return divisor * resolution;
-}
-
-static void gus_tmr_disable(int dev)
-{
-	gus_write8(0x45, 0);	/* Disable both timers */
-	gus_timer_enabled = 0;
-}
-
-static void gus_tmr_restart(int dev)
-{
-	if (curr_timer == 1)
-		gus_write8(0x45, 0x04);		/* Start timer 1 again */
-	else
-		gus_write8(0x45, 0x08);		/* Start timer 2 again */
-	gus_timer_enabled = 1;
-}
-
-static struct sound_lowlev_timer gus_tmr =
-{
-	0,
-	1,
-	gus_tmr_start,
-	gus_tmr_disable,
-	gus_tmr_restart
-};
-
-static void gus_tmr_install(int io_base)
-{
-	struct sound_lowlev_timer *tmr;
-
-	select_addr = io_base;
-	data_addr = io_base + 1;
-
-	tmr = &gus_tmr;
-
-#ifdef THIS_GETS_FIXED
-	sound_timer_init(&gus_tmr, "GUS");
-#endif
-}
--- linux-2.6.18.noarch/sound/oss/yss225.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/yss225.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,24 +0,0 @@
-#ifndef __yss255_h__
-#define __yss255_h__
-
-extern unsigned char page_zero[256];
-extern unsigned char page_one[256];
-extern unsigned char page_two[128];
-extern unsigned char page_three[128];
-extern unsigned char page_four[128];
-extern unsigned char page_six[192];
-extern unsigned char page_seven[256];
-extern unsigned char page_zero_v2[96];
-extern unsigned char page_one_v2[96];
-extern unsigned char page_two_v2[48];
-extern unsigned char page_three_v2[48];
-extern unsigned char page_four_v2[48];
-extern unsigned char page_seven_v2[96];
-extern unsigned char mod_v2[304];
-extern unsigned char coefficients[364];
-extern unsigned char coefficients2[56];
-extern unsigned char coefficients3[404];
-
-
-#endif /* __ys225_h__ */
-
--- linux-2.6.18.noarch/sound/oss/maestro3.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/maestro3.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,821 +0,0 @@
-/*
- *      ESS Technology allegro audio driver.
- *
- *      Copyright (C) 1992-2000  Don Kim (don.kim@esstech.com)
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *      Hacked for the maestro3 driver by zab
- */
-
-// Allegro PCI configuration registers
-#define PCI_LEGACY_AUDIO_CTRL   0x40
-#define SOUND_BLASTER_ENABLE    0x00000001
-#define FM_SYNTHESIS_ENABLE     0x00000002
-#define GAME_PORT_ENABLE        0x00000004
-#define MPU401_IO_ENABLE        0x00000008
-#define MPU401_IRQ_ENABLE       0x00000010
-#define ALIAS_10BIT_IO          0x00000020
-#define SB_DMA_MASK             0x000000C0
-#define SB_DMA_0                0x00000040
-#define SB_DMA_1                0x00000040
-#define SB_DMA_R                0x00000080
-#define SB_DMA_3                0x000000C0
-#define SB_IRQ_MASK             0x00000700
-#define SB_IRQ_5                0x00000000
-#define SB_IRQ_7                0x00000100
-#define SB_IRQ_9                0x00000200
-#define SB_IRQ_10               0x00000300
-#define MIDI_IRQ_MASK           0x00003800
-#define SERIAL_IRQ_ENABLE       0x00004000
-#define DISABLE_LEGACY          0x00008000
-
-#define PCI_ALLEGRO_CONFIG      0x50
-#define SB_ADDR_240             0x00000004
-#define MPU_ADDR_MASK           0x00000018
-#define MPU_ADDR_330            0x00000000
-#define MPU_ADDR_300            0x00000008
-#define MPU_ADDR_320            0x00000010
-#define MPU_ADDR_340            0x00000018
-#define USE_PCI_TIMING          0x00000040
-#define POSTED_WRITE_ENABLE     0x00000080
-#define DMA_POLICY_MASK         0x00000700
-#define DMA_DDMA                0x00000000
-#define DMA_TDMA                0x00000100
-#define DMA_PCPCI               0x00000200
-#define DMA_WBDMA16             0x00000400
-#define DMA_WBDMA4              0x00000500
-#define DMA_WBDMA2              0x00000600
-#define DMA_WBDMA1              0x00000700
-#define DMA_SAFE_GUARD          0x00000800
-#define HI_PERF_GP_ENABLE       0x00001000
-#define PIC_SNOOP_MODE_0        0x00002000
-#define PIC_SNOOP_MODE_1        0x00004000
-#define SOUNDBLASTER_IRQ_MASK   0x00008000
-#define RING_IN_ENABLE          0x00010000
-#define SPDIF_TEST_MODE         0x00020000
-#define CLK_MULT_MODE_SELECT_2  0x00040000
-#define EEPROM_WRITE_ENABLE     0x00080000
-#define CODEC_DIR_IN            0x00100000
-#define HV_BUTTON_FROM_GD       0x00200000
-#define REDUCED_DEBOUNCE        0x00400000
-#define HV_CTRL_ENABLE          0x00800000
-#define SPDIF_ENABLE            0x01000000
-#define CLK_DIV_SELECT          0x06000000
-#define CLK_DIV_BY_48           0x00000000
-#define CLK_DIV_BY_49           0x02000000
-#define CLK_DIV_BY_50           0x04000000
-#define CLK_DIV_RESERVED        0x06000000
-#define PM_CTRL_ENABLE          0x08000000
-#define CLK_MULT_MODE_SELECT    0x30000000
-#define CLK_MULT_MODE_SHIFT     28
-#define CLK_MULT_MODE_0         0x00000000
-#define CLK_MULT_MODE_1         0x10000000
-#define CLK_MULT_MODE_2         0x20000000
-#define CLK_MULT_MODE_3         0x30000000
-#define INT_CLK_SELECT          0x40000000
-#define INT_CLK_MULT_RESET      0x80000000
-
-// M3
-#define INT_CLK_SRC_NOT_PCI     0x00100000
-#define INT_CLK_MULT_ENABLE     0x80000000
-
-#define PCI_ACPI_CONTROL        0x54
-#define PCI_ACPI_D0             0x00000000
-#define PCI_ACPI_D1             0xB4F70000
-#define PCI_ACPI_D2             0xB4F7B4F7
-
-#define PCI_USER_CONFIG         0x58
-#define EXT_PCI_MASTER_ENABLE   0x00000001
-#define SPDIF_OUT_SELECT        0x00000002
-#define TEST_PIN_DIR_CTRL       0x00000004
-#define AC97_CODEC_TEST         0x00000020
-#define TRI_STATE_BUFFER        0x00000080
-#define IN_CLK_12MHZ_SELECT     0x00000100
-#define MULTI_FUNC_DISABLE      0x00000200
-#define EXT_MASTER_PAIR_SEL     0x00000400
-#define PCI_MASTER_SUPPORT      0x00000800
-#define STOP_CLOCK_ENABLE       0x00001000
-#define EAPD_DRIVE_ENABLE       0x00002000
-#define REQ_TRI_STATE_ENABLE    0x00004000
-#define REQ_LOW_ENABLE          0x00008000
-#define MIDI_1_ENABLE           0x00010000
-#define MIDI_2_ENABLE           0x00020000
-#define SB_AUDIO_SYNC           0x00040000
-#define HV_CTRL_TEST            0x00100000
-#define SOUNDBLASTER_TEST       0x00400000
-
-#define PCI_USER_CONFIG_C       0x5C
-
-#define PCI_DDMA_CTRL           0x60
-#define DDMA_ENABLE             0x00000001
-
-
-// Allegro registers
-#define HOST_INT_CTRL           0x18
-#define SB_INT_ENABLE           0x0001
-#define MPU401_INT_ENABLE       0x0002
-#define ASSP_INT_ENABLE         0x0010
-#define RING_INT_ENABLE         0x0020
-#define HV_INT_ENABLE           0x0040
-#define CLKRUN_GEN_ENABLE       0x0100
-#define HV_CTRL_TO_PME          0x0400
-#define SOFTWARE_RESET_ENABLE   0x8000
-
-/*
- * should be using the above defines, probably.
- */
-#define REGB_ENABLE_RESET               0x01
-#define REGB_STOP_CLOCK                 0x10
-
-#define HOST_INT_STATUS         0x1A
-#define SB_INT_PENDING          0x01
-#define MPU401_INT_PENDING      0x02
-#define ASSP_INT_PENDING        0x10
-#define RING_INT_PENDING        0x20
-#define HV_INT_PENDING          0x40
-
-#define HARDWARE_VOL_CTRL       0x1B
-#define SHADOW_MIX_REG_VOICE    0x1C
-#define HW_VOL_COUNTER_VOICE    0x1D
-#define SHADOW_MIX_REG_MASTER   0x1E
-#define HW_VOL_COUNTER_MASTER   0x1F
-
-#define CODEC_COMMAND           0x30
-#define CODEC_READ_B            0x80
-
-#define CODEC_STATUS            0x30
-#define CODEC_BUSY_B            0x01
-
-#define CODEC_DATA              0x32
-
-#define RING_BUS_CTRL_A         0x36
-#define RAC_PME_ENABLE          0x0100
-#define RAC_SDFS_ENABLE         0x0200
-#define LAC_PME_ENABLE          0x0400
-#define LAC_SDFS_ENABLE         0x0800
-#define SERIAL_AC_LINK_ENABLE   0x1000
-#define IO_SRAM_ENABLE          0x2000
-#define IIS_INPUT_ENABLE        0x8000
-
-#define RING_BUS_CTRL_B         0x38
-#define SECOND_CODEC_ID_MASK    0x0003
-#define SPDIF_FUNC_ENABLE       0x0010
-#define SECOND_AC_ENABLE        0x0020
-#define SB_MODULE_INTF_ENABLE   0x0040
-#define SSPE_ENABLE             0x0040
-#define M3I_DOCK_ENABLE         0x0080
-
-#define SDO_OUT_DEST_CTRL       0x3A
-#define COMMAND_ADDR_OUT        0x0003
-#define PCM_LR_OUT_LOCAL        0x0000
-#define PCM_LR_OUT_REMOTE       0x0004
-#define PCM_LR_OUT_MUTE         0x0008
-#define PCM_LR_OUT_BOTH         0x000C
-#define LINE1_DAC_OUT_LOCAL     0x0000
-#define LINE1_DAC_OUT_REMOTE    0x0010
-#define LINE1_DAC_OUT_MUTE      0x0020
-#define LINE1_DAC_OUT_BOTH      0x0030
-#define PCM_CLS_OUT_LOCAL       0x0000
-#define PCM_CLS_OUT_REMOTE      0x0040
-#define PCM_CLS_OUT_MUTE        0x0080
-#define PCM_CLS_OUT_BOTH        0x00C0
-#define PCM_RLF_OUT_LOCAL       0x0000
-#define PCM_RLF_OUT_REMOTE      0x0100
-#define PCM_RLF_OUT_MUTE        0x0200
-#define PCM_RLF_OUT_BOTH        0x0300
-#define LINE2_DAC_OUT_LOCAL     0x0000
-#define LINE2_DAC_OUT_REMOTE    0x0400
-#define LINE2_DAC_OUT_MUTE      0x0800
-#define LINE2_DAC_OUT_BOTH      0x0C00
-#define HANDSET_OUT_LOCAL       0x0000
-#define HANDSET_OUT_REMOTE      0x1000
-#define HANDSET_OUT_MUTE        0x2000
-#define HANDSET_OUT_BOTH        0x3000
-#define IO_CTRL_OUT_LOCAL       0x0000
-#define IO_CTRL_OUT_REMOTE      0x4000
-#define IO_CTRL_OUT_MUTE        0x8000
-#define IO_CTRL_OUT_BOTH        0xC000
-
-#define SDO_IN_DEST_CTRL        0x3C
-#define STATUS_ADDR_IN          0x0003
-#define PCM_LR_IN_LOCAL         0x0000
-#define PCM_LR_IN_REMOTE        0x0004
-#define PCM_LR_RESERVED         0x0008
-#define PCM_LR_IN_BOTH          0x000C
-#define LINE1_ADC_IN_LOCAL      0x0000
-#define LINE1_ADC_IN_REMOTE     0x0010
-#define LINE1_ADC_IN_MUTE       0x0020
-#define MIC_ADC_IN_LOCAL        0x0000
-#define MIC_ADC_IN_REMOTE       0x0040
-#define MIC_ADC_IN_MUTE         0x0080
-#define LINE2_DAC_IN_LOCAL      0x0000
-#define LINE2_DAC_IN_REMOTE     0x0400
-#define LINE2_DAC_IN_MUTE       0x0800
-#define HANDSET_IN_LOCAL        0x0000
-#define HANDSET_IN_REMOTE       0x1000
-#define HANDSET_IN_MUTE         0x2000
-#define IO_STATUS_IN_LOCAL      0x0000
-#define IO_STATUS_IN_REMOTE     0x4000
-
-#define SPDIF_IN_CTRL           0x3E
-#define SPDIF_IN_ENABLE         0x0001
-
-#define GPIO_DATA               0x60
-#define GPIO_DATA_MASK          0x0FFF
-#define GPIO_HV_STATUS          0x3000
-#define GPIO_PME_STATUS         0x4000
-
-#define GPIO_MASK               0x64
-#define GPIO_DIRECTION          0x68
-#define GPO_PRIMARY_AC97        0x0001
-#define GPI_LINEOUT_SENSE       0x0004
-#define GPO_SECONDARY_AC97      0x0008
-#define GPI_VOL_DOWN            0x0010
-#define GPI_VOL_UP              0x0020
-#define GPI_IIS_CLK             0x0040
-#define GPI_IIS_LRCLK           0x0080
-#define GPI_IIS_DATA            0x0100
-#define GPI_DOCKING_STATUS      0x0100
-#define GPI_HEADPHONE_SENSE     0x0200
-#define GPO_EXT_AMP_SHUTDOWN    0x1000
-
-// M3
-#define GPO_M3_EXT_AMP_SHUTDN   0x0002
-
-#define ASSP_INDEX_PORT         0x80
-#define ASSP_MEMORY_PORT        0x82
-#define ASSP_DATA_PORT          0x84
-
-#define MPU401_DATA_PORT        0x98
-#define MPU401_STATUS_PORT      0x99
-
-#define CLK_MULT_DATA_PORT      0x9C
-
-#define ASSP_CONTROL_A          0xA2
-#define ASSP_0_WS_ENABLE        0x01
-#define ASSP_CTRL_A_RESERVED1   0x02
-#define ASSP_CTRL_A_RESERVED2   0x04
-#define ASSP_CLK_49MHZ_SELECT   0x08
-#define FAST_PLU_ENABLE         0x10
-#define ASSP_CTRL_A_RESERVED3   0x20
-#define DSP_CLK_36MHZ_SELECT    0x40
-
-#define ASSP_CONTROL_B          0xA4
-#define RESET_ASSP              0x00
-#define RUN_ASSP                0x01
-#define ENABLE_ASSP_CLOCK       0x00
-#define STOP_ASSP_CLOCK         0x10
-#define RESET_TOGGLE            0x40
-
-#define ASSP_CONTROL_C          0xA6
-#define ASSP_HOST_INT_ENABLE    0x01
-#define FM_ADDR_REMAP_DISABLE   0x02
-#define HOST_WRITE_PORT_ENABLE  0x08
-
-#define ASSP_HOST_INT_STATUS    0xAC
-#define DSP2HOST_REQ_PIORECORD  0x01
-#define DSP2HOST_REQ_I2SRATE    0x02
-#define DSP2HOST_REQ_TIMER      0x04
-
-// AC97 registers
-// XXX fix this crap up
-/*#define AC97_RESET              0x00*/
-
-#define AC97_VOL_MUTE_B         0x8000
-#define AC97_VOL_M              0x1F
-#define AC97_LEFT_VOL_S         8
-
-#define AC97_MASTER_VOL         0x02
-#define AC97_LINE_LEVEL_VOL     0x04
-#define AC97_MASTER_MONO_VOL    0x06
-#define AC97_PC_BEEP_VOL        0x0A
-#define AC97_PC_BEEP_VOL_M      0x0F
-#define AC97_SROUND_MASTER_VOL  0x38
-#define AC97_PC_BEEP_VOL_S      1
-
-/*#define AC97_PHONE_VOL          0x0C
-#define AC97_MIC_VOL            0x0E*/
-#define AC97_MIC_20DB_ENABLE    0x40
-
-/*#define AC97_LINEIN_VOL         0x10
-#define AC97_CD_VOL             0x12
-#define AC97_VIDEO_VOL          0x14
-#define AC97_AUX_VOL            0x16*/
-#define AC97_PCM_OUT_VOL        0x18
-/*#define AC97_RECORD_SELECT      0x1A*/
-#define AC97_RECORD_MIC         0x00
-#define AC97_RECORD_CD          0x01
-#define AC97_RECORD_VIDEO       0x02
-#define AC97_RECORD_AUX         0x03
-#define AC97_RECORD_MONO_MUX    0x02
-#define AC97_RECORD_DIGITAL     0x03
-#define AC97_RECORD_LINE        0x04
-#define AC97_RECORD_STEREO      0x05
-#define AC97_RECORD_MONO        0x06
-#define AC97_RECORD_PHONE       0x07
-
-/*#define AC97_RECORD_GAIN        0x1C*/
-#define AC97_RECORD_VOL_M       0x0F
-
-/*#define AC97_GENERAL_PURPOSE    0x20*/
-#define AC97_POWER_DOWN_CTRL    0x26
-#define AC97_ADC_READY          0x0001
-#define AC97_DAC_READY          0x0002
-#define AC97_ANALOG_READY       0x0004
-#define AC97_VREF_ON            0x0008
-#define AC97_PR0                0x0100
-#define AC97_PR1                0x0200
-#define AC97_PR2                0x0400
-#define AC97_PR3                0x0800
-#define AC97_PR4                0x1000
-
-#define AC97_RESERVED1          0x28
-
-#define AC97_VENDOR_TEST        0x5A
-
-#define AC97_CLOCK_DELAY        0x5C
-#define AC97_LINEOUT_MUX_SEL    0x0001
-#define AC97_MONO_MUX_SEL       0x0002
-#define AC97_CLOCK_DELAY_SEL    0x1F
-#define AC97_DAC_CDS_SHIFT      6
-#define AC97_ADC_CDS_SHIFT      11
-
-#define AC97_MULTI_CHANNEL_SEL  0x74
-
-/*#define AC97_VENDOR_ID1         0x7C
-#define AC97_VENDOR_ID2         0x7E*/
-
-/*
- * ASSP control regs
- */
-#define DSP_PORT_TIMER_COUNT    0x06
-
-#define DSP_PORT_MEMORY_INDEX   0x80
-
-#define DSP_PORT_MEMORY_TYPE    0x82
-#define MEMTYPE_INTERNAL_CODE   0x0002
-#define MEMTYPE_INTERNAL_DATA   0x0003
-#define MEMTYPE_MASK            0x0003
-
-#define DSP_PORT_MEMORY_DATA    0x84
-
-#define DSP_PORT_CONTROL_REG_A  0xA2
-#define DSP_PORT_CONTROL_REG_B  0xA4
-#define DSP_PORT_CONTROL_REG_C  0xA6
-
-#define REV_A_CODE_MEMORY_BEGIN         0x0000
-#define REV_A_CODE_MEMORY_END           0x0FFF
-#define REV_A_CODE_MEMORY_UNIT_LENGTH   0x0040
-#define REV_A_CODE_MEMORY_LENGTH        (REV_A_CODE_MEMORY_END - REV_A_CODE_MEMORY_BEGIN + 1)
-
-#define REV_B_CODE_MEMORY_BEGIN         0x0000
-#define REV_B_CODE_MEMORY_END           0x0BFF
-#define REV_B_CODE_MEMORY_UNIT_LENGTH   0x0040
-#define REV_B_CODE_MEMORY_LENGTH        (REV_B_CODE_MEMORY_END - REV_B_CODE_MEMORY_BEGIN + 1)
-
-#define REV_A_DATA_MEMORY_BEGIN         0x1000
-#define REV_A_DATA_MEMORY_END           0x2FFF
-#define REV_A_DATA_MEMORY_UNIT_LENGTH   0x0080
-#define REV_A_DATA_MEMORY_LENGTH        (REV_A_DATA_MEMORY_END - REV_A_DATA_MEMORY_BEGIN + 1)
-
-#define REV_B_DATA_MEMORY_BEGIN         0x1000
-#define REV_B_DATA_MEMORY_END           0x2BFF
-#define REV_B_DATA_MEMORY_UNIT_LENGTH   0x0080
-#define REV_B_DATA_MEMORY_LENGTH        (REV_B_DATA_MEMORY_END - REV_B_DATA_MEMORY_BEGIN + 1)
-
-
-#define NUM_UNITS_KERNEL_CODE          16
-#define NUM_UNITS_KERNEL_DATA           2
-
-#define NUM_UNITS_KERNEL_CODE_WITH_HSP 16
-#define NUM_UNITS_KERNEL_DATA_WITH_HSP  5
-
-/*
- * Kernel data layout
- */
-
-#define DP_SHIFT_COUNT                  7
-
-#define KDATA_BASE_ADDR                 0x1000
-#define KDATA_BASE_ADDR2                0x1080
-
-#define KDATA_TASK0                     (KDATA_BASE_ADDR + 0x0000)
-#define KDATA_TASK1                     (KDATA_BASE_ADDR + 0x0001)
-#define KDATA_TASK2                     (KDATA_BASE_ADDR + 0x0002)
-#define KDATA_TASK3                     (KDATA_BASE_ADDR + 0x0003)
-#define KDATA_TASK4                     (KDATA_BASE_ADDR + 0x0004)
-#define KDATA_TASK5                     (KDATA_BASE_ADDR + 0x0005)
-#define KDATA_TASK6                     (KDATA_BASE_ADDR + 0x0006)
-#define KDATA_TASK7                     (KDATA_BASE_ADDR + 0x0007)
-#define KDATA_TASK_ENDMARK              (KDATA_BASE_ADDR + 0x0008)
-
-#define KDATA_CURRENT_TASK              (KDATA_BASE_ADDR + 0x0009)
-#define KDATA_TASK_SWITCH               (KDATA_BASE_ADDR + 0x000A)
-
-#define KDATA_INSTANCE0_POS3D           (KDATA_BASE_ADDR + 0x000B)
-#define KDATA_INSTANCE1_POS3D           (KDATA_BASE_ADDR + 0x000C)
-#define KDATA_INSTANCE2_POS3D           (KDATA_BASE_ADDR + 0x000D)
-#define KDATA_INSTANCE3_POS3D           (KDATA_BASE_ADDR + 0x000E)
-#define KDATA_INSTANCE4_POS3D           (KDATA_BASE_ADDR + 0x000F)
-#define KDATA_INSTANCE5_POS3D           (KDATA_BASE_ADDR + 0x0010)
-#define KDATA_INSTANCE6_POS3D           (KDATA_BASE_ADDR + 0x0011)
-#define KDATA_INSTANCE7_POS3D           (KDATA_BASE_ADDR + 0x0012)
-#define KDATA_INSTANCE8_POS3D           (KDATA_BASE_ADDR + 0x0013)
-#define KDATA_INSTANCE_POS3D_ENDMARK    (KDATA_BASE_ADDR + 0x0014)
-
-#define KDATA_INSTANCE0_SPKVIRT         (KDATA_BASE_ADDR + 0x0015)
-#define KDATA_INSTANCE_SPKVIRT_ENDMARK  (KDATA_BASE_ADDR + 0x0016)
-
-#define KDATA_INSTANCE0_SPDIF           (KDATA_BASE_ADDR + 0x0017)
-#define KDATA_INSTANCE_SPDIF_ENDMARK    (KDATA_BASE_ADDR + 0x0018)
-
-#define KDATA_INSTANCE0_MODEM           (KDATA_BASE_ADDR + 0x0019)
-#define KDATA_INSTANCE_MODEM_ENDMARK    (KDATA_BASE_ADDR + 0x001A)
-
-#define KDATA_INSTANCE0_SRC             (KDATA_BASE_ADDR + 0x001B)
-#define KDATA_INSTANCE1_SRC             (KDATA_BASE_ADDR + 0x001C)
-#define KDATA_INSTANCE_SRC_ENDMARK      (KDATA_BASE_ADDR + 0x001D)
-
-#define KDATA_INSTANCE0_MINISRC         (KDATA_BASE_ADDR + 0x001E)
-#define KDATA_INSTANCE1_MINISRC         (KDATA_BASE_ADDR + 0x001F)
-#define KDATA_INSTANCE2_MINISRC         (KDATA_BASE_ADDR + 0x0020)
-#define KDATA_INSTANCE3_MINISRC         (KDATA_BASE_ADDR + 0x0021)
-#define KDATA_INSTANCE_MINISRC_ENDMARK  (KDATA_BASE_ADDR + 0x0022)
-
-#define KDATA_INSTANCE0_CPYTHRU         (KDATA_BASE_ADDR + 0x0023)
-#define KDATA_INSTANCE1_CPYTHRU         (KDATA_BASE_ADDR + 0x0024)
-#define KDATA_INSTANCE_CPYTHRU_ENDMARK  (KDATA_BASE_ADDR + 0x0025)
-
-#define KDATA_CURRENT_DMA               (KDATA_BASE_ADDR + 0x0026)
-#define KDATA_DMA_SWITCH                (KDATA_BASE_ADDR + 0x0027)
-#define KDATA_DMA_ACTIVE                (KDATA_BASE_ADDR + 0x0028)
-
-#define KDATA_DMA_XFER0                 (KDATA_BASE_ADDR + 0x0029)
-#define KDATA_DMA_XFER1                 (KDATA_BASE_ADDR + 0x002A)
-#define KDATA_DMA_XFER2                 (KDATA_BASE_ADDR + 0x002B)
-#define KDATA_DMA_XFER3                 (KDATA_BASE_ADDR + 0x002C)
-#define KDATA_DMA_XFER4                 (KDATA_BASE_ADDR + 0x002D)
-#define KDATA_DMA_XFER5                 (KDATA_BASE_ADDR + 0x002E)
-#define KDATA_DMA_XFER6                 (KDATA_BASE_ADDR + 0x002F)
-#define KDATA_DMA_XFER7                 (KDATA_BASE_ADDR + 0x0030)
-#define KDATA_DMA_XFER8                 (KDATA_BASE_ADDR + 0x0031)
-#define KDATA_DMA_XFER_ENDMARK          (KDATA_BASE_ADDR + 0x0032)
-
-#define KDATA_I2S_SAMPLE_COUNT          (KDATA_BASE_ADDR + 0x0033)
-#define KDATA_I2S_INT_METER             (KDATA_BASE_ADDR + 0x0034)
-#define KDATA_I2S_ACTIVE                (KDATA_BASE_ADDR + 0x0035)
-
-#define KDATA_TIMER_COUNT_RELOAD        (KDATA_BASE_ADDR + 0x0036)
-#define KDATA_TIMER_COUNT_CURRENT       (KDATA_BASE_ADDR + 0x0037)
-
-#define KDATA_HALT_SYNCH_CLIENT         (KDATA_BASE_ADDR + 0x0038)
-#define KDATA_HALT_SYNCH_DMA            (KDATA_BASE_ADDR + 0x0039)
-#define KDATA_HALT_ACKNOWLEDGE          (KDATA_BASE_ADDR + 0x003A)
-
-#define KDATA_ADC1_XFER0                (KDATA_BASE_ADDR + 0x003B)
-#define KDATA_ADC1_XFER_ENDMARK         (KDATA_BASE_ADDR + 0x003C)
-#define KDATA_ADC1_LEFT_VOLUME			(KDATA_BASE_ADDR + 0x003D)
-#define KDATA_ADC1_RIGHT_VOLUME  		(KDATA_BASE_ADDR + 0x003E)
-#define KDATA_ADC1_LEFT_SUR_VOL			(KDATA_BASE_ADDR + 0x003F)
-#define KDATA_ADC1_RIGHT_SUR_VOL		(KDATA_BASE_ADDR + 0x0040)
-
-#define KDATA_ADC2_XFER0                (KDATA_BASE_ADDR + 0x0041)
-#define KDATA_ADC2_XFER_ENDMARK         (KDATA_BASE_ADDR + 0x0042)
-#define KDATA_ADC2_LEFT_VOLUME			(KDATA_BASE_ADDR + 0x0043)
-#define KDATA_ADC2_RIGHT_VOLUME			(KDATA_BASE_ADDR + 0x0044)
-#define KDATA_ADC2_LEFT_SUR_VOL			(KDATA_BASE_ADDR + 0x0045)
-#define KDATA_ADC2_RIGHT_SUR_VOL		(KDATA_BASE_ADDR + 0x0046)
-
-#define KDATA_CD_XFER0					(KDATA_BASE_ADDR + 0x0047)					
-#define KDATA_CD_XFER_ENDMARK			(KDATA_BASE_ADDR + 0x0048)
-#define KDATA_CD_LEFT_VOLUME			(KDATA_BASE_ADDR + 0x0049)
-#define KDATA_CD_RIGHT_VOLUME			(KDATA_BASE_ADDR + 0x004A)
-#define KDATA_CD_LEFT_SUR_VOL			(KDATA_BASE_ADDR + 0x004B)
-#define KDATA_CD_RIGHT_SUR_VOL			(KDATA_BASE_ADDR + 0x004C)
-
-#define KDATA_MIC_XFER0					(KDATA_BASE_ADDR + 0x004D)
-#define KDATA_MIC_XFER_ENDMARK			(KDATA_BASE_ADDR + 0x004E)
-#define KDATA_MIC_VOLUME				(KDATA_BASE_ADDR + 0x004F)
-#define KDATA_MIC_SUR_VOL				(KDATA_BASE_ADDR + 0x0050)
-
-#define KDATA_I2S_XFER0                 (KDATA_BASE_ADDR + 0x0051)
-#define KDATA_I2S_XFER_ENDMARK          (KDATA_BASE_ADDR + 0x0052)
-
-#define KDATA_CHI_XFER0                 (KDATA_BASE_ADDR + 0x0053)
-#define KDATA_CHI_XFER_ENDMARK          (KDATA_BASE_ADDR + 0x0054)
-
-#define KDATA_SPDIF_XFER                (KDATA_BASE_ADDR + 0x0055)
-#define KDATA_SPDIF_CURRENT_FRAME       (KDATA_BASE_ADDR + 0x0056)
-#define KDATA_SPDIF_FRAME0              (KDATA_BASE_ADDR + 0x0057)
-#define KDATA_SPDIF_FRAME1              (KDATA_BASE_ADDR + 0x0058)
-#define KDATA_SPDIF_FRAME2              (KDATA_BASE_ADDR + 0x0059)
-
-#define KDATA_SPDIF_REQUEST             (KDATA_BASE_ADDR + 0x005A)
-#define KDATA_SPDIF_TEMP                (KDATA_BASE_ADDR + 0x005B)
-
-#define KDATA_SPDIFIN_XFER0             (KDATA_BASE_ADDR + 0x005C)
-#define KDATA_SPDIFIN_XFER_ENDMARK      (KDATA_BASE_ADDR + 0x005D)
-#define KDATA_SPDIFIN_INT_METER         (KDATA_BASE_ADDR + 0x005E)
-
-#define KDATA_DSP_RESET_COUNT           (KDATA_BASE_ADDR + 0x005F)
-#define KDATA_DEBUG_OUTPUT              (KDATA_BASE_ADDR + 0x0060)
-
-#define KDATA_KERNEL_ISR_LIST           (KDATA_BASE_ADDR + 0x0061)
-
-#define KDATA_KERNEL_ISR_CBSR1          (KDATA_BASE_ADDR + 0x0062)
-#define KDATA_KERNEL_ISR_CBER1          (KDATA_BASE_ADDR + 0x0063)
-#define KDATA_KERNEL_ISR_CBCR           (KDATA_BASE_ADDR + 0x0064)
-#define KDATA_KERNEL_ISR_AR0            (KDATA_BASE_ADDR + 0x0065)
-#define KDATA_KERNEL_ISR_AR1            (KDATA_BASE_ADDR + 0x0066)
-#define KDATA_KERNEL_ISR_AR2            (KDATA_BASE_ADDR + 0x0067)
-#define KDATA_KERNEL_ISR_AR3            (KDATA_BASE_ADDR + 0x0068)
-#define KDATA_KERNEL_ISR_AR4            (KDATA_BASE_ADDR + 0x0069)
-#define KDATA_KERNEL_ISR_AR5            (KDATA_BASE_ADDR + 0x006A)
-#define KDATA_KERNEL_ISR_BRCR           (KDATA_BASE_ADDR + 0x006B)
-#define KDATA_KERNEL_ISR_PASR           (KDATA_BASE_ADDR + 0x006C)
-#define KDATA_KERNEL_ISR_PAER           (KDATA_BASE_ADDR + 0x006D)
-
-#define KDATA_CLIENT_SCRATCH0           (KDATA_BASE_ADDR + 0x006E)
-#define KDATA_CLIENT_SCRATCH1           (KDATA_BASE_ADDR + 0x006F)
-#define KDATA_KERNEL_SCRATCH            (KDATA_BASE_ADDR + 0x0070)
-#define KDATA_KERNEL_ISR_SCRATCH        (KDATA_BASE_ADDR + 0x0071)
-
-#define KDATA_OUEUE_LEFT                (KDATA_BASE_ADDR + 0x0072)
-#define KDATA_QUEUE_RIGHT               (KDATA_BASE_ADDR + 0x0073)
-
-#define KDATA_ADC1_REQUEST              (KDATA_BASE_ADDR + 0x0074)
-#define KDATA_ADC2_REQUEST              (KDATA_BASE_ADDR + 0x0075)
-#define KDATA_CD_REQUEST				(KDATA_BASE_ADDR + 0x0076)
-#define KDATA_MIC_REQUEST				(KDATA_BASE_ADDR + 0x0077)
-
-#define KDATA_ADC1_MIXER_REQUEST        (KDATA_BASE_ADDR + 0x0078)
-#define KDATA_ADC2_MIXER_REQUEST        (KDATA_BASE_ADDR + 0x0079)
-#define KDATA_CD_MIXER_REQUEST			(KDATA_BASE_ADDR + 0x007A)
-#define KDATA_MIC_MIXER_REQUEST			(KDATA_BASE_ADDR + 0x007B)
-#define KDATA_MIC_SYNC_COUNTER			(KDATA_BASE_ADDR + 0x007C)
-
-/*
- * second 'segment' (?) reserved for mixer
- * buffers..
- */
-
-#define KDATA_MIXER_WORD0               (KDATA_BASE_ADDR2 + 0x0000)
-#define KDATA_MIXER_WORD1               (KDATA_BASE_ADDR2 + 0x0001)
-#define KDATA_MIXER_WORD2               (KDATA_BASE_ADDR2 + 0x0002)
-#define KDATA_MIXER_WORD3               (KDATA_BASE_ADDR2 + 0x0003)
-#define KDATA_MIXER_WORD4               (KDATA_BASE_ADDR2 + 0x0004)
-#define KDATA_MIXER_WORD5               (KDATA_BASE_ADDR2 + 0x0005)
-#define KDATA_MIXER_WORD6               (KDATA_BASE_ADDR2 + 0x0006)
-#define KDATA_MIXER_WORD7               (KDATA_BASE_ADDR2 + 0x0007)
-#define KDATA_MIXER_WORD8               (KDATA_BASE_ADDR2 + 0x0008)
-#define KDATA_MIXER_WORD9               (KDATA_BASE_ADDR2 + 0x0009)
-#define KDATA_MIXER_WORDA               (KDATA_BASE_ADDR2 + 0x000A)
-#define KDATA_MIXER_WORDB               (KDATA_BASE_ADDR2 + 0x000B)
-#define KDATA_MIXER_WORDC               (KDATA_BASE_ADDR2 + 0x000C)
-#define KDATA_MIXER_WORDD               (KDATA_BASE_ADDR2 + 0x000D)
-#define KDATA_MIXER_WORDE               (KDATA_BASE_ADDR2 + 0x000E)
-#define KDATA_MIXER_WORDF               (KDATA_BASE_ADDR2 + 0x000F)
-
-#define KDATA_MIXER_XFER0               (KDATA_BASE_ADDR2 + 0x0010)
-#define KDATA_MIXER_XFER1               (KDATA_BASE_ADDR2 + 0x0011)
-#define KDATA_MIXER_XFER2               (KDATA_BASE_ADDR2 + 0x0012)
-#define KDATA_MIXER_XFER3               (KDATA_BASE_ADDR2 + 0x0013)
-#define KDATA_MIXER_XFER4               (KDATA_BASE_ADDR2 + 0x0014)
-#define KDATA_MIXER_XFER5               (KDATA_BASE_ADDR2 + 0x0015)
-#define KDATA_MIXER_XFER6               (KDATA_BASE_ADDR2 + 0x0016)
-#define KDATA_MIXER_XFER7               (KDATA_BASE_ADDR2 + 0x0017)
-#define KDATA_MIXER_XFER8               (KDATA_BASE_ADDR2 + 0x0018)
-#define KDATA_MIXER_XFER9               (KDATA_BASE_ADDR2 + 0x0019)
-#define KDATA_MIXER_XFER_ENDMARK        (KDATA_BASE_ADDR2 + 0x001A)
-
-#define KDATA_MIXER_TASK_NUMBER         (KDATA_BASE_ADDR2 + 0x001B)
-#define KDATA_CURRENT_MIXER             (KDATA_BASE_ADDR2 + 0x001C)
-#define KDATA_MIXER_ACTIVE              (KDATA_BASE_ADDR2 + 0x001D)
-#define KDATA_MIXER_BANK_STATUS         (KDATA_BASE_ADDR2 + 0x001E)
-#define KDATA_DAC_LEFT_VOLUME	        (KDATA_BASE_ADDR2 + 0x001F)
-#define KDATA_DAC_RIGHT_VOLUME          (KDATA_BASE_ADDR2 + 0x0020)
-
-#define MAX_INSTANCE_MINISRC            (KDATA_INSTANCE_MINISRC_ENDMARK - KDATA_INSTANCE0_MINISRC)
-#define MAX_VIRTUAL_DMA_CHANNELS        (KDATA_DMA_XFER_ENDMARK - KDATA_DMA_XFER0)
-#define MAX_VIRTUAL_MIXER_CHANNELS      (KDATA_MIXER_XFER_ENDMARK - KDATA_MIXER_XFER0)
-#define MAX_VIRTUAL_ADC1_CHANNELS       (KDATA_ADC1_XFER_ENDMARK - KDATA_ADC1_XFER0)
-
-/*
- * client data area offsets
- */
-#define CDATA_INSTANCE_READY            0x00
-
-#define CDATA_HOST_SRC_ADDRL            0x01
-#define CDATA_HOST_SRC_ADDRH            0x02
-#define CDATA_HOST_SRC_END_PLUS_1L      0x03
-#define CDATA_HOST_SRC_END_PLUS_1H      0x04
-#define CDATA_HOST_SRC_CURRENTL         0x05
-#define CDATA_HOST_SRC_CURRENTH         0x06
-
-#define CDATA_IN_BUF_CONNECT            0x07
-#define CDATA_OUT_BUF_CONNECT           0x08
-
-#define CDATA_IN_BUF_BEGIN              0x09
-#define CDATA_IN_BUF_END_PLUS_1         0x0A
-#define CDATA_IN_BUF_HEAD               0x0B
-#define CDATA_IN_BUF_TAIL               0x0C
-#define CDATA_OUT_BUF_BEGIN             0x0D
-#define CDATA_OUT_BUF_END_PLUS_1        0x0E
-#define CDATA_OUT_BUF_HEAD              0x0F
-#define CDATA_OUT_BUF_TAIL              0x10
-
-#define CDATA_DMA_CONTROL               0x11
-#define CDATA_RESERVED                  0x12
-
-#define CDATA_FREQUENCY                 0x13
-#define CDATA_LEFT_VOLUME               0x14
-#define CDATA_RIGHT_VOLUME              0x15
-#define CDATA_LEFT_SUR_VOL              0x16
-#define CDATA_RIGHT_SUR_VOL             0x17
-
-#define CDATA_HEADER_LEN                0x18
-
-#define SRC3_DIRECTION_OFFSET           CDATA_HEADER_LEN
-#define SRC3_MODE_OFFSET                (CDATA_HEADER_LEN + 1)
-#define SRC3_WORD_LENGTH_OFFSET         (CDATA_HEADER_LEN + 2)
-#define SRC3_PARAMETER_OFFSET           (CDATA_HEADER_LEN + 3)
-#define SRC3_COEFF_ADDR_OFFSET          (CDATA_HEADER_LEN + 8)
-#define SRC3_FILTAP_ADDR_OFFSET         (CDATA_HEADER_LEN + 10)
-#define SRC3_TEMP_INBUF_ADDR_OFFSET     (CDATA_HEADER_LEN + 16)
-#define SRC3_TEMP_OUTBUF_ADDR_OFFSET    (CDATA_HEADER_LEN + 17)
-
-#define MINISRC_IN_BUFFER_SIZE   ( 0x50 * 2 )
-#define MINISRC_OUT_BUFFER_SIZE  ( 0x50 * 2 * 2)
-#define MINISRC_OUT_BUFFER_SIZE  ( 0x50 * 2 * 2)
-#define MINISRC_TMP_BUFFER_SIZE  ( 112 + ( MINISRC_BIQUAD_STAGE * 3 + 4 ) * 2 * 2 )
-#define MINISRC_BIQUAD_STAGE    2
-#define MINISRC_COEF_LOC          0X175
-
-#define DMACONTROL_BLOCK_MASK           0x000F
-#define  DMAC_BLOCK0_SELECTOR           0x0000
-#define  DMAC_BLOCK1_SELECTOR           0x0001
-#define  DMAC_BLOCK2_SELECTOR           0x0002
-#define  DMAC_BLOCK3_SELECTOR           0x0003
-#define  DMAC_BLOCK4_SELECTOR           0x0004
-#define  DMAC_BLOCK5_SELECTOR           0x0005
-#define  DMAC_BLOCK6_SELECTOR           0x0006
-#define  DMAC_BLOCK7_SELECTOR           0x0007
-#define  DMAC_BLOCK8_SELECTOR           0x0008
-#define  DMAC_BLOCK9_SELECTOR           0x0009
-#define  DMAC_BLOCKA_SELECTOR           0x000A
-#define  DMAC_BLOCKB_SELECTOR           0x000B
-#define  DMAC_BLOCKC_SELECTOR           0x000C
-#define  DMAC_BLOCKD_SELECTOR           0x000D
-#define  DMAC_BLOCKE_SELECTOR           0x000E
-#define  DMAC_BLOCKF_SELECTOR           0x000F
-#define DMACONTROL_PAGE_MASK            0x00F0
-#define  DMAC_PAGE0_SELECTOR            0x0030
-#define  DMAC_PAGE1_SELECTOR            0x0020
-#define  DMAC_PAGE2_SELECTOR            0x0010
-#define  DMAC_PAGE3_SELECTOR            0x0000
-#define DMACONTROL_AUTOREPEAT           0x1000
-#define DMACONTROL_STOPPED              0x2000
-#define DMACONTROL_DIRECTION            0x0100
-
-
-/*
- * DSP Code images
- */
-
-static u16 assp_kernel_image[] = {
-    0x7980, 0x0030, 0x7980, 0x03B4, 0x7980, 0x03B4, 0x7980, 0x00FB, 0x7980, 0x00DD, 0x7980, 0x03B4, 
-    0x7980, 0x0332, 0x7980, 0x0287, 0x7980, 0x03B4, 0x7980, 0x03B4, 0x7980, 0x03B4, 0x7980, 0x03B4, 
-    0x7980, 0x031A, 0x7980, 0x03B4, 0x7980, 0x022F, 0x7980, 0x03B4, 0x7980, 0x03B4, 0x7980, 0x03B4, 
-    0x7980, 0x03B4, 0x7980, 0x03B4, 0x7980, 0x0063, 0x7980, 0x006B, 0x7980, 0x03B4, 0x7980, 0x03B4, 
-    0xBF80, 0x2C7C, 0x8806, 0x8804, 0xBE40, 0xBC20, 0xAE09, 0x1000, 0xAE0A, 0x0001, 0x6938, 0xEB08, 
-    0x0053, 0x695A, 0xEB08, 0x00D6, 0x0009, 0x8B88, 0x6980, 0xE388, 0x0036, 0xBE30, 0xBC20, 0x6909, 
-    0xB801, 0x9009, 0xBE41, 0xBE41, 0x6928, 0xEB88, 0x0078, 0xBE41, 0xBE40, 0x7980, 0x0038, 0xBE41, 
-    0xBE41, 0x903A, 0x6938, 0xE308, 0x0056, 0x903A, 0xBE41, 0xBE40, 0xEF00, 0x903A, 0x6939, 0xE308, 
-    0x005E, 0x903A, 0xEF00, 0x690B, 0x660C, 0xEF8C, 0x690A, 0x660C, 0x620B, 0x6609, 0xEF00, 0x6910, 
-    0x660F, 0xEF04, 0xE388, 0x0075, 0x690E, 0x660F, 0x6210, 0x660D, 0xEF00, 0x690E, 0x660D, 0xEF00, 
-    0xAE70, 0x0001, 0xBC20, 0xAE27, 0x0001, 0x6939, 0xEB08, 0x005D, 0x6926, 0xB801, 0x9026, 0x0026, 
-    0x8B88, 0x6980, 0xE388, 0x00CB, 0x9028, 0x0D28, 0x4211, 0xE100, 0x007A, 0x4711, 0xE100, 0x00A0, 
-    0x7A80, 0x0063, 0xB811, 0x660A, 0x6209, 0xE304, 0x007A, 0x0C0B, 0x4005, 0x100A, 0xBA01, 0x9012, 
-    0x0C12, 0x4002, 0x7980, 0x00AF, 0x7A80, 0x006B, 0xBE02, 0x620E, 0x660D, 0xBA10, 0xE344, 0x007A, 
-    0x0C10, 0x4005, 0x100E, 0xBA01, 0x9012, 0x0C12, 0x4002, 0x1003, 0xBA02, 0x9012, 0x0C12, 0x4000, 
-    0x1003, 0xE388, 0x00BA, 0x1004, 0x7980, 0x00BC, 0x1004, 0xBA01, 0x9012, 0x0C12, 0x4001, 0x0C05, 
-    0x4003, 0x0C06, 0x4004, 0x1011, 0xBFB0, 0x01FF, 0x9012, 0x0C12, 0x4006, 0xBC20, 0xEF00, 0xAE26, 
-    0x1028, 0x6970, 0xBFD0, 0x0001, 0x9070, 0xE388, 0x007A, 0xAE28, 0x0000, 0xEF00, 0xAE70, 0x0300, 
-    0x0C70, 0xB00C, 0xAE5A, 0x0000, 0xEF00, 0x7A80, 0x038A, 0x697F, 0xB801, 0x907F, 0x0056, 0x8B88, 
-    0x0CA0, 0xB008, 0xAF71, 0xB000, 0x4E71, 0xE200, 0x00F3, 0xAE56, 0x1057, 0x0056, 0x0CA0, 0xB008, 
-    0x8056, 0x7980, 0x03A1, 0x0810, 0xBFA0, 0x1059, 0xE304, 0x03A1, 0x8056, 0x7980, 0x03A1, 0x7A80, 
-    0x038A, 0xBF01, 0xBE43, 0xBE59, 0x907C, 0x6937, 0xE388, 0x010D, 0xBA01, 0xE308, 0x010C, 0xAE71, 
-    0x0004, 0x0C71, 0x5000, 0x6936, 0x9037, 0xBF0A, 0x109E, 0x8B8A, 0xAF80, 0x8014, 0x4C80, 0xBF0A, 
-    0x0560, 0xF500, 0xBF0A, 0x0520, 0xB900, 0xBB17, 0x90A0, 0x6917, 0xE388, 0x0148, 0x0D17, 0xE100, 
-    0x0127, 0xBF0C, 0x0578, 0xBF0D, 0x057C, 0x7980, 0x012B, 0xBF0C, 0x0538, 0xBF0D, 0x053C, 0x6900, 
-    0xE308, 0x0135, 0x8B8C, 0xBE59, 0xBB07, 0x90A0, 0xBC20, 0x7980, 0x0157, 0x030C, 0x8B8B, 0xB903, 
-    0x8809, 0xBEC6, 0x013E, 0x69AC, 0x90AB, 0x69AD, 0x90AB, 0x0813, 0x660A, 0xE344, 0x0144, 0x0309, 
-    0x830C, 0xBC20, 0x7980, 0x0157, 0x6955, 0xE388, 0x0157, 0x7C38, 0xBF0B, 0x0578, 0xF500, 0xBF0B, 
-    0x0538, 0xB907, 0x8809, 0xBEC6, 0x0156, 0x10AB, 0x90AA, 0x6974, 0xE388, 0x0163, 0xAE72, 0x0540, 
-    0xF500, 0xAE72, 0x0500, 0xAE61, 0x103B, 0x7A80, 0x02F6, 0x6978, 0xE388, 0x0182, 0x8B8C, 0xBF0C, 
-    0x0560, 0xE500, 0x7C40, 0x0814, 0xBA20, 0x8812, 0x733D, 0x7A80, 0x0380, 0x733E, 0x7A80, 0x0380, 
-    0x8B8C, 0xBF0C, 0x056C, 0xE500, 0x7C40, 0x0814, 0xBA2C, 0x8812, 0x733F, 0x7A80, 0x0380, 0x7340, 
-    0x7A80, 0x0380, 0x6975, 0xE388, 0x018E, 0xAE72, 0x0548, 0xF500, 0xAE72, 0x0508, 0xAE61, 0x1041, 
-    0x7A80, 0x02F6, 0x6979, 0xE388, 0x01AD, 0x8B8C, 0xBF0C, 0x0560, 0xE500, 0x7C40, 0x0814, 0xBA18, 
-    0x8812, 0x7343, 0x7A80, 0x0380, 0x7344, 0x7A80, 0x0380, 0x8B8C, 0xBF0C, 0x056C, 0xE500, 0x7C40, 
-    0x0814, 0xBA24, 0x8812, 0x7345, 0x7A80, 0x0380, 0x7346, 0x7A80, 0x0380, 0x6976, 0xE388, 0x01B9, 
-    0xAE72, 0x0558, 0xF500, 0xAE72, 0x0518, 0xAE61, 0x1047, 0x7A80, 0x02F6, 0x697A, 0xE388, 0x01D8, 
-    0x8B8C, 0xBF0C, 0x0560, 0xE500, 0x7C40, 0x0814, 0xBA08, 0x8812, 0x7349, 0x7A80, 0x0380, 0x734A, 
-    0x7A80, 0x0380, 0x8B8C, 0xBF0C, 0x056C, 0xE500, 0x7C40, 0x0814, 0xBA14, 0x8812, 0x734B, 0x7A80, 
-    0x0380, 0x734C, 0x7A80, 0x0380, 0xBC21, 0xAE1C, 0x1090, 0x8B8A, 0xBF0A, 0x0560, 0xE500, 0x7C40, 
-    0x0812, 0xB804, 0x8813, 0x8B8D, 0xBF0D, 0x056C, 0xE500, 0x7C40, 0x0815, 0xB804, 0x8811, 0x7A80, 
-    0x034A, 0x8B8A, 0xBF0A, 0x0560, 0xE500, 0x7C40, 0x731F, 0xB903, 0x8809, 0xBEC6, 0x01F9, 0x548A, 
-    0xBE03, 0x98A0, 0x7320, 0xB903, 0x8809, 0xBEC6, 0x0201, 0x548A, 0xBE03, 0x98A0, 0x1F20, 0x2F1F, 
-    0x9826, 0xBC20, 0x6935, 0xE388, 0x03A1, 0x6933, 0xB801, 0x9033, 0xBFA0, 0x02EE, 0xE308, 0x03A1, 
-    0x9033, 0xBF00, 0x6951, 0xE388, 0x021F, 0x7334, 0xBE80, 0x5760, 0xBE03, 0x9F7E, 0xBE59, 0x9034, 
-    0x697E, 0x0D51, 0x9013, 0xBC20, 0x695C, 0xE388, 0x03A1, 0x735E, 0xBE80, 0x5760, 0xBE03, 0x9F7E, 
-    0xBE59, 0x905E, 0x697E, 0x0D5C, 0x9013, 0x7980, 0x03A1, 0x7A80, 0x038A, 0xBF01, 0xBE43, 0x6977, 
-    0xE388, 0x024E, 0xAE61, 0x104D, 0x0061, 0x8B88, 0x6980, 0xE388, 0x024E, 0x9071, 0x0D71, 0x000B, 
-    0xAFA0, 0x8010, 0xAFA0, 0x8010, 0x0810, 0x660A, 0xE308, 0x0249, 0x0009, 0x0810, 0x660C, 0xE388, 
-    0x024E, 0x800B, 0xBC20, 0x697B, 0xE388, 0x03A1, 0xBF0A, 0x109E, 0x8B8A, 0xAF80, 0x8014, 0x4C80, 
-    0xE100, 0x0266, 0x697C, 0xBF90, 0x0560, 0x9072, 0x0372, 0x697C, 0xBF90, 0x0564, 0x9073, 0x0473, 
-    0x7980, 0x0270, 0x697C, 0xBF90, 0x0520, 0x9072, 0x0372, 0x697C, 0xBF90, 0x0524, 0x9073, 0x0473, 
-    0x697C, 0xB801, 0x907C, 0xBF0A, 0x10FD, 0x8B8A, 0xAF80, 0x8010, 0x734F, 0x548A, 0xBE03, 0x9880, 
-    0xBC21, 0x7326, 0x548B, 0xBE03, 0x618B, 0x988C, 0xBE03, 0x6180, 0x9880, 0x7980, 0x03A1, 0x7A80, 
-    0x038A, 0x0D28, 0x4711, 0xE100, 0x02BE, 0xAF12, 0x4006, 0x6912, 0xBFB0, 0x0C00, 0xE388, 0x02B6, 
-    0xBFA0, 0x0800, 0xE388, 0x02B2, 0x6912, 0xBFB0, 0x0C00, 0xBFA0, 0x0400, 0xE388, 0x02A3, 0x6909, 
-    0x900B, 0x7980, 0x02A5, 0xAF0B, 0x4005, 0x6901, 0x9005, 0x6902, 0x9006, 0x4311, 0xE100, 0x02ED, 
-    0x6911, 0xBFC0, 0x2000, 0x9011, 0x7980, 0x02ED, 0x6909, 0x900B, 0x7980, 0x02B8, 0xAF0B, 0x4005, 
-    0xAF05, 0x4003, 0xAF06, 0x4004, 0x7980, 0x02ED, 0xAF12, 0x4006, 0x6912, 0xBFB0, 0x0C00, 0xE388, 
-    0x02E7, 0xBFA0, 0x0800, 0xE388, 0x02E3, 0x6912, 0xBFB0, 0x0C00, 0xBFA0, 0x0400, 0xE388, 0x02D4, 
-    0x690D, 0x9010, 0x7980, 0x02D6, 0xAF10, 0x4005, 0x6901, 0x9005, 0x6902, 0x9006, 0x4311, 0xE100, 
-    0x02ED, 0x6911, 0xBFC0, 0x2000, 0x9011, 0x7980, 0x02ED, 0x690D, 0x9010, 0x7980, 0x02E9, 0xAF10, 
-    0x4005, 0xAF05, 0x4003, 0xAF06, 0x4004, 0xBC20, 0x6970, 0x9071, 0x7A80, 0x0078, 0x6971, 0x9070, 
-    0x7980, 0x03A1, 0xBC20, 0x0361, 0x8B8B, 0x6980, 0xEF88, 0x0272, 0x0372, 0x7804, 0x9071, 0x0D71, 
-    0x8B8A, 0x000B, 0xB903, 0x8809, 0xBEC6, 0x0309, 0x69A8, 0x90AB, 0x69A8, 0x90AA, 0x0810, 0x660A, 
-    0xE344, 0x030F, 0x0009, 0x0810, 0x660C, 0xE388, 0x0314, 0x800B, 0xBC20, 0x6961, 0xB801, 0x9061, 
-    0x7980, 0x02F7, 0x7A80, 0x038A, 0x5D35, 0x0001, 0x6934, 0xB801, 0x9034, 0xBF0A, 0x109E, 0x8B8A, 
-    0xAF80, 0x8014, 0x4880, 0xAE72, 0x0550, 0xF500, 0xAE72, 0x0510, 0xAE61, 0x1051, 0x7A80, 0x02F6, 
-    0x7980, 0x03A1, 0x7A80, 0x038A, 0x5D35, 0x0002, 0x695E, 0xB801, 0x905E, 0xBF0A, 0x109E, 0x8B8A, 
-    0xAF80, 0x8014, 0x4780, 0xAE72, 0x0558, 0xF500, 0xAE72, 0x0518, 0xAE61, 0x105C, 0x7A80, 0x02F6, 
-    0x7980, 0x03A1, 0x001C, 0x8B88, 0x6980, 0xEF88, 0x901D, 0x0D1D, 0x100F, 0x6610, 0xE38C, 0x0358, 
-    0x690E, 0x6610, 0x620F, 0x660D, 0xBA0F, 0xE301, 0x037A, 0x0410, 0x8B8A, 0xB903, 0x8809, 0xBEC6, 
-    0x036C, 0x6A8C, 0x61AA, 0x98AB, 0x6A8C, 0x61AB, 0x98AD, 0x6A8C, 0x61AD, 0x98A9, 0x6A8C, 0x61A9, 
-    0x98AA, 0x7C04, 0x8B8B, 0x7C04, 0x8B8D, 0x7C04, 0x8B89, 0x7C04, 0x0814, 0x660E, 0xE308, 0x0379, 
-    0x040D, 0x8410, 0xBC21, 0x691C, 0xB801, 0x901C, 0x7980, 0x034A, 0xB903, 0x8809, 0x8B8A, 0xBEC6, 
-    0x0388, 0x54AC, 0xBE03, 0x618C, 0x98AA, 0xEF00, 0xBC20, 0xBE46, 0x0809, 0x906B, 0x080A, 0x906C, 
-    0x080B, 0x906D, 0x081A, 0x9062, 0x081B, 0x9063, 0x081E, 0x9064, 0xBE59, 0x881E, 0x8065, 0x8166, 
-    0x8267, 0x8368, 0x8469, 0x856A, 0xEF00, 0xBC20, 0x696B, 0x8809, 0x696C, 0x880A, 0x696D, 0x880B, 
-    0x6962, 0x881A, 0x6963, 0x881B, 0x6964, 0x881E, 0x0065, 0x0166, 0x0267, 0x0368, 0x0469, 0x056A, 
-    0xBE3A, 
-};
-
-/*
- * Mini sample rate converter code image
- * that is to be loaded at 0x400 on the DSP.
- */
-static u16 assp_minisrc_image[] = {
-
-    0xBF80, 0x101E, 0x906E, 0x006E, 0x8B88, 0x6980, 0xEF88, 0x906F, 0x0D6F, 0x6900, 0xEB08, 0x0412, 
-    0xBC20, 0x696E, 0xB801, 0x906E, 0x7980, 0x0403, 0xB90E, 0x8807, 0xBE43, 0xBF01, 0xBE47, 0xBE41, 
-    0x7A80, 0x002A, 0xBE40, 0x3029, 0xEFCC, 0xBE41, 0x7A80, 0x0028, 0xBE40, 0x3028, 0xEFCC, 0x6907, 
-    0xE308, 0x042A, 0x6909, 0x902C, 0x7980, 0x042C, 0x690D, 0x902C, 0x1009, 0x881A, 0x100A, 0xBA01, 
-    0x881B, 0x100D, 0x881C, 0x100E, 0xBA01, 0x881D, 0xBF80, 0x00ED, 0x881E, 0x050C, 0x0124, 0xB904, 
-    0x9027, 0x6918, 0xE308, 0x04B3, 0x902D, 0x6913, 0xBFA0, 0x7598, 0xF704, 0xAE2D, 0x00FF, 0x8B8D, 
-    0x6919, 0xE308, 0x0463, 0x691A, 0xE308, 0x0456, 0xB907, 0x8809, 0xBEC6, 0x0453, 0x10A9, 0x90AD, 
-    0x7980, 0x047C, 0xB903, 0x8809, 0xBEC6, 0x0460, 0x1889, 0x6C22, 0x90AD, 0x10A9, 0x6E23, 0x6C22, 
-    0x90AD, 0x7980, 0x047C, 0x101A, 0xE308, 0x046F, 0xB903, 0x8809, 0xBEC6, 0x046C, 0x10A9, 0x90A0, 
-    0x90AD, 0x7980, 0x047C, 0xB901, 0x8809, 0xBEC6, 0x047B, 0x1889, 0x6C22, 0x90A0, 0x90AD, 0x10A9, 
-    0x6E23, 0x6C22, 0x90A0, 0x90AD, 0x692D, 0xE308, 0x049C, 0x0124, 0xB703, 0xB902, 0x8818, 0x8B89, 
-    0x022C, 0x108A, 0x7C04, 0x90A0, 0x692B, 0x881F, 0x7E80, 0x055B, 0x692A, 0x8809, 0x8B89, 0x99A0, 
-    0x108A, 0x90A0, 0x692B, 0x881F, 0x7E80, 0x055B, 0x692A, 0x8809, 0x8B89, 0x99AF, 0x7B99, 0x0484, 
-    0x0124, 0x060F, 0x101B, 0x2013, 0x901B, 0xBFA0, 0x7FFF, 0xE344, 0x04AC, 0x901B, 0x8B89, 0x7A80, 
-    0x051A, 0x6927, 0xBA01, 0x9027, 0x7A80, 0x0523, 0x6927, 0xE308, 0x049E, 0x7980, 0x050F, 0x0624, 
-    0x1026, 0x2013, 0x9026, 0xBFA0, 0x7FFF, 0xE304, 0x04C0, 0x8B8D, 0x7A80, 0x051A, 0x7980, 0x04B4, 
-    0x9026, 0x1013, 0x3026, 0x901B, 0x8B8D, 0x7A80, 0x051A, 0x7A80, 0x0523, 0x1027, 0xBA01, 0x9027, 
-    0xE308, 0x04B4, 0x0124, 0x060F, 0x8B89, 0x691A, 0xE308, 0x04EA, 0x6919, 0xE388, 0x04E0, 0xB903, 
-    0x8809, 0xBEC6, 0x04DD, 0x1FA0, 0x2FAE, 0x98A9, 0x7980, 0x050F, 0xB901, 0x8818, 0xB907, 0x8809, 
-    0xBEC6, 0x04E7, 0x10EE, 0x90A9, 0x7980, 0x050F, 0x6919, 0xE308, 0x04FE, 0xB903, 0x8809, 0xBE46, 
-    0xBEC6, 0x04FA, 0x17A0, 0xBE1E, 0x1FAE, 0xBFBF, 0xFF00, 0xBE13, 0xBFDF, 0x8080, 0x99A9, 0xBE47, 
-    0x7980, 0x050F, 0xB901, 0x8809, 0xBEC6, 0x050E, 0x16A0, 0x26A0, 0xBFB7, 0xFF00, 0xBE1E, 0x1EA0, 
-    0x2EAE, 0xBFBF, 0xFF00, 0xBE13, 0xBFDF, 0x8080, 0x99A9, 0x850C, 0x860F, 0x6907, 0xE388, 0x0516, 
-    0x0D07, 0x8510, 0xBE59, 0x881E, 0xBE4A, 0xEF00, 0x101E, 0x901C, 0x101F, 0x901D, 0x10A0, 0x901E, 
-    0x10A0, 0x901F, 0xEF00, 0x101E, 0x301C, 0x9020, 0x731B, 0x5420, 0xBE03, 0x9825, 0x1025, 0x201C, 
-    0x9025, 0x7325, 0x5414, 0xBE03, 0x8B8E, 0x9880, 0x692F, 0xE388, 0x0539, 0xBE59, 0xBB07, 0x6180, 
-    0x9880, 0x8BA0, 0x101F, 0x301D, 0x9021, 0x731B, 0x5421, 0xBE03, 0x982E, 0x102E, 0x201D, 0x902E, 
-    0x732E, 0x5415, 0xBE03, 0x9880, 0x692F, 0xE388, 0x054F, 0xBE59, 0xBB07, 0x6180, 0x9880, 0x8BA0, 
-    0x6918, 0xEF08, 0x7325, 0x5416, 0xBE03, 0x98A0, 0x732E, 0x5417, 0xBE03, 0x98A0, 0xEF00, 0x8BA0, 
-    0xBEC6, 0x056B, 0xBE59, 0xBB04, 0xAA90, 0xBE04, 0xBE1E, 0x99E0, 0x8BE0, 0x69A0, 0x90D0, 0x69A0, 
-    0x90D0, 0x081F, 0xB805, 0x881F, 0x8B90, 0x69A0, 0x90D0, 0x69A0, 0x9090, 0x8BD0, 0x8BD8, 0xBE1F, 
-    0xEF00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
-};
-
--- linux-2.6.18.noarch/sound/oss/dev_table.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/dev_table.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/dev_table.c
+ * sound/oss/dev_table.c
  *
  * Device call tables.
  *
@@ -13,9 +13,39 @@
 
 #include <linux/init.h>
 
-#define _DEV_TABLE_C_
 #include "sound_config.h"
 
+struct audio_operations *audio_devs[MAX_AUDIO_DEV];
+EXPORT_SYMBOL(audio_devs);
+
+int num_audiodevs;
+EXPORT_SYMBOL(num_audiodevs);
+
+struct mixer_operations *mixer_devs[MAX_MIXER_DEV];
+EXPORT_SYMBOL(mixer_devs);
+
+int num_mixers;
+EXPORT_SYMBOL(num_mixers);
+
+struct synth_operations *synth_devs[MAX_SYNTH_DEV+MAX_MIDI_DEV];
+EXPORT_SYMBOL(synth_devs);
+
+int num_synths;
+
+struct midi_operations *midi_devs[MAX_MIDI_DEV];
+EXPORT_SYMBOL(midi_devs);
+
+int num_midis;
+EXPORT_SYMBOL(num_midis);
+
+struct sound_timer_operations *sound_timer_devs[MAX_TIMER_DEV] = {
+	&default_sound_timer, NULL
+};
+EXPORT_SYMBOL(sound_timer_devs);
+
+int num_sound_timers = 1;
+
+
 static int sound_alloc_audiodev(void);
 
 int sound_install_audiodrv(int vers, char *name, struct audio_driver *driver,
@@ -75,6 +105,7 @@
 	audio_init_devices();
 	return num;
 }
+EXPORT_SYMBOL(sound_install_audiodrv);
 
 int sound_install_mixer(int vers, char *name, struct mixer_operations *driver,
 	int driver_size, void *devc)
@@ -113,6 +144,7 @@
 	mixer_devs[n] = op;
 	return n;
 }
+EXPORT_SYMBOL(sound_install_mixer);
 
 void sound_unload_audiodev(int dev)
 {
@@ -122,6 +154,7 @@
 		unregister_sound_dsp((dev<<4)+3);
 	}
 }
+EXPORT_SYMBOL(sound_unload_audiodev);
 
 static int sound_alloc_audiodev(void)
 { 
@@ -144,6 +177,7 @@
 		num_midis = i + 1;
 	return i;
 }
+EXPORT_SYMBOL(sound_alloc_mididev);
 
 int sound_alloc_synthdev(void)
 {
@@ -158,6 +192,7 @@
 	}
 	return -1;
 }
+EXPORT_SYMBOL(sound_alloc_synthdev);
 
 int sound_alloc_mixerdev(void)
 {
@@ -169,6 +204,7 @@
 		num_mixers = i + 1;
 	return i;
 }
+EXPORT_SYMBOL(sound_alloc_mixerdev);
 
 int sound_alloc_timerdev(void)
 {
@@ -183,6 +219,7 @@
 	}
 	return -1;
 }
+EXPORT_SYMBOL(sound_alloc_timerdev);
 
 void sound_unload_mixerdev(int dev)
 {
@@ -192,6 +229,7 @@
 		num_mixers--;
 	}
 }
+EXPORT_SYMBOL(sound_unload_mixerdev);
 
 void sound_unload_mididev(int dev)
 {
@@ -200,15 +238,19 @@
 		unregister_sound_midi((dev<<4)+2);
 	}
 }
+EXPORT_SYMBOL(sound_unload_mididev);
 
 void sound_unload_synthdev(int dev)
 {
 	if (dev != -1)
 		synth_devs[dev] = NULL;
 }
+EXPORT_SYMBOL(sound_unload_synthdev);
 
 void sound_unload_timerdev(int dev)
 {
 	if (dev != -1)
 		sound_timer_devs[dev] = NULL;
 }
+EXPORT_SYMBOL(sound_unload_timerdev);
+
--- linux-2.6.18.noarch/sound/oss/hal2.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/hal2.c	2007-06-05 17:44:14.000000000 -0400
@@ -370,9 +370,9 @@
 	wake_up(&adc->dma_wait);
 }
 
-static irqreturn_t hal2_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t hal2_interrupt(int irq, void *dev_id)
 {
-	struct hal2_card *hal2 = (struct hal2_card*)dev_id;
+	struct hal2_card *hal2 = dev_id;
 	irqreturn_t ret = IRQ_NONE;
 
 	/* decide what caused this interrupt */
@@ -1377,7 +1377,7 @@
 	return 0;
 }
 
-static struct file_operations hal2_audio_fops = {
+static const struct file_operations hal2_audio_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= hal2_read,
@@ -1388,7 +1388,7 @@
 	.release	= hal2_release,
 };
 
-static struct file_operations hal2_mixer_fops = {
+static const struct file_operations hal2_mixer_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.ioctl		= hal2_ioctl_mixdev,
@@ -1435,10 +1435,9 @@
 	int ret = 0;
 	struct hal2_card *hal2;
 
-	hal2 = (struct hal2_card *) kmalloc(sizeof(struct hal2_card), GFP_KERNEL);
+	hal2 = kzalloc(sizeof(struct hal2_card), GFP_KERNEL);
 	if (!hal2)
 		return -ENOMEM;
-	memset(hal2, 0, sizeof(struct hal2_card));
 
 	hal2->ctl_regs = (struct hal2_ctl_regs *)hpc3->pbus_extregs[0];
 	hal2->aes_regs = (struct hal2_aes_regs *)hpc3->pbus_extregs[1];
--- linux-2.6.18.noarch/sound/oss/sb_mixer.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sb_mixer.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sb_mixer.c
+ * sound/oss/sb_mixer.c
  *
  * The low level mixer driver for the Sound Blaster compatible cards.
  */
@@ -734,7 +734,7 @@
 	if (m == -1)
 		return 0;
 
-	mixer_devs[m] = (struct mixer_operations *)kmalloc(sizeof(struct mixer_operations), GFP_KERNEL);
+	mixer_devs[m] = kmalloc(sizeof(struct mixer_operations), GFP_KERNEL);
 	if (mixer_devs[m] == NULL)
 	{
 		printk(KERN_ERR "sb_mixer: Can't allocate memory\n");
--- linux-2.6.18.noarch/sound/oss/gus_linearvol.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus_linearvol.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,18 +0,0 @@
-static unsigned short gus_linearvol[128] = {
- 0x0000, 0x08ff, 0x09ff, 0x0a80, 0x0aff, 0x0b40, 0x0b80, 0x0bc0,
- 0x0bff, 0x0c20, 0x0c40, 0x0c60, 0x0c80, 0x0ca0, 0x0cc0, 0x0ce0,
- 0x0cff, 0x0d10, 0x0d20, 0x0d30, 0x0d40, 0x0d50, 0x0d60, 0x0d70,
- 0x0d80, 0x0d90, 0x0da0, 0x0db0, 0x0dc0, 0x0dd0, 0x0de0, 0x0df0,
- 0x0dff, 0x0e08, 0x0e10, 0x0e18, 0x0e20, 0x0e28, 0x0e30, 0x0e38,
- 0x0e40, 0x0e48, 0x0e50, 0x0e58, 0x0e60, 0x0e68, 0x0e70, 0x0e78,
- 0x0e80, 0x0e88, 0x0e90, 0x0e98, 0x0ea0, 0x0ea8, 0x0eb0, 0x0eb8,
- 0x0ec0, 0x0ec8, 0x0ed0, 0x0ed8, 0x0ee0, 0x0ee8, 0x0ef0, 0x0ef8,
- 0x0eff, 0x0f04, 0x0f08, 0x0f0c, 0x0f10, 0x0f14, 0x0f18, 0x0f1c,
- 0x0f20, 0x0f24, 0x0f28, 0x0f2c, 0x0f30, 0x0f34, 0x0f38, 0x0f3c,
- 0x0f40, 0x0f44, 0x0f48, 0x0f4c, 0x0f50, 0x0f54, 0x0f58, 0x0f5c,
- 0x0f60, 0x0f64, 0x0f68, 0x0f6c, 0x0f70, 0x0f74, 0x0f78, 0x0f7c,
- 0x0f80, 0x0f84, 0x0f88, 0x0f8c, 0x0f90, 0x0f94, 0x0f98, 0x0f9c,
- 0x0fa0, 0x0fa4, 0x0fa8, 0x0fac, 0x0fb0, 0x0fb4, 0x0fb8, 0x0fbc,
- 0x0fc0, 0x0fc4, 0x0fc8, 0x0fcc, 0x0fd0, 0x0fd4, 0x0fd8, 0x0fdc,
- 0x0fe0, 0x0fe4, 0x0fe8, 0x0fec, 0x0ff0, 0x0ff4, 0x0ff8, 0x0ffc
-};
--- linux-2.6.18.noarch/sound/oss/vwsnd.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/vwsnd.c	2007-06-05 17:44:14.000000000 -0400
@@ -2233,12 +2233,12 @@
 		pcm_output(devc, underflown, 0);
 }
 
-static irqreturn_t vwsnd_audio_intr(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t vwsnd_audio_intr(int irq, void *dev_id)
 {
-	vwsnd_dev_t *devc = (vwsnd_dev_t *) dev_id;
+	vwsnd_dev_t *devc = dev_id;
 	unsigned int status;
 
-	DBGEV("(irq=%d, dev_id=0x%p, regs=0x%p)\n", irq, dev_id, regs);
+	DBGEV("(irq=%d, dev_id=0x%p)\n", irq, dev_id);
 
 	status = li_get_clear_intr_status(&devc->lith);
 	vwsnd_audio_read_intr(devc, status);
@@ -3035,7 +3035,7 @@
 	return err;
 }
 
-static struct file_operations vwsnd_audio_fops = {
+static const struct file_operations vwsnd_audio_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
 	.read =		vwsnd_audio_read,
@@ -3225,7 +3225,7 @@
 	return retval;
 }
 
-static struct file_operations vwsnd_mixer_fops = {
+static const struct file_operations vwsnd_mixer_fops = {
 	.owner =	THIS_MODULE,
 	.llseek =	no_llseek,
 	.ioctl =	vwsnd_mixer_ioctl,
--- linux-2.6.18.noarch/sound/oss/midibuf.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/midibuf.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/midibuf.c
+ * sound/oss/midibuf.c
  *
  * Device file manager for /dev/midi#
  */
@@ -414,18 +414,11 @@
 }
 
 
-void MIDIbuf_init(void)
-{
-	/* drag in midi_syms.o */
-	{
-		extern char midi_syms_symbol;
-		midi_syms_symbol = 0;
-	}
-}
-
 int MIDIbuf_avail(int dev)
 {
 	if (midi_in_buf[dev])
 		return DATA_AVAIL (midi_in_buf[dev]);
 	return 0;
 }
+EXPORT_SYMBOL(MIDIbuf_avail);
+
--- linux-2.6.18.noarch/sound/oss/sscape.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sscape.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sscape.c
+ * sound/oss/sscape.c
  *
  * Low level driver for Ensoniq SoundScape
  *
@@ -39,6 +39,7 @@
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
+#include <linux/mm.h>
 #include <linux/spinlock.h>
 
 #include "coproc.h"
--- linux-2.6.18.noarch/sound/oss/sb_mixer.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sb_mixer.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sb_mixer.h
+ * sound/oss/sb_mixer.h
  * 
  * Definitions for the SB Pro and SB16 mixers
  */
--- linux-2.6.18.noarch/sound/oss/maestro.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/maestro.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,3686 +0,0 @@
-/*****************************************************************************
- *
- *      ESS Maestro/Maestro-2/Maestro-2E driver for Linux 2.[23].x
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *	(c) Copyright 1999	 Alan Cox <alan.cox@linux.org>
- *
- *	Based heavily on SonicVibes.c:
- *      Copyright (C) 1998-1999  Thomas Sailer (sailer@ife.ee.ethz.ch)
- *
- *	Heavily modified by Zach Brown <zab@zabbo.net> based on lunch
- *	with ESS engineers.  Many thanks to Howard Kim for providing 
- *	contacts and hardware.  Honorable mention goes to Eric 
- *	Brombaugh for all sorts of things.  Best regards to the 
- *	proprietors of Hack Central for fine lodging.
- *
- *  Supported devices:
- *  /dev/dsp0-3    standard /dev/dsp device, (mostly) OSS compatible
- *  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
- *
- *  Hardware Description
- *
- *	A working Maestro setup contains the Maestro chip wired to a 
- *	codec or 2.  In the Maestro we have the APUs, the ASSP, and the
- *	Wavecache.  The APUs can be though of as virtual audio routing
- *	channels.  They can take data from a number of sources and perform
- *	basic encodings of the data.  The wavecache is a storehouse for
- *	PCM data.  Typically it deals with PCI and interracts with the
- *	APUs.  The ASSP is a wacky DSP like device that ESS is loth
- *	to release docs on.  Thankfully it isn't required on the Maestro
- *	until you start doing insane things like FM emulation and surround
- *	encoding.  The codecs are almost always AC-97 compliant codecs, 
- *	but it appears that early Maestros may have had PT101 (an ESS
- *	part?) wired to them.  The only real difference in the Maestro
- *	families is external goop like docking capability, memory for
- *	the ASSP, and initialization differences.
- *
- *  Driver Operation
- *
- *	We only drive the APU/Wavecache as typical DACs and drive the
- *	mixers in the codecs.  There are 64 APUs.  We assign 6 to each
- *	/dev/dsp? device.  2 channels for output, and 4 channels for
- *	input.
- *
- *	Each APU can do a number of things, but we only really use
- *	3 basic functions.  For playback we use them to convert PCM
- *	data fetched over PCI by the wavecahche into analog data that
- *	is handed to the codec.  One APU for mono, and a pair for stereo.
- *	When in stereo, the combination of smarts in the APU and Wavecache
- *	decide which wavecache gets the left or right channel.
- *
- *	For record we still use the old overly mono system.  For each in
- *	coming channel the data comes in from the codec, through a 'input'
- *	APU, through another rate converter APU, and then into memory via
- *	the wavecache and PCI.  If its stereo, we mash it back into LRLR in
- *	software.  The pass between the 2 APUs is supposedly what requires us
- *	to have a 512 byte buffer sitting around in wavecache/memory.
- *
- *	The wavecache makes our life even more fun.  First off, it can
- *	only address the first 28 bits of PCI address space, making it
- *	useless on quite a few architectures.  Secondly, its insane.
- *	It claims to fetch from 4 regions of PCI space, each 4 meg in length.
- *	But that doesn't really work.  You can only use 1 region.  So all our
- *	allocations have to be in 4meg of each other.  Booo.  Hiss.
- *	So we have a module parameter, dsps_order, that is the order of
- *	the number of dsps to provide.  All their buffer space is allocated
- *	on open time.  The sonicvibes OSS routines we inherited really want
- *	power of 2 buffers, so we have all those next to each other, then
- *	512 byte regions for the recording wavecaches.  This ends up
- *	wasting quite a bit of memory.  The only fixes I can see would be 
- *	getting a kernel allocator that could work in zones, or figuring out
- *	just how to coerce the WP into doing what we want.
- *
- *	The indirection of the various registers means we have to spinlock
- *	nearly all register accesses.  We have the main register indirection
- *	like the wave cache, maestro registers, etc.  Then we have beasts
- *	like the APU interface that is indirect registers gotten at through
- *	the main maestro indirection.  Ouch.  We spinlock around the actual
- *	ports on a per card basis.  This means spinlock activity at each IO
- *	operation, but the only IO operation clusters are in non critical 
- *	paths and it makes the code far easier to follow.  Interrupts are
- *	blocked while holding the locks because the int handler has to
- *	get at some of them :(.  The mixer interface doesn't, however.
- *	We also have an OSS state lock that is thrown around in a few
- *	places.
- *
- *	This driver has brute force APM suspend support.  We catch suspend
- *	notifications and stop all work being done on the chip.  Any people
- *	that try between this shutdown and the real suspend operation will
- *	be put to sleep.  When we resume we restore our software state on
- *	the chip and wake up the people that were using it.  The code thats
- *	being used now is quite dirty and assumes we're on a uni-processor
- *	machine.  Much of it will need to be cleaned up for SMP ACPI or 
- *	similar.
- *
- *	We also pay attention to PCI power management now.  The driver
- *	will power down units of the chip that it knows aren't needed.
- *	The WaveProcessor and company are only powered on when people
- *	have /dev/dsp*s open.  On removal the driver will
- *	power down the maestro entirely.  There could still be
- *	trouble with BIOSen that magically change power states 
- *	themselves, but we'll see.  
- *	
- * History
- *  v0.15 - May 21 2001 - Marcus Meissner <mm@caldera.de>
- *      Ported to Linux 2.4 PCI API. Some clean ups, global devs list
- *      removed (now using pci device driver data).
- *      PM needs to be polished still. Bumped version.
- *  (still kind of v0.14) May 13 2001 - Ben Pfaff <pfaffben@msu.edu>
- *      Add support for 978 docking and basic hardware volume control
- *  (still kind of v0.14) Nov 23 - Alan Cox <alan@redhat.com>
- *	Add clocking= for people with seriously warped hardware
- *  (still v0.14) Nov 10 2000 - Bartlomiej Zolnierkiewicz <bkz@linux-ide.org>
- *	add __init to maestro_ac97_init() and maestro_install()
- *  (still based on v0.14) Mar 29 2000 - Zach Brown <zab@redhat.com>
- *	move to 2.3 power management interface, which
- *		required hacking some suspend/resume/check paths 
- *	make static compilation work
- *  v0.14 - Jan 28 2000 - Zach Brown <zab@redhat.com>
- *	add PCI power management through ACPI regs.
- *	we now shut down on machine reboot/halt
- *	leave scary PCI config items alone (isa stuff, mostly)
- *	enable 1921s, it seems only mine was broke.
- *	fix swapped left/right pcm dac.  har har.
- *	up bob freq, increase buffers, fix pointers at underflow
- *	silly compilation problems
- *  v0.13 - Nov 18 1999 - Zach Brown <zab@redhat.com>
- *	fix nec Versas?  man would that be cool.
- *  v0.12 - Nov 12 1999 - Zach Brown <zab@redhat.com>
- *	brown bag volume max fix..
- *  v0.11 - Nov 11 1999 - Zach Brown <zab@redhat.com>
- *	use proper stereo apu decoding, mmap/write should work.
- *	make volume sliders more useful, tweak rate calculation.
- *	fix lame 8bit format reporting bug.  duh. apm apu saving buglet also
- *	fix maestro 1 clock freq "bug", remove pt101 support
- *  v0.10 - Oct 28 1999 - Zach Brown <zab@redhat.com>
- *	aha, so, sometimes the WP writes a status word to offset 0
- *	  from one of the PCMBARs.  rearrange allocation accordingly..
- *	  cheers again to Eric for being a good hacker in investigating this.
- *	Jeroen Hoogervorst submits 7500 fix out of nowhere.  yay.  :)
- *  v0.09 - Oct 23 1999 - Zach Brown <zab@redhat.com>
- *	added APM support.
- *	re-order something such that some 2Es now work.  Magic!
- *	new codec reset routine.  made some codecs come to life.
- *	fix clear_advance, sync some control with ESS.
- *	now write to all base regs to be paranoid.
- *  v0.08 - Oct 20 1999 - Zach Brown <zab@redhat.com>
- *	Fix initial buflen bug.  I am so smart.  also smp compiling..
- *	I owe Eric yet another beer: fixed recmask, igain, 
- *	  muting, and adc sync consistency.  Go Team.
- *  v0.07 - Oct 4 1999 - Zach Brown <zab@redhat.com>
- *	tweak adc/dac, formating, and stuff to allow full duplex
- *	allocate dsps memory at open() so we can fit in the wavecache window
- *	fix wavecache braindamage.  again.  no more scribbling?
- *	fix ess 1921 codec bug on some laptops.
- *	fix dumb pci scanning bug
- *	started 2.3 cleanup, redid spinlocks, little cleanups
- *  v0.06 - Sep 20 1999 - Zach Brown <zab@redhat.com>
- *	fix wavecache thinkos.  limit to 1 /dev/dsp.
- *	eric is wearing his thinking toque this week.
- *		spotted apu mode bugs and gain ramping problem
- *	don't touch weird mixer regs, make recmask optional
- *	fixed igain inversion, defaults for mixers, clean up rec_start
- *	make mono recording work.
- *	report subsystem stuff, please send reports.
- *	littles: parallel out, amp now
- *  v0.05 - Sep 17 1999 - Zach Brown <zab@redhat.com>
- *	merged and fixed up Eric's initial recording code
- *	munged format handling to catch misuse, needs rewrite.
- *	revert ring bus init, fixup shared int, add pci busmaster setting
- *	fix mixer oss interface, fix mic mute and recmask
- *	mask off unsupported mixers, reset with all 1s, modularize defaults
- *	make sure bob is running while we need it
- *	got rid of device limit, initial minimal apm hooks
- *	pull out dead code/includes, only allow multimedia/audio maestros
- *  v0.04 - Sep 01 1999 - Zach Brown <zab@redhat.com>
- *	copied memory leak fix from sonicvibes driver
- *	different ac97 reset, play with 2.0 ac97, simplify ring bus setup
- *	bob freq code, region sanity, jitter sync fix; all from Eric 
- *
- * TODO
- *	fix bob frequency
- *	endianness
- *	do smart things with ac97 2.0 bits.
- *	dual codecs
- *	leave 54->61 open
- *
- *	it also would be fun to have a mode that would not use pci dma at all
- *	but would copy into the wavecache on board memory and use that 
- *	on architectures that don't like the maestro's pci dma ickiness.
- */
-
-/*****************************************************************************/
-
-#include <linux/module.h>
-#include <linux/sched.h>
-#include <linux/smp_lock.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-#include <linux/ioport.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/spinlock.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/poll.h>
-#include <linux/reboot.h>
-#include <linux/bitops.h>
-#include <linux/wait.h>
-#include <linux/mutex.h>
-
-
-#include <asm/current.h>
-#include <asm/dma.h>
-#include <asm/io.h>
-#include <asm/page.h>
-#include <asm/uaccess.h>
-
-#include "maestro.h"
-
-static struct pci_driver maestro_pci_driver;
-
-/* --------------------------------------------------------------------- */
-
-#define M_DEBUG 1
-
-#ifdef M_DEBUG
-static int debug;
-#define M_printk(args...) {if (debug) printk(args);}
-#else
-#define M_printk(x)
-#endif
-
-/* we try to setup 2^(dsps_order) /dev/dsp devices */
-static int dsps_order;
-/* whether or not we mess around with power management */
-static int use_pm=2; /* set to 1 for force */
-/* clocking for broken hardware - a few laptops seem to use a 50Khz clock
-	ie insmod with clocking=50000 or so */
-	
-static int clocking=48000;
-
-MODULE_AUTHOR("Zach Brown <zab@zabbo.net>, Alan Cox <alan@redhat.com>");
-MODULE_DESCRIPTION("ESS Maestro Driver");
-MODULE_LICENSE("GPL");
-
-#ifdef M_DEBUG
-module_param(debug, bool, 0644);
-#endif
-module_param(dsps_order, int, 0);
-module_param(use_pm, int, 0);
-module_param(clocking, int, 0);
-
-/* --------------------------------------------------------------------- */
-#define DRIVER_VERSION "0.15"
-
-#ifndef PCI_VENDOR_ESS
-#define PCI_VENDOR_ESS			0x125D
-#define PCI_DEVICE_ID_ESS_ESS1968	0x1968		/* Maestro 2	*/
-#define PCI_DEVICE_ID_ESS_ESS1978      	0x1978		/* Maestro 2E	*/
-
-#define PCI_VENDOR_ESS_OLD		0x1285		/* Platform Tech, 
-						the people the maestro 
-						was bought from */
-#define PCI_DEVICE_ID_ESS_ESS0100	0x0100		/* maestro 1 */
-#endif /* PCI_VENDOR_ESS */
-
-#define ESS_CHAN_HARD		0x100
-
-/* NEC Versas ? */
-#define NEC_VERSA_SUBID1	0x80581033
-#define NEC_VERSA_SUBID2	0x803c1033
-
-
-/* changed so that I could actually find all the
-	references and fix them up.  it's a little more readable now. */
-#define ESS_FMT_STEREO	0x01
-#define ESS_FMT_16BIT	0x02
-#define ESS_FMT_MASK	0x03
-#define ESS_DAC_SHIFT	0   
-#define ESS_ADC_SHIFT	4
-
-#define ESS_STATE_MAGIC		0x125D1968
-#define ESS_CARD_MAGIC		0x19283746
-
-#define DAC_RUNNING		1
-#define ADC_RUNNING		2
-
-#define MAX_DSP_ORDER	2
-#define MAX_DSPS	(1<<MAX_DSP_ORDER)
-#define NR_DSPS		(1<<dsps_order)
-#define NR_IDRS		32
-
-#define NR_APUS		64
-#define NR_APU_REGS	16
-
-/* acpi states */
-enum {
-	ACPI_D0=0,
-	ACPI_D1,
-	ACPI_D2,
-	ACPI_D3
-};
-
-/* bits in the acpi masks */
-#define ACPI_12MHZ	( 1 << 15)
-#define ACPI_24MHZ	( 1 << 14)
-#define ACPI_978	( 1 << 13)
-#define ACPI_SPDIF	( 1 << 12)
-#define ACPI_GLUE	( 1 << 11)
-#define ACPI__10	( 1 << 10) /* reserved */
-#define ACPI_PCIINT	( 1 << 9)
-#define ACPI_HV		( 1 << 8) /* hardware volume */
-#define ACPI_GPIO	( 1 << 7)
-#define ACPI_ASSP	( 1 << 6)
-#define ACPI_SB		( 1 << 5) /* sb emul */
-#define ACPI_FM		( 1 << 4) /* fm emul */
-#define ACPI_RB		( 1 << 3) /* ringbus / aclink */
-#define ACPI_MIDI	( 1 << 2) 
-#define ACPI_GP		( 1 << 1) /* game port */
-#define ACPI_WP		( 1 << 0) /* wave processor */
-
-#define ACPI_ALL	(0xffff)
-#define ACPI_SLEEP	(~(ACPI_SPDIF|ACPI_ASSP|ACPI_SB|ACPI_FM| \
-			ACPI_MIDI|ACPI_GP|ACPI_WP))
-#define ACPI_NONE	(ACPI__10)
-
-/* these masks indicate which units we care about at
-	which states */
-static u16 acpi_state_mask[] = {
-	[ACPI_D0] = ACPI_ALL,
-	[ACPI_D1] = ACPI_SLEEP,
-	[ACPI_D2] = ACPI_SLEEP,
-	[ACPI_D3] = ACPI_NONE
-};
-
-static char version[] __devinitdata =
-KERN_INFO "maestro: version " DRIVER_VERSION " time " __TIME__ " " __DATE__ "\n";
-
-
-
-static const unsigned sample_size[] = { 1, 2, 2, 4 };
-static const unsigned sample_shift[] = { 0, 1, 1, 2 };
-
-enum card_types_t {
-	TYPE_MAESTRO,
-	TYPE_MAESTRO2,
-	TYPE_MAESTRO2E
-};
-
-static const char *card_names[]={
-	[TYPE_MAESTRO] = "ESS Maestro",
-	[TYPE_MAESTRO2] = "ESS Maestro 2",
-	[TYPE_MAESTRO2E] = "ESS Maestro 2E"
-};
-
-static int clock_freq[]={
-	[TYPE_MAESTRO] = (49152000L / 1024L),
-	[TYPE_MAESTRO2] = (50000000L / 1024L),
-	[TYPE_MAESTRO2E] = (50000000L / 1024L)
-};
-
-static int maestro_notifier(struct notifier_block *nb, unsigned long event, void *buf);
-
-static struct notifier_block maestro_nb = {maestro_notifier, NULL, 0};
-
-/* --------------------------------------------------------------------- */
-
-struct ess_state {
-	unsigned int magic;
-	/* FIXME: we probably want submixers in here, but only one record pair */
-	u8 apu[6];		/* l/r output, l/r intput converters, l/r input apus */
-	u8 apu_mode[6];		/* Running mode for this APU */
-	u8 apu_pan[6];		/* Panning setup for this APU */
-	u32 apu_base[6];	/* base address for this apu */
-	struct ess_card *card;	/* Card info */
-	/* wave stuff */
-	unsigned int rateadc, ratedac;
-	unsigned char fmt, enable;
-
-	int index;
-
-	/* this locks around the oss state in the driver */
-	spinlock_t lock;
-	/* only let 1 be opening at a time */
-	struct mutex open_mutex;
-	wait_queue_head_t open_wait;
-	mode_t open_mode;
-
-	/* soundcore stuff */
-	int dev_audio;
-
-	struct dmabuf {
-		void *rawbuf;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-		/* XXX zab - swptr only in here so that it can be referenced by
-			clear_advance, as far as I can tell :( */
-		unsigned hwptr, swptr;
-		unsigned total_bytes;
-		int count;
-		unsigned error; /* over/underrun */
-		wait_queue_head_t wait;
-		/* redundant, but makes calculations easier */
-		unsigned fragsize;
-		unsigned dmasize;
-		unsigned fragsamples;
-		/* OSS stuff */
-		unsigned mapped:1;
-		unsigned ready:1;	/* our oss buffers are ready to go */
-		unsigned endcleared:1;
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-		u16 base;		/* Offset for ptr */
-	} dma_dac, dma_adc;
-
-	/* pointer to each dsp?s piece of the apu->src buffer page */
-	void *mixbuf;
-
-};
-	
-struct ess_card {
-	unsigned int magic;
-
-	/* We keep maestro cards in a linked list */
-	struct ess_card *next;
-
-	int dev_mixer;
-
-	int card_type;
-
-	/* as most of this is static,
-		perhaps it should be a pointer to a global struct */
-	struct mixer_goo {
-		int modcnt;
-		int supported_mixers;
-		int stereo_mixers;
-		int record_sources;
-		/* the caller must guarantee arg sanity before calling these */
-/*		int (*read_mixer)(struct ess_card *card, int index);*/
-		void (*write_mixer)(struct ess_card *card,int mixer, unsigned int left,unsigned int right);
-		int (*recmask_io)(struct ess_card *card,int rw,int mask);
-		unsigned int mixer_state[SOUND_MIXER_NRDEVICES];
-	} mix;
-	
-	int power_regs;
-		
-	int in_suspend;
-	wait_queue_head_t suspend_queue;
-
-	struct ess_state channels[MAX_DSPS];
-	u16 maestro_map[NR_IDRS];	/* Register map */
-	/* we have to store this junk so that we can come back from a
-		suspend */
-	u16 apu_map[NR_APUS][NR_APU_REGS];	/* contents of apu regs */
-
-	/* this locks around the physical registers on the card */
-	spinlock_t lock;
-
-	/* memory for this card.. wavecache limited :(*/
-	void *dmapages;
-	int dmaorder;
-
-	/* hardware resources */
-	struct pci_dev *pcidev;
-	u32 iobase;
-	u32 irq;
-
-	int bob_freq;
-	char dsps_open;
-
-	int dock_mute_vol;
-};
-
-static void set_mixer(struct ess_card *card,unsigned int mixer, unsigned int val );
-
-static unsigned 
-ld2(unsigned int x)
-{
-	unsigned r = 0;
-	
-	if (x >= 0x10000) {
-		x >>= 16;
-		r += 16;
-	}
-	if (x >= 0x100) {
-		x >>= 8;
-		r += 8;
-	}
-	if (x >= 0x10) {
-		x >>= 4;
-		r += 4;
-	}
-	if (x >= 4) {
-		x >>= 2;
-		r += 2;
-	}
-	if (x >= 2)
-		r++;
-	return r;
-}
-
-
-/* --------------------------------------------------------------------- */
-
-static void check_suspend(struct ess_card *card);
-
-/* --------------------------------------------------------------------- */
-
-
-/*
- *	ESS Maestro AC97 codec programming interface.
- */
-	 
-static void maestro_ac97_set(struct ess_card *card, u8 cmd, u16 val)
-{
-	int io = card->iobase;
-	int i;
-	/*
-	 *	Wait for the codec bus to be free 
-	 */
-
-	check_suspend(card);
-	 
-	for(i=0;i<10000;i++)
-	{
-		if(!(inb(io+ESS_AC97_INDEX)&1)) 
-			break;
-	}
-	/*
-	 *	Write the bus
-	 */ 
-	outw(val, io+ESS_AC97_DATA);
-	mdelay(1);
-	outb(cmd, io+ESS_AC97_INDEX);
-	mdelay(1);
-}
-
-static u16 maestro_ac97_get(struct ess_card *card, u8 cmd)
-{
-	int io = card->iobase;
-	int sanity=10000;
-	u16 data;
-	int i;
-	
-	check_suspend(card);
-	/*
-	 *	Wait for the codec bus to be free 
-	 */
-	 
-	for(i=0;i<10000;i++)
-	{
-		if(!(inb(io+ESS_AC97_INDEX)&1))
-			break;
-	}
-
-	outb(cmd|0x80, io+ESS_AC97_INDEX);
-	mdelay(1);
-	
-	while(inb(io+ESS_AC97_INDEX)&1)
-	{
-		sanity--;
-		if(!sanity)
-		{
-			printk(KERN_ERR "maestro: ac97 codec timeout reading 0x%x.\n",cmd);
-			return 0;
-		}
-	}
-	data=inw(io+ESS_AC97_DATA);
-	mdelay(1);
-	return data;
-}
-
-/* OSS interface to the ac97s.. */
-
-#define AC97_STEREO_MASK (SOUND_MASK_VOLUME|\
-	SOUND_MASK_PCM|SOUND_MASK_LINE|SOUND_MASK_CD|\
-	SOUND_MASK_VIDEO|SOUND_MASK_LINE1|SOUND_MASK_IGAIN)
-
-#define AC97_SUPPORTED_MASK (AC97_STEREO_MASK | \
-	SOUND_MASK_BASS|SOUND_MASK_TREBLE|SOUND_MASK_MIC|\
-	SOUND_MASK_SPEAKER)
-
-#define AC97_RECORD_MASK (SOUND_MASK_MIC|\
-	SOUND_MASK_CD| SOUND_MASK_VIDEO| SOUND_MASK_LINE1| SOUND_MASK_LINE|\
-	SOUND_MASK_PHONEIN)
-
-#define supported_mixer(CARD,FOO) ( CARD->mix.supported_mixers & (1<<FOO) )
-
-/* this table has default mixer values for all OSS mixers.
-	be sure to fill it in if you add oss mixers
-	to anyone's supported mixer defines */
-
-static unsigned int mixer_defaults[SOUND_MIXER_NRDEVICES] = {
-	[SOUND_MIXER_VOLUME] =          0x3232,
-	[SOUND_MIXER_BASS] =            0x3232,
-	[SOUND_MIXER_TREBLE] =          0x3232,
-	[SOUND_MIXER_SPEAKER] =         0x3232,
-	[SOUND_MIXER_MIC] =     0x8000, /* annoying */
-	[SOUND_MIXER_LINE] =    0x3232,
-	[SOUND_MIXER_CD] =      0x3232,
-	[SOUND_MIXER_VIDEO] =   0x3232,
-	[SOUND_MIXER_LINE1] =   0x3232,
-	[SOUND_MIXER_PCM] =             0x3232,
-	[SOUND_MIXER_IGAIN] =           0x3232
-};
-	
-static struct ac97_mixer_hw {
-	unsigned char offset;
-	int scale;
-} ac97_hw[SOUND_MIXER_NRDEVICES]= {
-	[SOUND_MIXER_VOLUME]	=	{0x02,63},
-	[SOUND_MIXER_BASS]	=	{0x08,15},
-	[SOUND_MIXER_TREBLE]	=	{0x08,15},
-	[SOUND_MIXER_SPEAKER]	=	{0x0a,15},
-	[SOUND_MIXER_MIC]	=	{0x0e,31},
-	[SOUND_MIXER_LINE]	=	{0x10,31},
-	[SOUND_MIXER_CD]	=	{0x12,31},
-	[SOUND_MIXER_VIDEO]	=	{0x14,31},
-	[SOUND_MIXER_LINE1]	=	{0x16,31},
-	[SOUND_MIXER_PCM]	=	{0x18,31},
-	[SOUND_MIXER_IGAIN]	=	{0x1c,15}
-};
-
-#if 0 /* *shrug* removed simply because we never used it.
-		feel free to implement again if needed */
-
-/* reads the given OSS mixer from the ac97
-	the caller must have insured that the ac97 knows
-	about that given mixer, and should be holding a
-	spinlock for the card */
-static int ac97_read_mixer(struct ess_card *card, int mixer) 
-{
-	u16 val;
-	int ret=0;
-	struct ac97_mixer_hw *mh = &ac97_hw[mixer];
-
-	val = maestro_ac97_get(card, mh->offset);
-
-	if(AC97_STEREO_MASK & (1<<mixer)) {
-		/* nice stereo mixers .. */
-		int left,right;
-
-		left = (val >> 8)  & 0x7f;
-		right = val  & 0x7f;
-
-		if (mixer == SOUND_MIXER_IGAIN) {
-			right = (right * 100) / mh->scale;
-			left = (left * 100) / mh->scale;
-		} else {
-			right = 100 - ((right * 100) / mh->scale);
-			left = 100 - ((left * 100) / mh->scale);
-		}
-
-		ret = left | (right << 8);
-	} else if (mixer == SOUND_MIXER_SPEAKER) {
-		ret = 100 - ((((val & 0x1e)>>1) * 100) / mh->scale);
-	} else if (mixer == SOUND_MIXER_MIC) {
-		ret = 100 - (((val & 0x1f) * 100) / mh->scale);
-	/*  the low bit is optional in the tone sliders and masking
-		it lets is avoid the 0xf 'bypass'.. */
-	} else if (mixer == SOUND_MIXER_BASS) {
-		ret = 100 - ((((val >> 8) & 0xe) * 100) / mh->scale);
-	} else if (mixer == SOUND_MIXER_TREBLE) {
-		ret = 100 - (((val & 0xe) * 100) / mh->scale);
-	}
-
-	M_printk("read mixer %d (0x%x) %x -> %x\n",mixer,mh->offset,val,ret);
-
-	return ret;
-}
-#endif
-
-/* write the OSS encoded volume to the given OSS encoded mixer,
-	again caller's job to make sure all is well in arg land,
-	call with spinlock held */
-	
-/* linear scale -> log */
-static unsigned char lin2log[101] = 
-{
-0, 0 , 15 , 23 , 30 , 34 , 38 , 42 , 45 , 47 ,
-50 , 52 , 53 , 55 , 57 , 58 , 60 , 61 , 62 ,
-63 , 65 , 66 , 67 , 68 , 69 , 69 , 70 , 71 ,
-72 , 73 , 73 , 74 , 75 , 75 , 76 , 77 , 77 ,
-78 , 78 , 79 , 80 , 80 , 81 , 81 , 82 , 82 ,
-83 , 83 , 84 , 84 , 84 , 85 , 85 , 86 , 86 ,
-87 , 87 , 87 , 88 , 88 , 88 , 89 , 89 , 89 ,
-90 , 90 , 90 , 91 , 91 , 91 , 92 , 92 , 92 ,
-93 , 93 , 93 , 94 , 94 , 94 , 94 , 95 , 95 ,
-95 , 95 , 96 , 96 , 96 , 96 , 97 , 97 , 97 ,
-97 , 98 , 98 , 98 , 98 , 99 , 99 , 99 , 99 , 99 
-};
-
-static void ac97_write_mixer(struct ess_card *card,int mixer, unsigned int left, unsigned int right)
-{
-	u16 val=0;
-	struct ac97_mixer_hw *mh = &ac97_hw[mixer];
-
-	M_printk("wrote mixer %d (0x%x) %d,%d",mixer,mh->offset,left,right);
-
-	if(AC97_STEREO_MASK & (1<<mixer)) {
-		/* stereo mixers, mute them if we can */
-
-		if (mixer == SOUND_MIXER_IGAIN) {
-			/* igain's slider is reversed.. */
-			right = (right * mh->scale) / 100;
-			left = (left * mh->scale) / 100;
-			if ((left == 0) && (right == 0))
-				val |= 0x8000;
-		} else if (mixer == SOUND_MIXER_PCM || mixer == SOUND_MIXER_CD) {
-			/* log conversion seems bad for them */
-			if ((left == 0) && (right == 0))
-				val = 0x8000;
-			right = ((100 - right) * mh->scale) / 100;
-			left = ((100 - left) * mh->scale) / 100;
-		} else {
-			/* log conversion for the stereo controls */
-			if((left == 0) && (right == 0))
-				val = 0x8000;
-			right = ((100 - lin2log[right]) * mh->scale) / 100;
-			left = ((100 - lin2log[left]) * mh->scale) / 100;
-		}
-
-		val |= (left << 8) | right;
-
-	} else if (mixer == SOUND_MIXER_SPEAKER) {
-		val = (((100 - left) * mh->scale) / 100) << 1;
-	} else if (mixer == SOUND_MIXER_MIC) {
-		val = maestro_ac97_get(card, mh->offset) & ~0x801f;
-		val |= (((100 - left) * mh->scale) / 100);
-	/*  the low bit is optional in the tone sliders and masking
-		it lets is avoid the 0xf 'bypass'.. */
-	} else if (mixer == SOUND_MIXER_BASS) {
-		val = maestro_ac97_get(card , mh->offset) & ~0x0f00;
-		val |= ((((100 - left) * mh->scale) / 100) << 8) & 0x0e00;
-	} else if (mixer == SOUND_MIXER_TREBLE)  {
-		val = maestro_ac97_get(card , mh->offset) & ~0x000f;
-		val |= (((100 - left) * mh->scale) / 100) & 0x000e;
-	}
-
-	maestro_ac97_set(card , mh->offset, val);
-	
-	M_printk(" -> %x\n",val);
-}
-
-/* the following tables allow us to go from 
-	OSS <-> ac97 quickly. */
-
-enum ac97_recsettings {
-	AC97_REC_MIC=0,
-	AC97_REC_CD,
-	AC97_REC_VIDEO,
-	AC97_REC_AUX,
-	AC97_REC_LINE,
-	AC97_REC_STEREO, /* combination of all enabled outputs..  */
-	AC97_REC_MONO,        /*.. or the mono equivalent */
-	AC97_REC_PHONE        
-};
-
-static unsigned int ac97_oss_mask[] = {
-	[AC97_REC_MIC] = SOUND_MASK_MIC, 
-	[AC97_REC_CD] = SOUND_MASK_CD, 
-	[AC97_REC_VIDEO] = SOUND_MASK_VIDEO, 
-	[AC97_REC_AUX] = SOUND_MASK_LINE1, 
-	[AC97_REC_LINE] = SOUND_MASK_LINE, 
-	[AC97_REC_PHONE] = SOUND_MASK_PHONEIN
-};
-
-/* indexed by bit position */
-static unsigned int ac97_oss_rm[] = {
-	[SOUND_MIXER_MIC] = AC97_REC_MIC,
-	[SOUND_MIXER_CD] = AC97_REC_CD,
-	[SOUND_MIXER_VIDEO] = AC97_REC_VIDEO,
-	[SOUND_MIXER_LINE1] = AC97_REC_AUX,
-	[SOUND_MIXER_LINE] = AC97_REC_LINE,
-	[SOUND_MIXER_PHONEIN] = AC97_REC_PHONE
-};
-	
-/* read or write the recmask 
-	the ac97 can really have left and right recording
-	inputs independently set, but OSS doesn't seem to 
-	want us to express that to the user. 
-	the caller guarantees that we have a supported bit set,
-	and they must be holding the card's spinlock */
-static int 
-ac97_recmask_io(struct ess_card *card, int read, int mask) 
-{
-	unsigned int val = ac97_oss_mask[ maestro_ac97_get(card, 0x1a) & 0x7 ];
-
-	if (read) return val;
-
-	/* oss can have many inputs, maestro can't.  try
-		to pick the 'new' one */
-
-	if (mask != val) mask &= ~val;
-
-	val = ffs(mask) - 1; 
-	val = ac97_oss_rm[val];
-	val |= val << 8;  /* set both channels */
-
-	M_printk("maestro: setting ac97 recmask to 0x%x\n",val);
-
-	maestro_ac97_set(card,0x1a,val);
-
-	return 0;
-};
-
-/*
- *	The Maestro can be wired to a standard AC97 compliant codec
- *	(see www.intel.com for the pdf's on this), or to a PT101 codec
- *	which appears to be the ES1918 (data sheet on the esstech.com.tw site)
- *
- *	The PT101 setup is untested.
- */
- 
-static u16 __init maestro_ac97_init(struct ess_card *card)
-{
-	u16 vend1, vend2, caps;
-
-	card->mix.supported_mixers = AC97_SUPPORTED_MASK;
-	card->mix.stereo_mixers = AC97_STEREO_MASK;
-	card->mix.record_sources = AC97_RECORD_MASK;
-/*	card->mix.read_mixer = ac97_read_mixer;*/
-	card->mix.write_mixer = ac97_write_mixer;
-	card->mix.recmask_io = ac97_recmask_io;
-
-	vend1 = maestro_ac97_get(card, 0x7c);
-	vend2 = maestro_ac97_get(card, 0x7e);
-
-	caps = maestro_ac97_get(card, 0x00);
-
-	printk(KERN_INFO "maestro: AC97 Codec detected: v: 0x%2x%2x caps: 0x%x pwr: 0x%x\n",
-		vend1,vend2,caps,maestro_ac97_get(card,0x26) & 0xf);
-
-	if (! (caps & 0x4) ) {
-		/* no bass/treble nobs */
-		card->mix.supported_mixers &= ~(SOUND_MASK_BASS|SOUND_MASK_TREBLE);
-	}
-
-	/* XXX endianness, dork head. */
-	/* vendor specifc bits.. */
-	switch ((long)(vend1 << 16) | vend2) {
-	case 0x545200ff:	/* TriTech */
-		/* no idea what this does */
-		maestro_ac97_set(card,0x2a,0x0001);
-		maestro_ac97_set(card,0x2c,0x0000);
-		maestro_ac97_set(card,0x2c,0xffff);
-		break;
-#if 0	/* i thought the problems I was seeing were with
-	the 1921, but apparently they were with the pci board
-	it was on, so this code is commented out.
-	 lets see if this holds true. */
-	case 0x83847609:	/* ESS 1921 */
-		/* writing to 0xe (mic) or 0x1a (recmask) seems
-			to hang this codec */
-		card->mix.supported_mixers &= ~(SOUND_MASK_MIC);
-		card->mix.record_sources = 0;
-		card->mix.recmask_io = NULL;
-#if 0	/* don't ask.  I have yet to see what these actually do. */
-		maestro_ac97_set(card,0x76,0xABBA); /* o/~ Take a chance on me o/~ */
-		udelay(20);
-		maestro_ac97_set(card,0x78,0x3002);
-		udelay(20);
-		maestro_ac97_set(card,0x78,0x3802);
-		udelay(20);
-#endif
-		break;
-#endif
-	default: break;
-	}
-
-	maestro_ac97_set(card, 0x1E, 0x0404);
-	/* null misc stuff */
-	maestro_ac97_set(card, 0x20, 0x0000);
-
-	return 0;
-}
-
-#if 0  /* there has been 1 person on the planet with a pt101 that we
-	know of.  If they care, they can put this back in :) */
-static u16 maestro_pt101_init(struct ess_card *card,int iobase)
-{
-	printk(KERN_INFO "maestro: PT101 Codec detected, initializing but _not_ installing mixer device.\n");
-	/* who knows.. */
-	maestro_ac97_set(iobase, 0x2A, 0x0001);
-	maestro_ac97_set(iobase, 0x2C, 0x0000);
-	maestro_ac97_set(iobase, 0x2C, 0xFFFF);
-	maestro_ac97_set(iobase, 0x10, 0x9F1F);
-	maestro_ac97_set(iobase, 0x12, 0x0808);
-	maestro_ac97_set(iobase, 0x14, 0x9F1F);
-	maestro_ac97_set(iobase, 0x16, 0x9F1F);
-	maestro_ac97_set(iobase, 0x18, 0x0404);
-	maestro_ac97_set(iobase, 0x1A, 0x0000);
-	maestro_ac97_set(iobase, 0x1C, 0x0000);
-	maestro_ac97_set(iobase, 0x02, 0x0404);
-	maestro_ac97_set(iobase, 0x04, 0x0808);
-	maestro_ac97_set(iobase, 0x0C, 0x801F);
-	maestro_ac97_set(iobase, 0x0E, 0x801F);
-	return 0;
-}
-#endif
-
-/* this is very magic, and very slow.. */
-static void 
-maestro_ac97_reset(int ioaddr, struct pci_dev *pcidev)
-{
-	u16 save_68;
-	u16 w;
-	u32 vend;
-
-	outw( inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);
-	outw( inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);
-	outw( inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
-
-	/* reset the first codec */
-	outw(0x0000,  ioaddr+0x36);
-	save_68 = inw(ioaddr+0x68);
-	pci_read_config_word(pcidev, 0x58, &w);	/* something magical with gpio and bus arb. */
-	pci_read_config_dword(pcidev, PCI_SUBSYSTEM_VENDOR_ID, &vend);
-	if( w & 0x1)
-		save_68 |= 0x10;
-	outw(0xfffe, ioaddr + 0x64);	/* tickly gpio 0.. */
-	outw(0x0001, ioaddr + 0x68);
-	outw(0x0000, ioaddr + 0x60);
-	udelay(20);
-	outw(0x0001, ioaddr + 0x60);
-	mdelay(20);
-
-	outw(save_68 | 0x1, ioaddr + 0x68);	/* now restore .. */
-	outw( (inw(ioaddr + 0x38) & 0xfffc)|0x1, ioaddr + 0x38);
-	outw( (inw(ioaddr + 0x3a) & 0xfffc)|0x1, ioaddr + 0x3a);
-	outw( (inw(ioaddr + 0x3c) & 0xfffc)|0x1, ioaddr + 0x3c);
-
-	/* now the second codec */
-	outw(0x0000,  ioaddr+0x36);
-	outw(0xfff7, ioaddr + 0x64);
-	save_68 = inw(ioaddr+0x68);
-	outw(0x0009, ioaddr + 0x68);
-	outw(0x0001, ioaddr + 0x60);
-	udelay(20);
-	outw(0x0009, ioaddr + 0x60);
-	mdelay(500);	/* .. ouch.. */
-	outw( inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);
-	outw( inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);
-	outw( inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
-
-#if 0 /* the loop here needs to be much better if we want it.. */
-	M_printk("trying software reset\n");
-	/* try and do a software reset */
-	outb(0x80|0x7c, ioaddr + 0x30);
-	for (w=0; ; w++) {
-		if ((inw(ioaddr+ 0x30) & 1) == 0) {
-			if(inb(ioaddr + 0x32) !=0) break;
-
-			outb(0x80|0x7d, ioaddr + 0x30);
-			if (((inw(ioaddr+ 0x30) & 1) == 0) && (inb(ioaddr + 0x32) !=0)) break;
-			outb(0x80|0x7f, ioaddr + 0x30);
-			if (((inw(ioaddr+ 0x30) & 1) == 0) && (inb(ioaddr + 0x32) !=0)) break;
-		}
-
-		if( w > 10000) {
-			outb( inb(ioaddr + 0x37) | 0x08, ioaddr + 0x37);  /* do a software reset */
-			mdelay(500); /* oh my.. */
-			outb( inb(ioaddr + 0x37) & ~0x08, ioaddr + 0x37);  
-			udelay(1);
-			outw( 0x80, ioaddr+0x30);
-			for(w = 0 ; w < 10000; w++) {
-				if((inw(ioaddr + 0x30) & 1) ==0) break;
-			}
-		}
-	}
-#endif
-	if ( vend == NEC_VERSA_SUBID1 || vend == NEC_VERSA_SUBID2) {
-		/* turn on external amp? */
-		outw(0xf9ff, ioaddr + 0x64);
-		outw(inw(ioaddr+0x68) | 0x600, ioaddr + 0x68);
-		outw(0x0209, ioaddr + 0x60);
-	}
-
-	/* Turn on the 978 docking chip.
-	   First frob the "master output enable" bit,
-	   then set most of the playback volume control registers to max. */
-	outb(inb(ioaddr+0xc0)|(1<<5), ioaddr+0xc0);
-	outb(0xff, ioaddr+0xc3);
-	outb(0xff, ioaddr+0xc4);
-	outb(0xff, ioaddr+0xc6);
-	outb(0xff, ioaddr+0xc8);
-	outb(0x3f, ioaddr+0xcf);
-	outb(0x3f, ioaddr+0xd0);
-}
-/*
- *	Indirect register access. Not all registers are readable so we
- *	need to keep register state ourselves
- */
- 
-#define WRITEABLE_MAP	0xEFFFFF
-#define READABLE_MAP	0x64003F
-
-/*
- *	The Maestro engineers were a little indirection happy. These indirected
- *	registers themselves include indirect registers at another layer
- */
-
-static void __maestro_write(struct ess_card *card, u16 reg, u16 data)
-{
-	long ioaddr = card->iobase;
-
-	outw(reg, ioaddr+0x02);
-	outw(data, ioaddr+0x00);
-	if( reg >= NR_IDRS) printk("maestro: IDR %d out of bounds!\n",reg);
-	else card->maestro_map[reg]=data;
-
-}
- 
-static void maestro_write(struct ess_state *s, u16 reg, u16 data)
-{
-	unsigned long flags;
-
-	check_suspend(s->card);
-	spin_lock_irqsave(&s->card->lock,flags);
-
-	__maestro_write(s->card,reg,data);
-
-	spin_unlock_irqrestore(&s->card->lock,flags);
-}
-
-static u16 __maestro_read(struct ess_card *card, u16 reg)
-{
-	long ioaddr = card->iobase;
-
-	outw(reg, ioaddr+0x02);
-	return card->maestro_map[reg]=inw(ioaddr+0x00);
-}
-
-static u16 maestro_read(struct ess_state *s, u16 reg)
-{
-	if(READABLE_MAP & (1<<reg))
-	{
-		unsigned long flags;
-		check_suspend(s->card);
-		spin_lock_irqsave(&s->card->lock,flags);
-
-		__maestro_read(s->card,reg);
-
-		spin_unlock_irqrestore(&s->card->lock,flags);
-	}
-	return s->card->maestro_map[reg];
-}
-
-/*
- *	These routines handle accessing the second level indirections to the
- *	wave ram.
- */
-
-/*
- *	The register names are the ones ESS uses (see 104T31.ZIP)
- */
- 
-#define IDR0_DATA_PORT		0x00
-#define IDR1_CRAM_POINTER	0x01
-#define IDR2_CRAM_DATA		0x02
-#define IDR3_WAVE_DATA		0x03
-#define IDR4_WAVE_PTR_LOW	0x04
-#define IDR5_WAVE_PTR_HI	0x05
-#define IDR6_TIMER_CTRL		0x06
-#define IDR7_WAVE_ROMRAM	0x07
-
-static void apu_index_set(struct ess_card *card, u16 index)
-{
-	int i;
-	__maestro_write(card, IDR1_CRAM_POINTER, index);
-	for(i=0;i<1000;i++)
-		if(__maestro_read(card, IDR1_CRAM_POINTER)==index)
-			return;
-	printk(KERN_WARNING "maestro: APU register select failed.\n");
-}
-
-static void apu_data_set(struct ess_card *card, u16 data)
-{
-	int i;
-	for(i=0;i<1000;i++)
-	{
-		if(__maestro_read(card, IDR0_DATA_PORT)==data)
-			return;
-		__maestro_write(card, IDR0_DATA_PORT, data);
-	}
-}
-
-/*
- *	This is the public interface for APU manipulation. It handles the
- *	interlock to avoid two APU writes in parallel etc. Don't diddle
- *	directly with the stuff above.
- */
-
-static void apu_set_register(struct ess_state *s, u16 channel, u8 reg, u16 data)
-{
-	unsigned long flags;
-	
-	check_suspend(s->card);
-
-	if(channel&ESS_CHAN_HARD)
-		channel&=~ESS_CHAN_HARD;
-	else
-	{
-		if(channel>5)
-			printk("BAD CHANNEL %d.\n",channel);
-		else
-			channel = s->apu[channel];
-		/* store based on real hardware apu/reg */
-		s->card->apu_map[channel][reg]=data;
-	}
-	reg|=(channel<<4);
-	
-	/* hooray for double indirection!! */
-	spin_lock_irqsave(&s->card->lock,flags);
-
-	apu_index_set(s->card, reg);
-	apu_data_set(s->card, data);
-
-	spin_unlock_irqrestore(&s->card->lock,flags);
-}
-
-static u16 apu_get_register(struct ess_state *s, u16 channel, u8 reg)
-{
-	unsigned long flags;
-	u16 v;
-	
-	check_suspend(s->card);
-
-	if(channel&ESS_CHAN_HARD)
-		channel&=~ESS_CHAN_HARD;
-	else
-		channel = s->apu[channel];
-
-	reg|=(channel<<4);
-	
-	spin_lock_irqsave(&s->card->lock,flags);
-
-	apu_index_set(s->card, reg);
-	v=__maestro_read(s->card, IDR0_DATA_PORT);
-
-	spin_unlock_irqrestore(&s->card->lock,flags);
-	return v;
-}
-
-
-/*
- *	The wavecache buffers between the APUs and
- *	pci bus mastering
- */
- 
-static void wave_set_register(struct ess_state *s, u16 reg, u16 value)
-{
-	long ioaddr = s->card->iobase;
-	unsigned long flags;
-	check_suspend(s->card);
-	
-	spin_lock_irqsave(&s->card->lock,flags);
-
-	outw(reg, ioaddr+0x10);
-	outw(value, ioaddr+0x12);
-
-	spin_unlock_irqrestore(&s->card->lock,flags);
-}
-
-static u16 wave_get_register(struct ess_state *s, u16 reg)
-{
-	long ioaddr = s->card->iobase;
-	unsigned long flags;
-	u16 value;
-	check_suspend(s->card);
-	
-	spin_lock_irqsave(&s->card->lock,flags);
-	outw(reg, ioaddr+0x10);
-	value=inw(ioaddr+0x12);
-	spin_unlock_irqrestore(&s->card->lock,flags);
-	
-	return value;
-}
-
-static void sound_reset(int ioaddr)
-{
-	outw(0x2000, 0x18+ioaddr);
-	udelay(1);
-	outw(0x0000, 0x18+ioaddr);
-	udelay(1);
-}
-
-/* sets the play formats of these apus, should be passed the already shifted format */
-static void set_apu_fmt(struct ess_state *s, int apu, int mode)
-{
-	int apu_fmt = 0x10;
-
-	if(!(mode&ESS_FMT_16BIT)) apu_fmt+=0x20; 
-	if((mode&ESS_FMT_STEREO)) apu_fmt+=0x10; 
-	s->apu_mode[apu]   = apu_fmt;
-	s->apu_mode[apu+1] = apu_fmt;
-}
-
-/* this only fixes the output apu mode to be later set by start_dac and
-	company.  output apu modes are set in ess_rec_setup */
-static void set_fmt(struct ess_state *s, unsigned char mask, unsigned char data)
-{
-	s->fmt = (s->fmt & mask) | data;
-	set_apu_fmt(s, 0, (s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK);
-}
-
-/* this is off by a little bit.. */
-static u32 compute_rate(struct ess_state *s, u32 freq)
-{
-	u32 clock = clock_freq[s->card->card_type];     
-
-	freq = (freq * clocking)/48000;
-	
-	if (freq == 48000) 
-		return 0x10000;
-
-	return ((freq / clock) <<16 )+  
-		(((freq % clock) << 16) / clock);
-}
-
-static void set_dac_rate(struct ess_state *s, unsigned int rate)
-{
-	u32 freq;
-	int fmt = (s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK;
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 4000)
-		rate = 4000;
-
-	s->ratedac = rate;
-
-	if(! (fmt & ESS_FMT_16BIT) && !(fmt & ESS_FMT_STEREO))
-		rate >>= 1;
-
-/*	M_printk("computing dac rate %d with mode %d\n",rate,s->fmt);*/
-
-	freq = compute_rate(s, rate);
-	
-	/* Load the frequency, turn on 6dB */
-	apu_set_register(s, 0, 2,(apu_get_register(s, 0, 2)&0x00FF)|
-		( ((freq&0xFF)<<8)|0x10 ));
-	apu_set_register(s, 0, 3, freq>>8);
-	apu_set_register(s, 1, 2,(apu_get_register(s, 1, 2)&0x00FF)|
-		( ((freq&0xFF)<<8)|0x10 ));
-	apu_set_register(s, 1, 3, freq>>8);
-}
-
-static void set_adc_rate(struct ess_state *s, unsigned rate)
-{
-	u32 freq;
-
-	/* Sample Rate conversion APUs don't like 0x10000 for their rate */
-	if (rate > 47999)
-		rate = 47999;
-	if (rate < 4000)
-		rate = 4000;
-
-	s->rateadc = rate;
-
-	freq = compute_rate(s, rate);
-	
-	/* Load the frequency, turn on 6dB */
-	apu_set_register(s, 2, 2,(apu_get_register(s, 2, 2)&0x00FF)|
-		( ((freq&0xFF)<<8)|0x10 ));
-	apu_set_register(s, 2, 3, freq>>8);
-	apu_set_register(s, 3, 2,(apu_get_register(s, 3, 2)&0x00FF)|
-		( ((freq&0xFF)<<8)|0x10 ));
-	apu_set_register(s, 3, 3, freq>>8);
-
-	/* fix mixer rate at 48khz.  and its _must_ be 0x10000. */
-	freq = 0x10000;
-
-	apu_set_register(s, 4, 2,(apu_get_register(s, 4, 2)&0x00FF)|
-		( ((freq&0xFF)<<8)|0x10 ));
-	apu_set_register(s, 4, 3, freq>>8);
-	apu_set_register(s, 5, 2,(apu_get_register(s, 5, 2)&0x00FF)|
-		( ((freq&0xFF)<<8)|0x10 ));
-	apu_set_register(s, 5, 3, freq>>8);
-}
-
-/* Stop our host of recording apus */
-static inline void stop_adc(struct ess_state *s)
-{
-	/* XXX lets hope we don't have to lock around this */
-	if (! (s->enable & ADC_RUNNING)) return;
-
-	s->enable &= ~ADC_RUNNING;
-	apu_set_register(s, 2, 0, apu_get_register(s, 2, 0)&0xFF0F);
-	apu_set_register(s, 3, 0, apu_get_register(s, 3, 0)&0xFF0F);
-	apu_set_register(s, 4, 0, apu_get_register(s, 2, 0)&0xFF0F);
-	apu_set_register(s, 5, 0, apu_get_register(s, 3, 0)&0xFF0F);
-}	
-
-/* stop output apus */
-static void stop_dac(struct ess_state *s)
-{
-	/* XXX have to lock around this? */
-	if (! (s->enable & DAC_RUNNING)) return;
-
-	s->enable &= ~DAC_RUNNING;
-	apu_set_register(s, 0, 0, apu_get_register(s, 0, 0)&0xFF0F);
-	apu_set_register(s, 1, 0, apu_get_register(s, 1, 0)&0xFF0F);
-}	
-
-static void start_dac(struct ess_state *s)
-{
-	/* XXX locks? */
-	if (	(s->dma_dac.mapped || s->dma_dac.count > 0) && 
-		s->dma_dac.ready &&
-		(! (s->enable & DAC_RUNNING)) ) {
-
-		s->enable |= DAC_RUNNING;
-
-		apu_set_register(s, 0, 0, 
-			(apu_get_register(s, 0, 0)&0xFF0F)|s->apu_mode[0]);
-
-		if((s->fmt >> ESS_DAC_SHIFT)  & ESS_FMT_STEREO) 
-			apu_set_register(s, 1, 0, 
-				(apu_get_register(s, 1, 0)&0xFF0F)|s->apu_mode[1]);
-	}
-}	
-
-static void start_adc(struct ess_state *s)
-{
-	/* XXX locks? */
-	if ((s->dma_adc.mapped || s->dma_adc.count < (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize)) 
-	    && s->dma_adc.ready && (! (s->enable & ADC_RUNNING)) ) {
-
-		s->enable |= ADC_RUNNING;
-		apu_set_register(s, 2, 0, 
-			(apu_get_register(s, 2, 0)&0xFF0F)|s->apu_mode[2]);
-		apu_set_register(s, 4, 0, 
-			(apu_get_register(s, 4, 0)&0xFF0F)|s->apu_mode[4]);
-
-		if( s->fmt & (ESS_FMT_STEREO << ESS_ADC_SHIFT)) {
-			apu_set_register(s, 3, 0, 
-				(apu_get_register(s, 3, 0)&0xFF0F)|s->apu_mode[3]);
-			apu_set_register(s, 5, 0, 
-				(apu_get_register(s, 5, 0)&0xFF0F)|s->apu_mode[5]);
-		}
-			
-	}
-}	
-
-
-/*
- *	Native play back driver 
- */
-
-/* the mode passed should be already shifted and masked */
-static void 
-ess_play_setup(struct ess_state *ess, int mode, u32 rate, void *buffer, int size)
-{
-	u32 pa;
-	u32 tmpval;
-	int high_apu = 0;
-	int channel;
-
-	M_printk("mode=%d rate=%d buf=%p len=%d.\n",
-		mode, rate, buffer, size);
-		
-	/* all maestro sizes are in 16bit words */
-	size >>=1;
-
-	if(mode&ESS_FMT_STEREO) {
-		high_apu++;
-		/* only 16/stereo gets size divided */
-		if(mode&ESS_FMT_16BIT)
-			size>>=1;
-	}
-	
-	for(channel=0; channel <= high_apu; channel++)
-	{
-		pa = virt_to_bus(buffer);
-
-		/* set the wavecache control reg */
-		tmpval = (pa - 0x10) & 0xFFF8;
-		if(!(mode & ESS_FMT_16BIT)) tmpval |= 4;
-		if(mode & ESS_FMT_STEREO) tmpval |= 2;
-		ess->apu_base[channel]=tmpval;
-		wave_set_register(ess, ess->apu[channel]<<3, tmpval);
-		
-		pa -= virt_to_bus(ess->card->dmapages);
-		pa>>=1; /* words */
-		
-		/* base offset of dma calcs when reading the pointer
-			on the left one */
-		if(!channel) ess->dma_dac.base = pa&0xFFFF;
-		
-		pa|=0x00400000;			/* System RAM */
-
-		/* XXX the 16bit here might not be needed.. */
-		if((mode & ESS_FMT_STEREO) && (mode & ESS_FMT_16BIT)) {
-			if(channel) 
-				pa|=0x00800000;			/* Stereo */
-			pa>>=1;
-		}
-			
-/* XXX think about endianess when writing these registers */
-		M_printk("maestro: ess_play_setup: APU[%d] pa = 0x%x\n", ess->apu[channel], pa);
-		/* start of sample */
-		apu_set_register(ess, channel, 4, ((pa>>16)&0xFF)<<8);
-		apu_set_register(ess, channel, 5, pa&0xFFFF);
-		/* sample end */
-		apu_set_register(ess, channel, 6, (pa+size)&0xFFFF);
-		/* setting loop len == sample len */
-		apu_set_register(ess, channel, 7, size);
-		
-		/* clear effects/env.. */
-		apu_set_register(ess, channel, 8, 0x0000);
-		/* set amp now to 0xd0 (?), low byte is 'amplitude dest'? */
-		apu_set_register(ess, channel, 9, 0xD000);
-
-		/* clear routing stuff */
-		apu_set_register(ess, channel, 11, 0x0000);
-		/* dma on, no envelopes, filter to all 1s) */
-		apu_set_register(ess, channel, 0, 0x400F);
-		
-		if(mode&ESS_FMT_16BIT)
-			ess->apu_mode[channel]=0x10;
-		else
-			ess->apu_mode[channel]=0x30;
-
-		if(mode&ESS_FMT_STEREO) {
-			/* set panning: left or right */
-			apu_set_register(ess, channel, 10, 0x8F00 | (channel ? 0 : 0x10));
-			ess->apu_mode[channel] += 0x10;
-		} else
-			apu_set_register(ess, channel, 10, 0x8F08);
-	}
-	
-	/* clear WP interrupts */
-	outw(1, ess->card->iobase+0x04);
-	/* enable WP ints */
-	outw(inw(ess->card->iobase+0x18)|4, ess->card->iobase+0x18);
-
-	/* go team! */
-	set_dac_rate(ess,rate);
-	start_dac(ess);
-}
-
-/*
- *	Native record driver 
- */
-
-/* again, passed mode is alrady shifted/masked */
-static void 
-ess_rec_setup(struct ess_state *ess, int mode, u32 rate, void *buffer, int size)
-{
-	int apu_step = 2;
-	int channel;
-
-	M_printk("maestro: ess_rec_setup: mode=%d rate=%d buf=0x%p len=%d.\n",
-		mode, rate, buffer, size);
-		
-	/* all maestro sizes are in 16bit words */
-	size >>=1;
-
-	/* we're given the full size of the buffer, but
-	in stereo each channel will only use its half */
-	if(mode&ESS_FMT_STEREO) {
-		size >>=1; 
-		apu_step = 1;
-	}
-	
-	/* APU assignments: 2 = mono/left SRC
-	                    3 = right SRC
-	                    4 = mono/left Input Mixer
-	                    5 = right Input Mixer */
-	for(channel=2;channel<6;channel+=apu_step)
-	{
-		int i;
-		int bsize, route;
-		u32 pa;
-		u32 tmpval;
-
-		/* data seems to flow from the codec, through an apu into
-			the 'mixbuf' bit of page, then through the SRC apu
-			and out to the real 'buffer'.  ok.  sure.  */
-		
-		if(channel & 0x04) {
-			/* ok, we're an input mixer going from adc
-				through the mixbuf to the other apus */
-
-			if(!(channel & 0x01)) { 
-				pa = virt_to_bus(ess->mixbuf);
-			} else {
-				pa = virt_to_bus(ess->mixbuf + (PAGE_SIZE >> 4));
-			}
-
-			/* we source from a 'magic' apu */
-			bsize = PAGE_SIZE >> 5;	/* half of this channels alloc, in words */
-			route = 0x14 + (channel - 4); /* parallel in crap, see maestro reg 0xC [8-11] */
-			ess->apu_mode[channel] = 0x90;  /* Input Mixer */
-
-		} else {  
-			/* we're a rate converter taking
-				input from the input apus and outputing it to
-				system memory */
-			if(!(channel & 0x01))  {
-				pa = virt_to_bus(buffer);
-			} else {
-				/* right channel records its split half.
-				*2 accommodates for rampant shifting earlier */
-				pa = virt_to_bus(buffer + size*2);
-			}
-
-			ess->apu_mode[channel] = 0xB0;  /* Sample Rate Converter */
-
-			bsize = size; 
-			/* get input from inputing apu */
-			route = channel + 2;
-		}
-
-		M_printk("maestro: ess_rec_setup: getting pa 0x%x from %d\n",pa,channel);
-		
-		/* set the wavecache control reg */
-		tmpval = (pa - 0x10) & 0xFFF8;
-		ess->apu_base[channel]=tmpval;
-		wave_set_register(ess, ess->apu[channel]<<3, tmpval);
-		
-		pa -= virt_to_bus(ess->card->dmapages);
-		pa>>=1; /* words */
-		
-		/* base offset of dma calcs when reading the pointer
-			on this left one */
-		if(channel==2) ess->dma_adc.base = pa&0xFFFF;
-
-		pa|=0x00400000;			/* bit 22 -> System RAM */
-
-		M_printk("maestro: ess_rec_setup: APU[%d] pa = 0x%x size = 0x%x route = 0x%x\n", 
-			ess->apu[channel], pa, bsize, route);
-		
-		/* Begin loading the APU */		
-		for(i=0;i<15;i++)		/* clear all PBRs */
-			apu_set_register(ess, channel, i, 0x0000);
-			
-		apu_set_register(ess, channel, 0, 0x400F);
-
-		/* need to enable subgroups.. and we should probably
-			have different groups for different /dev/dsps..  */
- 		apu_set_register(ess, channel, 2, 0x8);
-				
-		/* Load the buffer into the wave engine */
-		apu_set_register(ess, channel, 4, ((pa>>16)&0xFF)<<8);
-		/* XXX reg is little endian.. */
-		apu_set_register(ess, channel, 5, pa&0xFFFF);
-		apu_set_register(ess, channel, 6, (pa+bsize)&0xFFFF);
-		apu_set_register(ess, channel, 7, bsize);
-				
-		/* clear effects/env.. */
-		apu_set_register(ess, channel, 8, 0x00F0);
-		
-		/* amplitude now?  sure.  why not.  */
-		apu_set_register(ess, channel, 9, 0x0000);
-
-		/* set filter tune, radius, polar pan */
-		apu_set_register(ess, channel, 10, 0x8F08);
-
-		/* route input */
-		apu_set_register(ess, channel, 11, route);
-	}
-	
-	/* clear WP interrupts */
-	outw(1, ess->card->iobase+0x04);
-	/* enable WP ints */
-	outw(inw(ess->card->iobase+0x18)|4, ess->card->iobase+0x18);
-
-	/* let 'er rip */
-	set_adc_rate(ess,rate);
-	start_adc(ess);
-}
-/* --------------------------------------------------------------------- */
-
-static void set_dmaa(struct ess_state *s, unsigned int addr, unsigned int count)
-{
-	M_printk("set_dmaa??\n");
-}
-
-static void set_dmac(struct ess_state *s, unsigned int addr, unsigned int count)
-{
-	M_printk("set_dmac??\n");
-}
-
-/* Playback pointer */
-static inline unsigned get_dmaa(struct ess_state *s)
-{
-	int offset;
-
-	offset = apu_get_register(s,0,5);
-
-/*	M_printk("dmaa: offset: %d, base: %d\n",offset,s->dma_dac.base); */
-	
-	offset-=s->dma_dac.base;
-
-	return (offset&0xFFFE)<<1; /* hardware is in words */
-}
-
-/* Record pointer */
-static inline unsigned get_dmac(struct ess_state *s)
-{
-	int offset;
-
-	offset = apu_get_register(s,2,5);
-
-/*	M_printk("dmac: offset: %d, base: %d\n",offset,s->dma_adc.base); */
-	
-	/* The offset is an address not a position relative to base */
-	offset-=s->dma_adc.base;
-	
-	return (offset&0xFFFE)<<1; /* hardware is in words */
-}
-
-/*
- *	Meet Bob, the timer...
- */
-
-static irqreturn_t ess_interrupt(int irq, void *dev_id, struct pt_regs *regs);
-
-static void stop_bob(struct ess_state *s)
-{
-	/* Mask IDR 11,17 */
-	maestro_write(s,  0x11, maestro_read(s, 0x11)&~1);
-	maestro_write(s,  0x17, maestro_read(s, 0x17)&~1);
-}
-
-/* eventually we could be clever and limit bob ints
-	to the frequency at which our smallest duration
-	chunks may expire */
-#define ESS_SYSCLK	50000000
-static void start_bob(struct ess_state *s)
-{
-	int prescale;
-	int divide;
-	
-	/* XXX make freq selector much smarter, see calc_bob_rate */
-	int freq = 200; 
-	
-	/* compute ideal interrupt frequency for buffer size & play rate */
-	/* first, find best prescaler value to match freq */
-	for(prescale=5;prescale<12;prescale++)
-		if(freq > (ESS_SYSCLK>>(prescale+9)))
-			break;
-			
-	/* next, back off prescaler whilst getting divider into optimum range */
-	divide=1;
-	while((prescale > 5) && (divide<32))
-	{
-		prescale--;
-		divide <<=1;
-	}
-	divide>>=1;
-	
-	/* now fine-tune the divider for best match */
-	for(;divide<31;divide++)
-		if(freq >= ((ESS_SYSCLK>>(prescale+9))/(divide+1)))
-			break;
-	
-	/* divide = 0 is illegal, but don't let prescale = 4! */
-	if(divide == 0)
-	{
-		divide++;
-		if(prescale>5)
-			prescale--;
-	}
-
-	maestro_write(s, 6, 0x9000 | (prescale<<5) | divide); /* set reg */
-	
-	/* Now set IDR 11/17 */
-	maestro_write(s, 0x11, maestro_read(s, 0x11)|1);
-	maestro_write(s, 0x17, maestro_read(s, 0x17)|1);
-}
-/* --------------------------------------------------------------------- */
-
-/* this quickly calculates the frequency needed for bob
-	and sets it if its different than what bob is
-	currently running at.  its called often so 
-	needs to be fairly quick. */
-#define BOB_MIN 50
-#define BOB_MAX 400
-static void calc_bob_rate(struct ess_state *s) {
-#if 0 /* this thing tries to set the frequency of bob such that
-	there are 2 interrupts / buffer walked by the dac/adc.  That
-	is probably very wrong for people who actually care about 
-	mid buffer positioning.  it should be calculated as bytes/interrupt
-	and that needs to be decided :)  so for now just use the static 150
-	in start_bob.*/
-
-	unsigned int dac_rate=2,adc_rate=1,newrate;
-	static int israte=-1;
-
-	if (s->dma_dac.fragsize == 0) dac_rate = BOB_MIN;
-	else  {
-		dac_rate =	(2 * s->ratedac * sample_size[(s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK]) /
-				(s->dma_dac.fragsize) ;
-	}
-		
-	if (s->dma_adc.fragsize == 0) adc_rate = BOB_MIN;
-	else {
-		adc_rate =	(2 * s->rateadc * sample_size[(s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK]) /
-				(s->dma_adc.fragsize) ;
-	}
-
-	if(dac_rate > adc_rate) newrate = adc_rate;
-	else newrate=dac_rate;
-
-	if(newrate > BOB_MAX) newrate = BOB_MAX;
-	else {
-		if(newrate < BOB_MIN) 
-			newrate = BOB_MIN;
-	}
-
-	if( israte != newrate) {
-		printk("dac: %d  adc: %d rate: %d\n",dac_rate,adc_rate,israte);
-		israte=newrate;
-	}
-#endif
-
-}
-
-static int 
-prog_dmabuf(struct ess_state *s, unsigned rec)
-{
-	struct dmabuf *db = rec ? &s->dma_adc : &s->dma_dac;
-	unsigned rate = rec ? s->rateadc : s->ratedac;
-	unsigned bytepersec;
-	unsigned bufs;
-	unsigned char fmt;
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	fmt = s->fmt;
-	if (rec) {
-		stop_adc(s);
-		fmt >>= ESS_ADC_SHIFT;
-	} else {
-		stop_dac(s);
-		fmt >>= ESS_DAC_SHIFT;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	fmt &= ESS_FMT_MASK;
-
-	db->hwptr = db->swptr = db->total_bytes = db->count = db->error = db->endcleared = 0;
-
-	/* this algorithm is a little nuts.. where did /1000 come from? */
-	bytepersec = rate << sample_shift[fmt];
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < bytepersec)
-			db->fragshift = ld2(bytepersec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(bytepersec/100/(db->subdivision ? db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3; 
-	}
-	db->numfrag = bufs >> db->fragshift;
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->numfrag = bufs >> db->fragshift;
-	}
-	db->fragsize = 1 << db->fragshift;
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
-	db->fragsamples = db->fragsize >> sample_shift[fmt];
-	db->dmasize = db->numfrag << db->fragshift;
-
-	M_printk("maestro: setup oss: numfrag: %d fragsize: %d dmasize: %d\n",db->numfrag,db->fragsize,db->dmasize);
-
-	memset(db->rawbuf, (fmt & ESS_FMT_16BIT) ? 0 : 0x80, db->dmasize);
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (rec) 
-		ess_rec_setup(s, fmt, s->rateadc, db->rawbuf, db->dmasize);
-	else 
-		ess_play_setup(s, fmt, s->ratedac, db->rawbuf, db->dmasize);
-
-	spin_unlock_irqrestore(&s->lock, flags);
-	db->ready = 1;
-
-	return 0;
-}
-
-static __inline__ void 
-clear_advance(struct ess_state *s)
-{
-	unsigned char c = ((s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_16BIT) ? 0 : 0x80;
-	
-	unsigned char *buf = s->dma_dac.rawbuf;
-	unsigned bsize = s->dma_dac.dmasize;
-	unsigned bptr = s->dma_dac.swptr;
-	unsigned len = s->dma_dac.fragsize;
-	
-	if (bptr + len > bsize) {
-		unsigned x = bsize - bptr;
-		memset(buf + bptr, c, x);
-		/* account for wrapping? */
-		bptr = 0;
-		len -= x;
-	}
-	memset(buf + bptr, c, len);
-}
-
-/* call with spinlock held! */
-static void 
-ess_update_ptr(struct ess_state *s)
-{
-	unsigned hwptr;
-	int diff;
-
-	/* update ADC pointer */
-	if (s->dma_adc.ready) {
-		/* oh boy should this all be re-written.  everything in the current code paths think
-		that the various counters/pointers are expressed in bytes to the user but we have
-		two apus doing stereo stuff so we fix it up here.. it propagates to all the various
-		counters from here.  */
-		if ( s->fmt & (ESS_FMT_STEREO << ESS_ADC_SHIFT)) {
-			hwptr = (get_dmac(s)*2) % s->dma_adc.dmasize;
-		} else {
-			hwptr = get_dmac(s) % s->dma_adc.dmasize;
-		}
-		diff = (s->dma_adc.dmasize + hwptr - s->dma_adc.hwptr) % s->dma_adc.dmasize;
-		s->dma_adc.hwptr = hwptr;
-		s->dma_adc.total_bytes += diff;
-		s->dma_adc.count += diff;
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize) 
-			wake_up(&s->dma_adc.wait);
-		if (!s->dma_adc.mapped) {
-			if (s->dma_adc.count > (signed)(s->dma_adc.dmasize - ((3 * s->dma_adc.fragsize) >> 1))) {
-				/* FILL ME 
-				wrindir(s, SV_CIENABLE, s->enable); */
-				stop_adc(s); 
-				/* brute force everyone back in sync, sigh */
-				s->dma_adc.count = 0;
-				s->dma_adc.swptr = 0;
-				s->dma_adc.hwptr = 0;
-				s->dma_adc.error++;
-			}
-		}
-	}
-	/* update DAC pointer */
-	if (s->dma_dac.ready) {
-		hwptr = get_dmaa(s) % s->dma_dac.dmasize; 
-		/* the apu only reports the length it has seen, not the
-			length of the memory that has been used (the WP
-			knows that) */
-		if ( ((s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK) == (ESS_FMT_STEREO|ESS_FMT_16BIT))
-			hwptr<<=1;
-
-		diff = (s->dma_dac.dmasize + hwptr - s->dma_dac.hwptr) % s->dma_dac.dmasize;
-/*		M_printk("updating dac: hwptr: %d diff: %d\n",hwptr,diff);*/
-		s->dma_dac.hwptr = hwptr;
-		s->dma_dac.total_bytes += diff;
-		if (s->dma_dac.mapped) {
-			s->dma_dac.count += diff;
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) {
-				wake_up(&s->dma_dac.wait);
-			}
-		} else {
-			s->dma_dac.count -= diff;
-/*			M_printk("maestro: ess_update_ptr: diff: %d, count: %d\n", diff, s->dma_dac.count); */
-			if (s->dma_dac.count <= 0) {
-				M_printk("underflow! diff: %d count: %d hw: %d sw: %d\n", diff, s->dma_dac.count, 
-					hwptr, s->dma_dac.swptr);
-				/* FILL ME 
-				wrindir(s, SV_CIENABLE, s->enable); */
-				/* XXX how on earth can calling this with the lock held work.. */
-				stop_dac(s);
-				/* brute force everyone back in sync, sigh */
-				s->dma_dac.count = 0; 
-				s->dma_dac.swptr = hwptr; 
-				s->dma_dac.error++;
-			} else if (s->dma_dac.count <= (signed)s->dma_dac.fragsize && !s->dma_dac.endcleared) {
-				clear_advance(s);
-				s->dma_dac.endcleared = 1;
-			}
-			if (s->dma_dac.count + (signed)s->dma_dac.fragsize <= (signed)s->dma_dac.dmasize) {
-				wake_up(&s->dma_dac.wait);
-/*				printk("waking up DAC count: %d sw: %d hw: %d\n",s->dma_dac.count, s->dma_dac.swptr, 
-					hwptr);*/
-			}
-		}
-	}
-}
-
-static irqreturn_t
-ess_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-        struct ess_state *s;
-        struct ess_card *c = (struct ess_card *)dev_id;
-	int i;
-	u32 event;
-
-	if ( ! (event = inb(c->iobase+0x1A)) )
-		return IRQ_NONE;
-
-	outw(inw(c->iobase+4)&1, c->iobase+4);
-
-/*	M_printk("maestro int: %x\n",event);*/
-	if(event&(1<<6))
-	{
-		int x;
-		enum {UP_EVT, DOWN_EVT, MUTE_EVT} vol_evt;
-		int volume;
-
-		/* Figure out which volume control button was pushed,
-		   based on differences from the default register
-		   values. */
-		x = inb(c->iobase+0x1c);
-		if (x&1) vol_evt = MUTE_EVT;
-		else if (((x>>1)&7) > 4) vol_evt = UP_EVT;
-		else vol_evt = DOWN_EVT;
-
-		/* Reset the volume control registers. */
-		outb(0x88, c->iobase+0x1c);
-		outb(0x88, c->iobase+0x1d);
-		outb(0x88, c->iobase+0x1e);
-		outb(0x88, c->iobase+0x1f);
-
-		/* Deal with the button press in a hammer-handed
-		   manner by adjusting the master mixer volume. */
-		volume = c->mix.mixer_state[0] & 0xff;
-		if (vol_evt == UP_EVT) {
-			volume += 5;
-			if (volume > 100)
-				volume = 100;
-		}
-		else if (vol_evt == DOWN_EVT) {
-			volume -= 5;
-			if (volume < 0)
-				volume = 0;
-		} else {
-			/* vol_evt == MUTE_EVT */
-			if (volume == 0)
-				volume = c->dock_mute_vol;
-			else {
-				c->dock_mute_vol = volume;
-				volume = 0;
-			}
-		}
-		set_mixer (c, 0, (volume << 8) | volume);
-	}
-
-	/* Ack all the interrupts. */
-	outb(0xFF, c->iobase+0x1A);
-		
-	/*
-	 *	Update the pointers for all APU's we are running.
-	 */
-	for(i=0;i<NR_DSPS;i++)
-	{
-		s=&c->channels[i];
-		if(s->dev_audio == -1)
-			break;
-		spin_lock(&s->lock);
-		ess_update_ptr(s);
-		spin_unlock(&s->lock);
-	}
-	return IRQ_HANDLED;
-}
-
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT "maestro: invalid magic value in %s\n";
-
-#define VALIDATE_MAGIC(FOO,MAG)                         \
-({                                                \
-	if (!(FOO) || (FOO)->magic != MAG) { \
-		printk(invalid_magic,__FUNCTION__);            \
-		return -ENXIO;                    \
-	}                                         \
-})
-
-#define VALIDATE_STATE(a) VALIDATE_MAGIC(a,ESS_STATE_MAGIC)
-#define VALIDATE_CARD(a) VALIDATE_MAGIC(a,ESS_CARD_MAGIC)
-
-static void set_mixer(struct ess_card *card,unsigned int mixer, unsigned int val ) 
-{
-	unsigned int left,right;
-	/* cleanse input a little */
-	right = ((val >> 8)  & 0xff) ;
-	left = (val  & 0xff) ;
-
-	if(right > 100) right = 100;
-	if(left > 100) left = 100;
-
-	card->mix.mixer_state[mixer]=(right << 8) | left;
-	card->mix.write_mixer(card,mixer,left,right);
-}
-
-static void
-mixer_push_state(struct ess_card *card)
-{
-	int i;
-	for(i = 0 ; i < SOUND_MIXER_NRDEVICES ; i++) {
-		if( ! supported_mixer(card,i)) continue;
-
-		set_mixer(card,i,card->mix.mixer_state[i]);
-	}
-}
-
-static int mixer_ioctl(struct ess_card *card, unsigned int cmd, unsigned long arg)
-{
-	int i, val=0;
-	unsigned long flags;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_CARD(card);
-        if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		memset(&info, 0, sizeof(info));
-		strlcpy(info.id, card_names[card->card_type], sizeof(info.id));
-		strlcpy(info.name, card_names[card->card_type], sizeof(info.name));
-		info.modify_counter = card->mix.modcnt;
-		if (copy_to_user(argp, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == SOUND_OLD_MIXER_INFO) {
-		_old_mixer_info info;
-		memset(&info, 0, sizeof(info));
-		strlcpy(info.id, card_names[card->card_type], sizeof(info.id));
-		strlcpy(info.name, card_names[card->card_type], sizeof(info.name));
-		if (copy_to_user(argp, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, p);
-
-	if (_IOC_TYPE(cmd) != 'M' || _IOC_SIZE(cmd) != sizeof(int))
-                return -EINVAL;
-
-        if (_IOC_DIR(cmd) == _IOC_READ) {
-                switch (_IOC_NR(cmd)) {
-                case SOUND_MIXER_RECSRC: /* give them the current record source */
-
-			if(!card->mix.recmask_io) {
-				val = 0;
-			} else {
-                               spin_lock_irqsave(&card->lock, flags);
-				val = card->mix.recmask_io(card,1,0);
-                               spin_unlock_irqrestore(&card->lock, flags);
-			}
-			break;
-			
-                case SOUND_MIXER_DEVMASK: /* give them the supported mixers */
-			val = card->mix.supported_mixers;
-			break;
-
-                case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
-			val = card->mix.record_sources;
-			break;
-			
-                case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
-			val = card->mix.stereo_mixers;
-			break;
-			
-                case SOUND_MIXER_CAPS:
-			val = SOUND_CAP_EXCL_INPUT;
-			break;
-
-		default: /* read a specific mixer */
-			i = _IOC_NR(cmd);
-
-			if ( ! supported_mixer(card,i)) 
-				return -EINVAL;
-
-			/* do we ever want to touch the hardware? */
-/*                     spin_lock_irqsave(&card->lock, flags);
-			val = card->mix.read_mixer(card,i);
-                       spin_unlock_irqrestore(&card->lock, flags);*/
-
-			val = card->mix.mixer_state[i];
-/*			M_printk("returned 0x%x for mixer %d\n",val,i);*/
-
-			break;
-		}
-		return put_user(val, p);
-	}
-	
-        if (_IOC_DIR(cmd) != (_IOC_WRITE|_IOC_READ))
-		return -EINVAL;
-	
-	card->mix.modcnt++;
-
-	if (get_user(val, p))
-		return -EFAULT;
-
-	switch (_IOC_NR(cmd)) {
-	case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-
-		if (!card->mix.recmask_io) return -EINVAL;
-		if(!val) return 0;
-		if(! (val &= card->mix.record_sources)) return -EINVAL;
-
-               spin_lock_irqsave(&card->lock, flags);
-		card->mix.recmask_io(card,0,val);
-               spin_unlock_irqrestore(&card->lock, flags);
-		return 0;
-
-	default:
-		i = _IOC_NR(cmd);
-
-		if ( ! supported_mixer(card,i)) 
-			return -EINVAL;
-
-               spin_lock_irqsave(&card->lock, flags);
-		set_mixer(card,i,val);
-               spin_unlock_irqrestore(&card->lock, flags);
-
-		return 0;
-	}
-}
-
-/* --------------------------------------------------------------------- */
-static int ess_open_mixdev(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	struct ess_card *card = NULL;
-	struct pci_dev *pdev = NULL;
-	struct pci_driver *drvr;
-
-	while ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
-		drvr = pci_dev_driver (pdev);
-		if (drvr == &maestro_pci_driver) {
-			card = (struct ess_card*)pci_get_drvdata (pdev);
-			if (!card)
-				continue;
-			if (card->dev_mixer == minor)
-				break;
-		}
-	}
-	if (!card)
-		return -ENODEV;
-	file->private_data = card;
-	return nonseekable_open(inode, file);
-}
-
-static int ess_release_mixdev(struct inode *inode, struct file *file)
-{
-	struct ess_card *card = (struct ess_card *)file->private_data;
-
-	VALIDATE_CARD(card);
-	
-	return 0;
-}
-
-static int ess_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct ess_card *card = (struct ess_card *)file->private_data;
-
-	VALIDATE_CARD(card);
-
-	return mixer_ioctl(card, cmd, arg);
-}
-
-static /*const*/ struct file_operations ess_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= ess_ioctl_mixdev,
-	.open		= ess_open_mixdev,
-	.release	= ess_release_mixdev,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct ess_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait,current);
-	unsigned long flags;
-	int count;
-	signed long tmo;
-
-	if (s->dma_dac.mapped || !s->dma_dac.ready)
-		return 0;
-	current->state = TASK_INTERRUPTIBLE;
-        add_wait_queue(&s->dma_dac.wait, &wait);
-        for (;;) {
-		/* XXX uhm.. questionable locking*/
-                spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-                spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-                        break;
-                if (nonblock) {
-                        remove_wait_queue(&s->dma_dac.wait, &wait);
-			current->state = TASK_RUNNING;
-                        return -EBUSY;
-                }
-		tmo = (count * HZ) / s->ratedac;
-		tmo >>= sample_shift[(s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK];
-		/* XXX this is just broken.  someone is waking us up alot, or schedule_timeout is broken.
-			or something.  who cares. - zach */
-		if (!schedule_timeout(tmo ? tmo : 1) && tmo)
-			M_printk(KERN_DEBUG "maestro: dma timed out?? %ld\n",jiffies);
-        }
-        remove_wait_queue(&s->dma_dac.wait, &wait);
-	current->state = TASK_RUNNING;
-        if (signal_pending(current))
-                return -ERESTARTSYS;
-        return 0;
-}
-
-/* --------------------------------------------------------------------- */
-/* Zach sez: "god this is gross.." */
-static int 
-comb_stereo(unsigned char *real_buffer,unsigned char  *tmp_buffer, int offset, 
-	int count, int bufsize)
-{  
-	/* No such thing as stereo recording, so we
-	use dual input mixers.  which means we have to 
-	combine mono to stereo buffer.  yuck. 
-
-	but we don't have to be able to work a byte at a time..*/
-
-	unsigned char *so,*left,*right;
-	int i;
-
-	so = tmp_buffer;
-	left = real_buffer + offset;
-	right = real_buffer + bufsize/2 + offset;
-
-/*	M_printk("comb_stereo writing %d to %p from %p and %p, offset: %d size: %d\n",count/2, tmp_buffer,left,right,offset,bufsize);*/
-
-	for(i=count/4; i ; i--) {
-		(*(so+2)) = *(right++);
-		(*(so+3)) = *(right++);
-		(*so) = *(left++);
-		(*(so+1)) = *(left++);
-		so+=4;
-	}
-
-	return 0;
-}
-
-/* in this loop, dma_adc.count signifies the amount of data thats waiting
-	to be copied to the user's buffer.  it is filled by the interrupt
-	handler and drained by this loop. */
-static ssize_t 
-ess_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct ess_state *s = (struct ess_state *)file->private_data;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-	unsigned char *combbuf = NULL;
-	
-	VALIDATE_STATE(s);
-	if (s->dma_adc.mapped)
-		return -ENXIO;
-	if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-		return ret;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	if(!(combbuf = kmalloc(count,GFP_KERNEL)))
-		return -ENOMEM;
-	ret = 0;
-
-	calc_bob_rate(s);
-
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		/* remember, all these things are expressed in bytes to be
-			sent to the user.. hence the evil / 2 down below */
-		swptr = s->dma_adc.swptr;
-		cnt = s->dma_adc.dmasize-swptr;
-		if (s->dma_adc.count < cnt)
-			cnt = s->dma_adc.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		if (cnt > count)
-			cnt = count;
-
-		if ( cnt > 0 ) cnt &= ~3;
-
-		if (cnt <= 0) {
-			start_adc(s);
-			if (file->f_flags & O_NONBLOCK) 
-			{
-				ret = ret ? ret : -EAGAIN;
-				goto rec_return_free;
-			}
-			if (!interruptible_sleep_on_timeout(&s->dma_adc.wait, HZ)) {
-				if(! s->card->in_suspend) printk(KERN_DEBUG "maestro: read: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       s->dma_adc.dmasize, s->dma_adc.fragsize, s->dma_adc.count, 
-				       s->dma_adc.hwptr, s->dma_adc.swptr);
-				stop_adc(s);
-				spin_lock_irqsave(&s->lock, flags);
-				set_dmac(s, virt_to_bus(s->dma_adc.rawbuf), s->dma_adc.numfrag << s->dma_adc.fragshift);
-				/* program enhanced mode registers */
-				/* FILL ME */
-/*				wrindir(s, SV_CIDMACBASECOUNT1, (s->dma_adc.fragsamples-1) >> 8);
-				wrindir(s, SV_CIDMACBASECOUNT0, s->dma_adc.fragsamples-1); */
-				s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (signal_pending(current)) 
-			{
-				ret = ret ? ret : -ERESTARTSYS;
-				goto rec_return_free;
-			}
-			continue;
-		}
-	
-		if(s->fmt & (ESS_FMT_STEREO << ESS_ADC_SHIFT)) {
-			/* swptr/2 so that we know the real offset in each apu's buffer */
-			comb_stereo(s->dma_adc.rawbuf,combbuf,swptr/2,cnt,s->dma_adc.dmasize);
-			if (copy_to_user(buffer, combbuf, cnt)) {
-				ret = ret ? ret : -EFAULT;
-				goto rec_return_free;
-			}
-		} else  {
-			if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
-				ret = ret ? ret : -EFAULT;
-				goto rec_return_free;
-			}
-		}
-
-		swptr = (swptr + cnt) % s->dma_adc.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_adc.swptr = swptr;
-		s->dma_adc.count -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		start_adc(s);
-	}
-
-rec_return_free:
-	kfree(combbuf);
-	return ret;
-}
-
-static ssize_t 
-ess_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct ess_state *s = (struct ess_state *)file->private_data;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-	
-	VALIDATE_STATE(s);
-	if (s->dma_dac.mapped)
-		return -ENXIO;
-	if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-		return ret;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-
-	calc_bob_rate(s);
-
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-
-		if (s->dma_dac.count < 0) {
-			s->dma_dac.count = 0;
-			s->dma_dac.swptr = s->dma_dac.hwptr;
-		}
-		swptr = s->dma_dac.swptr;
-
-		cnt = s->dma_dac.dmasize-swptr;
-
-		if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
-			cnt = s->dma_dac.dmasize - s->dma_dac.count;
-
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		if (cnt > count)
-			cnt = count;
-
-		if (cnt <= 0) {
-			start_dac(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if(!ret) ret = -EAGAIN;
-				goto return_free;
-			}
-			if (!interruptible_sleep_on_timeout(&s->dma_dac.wait, HZ)) {
-				if(! s->card->in_suspend) printk(KERN_DEBUG "maestro: write: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       s->dma_dac.dmasize, s->dma_dac.fragsize, s->dma_dac.count, 
-				       s->dma_dac.hwptr, s->dma_dac.swptr);
-				stop_dac(s);
-				spin_lock_irqsave(&s->lock, flags);
-				set_dmaa(s, virt_to_bus(s->dma_dac.rawbuf), s->dma_dac.numfrag << s->dma_dac.fragshift);
-				/* program enhanced mode registers */
-/*				wrindir(s, SV_CIDMAABASECOUNT1, (s->dma_dac.fragsamples-1) >> 8);
-				wrindir(s, SV_CIDMAABASECOUNT0, s->dma_dac.fragsamples-1); */
-				/* FILL ME */
-				s->dma_dac.count = s->dma_dac.hwptr = s->dma_dac.swptr = 0;
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (signal_pending(current)) {
-				if (!ret) ret = -ERESTARTSYS;
-				goto return_free;
-			}
-			continue;
-		}
-		if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt)) {
-			if (!ret) ret = -EFAULT;
-			goto return_free;
-		}
-/*		printk("wrote %d bytes at sw: %d cnt: %d while hw: %d\n",cnt, swptr, s->dma_dac.count, s->dma_dac.hwptr);*/
-
-		swptr = (swptr + cnt) % s->dma_dac.dmasize;
-
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac.swptr = swptr;
-		s->dma_dac.count += cnt;
-		s->dma_dac.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		start_dac(s);
-	}
-return_free:
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int ess_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct ess_state *s = (struct ess_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-
-/* In 0.14 prog_dmabuf always returns success anyway ... */
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac.ready && prog_dmabuf(s, 0)) 
-			return 0;
-	}
-	if (file->f_mode & FMODE_READ) {
-	  	if (!s->dma_adc.ready && prog_dmabuf(s, 1))
-			return 0;
-	}
-
-	if (file->f_mode & FMODE_WRITE)
-		poll_wait(file, &s->dma_dac.wait, wait);
-	if (file->f_mode & FMODE_READ)
-		poll_wait(file, &s->dma_adc.wait, wait);
-	spin_lock_irqsave(&s->lock, flags);
-	ess_update_ptr(s);
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) 
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed)s->dma_dac.dmasize >= s->dma_dac.count + (signed)s->dma_dac.fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int ess_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct ess_state *s = (struct ess_state *)file->private_data;
-	struct dmabuf *db;
-	int ret = -EINVAL;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf(s, 1)) != 0)
-			goto out;
-		db = &s->dma_dac;
-	} else 
-#if 0
-	/* if we can have the wp/wc do the combining
-		we can turn this back on.  */
-	      if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf(s, 0)) != 0)
-			goto out;
-		db = &s->dma_adc;
-	} else  
-#endif
-		goto out;
-	ret = -EINVAL;
-	if (vma->vm_pgoff != 0)
-		goto out;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder))
-		goto out;
-	ret = -EAGAIN;
-	if (remap_pfn_range(vma, vma->vm_start,
-			virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-			size, vma->vm_page_prot))
-		goto out;
-	db->mapped = 1;
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-static int ess_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct ess_state *s = (struct ess_state *)file->private_data;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int val, mapped, ret;
-	unsigned char fmtm, fmtd;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-/*	printk("maestro: ess_ioctl: cmd %d\n", cmd);*/
-	
-	VALIDATE_STATE(s);
-        mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s, file->f_flags & O_NONBLOCK);
-		return 0;
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		/* XXX fix */
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-		
-        case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq(s->card->pcidev->irq);
-			s->dma_dac.swptr = s->dma_dac.hwptr = s->dma_dac.count = s->dma_dac.total_bytes = 0;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->card->pcidev->irq);
-			s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				set_adc_rate(s, val);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				set_dac_rate(s, val);
-			}
-		}
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-		
-        case SNDCTL_DSP_STEREO:
-		if (get_user(val, p))
-			return -EFAULT;
-		fmtd = 0;
-		fmtm = ~0;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ready = 0;
-			if (val)
-				fmtd |= ESS_FMT_STEREO << ESS_ADC_SHIFT;
-			else
-				fmtm &= ~(ESS_FMT_STEREO << ESS_ADC_SHIFT);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.ready = 0;
-			if (val)
-				fmtd |= ESS_FMT_STEREO << ESS_DAC_SHIFT;
-			else
-				fmtm &= ~(ESS_FMT_STEREO << ESS_DAC_SHIFT);
-		}
-		set_fmt(s, fmtm, fmtd);
-		return 0;
-
-        case SNDCTL_DSP_CHANNELS:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 0) {
-			fmtd = 0;
-			fmtm = ~0;
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val >= 2)
-					fmtd |= ESS_FMT_STEREO << ESS_ADC_SHIFT;
-				else
-					fmtm &= ~(ESS_FMT_STEREO << ESS_ADC_SHIFT);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val >= 2)
-					fmtd |= ESS_FMT_STEREO << ESS_DAC_SHIFT;
-				else
-					fmtm &= ~(ESS_FMT_STEREO << ESS_DAC_SHIFT);
-			}
-			set_fmt(s, fmtm, fmtd);
-		}
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (ESS_FMT_STEREO << ESS_ADC_SHIFT) 
-					   : (ESS_FMT_STEREO << ESS_DAC_SHIFT))) ? 2 : 1, p);
-		
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(AFMT_U8|AFMT_S16_LE, p);
-		
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			fmtd = 0;
-			fmtm = ~0;
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-	/* fixed at 16bit for now */
-				fmtd |= ESS_FMT_16BIT << ESS_ADC_SHIFT;
-#if 0
-				if (val == AFMT_S16_LE)
-					fmtd |= ESS_FMT_16BIT << ESS_ADC_SHIFT;
-				else
-					fmtm &= ~(ESS_FMT_16BIT << ESS_ADC_SHIFT);
-#endif
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val == AFMT_S16_LE)
-					fmtd |= ESS_FMT_16BIT << ESS_DAC_SHIFT;
-				else
-					fmtm &= ~(ESS_FMT_16BIT << ESS_DAC_SHIFT);
-			}
-			set_fmt(s, fmtm, fmtd);
-		}
- 		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? 
-			(ESS_FMT_16BIT << ESS_ADC_SHIFT) 
-			: (ESS_FMT_16BIT << ESS_DAC_SHIFT))) ? 
-				AFMT_S16_LE : 
-				AFMT_U8, 
-			p);
-		
-	case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if ((file->f_mode & FMODE_READ) && (s->enable & ADC_RUNNING))
-			val |= PCM_ENABLE_INPUT;
-		if ((file->f_mode & FMODE_WRITE) && (s->enable & DAC_RUNNING)) 
-			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, p);
-		
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready && (ret =  prog_dmabuf(s, 1)))
-					return ret;
-				start_adc(s);
-			} else
-				stop_adc(s);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-					return ret;
-				start_dac(s);
-			} else
-				stop_dac(s);
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-			return ret;
-		spin_lock_irqsave(&s->lock, flags);
-		ess_update_ptr(s);
-		abinfo.fragsize = s->dma_dac.fragsize;
-                abinfo.bytes = s->dma_dac.dmasize - s->dma_dac.count;
-                abinfo.fragstotal = s->dma_dac.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (ret =  prog_dmabuf(s, 1)))
-			return ret;
-		spin_lock_irqsave(&s->lock, flags);
-		ess_update_ptr(s);
-		abinfo.fragsize = s->dma_adc.fragsize;
-                abinfo.bytes = s->dma_adc.count;
-                abinfo.fragstotal = s->dma_adc.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-		
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-			return ret;
-		spin_lock_irqsave(&s->lock, flags);
-		ess_update_ptr(s);
-                val = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return put_user(val, p);
-
-        case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (ret =  prog_dmabuf(s, 1)))
-			return ret;
-		spin_lock_irqsave(&s->lock, flags);
-		ess_update_ptr(s);
-                cinfo.bytes = s->dma_adc.total_bytes;
-                cinfo.blocks = s->dma_adc.count >> s->dma_adc.fragshift;
-                cinfo.ptr = s->dma_adc.hwptr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-			return ret;
-		spin_lock_irqsave(&s->lock, flags);
-		ess_update_ptr(s);
-                cinfo.bytes = s->dma_dac.total_bytes;
-                cinfo.blocks = s->dma_dac.count >> s->dma_dac.fragshift;
-                cinfo.ptr = s->dma_dac.hwptr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= s->dma_dac.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf(s, 0)))
-				return val;
-			return put_user(s->dma_dac.fragsize, p);
-		}
-		if ((val = prog_dmabuf(s, 1)))
-			return val;
-		return put_user(s->dma_adc.fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-                if (get_user(val, p))
-			return -EFAULT;
-		M_printk("maestro: SETFRAGMENT: %0x\n",val);
-		if (file->f_mode & FMODE_READ) {
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			s->dma_dac.ossfragshift = val & 0xffff;
-			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac.ossfragshift < 4)
-				s->dma_dac.ossfragshift = 4;
-			if (s->dma_dac.ossfragshift > 15)
-				s->dma_dac.ossfragshift = 15;
-			if (s->dma_dac.ossmaxfrags < 4)
-				s->dma_dac.ossmaxfrags = 4;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-			return -EINVAL;
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		if (file->f_mode & FMODE_WRITE)
-			s->dma_dac.subdivision = val;
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (ESS_FMT_STEREO << ESS_ADC_SHIFT) 
-					   : (ESS_FMT_STEREO << ESS_DAC_SHIFT))) ? 2 : 1, p);
-
-        case SOUND_PCM_READ_BITS:
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (ESS_FMT_16BIT << ESS_ADC_SHIFT) 
-					   : (ESS_FMT_16BIT << ESS_DAC_SHIFT))) ? 16 : 8, p);
-
-        case SOUND_PCM_WRITE_FILTER:
-        case SNDCTL_DSP_SETSYNCRO:
-        case SOUND_PCM_READ_FILTER:
-                return -EINVAL;
-		
-	}
-	return -EINVAL;
-}
-
-static void
-set_base_registers(struct ess_state *s,void *vaddr)
-{
-	unsigned long packed_phys = virt_to_bus(vaddr)>>12;
-	wave_set_register(s, 0x01FC , packed_phys);
-	wave_set_register(s, 0x01FD , packed_phys);
-	wave_set_register(s, 0x01FE , packed_phys);
-	wave_set_register(s, 0x01FF , packed_phys);
-}
-
-/* 
- * this guy makes sure we're in the right power
- * state for what we want to be doing 
- */
-static void maestro_power(struct ess_card *card, int tostate)
-{
-	u16 active_mask = acpi_state_mask[tostate];
-	u8 state;
-
-	if(!use_pm) return;
-
-	pci_read_config_byte(card->pcidev, card->power_regs+0x4, &state);
-	state&=3;
-
-	/* make sure we're in the right state */
-	if(state != tostate) {
-		M_printk(KERN_WARNING "maestro: dev %02x:%02x.%x switching from D%d to D%d\n",
-			card->pcidev->bus->number, 
-			PCI_SLOT(card->pcidev->devfn),
-			PCI_FUNC(card->pcidev->devfn),
-			state,tostate);
-		pci_write_config_byte(card->pcidev, card->power_regs+0x4, tostate);
-	}
-
-	/* and make sure the units we care about are on 
-		XXX we might want to do this before state flipping? */
-	pci_write_config_word(card->pcidev, 0x54, ~ active_mask);
-	pci_write_config_word(card->pcidev, 0x56, ~ active_mask);
-}
-
-/* we allocate a large power of two for all our memory.
-	this is cut up into (not to scale :):
-	|silly fifo word	| 512byte mixbuf per adc	| dac/adc * channels |
-*/
-static int
-allocate_buffers(struct ess_state *s)
-{
-	void *rawbuf=NULL;
-	int order,i;
-	struct page *page, *pend;
-
-	/* alloc as big a chunk as we can */
-	for (order = (dsps_order + (16-PAGE_SHIFT) + 1); order >= (dsps_order + 2 + 1); order--)
-		if((rawbuf = (void *)__get_free_pages(GFP_KERNEL|GFP_DMA, order)))
-			break;
-
-	if (!rawbuf)
-		return 1;
-
-	M_printk("maestro: allocated %ld (%d) bytes at %p\n",PAGE_SIZE<<order,order, rawbuf);
-
-	if ((virt_to_bus(rawbuf) + (PAGE_SIZE << order) - 1) & ~((1<<28)-1))  {
-		printk(KERN_ERR "maestro: DMA buffer beyond 256MB! busaddr 0x%lx  size %ld\n",
-			virt_to_bus(rawbuf), PAGE_SIZE << order);
-		kfree(rawbuf);
-		return 1;
-	}
-
-	s->card->dmapages = rawbuf;
-	s->card->dmaorder = order;
-
-	for(i=0;i<NR_DSPS;i++) {
-		struct ess_state *ess = &s->card->channels[i];
-
-		if(ess->dev_audio == -1)
-			continue;
-
-		ess->dma_dac.ready = s->dma_dac.mapped = 0;
-		ess->dma_adc.ready = s->dma_adc.mapped = 0;
-		ess->dma_adc.buforder = ess->dma_dac.buforder = order - 1 - dsps_order - 1;
-
-		/* offset dac and adc buffers starting half way through and then at each [da][ad]c's
-			order's intervals.. */
-		ess->dma_dac.rawbuf = rawbuf + (PAGE_SIZE<<(order-1)) + (i * ( PAGE_SIZE << (ess->dma_dac.buforder + 1 )));
-		ess->dma_adc.rawbuf = ess->dma_dac.rawbuf + ( PAGE_SIZE << ess->dma_dac.buforder);
-		/* offset mixbuf by a mixbuf so that the lame status fifo can
-			happily scribble away.. */ 
-		ess->mixbuf = rawbuf + (512 * (i+1));
-
-		M_printk("maestro: setup apu %d: dac: %p adc: %p mix: %p\n",i,ess->dma_dac.rawbuf,
-			ess->dma_adc.rawbuf, ess->mixbuf);
-
-	}
-
-	/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-	pend = virt_to_page(rawbuf + (PAGE_SIZE << order) - 1);
-	for (page = virt_to_page(rawbuf); page <= pend; page++)
-		SetPageReserved(page);
-
-	return 0;
-} 
-static void
-free_buffers(struct ess_state *s)
-{
-	struct page *page, *pend;
-
-	s->dma_dac.rawbuf = s->dma_adc.rawbuf = NULL;
-	s->dma_dac.mapped = s->dma_adc.mapped = 0;
-	s->dma_dac.ready = s->dma_adc.ready = 0;
-
-	M_printk("maestro: freeing %p\n",s->card->dmapages);
-	/* undo marking the pages as reserved */
-
-	pend = virt_to_page(s->card->dmapages + (PAGE_SIZE << s->card->dmaorder) - 1);
-	for (page = virt_to_page(s->card->dmapages); page <= pend; page++)
-		ClearPageReserved(page);
-
-	free_pages((unsigned long)s->card->dmapages,s->card->dmaorder);
-	s->card->dmapages = NULL;
-}
-
-static int 
-ess_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	struct ess_state *s = NULL;
-	unsigned char fmtm = ~0, fmts = 0;
-	struct pci_dev *pdev = NULL;
-	/*
-	 *	Scan the cards and find the channel. We only
-	 *	do this at open time so it is ok
-	 */
-
-	while ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
-		struct ess_card *c;
-		struct pci_driver *drvr;
-
-		drvr = pci_dev_driver (pdev);
-		if (drvr == &maestro_pci_driver) {
-			int i;
-			struct ess_state *sp;
-
-			c = (struct ess_card*)pci_get_drvdata (pdev);
-			if (!c)
-				continue;
-			for(i=0;i<NR_DSPS;i++)
-			{
-				sp=&c->channels[i];
-				if(sp->dev_audio < 0)
-					continue;
-				if((sp->dev_audio ^ minor) & ~0xf)
-					continue;
-				s=sp;
-			}
-		}
-	}
-	if (!s)
-		return -ENODEV;
-
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & file->f_mode) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EWOULDBLOCK;
-		}
-		mutex_unlock(&s->open_mutex);
-		interruptible_sleep_on(&s->open_wait);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-
-	/* under semaphore.. */
-	if ((s->card->dmapages==NULL) && allocate_buffers(s)) {
-		mutex_unlock(&s->open_mutex);
-		return -ENOMEM;
-	}
-
-	/* we're covered by the open_mutex */
-	if( ! s->card->dsps_open )  {
-		maestro_power(s->card,ACPI_D0);
-		start_bob(s);
-	}
-	s->card->dsps_open++;
-	M_printk("maestro: open, %d bobs now\n",s->card->dsps_open);
-
-	/* ok, lets write WC base regs now that we've 
-		powered up the chip */
-	M_printk("maestro: writing 0x%lx (bus 0x%lx) to the wp\n",virt_to_bus(s->card->dmapages),
-		((virt_to_bus(s->card->dmapages))&0xFFE00000)>>12);
-	set_base_registers(s,s->card->dmapages);
-
-	if (file->f_mode & FMODE_READ) {
-/*
-		fmtm &= ~((ESS_FMT_STEREO | ESS_FMT_16BIT) << ESS_ADC_SHIFT);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			fmts |= ESS_FMT_16BIT << ESS_ADC_SHIFT; */
-
-		fmtm &= ~((ESS_FMT_STEREO|ESS_FMT_16BIT) << ESS_ADC_SHIFT);
-		fmts = (ESS_FMT_STEREO|ESS_FMT_16BIT) << ESS_ADC_SHIFT;
-
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
-		set_adc_rate(s, 8000);
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		fmtm &= ~((ESS_FMT_STEREO | ESS_FMT_16BIT) << ESS_DAC_SHIFT);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			fmts |= ESS_FMT_16BIT << ESS_DAC_SHIFT;
-
-		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags = s->dma_dac.subdivision = 0;
-		set_dac_rate(s, 8000);
-	}
-	set_fmt(s, fmtm, fmts);
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int 
-ess_release(struct inode *inode, struct file *file)
-{
-	struct ess_state *s = (struct ess_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE)
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac(s);
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-	}
-		
-	s->open_mode &= (~file->f_mode) & (FMODE_READ|FMODE_WRITE);
-	/* we're covered by the open_mutex */
-	M_printk("maestro: %d dsps now alive\n",s->card->dsps_open-1);
-	if( --s->card->dsps_open <= 0) {
-		s->card->dsps_open = 0;
-		stop_bob(s);
-		free_buffers(s);
-		maestro_power(s->card,ACPI_D2);
-	}
-	mutex_unlock(&s->open_mutex);
-	wake_up(&s->open_wait);
-	unlock_kernel();
-	return 0;
-}
-
-static struct file_operations ess_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= ess_read,
-	.write		= ess_write,
-	.poll		= ess_poll,
-	.ioctl		= ess_ioctl,
-	.mmap		= ess_mmap,
-	.open		= ess_open,
-	.release	= ess_release,
-};
-
-static int
-maestro_config(struct ess_card *card) 
-{
-	struct pci_dev *pcidev = card->pcidev;
-	struct ess_state *ess = &card->channels[0];
-	int apu,iobase  = card->iobase;
-	u16 w;
-	u32 n;
-
-	/* We used to muck around with pci config space that
-	 * we had no business messing with.  We don't know enough
-	 * about the machine to know which DMA mode is appropriate, 
-	 * etc.  We were guessing wrong on some machines and making
-	 * them unhappy.  We now trust in the BIOS to do things right,
-	 * which almost certainly means a new host of problems will
-	 * arise with broken BIOS implementations.  screw 'em. 
-	 * We're already intolerant of machines that don't assign
-	 * IRQs.
-	 */
-	
-	/* do config work at full power */
-	maestro_power(card,ACPI_D0);
-	 
-	pci_read_config_word(pcidev, 0x50, &w);
-
-	w&=~(1<<5);			/* Don't swap left/right (undoc)*/
-	
-	pci_write_config_word(pcidev, 0x50, w);
-	
-	pci_read_config_word(pcidev, 0x52, &w);
-	w&=~(1<<15);		/* Turn off internal clock multiplier */
-	/* XXX how do we know which to use? */
-	w&=~(1<<14);		/* External clock */
-	
-	w|= (1<<7);		/* Hardware volume control on */
-	w|= (1<<6);		/* Debounce off: easier to push the HWV buttons. */
-	w&=~(1<<5);		/* GPIO 4:5 */
-	w|= (1<<4);             /* Disconnect from the CHI.  Enabling this made a dell 7500 work. */
-	w&=~(1<<2);		/* MIDI fix off (undoc) */
-	w&=~(1<<1);		/* reserved, always write 0 */
-	pci_write_config_word(pcidev, 0x52, w);
-	
-	/*
-	 *	Legacy mode
-	 */
-
-	pci_read_config_word(pcidev, 0x40, &w);
-	w|=(1<<15);	/* legacy decode off */
-	w&=~(1<<14);	/* Disable SIRQ */
-	w&=~(0x1f);	/* disable mpu irq/io, game port, fm, SB */
-	 
-	pci_write_config_word(pcidev, 0x40, w);
-
-	/* Set up 978 docking control chip. */
-	pci_read_config_word(pcidev, 0x58, &w);
-	w|=1<<2;	/* Enable 978. */
-	w|=1<<3;	/* Turn on 978 hardware volume control. */
-	w&=~(1<<11);	/* Turn on 978 mixer volume control. */
-	pci_write_config_word(pcidev, 0x58, w);
-	
-	sound_reset(iobase);
-
-	/*
-	 *	Ring Bus Setup
-	 */
-
-	/* setup usual 0x34 stuff.. 0x36 may be chip specific */
-        outw(0xC090, iobase+0x34); /* direct sound, stereo */
-        udelay(20);
-        outw(0x3000, iobase+0x36); /* direct sound, stereo */
-        udelay(20);
-
-
-	/*
-	 *	Reset the CODEC
-	 */
-	 
-	maestro_ac97_reset(iobase,pcidev);
-	
-	/*
-	 *	Ring Bus Setup
-	 */
-	 	 
-	n=inl(iobase+0x34);
-	n&=~0xF000;
-	n|=12<<12;		/* Direct Sound, Stereo */
-	outl(n, iobase+0x34);
-
-	n=inl(iobase+0x34);
-	n&=~0x0F00;		/* Modem off */
-	outl(n, iobase+0x34);
-
-	n=inl(iobase+0x34);
-	n&=~0x00F0;
-	n|=9<<4;		/* DAC, Stereo */
-	outl(n, iobase+0x34);
-	
-	n=inl(iobase+0x34);
-	n&=~0x000F;		/* ASSP off */
-	outl(n, iobase+0x34);
-	
-	n=inl(iobase+0x34);
-	n|=(1<<29);		/* Enable ring bus */
-	outl(n, iobase+0x34);
-	
-	n=inl(iobase+0x34);
-	n|=(1<<28);		/* Enable serial bus */
-	outl(n, iobase+0x34);
-	
-	n=inl(iobase+0x34);
-	n&=~0x00F00000;		/* MIC off */
-	outl(n, iobase+0x34);
-	
-	n=inl(iobase+0x34);
-	n&=~0x000F0000;		/* I2S off */
-	outl(n, iobase+0x34);
-	
-
-	w=inw(iobase+0x18);
-	w&=~(1<<7);		/* ClkRun off */
-	outw(w, iobase+0x18);
-
-	w=inw(iobase+0x18);
-	w&=~(1<<6);		/* Hardware volume control interrupt off... for now. */
-	outw(w, iobase+0x18);
-	
-	w=inw(iobase+0x18);
-	w&=~(1<<4);		/* ASSP irq off */
-	outw(w, iobase+0x18);
-	
-	w=inw(iobase+0x18);
-	w&=~(1<<3);		/* ISDN irq off */
-	outw(w, iobase+0x18);
-	
-	w=inw(iobase+0x18);
-	w|=(1<<2);		/* Direct Sound IRQ on */
-	outw(w, iobase+0x18);
-
-	w=inw(iobase+0x18);
-	w&=~(1<<1);		/* MPU401 IRQ off */
-	outw(w, iobase+0x18);
-
-	w=inw(iobase+0x18);
-	w|=(1<<0);		/* SB IRQ on */
-	outw(w, iobase+0x18);
-
-	/* Set hardware volume control registers to midpoints.
-	   We can tell which button was pushed based on how they change. */
-	outb(0x88, iobase+0x1c);
-	outb(0x88, iobase+0x1d);
-	outb(0x88, iobase+0x1e);
-	outb(0x88, iobase+0x1f);
-
-	/* it appears some maestros (dell 7500) only work if these are set,
-		regardless of whether we use the assp or not. */
-
-	outb(0, iobase+0xA4); 
-	outb(3, iobase+0xA2); 
-	outb(0, iobase+0xA6);
-	
-	for(apu=0;apu<16;apu++)
-	{
-		/* Write 0 into the buffer area 0x1E0->1EF */
-		outw(0x01E0+apu, 0x10+iobase);
-		outw(0x0000, 0x12+iobase);
-	
-		/*
-		 * The 1.10 test program seem to write 0 into the buffer area
-		 * 0x1D0-0x1DF too.
-		 */
-		outw(0x01D0+apu, 0x10+iobase);
-		outw(0x0000, 0x12+iobase);
-	}
-
-#if 1
-	wave_set_register(ess, IDR7_WAVE_ROMRAM, 
-		(wave_get_register(ess, IDR7_WAVE_ROMRAM)&0xFF00));
-	wave_set_register(ess, IDR7_WAVE_ROMRAM,
-		wave_get_register(ess, IDR7_WAVE_ROMRAM)|0x100);
-	wave_set_register(ess, IDR7_WAVE_ROMRAM,
-		wave_get_register(ess, IDR7_WAVE_ROMRAM)&~0x200);
-	wave_set_register(ess, IDR7_WAVE_ROMRAM,
-		wave_get_register(ess, IDR7_WAVE_ROMRAM)|~0x400);
-#else		
-	maestro_write(ess, IDR7_WAVE_ROMRAM, 
-		(maestro_read(ess, IDR7_WAVE_ROMRAM)&0xFF00));
-	maestro_write(ess, IDR7_WAVE_ROMRAM,
-		maestro_read(ess, IDR7_WAVE_ROMRAM)|0x100);
-	maestro_write(ess, IDR7_WAVE_ROMRAM,
-		maestro_read(ess, IDR7_WAVE_ROMRAM)&~0x200);
-	maestro_write(ess, IDR7_WAVE_ROMRAM,
-		maestro_read(ess, IDR7_WAVE_ROMRAM)|0x400);
-#endif
-	
-	maestro_write(ess, IDR2_CRAM_DATA, 0x0000);
-	maestro_write(ess, 0x08, 0xB004);
-	/* Now back to the DirectSound stuff */
-	maestro_write(ess, 0x09, 0x001B);
-	maestro_write(ess, 0x0A, 0x8000);
-	maestro_write(ess, 0x0B, 0x3F37);
-	maestro_write(ess, 0x0C, 0x0098);
-	
-	/* parallel out ?? */
-	maestro_write(ess, 0x0C, 
-		(maestro_read(ess, 0x0C)&~0xF000)|0x8000); 
-	/* parallel in, has something to do with recording :) */
-	maestro_write(ess, 0x0C, 
-		(maestro_read(ess, 0x0C)&~0x0F00)|0x0500);
-
-	maestro_write(ess, 0x0D, 0x7632);
-			
-	/* Wave cache control on - test off, sg off, 
-		enable, enable extra chans 1Mb */
-
-	outw(inw(0x14+iobase)|(1<<8),0x14+iobase);
-	outw(inw(0x14+iobase)&0xFE03,0x14+iobase);
-	outw((inw(0x14+iobase)&0xFFFC), 0x14+iobase);
-	outw(inw(0x14+iobase)|(1<<7),0x14+iobase);
-
-	outw(0xA1A0, 0x14+iobase);      /* 0300 ? */
-
-	/* Now clear the APU control ram */	
-	for(apu=0;apu<NR_APUS;apu++)
-	{
-		for(w=0;w<NR_APU_REGS;w++)
-			apu_set_register(ess, apu|ESS_CHAN_HARD, w, 0);
-		
-	}
-
-	return 0;
-	
-}
-
-/* this guy tries to find the pci power management
- * register bank.  this should really be in core
- * code somewhere.  1 on success. */
-static int
-parse_power(struct ess_card *card, struct pci_dev *pcidev)
-{
-	u32 n;
-	u16 w;
-	u8 next;
-	int max = 64;  /* an a 8bit guy pointing to 32bit guys
-				can only express so much. */
-
-	card->power_regs = 0;
-
-	/* check to see if we have a capabilities list in
-		the config register */
-	pci_read_config_word(pcidev, PCI_STATUS, &w);
-	if(!(w & PCI_STATUS_CAP_LIST)) return 0;
-
-	/* walk the list, starting at the head. */
-	pci_read_config_byte(pcidev,PCI_CAPABILITY_LIST,&next);
-
-	while(next && max--) {
-		pci_read_config_dword(pcidev, next & ~3, &n);
-		if((n & 0xff) == PCI_CAP_ID_PM) {
-			card->power_regs = next;
-			break;
-		}
-		next = ((n>>8) & 0xff);
-	}
-
-	return card->power_regs ? 1 : 0;
-}
-
-static int __init
-maestro_probe(struct pci_dev *pcidev,const struct pci_device_id *pdid)
-{
-	int card_type = pdid->driver_data;
-	u32 n;
-	int iobase;
-	int i, ret;
-	struct ess_card *card;
-	struct ess_state *ess;
-	int num = 0;
-
-/* when built into the kernel, we only print version if device is found */
-#ifndef MODULE
-	static int printed_version;
-	if (!printed_version++)
-		printk(version);
-#endif
-
-	/* don't pick up weird modem maestros */
-	if(((pcidev->class >> 8) & 0xffff) != PCI_CLASS_MULTIMEDIA_AUDIO)
-		return -ENODEV;
-
-
-	if ((ret=pci_enable_device(pcidev)))
-		return ret;
-			
-	iobase = pci_resource_start(pcidev,0);
-	if (!iobase || !(pci_resource_flags(pcidev, 0 ) & IORESOURCE_IO))
-		return -ENODEV;
-
-	if(pcidev->irq == 0)
-		return -ENODEV;
-
-	/* stake our claim on the iospace */
-	if( request_region(iobase, 256, card_names[card_type]) == NULL )
-	{
-		printk(KERN_WARNING "maestro: can't allocate 256 bytes I/O at 0x%4.4x\n", iobase);
-		return -EBUSY;
-	}
-
-	/* just to be sure */
-	pci_set_master(pcidev);
-
-	card = kmalloc(sizeof(struct ess_card), GFP_KERNEL);
-	if(card == NULL)
-	{
-		printk(KERN_WARNING "maestro: out of memory\n");
-		release_region(iobase, 256);
-		return -ENOMEM;
-	}
-	
-	memset(card, 0, sizeof(*card));
-	card->pcidev = pcidev;
-
-	card->iobase = iobase;
-	card->card_type = card_type;
-	card->irq = pcidev->irq;
-	card->magic = ESS_CARD_MAGIC;
-	spin_lock_init(&card->lock);
-	init_waitqueue_head(&card->suspend_queue);
-
-	card->dock_mute_vol = 50;
-	
-	/* init our groups of 6 apus */
-	for(i=0;i<NR_DSPS;i++)
-	{
-		struct ess_state *s=&card->channels[i];
-
-		s->index = i;
-
-		s->card = card;
-		init_waitqueue_head(&s->dma_adc.wait);
-		init_waitqueue_head(&s->dma_dac.wait);
-		init_waitqueue_head(&s->open_wait);
-		spin_lock_init(&s->lock);
-		mutex_init(&s->open_mutex);
-		s->magic = ESS_STATE_MAGIC;
-		
-		s->apu[0] = 6*i;
-		s->apu[1] = (6*i)+1;
-		s->apu[2] = (6*i)+2;
-		s->apu[3] = (6*i)+3;
-		s->apu[4] = (6*i)+4;
-		s->apu[5] = (6*i)+5;
-		
-		if(s->dma_adc.ready || s->dma_dac.ready || s->dma_adc.rawbuf)
-			printk("maestro: BOTCH!\n");
-		/* register devices */
-		if ((s->dev_audio = register_sound_dsp(&ess_audio_fops, -1)) < 0)
-			break;
-	}
-	
-	num = i;
-	
-	/* clear the rest if we ran out of slots to register */
-	for(;i<NR_DSPS;i++)
-	{
-		struct ess_state *s=&card->channels[i];
-		s->dev_audio = -1;
-	}
-	
-	ess = &card->channels[0];
-
-	/*
-	 *	Ok card ready. Begin setup proper
-	 */
-
-	printk(KERN_INFO "maestro: Configuring %s found at IO 0x%04X IRQ %d\n", 
-		card_names[card_type],iobase,card->irq);
-	pci_read_config_dword(pcidev, PCI_SUBSYSTEM_VENDOR_ID, &n);
-	printk(KERN_INFO "maestro:  subvendor id: 0x%08x\n",n); 
-
-	/* turn off power management unless:
-	 *	- the user explicitly asks for it
-	 * 		or
-	 *		- we're not a 2e, lesser chipps seem to have problems.
-	 *		- we're not on our _very_ small whitelist.  some implemenetations
-	 *			really don't like the pm code, others require it.
-	 *			feel free to expand this as required.
-	 */
-#define SUBSYSTEM_VENDOR(x) (x&0xffff)
-	if(	(use_pm != 1) && 
-		((card_type != TYPE_MAESTRO2E)	|| (SUBSYSTEM_VENDOR(n) != 0x1028)))
-			use_pm = 0;
-
-	if(!use_pm) 
-		printk(KERN_INFO "maestro: not attempting power management.\n");
-	else {
-		if(!parse_power(card,pcidev)) 
-			printk(KERN_INFO "maestro: no PCI power management interface found.\n");
-		else {
-			pci_read_config_dword(pcidev, card->power_regs, &n);
-			printk(KERN_INFO "maestro: PCI power management capability: 0x%x\n",n>>16);
-		}	
-	}
-
-	maestro_config(card);
-
-	if(maestro_ac97_get(card, 0x00)==0x0080) {
-		printk(KERN_ERR "maestro: my goodness!  you seem to have a pt101 codec, which is quite rare.\n"
-				"\tyou should tell someone about this.\n");
-	} else {
-		maestro_ac97_init(card);
-	}
-
-	if ((card->dev_mixer = register_sound_mixer(&ess_mixer_fops, -1)) < 0) {
-		printk("maestro: couldn't register mixer!\n");
-	} else {
-		memcpy(card->mix.mixer_state,mixer_defaults,sizeof(card->mix.mixer_state));
-		mixer_push_state(card);
-	}
-	
-	if((ret=request_irq(card->irq, ess_interrupt, IRQF_SHARED, card_names[card_type], card)))
-	{
-		printk(KERN_ERR "maestro: unable to allocate irq %d,\n", card->irq);
-		unregister_sound_mixer(card->dev_mixer);
-		for(i=0;i<NR_DSPS;i++)
-		{
-			struct ess_state *s = &card->channels[i];
-			if(s->dev_audio != -1)
-				unregister_sound_dsp(s->dev_audio);
-		}
-		release_region(card->iobase, 256);		
-		unregister_reboot_notifier(&maestro_nb);
-		kfree(card);
-		return ret;
-	}
-
-	/* Turn on hardware volume control interrupt.
-	   This has to come after we grab the IRQ above,
-	   or a crash will result on installation if a button has been pressed,
-	   because in that case we'll get an immediate interrupt. */
-	n = inw(iobase+0x18);
-	n|=(1<<6);
-	outw(n, iobase+0x18);
-
-	pci_set_drvdata(pcidev,card);
-	/* now go to sleep 'till something interesting happens */
-	maestro_power(card,ACPI_D2);
-
-	printk(KERN_INFO "maestro: %d channels configured.\n", num);
-	return 0;
-}
-
-static void maestro_remove(struct pci_dev *pcidev) {
-	struct ess_card *card = pci_get_drvdata(pcidev);
-	int i;
-	u32 n;
-	
-	/* XXX maybe should force stop bob, but should be all 
-		stopped by _release by now */
-
-	/* Turn off hardware volume control interrupt.
-	   This has to come before we leave the IRQ below,
-	   or a crash results if a button is pressed ! */
-	n = inw(card->iobase+0x18);
-	n&=~(1<<6);
-	outw(n, card->iobase+0x18);
-
-	free_irq(card->irq, card);
-	unregister_sound_mixer(card->dev_mixer);
-	for(i=0;i<NR_DSPS;i++)
-	{
-		struct ess_state *ess = &card->channels[i];
-		if(ess->dev_audio != -1)
-			unregister_sound_dsp(ess->dev_audio);
-	}
-	/* Goodbye, Mr. Bond. */
-	maestro_power(card,ACPI_D3);
- 	release_region(card->iobase, 256);
-	kfree(card);
-	pci_set_drvdata(pcidev,NULL);
-}
-
-static struct pci_device_id maestro_pci_tbl[] = {
-	{PCI_VENDOR_ESS, PCI_DEVICE_ID_ESS_ESS1968, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPE_MAESTRO2},
-	{PCI_VENDOR_ESS, PCI_DEVICE_ID_ESS_ESS1978, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPE_MAESTRO2E},
-	{PCI_VENDOR_ESS_OLD, PCI_DEVICE_ID_ESS_ESS0100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TYPE_MAESTRO},
-	{0,}
-};
-MODULE_DEVICE_TABLE(pci, maestro_pci_tbl);
-
-static struct pci_driver maestro_pci_driver = {
-	.name	  = "maestro",
-	.id_table = maestro_pci_tbl,
-	.probe	  = maestro_probe,
-	.remove	  = maestro_remove,
-};
-
-static int __init init_maestro(void)
-{
-	int rc;
-
-	rc = pci_register_driver(&maestro_pci_driver);
-	if (rc < 0)
-		return rc;
-
-	if (register_reboot_notifier(&maestro_nb))
-		printk(KERN_WARNING "maestro: reboot notifier registration failed; may not reboot properly.\n");
-#ifdef MODULE
-	printk(version);
-#endif
-	if (dsps_order < 0)   {
-		dsps_order = 1;
-		printk(KERN_WARNING "maestro: clipping dsps_order to %d\n",dsps_order);
-	}
-	else if (dsps_order > MAX_DSP_ORDER)  {
-		dsps_order = MAX_DSP_ORDER;
-		printk(KERN_WARNING "maestro: clipping dsps_order to %d\n",dsps_order);
-	}
-	return 0;
-}
-
-static int maestro_notifier(struct notifier_block *nb, unsigned long event, void *buf)
-{
-	/* this notifier is called when the kernel is really shut down. */
-	M_printk("maestro: shutting down\n");
-	/* this will remove all card instances too */
-	pci_unregister_driver(&maestro_pci_driver);
-	/* XXX dunno about power management */
-	return NOTIFY_OK;
-}
-
-/* --------------------------------------------------------------------- */
-
-
-static void cleanup_maestro(void) {
-	M_printk("maestro: unloading\n");
-	pci_unregister_driver(&maestro_pci_driver);
-	unregister_reboot_notifier(&maestro_nb);
-}
-
-/* --------------------------------------------------------------------- */
-
-void
-check_suspend(struct ess_card *card)
-{
-	DECLARE_WAITQUEUE(wait, current);
-
-	if(!card->in_suspend) return;
-
-	card->in_suspend++;
-	add_wait_queue(&(card->suspend_queue), &wait);
-	current->state = TASK_UNINTERRUPTIBLE;
-	schedule();
-	remove_wait_queue(&(card->suspend_queue), &wait);
-	current->state = TASK_RUNNING;
-}
-
-module_init(init_maestro);
-module_exit(cleanup_maestro);
--- linux-2.6.18.noarch/sound/oss/iwmem.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/iwmem.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,36 +0,0 @@
-/*
- * sound/iwmem.h
- *
- * DRAM size encoding table for AMD Interwave chip.
- */
-/*
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- * Changes:
- * Bartlomiej Zolnierkiewicz	: added __initdata to mem_decode
- */
-
-
-#define K 1024
-#define M (1024*K)
-static int mem_decode[][4] __initdata =
-{
-/*	Bank0	Bank1	Bank2	Bank3	Encoding bits	*/
-	{256*K,	0,	0,	0},		/*  0 */
-	{256*K,	256*K,	0,	0},		/*  1 */
-	{256*K,	256*K,	256*K,	256*K},		/*  2 */
-	{256*K,	1*M,	0,	0},		/*  3 */
-	{256*K,	1*M,	1*M,	1*M},		/*  4 */
-	{256*K,	256*K,	1*M,	0},		/*  5 */
-	{256*K,	256*K,	1*M,	1*M},		/*  6 */
-	{1*M,	0,	0,	0},		/*  7 */
-	{1*M,	1*M,	0,	0},		/*  8 */
-	{1*M,	1*M,	1*M,	1*M},		/*  9 */
-	{4*M,	0,	0,	0},		/* 10 */
-	{4*M,	4*M,	0,	0},		/* 11 */
-	{4*M,	4*M,	4*M,	4*M}		/* 12 */
-};
--- linux-2.6.18.noarch/sound/oss/nm256_audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/nm256_audio.c	2007-06-05 17:44:14.000000000 -0400
@@ -45,8 +45,8 @@
 
 static int nm256_grabInterrupt (struct nm256_info *card);
 static int nm256_releaseInterrupt (struct nm256_info *card);
-static irqreturn_t nm256_interrupt (int irq, void *dev_id, struct pt_regs *dummy);
-static irqreturn_t nm256_interrupt_zx (int irq, void *dev_id, struct pt_regs *dummy);
+static irqreturn_t nm256_interrupt (int irq, void *dev_id);
+static irqreturn_t nm256_interrupt_zx (int irq, void *dev_id);
 
 /* These belong in linux/pci.h. */
 #define PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO 0x8005
@@ -526,7 +526,7 @@
  */
 
 static irqreturn_t
-nm256_interrupt (int irq, void *dev_id, struct pt_regs *dummy)
+nm256_interrupt (int irq, void *dev_id)
 {
     struct nm256_info *card = (struct nm256_info *)dev_id;
     u16 status;
@@ -629,7 +629,7 @@
  */
 
 static irqreturn_t
-nm256_interrupt_zx (int irq, void *dev_id, struct pt_regs *dummy)
+nm256_interrupt_zx (int irq, void *dev_id)
 {
     struct nm256_info *card = (struct nm256_info *)dev_id;
     u32 status;
@@ -1237,7 +1237,7 @@
     return -1; /* should not come here ... */
 }
 
-static void __devexit
+static void __devinit
 nm256_remove(struct pci_dev *pcidev) {
     struct nm256_info *xcard = pci_get_drvdata(pcidev);
     struct nm256_info *card,*next_card = NULL;
@@ -1633,7 +1633,7 @@
 	.name		= "nm256_audio",
 	.id_table	= nm256_pci_tbl,
 	.probe		= nm256_probe,
-	.remove		= __devexit_p(nm256_remove),
+	.remove		= nm256_remove,
 };
 
 module_param(usecache, bool, 0);
--- linux-2.6.18.noarch/sound/oss/waveartist.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/waveartist.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/sound/waveartist.c
+ * linux/sound/oss/waveartist.c
  *
  * The low level driver for the RWA010 Rockwell Wave Artist
  * codec chip used in the Rebel.com NetWinder.
@@ -833,7 +833,7 @@
 
 
 static irqreturn_t
-waveartist_intr(int irq, void *dev_id, struct pt_regs *regs)
+waveartist_intr(int irq, void *dev_id)
 {
 	wavnc_info *devc = (wavnc_info *)dev_id;
 	int	   irqstatus, status;
@@ -1267,12 +1267,10 @@
 	conf_printf2(dev_name, devc->hw.io_base, devc->hw.irq,
 		     devc->hw.dma, devc->hw.dma2);
 
-	portc = (wavnc_port_info *)kmalloc(sizeof(wavnc_port_info), GFP_KERNEL);
+	portc = kzalloc(sizeof(wavnc_port_info), GFP_KERNEL);
 	if (portc == NULL)
 		goto nomem;
 
-	memset(portc, 0, sizeof(wavnc_port_info));
-
 	my_dev = sound_install_audiodrv(AUDIO_DRIVER_VERSION, dev_name,
 			&waveartist_audio_driver, sizeof(struct audio_driver),
 			devc->audio_flags, AFMT_U8 | AFMT_S16_LE | AFMT_S8,
--- linux-2.6.18.noarch/sound/oss/msnd_pinnacle.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/msnd_pinnacle.c	2007-06-05 17:44:14.000000000 -0400
@@ -1007,7 +1007,7 @@
 
 static ssize_t dev_read(struct file *file, char __user *buf, size_t count, loff_t *off)
 {
-	int minor = iminor(file->f_dentry->d_inode);
+	int minor = iminor(file->f_path.dentry->d_inode);
 	if (minor == dev.dsp_minor)
 		return dsp_read(buf, count);
 	else
@@ -1016,7 +1016,7 @@
 
 static ssize_t dev_write(struct file *file, const char __user *buf, size_t count, loff_t *off)
 {
-	int minor = iminor(file->f_dentry->d_inode);
+	int minor = iminor(file->f_path.dentry->d_inode);
 	if (minor == dev.dsp_minor)
 		return dsp_write(buf, count);
 	else
@@ -1087,7 +1087,7 @@
 	}
 }
 
-static irqreturn_t intr(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t intr(int irq, void *dev_id)
 {
 	/* Send ack to DSP */
 	msnd_inb(dev.io + HP_RXL);
@@ -1106,7 +1106,7 @@
 	return IRQ_HANDLED;
 }
 
-static struct file_operations dev_fileops = {
+static const struct file_operations dev_fileops = {
 	.owner		= THIS_MODULE,
 	.read		= dev_read,
 	.write		= dev_write,
--- linux-2.6.18.noarch/sound/oss/Kconfig.orig	2007-06-05 16:07:54.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/Kconfig	2007-06-05 17:44:14.000000000 -0400
@@ -5,7 +5,7 @@
 #
 # Prompt user for primary drivers.
 
-config OSS_OBSOLETE_DRIVER
+config OBSOLETE_OSS
 	bool "Obsolete OSS drivers"
 	depends on SOUND_PRIME
 	help
@@ -35,40 +35,6 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called btaudio.
 
-config SOUND_EMU10K1
-	tristate "Creative SBLive! (EMU10K1)"
-	depends on SOUND_PRIME && PCI && OSS_OBSOLETE_DRIVER
-	---help---
-	  Say Y or M if you have a PCI sound card using the EMU10K1 chipset,
-	  such as the Creative SBLive!, SB PCI512 or Emu-APS.
-
-	  For more information on this driver and the degree of support for
-	  the different card models please check:
-
-		<http://sourceforge.net/projects/emu10k1/>
-
-	  It is now possible to load dsp microcode patches into the EMU10K1
-	  chip.  These patches are used to implement real time sound
-	  processing effects which include for example: signal routing,
-	  bass/treble control, AC3 passthrough, ...
-	  Userspace tools to create new patches and load/unload them can be
-	  found in the emu-tools package at the above URL.
-
-config MIDI_EMU10K1
-	bool "Creative SBLive! MIDI (EXPERIMENTAL)"
-	depends on SOUND_EMU10K1 && EXPERIMENTAL && ISA_DMA_API
-	help
-	  Say Y if you want to be able to use the OSS /dev/sequencer
-	  interface.  This code is still experimental.
-
-config SOUND_FUSION
-	tristate "Crystal SoundFusion (CS4280/461x)"
-	depends on SOUND_PRIME && PCI && OSS_OBSOLETE_DRIVER
-	help
-	  This module drives the Crystal SoundFusion devices (CS4280/46xx
-	  series) when wired as native sound drivers with AC97 codecs.  If
-	  this driver does not work try the CS4232 driver.
-
 config SOUND_BCM_CS4297A
 	tristate "Crystal Sound CS4297a (for Swarm)"
 	depends on SOUND_PRIME && SIBYTE_SWARM
@@ -81,7 +47,7 @@
 
 config SOUND_ES1371
 	tristate "Creative Ensoniq AudioPCI 97 (ES1371)"
-	depends on SOUND_PRIME && PCI
+	depends on SOUND_PRIME && PCI && OBSOLETE_OSS
 	help
 	  Say Y or M if you have a PCI sound card utilizing the Ensoniq
 	  ES1371 chipset, such as Ensoniq's AudioPCI97. To find out if
@@ -115,10 +81,6 @@
 	  Say Y or M if you have an SGI Indy or Indigo2 system and want to be able to
 	  use its on-board A2 audio system.
 
-config SOUND_IT8172
-	tristate "IT8172G Sound"
-	depends on SOUND_PRIME && (MIPS_ITE8172 || MIPS_IVR)
-
 config SOUND_VRC5477
 	tristate "NEC Vrc5477 AC97 sound"
 	depends on SOUND_PRIME && DDB5477
@@ -452,47 +414,6 @@
 
 	  Say Y unless you have 16MB or more RAM or a PCI sound card.
 
-config SOUND_AD1816
-	tristate "AD1816(A) based cards (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && SOUND_OSS && OSS_OBSOLETE_DRIVER
-	help
-	  Say M here if you have a sound card based on the Analog Devices
-	  AD1816(A) chip.
-
-	  If you compile the driver into the kernel, you have to add
-	  "ad1816=<io>,<irq>,<dma>,<dma2>" to the kernel command line.
-
-config SOUND_AD1889
-	tristate "AD1889 based cards (AD1819 codec) (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && SOUND_OSS && PCI && OSS_OBSOLETE_DRIVER
-	help
-	  Say M here if you have a sound card based on the Analog Devices
-	  AD1889 chip.
-
-config SOUND_ADLIB
-	tristate "Adlib Cards"
-	depends on SOUND_OSS && OSS_OBSOLETE_DRIVER
-	help
-	  Includes ASB 64 4D. Information on programming AdLib cards is
-	  available at <http://www.itsnet.com/home/ldragon/Specs/adlib.html>.
-
-config SOUND_ACI_MIXER
-	tristate "ACI mixer (miroSOUND PCM1-pro/PCM12/PCM20)"
-	depends on SOUND_OSS && OSS_OBSOLETE_DRIVER
-	---help---
-	  ACI (Audio Command Interface) is a protocol used to communicate with
-	  the microcontroller on some sound cards produced by miro and
-	  Cardinal Technologies.  The main function of the ACI is to control
-	  the mixer and to get a product identification.
-
-	  This VoxWare ACI driver currently supports the ACI functions on the
-	  miroSOUND PCM1-pro, PCM12 and PCM20 radio. On the PCM20 radio, ACI
-	  also controls the radio tuner. This is supported in the video4linux
-	  miropcm20 driver (say M or Y here and go back to "Multimedia
-	  devices" -> "Radio Adapters").
-
-	  This driver is also available as a module and will be called aci.
-
 config SOUND_CS4232
 	tristate "Crystal CS4232 based (PnP) cards"
 	depends on SOUND_OSS
@@ -598,18 +519,6 @@
 	  If you compile the driver into the kernel, you have to add
 	  "mpu401=<io>,<irq>" to the kernel command line.
 
-config SOUND_NM256
-	tristate "NM256AV/NM256ZX audio support"
-	depends on SOUND_OSS && OSS_OBSOLETE_DRIVER
-	help
-	  Say M here to include audio support for the NeoMagic 256AV/256ZX
-	  chipsets. These are the audio chipsets found in the Sony
-	  Z505S/SX/DX, some Sony F-series, and the Dell Latitude CPi and CPt
-	  laptops. It includes support for an AC97-compatible mixer and an
-	  apparently proprietary sound engine.
-
-	  See <file:Documentation/sound/oss/NM256> for further information.
-
 config SOUND_PAS
 	tristate "ProAudioSpectrum 16 support"
 	depends on SOUND_OSS
@@ -647,7 +556,7 @@
 	  command line.
 
 config PSS_MIXER
-	bool "Enable PSS mixer (Beethoven ADSP-16 and other compatibile)"
+	bool "Enable PSS mixer (Beethoven ADSP-16 and other compatible)"
 	depends on SOUND_PSS
 	help
 	  Answer Y for Beethoven ADSP-16. You may try to say Y also for other
@@ -718,20 +627,6 @@
 
 	  If unsure, say Y.
 
-config SOUND_OPL3SA2
-	tristate "Yamaha OPL3-SA2 and SA3 based PnP cards"
-	depends on SOUND_OSS && OSS_OBSOLETE_DRIVER
-	help
-	  Say Y or M if you have a card based on one of these Yamaha sound
-	  chipsets or the "SAx", which is actually a SA3. Read
-	  <file:Documentation/sound/oss/OPL3-SA2> for more information on
-	  configuring these cards.
-
-	  If you compile the driver into the kernel and do not also
-	  configure in the optional ISA PnP support, you will have to add
-	  "opl3sa2=<io>,<irq>,<dma>,<dma2>,<mssio>,<mpuio>" to the kernel
-	  command line.
-
 config SOUND_UART6850
 	tristate "6850 UART support"
 	depends on SOUND_OSS
@@ -824,18 +719,6 @@
 
 endchoice
 
-config AEDSP16_MPU401
-	bool "Audio Excel DSP 16 (MPU401 emulation)"
-	depends on SOUND_AEDSP16 && SOUND_MPU401
-	help
-	  Answer Y if you want your audio card to emulate the MPU-401 midi
-	  interface. You should then also say Y to "MPU-401 support".
-
-	  Note that the I/O base for MPU-401 support of aedsp16 is the same
-	  you have selected for "MPU-401 support". If you are using this
-	  driver as a module you have to specify the MPU I/O base address with
-	  the parameter 'mpu_base=0xNNN'.
-
 config SOUND_VIDC
 	tristate "VIDC 16-bit sound"
 	depends on ARM && (ARCH_ACORN || ARCH_CLPS7500) && SOUND_OSS
--- linux-2.6.18.noarch/sound/oss/sound_syms.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sound_syms.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,50 +0,0 @@
-/*
- *	The sound core exports the following symbols to the rest of
- *	modulespace.
- *
- *      (C) Copyright 1997      Alan Cox, Licensed under the GNU GPL
- *
- *	Thu May 27 1999 Andrew J. Kroll <ag784@freenet..buffalo..edu>
- *	left out exported symbol... fixed
- */
-
-#include <linux/module.h>
-#include "sound_config.h"
-#include "sound_calls.h"
-
-char sound_syms_symbol;
-
-EXPORT_SYMBOL(mixer_devs);
-EXPORT_SYMBOL(audio_devs);
-EXPORT_SYMBOL(num_mixers);
-EXPORT_SYMBOL(num_audiodevs);
-
-EXPORT_SYMBOL(midi_devs);
-EXPORT_SYMBOL(num_midis);
-EXPORT_SYMBOL(synth_devs);
-
-EXPORT_SYMBOL(sound_timer_devs);
-
-EXPORT_SYMBOL(sound_install_audiodrv);
-EXPORT_SYMBOL(sound_install_mixer);
-EXPORT_SYMBOL(sound_alloc_dma);
-EXPORT_SYMBOL(sound_free_dma);
-EXPORT_SYMBOL(sound_open_dma);
-EXPORT_SYMBOL(sound_close_dma);
-EXPORT_SYMBOL(sound_alloc_mididev);
-EXPORT_SYMBOL(sound_alloc_mixerdev);
-EXPORT_SYMBOL(sound_alloc_timerdev);
-EXPORT_SYMBOL(sound_alloc_synthdev);
-EXPORT_SYMBOL(sound_unload_audiodev);
-EXPORT_SYMBOL(sound_unload_mididev);
-EXPORT_SYMBOL(sound_unload_mixerdev);
-EXPORT_SYMBOL(sound_unload_timerdev);
-EXPORT_SYMBOL(sound_unload_synthdev);
-
-EXPORT_SYMBOL(load_mixer_volumes);
-
-EXPORT_SYMBOL(conf_printf);
-EXPORT_SYMBOL(conf_printf2);
-
-MODULE_DESCRIPTION("OSS Sound subsystem");
-MODULE_AUTHOR("Hannu Savolainen, et al.");
--- linux-2.6.18.noarch/sound/oss/tuning.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/tuning.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,13 +1,11 @@
-#ifdef SEQUENCER_C
-
-unsigned short semitone_tuning[24] = 
+static unsigned short semitone_tuning[24] =
 {
 /*   0 */ 10000, 10595, 11225, 11892, 12599, 13348, 14142, 14983, 
 /*   8 */ 15874, 16818, 17818, 18877, 20000, 21189, 22449, 23784, 
 /*  16 */ 25198, 26697, 28284, 29966, 31748, 33636, 35636, 37755
 };
 
-unsigned short cent_tuning[100] =
+static unsigned short cent_tuning[100] =
 {
 /*   0 */ 10000, 10006, 10012, 10017, 10023, 10029, 10035, 10041, 
 /*   8 */ 10046, 10052, 10058, 10064, 10070, 10075, 10081, 10087, 
@@ -23,7 +21,3 @@
 /*  88 */ 10521, 10528, 10534, 10540, 10546, 10552, 10558, 10564, 
 /*  96 */ 10570, 10576, 10582, 10589
 };
-#else
-extern unsigned short semitone_tuning[24];
-extern unsigned short cent_tuning[100];
-#endif
--- linux-2.6.18.noarch/sound/oss/maui.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/maui.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,478 +0,0 @@
-/*
- * sound/maui.c
- *
- * The low level driver for Turtle Beach Maui and Tropez.
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- *
- *	Changes:
- *		Alan Cox		General clean up, use kernel IRQ 
- *					system
- *		Christoph Hellwig	Adapted to module_init/module_exit
- *		Bartlomiej Zolnierkiewicz
- *					Added __init to download_code()
- *
- *	Status:
- *		Andrew J. Kroll		Tested 06/01/1999 with:
- *					* OSWF.MOT File Version: 1.15
- *					* OSWF.MOT File Dated: 09/12/94
- *					* Older versions will cause problems.
- */
-
-#include <linux/interrupt.h>
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-
-#define USE_SEQ_MACROS
-#define USE_SIMPLE_MACROS
-
-#include "sound_config.h"
-#include "sound_firmware.h"
-
-#include "mpu401.h"
-
-static int      maui_base = 0x330;
-
-static volatile int irq_ok;
-static int     *maui_osp;
-
-#define HOST_DATA_PORT	(maui_base + 2)
-#define HOST_STAT_PORT	(maui_base + 3)
-#define HOST_CTRL_PORT	(maui_base + 3)
-
-#define STAT_TX_INTR	0x40
-#define STAT_TX_AVAIL	0x20
-#define STAT_TX_IENA	0x10
-#define STAT_RX_INTR	0x04
-#define STAT_RX_AVAIL	0x02
-#define STAT_RX_IENA	0x01
-
-static int      (*orig_load_patch)(int dev, int format, const char __user *addr,
-			      int offs, int count, int pmgr_flag) = NULL;
-
-#include "maui_boot.h"
-
-static int maui_wait(int mask)
-{
-	int i;
-
-	/*
-	 * Perform a short initial wait without sleeping
-	 */
-
-	for (i = 0; i < 100; i++)
-		if (inb(HOST_STAT_PORT) & mask)
-			return 1;
-
-	/*
-	 * Wait up to 15 seconds with sleeping
-	 */
-
-	for (i = 0; i < 150; i++) {
-		if (inb(HOST_STAT_PORT) & mask)
-			return 1;
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(HZ / 10);
-		if (signal_pending(current))
-			return 0;
-	}
-	return 0;
-}
-
-static int maui_read(void)
-{
-	if (maui_wait(STAT_RX_AVAIL))
-		return inb(HOST_DATA_PORT);
-	return -1;
-}
-
-static int maui_write(unsigned char data)
-{
-	if (maui_wait(STAT_TX_AVAIL)) {
-		outb((data), HOST_DATA_PORT);
-		return 1;
-	}
-	printk(KERN_WARNING "Maui: Write timeout\n");
-	return 0;
-}
-
-static irqreturn_t mauiintr(int irq, void *dev_id, struct pt_regs *dummy)
-{
-	irq_ok = 1;
-	return IRQ_HANDLED;
-}
-
-static int __init download_code(void)
-{
-	int i, lines = 0;
-	int eol_seen = 0, done = 0;
-	int skip = 1;
-
-	printk(KERN_INFO "Code download (%d bytes): ", maui_osLen);
-
-	for (i = 0; i < maui_osLen; i++) {
-		if (maui_os[i] != '\r') {
-			if (!skip || (maui_os[i] == 'S' && (i == 0 || maui_os[i - 1] == '\n'))) {
-				skip = 0;
-
-				if (maui_os[i] == '\n')
-					eol_seen = skip = 1;
-				else if (maui_os[i] == 'S') {
-					if (maui_os[i + 1] == '8')
-						done = 1;
-					if (!maui_write(0xF1))
-						goto failure;
-					if (!maui_write('S'))
-						goto failure;
-				} else {
-					if (!maui_write(maui_os[i]))
-						goto failure;
-				}
-
-				if (eol_seen) {
-					int c = 0;
-					int n;
-
-					eol_seen = 0;
-
-					for (n = 0; n < 2; n++) {
-						if (maui_wait(STAT_RX_AVAIL)) {
-							c = inb(HOST_DATA_PORT);
-							break;
-						}
-					}
-					if (c != 0x80) {
-						printk("Download not acknowledged\n");
-						return 0;
-					}
-					else if (!(lines++ % 10))
-						printk(".");
-
-					if (done) {
-						printk("\n");
-						printk(KERN_INFO "Download complete\n");
-						return 1;
-					}
-				}
-			}
-		}
-	}
-
-failure:
-	printk("\n");
-	printk(KERN_ERR "Download failed!!!\n");
-	return 0;
-}
-
-static int __init maui_init(int irq)
-{
-	unsigned char bits;
-
-	switch (irq) {
-		case 9:
-			bits = 0x00;
-			break;
-		case 5:
-			bits = 0x08;
-			break;
-		case 12:
-			bits = 0x10;
-			break;
-		case 15:
-			bits = 0x18;
-			break;
-
-		default:
-			printk(KERN_ERR "Maui: Invalid IRQ %d\n", irq);
-			return 0;
-	}
-	outb((0x00), HOST_CTRL_PORT);	/* Reset */
-	outb((bits), HOST_DATA_PORT);	/* Set the IRQ bits */
-	outb((bits | 0x80), HOST_DATA_PORT);	/* Set the IRQ bits again? */
-	outb((0x80), HOST_CTRL_PORT);	/* Leave reset */
-	outb((0x80), HOST_CTRL_PORT);	/* Leave reset */
-	outb((0xD0), HOST_CTRL_PORT);	/* Cause interrupt */
-
-#ifdef CONFIG_SMP
-	{
-		int i;
-		for (i = 0; i < 1000000 && !irq_ok; i++)
-			;
-		if (!irq_ok)
-			return 0;
-	}
-#endif
-	outb((0x80), HOST_CTRL_PORT);	/* Leave reset */
-
-	printk(KERN_INFO "Turtle Beach Maui initialization\n");
-
-	if (!download_code())
-		return 0;
-
-	outb((0xE0), HOST_CTRL_PORT);	/* Normal operation */
-
-	/* Select mpu401 mode */
-
-	maui_write(0xf0);
-	maui_write(1);
-	if (maui_read() != 0x80) {
-		maui_write(0xf0);
-		maui_write(1);
-		if (maui_read() != 0x80)
-			printk(KERN_ERR "Maui didn't acknowledge set HW mode command\n");
-	}
-	printk(KERN_INFO "Maui initialized OK\n");
-	return 1;
-}
-
-static int maui_short_wait(int mask) {
-	int i;
-
-	for (i = 0; i < 1000; i++) {
-		if (inb(HOST_STAT_PORT) & mask) {
-			return 1;
-		}
-	}
-	return 0;
-}
-
-static int maui_load_patch(int dev, int format, const char __user *addr,
-		int offs, int count, int pmgr_flag)
-{
-
-	struct sysex_info header;
-	unsigned long left, src_offs;
-	int hdr_size = (unsigned long) &header.data[0] - (unsigned long) &header;
-	int i;
-
-	if (format == SYSEX_PATCH)	/* Handled by midi_synth.c */
-		return orig_load_patch(dev, format, addr, offs, count, pmgr_flag);
-
-	if (format != MAUI_PATCH)
-	{
-		  printk(KERN_WARNING "Maui: Unknown patch format\n");
-	}
-	if (count < hdr_size) {
-/*		  printk("Maui error: Patch header too short\n");*/
-		  return -EINVAL;
-	}
-	count -= hdr_size;
-
-	/*
-	 * Copy the header from user space but ignore the first bytes which have
-	 * been transferred already.
-	 */
-
-	if(copy_from_user(&((char *) &header)[offs], &(addr)[offs], hdr_size - offs))
-		return -EFAULT;
-
-	if (count < header.len) {
-		  printk(KERN_ERR "Maui warning: Host command record too short (%d<%d)\n", count, (int) header.len);
-		  header.len = count;
-	}
-	left = header.len;
-	src_offs = 0;
-
-	for (i = 0; i < left; i++) {
-		unsigned char   data;
-
-		if(get_user(*(unsigned char *) &data, (unsigned char __user *) &((addr)[hdr_size + i])))
-			return -EFAULT;
-		if (i == 0 && !(data & 0x80))
-			return -EINVAL;
-
-		if (maui_write(data) == -1)
-			return -EIO;
-	}
-
-	if ((i = maui_read()) != 0x80) {
-		if (i != -1)
-			printk("Maui: Error status %02x\n", i);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int __init probe_maui(struct address_info *hw_config)
-{
-	struct resource *ports;
-	int this_dev;
-	int i;
-	int tmp1, tmp2, ret;
-
-	ports = request_region(hw_config->io_base, 2, "mpu401");
-	if (!ports)
-		return 0;
-
-	if (!request_region(hw_config->io_base + 2, 6, "Maui"))
-		goto out;
-
-	maui_base = hw_config->io_base;
-	maui_osp = hw_config->osp;
-
-	if (request_irq(hw_config->irq, mauiintr, 0, "Maui", NULL) < 0)
-		goto out2;
-
-	/*
-	 * Initialize the processor if necessary
-	 */
-
-	if (maui_osLen > 0) {
-		if (!(inb(HOST_STAT_PORT) & STAT_TX_AVAIL) ||
-			!maui_write(0x9F) ||	/* Report firmware version */
-			!maui_short_wait(STAT_RX_AVAIL) ||
-			maui_read() == -1 || maui_read() == -1)
-			if (!maui_init(hw_config->irq))
-				goto out3;
-	}
-	if (!maui_write(0xCF))	/* Report hardware version */ {
-		printk(KERN_ERR "No WaveFront firmware detected (card uninitialized?)\n");
-		goto out3;
-	}
-	if ((tmp1 = maui_read()) == -1 || (tmp2 = maui_read()) == -1) {
-		printk(KERN_ERR "No WaveFront firmware detected (card uninitialized?)\n");
-		goto out3;
-	}
-	if (tmp1 == 0xff || tmp2 == 0xff)
-		goto out3;
-	printk(KERN_DEBUG "WaveFront hardware version %d.%d\n", tmp1, tmp2);
-
-	if (!maui_write(0x9F))	/* Report firmware version */
-		goto out3;
-	if ((tmp1 = maui_read()) == -1 || (tmp2 = maui_read()) == -1)
-		goto out3;
-
-	printk(KERN_DEBUG "WaveFront firmware version %d.%d\n", tmp1, tmp2);
-
-	if (!maui_write(0x85))	/* Report free DRAM */
-		goto out3;
-	tmp1 = 0;
-	for (i = 0; i < 4; i++) {
-		tmp1 |= maui_read() << (7 * i);
-	}
-	printk(KERN_DEBUG "Available DRAM %dk\n", tmp1 / 1024);
-
-	for (i = 0; i < 1000; i++)
-		if (probe_mpu401(hw_config, ports))
-			break;
-
-	ret = probe_mpu401(hw_config, ports);
-	if (!ret)
-		goto out3;
-
-	conf_printf("Maui", hw_config);
-
-	hw_config->irq *= -1;
-	hw_config->name = "Maui";
-	attach_mpu401(hw_config, THIS_MODULE);
-
-	if (hw_config->slots[1] != -1)	/* The MPU401 driver installed itself */ {
-		struct synth_operations *synth;
-
-		this_dev = hw_config->slots[1];
-
-		/*
-		 * Intercept patch loading calls so that they can be handled
-		 * by the Maui driver.
-		 */
-
-		synth = midi_devs[this_dev]->converter;
-		if (synth != NULL) {
-			synth->id = "MAUI";
-			orig_load_patch = synth->load_patch;
-			synth->load_patch = &maui_load_patch;
-		} else
-			printk(KERN_ERR "Maui: Can't install patch loader\n");
-	}
-	return 1;
-
-out3:
-	free_irq(hw_config->irq, NULL);
-out2:
-	release_region(hw_config->io_base + 2, 6);
-out:
-	release_region(hw_config->io_base, 2);
-	return 0;
-}
-
-static void __exit unload_maui(struct address_info *hw_config)
-{
-	int irq = hw_config->irq;
-	release_region(hw_config->io_base + 2, 6);
-	unload_mpu401(hw_config);
-
-	if (irq < 0)
-		irq = -irq;
-	if (irq > 0)
-		free_irq(irq, NULL);
-}
-
-static int fw_load;
-
-static struct address_info cfg;
-
-static int __initdata io = -1;
-static int __initdata irq = -1;
-
-module_param(io, int, 0);
-module_param(irq, int, 0);
-
-/*
- *	Install a Maui card. Needs mpu401 loaded already.
- */
-
-static int __init init_maui(void)
-{
-	printk(KERN_INFO "Turtle beach Maui and Tropez driver, Copyright (C) by Hannu Savolainen 1993-1996\n");
-
-	cfg.io_base = io;
-	cfg.irq = irq;
-
-	if (cfg.io_base == -1 || cfg.irq == -1) {
-		printk(KERN_INFO "maui: irq and io must be set.\n");
-		return -EINVAL;
-	}
-
-	if (maui_os == NULL) {
-		fw_load = 1;
-		maui_osLen = mod_firmware_load("/etc/sound/oswf.mot", (char **) &maui_os);
-	}
-	if (probe_maui(&cfg) == 0)
-		return -ENODEV;
-
-	return 0;
-}
-
-static void __exit cleanup_maui(void)
-{
-	if (fw_load && maui_os)
-		vfree(maui_os);
-	unload_maui(&cfg);
-}
-
-module_init(init_maui);
-module_exit(cleanup_maui);
-
-#ifndef MODULE
-static int __init setup_maui(char *str)
-{
-        /* io, irq */
-	int ints[3];
-	
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-	
-	io = ints[1];
-	irq = ints[2];
-
-	return 1;
-}
-
-__setup("maui=", setup_maui);
-#endif
-MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/oss/nec_vrc5477.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/nec_vrc5477.c	2007-06-05 17:44:14.000000000 -0400
@@ -848,7 +848,7 @@
 		wake_up_interruptible(&dac->wait);
 }
 
-static irqreturn_t vrc5477_ac97_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t vrc5477_ac97_interrupt(int irq, void *dev_id)
 {
 	struct vrc5477_ac97_state *s = (struct vrc5477_ac97_state *)dev_id;
 	u32 irqStatus;
@@ -1381,11 +1381,11 @@
 	int val, ret;
 
 #ifdef VRC5477_AC97_DEBUG
-	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
+	for (count = 0; count < ARRAY_SIZE(ioctl_str); count++) {
 		if (ioctl_str[count].cmd == cmd)
 			break;
 	}
-	if (count < sizeof(ioctl_str)/sizeof(ioctl_str[0]))
+	if (count < ARRAY_SIZE(ioctl_str))
 		printk(KERN_INFO PFX "ioctl %s\n", ioctl_str[count].str);
 	else
 		printk(KERN_INFO PFX "ioctl unknown, 0x%x\n", cmd);
@@ -1860,11 +1860,10 @@
 	if (pcidev->irq == 0) 
 		return -1;
 
-	if (!(s = kmalloc(sizeof(struct vrc5477_ac97_state), GFP_KERNEL))) {
+	if (!(s = kzalloc(sizeof(struct vrc5477_ac97_state), GFP_KERNEL))) {
 		printk(KERN_ERR PFX "alloc of device struct failed\n");
 		return -1;
 	}
-	memset(s, 0, sizeof(struct vrc5477_ac97_state));
 
 	init_waitqueue_head(&s->dma_adc.wait);
 	init_waitqueue_head(&s->dma_dac.wait);
--- linux-2.6.18.noarch/sound/oss/cs4281/cs4281_hwdefs.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4281/cs4281_hwdefs.h	2007-06-05 17:44:20.000000000 -0400
@@ -1,1234 +0,0 @@
-//****************************************************************************
-//
-// HWDEFS.H - Definitions of the registers and data structures used by the
-//            CS4281
-//
-// Copyright (c) 1999,2000,2001 Crystal Semiconductor Corp.
-//
-//****************************************************************************
-
-#ifndef _H_HWDEFS
-#define _H_HWDEFS
-
-//****************************************************************************
-//
-// The following define the offsets of the registers located in the PCI
-// configuration space of the CS4281 part.
-//
-//****************************************************************************
-#define PCICONFIG_DEVID_VENID                   0x00000000L
-#define PCICONFIG_STATUS_COMMAND                0x00000004L
-#define PCICONFIG_CLASS_REVISION                0x00000008L
-#define PCICONFIG_LATENCY_TIMER                 0x0000000CL
-#define PCICONFIG_BA0                           0x00000010L
-#define PCICONFIG_BA1                           0x00000014L
-#define PCICONFIG_SUBSYSID_SUBSYSVENID          0x0000002CL
-#define PCICONFIG_INTERRUPT                     0x0000003CL
-
-//****************************************************************************
-//
-// The following define the offsets of the registers accessed via base address
-// register zero on the CS4281 part.
-//
-//****************************************************************************
-#define BA0_HISR                                0x00000000L
-#define BA0_HICR                                0x00000008L
-#define BA0_HIMR                                0x0000000CL
-#define BA0_IIER                                0x00000010L
-#define BA0_HDSR0                               0x000000F0L
-#define BA0_HDSR1                               0x000000F4L
-#define BA0_HDSR2                               0x000000F8L
-#define BA0_HDSR3                               0x000000FCL
-#define BA0_DCA0                                0x00000110L
-#define BA0_DCC0                                0x00000114L
-#define BA0_DBA0                                0x00000118L
-#define BA0_DBC0                                0x0000011CL
-#define BA0_DCA1                                0x00000120L
-#define BA0_DCC1                                0x00000124L
-#define BA0_DBA1                                0x00000128L
-#define BA0_DBC1                                0x0000012CL
-#define BA0_DCA2                                0x00000130L
-#define BA0_DCC2                                0x00000134L
-#define BA0_DBA2                                0x00000138L
-#define BA0_DBC2                                0x0000013CL
-#define BA0_DCA3                                0x00000140L
-#define BA0_DCC3                                0x00000144L
-#define BA0_DBA3                                0x00000148L
-#define BA0_DBC3                                0x0000014CL
-#define BA0_DMR0                                0x00000150L
-#define BA0_DCR0                                0x00000154L
-#define BA0_DMR1                                0x00000158L
-#define BA0_DCR1                                0x0000015CL
-#define BA0_DMR2                                0x00000160L
-#define BA0_DCR2                                0x00000164L
-#define BA0_DMR3                                0x00000168L
-#define BA0_DCR3                                0x0000016CL
-#define BA0_DLMR                                0x00000170L
-#define BA0_DLSR                                0x00000174L
-#define BA0_FCR0                                0x00000180L
-#define BA0_FCR1                                0x00000184L
-#define BA0_FCR2                                0x00000188L
-#define BA0_FCR3                                0x0000018CL
-#define BA0_FPDR0                               0x00000190L
-#define BA0_FPDR1                               0x00000194L
-#define BA0_FPDR2                               0x00000198L
-#define BA0_FPDR3                               0x0000019CL
-#define BA0_FCHS                                0x0000020CL
-#define BA0_FSIC0                               0x00000210L
-#define BA0_FSIC1                               0x00000214L
-#define BA0_FSIC2                               0x00000218L
-#define BA0_FSIC3                               0x0000021CL
-#define BA0_PCICFG00                            0x00000300L
-#define BA0_PCICFG04                            0x00000304L
-#define BA0_PCICFG08                            0x00000308L
-#define BA0_PCICFG0C                            0x0000030CL
-#define BA0_PCICFG10                            0x00000310L
-#define BA0_PCICFG14                            0x00000314L
-#define BA0_PCICFG18                            0x00000318L
-#define BA0_PCICFG1C                            0x0000031CL
-#define BA0_PCICFG20                            0x00000320L
-#define BA0_PCICFG24                            0x00000324L
-#define BA0_PCICFG28                            0x00000328L
-#define BA0_PCICFG2C                            0x0000032CL
-#define BA0_PCICFG30                            0x00000330L
-#define BA0_PCICFG34                            0x00000334L
-#define BA0_PCICFG38                            0x00000338L
-#define BA0_PCICFG3C                            0x0000033CL
-#define BA0_PCICFG40                            0x00000340L
-#define BA0_PMCS                                0x00000344L
-#define BA0_CWPR                                0x000003E0L
-#define BA0_EPPMC                               0x000003E4L
-#define BA0_GPIOR                               0x000003E8L
-#define BA0_SPMC                                0x000003ECL
-#define BA0_CFLR                                0x000003F0L
-#define BA0_IISR                                0x000003F4L
-#define BA0_TMS                                 0x000003F8L
-#define BA0_SSVID                               0x000003FCL
-#define BA0_CLKCR1                              0x00000400L
-#define BA0_FRR                                 0x00000410L
-#define BA0_SLT12O                              0x0000041CL
-#define BA0_SERMC                               0x00000420L
-#define BA0_SERC1                               0x00000428L
-#define BA0_SERC2                               0x0000042CL
-#define BA0_SLT12M                              0x0000045CL
-#define BA0_ACCTL                               0x00000460L
-#define BA0_ACSTS                               0x00000464L
-#define BA0_ACOSV                               0x00000468L
-#define BA0_ACCAD                               0x0000046CL
-#define BA0_ACCDA                               0x00000470L
-#define BA0_ACISV                               0x00000474L
-#define BA0_ACSAD                               0x00000478L
-#define BA0_ACSDA                               0x0000047CL
-#define BA0_JSPT                                0x00000480L
-#define BA0_JSCTL                               0x00000484L
-#define BA0_MIDCR                               0x00000490L
-#define BA0_MIDCMD                              0x00000494L
-#define BA0_MIDSR                               0x00000494L
-#define BA0_MIDWP                               0x00000498L
-#define BA0_MIDRP                               0x0000049CL
-#define BA0_AODSD1                              0x000004A8L
-#define BA0_AODSD2                              0x000004ACL
-#define BA0_CFGI                                0x000004B0L
-#define BA0_SLT12M2                             0x000004DCL
-#define BA0_ACSTS2                              0x000004E4L
-#define BA0_ACISV2                              0x000004F4L
-#define BA0_ACSAD2                              0x000004F8L
-#define BA0_ACSDA2                              0x000004FCL
-#define BA0_IOTGP                               0x00000500L
-#define BA0_IOTSB                               0x00000504L
-#define BA0_IOTFM                               0x00000508L
-#define BA0_IOTDMA                              0x0000050CL
-#define BA0_IOTAC0                              0x00000500L
-#define BA0_IOTAC1                              0x00000504L
-#define BA0_IOTAC2                              0x00000508L
-#define BA0_IOTAC3                              0x0000050CL
-#define BA0_IOTPCP                              0x0000052CL
-#define BA0_IOTCC                               0x00000530L
-#define BA0_IOTCR                               0x0000058CL
-#define BA0_PCPRR                               0x00000600L
-#define BA0_PCPGR                               0x00000604L
-#define BA0_PCPCR                               0x00000608L
-#define BA0_PCPCIEN                             0x00000608L
-#define BA0_SBMAR                               0x00000700L
-#define BA0_SBMDR                               0x00000704L
-#define BA0_SBRR                                0x00000708L
-#define BA0_SBRDP                               0x0000070CL
-#define BA0_SBWDP                               0x00000710L
-#define BA0_SBWBS                               0x00000710L
-#define BA0_SBRBS                               0x00000714L
-#define BA0_FMSR                                0x00000730L
-#define BA0_B0AP                                0x00000730L
-#define BA0_FMDP                                0x00000734L
-#define BA0_B1AP                                0x00000738L
-#define BA0_B1DP                                0x0000073CL
-#define BA0_SSPM                                0x00000740L
-#define BA0_DACSR                               0x00000744L
-#define BA0_ADCSR                               0x00000748L
-#define BA0_SSCR                                0x0000074CL
-#define BA0_FMLVC                               0x00000754L
-#define BA0_FMRVC                               0x00000758L
-#define BA0_SRCSA                               0x0000075CL
-#define BA0_PPLVC                               0x00000760L
-#define BA0_PPRVC                               0x00000764L
-#define BA0_PASR                                0x00000768L
-#define BA0_CASR                                0x0000076CL
-
-//****************************************************************************
-//
-// The following define the offsets of the AC97 shadow registers, which appear
-// as a virtual extension to the base address register zero memory range.
-//
-//****************************************************************************
-#define AC97_REG_OFFSET_MASK                    0x0000007EL
-#define AC97_CODEC_NUMBER_MASK                  0x00003000L
-
-#define BA0_AC97_RESET                          0x00001000L
-#define BA0_AC97_MASTER_VOLUME                  0x00001002L
-#define BA0_AC97_HEADPHONE_VOLUME               0x00001004L
-#define BA0_AC97_MASTER_VOLUME_MONO             0x00001006L
-#define BA0_AC97_MASTER_TONE                    0x00001008L
-#define BA0_AC97_PC_BEEP_VOLUME                 0x0000100AL
-#define BA0_AC97_PHONE_VOLUME                   0x0000100CL
-#define BA0_AC97_MIC_VOLUME                     0x0000100EL
-#define BA0_AC97_LINE_IN_VOLUME                 0x00001010L
-#define BA0_AC97_CD_VOLUME                      0x00001012L
-#define BA0_AC97_VIDEO_VOLUME                   0x00001014L
-#define BA0_AC97_AUX_VOLUME                     0x00001016L
-#define BA0_AC97_PCM_OUT_VOLUME                 0x00001018L
-#define BA0_AC97_RECORD_SELECT                  0x0000101AL
-#define BA0_AC97_RECORD_GAIN                    0x0000101CL
-#define BA0_AC97_RECORD_GAIN_MIC                0x0000101EL
-#define BA0_AC97_GENERAL_PURPOSE                0x00001020L
-#define BA0_AC97_3D_CONTROL                     0x00001022L
-#define BA0_AC97_MODEM_RATE                     0x00001024L
-#define BA0_AC97_POWERDOWN                      0x00001026L
-#define BA0_AC97_EXT_AUDIO_ID                   0x00001028L
-#define BA0_AC97_EXT_AUDIO_POWER                0x0000102AL
-#define BA0_AC97_PCM_FRONT_DAC_RATE             0x0000102CL
-#define BA0_AC97_PCM_SURR_DAC_RATE              0x0000102EL
-#define BA0_AC97_PCM_LFE_DAC_RATE               0x00001030L
-#define BA0_AC97_PCM_LR_ADC_RATE                0x00001032L
-#define BA0_AC97_MIC_ADC_RATE                   0x00001034L
-#define BA0_AC97_6CH_VOL_C_LFE                  0x00001036L
-#define BA0_AC97_6CH_VOL_SURROUND               0x00001038L
-#define BA0_AC97_RESERVED_3A                    0x0000103AL
-#define BA0_AC97_EXT_MODEM_ID                   0x0000103CL
-#define BA0_AC97_EXT_MODEM_POWER                0x0000103EL
-#define BA0_AC97_LINE1_CODEC_RATE               0x00001040L
-#define BA0_AC97_LINE2_CODEC_RATE               0x00001042L
-#define BA0_AC97_HANDSET_CODEC_RATE             0x00001044L
-#define BA0_AC97_LINE1_CODEC_LEVEL              0x00001046L
-#define BA0_AC97_LINE2_CODEC_LEVEL              0x00001048L
-#define BA0_AC97_HANDSET_CODEC_LEVEL            0x0000104AL
-#define BA0_AC97_GPIO_PIN_CONFIG                0x0000104CL
-#define BA0_AC97_GPIO_PIN_TYPE                  0x0000104EL
-#define BA0_AC97_GPIO_PIN_STICKY                0x00001050L
-#define BA0_AC97_GPIO_PIN_WAKEUP                0x00001052L
-#define BA0_AC97_GPIO_PIN_STATUS                0x00001054L
-#define BA0_AC97_MISC_MODEM_AFE_STAT            0x00001056L
-#define BA0_AC97_RESERVED_58                    0x00001058L
-#define BA0_AC97_CRYSTAL_REV_N_FAB_ID           0x0000105AL
-#define BA0_AC97_TEST_AND_MISC_CTRL             0x0000105CL
-#define BA0_AC97_AC_MODE                        0x0000105EL
-#define BA0_AC97_MISC_CRYSTAL_CONTROL           0x00001060L
-#define BA0_AC97_LINE1_HYPRID_CTRL              0x00001062L
-#define BA0_AC97_VENDOR_RESERVED_64             0x00001064L
-#define BA0_AC97_VENDOR_RESERVED_66             0x00001066L
-#define BA0_AC97_SPDIF_CONTROL                  0x00001068L
-#define BA0_AC97_VENDOR_RESERVED_6A             0x0000106AL
-#define BA0_AC97_VENDOR_RESERVED_6C             0x0000106CL
-#define BA0_AC97_VENDOR_RESERVED_6E             0x0000106EL
-#define BA0_AC97_VENDOR_RESERVED_70             0x00001070L
-#define BA0_AC97_VENDOR_RESERVED_72             0x00001072L
-#define BA0_AC97_VENDOR_RESERVED_74             0x00001074L
-#define BA0_AC97_CAL_ADDRESS                    0x00001076L
-#define BA0_AC97_CAL_DATA                       0x00001078L
-#define BA0_AC97_VENDOR_RESERVED_7A             0x0000107AL
-#define BA0_AC97_VENDOR_ID1                     0x0000107CL
-#define BA0_AC97_VENDOR_ID2                     0x0000107EL
-
-//****************************************************************************
-//
-// The following define the offsets of the registers and memories accessed via
-// base address register one on the CS4281 part.
-//
-//****************************************************************************
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI device ID/vendor ID
-// register.
-//
-//****************************************************************************
-#define PDV_VENID_MASK                          0x0000FFFFL
-#define PDV_DEVID_MASK                          0xFFFF0000L
-#define PDV_VENID_SHIFT                         0L
-#define PDV_DEVID_SHIFT                         16L
-#define VENID_CIRRUS_LOGIC                      0x1013L
-#define DEVID_CS4281                            0x6005L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI status and command
-// register.
-//
-//****************************************************************************
-#define PSC_IO_SPACE_ENABLE                     0x00000001L
-#define PSC_MEMORY_SPACE_ENABLE                 0x00000002L
-#define PSC_BUS_MASTER_ENABLE                   0x00000004L
-#define PSC_SPECIAL_CYCLES                      0x00000008L
-#define PSC_MWI_ENABLE                          0x00000010L
-#define PSC_VGA_PALETTE_SNOOP                   0x00000020L
-#define PSC_PARITY_RESPONSE                     0x00000040L
-#define PSC_WAIT_CONTROL                        0x00000080L
-#define PSC_SERR_ENABLE                         0x00000100L
-#define PSC_FAST_B2B_ENABLE                     0x00000200L
-#define PSC_UDF_MASK                            0x007F0000L
-#define PSC_FAST_B2B_CAPABLE                    0x00800000L
-#define PSC_PARITY_ERROR_DETECTED               0x01000000L
-#define PSC_DEVSEL_TIMING_MASK                  0x06000000L
-#define PSC_TARGET_ABORT_SIGNALLED              0x08000000L
-#define PSC_RECEIVED_TARGET_ABORT               0x10000000L
-#define PSC_RECEIVED_MASTER_ABORT               0x20000000L
-#define PSC_SIGNALLED_SERR                      0x40000000L
-#define PSC_DETECTED_PARITY_ERROR               0x80000000L
-#define PSC_UDF_SHIFT                           16L
-#define PSC_DEVSEL_TIMING_SHIFT                 25L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI class/revision ID
-// register.
-//
-//****************************************************************************
-#define PCR_REVID_MASK                          0x000000FFL
-#define PCR_INTERFACE_MASK                      0x0000FF00L
-#define PCR_SUBCLASS_MASK                       0x00FF0000L
-#define PCR_CLASS_MASK                          0xFF000000L
-#define PCR_REVID_SHIFT                         0L
-#define PCR_INTERFACE_SHIFT                     8L
-#define PCR_SUBCLASS_SHIFT                      16L
-#define PCR_CLASS_SHIFT                         24L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI latency timer register.
-//
-//****************************************************************************
-#define PLT_CACHE_LINE_SIZE_MASK                0x000000FFL
-#define PLT_LATENCY_TIMER_MASK                  0x0000FF00L
-#define PLT_HEADER_TYPE_MASK                    0x00FF0000L
-#define PLT_BIST_MASK                           0xFF000000L
-#define PLT_CACHE_LINE_SIZE_SHIFT               0L
-#define PLT_LATENCY_TIMER_SHIFT                 8L
-#define PLT_HEADER_TYPE_SHIFT                   16L
-#define PLT_BIST_SHIFT                          24L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI base address registers.
-//
-//****************************************************************************
-#define PBAR_MEMORY_SPACE_INDICATOR             0x00000001L
-#define PBAR_LOCATION_TYPE_MASK                 0x00000006L
-#define PBAR_NOT_PREFETCHABLE                   0x00000008L
-#define PBAR_ADDRESS_MASK                       0xFFFFFFF0L
-#define PBAR_LOCATION_TYPE_SHIFT                1L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI subsystem ID/subsystem
-// vendor ID register.
-//
-//****************************************************************************
-#define PSS_SUBSYSTEM_VENDOR_ID_MASK            0x0000FFFFL
-#define PSS_SUBSYSTEM_ID_MASK                   0xFFFF0000L
-#define PSS_SUBSYSTEM_VENDOR_ID_SHIFT           0L
-#define PSS_SUBSYSTEM_ID_SHIFT                  16L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PCI interrupt register.
-//
-//****************************************************************************
-#define PI_LINE_MASK                            0x000000FFL
-#define PI_PIN_MASK                             0x0000FF00L
-#define PI_MIN_GRANT_MASK                       0x00FF0000L
-#define PI_MAX_LATENCY_MASK                     0xFF000000L
-#define PI_LINE_SHIFT                           0L
-#define PI_PIN_SHIFT                            8L
-#define PI_MIN_GRANT_SHIFT                      16L
-#define PI_MAX_LATENCY_SHIFT                    24L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the host interrupt status
-// register.
-//
-//****************************************************************************
-#define HISR_HVOLMASK                            0x00000003L
-#define HISR_VDNI                                0x00000001L
-#define HISR_VUPI                                0x00000002L
-#define HISR_GP1I                                0x00000004L
-#define HISR_GP3I                                0x00000008L
-#define HISR_GPSI                                0x00000010L
-#define HISR_GPPI                                0x00000020L
-#define HISR_DMAI                                0x00040000L
-#define HISR_FIFOI                               0x00100000L
-#define HISR_HVOL                                0x00200000L
-#define HISR_MIDI                                0x00400000L
-#define HISR_SBINT                               0x00800000L
-#define HISR_INTENA                              0x80000000L
-#define HISR_DMA_MASK                            0x00000F00L
-#define HISR_FIFO_MASK                           0x0000F000L
-#define HISR_DMA_SHIFT                           8L
-#define HISR_FIFO_SHIFT                          12L
-#define HISR_FIFO0                               0x00001000L
-#define HISR_FIFO1                               0x00002000L
-#define HISR_FIFO2                               0x00004000L
-#define HISR_FIFO3                               0x00008000L
-#define HISR_DMA0                                0x00000100L
-#define HISR_DMA1                                0x00000200L
-#define HISR_DMA2                                0x00000400L
-#define HISR_DMA3                                0x00000800L
-#define HISR_RESERVED                            0x40000000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the host interrupt control
-// register.
-//
-//****************************************************************************
-#define HICR_IEV                                 0x00000001L
-#define HICR_CHGM                                0x00000002L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the DMA Mode Register n
-// (DMRn)
-//
-//****************************************************************************
-#define DMRn_TR_MASK                             0x0000000CL
-#define DMRn_TR_SHIFT                            2L
-#define DMRn_AUTO                                0x00000010L
-#define DMRn_TR_READ                             0x00000008L
-#define DMRn_TR_WRITE                            0x00000004L
-#define DMRn_TYPE_MASK                           0x000000C0L
-#define DMRn_TYPE_SHIFT                          6L
-#define DMRn_SIZE8                               0x00010000L
-#define DMRn_MONO                                0x00020000L
-#define DMRn_BEND                                0x00040000L
-#define DMRn_USIGN                               0x00080000L
-#define DMRn_SIZE20                              0x00100000L
-#define DMRn_SWAPC                               0x00400000L
-#define DMRn_CBC                                 0x01000000L
-#define DMRn_TBC                                 0x02000000L
-#define DMRn_POLL                                0x10000000L
-#define DMRn_DMA                                 0x20000000L
-#define DMRn_FSEL_MASK                           0xC0000000L
-#define DMRn_FSEL_SHIFT                          30L
-#define DMRn_FSEL0                               0x00000000L
-#define DMRn_FSEL1                               0x40000000L
-#define DMRn_FSEL2                               0x80000000L
-#define DMRn_FSEL3                               0xC0000000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the DMA Command Register n
-// (DCRn)
-//
-//****************************************************************************
-#define DCRn_HTCIE                               0x00020000L
-#define DCRn_TCIE                                0x00010000L
-#define DCRn_MSK                                 0x00000001L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the FIFO Control 
-// register n.(FCRn)
-//
-//****************************************************************************
-#define FCRn_OF_MASK                            0x0000007FL
-#define FCRn_OF_SHIFT                           0L
-#define FCRn_SZ_MASK                            0x00007F00L
-#define FCRn_SZ_SHIFT                           8L
-#define FCRn_LS_MASK                            0x001F0000L
-#define FCRn_LS_SHIFT                           16L
-#define FCRn_RS_MASK                            0x1F000000L
-#define FCRn_RS_SHIFT                           24L
-#define FCRn_FEN                                0x80000000L
-#define FCRn_PSH                                0x20000000L
-#define FCRn_DACZ                               0x40000000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the serial port Power Management
-// control register.(SPMC)
-//
-//****************************************************************************
-#define SPMC_RSTN                               0x00000001L
-#define SPMC_ASYN                               0x00000002L
-#define SPMC_WUP1                               0x00000004L
-#define SPMC_WUP2                               0x00000008L
-#define SPMC_ASDI2E                             0x00000100L
-#define SPMC_ESSPD                              0x00000200L
-#define SPMC_GISPEN                             0x00004000L
-#define SPMC_GIPPEN                             0x00008000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the Configuration Load register.
-// (CFLR)
-//
-//****************************************************************************
-#define CFLR_CLOCK_SOURCE_MASK                  0x00000003L
-#define CFLR_CLOCK_SOURCE_AC97                  0x00000001L
-
-#define CFLR_CB0_MASK                            0x000000FFL
-#define CFLR_CB1_MASK                            0x0000FF00L
-#define CFLR_CB2_MASK                            0x00FF0000L
-#define CFLR_CB3_MASK                            0xFF000000L
-#define CFLR_CB0_SHIFT                           0L
-#define CFLR_CB1_SHIFT                           8L
-#define CFLR_CB2_SHIFT                           16L
-#define CFLR_CB3_SHIFT                           24L
-
-#define IOTCR_DMA0                              0x00000000L
-#define IOTCR_DMA1                              0x00000400L
-#define IOTCR_DMA2                              0x00000800L
-#define IOTCR_DMA3                              0x00000C00L
-#define IOTCR_CCLS                              0x00000100L
-#define IOTCR_PCPCI                             0x00000200L
-#define IOTCR_DDMA                              0x00000300L
-
-#define SBWBS_WBB                               0x00000080L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the SRC Slot Assignment Register
-// (SRCSA)
-//
-//****************************************************************************
-#define SRCSA_PLSS_MASK                         0x0000001FL
-#define SRCSA_PLSS_SHIFT                        0L
-#define SRCSA_PRSS_MASK                         0x00001F00L
-#define SRCSA_PRSS_SHIFT                        8L
-#define SRCSA_CLSS_MASK                         0x001F0000L
-#define SRCSA_CLSS_SHIFT                        16L
-#define SRCSA_CRSS_MASK                         0x1F000000L
-#define SRCSA_CRSS_SHIFT                        24L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the Sound System Power Management
-// register.(SSPM)
-//
-//****************************************************************************
-#define SSPM_FPDN                               0x00000080L
-#define SSPM_MIXEN                              0x00000040L
-#define SSPM_CSRCEN                             0x00000020L
-#define SSPM_PSRCEN                             0x00000010L
-#define SSPM_JSEN                               0x00000008L
-#define SSPM_ACLEN                              0x00000004L
-#define SSPM_FMEN                               0x00000002L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the Sound System Control
-// Register. (SSCR)
-//
-//****************************************************************************
-#define SSCR_SB                                 0x00000004L
-#define SSCR_HVC                                0x00000008L
-#define SSCR_LPFIFO                             0x00000040L
-#define SSCR_LPSRC                              0x00000080L
-#define SSCR_XLPSRC                             0x00000100L
-#define SSCR_MVMD                               0x00010000L
-#define SSCR_MVAD                               0x00020000L
-#define SSCR_MVLD                               0x00040000L
-#define SSCR_MVCS                               0x00080000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the Clock Control Register 1. 
-// (CLKCR1)
-//
-//****************************************************************************
-#define CLKCR1_DLLSS_MASK                       0x0000000CL
-#define CLKCR1_DLLSS_SHIFT                      2L
-#define CLKCR1_DLLP                             0x00000010L
-#define CLKCR1_SWCE                             0x00000020L
-#define CLKCR1_DLLOS                            0x00000040L
-#define CLKCR1_CKRA                             0x00010000L
-#define CLKCR1_CKRN                             0x00020000L
-#define CLKCR1_DLLRDY                           0x01000000L
-#define CLKCR1_CLKON                            0x02000000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the Sound Blaster Read Buffer
-// Status.(SBRBS)
-//
-//****************************************************************************
-#define SBRBS_RD_MASK                           0x0000007FL
-#define SBRBS_RD_SHIFT                          0L
-#define SBRBS_RBF                               0x00000080L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the serial port master control
-// register.(SERMC)
-//
-//****************************************************************************
-#define SERMC_MSPE                              0x00000001L
-#define SERMC_PTC_MASK                          0x0000000EL
-#define SERMC_PTC_SHIFT                         1L
-#define SERMC_PTC_AC97                          0x00000002L
-#define SERMC_PLB                               0x00000010L
-#define SERMC_PXLB                              0x00000020L
-#define SERMC_LOFV                              0x00080000L
-#define SERMC_SLB                               0x00100000L
-#define SERMC_SXLB                              0x00200000L
-#define SERMC_ODSEN1                            0x01000000L
-#define SERMC_ODSEN2                            0x02000000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the General Purpose I/O Register. 
-// (GPIOR)
-//
-//****************************************************************************
-#define GPIOR_VDNS                              0x00000001L
-#define GPIOR_VUPS                              0x00000002L
-#define GPIOR_GP1S                              0x00000004L
-#define GPIOR_GP3S                              0x00000008L
-#define GPIOR_GPSS                              0x00000010L
-#define GPIOR_GPPS                              0x00000020L
-#define GPIOR_GP1D                              0x00000400L
-#define GPIOR_GP3D                              0x00000800L
-#define GPIOR_VDNLT                             0x00010000L
-#define GPIOR_VDNPO                             0x00020000L
-#define GPIOR_VDNST                             0x00040000L
-#define GPIOR_VDNW                              0x00080000L
-#define GPIOR_VUPLT                             0x00100000L
-#define GPIOR_VUPPO                             0x00200000L
-#define GPIOR_VUPST                             0x00400000L
-#define GPIOR_VUPW                              0x00800000L
-#define GPIOR_GP1OE                             0x01000000L
-#define GPIOR_GP1PT                             0x02000000L
-#define GPIOR_GP1ST                             0x04000000L
-#define GPIOR_GP1W                              0x08000000L
-#define GPIOR_GP3OE                             0x10000000L
-#define GPIOR_GP3PT                             0x20000000L
-#define GPIOR_GP3ST                             0x40000000L
-#define GPIOR_GP3W                              0x80000000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the clock control register 1.
-//
-//****************************************************************************
-#define CLKCR1_PLLSS_MASK                       0x0000000CL
-#define CLKCR1_PLLSS_SERIAL                     0x00000000L
-#define CLKCR1_PLLSS_CRYSTAL                    0x00000004L
-#define CLKCR1_PLLSS_PCI                        0x00000008L
-#define CLKCR1_PLLSS_RESERVED                   0x0000000CL
-#define CLKCR1_PLLP                             0x00000010L
-#define CLKCR1_SWCE                             0x00000020L
-#define CLKCR1_PLLOS                            0x00000040L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the feature reporting register.
-//
-//****************************************************************************
-#define FRR_FAB_MASK                            0x00000003L
-#define FRR_MASK_MASK                           0x0000001CL
-#define FRR_ID_MASK                             0x00003000L
-#define FRR_FAB_SHIFT                           0L
-#define FRR_MASK_SHIFT                          2L
-#define FRR_ID_SHIFT                            12L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the serial port 1 configuration
-// register.
-//
-//****************************************************************************
-#define SERC1_VALUE                             0x00000003L
-#define SERC1_SO1EN                             0x00000001L
-#define SERC1_SO1F_MASK                         0x0000000EL
-#define SERC1_SO1F_CS423X                       0x00000000L
-#define SERC1_SO1F_AC97                         0x00000002L
-#define SERC1_SO1F_DAC                          0x00000004L
-#define SERC1_SO1F_SPDIF                        0x00000006L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the serial port 2 configuration
-// register.
-//
-//****************************************************************************
-#define SERC2_VALUE                             0x00000003L
-#define SERC2_SI1EN                             0x00000001L
-#define SERC2_SI1F_MASK                         0x0000000EL
-#define SERC2_SI1F_CS423X                       0x00000000L
-#define SERC2_SI1F_AC97                         0x00000002L
-#define SERC2_SI1F_ADC                          0x00000004L
-#define SERC2_SI1F_SPDIF                        0x00000006L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 control register.
-//
-//****************************************************************************
-#define ACCTL_ESYN                              0x00000002L
-#define ACCTL_VFRM                              0x00000004L
-#define ACCTL_DCV                               0x00000008L
-#define ACCTL_CRW                               0x00000010L
-#define ACCTL_TC                                0x00000040L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 status register.
-//
-//****************************************************************************
-#define ACSTS_CRDY                              0x00000001L
-#define ACSTS_VSTS                              0x00000002L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 output slot valid
-// register.
-//
-//****************************************************************************
-#define ACOSV_SLV3                              0x00000001L
-#define ACOSV_SLV4                              0x00000002L
-#define ACOSV_SLV5                              0x00000004L
-#define ACOSV_SLV6                              0x00000008L
-#define ACOSV_SLV7                              0x00000010L
-#define ACOSV_SLV8                              0x00000020L
-#define ACOSV_SLV9                              0x00000040L
-#define ACOSV_SLV10                             0x00000080L
-#define ACOSV_SLV11                             0x00000100L
-#define ACOSV_SLV12                             0x00000200L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 command address
-// register.
-//
-//****************************************************************************
-#define ACCAD_CI_MASK                           0x0000007FL
-#define ACCAD_CI_SHIFT                          0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 command data register.
-//
-//****************************************************************************
-#define ACCDA_CD_MASK                           0x0000FFFFL
-#define ACCDA_CD_SHIFT                          0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 input slot valid
-// register.
-//
-//****************************************************************************
-#define ACISV_ISV3                              0x00000001L
-#define ACISV_ISV4                              0x00000002L
-#define ACISV_ISV5                              0x00000004L
-#define ACISV_ISV6                              0x00000008L
-#define ACISV_ISV7                              0x00000010L
-#define ACISV_ISV8                              0x00000020L
-#define ACISV_ISV9                              0x00000040L
-#define ACISV_ISV10                             0x00000080L
-#define ACISV_ISV11                             0x00000100L
-#define ACISV_ISV12                             0x00000200L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 status address
-// register.
-//
-//****************************************************************************
-#define ACSAD_SI_MASK                           0x0000007FL
-#define ACSAD_SI_SHIFT                          0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 status data register.
-//
-//****************************************************************************
-#define ACSDA_SD_MASK                           0x0000FFFFL
-#define ACSDA_SD_SHIFT                          0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the I/O trap address and control
-// registers (all 12).
-//
-//****************************************************************************
-#define IOTAC_SA_MASK                           0x0000FFFFL
-#define IOTAC_MSK_MASK                          0x000F0000L
-#define IOTAC_IODC_MASK                         0x06000000L
-#define IOTAC_IODC_16_BIT                       0x00000000L
-#define IOTAC_IODC_10_BIT                       0x02000000L
-#define IOTAC_IODC_12_BIT                       0x04000000L
-#define IOTAC_WSPI                              0x08000000L
-#define IOTAC_RSPI                              0x10000000L
-#define IOTAC_WSE                               0x20000000L
-#define IOTAC_WE                                0x40000000L
-#define IOTAC_RE                                0x80000000L
-#define IOTAC_SA_SHIFT                          0L
-#define IOTAC_MSK_SHIFT                         16L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PC/PCI master enable
-// register.
-//
-//****************************************************************************
-#define PCPCIEN_EN                              0x00000001L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the joystick poll/trigger
-// register.
-//
-//****************************************************************************
-#define JSPT_CAX                                0x00000001L
-#define JSPT_CAY                                0x00000002L
-#define JSPT_CBX                                0x00000004L
-#define JSPT_CBY                                0x00000008L
-#define JSPT_BA1                                0x00000010L
-#define JSPT_BA2                                0x00000020L
-#define JSPT_BB1                                0x00000040L
-#define JSPT_BB2                                0x00000080L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the joystick control register.
-// The TBF bit has been moved from MIDSR register to JSCTL register bit 8.
-//
-//****************************************************************************
-#define JSCTL_SP_MASK                           0x00000003L
-#define JSCTL_SP_SLOW                           0x00000000L
-#define JSCTL_SP_MEDIUM_SLOW                    0x00000001L
-#define JSCTL_SP_MEDIUM_FAST                    0x00000002L
-#define JSCTL_SP_FAST                           0x00000003L
-#define JSCTL_ARE                               0x00000004L
-#define JSCTL_TBF                               0x00000100L
-
-
-//****************************************************************************
-//
-// The following defines are for the flags in the MIDI control register.
-//
-//****************************************************************************
-#define MIDCR_TXE                               0x00000001L
-#define MIDCR_RXE                               0x00000002L
-#define MIDCR_RIE                               0x00000004L
-#define MIDCR_TIE                               0x00000008L
-#define MIDCR_MLB                               0x00000010L
-#define MIDCR_MRST                              0x00000020L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the MIDI status register.
-//
-//****************************************************************************
-#define MIDSR_RBE                               0x00000080L
-#define MIDSR_RDA                               0x00008000L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the MIDI write port register.
-//
-//****************************************************************************
-#define MIDWP_MWD_MASK                          0x000000FFL
-#define MIDWP_MWD_SHIFT                         0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the MIDI read port register.
-//
-//****************************************************************************
-#define MIDRP_MRD_MASK                          0x000000FFL
-#define MIDRP_MRD_SHIFT                         0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the configuration interface
-// register.
-//
-//****************************************************************************
-#define CFGI_CLK                                0x00000001L
-#define CFGI_DOUT                               0x00000002L
-#define CFGI_DIN_EEN                            0x00000004L
-#define CFGI_EELD                               0x00000008L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the subsystem ID and vendor ID
-// register.
-//
-//****************************************************************************
-#define SSVID_VID_MASK                          0x0000FFFFL
-#define SSVID_SID_MASK                          0xFFFF0000L
-#define SSVID_VID_SHIFT                         0L
-#define SSVID_SID_SHIFT                         16L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the GPIO pin interface register.
-//
-//****************************************************************************
-#define GPIOR_VOLDN                             0x00000001L
-#define GPIOR_VOLUP                             0x00000002L
-#define GPIOR_SI2D                              0x00000004L
-#define GPIOR_SI2OE                             0x00000008L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 status register 2.
-//
-//****************************************************************************
-#define ACSTS2_CRDY                             0x00000001L
-#define ACSTS2_VSTS                             0x00000002L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 input slot valid
-// register 2.
-//
-//****************************************************************************
-#define ACISV2_ISV3                             0x00000001L
-#define ACISV2_ISV4                             0x00000002L
-#define ACISV2_ISV5                             0x00000004L
-#define ACISV2_ISV6                             0x00000008L
-#define ACISV2_ISV7                             0x00000010L
-#define ACISV2_ISV8                             0x00000020L
-#define ACISV2_ISV9                             0x00000040L
-#define ACISV2_ISV10                            0x00000080L
-#define ACISV2_ISV11                            0x00000100L
-#define ACISV2_ISV12                            0x00000200L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 status address
-// register 2.
-//
-//****************************************************************************
-#define ACSAD2_SI_MASK                          0x0000007FL
-#define ACSAD2_SI_SHIFT                         0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 status data register 2.
-//
-//****************************************************************************
-#define ACSDA2_SD_MASK                          0x0000FFFFL
-#define ACSDA2_SD_SHIFT                         0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the I/O trap control register.
-//
-//****************************************************************************
-#define IOTCR_ITD                               0x00000001L
-#define IOTCR_HRV                               0x00000002L
-#define IOTCR_SRV                               0x00000004L
-#define IOTCR_DTI                               0x00000008L
-#define IOTCR_DFI                               0x00000010L
-#define IOTCR_DDP                               0x00000020L
-#define IOTCR_JTE                               0x00000040L
-#define IOTCR_PPE                               0x00000080L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the I/O trap address and control
-// registers for Hardware Master Volume.  
-//
-//****************************************************************************
-#define IOTGP_SA_MASK                           0x0000FFFFL
-#define IOTGP_MSK_MASK                          0x000F0000L
-#define IOTGP_IODC_MASK                         0x06000000L
-#define IOTGP_IODC_16_BIT                       0x00000000L
-#define IOTGP_IODC_10_BIT                       0x02000000L
-#define IOTGP_IODC_12_BIT                       0x04000000L
-#define IOTGP_WSPI                              0x08000000L
-#define IOTGP_RSPI                              0x10000000L
-#define IOTGP_WSE                               0x20000000L
-#define IOTGP_WE                                0x40000000L
-#define IOTGP_RE                                0x80000000L
-#define IOTGP_SA_SHIFT                          0L
-#define IOTGP_MSK_SHIFT                         16L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the I/O trap address and control
-// registers for Sound Blaster
-//
-//****************************************************************************
-#define IOTSB_SA_MASK                           0x0000FFFFL
-#define IOTSB_MSK_MASK                          0x000F0000L
-#define IOTSB_IODC_MASK                         0x06000000L
-#define IOTSB_IODC_16_BIT                       0x00000000L
-#define IOTSB_IODC_10_BIT                       0x02000000L
-#define IOTSB_IODC_12_BIT                       0x04000000L
-#define IOTSB_WSPI                              0x08000000L
-#define IOTSB_RSPI                              0x10000000L
-#define IOTSB_WSE                               0x20000000L
-#define IOTSB_WE                                0x40000000L
-#define IOTSB_RE                                0x80000000L
-#define IOTSB_SA_SHIFT                          0L
-#define IOTSB_MSK_SHIFT                         16L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the I/O trap address and control
-// registers for FM.
-//
-//****************************************************************************
-#define IOTFM_SA_MASK                           0x0000FFFFL
-#define IOTFM_MSK_MASK                          0x000F0000L
-#define IOTFM_IODC_MASK                         0x06000000L
-#define IOTFM_IODC_16_BIT                       0x00000000L
-#define IOTFM_IODC_10_BIT                       0x02000000L
-#define IOTFM_IODC_12_BIT                       0x04000000L
-#define IOTFM_WSPI                              0x08000000L
-#define IOTFM_RSPI                              0x10000000L
-#define IOTFM_WSE                               0x20000000L
-#define IOTFM_WE                                0x40000000L
-#define IOTFM_RE                                0x80000000L
-#define IOTFM_SA_SHIFT                          0L
-#define IOTFM_MSK_SHIFT                         16L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PC/PCI request register.
-//
-//****************************************************************************
-#define PCPRR_RDC_MASK                         0x00000007L
-#define PCPRR_REQ                              0x00008000L
-#define PCPRR_RDC_SHIFT                        0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PC/PCI grant register.
-//
-//****************************************************************************
-#define PCPGR_GDC_MASK                         0x00000007L
-#define PCPGR_VL                               0x00008000L
-#define PCPGR_GDC_SHIFT                        0L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the PC/PCI Control Register.
-//
-//****************************************************************************
-#define PCPCR_EN                               0x00000001L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the debug index register.
-//
-//****************************************************************************
-#define DREG_REGID_MASK                         0x0000007FL
-#define DREG_DEBUG                              0x00000080L
-#define DREG_RGBK_MASK                          0x00000700L
-#define DREG_TRAP                               0x00000800L
-#if !defined(NO_CS4612)
-#if !defined(NO_CS4615)
-#define DREG_TRAPX                              0x00001000L
-#endif
-#endif
-#define DREG_REGID_SHIFT                        0L
-#define DREG_RGBK_SHIFT                         8L
-#define DREG_RGBK_REGID_MASK                    0x0000077FL
-#define DREG_REGID_R0                           0x00000010L
-#define DREG_REGID_R1                           0x00000011L
-#define DREG_REGID_R2                           0x00000012L
-#define DREG_REGID_R3                           0x00000013L
-#define DREG_REGID_R4                           0x00000014L
-#define DREG_REGID_R5                           0x00000015L
-#define DREG_REGID_R6                           0x00000016L
-#define DREG_REGID_R7                           0x00000017L
-#define DREG_REGID_R8                           0x00000018L
-#define DREG_REGID_R9                           0x00000019L
-#define DREG_REGID_RA                           0x0000001AL
-#define DREG_REGID_RB                           0x0000001BL
-#define DREG_REGID_RC                           0x0000001CL
-#define DREG_REGID_RD                           0x0000001DL
-#define DREG_REGID_RE                           0x0000001EL
-#define DREG_REGID_RF                           0x0000001FL
-#define DREG_REGID_RA_BUS_LOW                   0x00000020L
-#define DREG_REGID_RA_BUS_HIGH                  0x00000038L
-#define DREG_REGID_YBUS_LOW                     0x00000050L
-#define DREG_REGID_YBUS_HIGH                    0x00000058L
-#define DREG_REGID_TRAP_0                       0x00000100L
-#define DREG_REGID_TRAP_1                       0x00000101L
-#define DREG_REGID_TRAP_2                       0x00000102L
-#define DREG_REGID_TRAP_3                       0x00000103L
-#define DREG_REGID_TRAP_4                       0x00000104L
-#define DREG_REGID_TRAP_5                       0x00000105L
-#define DREG_REGID_TRAP_6                       0x00000106L
-#define DREG_REGID_TRAP_7                       0x00000107L
-#define DREG_REGID_INDIRECT_ADDRESS             0x0000010EL
-#define DREG_REGID_TOP_OF_STACK                 0x0000010FL
-#if !defined(NO_CS4612)
-#if !defined(NO_CS4615)
-#define DREG_REGID_TRAP_8                       0x00000110L
-#define DREG_REGID_TRAP_9                       0x00000111L
-#define DREG_REGID_TRAP_10                      0x00000112L
-#define DREG_REGID_TRAP_11                      0x00000113L
-#define DREG_REGID_TRAP_12                      0x00000114L
-#define DREG_REGID_TRAP_13                      0x00000115L
-#define DREG_REGID_TRAP_14                      0x00000116L
-#define DREG_REGID_TRAP_15                      0x00000117L
-#define DREG_REGID_TRAP_16                      0x00000118L
-#define DREG_REGID_TRAP_17                      0x00000119L
-#define DREG_REGID_TRAP_18                      0x0000011AL
-#define DREG_REGID_TRAP_19                      0x0000011BL
-#define DREG_REGID_TRAP_20                      0x0000011CL
-#define DREG_REGID_TRAP_21                      0x0000011DL
-#define DREG_REGID_TRAP_22                      0x0000011EL
-#define DREG_REGID_TRAP_23                      0x0000011FL
-#endif
-#endif
-#define DREG_REGID_RSA0_LOW                     0x00000200L
-#define DREG_REGID_RSA0_HIGH                    0x00000201L
-#define DREG_REGID_RSA1_LOW                     0x00000202L
-#define DREG_REGID_RSA1_HIGH                    0x00000203L
-#define DREG_REGID_RSA2                         0x00000204L
-#define DREG_REGID_RSA3                         0x00000205L
-#define DREG_REGID_RSI0_LOW                     0x00000206L
-#define DREG_REGID_RSI0_HIGH                    0x00000207L
-#define DREG_REGID_RSI1                         0x00000208L
-#define DREG_REGID_RSI2                         0x00000209L
-#define DREG_REGID_SAGUSTATUS                   0x0000020AL
-#define DREG_REGID_RSCONFIG01_LOW               0x0000020BL
-#define DREG_REGID_RSCONFIG01_HIGH              0x0000020CL
-#define DREG_REGID_RSCONFIG23_LOW               0x0000020DL
-#define DREG_REGID_RSCONFIG23_HIGH              0x0000020EL
-#define DREG_REGID_RSDMA01E                     0x0000020FL
-#define DREG_REGID_RSDMA23E                     0x00000210L
-#define DREG_REGID_RSD0_LOW                     0x00000211L
-#define DREG_REGID_RSD0_HIGH                    0x00000212L
-#define DREG_REGID_RSD1_LOW                     0x00000213L
-#define DREG_REGID_RSD1_HIGH                    0x00000214L
-#define DREG_REGID_RSD2_LOW                     0x00000215L
-#define DREG_REGID_RSD2_HIGH                    0x00000216L
-#define DREG_REGID_RSD3_LOW                     0x00000217L
-#define DREG_REGID_RSD3_HIGH                    0x00000218L
-#define DREG_REGID_SRAR_HIGH                    0x0000021AL
-#define DREG_REGID_SRAR_LOW                     0x0000021BL
-#define DREG_REGID_DMA_STATE                    0x0000021CL
-#define DREG_REGID_CURRENT_DMA_STREAM           0x0000021DL
-#define DREG_REGID_NEXT_DMA_STREAM              0x0000021EL
-#define DREG_REGID_CPU_STATUS                   0x00000300L
-#define DREG_REGID_MAC_MODE                     0x00000301L
-#define DREG_REGID_STACK_AND_REPEAT             0x00000302L
-#define DREG_REGID_INDEX0                       0x00000304L
-#define DREG_REGID_INDEX1                       0x00000305L
-#define DREG_REGID_DMA_STATE_0_3                0x00000400L
-#define DREG_REGID_DMA_STATE_4_7                0x00000404L
-#define DREG_REGID_DMA_STATE_8_11               0x00000408L
-#define DREG_REGID_DMA_STATE_12_15              0x0000040CL
-#define DREG_REGID_DMA_STATE_16_19              0x00000410L
-#define DREG_REGID_DMA_STATE_20_23              0x00000414L
-#define DREG_REGID_DMA_STATE_24_27              0x00000418L
-#define DREG_REGID_DMA_STATE_28_31              0x0000041CL
-#define DREG_REGID_DMA_STATE_32_35              0x00000420L
-#define DREG_REGID_DMA_STATE_36_39              0x00000424L
-#define DREG_REGID_DMA_STATE_40_43              0x00000428L
-#define DREG_REGID_DMA_STATE_44_47              0x0000042CL
-#define DREG_REGID_DMA_STATE_48_51              0x00000430L
-#define DREG_REGID_DMA_STATE_52_55              0x00000434L
-#define DREG_REGID_DMA_STATE_56_59              0x00000438L
-#define DREG_REGID_DMA_STATE_60_63              0x0000043CL
-#define DREG_REGID_DMA_STATE_64_67              0x00000440L
-#define DREG_REGID_DMA_STATE_68_71              0x00000444L
-#define DREG_REGID_DMA_STATE_72_75              0x00000448L
-#define DREG_REGID_DMA_STATE_76_79              0x0000044CL
-#define DREG_REGID_DMA_STATE_80_83              0x00000450L
-#define DREG_REGID_DMA_STATE_84_87              0x00000454L
-#define DREG_REGID_DMA_STATE_88_91              0x00000458L
-#define DREG_REGID_DMA_STATE_92_95              0x0000045CL
-#define DREG_REGID_TRAP_SELECT                  0x00000500L
-#define DREG_REGID_TRAP_WRITE_0                 0x00000500L
-#define DREG_REGID_TRAP_WRITE_1                 0x00000501L
-#define DREG_REGID_TRAP_WRITE_2                 0x00000502L
-#define DREG_REGID_TRAP_WRITE_3                 0x00000503L
-#define DREG_REGID_TRAP_WRITE_4                 0x00000504L
-#define DREG_REGID_TRAP_WRITE_5                 0x00000505L
-#define DREG_REGID_TRAP_WRITE_6                 0x00000506L
-#define DREG_REGID_TRAP_WRITE_7                 0x00000507L
-#if !defined(NO_CS4612)
-#if !defined(NO_CS4615)
-#define DREG_REGID_TRAP_WRITE_8                 0x00000510L
-#define DREG_REGID_TRAP_WRITE_9                 0x00000511L
-#define DREG_REGID_TRAP_WRITE_10                0x00000512L
-#define DREG_REGID_TRAP_WRITE_11                0x00000513L
-#define DREG_REGID_TRAP_WRITE_12                0x00000514L
-#define DREG_REGID_TRAP_WRITE_13                0x00000515L
-#define DREG_REGID_TRAP_WRITE_14                0x00000516L
-#define DREG_REGID_TRAP_WRITE_15                0x00000517L
-#define DREG_REGID_TRAP_WRITE_16                0x00000518L
-#define DREG_REGID_TRAP_WRITE_17                0x00000519L
-#define DREG_REGID_TRAP_WRITE_18                0x0000051AL
-#define DREG_REGID_TRAP_WRITE_19                0x0000051BL
-#define DREG_REGID_TRAP_WRITE_20                0x0000051CL
-#define DREG_REGID_TRAP_WRITE_21                0x0000051DL
-#define DREG_REGID_TRAP_WRITE_22                0x0000051EL
-#define DREG_REGID_TRAP_WRITE_23                0x0000051FL
-#endif
-#endif
-#define DREG_REGID_MAC0_ACC0_LOW                0x00000600L
-#define DREG_REGID_MAC0_ACC1_LOW                0x00000601L
-#define DREG_REGID_MAC0_ACC2_LOW                0x00000602L
-#define DREG_REGID_MAC0_ACC3_LOW                0x00000603L
-#define DREG_REGID_MAC1_ACC0_LOW                0x00000604L
-#define DREG_REGID_MAC1_ACC1_LOW                0x00000605L
-#define DREG_REGID_MAC1_ACC2_LOW                0x00000606L
-#define DREG_REGID_MAC1_ACC3_LOW                0x00000607L
-#define DREG_REGID_MAC0_ACC0_MID                0x00000608L
-#define DREG_REGID_MAC0_ACC1_MID                0x00000609L
-#define DREG_REGID_MAC0_ACC2_MID                0x0000060AL
-#define DREG_REGID_MAC0_ACC3_MID                0x0000060BL
-#define DREG_REGID_MAC1_ACC0_MID                0x0000060CL
-#define DREG_REGID_MAC1_ACC1_MID                0x0000060DL
-#define DREG_REGID_MAC1_ACC2_MID                0x0000060EL
-#define DREG_REGID_MAC1_ACC3_MID                0x0000060FL
-#define DREG_REGID_MAC0_ACC0_HIGH               0x00000610L
-#define DREG_REGID_MAC0_ACC1_HIGH               0x00000611L
-#define DREG_REGID_MAC0_ACC2_HIGH               0x00000612L
-#define DREG_REGID_MAC0_ACC3_HIGH               0x00000613L
-#define DREG_REGID_MAC1_ACC0_HIGH               0x00000614L
-#define DREG_REGID_MAC1_ACC1_HIGH               0x00000615L
-#define DREG_REGID_MAC1_ACC2_HIGH               0x00000616L
-#define DREG_REGID_MAC1_ACC3_HIGH               0x00000617L
-#define DREG_REGID_RSHOUT_LOW                   0x00000620L
-#define DREG_REGID_RSHOUT_MID                   0x00000628L
-#define DREG_REGID_RSHOUT_HIGH                  0x00000630L
-
-//****************************************************************************
-//
-// The following defines are for the flags in the AC97 S/PDIF Control register.
-//
-//****************************************************************************
-#define SPDIF_CONTROL_SPDIF_EN                 0x00008000L
-#define SPDIF_CONTROL_VAL                      0x00004000L
-#define SPDIF_CONTROL_COPY                     0x00000004L
-#define SPDIF_CONTROL_CC0                      0x00000010L
-#define SPDIF_CONTROL_CC1                      0x00000020L
-#define SPDIF_CONTROL_CC2                      0x00000040L
-#define SPDIF_CONTROL_CC3                      0x00000080L
-#define SPDIF_CONTROL_CC4                      0x00000100L
-#define SPDIF_CONTROL_CC5                      0x00000200L
-#define SPDIF_CONTROL_CC6                      0x00000400L
-#define SPDIF_CONTROL_L                        0x00000800L
-
-#endif // _H_HWDEFS
--- linux-2.6.18.noarch/sound/oss/cs4281/Makefile.orig	2007-06-05 16:07:56.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4281/Makefile	2007-06-05 17:44:20.000000000 -0400
@@ -1,6 +0,0 @@
-# Makefile for Cirrus Logic-Crystal CS4281 
-#
-
-obj-$(CONFIG_SOUND_CS4281) += cs4281.o
-
-cs4281-objs += cs4281m.o
--- linux-2.6.18.noarch/sound/oss/cs4281/cs4281m.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4281/cs4281m.c	2007-06-05 17:44:20.000000000 -0400
@@ -1,4487 +0,0 @@
-/*******************************************************************************
-*
-*      "cs4281.c" --  Cirrus Logic-Crystal CS4281 linux audio driver.
-*
-*      Copyright (C) 2000,2001  Cirrus Logic Corp.  
-*            -- adapted from drivers by Thomas Sailer, 
-*            -- but don't bug him; Problems should go to:
-*            -- tom woller (twoller@crystal.cirrus.com) or
-*               (audio@crystal.cirrus.com).
-*
-*      This program is free software; you can redistribute it and/or modify
-*      it under the terms of the GNU General Public License as published by
-*      the Free Software Foundation; either version 2 of the License, or
-*      (at your option) any later version.
-*
-*      This program is distributed in the hope that it will be useful,
-*      but WITHOUT ANY WARRANTY; without even the implied warranty of
-*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*      GNU General Public License for more details.
-*
-*      You should have received a copy of the GNU General Public License
-*      along with this program; if not, write to the Free Software
-*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-* Module command line parameters:
-*   none
-*
-*  Supported devices:
-*  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible
-*  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
-*  /dev/midi   simple MIDI UART interface, no ioctl
-*
-* Modification History
-* 08/20/00 trw - silence and no stopping DAC until release
-* 08/23/00 trw - added CS_DBG statements, fix interrupt hang issue on DAC stop.
-* 09/18/00 trw - added 16bit only record with conversion 
-* 09/24/00 trw - added Enhanced Full duplex (separate simultaneous 
-*                capture/playback rates)
-* 10/03/00 trw - fixed mmap (fixed GRECORD and the XMMS mmap test plugin  
-*                libOSSm.so)
-* 10/11/00 trw - modified for 2.4.0-test9 kernel enhancements (NR_MAP removal)
-* 11/03/00 trw - fixed interrupt loss/stutter, added debug.
-* 11/10/00 bkz - added __devinit to cs4281_hw_init()
-* 11/10/00 trw - fixed SMP and capture spinlock hang.
-* 12/04/00 trw - cleaned up CSDEBUG flags and added "defaultorder" moduleparm.
-* 12/05/00 trw - fixed polling (myth2), and added underrun swptr fix.
-* 12/08/00 trw - added PM support. 
-* 12/14/00 trw - added wrapper code, builds under 2.4.0, 2.2.17-20, 2.2.17-8 
-*		 (RH/Dell base), 2.2.18, 2.2.12.  cleaned up code mods by ident.
-* 12/19/00 trw - added PM support for 2.2 base (apm_callback). other PM cleanup.
-* 12/21/00 trw - added fractional "defaultorder" inputs. if >100 then use 
-*		 defaultorder-100 as power of 2 for the buffer size. example:
-*		 106 = 2^(106-100) = 2^6 = 64 bytes for the buffer size.
-*
-*******************************************************************************/
-
-/* uncomment the following line to disable building PM support into the driver */
-//#define NOT_CS4281_PM 1 
-
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/bitops.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/poll.h>
-#include <linux/fs.h>
-#include <linux/wait.h>
-
-#include <asm/current.h>
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <asm/page.h>
-#include <asm/uaccess.h>
-
-//#include "cs_dm.h"
-#include "cs4281_hwdefs.h"
-#include "cs4281pm.h"
-
-struct cs4281_state;
-
-static void stop_dac(struct cs4281_state *s);
-static void stop_adc(struct cs4281_state *s);
-static void start_dac(struct cs4281_state *s);
-static void start_adc(struct cs4281_state *s);
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-
-// --------------------------------------------------------------------- 
-
-#ifndef PCI_VENDOR_ID_CIRRUS
-#define PCI_VENDOR_ID_CIRRUS          0x1013
-#endif
-#ifndef PCI_DEVICE_ID_CRYSTAL_CS4281
-#define PCI_DEVICE_ID_CRYSTAL_CS4281  0x6005
-#endif
-
-#define CS4281_MAGIC  ((PCI_DEVICE_ID_CRYSTAL_CS4281<<16) | PCI_VENDOR_ID_CIRRUS)
-#define	CS4281_CFLR_DEFAULT	0x00000001  /* CFLR must be in AC97 link mode */
-
-// buffer order determines the size of the dma buffer for the driver.
-// under Linux, a smaller buffer allows more responsiveness from many of the 
-// applications (e.g. games).  A larger buffer allows some of the apps (esound) 
-// to not underrun the dma buffer as easily.  As default, use 32k (order=3)
-// rather than 64k as some of the games work more responsively.
-// log base 2( buff sz = 32k).
-static unsigned long defaultorder = 3;
-module_param(defaultorder, ulong, 0);
-
-//
-// Turn on/off debugging compilation by commenting out "#define CSDEBUG"
-//
-#define CSDEBUG 1
-#if CSDEBUG
-#define CSDEBUG_INTERFACE 1
-#else
-#undef CSDEBUG_INTERFACE
-#endif
-//
-// cs_debugmask areas
-//
-#define CS_INIT	 	0x00000001	// initialization and probe functions
-#define CS_ERROR 	0x00000002	// tmp debugging bit placeholder
-#define CS_INTERRUPT	0x00000004	// interrupt handler (separate from all other)
-#define CS_FUNCTION 	0x00000008	// enter/leave functions
-#define CS_WAVE_WRITE 	0x00000010	// write information for wave
-#define CS_WAVE_READ 	0x00000020	// read information for wave
-#define CS_MIDI_WRITE 	0x00000040	// write information for midi
-#define CS_MIDI_READ 	0x00000080	// read information for midi
-#define CS_MPU401_WRITE 0x00000100	// write information for mpu401
-#define CS_MPU401_READ 	0x00000200	// read information for mpu401
-#define CS_OPEN		0x00000400	// all open functions in the driver
-#define CS_RELEASE	0x00000800	// all release functions in the driver
-#define CS_PARMS	0x00001000	// functional and operational parameters
-#define CS_IOCTL	0x00002000	// ioctl (non-mixer)
-#define CS_PM		0x00004000	// power management 
-#define CS_TMP		0x10000000	// tmp debug mask bit
-
-#define CS_IOCTL_CMD_SUSPEND	0x1	// suspend
-#define CS_IOCTL_CMD_RESUME	0x2	// resume
-//
-// CSDEBUG is usual mode is set to 1, then use the
-// cs_debuglevel and cs_debugmask to turn on or off debugging.
-// Debug level of 1 has been defined to be kernel errors and info
-// that should be printed on any released driver.
-//
-#if CSDEBUG
-#define CS_DBGOUT(mask,level,x) if((cs_debuglevel >= (level)) && ((mask) & cs_debugmask) ) {x;}
-#else
-#define CS_DBGOUT(mask,level,x)
-#endif
-
-#if CSDEBUG
-static unsigned long cs_debuglevel = 1;	// levels range from 1-9
-static unsigned long cs_debugmask = CS_INIT | CS_ERROR;	// use CS_DBGOUT with various mask values
-module_param(cs_debuglevel, ulong, 0);
-module_param(cs_debugmask, ulong, 0);
-#endif
-#define CS_TRUE 	1
-#define CS_FALSE 	0
-
-// MIDI buffer sizes 
-#define MIDIINBUF  500
-#define MIDIOUTBUF 500
-
-#define FMODE_MIDI_SHIFT 3
-#define FMODE_MIDI_READ  (FMODE_READ << FMODE_MIDI_SHIFT)
-#define FMODE_MIDI_WRITE (FMODE_WRITE << FMODE_MIDI_SHIFT)
-
-#define CS4281_MAJOR_VERSION 	1
-#define CS4281_MINOR_VERSION 	13
-#ifdef __ia64__
-#define CS4281_ARCH	     	64	//architecture key
-#else
-#define CS4281_ARCH	     	32	//architecture key
-#endif
-
-#define CS_TYPE_ADC 0
-#define CS_TYPE_DAC 1
-
-
-static const char invalid_magic[] =
-    KERN_CRIT "cs4281: invalid magic value\n";
-
-#define VALIDATE_STATE(s)                         \
-({                                                \
-        if (!(s) || (s)->magic != CS4281_MAGIC) { \
-                printk(invalid_magic);            \
-                return -ENXIO;                    \
-        }                                         \
-})
-
-//LIST_HEAD(cs4281_devs);
-static struct list_head cs4281_devs = { &cs4281_devs, &cs4281_devs };
-
-struct cs4281_state; 
-
-#include "cs4281_wrapper-24.c"
-
-struct cs4281_state {
-	// magic 
-	unsigned int magic;
-
-	// we keep the cards in a linked list 
-	struct cs4281_state *next;
-
-	// pcidev is needed to turn off the DDMA controller at driver shutdown 
-	struct pci_dev *pcidev;
-	struct list_head list;
-
-	// soundcore stuff 
-	int dev_audio;
-	int dev_mixer;
-	int dev_midi;
-
-	// hardware resources 
-	unsigned int pBA0phys, pBA1phys;
-	char __iomem *pBA0;
-	char __iomem *pBA1;
-	unsigned int irq;
-
-	// mixer registers 
-	struct {
-		unsigned short vol[10];
-		unsigned int recsrc;
-		unsigned int modcnt;
-		unsigned short micpreamp;
-	} mix;
-
-	// wave stuff   
-	struct properties {
-		unsigned fmt;
-		unsigned fmt_original;	// original requested format
-		unsigned channels;
-		unsigned rate;
-		unsigned char clkdiv;
-	} prop_dac, prop_adc;
-	unsigned conversion:1;	// conversion from 16 to 8 bit in progress
-	void *tmpbuff;		// tmp buffer for sample conversions
-	unsigned ena;
-	spinlock_t lock;
-	struct mutex open_sem;
-	struct mutex open_sem_adc;
-	struct mutex open_sem_dac;
-	mode_t open_mode;
-	wait_queue_head_t open_wait;
-	wait_queue_head_t open_wait_adc;
-	wait_queue_head_t open_wait_dac;
-
-	dma_addr_t dmaaddr_tmpbuff;
-	unsigned buforder_tmpbuff;	// Log base 2 of 'rawbuf' size in bytes..
-	struct dmabuf {
-		void *rawbuf;	// Physical address of  
-		dma_addr_t dmaaddr;
-		unsigned buforder;	// Log base 2 of 'rawbuf' size in bytes..
-		unsigned numfrag;	// # of 'fragments' in the buffer.
-		unsigned fragshift;	// Log base 2 of fragment size.
-		unsigned hwptr, swptr;
-		unsigned total_bytes;	// # bytes process since open.
-		unsigned blocks;	// last returned blocks value GETOPTR
-		unsigned wakeup;	// interrupt occurred on block 
-		int count;
-		unsigned underrun;	// underrun flag
-		unsigned error;	// over/underrun 
-		wait_queue_head_t wait;
-		// redundant, but makes calculations easier 
-		unsigned fragsize;	// 2**fragshift..
-		unsigned dmasize;	// 2**buforder.
-		unsigned fragsamples;
-		// OSS stuff 
-		unsigned mapped:1;	// Buffer mapped in cs4281_mmap()?
-		unsigned ready:1;	// prog_dmabuf_dac()/adc() successful?
-		unsigned endcleared:1;
-		unsigned type:1;	// adc or dac buffer (CS_TYPE_XXX)
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-	} dma_dac, dma_adc;
-
-	// midi stuff 
-	struct {
-		unsigned ird, iwr, icnt;
-		unsigned ord, owr, ocnt;
-		wait_queue_head_t iwait;
-		wait_queue_head_t owait;
-		struct timer_list timer;
-		unsigned char ibuf[MIDIINBUF];
-		unsigned char obuf[MIDIOUTBUF];
-	} midi;
-
-	struct cs4281_pm pm;
-	struct cs4281_pipeline pl[CS4281_NUMBER_OF_PIPELINES];
-};
-
-#include "cs4281pm-24.c"
-
-#if CSDEBUG
-
-// DEBUG ROUTINES
-
-#define SOUND_MIXER_CS_GETDBGLEVEL 	_SIOWR('M',120, int)
-#define SOUND_MIXER_CS_SETDBGLEVEL 	_SIOWR('M',121, int)
-#define SOUND_MIXER_CS_GETDBGMASK 	_SIOWR('M',122, int)
-#define SOUND_MIXER_CS_SETDBGMASK 	_SIOWR('M',123, int)
-
-#define SOUND_MIXER_CS_APM	 	_SIOWR('M',124, int)
-
-
-static void cs_printioctl(unsigned int x)
-{
-	unsigned int i;
-	unsigned char vidx;
-	// Index of mixtable1[] member is Device ID 
-	// and must be <= SOUND_MIXER_NRDEVICES.
-	// Value of array member is index into s->mix.vol[]
-	static const unsigned char mixtable1[SOUND_MIXER_NRDEVICES] = {
-		[SOUND_MIXER_PCM] = 1,	// voice 
-		[SOUND_MIXER_LINE1] = 2,	// AUX
-		[SOUND_MIXER_CD] = 3,	// CD 
-		[SOUND_MIXER_LINE] = 4,	// Line 
-		[SOUND_MIXER_SYNTH] = 5,	// FM
-		[SOUND_MIXER_MIC] = 6,	// Mic 
-		[SOUND_MIXER_SPEAKER] = 7,	// Speaker 
-		[SOUND_MIXER_RECLEV] = 8,	// Recording level 
-		[SOUND_MIXER_VOLUME] = 9	// Master Volume 
-	};
-
-	switch (x) {
-	case SOUND_MIXER_CS_GETDBGMASK:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SOUND_MIXER_CS_GETDBGMASK:\n"));
-		break;
-	case SOUND_MIXER_CS_GETDBGLEVEL:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SOUND_MIXER_CS_GETDBGLEVEL:\n"));
-		break;
-	case SOUND_MIXER_CS_SETDBGMASK:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SOUND_MIXER_CS_SETDBGMASK:\n"));
-		break;
-	case SOUND_MIXER_CS_SETDBGLEVEL:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SOUND_MIXER_CS_SETDBGLEVEL:\n"));
-		break;
-	case OSS_GETVERSION:
-		CS_DBGOUT(CS_IOCTL, 4, printk("OSS_GETVERSION:\n"));
-		break;
-	case SNDCTL_DSP_SYNC:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SYNC:\n"));
-		break;
-	case SNDCTL_DSP_SETDUPLEX:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETDUPLEX:\n"));
-		break;
-	case SNDCTL_DSP_GETCAPS:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETCAPS:\n"));
-		break;
-	case SNDCTL_DSP_RESET:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_RESET:\n"));
-		break;
-	case SNDCTL_DSP_SPEED:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SPEED:\n"));
-		break;
-	case SNDCTL_DSP_STEREO:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_STEREO:\n"));
-		break;
-	case SNDCTL_DSP_CHANNELS:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_CHANNELS:\n"));
-		break;
-	case SNDCTL_DSP_GETFMTS:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETFMTS:\n"));
-		break;
-	case SNDCTL_DSP_SETFMT:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETFMT:\n"));
-		break;
-	case SNDCTL_DSP_POST:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_POST:\n"));
-		break;
-	case SNDCTL_DSP_GETTRIGGER:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETTRIGGER:\n"));
-		break;
-	case SNDCTL_DSP_SETTRIGGER:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETTRIGGER:\n"));
-		break;
-	case SNDCTL_DSP_GETOSPACE:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETOSPACE:\n"));
-		break;
-	case SNDCTL_DSP_GETISPACE:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETISPACE:\n"));
-		break;
-	case SNDCTL_DSP_NONBLOCK:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_NONBLOCK:\n"));
-		break;
-	case SNDCTL_DSP_GETODELAY:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETODELAY:\n"));
-		break;
-	case SNDCTL_DSP_GETIPTR:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETIPTR:\n"));
-		break;
-	case SNDCTL_DSP_GETOPTR:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETOPTR:\n"));
-		break;
-	case SNDCTL_DSP_GETBLKSIZE:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETBLKSIZE:\n"));
-		break;
-	case SNDCTL_DSP_SETFRAGMENT:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SNDCTL_DSP_SETFRAGMENT:\n"));
-		break;
-	case SNDCTL_DSP_SUBDIVIDE:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SUBDIVIDE:\n"));
-		break;
-	case SOUND_PCM_READ_RATE:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_PCM_READ_RATE:\n"));
-		break;
-	case SOUND_PCM_READ_CHANNELS:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SOUND_PCM_READ_CHANNELS:\n"));
-		break;
-	case SOUND_PCM_READ_BITS:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_PCM_READ_BITS:\n"));
-		break;
-	case SOUND_PCM_WRITE_FILTER:
-		CS_DBGOUT(CS_IOCTL, 4,
-			  printk("SOUND_PCM_WRITE_FILTER:\n"));
-		break;
-	case SNDCTL_DSP_SETSYNCRO:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETSYNCRO:\n"));
-		break;
-	case SOUND_PCM_READ_FILTER:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_PCM_READ_FILTER:\n"));
-		break;
-	case SOUND_MIXER_PRIVATE1:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE1:\n"));
-		break;
-	case SOUND_MIXER_PRIVATE2:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE2:\n"));
-		break;
-	case SOUND_MIXER_PRIVATE3:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE3:\n"));
-		break;
-	case SOUND_MIXER_PRIVATE4:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE4:\n"));
-		break;
-	case SOUND_MIXER_PRIVATE5:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE5:\n"));
-		break;
-	case SOUND_MIXER_INFO:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_INFO:\n"));
-		break;
-	case SOUND_OLD_MIXER_INFO:
-		CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_OLD_MIXER_INFO:\n"));
-		break;
-
-	default:
-		switch (_IOC_NR(x)) {
-		case SOUND_MIXER_VOLUME:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_VOLUME:\n"));
-			break;
-		case SOUND_MIXER_SPEAKER:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_SPEAKER:\n"));
-			break;
-		case SOUND_MIXER_RECLEV:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_RECLEV:\n"));
-			break;
-		case SOUND_MIXER_MIC:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_MIC:\n"));
-			break;
-		case SOUND_MIXER_SYNTH:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_SYNTH:\n"));
-			break;
-		case SOUND_MIXER_RECSRC:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_RECSRC:\n"));
-			break;
-		case SOUND_MIXER_DEVMASK:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_DEVMASK:\n"));
-			break;
-		case SOUND_MIXER_RECMASK:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_RECMASK:\n"));
-			break;
-		case SOUND_MIXER_STEREODEVS:
-			CS_DBGOUT(CS_IOCTL, 4,
-				  printk("SOUND_MIXER_STEREODEVS:\n"));
-			break;
-		case SOUND_MIXER_CAPS:
-			CS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_CAPS:\n"));
-			break;
-		default:
-			i = _IOC_NR(x);
-			if (i >= SOUND_MIXER_NRDEVICES
-			    || !(vidx = mixtable1[i])) {
-				CS_DBGOUT(CS_IOCTL, 4, printk
-					("UNKNOWN IOCTL: 0x%.8x NR=%d\n",
-						x, i));
-			} else {
-				CS_DBGOUT(CS_IOCTL, 4, printk
-					("SOUND_MIXER_IOCTL AC9x: 0x%.8x NR=%d\n",
-						x, i));
-			}
-			break;
-		}
-	}
-}
-#endif
-static int prog_dmabuf_adc(struct cs4281_state *s);
-static void prog_codec(struct cs4281_state *s, unsigned type);
-
-// --------------------------------------------------------------------- 
-//
-//              Hardware Interfaces For the CS4281
-//
-
-
-//******************************************************************************
-// "delayus()-- Delay for the specified # of microseconds.
-//******************************************************************************
-static void delayus(struct cs4281_state *s, u32 delay)
-{
-	u32 j;
-	if ((delay > 9999) && (s->pm.flags & CS4281_PM_IDLE)) {
-		j = (delay * HZ) / 1000000;	/* calculate delay in jiffies  */
-		if (j < 1)
-			j = 1;	/* minimum one jiffy. */
-		current->state = TASK_UNINTERRUPTIBLE;
-		schedule_timeout(j);
-	} else
-		udelay(delay);
-	return;
-}
-
-
-//******************************************************************************
-// "cs4281_read_ac97" -- Reads a word from the specified location in the
-//               CS4281's address space(based on the BA0 register).
-//
-// 1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
-// 2. Write ACCDA = Command Data Register = 470h for data to write to AC97 register,
-//                                            0h for reads.
-// 3. Write ACCTL = Control Register = 460h for initiating the write
-// 4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h
-// 5. if DCV not cleared, break and return error
-// 6. Read ACSTS = Status Register = 464h, check VSTS bit
-//****************************************************************************
-static int cs4281_read_ac97(struct cs4281_state *card, u32 offset,
-			    u32 * value)
-{
-	u32 count, status;
-
-	// Make sure that there is not data sitting
-	// around from a previous uncompleted access.
-	// ACSDA = Status Data Register = 47Ch
-	status = readl(card->pBA0 + BA0_ACSDA);
-
-	// Setup the AC97 control registers on the CS4281 to send the
-	// appropriate command to the AC97 to perform the read.
-	// ACCAD = Command Address Register = 46Ch
-	// ACCDA = Command Data Register = 470h
-	// ACCTL = Control Register = 460h
-	// bit DCV - will clear when process completed
-	// bit CRW - Read command
-	// bit VFRM - valid frame enabled
-	// bit ESYN - ASYNC generation enabled
-
-	// Get the actual AC97 register from the offset
-	writel(offset - BA0_AC97_RESET, card->pBA0 + BA0_ACCAD);
-	writel(0, card->pBA0 + BA0_ACCDA);
-	writel(ACCTL_DCV | ACCTL_CRW | ACCTL_VFRM | ACCTL_ESYN,
-	       card->pBA0 + BA0_ACCTL);
-
-	// Wait for the read to occur.
-	for (count = 0; count < 10; count++) {
-		// First, we want to wait for a short time.
-		udelay(25);
-
-		// Now, check to see if the read has completed.
-		// ACCTL = 460h, DCV should be reset by now and 460h = 17h
-		if (!(readl(card->pBA0 + BA0_ACCTL) & ACCTL_DCV))
-			break;
-	}
-
-	// Make sure the read completed.
-	if (readl(card->pBA0 + BA0_ACCTL) & ACCTL_DCV)
-		return 1;
-
-	// Wait for the valid status bit to go active.
-	for (count = 0; count < 10; count++) {
-		// Read the AC97 status register.
-		// ACSTS = Status Register = 464h
-		status = readl(card->pBA0 + BA0_ACSTS);
-
-		// See if we have valid status.
-		// VSTS - Valid Status
-		if (status & ACSTS_VSTS)
-			break;
-		// Wait for a short while.
-		udelay(25);
-	}
-
-	// Make sure we got valid status.
-	if (!(status & ACSTS_VSTS))
-		return 1;
-
-	// Read the data returned from the AC97 register.
-	// ACSDA = Status Data Register = 474h
-	*value = readl(card->pBA0 + BA0_ACSDA);
-
-	// Success.
-	return (0);
-}
-
-
-//****************************************************************************
-//
-// "cs4281_write_ac97()"-- writes a word to the specified location in the
-// CS461x's address space (based on the part's base address zero register).
-//
-// 1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
-// 2. Write ACCDA = Command Data Register = 470h for data to write to AC97 reg.
-// 3. Write ACCTL = Control Register = 460h for initiating the write
-// 4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h
-// 5. if DCV not cleared, break and return error
-//
-//****************************************************************************
-static int cs4281_write_ac97(struct cs4281_state *card, u32 offset,
-			     u32 value)
-{
-	u32 count, status=0;
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: cs_4281_write_ac97()+ \n"));
-
-	// Setup the AC97 control registers on the CS4281 to send the
-	// appropriate command to the AC97 to perform the read.
-	// ACCAD = Command Address Register = 46Ch
-	// ACCDA = Command Data Register = 470h
-	// ACCTL = Control Register = 460h
-	// set DCV - will clear when process completed
-	// reset CRW - Write command
-	// set VFRM - valid frame enabled
-	// set ESYN - ASYNC generation enabled
-	// set RSTN - ARST# inactive, AC97 codec not reset
-
-	// Get the actual AC97 register from the offset
-
-	writel(offset - BA0_AC97_RESET, card->pBA0 + BA0_ACCAD);
-	writel(value, card->pBA0 + BA0_ACCDA);
-	writel(ACCTL_DCV | ACCTL_VFRM | ACCTL_ESYN,
-	       card->pBA0 + BA0_ACCTL);
-
-	// Wait for the write to occur.
-	for (count = 0; count < 100; count++) {
-		// First, we want to wait for a short time.
-		udelay(25);
-		// Now, check to see if the write has completed.
-		// ACCTL = 460h, DCV should be reset by now and 460h = 07h
-		status = readl(card->pBA0 + BA0_ACCTL);
-		if (!(status & ACCTL_DCV))
-			break;
-	}
-
-	// Make sure the write completed.
-	if (status & ACCTL_DCV) {
-		CS_DBGOUT(CS_ERROR, 1, printk(KERN_INFO
-	      		"cs4281: cs_4281_write_ac97()- unable to write. ACCTL_DCV active\n"));
-		return 1;
-	}
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: cs_4281_write_ac97()- 0\n"));
-	// Success.
-	return 0;
-}
-
-
-//******************************************************************************
-// "Init4281()" -- Bring up the part.
-//******************************************************************************
-static __devinit int cs4281_hw_init(struct cs4281_state *card)
-{
-	u32 ac97_slotid;
-	u32 temp1, temp2;
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: cs4281_hw_init()+ \n"));
-#ifndef NOT_CS4281_PM
-	if(!card)
-		return 1;
-#endif
-	temp2 = readl(card->pBA0 + BA0_CFLR);
-	CS_DBGOUT(CS_INIT | CS_ERROR | CS_PARMS, 4, printk(KERN_INFO 
-		"cs4281: cs4281_hw_init() CFLR 0x%x\n", temp2));
-	if(temp2 != CS4281_CFLR_DEFAULT)
-	{
-		CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_INFO 
-			"cs4281: cs4281_hw_init() CFLR invalid - resetting from 0x%x to 0x%x\n",
-				temp2,CS4281_CFLR_DEFAULT));
-		writel(CS4281_CFLR_DEFAULT, card->pBA0 + BA0_CFLR);
-		temp2 = readl(card->pBA0 + BA0_CFLR);
-		if(temp2 != CS4281_CFLR_DEFAULT)
-		{
-			CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_INFO 
-				"cs4281: cs4281_hw_init() Invalid hardware - unable to configure CFLR\n"));
-			return 1;
-		}
-	}
-
-	//***************************************7
-	//  Set up the Sound System Configuration
-	//***************************************
-
-	// Set the 'Configuration Write Protect' register
-	// to 4281h.  Allows vendor-defined configuration
-	// space between 0e4h and 0ffh to be written.
-
-	writel(0x4281, card->pBA0 + BA0_CWPR);	// (3e0h)
-
-	// (0), Blast the clock control register to zero so that the
-	// PLL starts out in a known state, and blast the master serial
-	// port control register to zero so that the serial ports also
-	// start out in a known state.
-
-	writel(0, card->pBA0 + BA0_CLKCR1);	// (400h)
-	writel(0, card->pBA0 + BA0_SERMC);	// (420h)
-
-
-	// (1), Make ESYN go to zero to turn off
-	// the Sync pulse on the AC97 link.
-
-	writel(0, card->pBA0 + BA0_ACCTL);
-	udelay(50);
-
-
-	// (2) Drive the ARST# pin low for a minimum of 1uS (as defined in
-	// the AC97 spec) and then drive it high.  This is done for non
-	// AC97 modes since there might be logic external to the CS461x
-	// that uses the ARST# line for a reset.
-
-	writel(0, card->pBA0 + BA0_SPMC);	// (3ech)
-	udelay(100);
-	writel(SPMC_RSTN, card->pBA0 + BA0_SPMC);
-	delayus(card,50000);		// Wait 50 ms for ABITCLK to become stable.
-
-	// (3) Turn on the Sound System Clocks.
-	writel(CLKCR1_PLLP, card->pBA0 + BA0_CLKCR1);	// (400h)
-	delayus(card,50000);		// Wait for the PLL to stabilize.
-	// Turn on clocking of the core (CLKCR1(400h) = 0x00000030)
-	writel(CLKCR1_PLLP | CLKCR1_SWCE, card->pBA0 + BA0_CLKCR1);
-
-	// (4) Power on everything for now..
-	writel(0x7E, card->pBA0 + BA0_SSPM);	// (740h)
-
-	// (5) Wait for clock stabilization.
-	for (temp1 = 0; temp1 < 1000; temp1++) {
-		udelay(1000);
-		if (readl(card->pBA0 + BA0_CLKCR1) & CLKCR1_DLLRDY)
-			break;
-	}
-	if (!(readl(card->pBA0 + BA0_CLKCR1) & CLKCR1_DLLRDY)) {
-		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR 
-			"cs4281: DLLRDY failed!\n"));
-		return -EIO;
-	}
-	// (6) Enable ASYNC generation.
-	writel(ACCTL_ESYN, card->pBA0 + BA0_ACCTL);	// (460h)
-
-	// Now wait 'for a short while' to allow the  AC97
-	// part to start generating bit clock. (so we don't
-	// Try to start the PLL without an input clock.)
-	delayus(card,50000);
-
-	// Set the serial port timing configuration, so that the
-	// clock control circuit gets its clock from the right place.
-	writel(SERMC_PTC_AC97, card->pBA0 + BA0_SERMC);	// (420h)=2.
-
-	// (7) Wait for the codec ready signal from the AC97 codec.
-
-	for (temp1 = 0; temp1 < 1000; temp1++) {
-		// Delay a mil to let things settle out and
-		// to prevent retrying the read too quickly.
-		udelay(1000);
-		if (readl(card->pBA0 + BA0_ACSTS) & ACSTS_CRDY)	// If ready,  (464h)
-			break;	//   exit the 'for' loop.
-	}
-	if (!(readl(card->pBA0 + BA0_ACSTS) & ACSTS_CRDY))	// If never came ready,
-	{
-		CS_DBGOUT(CS_FUNCTION, 2, printk(KERN_ERR
-			 "cs4281: ACSTS never came ready!\n"));
-		return -EIO;	//   exit initialization.
-	}
-	// (8) Assert the 'valid frame' signal so we can
-	// begin sending commands to the AC97 codec.
-	writel(ACCTL_VFRM | ACCTL_ESYN, card->pBA0 + BA0_ACCTL);	// (460h)
-
-	// (9), Wait until CODEC calibration is finished.
-	// Print an error message if it doesn't.
-	for (temp1 = 0; temp1 < 1000; temp1++) {
-		delayus(card,10000);
-		// Read the AC97 Powerdown Control/Status Register.
-		cs4281_read_ac97(card, BA0_AC97_POWERDOWN, &temp2);
-		if ((temp2 & 0x0000000F) == 0x0000000F)
-			break;
-	}
-	if ((temp2 & 0x0000000F) != 0x0000000F) {
-		CS_DBGOUT(CS_FUNCTION, 2, printk(KERN_ERR
-			"cs4281: Codec failed to calibrate.  Status = %.8x.\n",
-				temp2));
-		return -EIO;
-	}
-	// (10), Set the serial port timing configuration, so that the
-	// clock control circuit gets its clock from the right place.
-	writel(SERMC_PTC_AC97, card->pBA0 + BA0_SERMC);	// (420h)=2.
-
-
-	// (11) Wait until we've sampled input slots 3 & 4 as valid, meaning
-	// that the codec is pumping ADC data across the AC link.
-	for (temp1 = 0; temp1 < 1000; temp1++) {
-		// Delay a mil to let things settle out and
-		// to prevent retrying the read too quickly.
-		delayus(card,1000);	//(test)
-
-		// Read the input slot valid register;  See
-		// if input slots 3 and 4 are valid yet.
-		if (
-		    (readl(card->pBA0 + BA0_ACISV) &
-		     (ACISV_ISV3 | ACISV_ISV4)) ==
-		    (ACISV_ISV3 | ACISV_ISV4)) break;	// Exit the 'for' if slots are valid.
-	}
-	// If we never got valid data, exit initialization.
-	if ((readl(card->pBA0 + BA0_ACISV) & (ACISV_ISV3 | ACISV_ISV4))
-	    != (ACISV_ISV3 | ACISV_ISV4)) {
-		CS_DBGOUT(CS_FUNCTION, 2,
-			  printk(KERN_ERR
-				 "cs4281: Never got valid data!\n"));
-		return -EIO;	// If no valid data, exit initialization.
-	}
-	// (12), Start digital data transfer of audio data to the codec.
-	writel(ACOSV_SLV3 | ACOSV_SLV4, card->pBA0 + BA0_ACOSV);	// (468h)
-
-
-	//**************************************
-	// Unmute the Master and Alternate
-	// (headphone) volumes.  Set to max.
-	//**************************************
-	cs4281_write_ac97(card, BA0_AC97_HEADPHONE_VOLUME, 0);
-	cs4281_write_ac97(card, BA0_AC97_MASTER_VOLUME, 0);
-
-	//******************************************
-	// Power on the DAC(AddDACUser()from main())
-	//******************************************
-	cs4281_read_ac97(card, BA0_AC97_POWERDOWN, &temp1);
-	cs4281_write_ac97(card, BA0_AC97_POWERDOWN, temp1 &= 0xfdff);
-
-	// Wait until we sample a DAC ready state.
-	for (temp2 = 0; temp2 < 32; temp2++) {
-		// Let's wait a mil to let things settle.
-		delayus(card,1000);
-		// Read the current state of the power control reg.
-		cs4281_read_ac97(card, BA0_AC97_POWERDOWN, &temp1);
-		// If the DAC ready state bit is set, stop waiting.
-		if (temp1 & 0x2)
-			break;
-	}
-
-	//******************************************
-	// Power on the ADC(AddADCUser()from main())
-	//******************************************
-	cs4281_read_ac97(card, BA0_AC97_POWERDOWN, &temp1);
-	cs4281_write_ac97(card, BA0_AC97_POWERDOWN, temp1 &= 0xfeff);
-
-	// Wait until we sample ADC ready state.
-	for (temp2 = 0; temp2 < 32; temp2++) {
-		// Let's wait a mil to let things settle.
-		delayus(card,1000);
-		// Read the current state of the power control reg.
-		cs4281_read_ac97(card, BA0_AC97_POWERDOWN, &temp1);
-		// If the ADC ready state bit is set, stop waiting.
-		if (temp1 & 0x1)
-			break;
-	}
-	// Set up 4281 Register contents that
-	// don't change for boot duration.
-
-	// For playback, we map AC97 slot 3 and 4(Left
-	// & Right PCM playback) to DMA Channel 0.
-	// Set the fifo to be 15 bytes at offset zero.
-
-	ac97_slotid = 0x01000f00;	// FCR0.RS[4:0]=1(=>slot4, right PCM playback).
-	// FCR0.LS[4:0]=0(=>slot3, left PCM playback).
-	// FCR0.SZ[6-0]=15; FCR0.OF[6-0]=0.
-	writel(ac97_slotid, card->pBA0 + BA0_FCR0);	// (180h)
-	writel(ac97_slotid | FCRn_FEN, card->pBA0 + BA0_FCR0);	// Turn on FIFO Enable.
-
-	// For capture, we map AC97 slot 10 and 11(Left
-	// and Right PCM Record) to DMA Channel 1.
-	// Set the fifo to be 15 bytes at offset sixteen.
-	ac97_slotid = 0x0B0A0f10;	// FCR1.RS[4:0]=11(=>slot11, right PCM record).
-	// FCR1.LS[4:0]=10(=>slot10, left PCM record).
-	// FCR1.SZ[6-0]=15; FCR1.OF[6-0]=16.
-	writel(ac97_slotid | FCRn_PSH, card->pBA0 + BA0_FCR1);	// (184h)
-	writel(ac97_slotid | FCRn_FEN, card->pBA0 + BA0_FCR1);	// Turn on FIFO Enable.
-
-	// Map the Playback SRC to the same AC97 slots(3 & 4--
-	// --Playback left & right)as DMA channel 0.
-	// Map the record SRC to the same AC97 slots(10 & 11--
-	// -- Record left & right) as DMA channel 1.
-
-	ac97_slotid = 0x0b0a0100;	// SCRSA.PRSS[4:0]=1(=>slot4, right PCM playback).
-	// SCRSA.PLSS[4:0]=0(=>slot3, left PCM playback).
-	// SCRSA.CRSS[4:0]=11(=>slot11, right PCM record)
-	// SCRSA.CLSS[4:0]=10(=>slot10, left PCM record).
-	writel(ac97_slotid, card->pBA0 + BA0_SRCSA);	// (75ch)
-
-	// Set 'Half Terminal Count Interrupt Enable' and 'Terminal
-	// Count Interrupt Enable' in DMA Control Registers 0 & 1.
-	// Set 'MSK' flag to 1 to keep the DMA engines paused.
-	temp1 = (DCRn_HTCIE | DCRn_TCIE | DCRn_MSK);	// (00030001h)
-	writel(temp1, card->pBA0 + BA0_DCR0);	// (154h
-	writel(temp1, card->pBA0 + BA0_DCR1);	// (15ch)
-
-	// Set 'Auto-Initialize Control' to 'enabled'; For playback,
-	// set 'Transfer Type Control'(TR[1:0]) to 'read transfer',
-	// for record, set Transfer Type Control to 'write transfer'.
-	// All other bits set to zero;  Some will be changed @ transfer start.
-	temp1 = (DMRn_DMA | DMRn_AUTO | DMRn_TR_READ);	// (20000018h)
-	writel(temp1, card->pBA0 + BA0_DMR0);	// (150h)
-	temp1 = (DMRn_DMA | DMRn_AUTO | DMRn_TR_WRITE);	// (20000014h)
-	writel(temp1, card->pBA0 + BA0_DMR1);	// (158h)
-
-	// Enable DMA interrupts generally, and
-	// DMA0 & DMA1 interrupts specifically.
-	temp1 = readl(card->pBA0 + BA0_HIMR) & 0xfffbfcff;
-	writel(temp1, card->pBA0 + BA0_HIMR);
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: cs4281_hw_init()- 0\n"));
-	return 0;
-}
-
-#ifndef NOT_CS4281_PM
-static void printpm(struct cs4281_state *s)
-{
-	CS_DBGOUT(CS_PM, 9, printk("pm struct:\n"));
-	CS_DBGOUT(CS_PM, 9, printk("flags:0x%x u32CLKCR1_SAVE: 0%x u32SSPMValue: 0x%x\n",
-		(unsigned)s->pm.flags,s->pm.u32CLKCR1_SAVE,s->pm.u32SSPMValue));
-	CS_DBGOUT(CS_PM, 9, printk("u32PPLVCvalue: 0x%x u32PPRVCvalue: 0x%x\n",
-		s->pm.u32PPLVCvalue,s->pm.u32PPRVCvalue));
-	CS_DBGOUT(CS_PM, 9, printk("u32FMLVCvalue: 0x%x u32FMRVCvalue: 0x%x\n",
-		s->pm.u32FMLVCvalue,s->pm.u32FMRVCvalue));
-	CS_DBGOUT(CS_PM, 9, printk("u32GPIORvalue: 0x%x u32JSCTLvalue: 0x%x\n",
-		s->pm.u32GPIORvalue,s->pm.u32JSCTLvalue));
-	CS_DBGOUT(CS_PM, 9, printk("u32SSCR: 0x%x u32SRCSA: 0x%x\n",
-		s->pm.u32SSCR,s->pm.u32SRCSA));
-	CS_DBGOUT(CS_PM, 9, printk("u32DacASR: 0x%x u32AdcASR: 0x%x\n",
-		s->pm.u32DacASR,s->pm.u32AdcASR));
-	CS_DBGOUT(CS_PM, 9, printk("u32DacSR: 0x%x u32AdcSR: 0x%x\n",
-		s->pm.u32DacSR,s->pm.u32AdcSR));
-	CS_DBGOUT(CS_PM, 9, printk("u32MIDCR_Save: 0x%x\n",
-		s->pm.u32MIDCR_Save));
-
-}
-static void printpipe(struct cs4281_pipeline *pl)
-{
-
-	CS_DBGOUT(CS_PM, 9, printk("pm struct:\n"));
-	CS_DBGOUT(CS_PM, 9, printk("flags:0x%x number: 0%x\n",
-		(unsigned)pl->flags,pl->number));
-	CS_DBGOUT(CS_PM, 9, printk("u32DBAnValue: 0%x u32DBCnValue: 0x%x\n",
-		pl->u32DBAnValue,pl->u32DBCnValue));
-	CS_DBGOUT(CS_PM, 9, printk("u32DMRnValue: 0x%x u32DCRnValue: 0x%x\n",
-		pl->u32DMRnValue,pl->u32DCRnValue));
-	CS_DBGOUT(CS_PM, 9, printk("u32DBAnAddress: 0x%x u32DBCnAddress: 0x%x\n",
-		pl->u32DBAnAddress,pl->u32DBCnAddress));
-	CS_DBGOUT(CS_PM, 9, printk("u32DCAnAddress: 0x%x u32DCCnAddress: 0x%x\n",
-		pl->u32DCCnAddress,pl->u32DCCnAddress));
-	CS_DBGOUT(CS_PM, 9, printk("u32DMRnAddress: 0x%x u32DCRnAddress: 0x%x\n",
-		pl->u32DMRnAddress,pl->u32DCRnAddress));
-	CS_DBGOUT(CS_PM, 9, printk("u32HDSRnAddress: 0x%x u32DBAn_Save: 0x%x\n",
-		pl->u32HDSRnAddress,pl->u32DBAn_Save));
-	CS_DBGOUT(CS_PM, 9, printk("u32DBCn_Save: 0x%x u32DMRn_Save: 0x%x\n",
-		pl->u32DBCn_Save,pl->u32DMRn_Save));
-	CS_DBGOUT(CS_PM, 9, printk("u32DCRn_Save: 0x%x u32DCCn_Save: 0x%x\n",
-		pl->u32DCRn_Save,pl->u32DCCn_Save));
-	CS_DBGOUT(CS_PM, 9, printk("u32DCAn_Save: 0x%x\n",
-		pl->u32DCAn_Save));
-	CS_DBGOUT(CS_PM, 9, printk("u32FCRn_Save: 0x%x u32FSICn_Save: 0x%x\n",
-		pl->u32FCRn_Save,pl->u32FSICn_Save));
-	CS_DBGOUT(CS_PM, 9, printk("u32FCRnValue: 0x%x u32FSICnValue: 0x%x\n",
-		pl->u32FCRnValue,pl->u32FSICnValue));
-	CS_DBGOUT(CS_PM, 9, printk("u32FCRnAddress: 0x%x u32FSICnAddress: 0x%x\n",
-		pl->u32FCRnAddress,pl->u32FSICnAddress));
-	CS_DBGOUT(CS_PM, 9, printk("u32FPDRnValue: 0x%x u32FPDRnAddress: 0x%x\n",
-		pl->u32FPDRnValue,pl->u32FPDRnAddress));
-}
-static void printpipelines(struct cs4281_state *s)
-{
-	int i;
-	for(i=0;i<CS4281_NUMBER_OF_PIPELINES;i++)
-	{
-		if(s->pl[i].flags & CS4281_PIPELINE_VALID)
-		{
-			printpipe(&s->pl[i]);
-		}
-	}
-}
-/****************************************************************************
-*
-*  Suspend - save the ac97 regs, mute the outputs and power down the part.  
-*
-****************************************************************************/
-static void cs4281_ac97_suspend(struct cs4281_state *s)
-{
-	int Count,i;
-
-	CS_DBGOUT(CS_PM, 9, printk("cs4281: cs4281_ac97_suspend()+\n"));
-/*
-* change the state, save the current hwptr, then stop the dac/adc
-*/
-	s->pm.flags &= ~CS4281_PM_IDLE;
-	s->pm.flags |= CS4281_PM_SUSPENDING;
-	s->pm.u32hwptr_playback = readl(s->pBA0 + BA0_DCA0);
-	s->pm.u32hwptr_capture = readl(s->pBA0 + BA0_DCA1);
-	stop_dac(s);
-	stop_adc(s);
-
-	for(Count = 0x2, i=0; (Count <= CS4281_AC97_HIGHESTREGTORESTORE)
-			&& (i < CS4281_AC97_NUMBER_RESTORE_REGS); 
-		Count += 2, i++)
-	{
-		cs4281_read_ac97(s, BA0_AC97_RESET + Count, &s->pm.ac97[i]);
-	}
-/*
-* Save the ac97 volume registers as well as the current powerdown state.
-* Now, mute the all the outputs (master, headphone, and mono), as well
-* as the PCM volume, in preparation for powering down the entire part.
-*/ 
-	cs4281_read_ac97(s, BA0_AC97_MASTER_VOLUME, &s->pm.u32AC97_master_volume);
-	cs4281_read_ac97(s, BA0_AC97_HEADPHONE_VOLUME, &s->pm.u32AC97_headphone_volume);
-	cs4281_read_ac97(s, BA0_AC97_MASTER_VOLUME_MONO, &s->pm.u32AC97_master_volume_mono);
-	cs4281_read_ac97(s, BA0_AC97_PCM_OUT_VOLUME, &s->pm.u32AC97_pcm_out_volume);
-		
-	cs4281_write_ac97(s, BA0_AC97_MASTER_VOLUME, 0x8000);
-	cs4281_write_ac97(s, BA0_AC97_HEADPHONE_VOLUME, 0x8000);
-	cs4281_write_ac97(s, BA0_AC97_MASTER_VOLUME_MONO, 0x8000);
-	cs4281_write_ac97(s, BA0_AC97_PCM_OUT_VOLUME, 0x8000);
-
-	cs4281_read_ac97(s, BA0_AC97_POWERDOWN, &s->pm.u32AC97_powerdown);
-	cs4281_read_ac97(s, BA0_AC97_GENERAL_PURPOSE, &s->pm.u32AC97_general_purpose);
-
-/*
-* And power down everything on the AC97 codec.
-*/
-	cs4281_write_ac97(s, BA0_AC97_POWERDOWN, 0xff00);
-	CS_DBGOUT(CS_PM, 9, printk("cs4281: cs4281_ac97_suspend()-\n"));
-}
-
-/****************************************************************************
-*
-*  Resume - power up the part and restore its registers..  
-*
-****************************************************************************/
-static void cs4281_ac97_resume(struct cs4281_state *s)
-{
-	int Count,i;
-
-	CS_DBGOUT(CS_PM, 9, printk("cs4281: cs4281_ac97_resume()+\n"));
-
-/* do not save the power state registers at this time
-    //
-    // If we saved away the power control registers, write them into the
-    // shadows so those saved values get restored instead of the current
-    // shadowed value.
-    //
-    if( bPowerStateSaved )
-    {
-        PokeShadow( 0x26, ulSaveReg0x26 );
-        bPowerStateSaved = FALSE;
-    }
-*/
-
-//
-// First, we restore the state of the general purpose register.  This
-// contains the mic select (mic1 or mic2) and if we restore this after
-// we restore the mic volume/boost state and mic2 was selected at
-// suspend time, we will end up with a brief period of time where mic1
-// is selected with the volume/boost settings for mic2, causing
-// acoustic feedback.  So we restore the general purpose register
-// first, thereby getting the correct mic selected before we restore
-// the mic volume/boost.
-//
-	cs4281_write_ac97(s, BA0_AC97_GENERAL_PURPOSE, s->pm.u32AC97_general_purpose);
-
-//
-// Now, while the outputs are still muted, restore the state of power
-// on the AC97 part.
-//
-	cs4281_write_ac97(s, BA0_AC97_POWERDOWN, s->pm.u32AC97_powerdown);
-
-/*
-* Restore just the first set of registers, from register number
-* 0x02 to the register number that ulHighestRegToRestore specifies.
-*/
-	for(	Count = 0x2, i=0; 
-		(Count <= CS4281_AC97_HIGHESTREGTORESTORE)
-			&& (i < CS4281_AC97_NUMBER_RESTORE_REGS); 
-		Count += 2, i++)
-	{
-		cs4281_write_ac97(s, BA0_AC97_RESET + Count, s->pm.ac97[i]);
-	}
-	CS_DBGOUT(CS_PM, 9, printk("cs4281: cs4281_ac97_resume()-\n"));
-}
-
-/* do not save the power state registers at this time
-****************************************************************************
-*
-*  SavePowerState - Save the power registers away. 
-*
-****************************************************************************
-void 
-HWAC97codec::SavePowerState(void)
-{
-    ENTRY(TM_OBJECTCALLS, "HWAC97codec::SavePowerState()\r\n");
-
-    ulSaveReg0x26 = PeekShadow(0x26);
-
-    //
-    // Note that we have saved registers that need to be restored during a
-    // resume instead of ulAC97Regs[].
-    //
-    bPowerStateSaved = TRUE;
-
-} // SavePowerState
-*/
-
-static void cs4281_SuspendFIFO(struct cs4281_state *s, struct cs4281_pipeline *pl)
-{
- /*
- * We need to save the contents of the BASIC FIFO Registers.
- */
-	pl->u32FCRn_Save = readl(s->pBA0 + pl->u32FCRnAddress);
-	pl->u32FSICn_Save = readl(s->pBA0 + pl->u32FSICnAddress);
-}
-static void cs4281_ResumeFIFO(struct cs4281_state *s, struct cs4281_pipeline *pl)
-{
- /*
- * We need to restore the contents of the BASIC FIFO Registers.
- */
-	writel(pl->u32FCRn_Save,s->pBA0 + pl->u32FCRnAddress);
-	writel(pl->u32FSICn_Save,s->pBA0 + pl->u32FSICnAddress);
-}
-static void cs4281_SuspendDMAengine(struct cs4281_state *s, struct cs4281_pipeline *pl)
-{
-	//
-	// We need to save the contents of the BASIC DMA Registers.
-	//
-	pl->u32DBAn_Save = readl(s->pBA0 + pl->u32DBAnAddress);
-	pl->u32DBCn_Save = readl(s->pBA0 + pl->u32DBCnAddress);
-	pl->u32DMRn_Save = readl(s->pBA0 + pl->u32DMRnAddress);
-	pl->u32DCRn_Save = readl(s->pBA0 + pl->u32DCRnAddress);
-	pl->u32DCCn_Save = readl(s->pBA0 + pl->u32DCCnAddress);
-	pl->u32DCAn_Save = readl(s->pBA0 + pl->u32DCAnAddress);
-}
-static void cs4281_ResumeDMAengine(struct cs4281_state *s, struct cs4281_pipeline *pl)
-{
-	//
-	// We need to save the contents of the BASIC DMA Registers.
-	//
-	writel( pl->u32DBAn_Save, s->pBA0 + pl->u32DBAnAddress);
-	writel( pl->u32DBCn_Save, s->pBA0 + pl->u32DBCnAddress);
-	writel( pl->u32DMRn_Save, s->pBA0 + pl->u32DMRnAddress);
-	writel( pl->u32DCRn_Save, s->pBA0 + pl->u32DCRnAddress);
-	writel( pl->u32DCCn_Save, s->pBA0 + pl->u32DCCnAddress);
-	writel( pl->u32DCAn_Save, s->pBA0 + pl->u32DCAnAddress);
-}
-
-static int cs4281_suspend(struct cs4281_state *s)
-{
-	int i;
-	u32 u32CLKCR1;
-	struct cs4281_pm *pm = &s->pm;
-	CS_DBGOUT(CS_PM | CS_FUNCTION, 9, 
-		printk("cs4281: cs4281_suspend()+ flags=%d\n",
-			(unsigned)s->pm.flags));
-/*
-* check the current state, only suspend if IDLE
-*/
-	if(!(s->pm.flags & CS4281_PM_IDLE))
-	{
-		CS_DBGOUT(CS_PM | CS_ERROR, 2, 
-			printk("cs4281: cs4281_suspend() unable to suspend, not IDLE\n"));
-		return 1;
-	}
-	s->pm.flags &= ~CS4281_PM_IDLE;
-	s->pm.flags |= CS4281_PM_SUSPENDING;
-
-//
-// Gershwin CLKRUN - Set CKRA
-//
-	u32CLKCR1 = readl(s->pBA0 + BA0_CLKCR1);
-
-	pm->u32CLKCR1_SAVE = u32CLKCR1;
-	if(!(u32CLKCR1 & 0x00010000 ) )
-		writel(u32CLKCR1 | 0x00010000, s->pBA0 + BA0_CLKCR1);
-
-//
-// First, turn on the clocks (yikes) to the devices, so that they will
-// respond when we try to save their state.
-//
-	if(!(u32CLKCR1 & CLKCR1_SWCE))
-	{
-		writel(u32CLKCR1 | CLKCR1_SWCE , s->pBA0 + BA0_CLKCR1);
-	}
-    
-	//
-	// Save the power state
-	//
-	pm->u32SSPMValue = readl(s->pBA0 + BA0_SSPM);
-
-	//
-	// Disable interrupts.
-	//
-	writel(HICR_CHGM, s->pBA0 + BA0_HICR);
-
-	//
-	// Save the PCM Playback Left and Right Volume Control.
-	//
-	pm->u32PPLVCvalue = readl(s->pBA0 + BA0_PPLVC);
-	pm->u32PPRVCvalue = readl(s->pBA0 + BA0_PPRVC);
-
-	//
-	// Save the FM Synthesis Left and Right Volume Control.
-	//
-	pm->u32FMLVCvalue = readl(s->pBA0 + BA0_FMLVC);
-	pm->u32FMRVCvalue = readl(s->pBA0 + BA0_FMRVC);
-
-	//
-	// Save the GPIOR value.
-	//
-	pm->u32GPIORvalue = readl(s->pBA0 + BA0_GPIOR);
-
-	//
-	// Save the JSCTL value.
-	//
-	pm->u32JSCTLvalue = readl(s->pBA0 + BA0_GPIOR);
-
-	//
-	// Save Sound System Control Register
-	//
-	pm->u32SSCR = readl(s->pBA0 + BA0_SSCR);
-
-	//
-	// Save SRC Slot Assinment register
-	//
-	pm->u32SRCSA = readl(s->pBA0 + BA0_SRCSA);
-
-	//
-	// Save sample rate
-	//
-	pm->u32DacASR = readl(s->pBA0 + BA0_PASR);
-	pm->u32AdcASR = readl(s->pBA0 + BA0_CASR);
-	pm->u32DacSR = readl(s->pBA0 + BA0_DACSR);
-	pm->u32AdcSR = readl(s->pBA0 + BA0_ADCSR);
-
-	//
-	// Loop through all of the PipeLines 
-	//
-	for(i = 0; i < CS4281_NUMBER_OF_PIPELINES; i++)
-        {
-		if(s->pl[i].flags & CS4281_PIPELINE_VALID)
-		{
-		//
-		// Ask the DMAengines and FIFOs to Suspend.
-		//
-			cs4281_SuspendDMAengine(s,&s->pl[i]);
-			cs4281_SuspendFIFO(s,&s->pl[i]);
-		}
-	}
-	//
-	// We need to save the contents of the Midi Control Register.
-	//
-	pm->u32MIDCR_Save = readl(s->pBA0 + BA0_MIDCR);
-/*
-* save off the AC97 part information
-*/
-	cs4281_ac97_suspend(s);
-    
-	//
-	// Turn off the serial ports.
-	//
-	writel(0, s->pBA0 + BA0_SERMC);
-
-	//
-	// Power off FM, Joystick, AC link, 
-	//
-	writel(0, s->pBA0 + BA0_SSPM);
-
-	//
-	// DLL off.
-	//
-	writel(0, s->pBA0 + BA0_CLKCR1);
-
-	//
-	// AC link off.
-	//
-	writel(0, s->pBA0 + BA0_SPMC);
-
-	//
-	// Put the chip into D3(hot) state.
-	//
-	// PokeBA0(BA0_PMCS, 0x00000003);
-
-	//
-	// Gershwin CLKRUN - Clear CKRA
-	//
-	u32CLKCR1 = readl(s->pBA0 + BA0_CLKCR1);
-	writel(u32CLKCR1 & 0xFFFEFFFF, s->pBA0 + BA0_CLKCR1);
-
-#ifdef CSDEBUG
-	printpm(s);
-	printpipelines(s);
-#endif
-
-	s->pm.flags &= ~CS4281_PM_SUSPENDING;
-	s->pm.flags |= CS4281_PM_SUSPENDED;
-
-	CS_DBGOUT(CS_PM | CS_FUNCTION, 9, 
-		printk("cs4281: cs4281_suspend()- flags=%d\n",
-			(unsigned)s->pm.flags));
-	return 0;
-}
-
-static int cs4281_resume(struct cs4281_state *s)
-{
-	int i;
-	unsigned temp1;
-	u32 u32CLKCR1;
-	struct cs4281_pm *pm = &s->pm;
-	CS_DBGOUT(CS_PM | CS_FUNCTION, 4, 
-		printk( "cs4281: cs4281_resume()+ flags=%d\n",
-			(unsigned)s->pm.flags));
-	if(!(s->pm.flags & CS4281_PM_SUSPENDED))
-	{
-		CS_DBGOUT(CS_PM | CS_ERROR, 2, 
-			printk("cs4281: cs4281_resume() unable to resume, not SUSPENDED\n"));
-		return 1;
-	}
-	s->pm.flags &= ~CS4281_PM_SUSPENDED;
-	s->pm.flags |= CS4281_PM_RESUMING;
-
-//
-// Gershwin CLKRUN - Set CKRA
-//
-	u32CLKCR1 = readl(s->pBA0 + BA0_CLKCR1);
-	writel(u32CLKCR1 | 0x00010000, s->pBA0 + BA0_CLKCR1);
-
-	//
-	// set the power state.
-	//
-	//old PokeBA0(BA0_PMCS, 0);
-
-	//
-	// Program the clock circuit and serial ports.
-	//
-	temp1 = cs4281_hw_init(s);
-	if (temp1) {
-		CS_DBGOUT(CS_ERROR | CS_INIT, 1,
-		    printk(KERN_ERR
-			"cs4281: resume cs4281_hw_init() error.\n"));
-		return -1;
-	}
-
-	//
-	// restore the Power state
-	//
-	writel(pm->u32SSPMValue, s->pBA0 + BA0_SSPM);
-
-	//
-	// Set post SRC mix setting (FM or ALT48K)
-	//
-	writel(pm->u32SSPM_BITS, s->pBA0 + BA0_SSPM);
-
-	//
-	// Loop through all of the PipeLines 
-	//
-	for(i = 0; i < CS4281_NUMBER_OF_PIPELINES; i++)
-        {
-		if(s->pl[i].flags & CS4281_PIPELINE_VALID)
-		{
-		//
-		// Ask the DMAengines and FIFOs to Resume.
-		//
-			cs4281_ResumeDMAengine(s,&s->pl[i]);
-			cs4281_ResumeFIFO(s,&s->pl[i]);
-		}
-	}
-	//
-	// We need to restore the contents of the Midi Control Register.
-	//
-	writel(pm->u32MIDCR_Save, s->pBA0 + BA0_MIDCR);
-
-	cs4281_ac97_resume(s);
-	//
-	// Restore the PCM Playback Left and Right Volume Control.
-	//
-	writel(pm->u32PPLVCvalue, s->pBA0 + BA0_PPLVC);
-	writel(pm->u32PPRVCvalue, s->pBA0 + BA0_PPRVC);
-
-	//
-	// Restore the FM Synthesis Left and Right Volume Control.
-	//
-	writel(pm->u32FMLVCvalue, s->pBA0 + BA0_FMLVC);
-	writel(pm->u32FMRVCvalue, s->pBA0 + BA0_FMRVC);
-
-	//
-	// Restore the JSCTL value.
-	//
-	writel(pm->u32JSCTLvalue, s->pBA0 + BA0_JSCTL);
-
-	//
-	// Restore the GPIOR register value.
-	//
-	writel(pm->u32GPIORvalue, s->pBA0 + BA0_GPIOR);
-
-	//
-	// Restore Sound System Control Register
-	//
-	writel(pm->u32SSCR, s->pBA0 + BA0_SSCR);
-
-	//
-	// Restore SRC Slot Assignment register
-	//
-	writel(pm->u32SRCSA, s->pBA0 + BA0_SRCSA);
-
-	//
-	// Restore sample rate
-	//
-	writel(pm->u32DacASR, s->pBA0 + BA0_PASR);
-	writel(pm->u32AdcASR, s->pBA0 + BA0_CASR);
-	writel(pm->u32DacSR, s->pBA0 + BA0_DACSR);
-	writel(pm->u32AdcSR, s->pBA0 + BA0_ADCSR);
-
-	// 
-	// Restore CFL1/2 registers we saved to compensate for OEM bugs.
-	//
-	//	PokeBA0(BA0_CFLR, ulConfig);
-
-	//
-	// Gershwin CLKRUN - Clear CKRA
-	//
-	writel(pm->u32CLKCR1_SAVE, s->pBA0 + BA0_CLKCR1);
-
-	//
-	// Enable interrupts on the part.
-	//
-	writel(HICR_IEV | HICR_CHGM, s->pBA0 + BA0_HICR);
-
-#ifdef CSDEBUG
-	printpm(s);
-	printpipelines(s);
-#endif
-/*
-* change the state, restore the current hwptrs, then stop the dac/adc
-*/
-	s->pm.flags |= CS4281_PM_IDLE;
-	s->pm.flags &= ~(CS4281_PM_SUSPENDING | CS4281_PM_SUSPENDED 
-			| CS4281_PM_RESUMING | CS4281_PM_RESUMED);
-
-	writel(s->pm.u32hwptr_playback, s->pBA0 + BA0_DCA0);
-	writel(s->pm.u32hwptr_capture, s->pBA0 + BA0_DCA1);
-	start_dac(s);
-	start_adc(s);
-
-	CS_DBGOUT(CS_PM | CS_FUNCTION, 9, printk("cs4281: cs4281_resume()- flags=%d\n",
-		(unsigned)s->pm.flags));
-	return 0;
-}
-
-#endif
-
-//******************************************************************************
-// "cs4281_play_rate()" --
-//******************************************************************************
-static void cs4281_play_rate(struct cs4281_state *card, u32 playrate)
-{
-	u32 DACSRvalue = 1;
-
-	// Based on the sample rate, program the DACSR register.
-	if (playrate == 8000)
-		DACSRvalue = 5;
-	if (playrate == 11025)
-		DACSRvalue = 4;
-	else if (playrate == 22050)
-		DACSRvalue = 2;
-	else if (playrate == 44100)
-		DACSRvalue = 1;
-	else if ((playrate <= 48000) && (playrate >= 6023))
-		DACSRvalue = 24576000 / (playrate * 16);
-	else if (playrate < 6023)
-		// Not allowed by open.
-		return;
-	else if (playrate > 48000)
-		// Not allowed by open.
-		return;
-	CS_DBGOUT(CS_WAVE_WRITE | CS_PARMS, 2, printk(KERN_INFO
-		"cs4281: cs4281_play_rate(): DACSRvalue=0x%.8x playrate=%d\n",
-			DACSRvalue, playrate));
-	//  Write the 'sample rate select code'
-	//  to the 'DAC Sample Rate' register.
-	writel(DACSRvalue, card->pBA0 + BA0_DACSR);	// (744h)
-}
-
-//******************************************************************************
-// "cs4281_record_rate()" -- Initialize the record sample rate converter.
-//******************************************************************************
-static void cs4281_record_rate(struct cs4281_state *card, u32 outrate)
-{
-	u32 ADCSRvalue = 1;
-
-	//
-	// Based on the sample rate, program the ADCSR register
-	//
-	if (outrate == 8000)
-		ADCSRvalue = 5;
-	if (outrate == 11025)
-		ADCSRvalue = 4;
-	else if (outrate == 22050)
-		ADCSRvalue = 2;
-	else if (outrate == 44100)
-		ADCSRvalue = 1;
-	else if ((outrate <= 48000) && (outrate >= 6023))
-		ADCSRvalue = 24576000 / (outrate * 16);
-	else if (outrate < 6023) {
-		// Not allowed by open.
-		return;
-	} else if (outrate > 48000) {
-		// Not allowed by open.
-		return;
-	}
-	CS_DBGOUT(CS_WAVE_READ | CS_PARMS, 2, printk(KERN_INFO
-		"cs4281: cs4281_record_rate(): ADCSRvalue=0x%.8x outrate=%d\n",
-			ADCSRvalue, outrate));
-	//  Write the 'sample rate select code
-	//  to the 'ADC Sample Rate' register.
-	writel(ADCSRvalue, card->pBA0 + BA0_ADCSR);	// (748h)
-}
-
-
-
-static void stop_dac(struct cs4281_state *s)
-{
-	unsigned long flags;
-	unsigned temp1;
-
-	CS_DBGOUT(CS_WAVE_WRITE, 3, printk(KERN_INFO "cs4281: stop_dac():\n"));
-	spin_lock_irqsave(&s->lock, flags);
-	s->ena &= ~FMODE_WRITE;
-	temp1 = readl(s->pBA0 + BA0_DCR0) | DCRn_MSK;
-	writel(temp1, s->pBA0 + BA0_DCR0);
-
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-
-static void start_dac(struct cs4281_state *s)
-{
-	unsigned long flags;
-	unsigned temp1;
-
-	CS_DBGOUT(CS_FUNCTION, 3, printk(KERN_INFO "cs4281: start_dac()+\n"));
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->ena & FMODE_WRITE) && (s->dma_dac.mapped ||
-					(s->dma_dac.count > 0
-	    				&& s->dma_dac.ready))
-#ifndef NOT_CS4281_PM
-	&& (s->pm.flags & CS4281_PM_IDLE))
-#else
-)
-#endif
- {
-		s->ena |= FMODE_WRITE;
-		temp1 = readl(s->pBA0 + BA0_DCR0) & ~DCRn_MSK;	// Clear DMA0 channel mask.
-		writel(temp1, s->pBA0 + BA0_DCR0);	// Start DMA'ing.
-		writel(HICR_IEV | HICR_CHGM, s->pBA0 + BA0_HICR);	// Enable interrupts.              
-
-		writel(7, s->pBA0 + BA0_PPRVC);
-		writel(7, s->pBA0 + BA0_PPLVC);
-		CS_DBGOUT(CS_WAVE_WRITE | CS_PARMS, 8, printk(KERN_INFO
-			"cs4281: start_dac(): writel 0x%x start dma\n", temp1));
-
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	CS_DBGOUT(CS_FUNCTION, 3,
-		  printk(KERN_INFO "cs4281: start_dac()-\n"));
-}
-
-
-static void stop_adc(struct cs4281_state *s)
-{
-	unsigned long flags;
-	unsigned temp1;
-
-	CS_DBGOUT(CS_FUNCTION, 3,
-		  printk(KERN_INFO "cs4281: stop_adc()+\n"));
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->ena &= ~FMODE_READ;
-
-	if (s->conversion == 1) {
-		s->conversion = 0;
-		s->prop_adc.fmt = s->prop_adc.fmt_original;
-	}
-	temp1 = readl(s->pBA0 + BA0_DCR1) | DCRn_MSK;
-	writel(temp1, s->pBA0 + BA0_DCR1);
-	spin_unlock_irqrestore(&s->lock, flags);
-	CS_DBGOUT(CS_FUNCTION, 3,
-		  printk(KERN_INFO "cs4281: stop_adc()-\n"));
-}
-
-
-static void start_adc(struct cs4281_state *s)
-{
-	unsigned long flags;
-	unsigned temp1;
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: start_adc()+\n"));
-
-	if (!(s->ena & FMODE_READ) &&
-	    (s->dma_adc.mapped || s->dma_adc.count <=
-	     (signed) (s->dma_adc.dmasize - 2 * s->dma_adc.fragsize))
-	    && s->dma_adc.ready
-#ifndef NOT_CS4281_PM
-	&& (s->pm.flags & CS4281_PM_IDLE))
-#else
-) 
-#endif
-	{
-		if (s->prop_adc.fmt & AFMT_S8 || s->prop_adc.fmt & AFMT_U8) {
-			// 
-			// now only use 16 bit capture, due to truncation issue
-			// in the chip, noticable distortion occurs.
-			// allocate buffer and then convert from 16 bit to 
-			// 8 bit for the user buffer.
-			//
-			s->prop_adc.fmt_original = s->prop_adc.fmt;
-			if (s->prop_adc.fmt & AFMT_S8) {
-				s->prop_adc.fmt &= ~AFMT_S8;
-				s->prop_adc.fmt |= AFMT_S16_LE;
-			}
-			if (s->prop_adc.fmt & AFMT_U8) {
-				s->prop_adc.fmt &= ~AFMT_U8;
-				s->prop_adc.fmt |= AFMT_U16_LE;
-			}
-			//
-			// prog_dmabuf_adc performs a stop_adc() but that is
-			// ok since we really haven't started the DMA yet.
-			//
-			prog_codec(s, CS_TYPE_ADC);
-
-			if (prog_dmabuf_adc(s) != 0) {
-				CS_DBGOUT(CS_ERROR, 2, printk(KERN_INFO
-					 "cs4281: start_adc(): error in prog_dmabuf_adc\n"));
-			}
-			s->conversion = 1;
-		}
-		spin_lock_irqsave(&s->lock, flags);
-		s->ena |= FMODE_READ;
-		temp1 = readl(s->pBA0 + BA0_DCR1) & ~DCRn_MSK;	// Clear DMA1 channel mask bit.
-		writel(temp1, s->pBA0 + BA0_DCR1);	// Start recording
-		writel(HICR_IEV | HICR_CHGM, s->pBA0 + BA0_HICR);	// Enable interrupts.
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		CS_DBGOUT(CS_PARMS, 6, printk(KERN_INFO
-			 "cs4281: start_adc(): writel 0x%x \n", temp1));
-	}
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: start_adc()-\n"));
-
-}
-
-
-// --------------------------------------------------------------------- 
-
-#define DMABUF_MINORDER 1	// ==> min buffer size = 8K.
-
-
-static void dealloc_dmabuf(struct cs4281_state *s, struct dmabuf *db)
-{
-	struct page *map, *mapend;
-
-	if (db->rawbuf) {
-		// Undo prog_dmabuf()'s marking the pages as reserved 
-		mapend =
-		    virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) -
-				 1);
-		for (map = virt_to_page(db->rawbuf); map <= mapend; map++)
-			ClearPageReserved(map);
-		free_dmabuf(s, db);
-	}
-	if (s->tmpbuff && (db->type == CS_TYPE_ADC)) {
-		// Undo prog_dmabuf()'s marking the pages as reserved 
-		mapend =
-		    virt_to_page(s->tmpbuff +
-				 (PAGE_SIZE << s->buforder_tmpbuff) - 1);
-		for (map = virt_to_page(s->tmpbuff); map <= mapend; map++)
-			ClearPageReserved(map);
-		free_dmabuf2(s, db);
-	}
-	s->tmpbuff = NULL;
-	db->rawbuf = NULL;
-	db->mapped = db->ready = 0;
-}
-
-static int prog_dmabuf(struct cs4281_state *s, struct dmabuf *db)
-{
-	int order;
-	unsigned bytespersec, temp1;
-	unsigned bufs, sample_shift = 0;
-	struct page *map, *mapend;
-	unsigned long df;
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: prog_dmabuf()+\n"));
-	db->hwptr = db->swptr = db->total_bytes = db->count = db->error =
-	    db->endcleared = db->blocks = db->wakeup = db->underrun = 0;
-/*
-* check for order within limits, but do not overwrite value, check
-* later for a fractional defaultorder (i.e. 100+).
-*/
-	if((defaultorder > 0) && (defaultorder < 12))
-		df = defaultorder;
-	else
-		df = 1;	
-
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-		for (order = df; order >= DMABUF_MINORDER; order--)
-			if ( (db->rawbuf = (void *) pci_alloc_consistent(
-				s->pcidev, PAGE_SIZE << order, &db-> dmaaddr)))
-				    break;
-		if (!db->rawbuf) {
-			CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
-				"cs4281: prog_dmabuf(): unable to allocate rawbuf\n"));
-			return -ENOMEM;
-		}
-		db->buforder = order;
-		// Now mark the pages as reserved; otherwise the 
-		// remap_pfn_range() in cs4281_mmap doesn't work.
-		// 1. get index to last page in mem_map array for rawbuf.
-		mapend = virt_to_page(db->rawbuf + 
-			(PAGE_SIZE << db->buforder) - 1);
-
-		// 2. mark each physical page in range as 'reserved'.
-		for (map = virt_to_page(db->rawbuf); map <= mapend; map++)
-			SetPageReserved(map);
-	}
-	if (!s->tmpbuff && (db->type == CS_TYPE_ADC)) {
-		for (order = df; order >= DMABUF_MINORDER;
-		     order--)
-			if ( (s->tmpbuff = (void *) pci_alloc_consistent(
-					s->pcidev, PAGE_SIZE << order, 
-					&s->dmaaddr_tmpbuff)))
-				    break;
-		if (!s->tmpbuff) {
-			CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
-				"cs4281: prog_dmabuf(): unable to allocate tmpbuff\n"));
-			return -ENOMEM;
-		}
-		s->buforder_tmpbuff = order;
-		// Now mark the pages as reserved; otherwise the 
-		// remap_pfn_range() in cs4281_mmap doesn't work.
-		// 1. get index to last page in mem_map array for rawbuf.
-		mapend = virt_to_page(s->tmpbuff + 
-				(PAGE_SIZE << s->buforder_tmpbuff) - 1);
-
-		// 2. mark each physical page in range as 'reserved'.
-		for (map = virt_to_page(s->tmpbuff); map <= mapend; map++)
-			SetPageReserved(map);
-	}
-	if (db->type == CS_TYPE_DAC) {
-		if (s->prop_dac.fmt & (AFMT_S16_LE | AFMT_U16_LE))
-			sample_shift++;
-		if (s->prop_dac.channels > 1)
-			sample_shift++;
-		bytespersec = s->prop_dac.rate << sample_shift;
-	} else			// CS_TYPE_ADC
-	{
-		if (s->prop_adc.fmt & (AFMT_S16_LE | AFMT_U16_LE))
-			sample_shift++;
-		if (s->prop_adc.channels > 1)
-			sample_shift++;
-		bytespersec = s->prop_adc.rate << sample_shift;
-	}
-	bufs = PAGE_SIZE << db->buforder;
-
-/*
-* added fractional "defaultorder" inputs. if >100 then use 
-* defaultorder-100 as power of 2 for the buffer size. example:
-* 106 = 2^(106-100) = 2^6 = 64 bytes for the buffer size.
-*/
-	if(defaultorder >= 100)
-	{
-		bufs = 1 << (defaultorder-100);
-	}
-
-#define INTERRUPT_RATE_MS       100	// Interrupt rate in milliseconds.
-	db->numfrag = 2;
-/* 
-* Nominal frag size(bytes/interrupt)
-*/
-	temp1 = bytespersec / (1000 / INTERRUPT_RATE_MS);
-	db->fragshift = 8;	// Min 256 bytes.
-	while (1 << db->fragshift < temp1)	// Calc power of 2 frag size.
-		db->fragshift += 1;
-	db->fragsize = 1 << db->fragshift;
-	db->dmasize = db->fragsize * 2;
-	db->fragsamples = db->fragsize >> sample_shift;	// # samples/fragment.
-
-// If the calculated size is larger than the allocated
-//  buffer, divide the allocated buffer into 2 fragments.
-	if (db->dmasize > bufs) {
-
-		db->numfrag = 2;	// Two fragments.
-		db->fragsize = bufs >> 1;	// Each 1/2 the alloc'ed buffer.
-		db->fragsamples = db->fragsize >> sample_shift;	// # samples/fragment.
-		db->dmasize = bufs;	// Use all the alloc'ed buffer.
-
-		db->fragshift = 0;	// Calculate 'fragshift'.
-		temp1 = db->fragsize;	// update_ptr() uses it 
-		while ((temp1 >>= 1) > 1)	// to calc 'total-bytes'
-			db->fragshift += 1;	// returned in DSP_GETI/OPTR. 
-	}
-	CS_DBGOUT(CS_PARMS, 3, printk(KERN_INFO
-		"cs4281: prog_dmabuf(): numfrag=%d fragsize=%d fragsamples=%d fragshift=%d bufs=%d fmt=0x%x ch=%d\n",
-			db->numfrag, db->fragsize, db->fragsamples, 
-			db->fragshift, bufs, 
-			(db->type == CS_TYPE_DAC) ? s->prop_dac.fmt : 
-				s->prop_adc.fmt, 
-			(db->type == CS_TYPE_DAC) ? s->prop_dac.channels : 
-				s->prop_adc.channels));
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: prog_dmabuf()-\n"));
-	return 0;
-}
-
-
-static int prog_dmabuf_adc(struct cs4281_state *s)
-{
-	unsigned long va;
-	unsigned count;
-	int c;
-	stop_adc(s);
-	s->dma_adc.type = CS_TYPE_ADC;
-	if ((c = prog_dmabuf(s, &s->dma_adc)))
-		return c;
-
-	if (s->dma_adc.rawbuf) {
-		memset(s->dma_adc.rawbuf,
-		       (s->prop_adc.
-			fmt & (AFMT_U8 | AFMT_U16_LE)) ? 0x80 : 0,
-		       s->dma_adc.dmasize);
-	}
-	if (s->tmpbuff) {
-		memset(s->tmpbuff,
-		       (s->prop_adc.
-			fmt & (AFMT_U8 | AFMT_U16_LE)) ? 0x80 : 0,
-		       PAGE_SIZE << s->buforder_tmpbuff);
-	}
-
-	va = virt_to_bus(s->dma_adc.rawbuf);
-
-	count = s->dma_adc.dmasize;
-
-	if (s->prop_adc.
-	    fmt & (AFMT_S16_LE | AFMT_U16_LE | AFMT_S16_BE | AFMT_U16_BE))
-		    count /= 2;	// 16-bit.
-
-	if (s->prop_adc.channels > 1)
-		count /= 2;	// Assume stereo.
-
-	CS_DBGOUT(CS_WAVE_READ, 3, printk(KERN_INFO
-		"cs4281: prog_dmabuf_adc(): count=%d va=0x%.8x\n",
-			count, (unsigned) va));
-
-	writel(va, s->pBA0 + BA0_DBA1);	// Set buffer start address.
-	writel(count - 1, s->pBA0 + BA0_DBC1);	// Set count. 
-	s->dma_adc.ready = 1;
-	return 0;
-}
-
-
-static int prog_dmabuf_dac(struct cs4281_state *s)
-{
-	unsigned long va;
-	unsigned count;
-	int c;
-	stop_dac(s);
-	s->dma_dac.type = CS_TYPE_DAC;
-	if ((c = prog_dmabuf(s, &s->dma_dac)))
-		return c;
-	memset(s->dma_dac.rawbuf,
-	       (s->prop_dac.fmt & (AFMT_U8 | AFMT_U16_LE)) ? 0x80 : 0,
-	       s->dma_dac.dmasize);
-
-	va = virt_to_bus(s->dma_dac.rawbuf);
-
-	count = s->dma_dac.dmasize;
-	if (s->prop_dac.
-	    fmt & (AFMT_S16_LE | AFMT_U16_LE | AFMT_S16_BE | AFMT_U16_BE))
-		    count /= 2;	// 16-bit.
-
-	if (s->prop_dac.channels > 1)
-		count /= 2;	// Assume stereo.
-
-	writel(va, s->pBA0 + BA0_DBA0);	// Set buffer start address.
-	writel(count - 1, s->pBA0 + BA0_DBC0);	// Set count.             
-
-	CS_DBGOUT(CS_WAVE_WRITE, 3, printk(KERN_INFO
-		"cs4281: prog_dmabuf_dac(): count=%d va=0x%.8x\n",
-			count, (unsigned) va));
-
-	s->dma_dac.ready = 1;
-	return 0;
-}
-
-
-static void clear_advance(void *buf, unsigned bsize, unsigned bptr,
-			  unsigned len, unsigned char c)
-{
-	if (bptr + len > bsize) {
-		unsigned x = bsize - bptr;
-		memset(((char *) buf) + bptr, c, x);
-		bptr = 0;
-		len -= x;
-	}
-	CS_DBGOUT(CS_WAVE_WRITE, 4, printk(KERN_INFO
-		"cs4281: clear_advance(): memset %d at %p for %d size \n",
-			(unsigned)c, ((char *) buf) + bptr, len));
-	memset(((char *) buf) + bptr, c, len);
-}
-
-
-
-// call with spinlock held! 
-static void cs4281_update_ptr(struct cs4281_state *s, int intflag)
-{
-	int diff;
-	unsigned hwptr, va;
-
-	// update ADC pointer 
-	if (s->ena & FMODE_READ) {
-		hwptr = readl(s->pBA0 + BA0_DCA1);	// Read capture DMA address.
-		va = virt_to_bus(s->dma_adc.rawbuf);
-		hwptr -= (unsigned) va;
-		diff =
-		    (s->dma_adc.dmasize + hwptr -
-		     s->dma_adc.hwptr) % s->dma_adc.dmasize;
-		s->dma_adc.hwptr = hwptr;
-		s->dma_adc.total_bytes += diff;
-		s->dma_adc.count += diff;
-		if (s->dma_adc.count > s->dma_adc.dmasize)
-			s->dma_adc.count = s->dma_adc.dmasize;
-		if (s->dma_adc.mapped) {
-			if (s->dma_adc.count >=
-			    (signed) s->dma_adc.fragsize) wake_up(&s->
-								  dma_adc.
-								  wait);
-		} else {
-			if (s->dma_adc.count > 0)
-				wake_up(&s->dma_adc.wait);
-		}
-		CS_DBGOUT(CS_PARMS, 8, printk(KERN_INFO
-			"cs4281: cs4281_update_ptr(): s=%p hwptr=%d total_bytes=%d count=%d \n",
-				s, s->dma_adc.hwptr, s->dma_adc.total_bytes, s->dma_adc.count));
-	}
-	// update DAC pointer 
-	//
-	// check for end of buffer, means that we are going to wait for another interrupt
-	// to allow silence to fill the fifos on the part, to keep pops down to a minimum.
-	//
-	if (s->ena & FMODE_WRITE) {
-		hwptr = readl(s->pBA0 + BA0_DCA0);	// Read play DMA address.
-		va = virt_to_bus(s->dma_dac.rawbuf);
-		hwptr -= (unsigned) va;
-		diff = (s->dma_dac.dmasize + hwptr -
-		     s->dma_dac.hwptr) % s->dma_dac.dmasize;
-		s->dma_dac.hwptr = hwptr;
-		s->dma_dac.total_bytes += diff;
-		if (s->dma_dac.mapped) {
-			s->dma_dac.count += diff;
-			if (s->dma_dac.count >= s->dma_dac.fragsize) {
-				s->dma_dac.wakeup = 1;
-				wake_up(&s->dma_dac.wait);
-				if (s->dma_dac.count > s->dma_dac.dmasize)
-					s->dma_dac.count &=
-					    s->dma_dac.dmasize - 1;
-			}
-		} else {
-			s->dma_dac.count -= diff;
-			if (s->dma_dac.count <= 0) {
-				//
-				// fill with silence, and do not shut down the DAC.
-				// Continue to play silence until the _release.
-				//
-				CS_DBGOUT(CS_WAVE_WRITE, 6, printk(KERN_INFO
-					"cs4281: cs4281_update_ptr(): memset %d at %p for %d size \n",
-						(unsigned)(s->prop_dac.fmt & 
-						(AFMT_U8 | AFMT_U16_LE)) ? 0x80 : 0, 
-						s->dma_dac.rawbuf, s->dma_dac.dmasize));
-				memset(s->dma_dac.rawbuf,
-				       (s->prop_dac.
-					fmt & (AFMT_U8 | AFMT_U16_LE)) ?
-				       0x80 : 0, s->dma_dac.dmasize);
-				if (s->dma_dac.count < 0) {
-					s->dma_dac.underrun = 1;
-					s->dma_dac.count = 0;
-					CS_DBGOUT(CS_ERROR, 9, printk(KERN_INFO
-					 "cs4281: cs4281_update_ptr(): underrun\n"));
-				}
-			} else if (s->dma_dac.count <=
-				   (signed) s->dma_dac.fragsize
-				   && !s->dma_dac.endcleared) {
-				clear_advance(s->dma_dac.rawbuf,
-					      s->dma_dac.dmasize,
-					      s->dma_dac.swptr,
-					      s->dma_dac.fragsize,
-					      (s->prop_dac.
-					       fmt & (AFMT_U8 |
-						      AFMT_U16_LE)) ? 0x80
-					      : 0);
-				s->dma_dac.endcleared = 1;
-			}
-			if ( (s->dma_dac.count <= (signed) s->dma_dac.dmasize/2) ||
-				intflag)
-			{
-				wake_up(&s->dma_dac.wait);
-			}
-		}
-		CS_DBGOUT(CS_PARMS, 8, printk(KERN_INFO
-			"cs4281: cs4281_update_ptr(): s=%p hwptr=%d total_bytes=%d count=%d \n",
-				s, s->dma_dac.hwptr, s->dma_dac.total_bytes, s->dma_dac.count));
-	}
-}
-
-
-// --------------------------------------------------------------------- 
-
-static void prog_codec(struct cs4281_state *s, unsigned type)
-{
-	unsigned long flags;
-	unsigned temp1, format;
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: prog_codec()+ \n"));
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (type == CS_TYPE_ADC) {
-		temp1 = readl(s->pBA0 + BA0_DCR1);
-		writel(temp1 | DCRn_MSK, s->pBA0 + BA0_DCR1);	// Stop capture DMA, if active.
-
-		// program sampling rates  
-		// Note, for CS4281, capture & play rates can be set independently.
-		cs4281_record_rate(s, s->prop_adc.rate);
-
-		// program ADC parameters 
-		format = DMRn_DMA | DMRn_AUTO | DMRn_TR_WRITE;
-		if (s->prop_adc.
-		    fmt & (AFMT_S16_LE | AFMT_U16_LE | AFMT_S16_BE | AFMT_U16_BE)) {	// 16-bit
-			if (s->prop_adc.fmt & (AFMT_S16_BE | AFMT_U16_BE))	// Big-endian?
-				format |= DMRn_BEND;
-			if (s->prop_adc.fmt & (AFMT_U16_LE | AFMT_U16_BE))
-				format |= DMRn_USIGN;	// Unsigned.      
-		} else
-			format |= DMRn_SIZE8 | DMRn_USIGN;	// 8-bit, unsigned
-		if (s->prop_adc.channels < 2)
-			format |= DMRn_MONO;
-
-		writel(format, s->pBA0 + BA0_DMR1);
-
-		CS_DBGOUT(CS_PARMS, 2, printk(KERN_INFO
-			"cs4281: prog_codec(): adc %s %s %s rate=%d DMR0 format=0x%.8x\n",
-				(format & DMRn_SIZE8) ? "8" : "16",
-				(format & DMRn_USIGN) ?  "Unsigned" : "Signed", 
-				(format & DMRn_MONO) ? "Mono" : "Stereo", 
-				s->prop_adc.rate, format));
-
-		s->ena &= ~FMODE_READ;	// not capturing data yet
-	}
-
-
-	if (type == CS_TYPE_DAC) {
-		temp1 = readl(s->pBA0 + BA0_DCR0);
-		writel(temp1 | DCRn_MSK, s->pBA0 + BA0_DCR0);	// Stop play DMA, if active.
-
-		// program sampling rates  
-		// Note, for CS4281, capture & play rates can be set independently.
-		cs4281_play_rate(s, s->prop_dac.rate);
-
-		// program DAC parameters 
-		format = DMRn_DMA | DMRn_AUTO | DMRn_TR_READ;
-		if (s->prop_dac.
-		    fmt & (AFMT_S16_LE | AFMT_U16_LE | AFMT_S16_BE | AFMT_U16_BE)) {	// 16-bit
-			if (s->prop_dac.fmt & (AFMT_S16_BE | AFMT_U16_BE))
-				format |= DMRn_BEND;	// Big Endian.
-			if (s->prop_dac.fmt & (AFMT_U16_LE | AFMT_U16_BE))
-				format |= DMRn_USIGN;	// Unsigned.      
-		} else
-			format |= DMRn_SIZE8 | DMRn_USIGN;	// 8-bit, unsigned
-
-		if (s->prop_dac.channels < 2)
-			format |= DMRn_MONO;
-
-		writel(format, s->pBA0 + BA0_DMR0);
-
-
-		CS_DBGOUT(CS_PARMS, 2, printk(KERN_INFO
-			"cs4281: prog_codec(): dac %s %s %s rate=%d DMR0 format=0x%.8x\n",
-				(format & DMRn_SIZE8) ? "8" : "16",
-				(format & DMRn_USIGN) ?  "Unsigned" : "Signed",
-				(format & DMRn_MONO) ? "Mono" : "Stereo", 
-				s->prop_dac.rate, format));
-
-		s->ena &= ~FMODE_WRITE;	// not capturing data yet
-
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: prog_codec()- \n"));
-}
-
-
-static int mixer_ioctl(struct cs4281_state *s, unsigned int cmd,
-		       unsigned long arg)
-{
-	// Index to mixer_src[] is value of AC97 Input Mux Select Reg.
-	// Value of array member is recording source Device ID Mask.
-	static const unsigned int mixer_src[8] = {
-		SOUND_MASK_MIC, SOUND_MASK_CD, 0, SOUND_MASK_LINE1,
-		SOUND_MASK_LINE, SOUND_MASK_VOLUME, 0, 0
-	};
-	void __user *argp = (void __user *)arg;
-
-	// Index of mixtable1[] member is Device ID 
-	// and must be <= SOUND_MIXER_NRDEVICES.
-	// Value of array member is index into s->mix.vol[]
-	static const unsigned char mixtable1[SOUND_MIXER_NRDEVICES] = {
-		[SOUND_MIXER_PCM] = 1,	// voice 
-		[SOUND_MIXER_LINE1] = 2,	// AUX
-		[SOUND_MIXER_CD] = 3,	// CD 
-		[SOUND_MIXER_LINE] = 4,	// Line 
-		[SOUND_MIXER_SYNTH] = 5,	// FM
-		[SOUND_MIXER_MIC] = 6,	// Mic 
-		[SOUND_MIXER_SPEAKER] = 7,	// Speaker 
-		[SOUND_MIXER_RECLEV] = 8,	// Recording level 
-		[SOUND_MIXER_VOLUME] = 9	// Master Volume 
-	};
-
-
-	static const unsigned mixreg[] = {
-		BA0_AC97_PCM_OUT_VOLUME,
-		BA0_AC97_AUX_VOLUME,
-		BA0_AC97_CD_VOLUME,
-		BA0_AC97_LINE_IN_VOLUME
-	};
-	unsigned char l, r, rl, rr, vidx;
-	unsigned char attentbl[11] =
-	    { 63, 42, 26, 17, 14, 11, 8, 6, 4, 2, 0 };
-	unsigned temp1;
-	int i, val;
-
-	VALIDATE_STATE(s);
-	CS_DBGOUT(CS_FUNCTION, 4, printk(KERN_INFO
-		 "cs4281: mixer_ioctl(): s=%p cmd=0x%.8x\n", s, cmd));
-#if CSDEBUG
-	cs_printioctl(cmd);
-#endif
-#if CSDEBUG_INTERFACE
-
-	if ((cmd == SOUND_MIXER_CS_GETDBGMASK) ||
-	    (cmd == SOUND_MIXER_CS_SETDBGMASK) ||
-	    (cmd == SOUND_MIXER_CS_GETDBGLEVEL) ||
-	    (cmd == SOUND_MIXER_CS_SETDBGLEVEL) ||
-	    (cmd == SOUND_MIXER_CS_APM))
-	{
-		switch (cmd) {
-
-		case SOUND_MIXER_CS_GETDBGMASK:
-			return put_user(cs_debugmask,
-					(unsigned long __user *) argp);
-
-		case SOUND_MIXER_CS_GETDBGLEVEL:
-			return put_user(cs_debuglevel,
-					(unsigned long __user *) argp);
-
-		case SOUND_MIXER_CS_SETDBGMASK:
-			if (get_user(val, (unsigned long __user *) argp))
-				return -EFAULT;
-			cs_debugmask = val;
-			return 0;
-
-		case SOUND_MIXER_CS_SETDBGLEVEL:
-			if (get_user(val, (unsigned long __user *) argp))
-				return -EFAULT;
-			cs_debuglevel = val;
-			return 0;
-#ifndef NOT_CS4281_PM
-		case SOUND_MIXER_CS_APM:
-			if (get_user(val, (unsigned long __user *) argp))
-				return -EFAULT;
-			if(val == CS_IOCTL_CMD_SUSPEND)
-				cs4281_suspend(s);
-			else if(val == CS_IOCTL_CMD_RESUME)
-				cs4281_resume(s);
-			else
-			{
-				CS_DBGOUT(CS_ERROR, 1, printk(KERN_INFO
-				    "cs4281: mixer_ioctl(): invalid APM cmd (%d)\n",
-					val));
-			}
-			return 0;
-#endif
-		default:
-			CS_DBGOUT(CS_ERROR, 1, printk(KERN_INFO
-				"cs4281: mixer_ioctl(): ERROR unknown debug cmd\n"));
-			return 0;
-		}
-	}
-#endif
-
-	if (cmd == SOUND_MIXER_PRIVATE1) {
-		// enable/disable/query mixer preamp 
-		if (get_user(val, (int __user *) argp))
-			return -EFAULT;
-		if (val != -1) {
-			cs4281_read_ac97(s, BA0_AC97_MIC_VOLUME, &temp1);
-			temp1 = val ? (temp1 | 0x40) : (temp1 & 0xffbf);
-			cs4281_write_ac97(s, BA0_AC97_MIC_VOLUME, temp1);
-		}
-		cs4281_read_ac97(s, BA0_AC97_MIC_VOLUME, &temp1);
-		val = (temp1 & 0x40) ? 1 : 0;
-		return put_user(val, (int __user *) argp);
-	}
-	if (cmd == SOUND_MIXER_PRIVATE2) {
-		// enable/disable/query spatializer 
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		if (val != -1) {
-			temp1 = (val & 0x3f) >> 2;
-			cs4281_write_ac97(s, BA0_AC97_3D_CONTROL, temp1);
-			cs4281_read_ac97(s, BA0_AC97_GENERAL_PURPOSE,
-					 &temp1);
-			cs4281_write_ac97(s, BA0_AC97_GENERAL_PURPOSE,
-					  temp1 | 0x2000);
-		}
-		cs4281_read_ac97(s, BA0_AC97_3D_CONTROL, &temp1);
-		return put_user((temp1 << 2) | 3, (int __user *)argp);
-	}
-	if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		strlcpy(info.id, "CS4281", sizeof(info.id));
-		strlcpy(info.name, "Crystal CS4281", sizeof(info.name));
-		info.modify_counter = s->mix.modcnt;
-		if (copy_to_user(argp, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == SOUND_OLD_MIXER_INFO) {
-		_old_mixer_info info;
-		strlcpy(info.id, "CS4281", sizeof(info.id));
-		strlcpy(info.name, "Crystal CS4281", sizeof(info.name));
-		if (copy_to_user(argp, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, (int __user *) argp);
-
-	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
-		return -EINVAL;
-
-	// If ioctl has only the SIOC_READ bit(bit 31)
-	// on, process the only-read commands. 
-	if (_SIOC_DIR(cmd) == _SIOC_READ) {
-		switch (_IOC_NR(cmd)) {
-		case SOUND_MIXER_RECSRC:	// Arg contains a bit for each recording source 
-			cs4281_read_ac97(s, BA0_AC97_RECORD_SELECT, &temp1);
-			return put_user(mixer_src[temp1&7], (int __user *)argp);
-
-		case SOUND_MIXER_DEVMASK:	// Arg contains a bit for each supported device 
-			return put_user(SOUND_MASK_PCM | SOUND_MASK_SYNTH |
-					SOUND_MASK_CD | SOUND_MASK_LINE |
-					SOUND_MASK_LINE1 | SOUND_MASK_MIC |
-					SOUND_MASK_VOLUME |
-					SOUND_MASK_RECLEV |
-					SOUND_MASK_SPEAKER, (int __user *)argp);
-
-		case SOUND_MIXER_RECMASK:	// Arg contains a bit for each supported recording source 
-			return put_user(SOUND_MASK_LINE | SOUND_MASK_MIC |
-					SOUND_MASK_CD | SOUND_MASK_VOLUME |
-					SOUND_MASK_LINE1, (int __user *) argp);
-
-		case SOUND_MIXER_STEREODEVS:	// Mixer channels supporting stereo 
-			return put_user(SOUND_MASK_PCM | SOUND_MASK_SYNTH |
-					SOUND_MASK_CD | SOUND_MASK_LINE |
-					SOUND_MASK_LINE1 | SOUND_MASK_MIC |
-					SOUND_MASK_VOLUME |
-					SOUND_MASK_RECLEV, (int __user *)argp);
-
-		case SOUND_MIXER_CAPS:
-			return put_user(SOUND_CAP_EXCL_INPUT, (int __user *)argp);
-
-		default:
-			i = _IOC_NR(cmd);
-			if (i >= SOUND_MIXER_NRDEVICES
-			    || !(vidx = mixtable1[i]))
-				return -EINVAL;
-			return put_user(s->mix.vol[vidx - 1], (int __user *)argp);
-		}
-	}
-	// If ioctl doesn't have both the SIOC_READ and 
-	// the SIOC_WRITE bit set, return invalid.
-	if (_SIOC_DIR(cmd) != (_SIOC_READ | _SIOC_WRITE))
-		return -EINVAL;
-
-	// Increment the count of volume writes.
-	s->mix.modcnt++;
-
-	// Isolate the command; it must be a write.
-	switch (_IOC_NR(cmd)) {
-
-	case SOUND_MIXER_RECSRC:	// Arg contains a bit for each recording source 
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		i = hweight32(val);	// i = # bits on in val.
-		if (i != 1)	// One & only 1 bit must be on.
-			return 0;
-		for (i = 0; i < sizeof(mixer_src) / sizeof(int); i++) {
-			if (val == mixer_src[i]) {
-				temp1 = (i << 8) | i;
-				cs4281_write_ac97(s,
-						  BA0_AC97_RECORD_SELECT,
-						  temp1);
-				return 0;
-			}
-		}
-		return 0;
-
-	case SOUND_MIXER_VOLUME:
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;	// Max soundcard.h vol is 100.
-		if (l < 6) {
-			rl = 63;
-			l = 0;
-		} else
-			rl = attentbl[(10 * l) / 100];	// Convert 0-100 vol to 63-0 atten.
-
-		r = (val >> 8) & 0xff;
-		if (r > 100)
-			r = 100;	// Max right volume is 100, too
-		if (r < 6) {
-			rr = 63;
-			r = 0;
-		} else
-			rr = attentbl[(10 * r) / 100];	// Convert volume to attenuation.
-
-		if ((rl > 60) && (rr > 60))	// If both l & r are 'low',          
-			temp1 = 0x8000;	//  turn on the mute bit.
-		else
-			temp1 = 0;
-
-		temp1 |= (rl << 8) | rr;
-
-		cs4281_write_ac97(s, BA0_AC97_MASTER_VOLUME, temp1);
-		cs4281_write_ac97(s, BA0_AC97_HEADPHONE_VOLUME, temp1);
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[8] = ((unsigned int) r << 8) | l;
-#else
-		s->mix.vol[8] = val;
-#endif
-		return put_user(s->mix.vol[8], (int __user *)argp);
-
-	case SOUND_MIXER_SPEAKER:
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		if (l < 3) {
-			rl = 0;
-			l = 0;
-		} else {
-			rl = (l * 2 - 5) / 13;	// Convert 0-100 range to 0-15.
-			l = (rl * 13 + 5) / 2;
-		}
-
-		if (rl < 3) {
-			temp1 = 0x8000;
-			rl = 0;
-		} else
-			temp1 = 0;
-		rl = 15 - rl;	// Convert volume to attenuation.
-		temp1 |= rl << 1;
-		cs4281_write_ac97(s, BA0_AC97_PC_BEEP_VOLUME, temp1);
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[6] = l << 8;
-#else
-		s->mix.vol[6] = val;
-#endif
-		return put_user(s->mix.vol[6], (int __user *)argp);
-
-	case SOUND_MIXER_RECLEV:
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		r = (val >> 8) & 0xff;
-		if (r > 100)
-			r = 100;
-		rl = (l * 2 - 5) / 13;	// Convert 0-100 scale to 0-15.
-		rr = (r * 2 - 5) / 13;
-		if (rl < 3 && rr < 3)
-			temp1 = 0x8000;
-		else
-			temp1 = 0;
-
-		temp1 = temp1 | (rl << 8) | rr;
-		cs4281_write_ac97(s, BA0_AC97_RECORD_GAIN, temp1);
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[7] = ((unsigned int) r << 8) | l;
-#else
-		s->mix.vol[7] = val;
-#endif
-		return put_user(s->mix.vol[7], (int __user *)argp);
-
-	case SOUND_MIXER_MIC:
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		if (l < 1) {
-			l = 0;
-			rl = 0;
-		} else {
-			rl = ((unsigned) l * 5 - 4) / 16;	// Convert 0-100 range to 0-31.
-			l = (rl * 16 + 4) / 5;
-		}
-		cs4281_read_ac97(s, BA0_AC97_MIC_VOLUME, &temp1);
-		temp1 &= 0x40;	// Isolate 20db gain bit.
-		if (rl < 3) {
-			temp1 |= 0x8000;
-			rl = 0;
-		}
-		rl = 31 - rl;	// Convert volume to attenuation.
-		temp1 |= rl;
-		cs4281_write_ac97(s, BA0_AC97_MIC_VOLUME, temp1);
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[5] = val << 8;
-#else
-		s->mix.vol[5] = val;
-#endif
-		return put_user(s->mix.vol[5], (int __user *)argp);
-
-
-	case SOUND_MIXER_SYNTH:
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		r = (val >> 8) & 0xff;
-		if (r > 100)
-			r = 100;
-		rl = (l * 2 - 11) / 3;	// Convert 0-100 range to 0-63.
-		rr = (r * 2 - 11) / 3;
-		if (rl < 3)	// If l is low, turn on
-			temp1 = 0x0080;	//  the mute bit.
-		else
-			temp1 = 0;
-
-		rl = 63 - rl;	// Convert vol to attenuation.
-		writel(temp1 | rl, s->pBA0 + BA0_FMLVC);
-		if (rr < 3)	//  If rr is low, turn on
-			temp1 = 0x0080;	//   the mute bit.
-		else
-			temp1 = 0;
-		rr = 63 - rr;	// Convert vol to attenuation.
-		writel(temp1 | rr, s->pBA0 + BA0_FMRVC);
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[4] = (r << 8) | l;
-#else
-		s->mix.vol[4] = val;
-#endif
-		return put_user(s->mix.vol[4], (int __user *)argp);
-
-
-	default:
-		CS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO
-			"cs4281: mixer_ioctl(): default\n"));
-
-		i = _IOC_NR(cmd);
-		if (i >= SOUND_MIXER_NRDEVICES || !(vidx = mixtable1[i]))
-			return -EINVAL;
-		if (get_user(val, (int __user *)argp))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		if (l < 1) {
-			l = 0;
-			rl = 31;
-		} else
-			rl = (attentbl[(l * 10) / 100]) >> 1;
-
-		r = (val >> 8) & 0xff;
-		if (r > 100)
-			r = 100;
-		if (r < 1) {
-			r = 0;
-			rr = 31;
-		} else
-			rr = (attentbl[(r * 10) / 100]) >> 1;
-		if ((rl > 30) && (rr > 30))
-			temp1 = 0x8000;
-		else
-			temp1 = 0;
-		temp1 = temp1 | (rl << 8) | rr;
-		cs4281_write_ac97(s, mixreg[vidx - 1], temp1);
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[vidx - 1] = ((unsigned int) r << 8) | l;
-#else
-		s->mix.vol[vidx - 1] = val;
-#endif
-#ifndef NOT_CS4281_PM
-		CS_DBGOUT(CS_PM, 9, printk(KERN_INFO 
-			"write ac97 mixreg[%d]=0x%x mix.vol[]=0x%x\n", 
-				vidx-1,temp1,s->mix.vol[vidx-1]));
-#endif
-		return put_user(s->mix.vol[vidx - 1], (int __user *)argp);
-	}
-}
-
-
-// --------------------------------------------------------------------- 
-
-static int cs4281_open_mixdev(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	struct cs4281_state *s=NULL;
-	struct list_head *entry;
-
-	CS_DBGOUT(CS_FUNCTION | CS_OPEN, 4,
-		  printk(KERN_INFO "cs4281: cs4281_open_mixdev()+\n"));
-
-	list_for_each(entry, &cs4281_devs)
-	{
-		s = list_entry(entry, struct cs4281_state, list);
-		if(s->dev_mixer == minor)
-			break;
-	}
-	if (!s)
-	{
-		CS_DBGOUT(CS_FUNCTION | CS_OPEN | CS_ERROR, 2,
-			printk(KERN_INFO "cs4281: cs4281_open_mixdev()- -ENODEV\n"));
-		return -ENODEV;
-	}
-	VALIDATE_STATE(s);
-	file->private_data = s;
-
-	CS_DBGOUT(CS_FUNCTION | CS_OPEN, 4,
-		  printk(KERN_INFO "cs4281: cs4281_open_mixdev()- 0\n"));
-
-	return nonseekable_open(inode, file);
-}
-
-
-static int cs4281_release_mixdev(struct inode *inode, struct file *file)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-
-	VALIDATE_STATE(s);
-	return 0;
-}
-
-
-static int cs4281_ioctl_mixdev(struct inode *inode, struct file *file,
-			       unsigned int cmd, unsigned long arg)
-{
-	return mixer_ioctl((struct cs4281_state *) file->private_data, cmd,
-			   arg);
-}
-
-
-// ******************************************************************************************
-//   Mixer file operations struct.
-// ******************************************************************************************
-static /*const */ struct file_operations cs4281_mixer_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek	 = no_llseek,
-	.ioctl	 = cs4281_ioctl_mixdev,
-	.open	 = cs4281_open_mixdev,
-	.release = cs4281_release_mixdev,
-};
-
-// --------------------------------------------------------------------- 
-
-
-static int drain_adc(struct cs4281_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count;
-	unsigned tmo;
-
-	if (s->dma_adc.mapped)
-		return 0;
-	add_wait_queue(&s->dma_adc.wait, &wait);
-	for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_adc.count;
-		CS_DBGOUT(CS_FUNCTION, 2,
-			  printk(KERN_INFO "cs4281: drain_adc() %d\n", count));
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0) {
-			CS_DBGOUT(CS_FUNCTION, 2, printk(KERN_INFO
-				 "cs4281: drain_adc() count<0\n"));
-			break;
-		}
-		if (signal_pending(current))
-			break;
-		if (nonblock) {
-			remove_wait_queue(&s->dma_adc.wait, &wait);
-			current->state = TASK_RUNNING;
-			return -EBUSY;
-		}
-		tmo =
-		    3 * HZ * (count +
-			      s->dma_adc.fragsize) / 2 / s->prop_adc.rate;
-		if (s->prop_adc.fmt & (AFMT_S16_LE | AFMT_U16_LE))
-			tmo >>= 1;
-		if (s->prop_adc.channels > 1)
-			tmo >>= 1;
-		if (!schedule_timeout(tmo + 1))
-			printk(KERN_DEBUG "cs4281: dma timed out??\n");
-	}
-	remove_wait_queue(&s->dma_adc.wait, &wait);
-	current->state = TASK_RUNNING;
-	if (signal_pending(current))
-		return -ERESTARTSYS;
-	return 0;
-}
-
-static int drain_dac(struct cs4281_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count;
-	unsigned tmo;
-
-	if (s->dma_dac.mapped)
-		return 0;
-	add_wait_queue(&s->dma_dac.wait, &wait);
-	for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-			break;
-		if (nonblock) {
-			remove_wait_queue(&s->dma_dac.wait, &wait);
-			current->state = TASK_RUNNING;
-			return -EBUSY;
-		}
-		tmo =
-		    3 * HZ * (count +
-			      s->dma_dac.fragsize) / 2 / s->prop_dac.rate;
-		if (s->prop_dac.fmt & (AFMT_S16_LE | AFMT_U16_LE))
-			tmo >>= 1;
-		if (s->prop_dac.channels > 1)
-			tmo >>= 1;
-		if (!schedule_timeout(tmo + 1))
-			printk(KERN_DEBUG "cs4281: dma timed out??\n");
-	}
-	remove_wait_queue(&s->dma_dac.wait, &wait);
-	current->state = TASK_RUNNING;
-	if (signal_pending(current))
-		return -ERESTARTSYS;
-	return 0;
-}
-
-//****************************************************************************
-//
-// CopySamples copies 16-bit stereo samples from the source to the
-// destination, possibly converting down to either 8-bit or mono or both.
-// count specifies the number of output bytes to write.
-//
-//  Arguments:
-//
-//  dst             - Pointer to a destination buffer.
-//  src             - Pointer to a source buffer
-//  count           - The number of bytes to copy into the destination buffer.
-//  iChannels       - Stereo - 2
-//                    Mono   - 1
-//  fmt             - AFMT_xxx (soundcard.h formats)
-//
-// NOTES: only call this routine for conversion to 8bit from 16bit
-//
-//****************************************************************************
-static void CopySamples(char *dst, char *src, int count, int iChannels,
-			unsigned fmt)
-{
-
-	unsigned short *psSrc;
-	long lAudioSample;
-
-	CS_DBGOUT(CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: CopySamples()+ "));
-	CS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO
-		 " dst=%p src=%p count=%d iChannels=%d fmt=0x%x\n",
-			 dst, src, (unsigned) count, (unsigned) iChannels, (unsigned) fmt));
-
-	// Gershwin does format conversion in hardware so normally
-	// we don't do any host based coversion. The data formatter
-	// truncates 16 bit data to 8 bit and that causes some hiss.
-	// We have already forced the HW to do 16 bit sampling and 
-	// 2 channel so that we can use software to round instead 
-	// of truncate
-
-	//
-	// See if the data should be output as 8-bit unsigned stereo.
-	// or if the data should be output at 8-bit unsigned mono.
-	//
-	if ( ((iChannels == 2) && (fmt & AFMT_U8)) ||
-		((iChannels == 1) && (fmt & AFMT_U8)) ) {
-		//
-		// Convert each 16-bit unsigned stereo sample to 8-bit unsigned 
-		// stereo using rounding.
-		//
-		psSrc = (unsigned short *) src;
-		count = count / 2;
-		while (count--) {
-			lAudioSample = (long) psSrc[count] + (long) 0x80;
-			if (lAudioSample > 0xffff) {
-				lAudioSample = 0xffff;
-			}
-			dst[count] = (char) (lAudioSample >> 8);
-		}
-	}
-	//
-	// check for 8-bit signed stereo.
-	//
-	else if ((iChannels == 2) && (fmt & AFMT_S8)) {
-		//
-		// Convert each 16-bit stereo sample to 8-bit stereo using rounding.
-		//
-		psSrc = (short *) src;
-		while (count--) {
-			lAudioSample =
-			    (((long) psSrc[0] + (long) psSrc[1]) / 2);
-			psSrc += 2;
-			*dst++ = (char) ((short) lAudioSample >> 8);
-		}
-	}
-	//
-	// Otherwise, the data should be output as 8-bit signed mono.
-	//
-	else if ((iChannels == 1) && (fmt & AFMT_S8)) {
-		//
-		// Convert each 16-bit signed mono sample to 8-bit signed mono 
-		// using rounding.
-		//
-		psSrc = (short *) src;
-		count = count / 2;
-		while (count--) {
-			lAudioSample =
-			    (((long) psSrc[0] + (long) psSrc[1]) / 2);
-			if (lAudioSample > 0x7fff) {
-				lAudioSample = 0x7fff;
-			}
-			psSrc += 2;
-			*dst++ = (char) ((short) lAudioSample >> 8);
-		}
-	}
-}
-
-//
-// cs_copy_to_user()
-// replacement for the standard copy_to_user, to allow for a conversion from
-// 16 bit to 8 bit if the record conversion is active.  the cs4281 has some
-// issues with 8 bit capture, so the driver always captures data in 16 bit
-// and then if the user requested 8 bit, converts from 16 to 8 bit.
-//
-static unsigned cs_copy_to_user(struct cs4281_state *s, void __user *dest,
-				unsigned *hwsrc, unsigned cnt,
-				unsigned *copied)
-{
-	void *src = hwsrc;	//default to the standard destination buffer addr
-
-	CS_DBGOUT(CS_FUNCTION, 6, printk(KERN_INFO
-		"cs_copy_to_user()+ fmt=0x%x fmt_o=0x%x cnt=%d dest=%p\n",
-			s->prop_adc.fmt, s->prop_adc.fmt_original,
-			(unsigned) cnt, dest));
-
-	if (cnt > s->dma_adc.dmasize) {
-		cnt = s->dma_adc.dmasize;
-	}
-	if (!cnt) {
-		*copied = 0;
-		return 0;
-	}
-	if (s->conversion) {
-		if (!s->tmpbuff) {
-			*copied = cnt / 2;
-			return 0;
-		}
-		CopySamples(s->tmpbuff, (void *) hwsrc, cnt,
-			    (unsigned) s->prop_adc.channels,
-			    s->prop_adc.fmt_original);
-		src = s->tmpbuff;
-		cnt = cnt / 2;
-	}
-
-	if (copy_to_user(dest, src, cnt)) {
-		*copied = 0;
-		return -EFAULT;
-	}
-	*copied = cnt;
-	CS_DBGOUT(CS_FUNCTION, 2, printk(KERN_INFO
-		"cs4281: cs_copy_to_user()- copied bytes is %d \n", cnt));
-	return 0;
-}
-
-// --------------------------------------------------------------------- 
-
-static ssize_t cs4281_read(struct file *file, char __user *buffer, size_t count,
-			   loff_t * ppos)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-	unsigned copied = 0;
-
-	CS_DBGOUT(CS_FUNCTION | CS_WAVE_READ, 2,
-		  printk(KERN_INFO "cs4281: cs4281_read()+ %Zu \n", count));
-
-	VALIDATE_STATE(s);
-	if (s->dma_adc.mapped)
-		return -ENXIO;
-	if (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))
-		return ret;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-//
-// "count" is the amount of bytes to read (from app), is decremented each loop
-//      by the amount of bytes that have been returned to the user buffer.
-// "cnt" is the running total of each read from the buffer (changes each loop)
-// "buffer" points to the app's buffer
-// "ret" keeps a running total of the amount of bytes that have been copied
-//      to the user buffer.
-// "copied" is the total bytes copied into the user buffer for each loop.
-//
-	while (count > 0) {
-		CS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO
-			"_read() count>0 count=%Zu .count=%d .swptr=%d .hwptr=%d \n",
-				count, s->dma_adc.count,
-				s->dma_adc.swptr, s->dma_adc.hwptr));
-		spin_lock_irqsave(&s->lock, flags);
-
-		// get the current copy point of the sw buffer
-		swptr = s->dma_adc.swptr;
-
-		// cnt is the amount of unread bytes from the end of the 
-		// hw buffer to the current sw pointer
-		cnt = s->dma_adc.dmasize - swptr;
-
-		// dma_adc.count is the current total bytes that have not been read.
-		// if the amount of unread bytes from the current sw pointer to the
-		// end of the buffer is greater than the current total bytes that
-		// have not been read, then set the "cnt" (unread bytes) to the
-		// amount of unread bytes.  
-
-		if (s->dma_adc.count < cnt)
-			cnt = s->dma_adc.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		//
-		// if we are converting from 8/16 then we need to copy
-		// twice the number of 16 bit bytes then 8 bit bytes.
-		// 
-		if (s->conversion) {
-			if (cnt > (count * 2))
-				cnt = (count * 2);
-		} else {
-			if (cnt > count)
-				cnt = count;
-		}
-		//
-		// "cnt" NOW is the smaller of the amount that will be read,
-		// and the amount that is requested in this read (or partial).
-		// if there are no bytes in the buffer to read, then start the
-		// ADC and wait for the interrupt handler to wake us up.
-		//
-		if (cnt <= 0) {
-
-			// start up the dma engine and then continue back to the top of
-			// the loop when wake up occurs.
-			start_adc(s);
-			if (file->f_flags & O_NONBLOCK)
-				return ret ? ret : -EAGAIN;
-			interruptible_sleep_on(&s->dma_adc.wait);
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
-			continue;
-		}
-		// there are bytes in the buffer to read.
-		// copy from the hw buffer over to the user buffer.
-		// user buffer is designated by "buffer"
-		// virtual address to copy from is rawbuf+swptr
-		// the "cnt" is the number of bytes to read.
-
-		CS_DBGOUT(CS_WAVE_READ, 2, printk(KERN_INFO
-			"_read() copy_to cnt=%d count=%Zu ", cnt, count));
-		CS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO
-			 " .dmasize=%d .count=%d buffer=%p ret=%Zd\n",
-				 s->dma_adc.dmasize, s->dma_adc.count, buffer, ret));
-
-		if (cs_copy_to_user
-		    (s, buffer, s->dma_adc.rawbuf + swptr, cnt, &copied))
-			return ret ? ret : -EFAULT;
-		swptr = (swptr + cnt) % s->dma_adc.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_adc.swptr = swptr;
-		s->dma_adc.count -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= copied;
-		buffer += copied;
-		ret += copied;
-		start_adc(s);
-	}
-	CS_DBGOUT(CS_FUNCTION | CS_WAVE_READ, 2,
-		  printk(KERN_INFO "cs4281: cs4281_read()- %Zd\n", ret));
-	return ret;
-}
-
-
-static ssize_t cs4281_write(struct file *file, const char __user *buffer,
-			    size_t count, loff_t * ppos)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr, hwptr, busaddr;
-	int cnt;
-
-	CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE, 2,
-		  printk(KERN_INFO "cs4281: cs4281_write()+ count=%Zu\n",
-			 count));
-	VALIDATE_STATE(s);
-
-	if (s->dma_dac.mapped)
-		return -ENXIO;
-	if (!s->dma_dac.ready && (ret = prog_dmabuf_dac(s)))
-		return ret;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		if (s->dma_dac.count < 0) {
-			s->dma_dac.count = 0;
-			s->dma_dac.swptr = s->dma_dac.hwptr;
-		}
-		if (s->dma_dac.underrun) {
-			s->dma_dac.underrun = 0;
-			hwptr = readl(s->pBA0 + BA0_DCA0);
-			busaddr = virt_to_bus(s->dma_dac.rawbuf);
-			hwptr -= (unsigned) busaddr;
-			s->dma_dac.swptr = s->dma_dac.hwptr = hwptr;
-		}
-		swptr = s->dma_dac.swptr;
-		cnt = s->dma_dac.dmasize - swptr;
-		if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
-			cnt = s->dma_dac.dmasize - s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			start_dac(s);
-			if (file->f_flags & O_NONBLOCK)
-				return ret ? ret : -EAGAIN;
-			interruptible_sleep_on(&s->dma_dac.wait);
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
-			continue;
-		}
-		if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt))
-			return ret ? ret : -EFAULT;
-		swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac.swptr = swptr;
-		s->dma_dac.count += cnt;
-		s->dma_dac.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		start_dac(s);
-	}
-	CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE, 2,
-		  printk(KERN_INFO "cs4281: cs4281_write()- %Zd\n", ret));
-	return ret;
-}
-
-
-static unsigned int cs4281_poll(struct file *file,
-				struct poll_table_struct *wait)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,
-		  printk(KERN_INFO "cs4281: cs4281_poll()+\n"));
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE) {
-		CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,
-			  printk(KERN_INFO
-				 "cs4281: cs4281_poll() wait on FMODE_WRITE\n"));
-		if(!s->dma_dac.ready && prog_dmabuf_dac(s))
-			return 0;
-		poll_wait(file, &s->dma_dac.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,
-			  printk(KERN_INFO
-				 "cs4281: cs4281_poll() wait on FMODE_READ\n"));
-		if(!s->dma_dac.ready && prog_dmabuf_adc(s))
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	cs4281_update_ptr(s,CS_FALSE);
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >=
-			    (signed) s->dma_dac.fragsize) {
-				if (s->dma_dac.wakeup)
-					mask |= POLLOUT | POLLWRNORM;
-				else
-					mask = 0;
-				s->dma_dac.wakeup = 0;
-			}
-		} else {
-			if ((signed) (s->dma_dac.dmasize/2) >= s->dma_dac.count)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	} else if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.mapped) {
-			if (s->dma_adc.count >= (signed) s->dma_adc.fragsize) 
-				mask |= POLLIN | POLLRDNORM;
-		} else {
-			if (s->dma_adc.count > 0)
-				mask |= POLLIN | POLLRDNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	CS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,
-		  printk(KERN_INFO "cs4281: cs4281_poll()- 0x%.8x\n",
-			 mask));
-	return mask;
-}
-
-
-static int cs4281_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	struct dmabuf *db;
-	int ret;
-	unsigned long size;
-
-	CS_DBGOUT(CS_FUNCTION | CS_PARMS | CS_OPEN, 4,
-		  printk(KERN_INFO "cs4281: cs4281_mmap()+\n"));
-
-	VALIDATE_STATE(s);
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf_dac(s)) != 0)
-			return ret;
-		db = &s->dma_dac;
-	} else if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf_adc(s)) != 0)
-			return ret;
-		db = &s->dma_adc;
-	} else
-		return -EINVAL;
-//
-// only support PLAYBACK for now
-//
-	db = &s->dma_dac;
-
-	if (cs4x_pgoff(vma) != 0)
-		return -EINVAL;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder))
-		return -EINVAL;
-	if (remap_pfn_range(vma, vma->vm_start,
-				virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-				size, vma->vm_page_prot))
-		return -EAGAIN;
-	db->mapped = 1;
-
-	CS_DBGOUT(CS_FUNCTION | CS_PARMS | CS_OPEN, 4,
-		  printk(KERN_INFO "cs4281: cs4281_mmap()- 0 size=%d\n",
-			 (unsigned) size));
-
-	return 0;
-}
-
-
-static int cs4281_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	unsigned long flags;
-	audio_buf_info abinfo;
-	count_info cinfo;
-	int val, mapped, ret;
-	int __user *p = (int __user *)arg;
-
-	CS_DBGOUT(CS_FUNCTION, 4, printk(KERN_INFO
-		 "cs4281: cs4281_ioctl(): file=%p cmd=0x%.8x\n", file, cmd));
-#if CSDEBUG
-	cs_printioctl(cmd);
-#endif
-	VALIDATE_STATE(s);
-	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-	    ((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-			"cs4281: cs4281_ioctl(): SOUND_VERSION=0x%.8x\n",
-				 SOUND_VERSION));
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		CS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_SYNC\n"));
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s,
-					 0 /*file->f_flags & O_NONBLOCK */
-					 );
-		return 0;
-
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
-				DSP_CAP_TRIGGER | DSP_CAP_MMAP,
-				p);
-
-	case SNDCTL_DSP_RESET:
-		CS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_RESET\n"));
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq(s->irq);
-			s->dma_dac.swptr = s->dma_dac.hwptr =
-			    s->dma_dac.count = s->dma_dac.total_bytes =
-			    s->dma_dac.blocks = s->dma_dac.wakeup = 0;
-			prog_codec(s, CS_TYPE_DAC);
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->irq);
-			s->dma_adc.swptr = s->dma_adc.hwptr =
-			    s->dma_adc.count = s->dma_adc.total_bytes =
-			    s->dma_adc.blocks = s->dma_dac.wakeup = 0;
-			prog_codec(s, CS_TYPE_ADC);
-		}
-		return 0;
-
-	case SNDCTL_DSP_SPEED:
-		if (get_user(val, p))
-			return -EFAULT;
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_SPEED val=%d\n", val));
-		//
-		// support independent capture and playback channels
-		// assume that the file mode bit determines the 
-		// direction of the data flow.
-		//
-		if (file->f_mode & FMODE_READ) {
-			if (val >= 0) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				// program sampling rates 
-				if (val > 48000)
-					val = 48000;
-				if (val < 6300)
-					val = 6300;
-				s->prop_adc.rate = val;
-				prog_codec(s, CS_TYPE_ADC);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val >= 0) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				// program sampling rates 
-				if (val > 48000)
-					val = 48000;
-				if (val < 6300)
-					val = 6300;
-				s->prop_dac.rate = val;
-				prog_codec(s, CS_TYPE_DAC);
-			}
-		}
-
-		if (file->f_mode & FMODE_WRITE)
-			val = s->prop_dac.rate;
-		else if (file->f_mode & FMODE_READ)
-			val = s->prop_adc.rate;
-
-		return put_user(val, p);
-
-	case SNDCTL_DSP_STEREO:
-		if (get_user(val, p))
-			return -EFAULT;
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_STEREO val=%d\n", val));
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ready = 0;
-			s->prop_adc.channels = val ? 2 : 1;
-			prog_codec(s, CS_TYPE_ADC);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.ready = 0;
-			s->prop_dac.channels = val ? 2 : 1;
-			prog_codec(s, CS_TYPE_DAC);
-		}
-		return 0;
-
-	case SNDCTL_DSP_CHANNELS:
-		if (get_user(val, p))
-			return -EFAULT;
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_CHANNELS val=%d\n",
-				 val));
-		if (val != 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val >= 2)
-					s->prop_adc.channels = 2;
-				else
-					s->prop_adc.channels = 1;
-				prog_codec(s, CS_TYPE_ADC);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val >= 2)
-					s->prop_dac.channels = 2;
-				else
-					s->prop_dac.channels = 1;
-				prog_codec(s, CS_TYPE_DAC);
-			}
-		}
-
-		if (file->f_mode & FMODE_WRITE)
-			val = s->prop_dac.channels;
-		else if (file->f_mode & FMODE_READ)
-			val = s->prop_adc.channels;
-
-		return put_user(val, p);
-
-	case SNDCTL_DSP_GETFMTS:	// Returns a mask 
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-			"cs4281: cs4281_ioctl(): DSP_GETFMT val=0x%.8x\n",
-				 AFMT_S16_LE | AFMT_U16_LE | AFMT_S8 |
-				 AFMT_U8));
-		return put_user(AFMT_S16_LE | AFMT_U16_LE | AFMT_S8 |
-				AFMT_U8, p);
-
-	case SNDCTL_DSP_SETFMT:
-		if (get_user(val, p))
-			return -EFAULT;
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_SETFMT val=0x%.8x\n",
-				 val));
-		if (val != AFMT_QUERY) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val != AFMT_S16_LE
-				    && val != AFMT_U16_LE && val != AFMT_S8
-				    && val != AFMT_U8)
-					val = AFMT_U8;
-				s->prop_adc.fmt = val;
-				s->prop_adc.fmt_original = s->prop_adc.fmt;
-				prog_codec(s, CS_TYPE_ADC);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val != AFMT_S16_LE
-				    && val != AFMT_U16_LE && val != AFMT_S8
-				    && val != AFMT_U8)
-					val = AFMT_U8;
-				s->prop_dac.fmt = val;
-				s->prop_dac.fmt_original = s->prop_dac.fmt;
-				prog_codec(s, CS_TYPE_DAC);
-			}
-		} else {
-			if (file->f_mode & FMODE_WRITE)
-				val = s->prop_dac.fmt_original;
-			else if (file->f_mode & FMODE_READ)
-				val = s->prop_adc.fmt_original;
-		}
-		CS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO
-		  "cs4281: cs4281_ioctl(): DSP_SETFMT return val=0x%.8x\n", 
-			val));
-		return put_user(val, p);
-
-	case SNDCTL_DSP_POST:
-		CS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO
-			 "cs4281: cs4281_ioctl(): DSP_POST\n"));
-		return 0;
-
-	case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if (file->f_mode & s->ena & FMODE_READ)
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & s->ena & FMODE_WRITE)
-			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, p);
-
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready
-				    && (ret = prog_dmabuf_adc(s)))
-					return ret;
-				start_adc(s);
-			} else
-				stop_adc(s);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac.ready
-				    && (ret = prog_dmabuf_dac(s)))
-					return ret;
-				start_dac(s);
-			} else
-				stop_dac(s);
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf_dac(s)))
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		cs4281_update_ptr(s,CS_FALSE);
-		abinfo.fragsize = s->dma_dac.fragsize;
-		if (s->dma_dac.mapped)
-			abinfo.bytes = s->dma_dac.dmasize;
-		else
-			abinfo.bytes =
-			    s->dma_dac.dmasize - s->dma_dac.count;
-		abinfo.fragstotal = s->dma_dac.numfrag;
-		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
-		CS_DBGOUT(CS_FUNCTION | CS_PARMS, 4, printk(KERN_INFO
-			"cs4281: cs4281_ioctl(): GETOSPACE .fragsize=%d .bytes=%d .fragstotal=%d .fragments=%d\n",
-				abinfo.fragsize,abinfo.bytes,abinfo.fragstotal,
-				abinfo.fragments));
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(p, &abinfo,
-				    sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf_adc(s)))
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		cs4281_update_ptr(s,CS_FALSE);
-		if (s->conversion) {
-			abinfo.fragsize = s->dma_adc.fragsize / 2;
-			abinfo.bytes = s->dma_adc.count / 2;
-			abinfo.fragstotal = s->dma_adc.numfrag;
-			abinfo.fragments =
-			    abinfo.bytes >> (s->dma_adc.fragshift - 1);
-		} else {
-			abinfo.fragsize = s->dma_adc.fragsize;
-			abinfo.bytes = s->dma_adc.count;
-			abinfo.fragstotal = s->dma_adc.numfrag;
-			abinfo.fragments =
-			    abinfo.bytes >> s->dma_adc.fragshift;
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(p, &abinfo,
-				    sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_NONBLOCK:
-		file->f_flags |= O_NONBLOCK;
-		return 0;
-
-	case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if(!s->dma_dac.ready && prog_dmabuf_dac(s))
-			return 0;
-		spin_lock_irqsave(&s->lock, flags);
-		cs4281_update_ptr(s,CS_FALSE);
-		val = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		return put_user(val, p);
-
-	case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if(!s->dma_adc.ready && prog_dmabuf_adc(s))
-			return 0;
-		spin_lock_irqsave(&s->lock, flags);
-		cs4281_update_ptr(s,CS_FALSE);
-		cinfo.bytes = s->dma_adc.total_bytes;
-		if (s->dma_adc.mapped) {
-			cinfo.blocks =
-			    (cinfo.bytes >> s->dma_adc.fragshift) -
-			    s->dma_adc.blocks;
-			s->dma_adc.blocks =
-			    cinfo.bytes >> s->dma_adc.fragshift;
-		} else {
-			if (s->conversion) {
-				cinfo.blocks =
-				    s->dma_adc.count /
-				    2 >> (s->dma_adc.fragshift - 1);
-			} else
-				cinfo.blocks =
-				    s->dma_adc.count >> s->dma_adc.
-				    fragshift;
-		}
-		if (s->conversion)
-			cinfo.ptr = s->dma_adc.hwptr / 2;
-		else
-			cinfo.ptr = s->dma_adc.hwptr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize - 1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(p, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-	case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if(!s->dma_dac.ready && prog_dmabuf_dac(s))
-			return 0;
-		spin_lock_irqsave(&s->lock, flags);
-		cs4281_update_ptr(s,CS_FALSE);
-		cinfo.bytes = s->dma_dac.total_bytes;
-		if (s->dma_dac.mapped) {
-			cinfo.blocks =
-			    (cinfo.bytes >> s->dma_dac.fragshift) -
-			    s->dma_dac.blocks;
-			s->dma_dac.blocks =
-			    cinfo.bytes >> s->dma_dac.fragshift;
-		} else {
-			cinfo.blocks =
-			    s->dma_dac.count >> s->dma_dac.fragshift;
-		}
-		cinfo.ptr = s->dma_dac.hwptr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= s->dma_dac.fragsize - 1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(p, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf_dac(s)))
-				return val;
-			return put_user(s->dma_dac.fragsize, p);
-		}
-		if ((val = prog_dmabuf_adc(s)))
-			return val;
-		if (s->conversion)
-			return put_user(s->dma_adc.fragsize / 2, p);
-		else
-			return put_user(s->dma_adc.fragsize, p);
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, p))
-			return -EFAULT;
-		return 0;	// Say OK, but do nothing.
-
-	case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision)
-		    || (file->f_mode & FMODE_WRITE
-			&& s->dma_dac.subdivision)) return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		else if (file->f_mode & FMODE_WRITE)
-			s->dma_dac.subdivision = val;
-		return 0;
-
-	case SOUND_PCM_READ_RATE:
-		if (file->f_mode & FMODE_READ)
-			return put_user(s->prop_adc.rate, p);
-		else if (file->f_mode & FMODE_WRITE)
-			return put_user(s->prop_dac.rate, p);
-
-	case SOUND_PCM_READ_CHANNELS:
-		if (file->f_mode & FMODE_READ)
-			return put_user(s->prop_adc.channels, p);
-		else if (file->f_mode & FMODE_WRITE)
-			return put_user(s->prop_dac.channels, p);
-
-	case SOUND_PCM_READ_BITS:
-		if (file->f_mode & FMODE_READ)
-			return
-			    put_user(
-				     (s->prop_adc.
-				      fmt & (AFMT_S8 | AFMT_U8)) ? 8 : 16,
-				     p);
-		else if (file->f_mode & FMODE_WRITE)
-			return
-			    put_user(
-				     (s->prop_dac.
-				      fmt & (AFMT_S8 | AFMT_U8)) ? 8 : 16,
-				     p);
-
-	case SOUND_PCM_WRITE_FILTER:
-	case SNDCTL_DSP_SETSYNCRO:
-	case SOUND_PCM_READ_FILTER:
-		return -EINVAL;
-	}
-	return mixer_ioctl(s, cmd, arg);
-}
-
-
-static int cs4281_release(struct inode *inode, struct file *file)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-
-	CS_DBGOUT(CS_FUNCTION | CS_RELEASE, 2, printk(KERN_INFO
-		 "cs4281: cs4281_release(): inode=%p file=%p f_mode=%d\n",
-			 inode, file, file->f_mode));
-
-	VALIDATE_STATE(s);
-
-	if (file->f_mode & FMODE_WRITE) {
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-		mutex_lock(&s->open_sem_dac);
-		stop_dac(s);
-		dealloc_dmabuf(s, &s->dma_dac);
-		s->open_mode &= ~FMODE_WRITE;
-		mutex_unlock(&s->open_sem_dac);
-		wake_up(&s->open_wait_dac);
-	}
-	if (file->f_mode & FMODE_READ) {
-		drain_adc(s, file->f_flags & O_NONBLOCK);
-		mutex_lock(&s->open_sem_adc);
-		stop_adc(s);
-		dealloc_dmabuf(s, &s->dma_adc);
-		s->open_mode &= ~FMODE_READ;
-		mutex_unlock(&s->open_sem_adc);
-		wake_up(&s->open_wait_adc);
-	}
-	return 0;
-}
-
-static int cs4281_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	struct cs4281_state *s=NULL;
-	struct list_head *entry;
-
-	CS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO
-		"cs4281: cs4281_open(): inode=%p file=%p f_mode=0x%x\n",
-			inode, file, file->f_mode));
-
-	list_for_each(entry, &cs4281_devs)
-	{
-		s = list_entry(entry, struct cs4281_state, list);
-
-		if (!((s->dev_audio ^ minor) & ~0xf))
-			break;
-	}
-	if (entry == &cs4281_devs)
-		return -ENODEV;
-	if (!s) {
-		CS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO
-			"cs4281: cs4281_open(): Error - unable to find audio state struct\n"));
-		return -ENODEV;
-	}
-	VALIDATE_STATE(s);
-	file->private_data = s;
-
-	// wait for device to become free 
-	if (!(file->f_mode & (FMODE_WRITE | FMODE_READ))) {
-		CS_DBGOUT(CS_FUNCTION | CS_OPEN | CS_ERROR, 2, printk(KERN_INFO
-			 "cs4281: cs4281_open(): Error - must open READ and/or WRITE\n"));
-		return -ENODEV;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		mutex_lock(&s->open_sem_dac);
-		while (s->open_mode & FMODE_WRITE) {
-			if (file->f_flags & O_NONBLOCK) {
-				mutex_unlock(&s->open_sem_dac);
-				return -EBUSY;
-			}
-			mutex_unlock(&s->open_sem_dac);
-			interruptible_sleep_on(&s->open_wait_dac);
-
-			if (signal_pending(current))
-				return -ERESTARTSYS;
-			mutex_lock(&s->open_sem_dac);
-		}
-	}
-	if (file->f_mode & FMODE_READ) {
-		mutex_lock(&s->open_sem_adc);
-		while (s->open_mode & FMODE_READ) {
-			if (file->f_flags & O_NONBLOCK) {
-				mutex_unlock(&s->open_sem_adc);
-				return -EBUSY;
-			}
-			mutex_unlock(&s->open_sem_adc);
-			interruptible_sleep_on(&s->open_wait_adc);
-
-			if (signal_pending(current))
-				return -ERESTARTSYS;
-			mutex_lock(&s->open_sem_adc);
-		}
-	}
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	if (file->f_mode & FMODE_READ) {
-		s->prop_adc.fmt = AFMT_U8;
-		s->prop_adc.fmt_original = s->prop_adc.fmt;
-		s->prop_adc.channels = 1;
-		s->prop_adc.rate = 8000;
-		s->prop_adc.clkdiv = 96 | 0x80;
-		s->conversion = 0;
-		s->ena &= ~FMODE_READ;
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
-		    s->dma_adc.subdivision = 0;
-		mutex_unlock(&s->open_sem_adc);
-
-		if (prog_dmabuf_adc(s)) {
-			CS_DBGOUT(CS_OPEN | CS_ERROR, 2, printk(KERN_ERR
-				"cs4281: adc Program dmabufs failed.\n"));
-			cs4281_release(inode, file);
-			return -ENOMEM;
-		}
-		prog_codec(s, CS_TYPE_ADC);
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->prop_dac.fmt = AFMT_U8;
-		s->prop_dac.fmt_original = s->prop_dac.fmt;
-		s->prop_dac.channels = 1;
-		s->prop_dac.rate = 8000;
-		s->prop_dac.clkdiv = 96 | 0x80;
-		s->conversion = 0;
-		s->ena &= ~FMODE_WRITE;
-		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
-		    s->dma_dac.subdivision = 0;
-		mutex_unlock(&s->open_sem_dac);
-
-		if (prog_dmabuf_dac(s)) {
-			CS_DBGOUT(CS_OPEN | CS_ERROR, 2, printk(KERN_ERR
-				"cs4281: dac Program dmabufs failed.\n"));
-			cs4281_release(inode, file);
-			return -ENOMEM;
-		}
-		prog_codec(s, CS_TYPE_DAC);
-	}
-	CS_DBGOUT(CS_FUNCTION | CS_OPEN, 2,
-		  printk(KERN_INFO "cs4281: cs4281_open()- 0\n"));
-	return nonseekable_open(inode, file);
-}
-
-
-// ******************************************************************************************
-//   Wave (audio) file operations struct.
-// ******************************************************************************************
-static /*const */ struct file_operations cs4281_audio_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek	 = no_llseek,
-	.read	 = cs4281_read,
-	.write	 = cs4281_write,
-	.poll	 = cs4281_poll,
-	.ioctl	 = cs4281_ioctl,
-	.mmap	 = cs4281_mmap,
-	.open	 = cs4281_open,
-	.release = cs4281_release,
-};
-
-// --------------------------------------------------------------------- 
-
-// hold spinlock for the following! 
-static void cs4281_handle_midi(struct cs4281_state *s)
-{
-	unsigned char ch;
-	int wake;
-	unsigned temp1;
-
-	wake = 0;
-	while (!(readl(s->pBA0 + BA0_MIDSR) & 0x80)) {
-		ch = readl(s->pBA0 + BA0_MIDRP);
-		if (s->midi.icnt < MIDIINBUF) {
-			s->midi.ibuf[s->midi.iwr] = ch;
-			s->midi.iwr = (s->midi.iwr + 1) % MIDIINBUF;
-			s->midi.icnt++;
-		}
-		wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.iwait);
-	wake = 0;
-	while (!(readl(s->pBA0 + BA0_MIDSR) & 0x40) && s->midi.ocnt > 0) {
-		temp1 = (s->midi.obuf[s->midi.ord]) & 0x000000ff;
-		writel(temp1, s->pBA0 + BA0_MIDWP);
-		s->midi.ord = (s->midi.ord + 1) % MIDIOUTBUF;
-		s->midi.ocnt--;
-		if (s->midi.ocnt < MIDIOUTBUF - 16)
-			wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.owait);
-}
-
-
-
-static irqreturn_t cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct cs4281_state *s = (struct cs4281_state *) dev_id;
-	unsigned int temp1;
-
-	// fastpath out, to ease interrupt sharing 
-	temp1 = readl(s->pBA0 + BA0_HISR);	// Get Int Status reg.
-
-	CS_DBGOUT(CS_INTERRUPT, 6, printk(KERN_INFO
-		  "cs4281: cs4281_interrupt() BA0_HISR=0x%.8x\n", temp1));
-/*
-* If not DMA or MIDI interrupt, then just return.
-*/
-	if (!(temp1 & (HISR_DMA0 | HISR_DMA1 | HISR_MIDI))) {
-		writel(HICR_IEV | HICR_CHGM, s->pBA0 + BA0_HICR);
-		CS_DBGOUT(CS_INTERRUPT, 9, printk(KERN_INFO
-			"cs4281: cs4281_interrupt(): returning not cs4281 interrupt.\n"));
-		return IRQ_NONE;
-	}
-
-	if (temp1 & HISR_DMA0)	// If play interrupt,
-		readl(s->pBA0 + BA0_HDSR0);	//   clear the source.
-
-	if (temp1 & HISR_DMA1)	// Same for play.
-		readl(s->pBA0 + BA0_HDSR1);
-	writel(HICR_IEV | HICR_CHGM, s->pBA0 + BA0_HICR);	// Local EOI
-
-	spin_lock(&s->lock);
-	cs4281_update_ptr(s,CS_TRUE);
-	cs4281_handle_midi(s);
-	spin_unlock(&s->lock);
-	return IRQ_HANDLED;
-}
-
-// **************************************************************************
-
-static void cs4281_midi_timer(unsigned long data)
-{
-	struct cs4281_state *s = (struct cs4281_state *) data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	cs4281_handle_midi(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->midi.timer.expires = jiffies + 1;
-	add_timer(&s->midi.timer);
-}
-
-
-// --------------------------------------------------------------------- 
-
-static ssize_t cs4281_midi_read(struct file *file, char __user *buffer,
-				size_t count, loff_t * ppos)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.ird;
-		cnt = MIDIINBUF - ptr;
-		if (s->midi.icnt < cnt)
-			cnt = s->midi.icnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK)
-				return ret ? ret : -EAGAIN;
-			interruptible_sleep_on(&s->midi.iwait);
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
-			continue;
-		}
-		if (copy_to_user(buffer, s->midi.ibuf + ptr, cnt))
-			return ret ? ret : -EFAULT;
-		ptr = (ptr + cnt) % MIDIINBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.ird = ptr;
-		s->midi.icnt -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-	}
-	return ret;
-}
-
-
-static ssize_t cs4281_midi_write(struct file *file, const char __user *buffer,
-				 size_t count, loff_t * ppos)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.owr;
-		cnt = MIDIOUTBUF - ptr;
-		if (s->midi.ocnt + cnt > MIDIOUTBUF)
-			cnt = MIDIOUTBUF - s->midi.ocnt;
-		if (cnt <= 0)
-			cs4281_handle_midi(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK)
-				return ret ? ret : -EAGAIN;
-			interruptible_sleep_on(&s->midi.owait);
-			if (signal_pending(current))
-				return ret ? ret : -ERESTARTSYS;
-			continue;
-		}
-		if (copy_from_user(s->midi.obuf + ptr, buffer, cnt))
-			return ret ? ret : -EFAULT;
-		ptr = (ptr + cnt) % MIDIOUTBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.owr = ptr;
-		s->midi.ocnt += cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		spin_lock_irqsave(&s->lock, flags);
-		cs4281_handle_midi(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-	}
-	return ret;
-}
-
-
-static unsigned int cs4281_midi_poll(struct file *file,
-				     struct poll_table_struct *wait)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_flags & FMODE_WRITE)
-		poll_wait(file, &s->midi.owait, wait);
-	if (file->f_flags & FMODE_READ)
-		poll_wait(file, &s->midi.iwait, wait);
-	spin_lock_irqsave(&s->lock, flags);
-	if (file->f_flags & FMODE_READ) {
-		if (s->midi.icnt > 0)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_flags & FMODE_WRITE) {
-		if (s->midi.ocnt < MIDIOUTBUF)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-
-static int cs4281_midi_open(struct inode *inode, struct file *file)
-{
-	unsigned long flags, temp1;
-	unsigned int minor = iminor(inode);
-	struct cs4281_state *s=NULL;
-	struct list_head *entry;
-	list_for_each(entry, &cs4281_devs)
-	{
-		s = list_entry(entry, struct cs4281_state, list);
-
-		if (s->dev_midi == minor)
-			break;
-	}
-
-	if (entry == &cs4281_devs)
-		return -ENODEV;
-	if (!s)
-	{
-		CS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO
-			"cs4281: cs4281_open(): Error - unable to find audio state struct\n"));
-		return -ENODEV;
-	}
-	VALIDATE_STATE(s);
-	file->private_data = s;
-	// wait for device to become free 
-	mutex_lock(&s->open_sem);
-	while (s->open_mode & (file->f_mode << FMODE_MIDI_SHIFT)) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_sem);
-			return -EBUSY;
-		}
-		mutex_unlock(&s->open_sem);
-		interruptible_sleep_on(&s->open_wait);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_sem);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-		writel(1, s->pBA0 + BA0_MIDCR);	// Reset the interface.
-		writel(0, s->pBA0 + BA0_MIDCR);	// Return to normal mode.
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		writel(0x0000000f, s->pBA0 + BA0_MIDCR);	// Enable transmit, record, ints.
-		temp1 = readl(s->pBA0 + BA0_HIMR);
-		writel(temp1 & 0xffbfffff, s->pBA0 + BA0_HIMR);	// Enable midi int. recognition.
-		writel(HICR_IEV | HICR_CHGM, s->pBA0 + BA0_HICR);	// Enable interrupts
-		init_timer(&s->midi.timer);
-		s->midi.timer.expires = jiffies + 1;
-		s->midi.timer.data = (unsigned long) s;
-		s->midi.timer.function = cs4281_midi_timer;
-		add_timer(&s->midi.timer);
-	}
-	if (file->f_mode & FMODE_READ) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->open_mode |=
-	    (file->
-	     f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ |
-					    FMODE_MIDI_WRITE);
-	mutex_unlock(&s->open_sem);
-	return nonseekable_open(inode, file);
-}
-
-
-static int cs4281_midi_release(struct inode *inode, struct file *file)
-{
-	struct cs4281_state *s =
-	    (struct cs4281_state *) file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	unsigned count, tmo;
-
-	VALIDATE_STATE(s);
-
-	if (file->f_mode & FMODE_WRITE) {
-		add_wait_queue(&s->midi.owait, &wait);
-		for (;;) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			spin_lock_irqsave(&s->lock, flags);
-			count = s->midi.ocnt;
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (count <= 0)
-				break;
-			if (signal_pending(current))
-				break;
-			if (file->f_flags & O_NONBLOCK) {
-				remove_wait_queue(&s->midi.owait, &wait);
-				current->state = TASK_RUNNING;
-				return -EBUSY;
-			}
-			tmo = (count * HZ) / 3100;
-			if (!schedule_timeout(tmo ? : 1) && tmo)
-				printk(KERN_DEBUG
-				       "cs4281: midi timed out??\n");
-		}
-		remove_wait_queue(&s->midi.owait, &wait);
-		current->state = TASK_RUNNING;
-	}
-	mutex_lock(&s->open_sem);
-	s->open_mode &=
-	    (~(file->f_mode << FMODE_MIDI_SHIFT)) & (FMODE_MIDI_READ |
-						     FMODE_MIDI_WRITE);
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		writel(0, s->pBA0 + BA0_MIDCR);	// Disable Midi interrupts.  
-		del_timer(&s->midi.timer);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	mutex_unlock(&s->open_sem);
-	wake_up(&s->open_wait);
-	return 0;
-}
-
-// ******************************************************************************************
-//   Midi file operations struct.
-// ******************************************************************************************
-static /*const */ struct file_operations cs4281_midi_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek	 = no_llseek,
-	.read	 = cs4281_midi_read,
-	.write	 = cs4281_midi_write,
-	.poll	 = cs4281_midi_poll,
-	.open	 = cs4281_midi_open,
-	.release = cs4281_midi_release,
-};
-
-
-// --------------------------------------------------------------------- 
-
-// maximum number of devices 
-#define NR_DEVICE 8		// Only eight devices supported currently.
-
-// --------------------------------------------------------------------- 
-
-static struct initvol {
-	int mixch;
-	int vol;
-} initvol[] __devinitdata = {
-
-	{
-	SOUND_MIXER_WRITE_VOLUME, 0x4040}, {
-	SOUND_MIXER_WRITE_PCM, 0x4040}, {
-	SOUND_MIXER_WRITE_SYNTH, 0x4040}, {
-	SOUND_MIXER_WRITE_CD, 0x4040}, {
-	SOUND_MIXER_WRITE_LINE, 0x4040}, {
-	SOUND_MIXER_WRITE_LINE1, 0x4040}, {
-	SOUND_MIXER_WRITE_RECLEV, 0x0000}, {
-	SOUND_MIXER_WRITE_SPEAKER, 0x4040}, {
-	SOUND_MIXER_WRITE_MIC, 0x0000}
-};
-
-
-#ifndef NOT_CS4281_PM
-static void __devinit cs4281_BuildFIFO(
-	struct cs4281_pipeline *p, 
-	struct cs4281_state *s)
-{
-	switch(p->number)
-	{
-		case 0:  /* playback */
-		{
-			p->u32FCRnAddress  =  BA0_FCR0;
-			p->u32FSICnAddress = BA0_FSIC0;
-			p->u32FPDRnAddress = BA0_FPDR0;
-			break;
-		}
-		case 1:  /* capture */
-		{
-			p->u32FCRnAddress  =  BA0_FCR1;
-			p->u32FSICnAddress = BA0_FSIC1;
-			p->u32FPDRnAddress = BA0_FPDR1;
-			break;
-		}
-
-		case 2: 
-		{
-			p->u32FCRnAddress  =  BA0_FCR2;
-			p->u32FSICnAddress = BA0_FSIC2;
-			p->u32FPDRnAddress = BA0_FPDR2;
-			break;
-		}
-		case 3: 
-		{
-			p->u32FCRnAddress  =  BA0_FCR3;
-			p->u32FSICnAddress = BA0_FSIC3;
-			p->u32FPDRnAddress = BA0_FPDR3;
-			break;
-		}
-		default:
-			break;
-	}
-	//
-	// first read the hardware to initialize the member variables
-	//
-	p->u32FCRnValue = readl(s->pBA0 + p->u32FCRnAddress);
-	p->u32FSICnValue = readl(s->pBA0 + p->u32FSICnAddress);
-	p->u32FPDRnValue = readl(s->pBA0 + p->u32FPDRnAddress);
-
-}
-
-static void __devinit cs4281_BuildDMAengine(
-	struct cs4281_pipeline *p, 
-	struct cs4281_state *s)
-{
-/*
-* initialize all the addresses of this pipeline dma info.
-*/
-	switch(p->number)
-	{
-		case 0:  /* playback */
-		{
-			p->u32DBAnAddress = BA0_DBA0;
-			p->u32DCAnAddress = BA0_DCA0;
-			p->u32DBCnAddress = BA0_DBC0;
-			p->u32DCCnAddress = BA0_DCC0;
-			p->u32DMRnAddress = BA0_DMR0;
-			p->u32DCRnAddress = BA0_DCR0;
-			p->u32HDSRnAddress = BA0_HDSR0;
-			break;
-		}
-
-		case 1: /* capture */
-		{
-			p->u32DBAnAddress = BA0_DBA1;
-			p->u32DCAnAddress = BA0_DCA1;
-			p->u32DBCnAddress = BA0_DBC1;
-			p->u32DCCnAddress = BA0_DCC1;
-			p->u32DMRnAddress = BA0_DMR1;
-			p->u32DCRnAddress = BA0_DCR1;
-			p->u32HDSRnAddress = BA0_HDSR1;
-			break;
-		}
-
-		case 2:
-		{
-			p->u32DBAnAddress = BA0_DBA2;
-			p->u32DCAnAddress = BA0_DCA2;
-			p->u32DBCnAddress = BA0_DBC2;
-			p->u32DCCnAddress = BA0_DCC2;
-			p->u32DMRnAddress = BA0_DMR2;
-			p->u32DCRnAddress = BA0_DCR2;
-			p->u32HDSRnAddress = BA0_HDSR2;
-			break;
-		}
-
-		case 3:
-		{
-			p->u32DBAnAddress = BA0_DBA3;
-			p->u32DCAnAddress = BA0_DCA3;
-			p->u32DBCnAddress = BA0_DBC3;
-			p->u32DCCnAddress = BA0_DCC3;
-			p->u32DMRnAddress = BA0_DMR3;
-			p->u32DCRnAddress = BA0_DCR3;
-			p->u32HDSRnAddress = BA0_HDSR3;
-			break;
-		}
-		default:
-			break;
-	}
-
-//
-// Initialize the dma values for this pipeline
-//
-	p->u32DBAnValue = readl(s->pBA0 + p->u32DBAnAddress);
-	p->u32DBCnValue = readl(s->pBA0 + p->u32DBCnAddress);
-	p->u32DMRnValue = readl(s->pBA0 + p->u32DMRnAddress);
-	p->u32DCRnValue = readl(s->pBA0 + p->u32DCRnAddress);
-
-}
-
-static void __devinit cs4281_InitPM(struct cs4281_state *s)
-{
-	int i;
-	struct cs4281_pipeline *p;
-
-	for(i=0;i<CS4281_NUMBER_OF_PIPELINES;i++)
-	{
-		p = &s->pl[i];
-		p->number = i;
-		cs4281_BuildDMAengine(p,s);
-		cs4281_BuildFIFO(p,s);
-	/*
-	* currently only  2 pipelines are used
-	* so, only set the valid bit on the playback and capture.
-	*/
-		if( (i == CS4281_PLAYBACK_PIPELINE_NUMBER) || 
-			(i == CS4281_CAPTURE_PIPELINE_NUMBER))
-			p->flags |= CS4281_PIPELINE_VALID;
-	}
-	s->pm.u32SSPM_BITS = 0x7e;  /* rev c, use 0x7c for rev a or b */
-}
-#endif
-
-static int __devinit cs4281_probe(struct pci_dev *pcidev,
-				  const struct pci_device_id *pciid)
-{
-	struct cs4281_state *s;
-	dma_addr_t dma_mask;
-	mm_segment_t fs;
-	int i, val;
-	unsigned int temp1, temp2;
-
-	CS_DBGOUT(CS_FUNCTION | CS_INIT, 2,
-		  printk(KERN_INFO "cs4281: probe()+\n"));
-
-	if (pci_enable_device(pcidev)) {
-		CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR
-			 "cs4281: pci_enable_device() failed\n"));
-		return -1;
-	}
-	if (!(pci_resource_flags(pcidev, 0) & IORESOURCE_MEM) ||
-	    !(pci_resource_flags(pcidev, 1) & IORESOURCE_MEM)) {
-		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
-			 "cs4281: probe()- Memory region not assigned\n"));
-		return -ENODEV;
-	}
-	if (pcidev->irq == 0) {
-		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
-			 "cs4281: probe() IRQ not assigned\n"));
-		return -ENODEV;
-	}
-	dma_mask = 0xffffffff;	/* this enables playback and recording */
-	i = pci_set_dma_mask(pcidev, dma_mask);
-	if (i) {
-		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
-		      "cs4281: probe() architecture does not support 32bit PCI busmaster DMA\n"));
-		return i;
-	}
-	if (!(s = kmalloc(sizeof(struct cs4281_state), GFP_KERNEL))) {
-		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
-		      "cs4281: probe() no memory for state struct.\n"));
-		return -1;
-	}
-	memset(s, 0, sizeof(struct cs4281_state));
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac.wait);
-	init_waitqueue_head(&s->open_wait);
-	init_waitqueue_head(&s->open_wait_adc);
-	init_waitqueue_head(&s->open_wait_dac);
-	init_waitqueue_head(&s->midi.iwait);
-	init_waitqueue_head(&s->midi.owait);
-	mutex_init(&s->open_sem);
-	mutex_init(&s->open_sem_adc);
-	mutex_init(&s->open_sem_dac);
-	spin_lock_init(&s->lock);
-	s->pBA0phys = pci_resource_start(pcidev, 0);
-	s->pBA1phys = pci_resource_start(pcidev, 1);
-
-	/* Convert phys to linear. */
-	s->pBA0 = ioremap_nocache(s->pBA0phys, 4096);
-	if (!s->pBA0) {
-		CS_DBGOUT(CS_ERROR | CS_INIT, 1, printk(KERN_ERR
-			 "cs4281: BA0 I/O mapping failed. Skipping part.\n"));
-		goto err_free;
-	}
-	s->pBA1 = ioremap_nocache(s->pBA1phys, 65536);
-	if (!s->pBA1) {
-		CS_DBGOUT(CS_ERROR | CS_INIT, 1, printk(KERN_ERR
-			 "cs4281: BA1 I/O mapping failed. Skipping part.\n"));
-		goto err_unmap;
-	}
-
-	temp1 = readl(s->pBA0 + BA0_PCICFG00);
-	temp2 = readl(s->pBA0 + BA0_PCICFG04);
-
-	CS_DBGOUT(CS_INIT, 2,
-		  printk(KERN_INFO
-			 "cs4281: probe() BA0=0x%.8x BA1=0x%.8x pBA0=%p pBA1=%p \n",
-			 (unsigned) temp1, (unsigned) temp2, s->pBA0, s->pBA1));
-	CS_DBGOUT(CS_INIT, 2,
-		  printk(KERN_INFO
-			 "cs4281: probe() pBA0phys=0x%.8x pBA1phys=0x%.8x\n",
-			 (unsigned) s->pBA0phys, (unsigned) s->pBA1phys));
-
-#ifndef NOT_CS4281_PM
-	s->pm.flags = CS4281_PM_IDLE;
-#endif
-	temp1 = cs4281_hw_init(s);
-	if (temp1) {
-		CS_DBGOUT(CS_ERROR | CS_INIT, 1, printk(KERN_ERR
-			 "cs4281: cs4281_hw_init() failed. Skipping part.\n"));
-		goto err_irq;
-	}
-	s->magic = CS4281_MAGIC;
-	s->pcidev = pcidev;
-	s->irq = pcidev->irq;
-	if (request_irq
-	    (s->irq, cs4281_interrupt, IRQF_SHARED, "Crystal CS4281", s)) {
-		CS_DBGOUT(CS_INIT | CS_ERROR, 1,
-			  printk(KERN_ERR "cs4281: irq %u in use\n", s->irq));
-		goto err_irq;
-	}
-	if ((s->dev_audio = register_sound_dsp(&cs4281_audio_fops, -1)) <
-	    0) {
-		CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR
-			 "cs4281: probe() register_sound_dsp() failed.\n"));
-		goto err_dev1;
-	}
-	if ((s->dev_mixer = register_sound_mixer(&cs4281_mixer_fops, -1)) <
-	    0) {
-		CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR
-			 "cs4281: probe() register_sound_mixer() failed.\n"));
-		goto err_dev2;
-	}
-	if ((s->dev_midi = register_sound_midi(&cs4281_midi_fops, -1)) < 0) {
-		CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR
-			 "cs4281: probe() register_sound_midi() failed.\n"));
-		goto err_dev3;
-	}
-#ifndef NOT_CS4281_PM
-	cs4281_InitPM(s);
-	s->pm.flags |= CS4281_PM_NOT_REGISTERED;
-#endif
-
-	pci_set_master(pcidev);	// enable bus mastering 
-
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	val = SOUND_MASK_LINE;
-	mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long) &val);
-	for (i = 0; i < sizeof(initvol) / sizeof(initvol[0]); i++) {
-		val = initvol[i].vol;
-		mixer_ioctl(s, initvol[i].mixch, (unsigned long) &val);
-	}
-	val = 1;		// enable mic preamp 
-	mixer_ioctl(s, SOUND_MIXER_PRIVATE1, (unsigned long) &val);
-	set_fs(fs);
-
-	pci_set_drvdata(pcidev, s);
-	list_add(&s->list, &cs4281_devs);
-	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2, printk(KERN_INFO
-		"cs4281: probe()- device allocated successfully\n"));
-	return 0;
-
-      err_dev3:
-	unregister_sound_mixer(s->dev_mixer);
-      err_dev2:
-	unregister_sound_dsp(s->dev_audio);
-      err_dev1:
-	free_irq(s->irq, s);
-      err_irq:
-	iounmap(s->pBA1);
-      err_unmap:
-	iounmap(s->pBA0);
-      err_free:
-	kfree(s);
-
-	CS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_INFO
-		"cs4281: probe()- no device allocated\n"));
-	return -ENODEV;
-} // probe_cs4281
-
-
-// --------------------------------------------------------------------- 
-
-static void __devexit cs4281_remove(struct pci_dev *pci_dev)
-{
-	struct cs4281_state *s = pci_get_drvdata(pci_dev);
-	// stop DMA controller 
-	synchronize_irq(s->irq);
-	free_irq(s->irq, s);
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->dev_mixer);
-	unregister_sound_midi(s->dev_midi);
-	iounmap(s->pBA1);
-	iounmap(s->pBA0);
-	pci_set_drvdata(pci_dev,NULL);
-	list_del(&s->list);
-	kfree(s);
-	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2, printk(KERN_INFO
-		 "cs4281: cs4281_remove()-: remove successful\n"));
-}
-
-static struct pci_device_id cs4281_pci_tbl[] = {
-	{
-		.vendor    = PCI_VENDOR_ID_CIRRUS,
-		.device    = PCI_DEVICE_ID_CRYSTAL_CS4281,
-		.subvendor = PCI_ANY_ID,
-		.subdevice = PCI_ANY_ID,
-	},
-	{ 0, },
-};
-
-MODULE_DEVICE_TABLE(pci, cs4281_pci_tbl);
-
-static struct pci_driver cs4281_pci_driver = {
-	.name	  = "cs4281",
-	.id_table = cs4281_pci_tbl,
-	.probe	  = cs4281_probe,
-	.remove	  = __devexit_p(cs4281_remove),
-	.suspend  = CS4281_SUSPEND_TBL,
-	.resume	  = CS4281_RESUME_TBL,
-};
-
-static int __init cs4281_init_module(void)
-{
-	int rtn = 0;
-	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2, printk(KERN_INFO 
-		"cs4281: cs4281_init_module()+ \n"));
-	printk(KERN_INFO "cs4281: version v%d.%02d.%d time " __TIME__ " "
-	       __DATE__ "\n", CS4281_MAJOR_VERSION, CS4281_MINOR_VERSION,
-	       CS4281_ARCH);
-	rtn = pci_register_driver(&cs4281_pci_driver);
-
-	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: cs4281_init_module()- (%d)\n",rtn));
-	return rtn;
-}
-
-static void __exit cs4281_cleanup_module(void)
-{
-	pci_unregister_driver(&cs4281_pci_driver);
-	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2,
-		  printk(KERN_INFO "cs4281: cleanup_cs4281() finished\n"));
-}
-// --------------------------------------------------------------------- 
-
-MODULE_AUTHOR("gw boynton, audio@crystal.cirrus.com");
-MODULE_DESCRIPTION("Cirrus Logic CS4281 Driver");
-MODULE_LICENSE("GPL");
-
-// --------------------------------------------------------------------- 
-
-module_init(cs4281_init_module);
-module_exit(cs4281_cleanup_module);
-
--- linux-2.6.18.noarch/sound/oss/cs4281/cs4281_wrapper-24.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4281/cs4281_wrapper-24.c	2007-06-05 17:44:20.000000000 -0400
@@ -1,41 +0,0 @@
-/*******************************************************************************
-*
-*      "cs4281_wrapper.c" --  Cirrus Logic-Crystal CS4281 linux audio driver.
-*
-*      Copyright (C) 2000,2001  Cirrus Logic Corp.  
-*            -- tom woller (twoller@crystal.cirrus.com) or
-*               (audio@crystal.cirrus.com).
-*
-*      This program is free software; you can redistribute it and/or modify
-*      it under the terms of the GNU General Public License as published by
-*      the Free Software Foundation; either version 2 of the License, or
-*      (at your option) any later version.
-*
-*      This program is distributed in the hope that it will be useful,
-*      but WITHOUT ANY WARRANTY; without even the implied warranty of
-*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*      GNU General Public License for more details.
-*
-*      You should have received a copy of the GNU General Public License
-*      along with this program; if not, write to the Free Software
-*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-* 12/20/00 trw - new file. 
-*
-*******************************************************************************/
-
-#include <linux/spinlock.h>
-
-static int cs4281_resume_null(struct pci_dev *pcidev) { return 0; }
-static int cs4281_suspend_null(struct pci_dev *pcidev, pm_message_t state) { return 0; }
-
-#define free_dmabuf(state, dmabuf) \
-	pci_free_consistent(state->pcidev, \
-			    PAGE_SIZE << (dmabuf)->buforder, \
-			    (dmabuf)->rawbuf, (dmabuf)->dmaaddr);
-#define free_dmabuf2(state, dmabuf) \
-	pci_free_consistent((state)->pcidev, \
-				    PAGE_SIZE << (state)->buforder_tmpbuff, \
-				    (state)->tmpbuff, (state)->dmaaddr_tmpbuff);
-#define cs4x_pgoff(vma) ((vma)->vm_pgoff)
-
--- linux-2.6.18.noarch/sound/oss/cs4281/cs4281pm-24.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4281/cs4281pm-24.c	2007-06-05 17:44:20.000000000 -0400
@@ -1,45 +0,0 @@
-/*******************************************************************************
-*
-*      "cs4281pm.c" --  Cirrus Logic-Crystal CS4281 linux audio driver.
-*
-*      Copyright (C) 2000,2001  Cirrus Logic Corp.  
-*            -- tom woller (twoller@crystal.cirrus.com) or
-*               (audio@crystal.cirrus.com).
-*
-*      This program is free software; you can redistribute it and/or modify
-*      it under the terms of the GNU General Public License as published by
-*      the Free Software Foundation; either version 2 of the License, or
-*      (at your option) any later version.
-*
-*      This program is distributed in the hope that it will be useful,
-*      but WITHOUT ANY WARRANTY; without even the implied warranty of
-*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*      GNU General Public License for more details.
-*
-*      You should have received a copy of the GNU General Public License
-*      along with this program; if not, write to the Free Software
-*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-* 12/22/00 trw - new file. 
-*
-*******************************************************************************/
-
-#ifndef NOT_CS4281_PM
-#include <linux/pm.h>
-
-static int cs4281_suspend(struct cs4281_state *s);
-static int cs4281_resume(struct cs4281_state *s);
-/* 
-* for now (12/22/00) only enable the pm_register PM support.
-* allow these table entries to be null.
-#define CS4281_SUSPEND_TBL cs4281_suspend_tbl
-#define CS4281_RESUME_TBL cs4281_resume_tbl
-*/
-#define CS4281_SUSPEND_TBL cs4281_suspend_null
-#define CS4281_RESUME_TBL cs4281_resume_null
-
-#else /* CS4281_PM */
-#define CS4281_SUSPEND_TBL cs4281_suspend_null
-#define CS4281_RESUME_TBL cs4281_resume_null
-#endif /* CS4281_PM */
-
--- linux-2.6.18.noarch/sound/oss/cs4281/cs4281pm.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/cs4281/cs4281pm.h	2007-06-05 17:44:20.000000000 -0400
@@ -1,74 +0,0 @@
-#ifndef NOT_CS4281_PM
-/*******************************************************************************
-*
-*      "cs4281pm.h" --  Cirrus Logic-Crystal CS4281 linux audio driver.
-*
-*      Copyright (C) 2000,2001  Cirrus Logic Corp.  
-*            -- tom woller (twoller@crystal.cirrus.com) or
-*               (audio@crystal.cirrus.com).
-*
-*      This program is free software; you can redistribute it and/or modify
-*      it under the terms of the GNU General Public License as published by
-*      the Free Software Foundation; either version 2 of the License, or
-*      (at your option) any later version.
-*
-*      This program is distributed in the hope that it will be useful,
-*      but WITHOUT ANY WARRANTY; without even the implied warranty of
-*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*      GNU General Public License for more details.
-*
-*      You should have received a copy of the GNU General Public License
-*      along with this program; if not, write to the Free Software
-*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-* 12/22/00 trw - new file. 
-*
-*******************************************************************************/
-/* general pm definitions */
-#define CS4281_AC97_HIGHESTREGTORESTORE 0x26
-#define CS4281_AC97_NUMBER_RESTORE_REGS (CS4281_AC97_HIGHESTREGTORESTORE/2-1)
-
-/* pipeline definitions */
-#define CS4281_NUMBER_OF_PIPELINES 	4
-#define CS4281_PIPELINE_VALID 		0x0001
-#define CS4281_PLAYBACK_PIPELINE_NUMBER	0x0000
-#define CS4281_CAPTURE_PIPELINE_NUMBER 	0x0001
-
-/* PM state defintions */
-#define CS4281_PM_NOT_REGISTERED	0x1000
-#define CS4281_PM_IDLE			0x0001
-#define CS4281_PM_SUSPENDING		0x0002
-#define CS4281_PM_SUSPENDED		0x0004
-#define CS4281_PM_RESUMING		0x0008
-#define CS4281_PM_RESUMED		0x0010
-
-struct cs4281_pm {
-	unsigned long flags;
-	u32 u32CLKCR1_SAVE,u32SSPMValue,u32PPLVCvalue,u32PPRVCvalue;
-	u32 u32FMLVCvalue,u32FMRVCvalue,u32GPIORvalue,u32JSCTLvalue,u32SSCR;
-	u32 u32SRCSA,u32DacASR,u32AdcASR,u32DacSR,u32AdcSR,u32MIDCR_Save;
-	u32 u32SSPM_BITS;
-	u32 ac97[CS4281_AC97_NUMBER_RESTORE_REGS];
-	u32 u32AC97_master_volume, u32AC97_headphone_volume, u32AC97_master_volume_mono;
-	u32 u32AC97_pcm_out_volume, u32AC97_powerdown, u32AC97_general_purpose;
-	u32 u32hwptr_playback,u32hwptr_capture;
-};
-
-struct cs4281_pipeline {
-	unsigned flags;
-	unsigned number;
-	u32 u32DBAnValue,u32DBCnValue,u32DMRnValue,u32DCRnValue;
-	u32 u32DBAnAddress,u32DCAnAddress,u32DBCnAddress,u32DCCnAddress;
-	u32 u32DMRnAddress,u32DCRnAddress,u32HDSRnAddress;
-	u32 u32DBAn_Save,u32DBCn_Save,u32DMRn_Save,u32DCRn_Save;
-	u32 u32DCCn_Save,u32DCAn_Save;
-/* 
-* technically, these are fifo variables, but just map the 
-* first fifo with the first pipeline and then use the fifo
-* variables inside of the pipeline struct.
-*/
-	u32 u32FCRn_Save,u32FSICn_Save;
-	u32 u32FCRnValue,u32FCRnAddress,u32FSICnValue,u32FSICnAddress;
-	u32 u32FPDRnValue,u32FPDRnAddress;
-};
-#endif
--- linux-2.6.18.noarch/sound/oss/ac97_codec.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ac97_codec.c	2007-06-05 17:44:14.000000000 -0400
@@ -744,11 +744,10 @@
  
 struct ac97_codec *ac97_alloc_codec(void)
 {
-	struct ac97_codec *codec = kmalloc(sizeof(struct ac97_codec), GFP_KERNEL);
+	struct ac97_codec *codec = kzalloc(sizeof(struct ac97_codec), GFP_KERNEL);
 	if(!codec)
 		return NULL;
 
-	memset(codec, 0, sizeof(*codec));
 	spin_lock_init(&codec->lock);
 	INIT_LIST_HEAD(&codec->list);
 	return codec;
@@ -1399,95 +1398,6 @@
 
 EXPORT_SYMBOL(ac97_set_adc_rate);
 
-int ac97_save_state(struct ac97_codec *codec)
-{
-	return 0;	
-}
-
-EXPORT_SYMBOL(ac97_save_state);
-
-int ac97_restore_state(struct ac97_codec *codec)
-{
-	int i;
-	unsigned int left, right, val;
-
-	for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-		if (!supported_mixer(codec, i)) 
-			continue;
-
-		val = codec->mixer_state[i];
-		right = val >> 8;
-		left = val  & 0xff;
-		codec->write_mixer(codec, i, left, right);
-	}
-	return 0;
-}
-
-EXPORT_SYMBOL(ac97_restore_state);
-
-/**
- *	ac97_register_driver	-	register a codec helper
- *	@driver: Driver handler
- *
- *	Register a handler for codecs matching the codec id. The handler
- *	attach function is called for all present codecs and will be 
- *	called when new codecs are discovered.
- */
- 
-int ac97_register_driver(struct ac97_driver *driver)
-{
-	struct list_head *l;
-	struct ac97_codec *c;
-	
-	mutex_lock(&codec_mutex);
-	INIT_LIST_HEAD(&driver->list);
-	list_add(&driver->list, &codec_drivers);
-	
-	list_for_each(l, &codecs)
-	{
-		c = list_entry(l, struct ac97_codec, list);
-		if(c->driver != NULL || ((c->model ^ driver->codec_id) & driver->codec_mask))
-			continue;
-		if(driver->probe(c, driver))
-			continue;
-		c->driver = driver;
-	}
-	mutex_unlock(&codec_mutex);
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(ac97_register_driver);
-
-/**
- *	ac97_unregister_driver	-	unregister a codec helper
- *	@driver: Driver handler
- *
- *	Unregister a handler for codecs matching the codec id. The handler
- *	remove function is called for all matching codecs.
- */
- 
-void ac97_unregister_driver(struct ac97_driver *driver)
-{
-	struct list_head *l;
-	struct ac97_codec *c;
-	
-	mutex_lock(&codec_mutex);
-	list_del_init(&driver->list);
-
-	list_for_each(l, &codecs)
-	{
-		c = list_entry(l, struct ac97_codec, list);
-		if (c->driver == driver) {
-			driver->remove(c, driver);
-			c->driver = NULL;
-		}
-	}
-	
-	mutex_unlock(&codec_mutex);
-}
-
-EXPORT_SYMBOL_GPL(ac97_unregister_driver);
-
 static int swap_headphone(int remove_master)
 {
 	struct list_head *l;
--- linux-2.6.18.noarch/sound/oss/sb_card.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sb_card.c	2007-06-05 17:44:14.000000000 -0400
@@ -137,11 +137,10 @@
 {
 	struct sb_module_options sbmo = {0};
 
-	if((legacy = kmalloc(sizeof(struct sb_card_config), GFP_KERNEL)) == NULL) {
+	if((legacy = kzalloc(sizeof(struct sb_card_config), GFP_KERNEL)) == NULL) {
 		printk(KERN_ERR "sb: Error: Could not allocate memory\n");
 		return -ENOMEM;
 	}
-	memset(legacy, 0, sizeof(struct sb_card_config));
 
 	legacy->conf.io_base      = io;
 	legacy->conf.irq          = irq;
@@ -237,7 +236,7 @@
 static unsigned int sb_pnp_devices;
 
 /* Probe callback function for the PnP API */
-static int __devinit sb_pnp_probe(struct pnp_card_link *card, const struct pnp_card_device_id *card_id)
+static int sb_pnp_probe(struct pnp_card_link *card, const struct pnp_card_device_id *card_id)
 {
 	struct sb_card_config *scc;
 	struct sb_module_options sbmo = {0}; /* Default to 0 for PnP */
@@ -247,11 +246,10 @@
 		return -EBUSY;
 	}
 
-	if((scc = kmalloc(sizeof(struct sb_card_config), GFP_KERNEL)) == NULL) {
+	if((scc = kzalloc(sizeof(struct sb_card_config), GFP_KERNEL)) == NULL) {
 		printk(KERN_ERR "sb: Error: Could not allocate memory\n");
 		return -ENOMEM;
 	}
-	memset(scc, 0, sizeof(struct sb_card_config));
 
 	printk(KERN_INFO "sb: PnP: Found Card Named = \"%s\", Card PnP id = " \
 	       "%s, Device PnP id = %s\n", card->card->name, card_id->id,
@@ -271,7 +269,7 @@
 	return sb_register_oss(scc, &sbmo);
 }
 
-static void __devexit sb_pnp_remove(struct pnp_card_link *card)
+static void sb_pnp_remove(struct pnp_card_link *card)
 {
 	struct sb_card_config *scc = pnp_get_card_drvdata(card);
 
@@ -287,7 +285,7 @@
 	.name          = "OSS SndBlstr", /* 16 character limit */
 	.id_table      = sb_pnp_card_table,
 	.probe         = sb_pnp_probe,
-	.remove        = __devexit_p( sb_pnp_remove),
+	.remove        = sb_pnp_remove,
 };
 MODULE_DEVICE_TABLE(pnp_card, sb_pnp_card_table);
 #endif /* CONFIG_PNP */
--- linux-2.6.18.noarch/sound/oss/v_midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/v_midi.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/v_midi.c
+ * sound/oss/v_midi.c
  *
  * The low level driver for the Sound Blaster DS chips.
  *
@@ -183,7 +183,7 @@
 		return;
 	}
 	
-	m=(struct vmidi_memory *)kmalloc(sizeof(struct vmidi_memory), GFP_KERNEL);
+	m = kmalloc(sizeof(struct vmidi_memory), GFP_KERNEL);
 	if (m == NULL)
 	{
 		printk(KERN_WARNING "Loopback MIDI: Failed to allocate memory\n");
--- linux-2.6.18.noarch/sound/oss/ad1816.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ad1816.c	2007-06-05 17:44:14.000000000 -0400
@@ -521,7 +521,7 @@
 /* Interrupt handler */
 
 
-static irqreturn_t ad1816_interrupt (int irq, void *dev_id, struct pt_regs *dummy)
+static irqreturn_t ad1816_interrupt (int irq, void *dev_id)
 {
 	unsigned char	status;
 	ad1816_info	*devc = (ad1816_info *)dev_id;
--- linux-2.6.18.noarch/sound/oss/kahlua.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/kahlua.c	2007-06-05 17:44:14.000000000 -0400
@@ -139,13 +139,12 @@
 	printk(KERN_INFO "kahlua: XpressAudio on IRQ %d, DMA %d, %d\n",
 		irq, dma8, dma16);
 	
-	hw_config = kmalloc(sizeof(struct address_info), GFP_KERNEL);
+	hw_config = kzalloc(sizeof(struct address_info), GFP_KERNEL);
 	if(hw_config == NULL)
 	{
 		printk(KERN_ERR "kahlua: out of memory.\n");
 		return 1;
 	}
-	memset(hw_config, 0, sizeof(*hw_config));
 	
 	pci_set_drvdata(pdev, hw_config);
 	
--- linux-2.6.18.noarch/sound/oss/wf_midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/wf_midi.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,880 +0,0 @@
-/*
- * sound/wf_midi.c
- *
- * The low level driver for the WaveFront ICS2115 MIDI interface(s)
- * Note that there is also an MPU-401 emulation (actually, a UART-401
- * emulation) on the CS4232 on the Tropez Plus. This code has nothing
- * to do with that interface at all.
- *
- * The interface is essentially just a UART-401, but is has the
- * interesting property of supporting what Turtle Beach called
- * "Virtual MIDI" mode. In this mode, there are effectively *two*
- * MIDI buses accessible via the interface, one that is routed
- * solely to/from the external WaveFront synthesizer and the other
- * corresponding to the pin/socket connector used to link external
- * MIDI devices to the board.
- *
- * This driver fully supports this mode, allowing two distinct
- * midi devices (/dev/midiNN and /dev/midiNN+1) to be used
- * completely independently, giving 32 channels of MIDI routing,
- * 16 to the WaveFront synth and 16 to the external MIDI bus.
- *
- * Switching between the two is accomplished externally by the driver
- * using the two otherwise unused MIDI bytes. See the code for more details.
- *
- * NOTE: VIRTUAL MIDI MODE IS ON BY DEFAULT (see wavefront.c)
- *
- * The main reason to turn off Virtual MIDI mode is when you want to
- * tightly couple the WaveFront synth with an external MIDI
- * device. You won't be able to distinguish the source of any MIDI
- * data except via SysEx ID, but thats probably OK, since for the most
- * part, the WaveFront won't be sending any MIDI data at all.
- *  
- * The main reason to turn on Virtual MIDI Mode is to provide two
- * completely independent 16-channel MIDI buses, one to the
- * WaveFront and one to any external MIDI devices. Given the 32
- * voice nature of the WaveFront, its pretty easy to find a use
- * for all 16 channels driving just that synth.
- *
- */
-
-/*
- * Copyright (C) by Paul Barton-Davis 1998
- * Some portions of this file are derived from work that is:
- *
- *    CopyriGht (C) by Hannu Savolainen 1993-1996
- *
- * USS/Lite for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- */
-
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include "sound_config.h"
-
-#include <linux/wavefront.h>
-
-#ifdef MODULE
-
-struct wf_mpu_config {
-	int             base;
-#define	DATAPORT(d)   (d)->base
-#define	COMDPORT(d)   (d)->base+1
-#define	STATPORT(d)   (d)->base+1
-
-	int             irq;
-	int             opened;
-	int             devno;
-	int             synthno;
-	int             mode;
-#define MODE_MIDI	1
-#define MODE_SYNTH	2
-
-	void            (*inputintr) (int dev, unsigned char data);
-	char isvirtual;                /* do virtual I/O stuff */
-};
-
-static struct wf_mpu_config  devs[2];
-static struct wf_mpu_config *phys_dev = &devs[0];
-static struct wf_mpu_config *virt_dev = &devs[1];
-
-static void start_uart_mode (void);
-static DEFINE_SPINLOCK(lock);
-
-#define	OUTPUT_READY	0x40
-#define	INPUT_AVAIL	0x80
-#define	MPU_ACK		0xFE
-#define	UART_MODE_ON	0x3F
-
-static inline int wf_mpu_status (void)
-{
-	return inb (STATPORT (phys_dev));
-}
-
-static inline int input_avail (void)
-{
-	return !(wf_mpu_status() & INPUT_AVAIL);
-}
-
-static inline int output_ready (void)
-{
-	return !(wf_mpu_status() & OUTPUT_READY);
-}
-
-static inline int  read_data (void)
-{
-	return inb (DATAPORT (phys_dev));
-}
-
-static inline void write_data (unsigned char byte)
-{
-	outb (byte, DATAPORT (phys_dev));
-}
-
-/*
- * States for the input scanner (should be in dev_table.h)
- */
-
-#define MST_SYSMSG		100	/* System message (sysx etc). */
-#define MST_MTC			102	/* Midi Time Code (MTC) qframe msg */
-#define MST_SONGSEL		103	/* Song select */
-#define MST_SONGPOS		104	/* Song position pointer */
-#define MST_TIMED		105	/* Leading timing byte rcvd */
-
-/* buffer space check for input scanner */
-
-#define BUFTEST(mi) if (mi->m_ptr >= MI_MAX || mi->m_ptr < 0) \
-{printk(KERN_ERR "WF-MPU: Invalid buffer pointer %d/%d, s=%d\n", \
-	mi->m_ptr, mi->m_left, mi->m_state);mi->m_ptr--;}
-
-static unsigned char len_tab[] =	/* # of data bytes following a status
-					 */
-{
-	2,				/* 8x */
-	2,				/* 9x */
-	2,				/* Ax */
-	2,				/* Bx */
-	1,				/* Cx */
-	1,				/* Dx */
-	2,				/* Ex */
-	0				/* Fx */
-};
-
-static int
-wf_mpu_input_scanner (int devno, int synthdev, unsigned char midic)
-
-{
-	struct midi_input_info *mi = &midi_devs[devno]->in_info;
-
-	switch (mi->m_state) {
-	case MST_INIT:
-		switch (midic) {
-		case 0xf8:
-			/* Timer overflow */
-			break;
-		
-		case 0xfc:
-			break;
-		
-		case 0xfd:
-			/* XXX do something useful with this. If there is
-			   an external MIDI timer (e.g. a hardware sequencer,
-			   a useful timer can be derived ...
-		   
-			   For now, no timer support.
-			*/
-			break;
-		
-		case 0xfe:
-			return MPU_ACK;
-			break;
-		
-		case 0xf0:
-		case 0xf1:
-		case 0xf2:
-		case 0xf3:
-		case 0xf4:
-		case 0xf5:
-		case 0xf6:
-		case 0xf7:
-			break;
-		
-		case 0xf9:
-			break;
-		
-		case 0xff:
-			mi->m_state = MST_SYSMSG;
-			break;
-		
-		default:
-			if (midic <= 0xef) {
-				mi->m_state = MST_TIMED;
-			}
-			else
-				printk (KERN_ERR "<MPU: Unknown event %02x> ",
-					midic);
-		}
-		break;
-	  
-	case MST_TIMED:
-	{
-		int             msg = ((int) (midic & 0xf0) >> 4);
-	  
-		mi->m_state = MST_DATA;
-	  
-		if (msg < 8) {	/* Data byte */
-	      
-			msg = ((int) (mi->m_prev_status & 0xf0) >> 4);
-			msg -= 8;
-			mi->m_left = len_tab[msg] - 1;
-	      
-			mi->m_ptr = 2;
-			mi->m_buf[0] = mi->m_prev_status;
-			mi->m_buf[1] = midic;
-
-			if (mi->m_left <= 0) {
-				mi->m_state = MST_INIT;
-				do_midi_msg (synthdev, mi->m_buf, mi->m_ptr);
-				mi->m_ptr = 0;
-			}
-		} else if (msg == 0xf) {	/* MPU MARK */
-	      
-			mi->m_state = MST_INIT;
-
-			switch (midic) {
-			case 0xf8:
-				break;
-		    
-			case 0xf9:
-				break;
-		    
-			case 0xfc:
-				break;
-		    
-			default:
-				break;
-			}
-		} else {
-			mi->m_prev_status = midic;
-			msg -= 8;
-			mi->m_left = len_tab[msg];
-	      
-			mi->m_ptr = 1;
-			mi->m_buf[0] = midic;
-	      
-			if (mi->m_left <= 0) {
-				mi->m_state = MST_INIT;
-				do_midi_msg (synthdev, mi->m_buf, mi->m_ptr);
-				mi->m_ptr = 0;
-			}
-		}
-	}
-	break;
-
-	case MST_SYSMSG:
-		switch (midic) {
-		case 0xf0:
-			mi->m_state = MST_SYSEX;
-			break;
-	    
-		case 0xf1:
-			mi->m_state = MST_MTC;
-			break;
-
-		case 0xf2:
-			mi->m_state = MST_SONGPOS;
-			mi->m_ptr = 0;
-			break;
-	    
-		case 0xf3:
-			mi->m_state = MST_SONGSEL;
-			break;
-	    
-		case 0xf6:
-			mi->m_state = MST_INIT;
-	    
-			/*
-			 *    Real time messages
-			 */
-		case 0xf8:
-			/* midi clock */
-			mi->m_state = MST_INIT;
-			/* XXX need ext MIDI timer support */
-			break;
-	    
-		case 0xfA:
-			mi->m_state = MST_INIT;
-			/* XXX need ext MIDI timer support */
-			break;
-	    
-		case 0xFB:
-			mi->m_state = MST_INIT;
-			/* XXX need ext MIDI timer support */
-			break;
-	    
-		case 0xFC:
-			mi->m_state = MST_INIT;
-			/* XXX need ext MIDI timer support */
-			break;
-	    
-		case 0xFE:
-			/* active sensing */
-			mi->m_state = MST_INIT;
-			break;
-	    
-		case 0xff:
-			mi->m_state = MST_INIT;
-			break;
-
-		default:
-			printk (KERN_ERR "unknown MIDI sysmsg %0x\n", midic);
-			mi->m_state = MST_INIT;
-		}
-		break;
-
-	case MST_MTC:
-		mi->m_state = MST_INIT;
-		break;
-
-	case MST_SYSEX:
-		if (midic == 0xf7) {
-			mi->m_state = MST_INIT;
-		} else {
-			/* XXX fix me */
-		}
-		break;
-
-	case MST_SONGPOS:
-		BUFTEST (mi);
-		mi->m_buf[mi->m_ptr++] = midic;
-		if (mi->m_ptr == 2) {
-			mi->m_state = MST_INIT;
-			mi->m_ptr = 0;
-			/* XXX need ext MIDI timer support */
-		}
-		break;
-
-	case MST_DATA:
-		BUFTEST (mi);
-		mi->m_buf[mi->m_ptr++] = midic;
-		if ((--mi->m_left) <= 0) {
-			mi->m_state = MST_INIT;
-			do_midi_msg (synthdev, mi->m_buf, mi->m_ptr);
-			mi->m_ptr = 0;
-		}
-		break;
-
-	default:
-		printk (KERN_ERR "Bad state %d ", mi->m_state);
-		mi->m_state = MST_INIT;
-	}
-
-	return 1;
-}
-
-static irqreturn_t
-wf_mpuintr(int irq, void *dev_id, struct pt_regs *dummy)
-
-{
-	struct wf_mpu_config *physical_dev = dev_id;
-	static struct wf_mpu_config *input_dev;
-	struct midi_input_info *mi = &midi_devs[physical_dev->devno]->in_info;
-	int n;
-
-	if (!input_avail()) { /* not for us */
-		return IRQ_NONE;
-	}
-
-	if (mi->m_busy)
-		return IRQ_HANDLED;
-	spin_lock(&lock);
-	mi->m_busy = 1;
-
-	if (!input_dev) {
-		input_dev = physical_dev;
-	}
-
-	n = 50; /* XXX why ? */
-
-	do {
-		unsigned char c = read_data ();
-      
-		if (phys_dev->isvirtual) {
-
-			if (c == WF_EXTERNAL_SWITCH) {
-				input_dev = virt_dev;
-				continue;
-			} else if (c == WF_INTERNAL_SWITCH) { 
-				input_dev = phys_dev;
-				continue;
-			} /* else just leave it as it is */
-
-		} else {
-			input_dev = phys_dev;
-		}
-
-		if (input_dev->mode == MODE_SYNTH) {
-	  
-			wf_mpu_input_scanner (input_dev->devno,
-					      input_dev->synthno, c);
-	  
-		} else if (input_dev->opened & OPEN_READ) {
-	  
-			if (input_dev->inputintr) {
-				input_dev->inputintr (input_dev->devno, c);
-			} 
-		}
-
-	} while (input_avail() && n-- > 0);
-
-	mi->m_busy = 0;
-	spin_unlock(&lock);
-	return IRQ_HANDLED;
-}
-
-static int
-wf_mpu_open (int dev, int mode,
-	     void            (*input) (int dev, unsigned char data),
-	     void            (*output) (int dev)
-	)
-{
-	struct wf_mpu_config *devc;
-
-	if (dev < 0 || dev >= num_midis || midi_devs[dev]==NULL)
-		return -(ENXIO);
-
-	if (phys_dev->devno == dev) {
-		devc = phys_dev;
-	} else if (phys_dev->isvirtual && virt_dev->devno == dev) {
-		devc = virt_dev;
-	} else {
-		printk (KERN_ERR "WF-MPU: unknown device number %d\n", dev);
-		return -(EINVAL);
-	}
-
-	if (devc->opened) {
-		return -(EBUSY);
-	}
-
-	devc->mode = MODE_MIDI;
-	devc->opened = mode;
-	devc->synthno = 0;
-
-	devc->inputintr = input;
-	return 0;
-}
- 
-static void
-wf_mpu_close (int dev)
-{
-	struct wf_mpu_config *devc;
-
-	if (dev < 0 || dev >= num_midis || midi_devs[dev]==NULL)
-		return;
-
-	if (phys_dev->devno == dev) {
-		devc = phys_dev;
-	} else if (phys_dev->isvirtual && virt_dev->devno == dev) {
-		devc = virt_dev;
-	} else {
-		printk (KERN_ERR "WF-MPU: unknown device number %d\n", dev);
-		return;
-	}
-
-	devc->mode = 0;
-	devc->inputintr = NULL;
-	devc->opened = 0;
-}
-
-static int
-wf_mpu_out (int dev, unsigned char midi_byte)
-{
-	int             timeout;
-	unsigned long   flags;
-	static int lastoutdev = -1;
-	unsigned char switchch;
-
-	if (phys_dev->isvirtual && lastoutdev != dev) {
-      
-		if (dev == phys_dev->devno) { 
-			switchch = WF_INTERNAL_SWITCH;
-		} else if (dev == virt_dev->devno) { 
-			switchch = WF_EXTERNAL_SWITCH;
-		} else {
-			printk (KERN_ERR "WF-MPU: bad device number %d", dev);
-			return (0);
-		}
-
-		/* XXX fix me */
-      
-		for (timeout = 30000; timeout > 0 && !output_ready ();
-		     timeout--);
-      
-		spin_lock_irqsave(&lock,flags);
-      
-		if (!output_ready ()) {
-			printk (KERN_WARNING "WF-MPU: Send switch "
-				"byte timeout\n");
-			spin_unlock_irqrestore(&lock,flags);
-			return 0;
-		}
-      
-		write_data (switchch);
-		spin_unlock_irqrestore(&lock,flags);
-	} 
-
-	lastoutdev = dev;
-
-	/*
-	 * Sometimes it takes about 30000 loops before the output becomes ready
-	 * (After reset). Normally it takes just about 10 loops.
-	 */
-
-	/* XXX fix me */
-
-	for (timeout = 30000; timeout > 0 && !output_ready (); timeout--);
-
-	spin_lock_irqsave(&lock,flags);
-	if (!output_ready ()) {
-		spin_unlock_irqrestore(&lock,flags);
-		printk (KERN_WARNING "WF-MPU: Send data timeout\n");
-		return 0;
-	}
-
-	write_data (midi_byte);
-	spin_unlock_irqrestore(&lock,flags);
-
-	return 1;
-}
-
-static inline int wf_mpu_start_read (int dev) {
-	return 0;
-}
-
-static inline int wf_mpu_end_read (int dev) {
-	return 0;
-}
-
-static int wf_mpu_ioctl (int dev, unsigned cmd, void __user *arg)
-{
-	printk (KERN_WARNING
-		"WF-MPU: Intelligent mode not supported by hardware.\n");
-	return -(EINVAL);
-}
-
-static int wf_mpu_buffer_status (int dev)
-{
-	return 0;
-}
-
-static struct synth_operations wf_mpu_synth_operations[2];
-static struct midi_operations  wf_mpu_midi_operations[2];
-
-static struct midi_operations wf_mpu_midi_proto =
-{
-	.owner		= THIS_MODULE,
-	.info		= {"WF-MPU MIDI", 0, MIDI_CAP_MPU401, SNDCARD_MPU401},
-	.in_info	= {0},   /* in_info */
-	.open		= wf_mpu_open,
-	.close		= wf_mpu_close,
-	.ioctl		= wf_mpu_ioctl,
-	.outputc	= wf_mpu_out,
-	.start_read	= wf_mpu_start_read,
-	.end_read	= wf_mpu_end_read,
-	.buffer_status	= wf_mpu_buffer_status,
-};
-
-static struct synth_info wf_mpu_synth_info_proto =
-{"WaveFront MPU-401 interface", 0,
- SYNTH_TYPE_MIDI, MIDI_TYPE_MPU401, 0, 128, 0, 128, SYNTH_CAP_INPUT};
-
-static struct synth_info wf_mpu_synth_info[2];
-
-static int
-wf_mpu_synth_ioctl (int dev, unsigned int cmd, void __user *arg)
-{
-	int             midi_dev;
-	int index;
-
-	midi_dev = synth_devs[dev]->midi_dev;
-
-	if (midi_dev < 0 || midi_dev > num_midis || midi_devs[midi_dev]==NULL)
-		return -(ENXIO);
-
-	if (midi_dev == phys_dev->devno) {
-		index = 0;
-	} else if (phys_dev->isvirtual && midi_dev == virt_dev->devno) {
-		index = 1;
-	} else {
-		return -(EINVAL);
-	}
-
-	switch (cmd) {
-
-	case SNDCTL_SYNTH_INFO:
-		if (copy_to_user(arg,
-			      &wf_mpu_synth_info[index],
-			      sizeof (struct synth_info)))
-			return -EFAULT;
-		return 0;
-	
-	case SNDCTL_SYNTH_MEMAVL:
-		return 0x7fffffff;
-	
-	default:
-		return -EINVAL;
-	}
-}
-
-static int
-wf_mpu_synth_open (int dev, int mode)
-{
-	int             midi_dev;
-	struct wf_mpu_config *devc;
-
-	midi_dev = synth_devs[dev]->midi_dev;
-
-	if (midi_dev < 0 || midi_dev > num_midis || midi_devs[midi_dev]==NULL) {
-		return -(ENXIO);
-	}
-  
-	if (phys_dev->devno == midi_dev) {
-		devc = phys_dev;
-	} else if (phys_dev->isvirtual && virt_dev->devno == midi_dev) {
-		devc = virt_dev;
-	} else {
-		printk (KERN_ERR "WF-MPU: unknown device number %d\n", dev);
-		return -(EINVAL);
-	}
-
-	if (devc->opened) {
-		return -(EBUSY);
-	}
-  
-	devc->mode = MODE_SYNTH;
-	devc->synthno = dev;
-	devc->opened = mode;
-	devc->inputintr = NULL;
-	return 0;
-}
-
-static void
-wf_mpu_synth_close (int dev)
-{
-	int             midi_dev;
-	struct wf_mpu_config *devc;
-
-	midi_dev = synth_devs[dev]->midi_dev;
-
-	if (phys_dev->devno == midi_dev) {
-		devc = phys_dev;
-	} else if (phys_dev->isvirtual && virt_dev->devno == midi_dev) {
-		devc = virt_dev;
-	} else {
-		printk (KERN_ERR "WF-MPU: unknown device number %d\n", dev);
-		return;
-	}
-
-	devc->inputintr = NULL;
-	devc->opened = 0;
-	devc->mode = 0;
-}
-
-#define _MIDI_SYNTH_C_
-#define MIDI_SYNTH_NAME	"WaveFront (MIDI)"
-#define MIDI_SYNTH_CAPS	SYNTH_CAP_INPUT
-#include "midi_synth.h"
-
-static struct synth_operations wf_mpu_synth_proto =
-{
-	.owner		= THIS_MODULE,
-	.id		= "WaveFront (ICS2115)",
-	.info		= NULL,  /* info field, filled in during configuration */
-	.midi_dev	= 0,     /* MIDI dev XXX should this be -1 ? */
-	.synth_type	= SYNTH_TYPE_MIDI,
-	.synth_subtype	= SAMPLE_TYPE_WAVEFRONT,
-	.open		= wf_mpu_synth_open,
-	.close		= wf_mpu_synth_close,
-	.ioctl		= wf_mpu_synth_ioctl,
-	.kill_note	= midi_synth_kill_note,
-	.start_note	= midi_synth_start_note,
-	.set_instr	= midi_synth_set_instr,
-	.reset		= midi_synth_reset,
-	.hw_control	= midi_synth_hw_control,
-	.load_patch	= midi_synth_load_patch,
-	.aftertouch	= midi_synth_aftertouch,
-	.controller	= midi_synth_controller,
-	.panning	= midi_synth_panning,
-	.bender		= midi_synth_bender,
-	.setup_voice	= midi_synth_setup_voice,
-	.send_sysex	= midi_synth_send_sysex
-};
-
-static int
-config_wf_mpu (struct wf_mpu_config *dev)
-
-{
-	int is_external;
-	char *name;
-	int index;
-
-	if (dev == phys_dev) {
-		name = "WaveFront internal MIDI";
-		is_external = 0;
-		index = 0;
-		memcpy ((char *) &wf_mpu_synth_operations[index],
-			(char *) &wf_mpu_synth_proto,
-			sizeof (struct synth_operations));
-	} else {
-		name = "WaveFront external MIDI";
-		is_external = 1;
-		index = 1;
-		/* no synth operations for an external MIDI interface */
-	}
-
-	memcpy ((char *) &wf_mpu_synth_info[dev->devno],
-		(char *) &wf_mpu_synth_info_proto,
-		sizeof (struct synth_info));
-
-	strcpy (wf_mpu_synth_info[index].name, name);
-
-	wf_mpu_synth_operations[index].midi_dev = dev->devno;
-	wf_mpu_synth_operations[index].info = &wf_mpu_synth_info[index];
-
-	memcpy ((char *) &wf_mpu_midi_operations[index],
-		(char *) &wf_mpu_midi_proto,
-		sizeof (struct midi_operations));
-  
-	if (is_external) {
-		wf_mpu_midi_operations[index].converter = NULL;
-	} else {
-		wf_mpu_midi_operations[index].converter =
-			&wf_mpu_synth_operations[index];
-	}
-
-	strcpy (wf_mpu_midi_operations[index].info.name, name);
-
-	midi_devs[dev->devno] = &wf_mpu_midi_operations[index];
-	midi_devs[dev->devno]->in_info.m_busy = 0;
-	midi_devs[dev->devno]->in_info.m_state = MST_INIT;
-	midi_devs[dev->devno]->in_info.m_ptr = 0;
-	midi_devs[dev->devno]->in_info.m_left = 0;
-	midi_devs[dev->devno]->in_info.m_prev_status = 0;
-
-	devs[index].opened = 0;
-	devs[index].mode = 0;
-
-	return (0);
-}
-
-int virtual_midi_enable (void)
-
-{
-	if ((virt_dev->devno < 0) &&
-	    (virt_dev->devno = sound_alloc_mididev()) == -1) {
-		printk (KERN_ERR
-			"WF-MPU: too many midi devices detected\n");
-		return -1;
-	}
-
-	config_wf_mpu (virt_dev);
-
-	phys_dev->isvirtual = 1;
-	return virt_dev->devno;
-}
-
-int
-virtual_midi_disable (void)
-
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&lock,flags);
-
-	wf_mpu_close (virt_dev->devno);
-	/* no synth on virt_dev, so no need to call wf_mpu_synth_close() */
-	phys_dev->isvirtual = 0;
-
-	spin_unlock_irqrestore(&lock,flags);
-
-	return 0;
-}
-
-int __init detect_wf_mpu (int irq, int io_base)
-{
-	if (!request_region(io_base, 2, "wavefront midi")) {
-		printk (KERN_WARNING "WF-MPU: I/O port %x already in use.\n",
-			io_base);
-		return -1;
-	}
-
-	phys_dev->base = io_base;
-	phys_dev->irq = irq;
-	phys_dev->devno = -1;
-	virt_dev->devno = -1;
-
-	return 0;
-}
-
-int __init install_wf_mpu (void)
-{
-	if ((phys_dev->devno = sound_alloc_mididev()) < 0){
-
-		printk (KERN_ERR "WF-MPU: Too many MIDI devices detected.\n");
-		release_region(phys_dev->base, 2);
-		return -1;
-	}
-
-	phys_dev->isvirtual = 0;
-
-	if (config_wf_mpu (phys_dev)) {
-
-		printk (KERN_WARNING
-			"WF-MPU: configuration for MIDI device %d failed\n",
-			phys_dev->devno);
-		sound_unload_mididev (phys_dev->devno);
-
-	}
-
-	/* OK, now we're configured to handle an interrupt ... */
-
-	if (request_irq (phys_dev->irq, wf_mpuintr, IRQF_DISABLED|IRQF_SHARED,
-			 "wavefront midi", phys_dev) < 0) {
-
-		printk (KERN_ERR "WF-MPU: Failed to allocate IRQ%d\n",
-			phys_dev->irq);
-		return -1;
-
-	}
-
-	/* This being a WaveFront (ICS-2115) emulated MPU-401, we have
-	   to switch it into UART (dumb) mode, because otherwise, it
-	   won't do anything at all.
-	*/
-  
-	start_uart_mode ();
-
-	return phys_dev->devno;
-}
- 
-void
-uninstall_wf_mpu (void)
-
-{
-	release_region (phys_dev->base, 2); 
-	free_irq (phys_dev->irq, phys_dev);
-	sound_unload_mididev (phys_dev->devno);
-
-	if (virt_dev->devno >= 0) {
-		sound_unload_mididev (virt_dev->devno);
-	}
-}
-
-static void
-start_uart_mode (void)
-
-{
-	int             ok, i;
-	unsigned long   flags;
-
-	spin_lock_irqsave(&lock,flags);
-
-	/* XXX fix me */
-
-	for (i = 0; i < 30000 && !output_ready (); i++);
-
-	outb (UART_MODE_ON, COMDPORT(phys_dev));
-
-	for (ok = 0, i = 50000; i > 0 && !ok; i--) {
-		if (input_avail ()) {
-			if (read_data () == MPU_ACK) {
-				ok = 1;
-			}
-		}
-	}
-
-	spin_unlock_irqrestore(&lock,flags);
-}
-#endif
--- linux-2.6.18.noarch/sound/oss/sb_midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sb_midi.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sb_dsp.c
+ * sound/oss/sb_midi.c
  *
  * The low level driver for the Sound Blaster DS chips.
  *
@@ -173,7 +173,7 @@
 		return;
 	}
 	std_midi_synth.midi_dev = devc->my_mididev = dev;
-	midi_devs[dev] = (struct midi_operations *)kmalloc(sizeof(struct midi_operations), GFP_KERNEL);
+	midi_devs[dev] = kmalloc(sizeof(struct midi_operations), GFP_KERNEL);
 	if (midi_devs[dev] == NULL)
 	{
 		printk(KERN_WARNING "Sound Blaster:  failed to allocate MIDI memory.\n");
@@ -189,7 +189,7 @@
 	midi_devs[dev]->devc = devc;
 
 
-	midi_devs[dev]->converter = (struct synth_operations *)kmalloc(sizeof(struct synth_operations), GFP_KERNEL);
+	midi_devs[dev]->converter = kmalloc(sizeof(struct synth_operations), GFP_KERNEL);
 	if (midi_devs[dev]->converter == NULL)
 	{
 		  printk(KERN_WARNING "Sound Blaster:  failed to allocate MIDI memory.\n");
--- linux-2.6.18.noarch/sound/oss/gus_vol.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus_vol.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,153 +0,0 @@
-
-/*
- * gus_vol.c - Compute volume for GUS.
- *
- *
- * Copyright (C) by Hannu Savolainen 1993-1997
- *
- * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
- * Version 2 (June 1991). See the "COPYING" file distributed with this software
- * for more info.
- */
-#include "sound_config.h"
-
-#include "gus.h"
-#include "gus_linearvol.h"
-
-#define GUS_VOLUME	gus_wave_volume
-
-
-extern int      gus_wave_volume;
-
-/*
- * Calculate gus volume from note velocity, main volume, expression, and
- * intrinsic patch volume given in patch library.  Expression is multiplied
- * in, so it emphasizes differences in note velocity, while main volume is
- * added in -- I don't know whether this is right, but it seems reasonable to
- * me.  (In the previous stage, main volume controller messages were changed
- * to expression controller messages, if they were found to be used for
- * dynamic volume adjustments, so here, main volume can be assumed to be
- * constant throughout a song.)
- *
- * Intrinsic patch volume is added in, but if over 64 is also multiplied in, so
- * we can give a big boost to very weak voices like nylon guitar and the
- * basses.  The normal value is 64.  Strings are assigned lower values.
- */
-
-unsigned short gus_adagio_vol(int vel, int mainv, int xpn, int voicev)
-{
-	int i, m, n, x;
-
-
-	/*
-	 * A voice volume of 64 is considered neutral, so adjust the main volume if
-	 * something other than this neutral value was assigned in the patch
-	 * library.
-	 */
-	x = 256 + 6 * (voicev - 64);
-
-	/*
-	 * Boost expression by voice volume above neutral.
-	 */
-	 
-	if (voicev > 65)
-		xpn += voicev - 64;
-	xpn += (voicev - 64) / 2;
-
-	/*
-	 * Combine multiplicative and level components.
-	 */
-	x = vel * xpn * 6 + (voicev / 4) * x;
-
-#ifdef GUS_VOLUME
-	/*
-	 * Further adjustment by installation-specific master volume control
-	 * (default 60).
-	 */
-	x = (x * GUS_VOLUME * GUS_VOLUME) / 10000;
-#endif
-
-#ifdef GUS_USE_CHN_MAIN_VOLUME
-	/*
-	 * Experimental support for the channel main volume
-	 */
-
-	mainv = (mainv / 2) + 64;	/* Scale to 64 to 127 */
-	x = (x * mainv * mainv) / 16384;
-#endif
-
-	if (x < 2)
-		return (0);
-	else if (x >= 65535)
-		return ((15 << 8) | 255);
-
-	/*
-	 * Convert to GUS's logarithmic form with 4 bit exponent i and 8 bit
-	 * mantissa m.
-	 */
-	 
-	n = x;
-	i = 7;
-	if (n < 128)
-	{
-		  while (i > 0 && n < (1 << i))
-			  i--;
-	}
-	else
-	{
-		while (n > 255)
-		{
-			  n >>= 1;
-			  i++;
-		}
-	}
-	/*
-	 * Mantissa is part of linear volume not expressed in exponent.  (This is
-	 * not quite like real logs -- I wonder if it's right.)
-	 */
-	m = x - (1 << i);
-
-	/*
-	 * Adjust mantissa to 8 bits.
-	 */
-	if (m > 0)
-	{
-		if (i > 8)
-			m >>= i - 8;
-		else if (i < 8)
-			m <<= 8 - i;
-	}
-	return ((i << 8) + m);
-}
-
-/*
- * Volume-values are interpreted as linear values. Volume is based on the
- * value supplied with SEQ_START_NOTE(), channel main volume (if compiled in)
- * and the volume set by the mixer-device (default 60%).
- */
-
-unsigned short gus_linear_vol(int vol, int mainvol)
-{
-	int mixer_mainvol;
-
-	if (vol <= 0)
-		vol = 0;
-	else if (vol >= 127)
-		vol = 127;
-
-#ifdef GUS_VOLUME
-	mixer_mainvol = GUS_VOLUME;
-#else
-	mixer_mainvol = 100;
-#endif
-
-#ifdef GUS_USE_CHN_MAIN_VOLUME
-	if (mainvol <= 0)
-		mainvol = 0;
-	else if (mainvol >= 127)
-		mainvol = 127;
-#else
-	mainvol = 127;
-#endif
-	return gus_linearvol[(((vol * mainvol) / 127) * mixer_mainvol) / 100];
-}
--- linux-2.6.18.noarch/sound/oss/gus.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,24 +0,0 @@
-
-#include "ad1848.h"
-
-/*	From gus_card.c */
-int gus_set_midi_irq(int num);
-irqreturn_t gusintr(int irq, void *dev_id, struct pt_regs * dummy);
-
-/*	From gus_wave.c */
-int gus_wave_detect(int baseaddr);
-void gus_wave_init(struct address_info *hw_config);
-void gus_wave_unload (struct address_info *hw_config);
-void gus_voice_irq(void);
-void gus_write8(int reg, unsigned int data);
-void guswave_dma_irq(void);
-void gus_delay(void);
-int gus_default_mixer_ioctl (int dev, unsigned int cmd, void __user *arg);
-void gus_timer_command (unsigned int addr, unsigned int val);
-
-/*	From gus_midi.c */
-void gus_midi_init(struct address_info *hw_config);
-void gus_midi_interrupt(int dummy);
-
-/*	From ics2101.c */
-int ics2101_mixer_init(void);
--- linux-2.6.18.noarch/sound/oss/vidc.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/vidc.c	2007-06-05 17:44:14.000000000 -0400
@@ -372,7 +372,7 @@
 			adev->flags |= DMA_ACTIVE;
 
 			dma_interrupt = vidc_audio_dma_interrupt;
-			vidc_sound_dma_irq(0, NULL, NULL);
+			vidc_sound_dma_irq(0, NULL);
 			iomd_writeb(DMA_CR_E | 0x10, IOMD_SD0CR);
 
 			local_irq_restore(flags);
--- linux-2.6.18.noarch/sound/oss/adlib_card.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/adlib_card.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/adlib_card.c
+ * sound/oss/adlib_card.c
  *
  * Detection routine for the AdLib card.
  *
--- linux-2.6.18.noarch/sound/oss/maestro3.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/maestro3.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2969 +0,0 @@
-/*****************************************************************************
- *
- *      ESS Maestro3/Allegro driver for Linux 2.4.x
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *    (c) Copyright 2000 Zach Brown <zab@zabbo.net>
- *
- * I need to thank many people for helping make this driver happen.  
- * As always, Eric Brombaugh was a hacking machine and killed many bugs
- * that I was too dumb to notice.  Howard Kim at ESS provided reference boards 
- * and as much docs as he could.  Todd and Mick at Dell tested snapshots on 
- * an army of laptops.  msw and deviant at Red Hat also humoured me by hanging
- * their laptops every few hours in the name of science.
- * 
- * Shouts go out to Mike "DJ XPCom" Ang.
- *
- * History
- *  v1.23 - Jun 5 2002 - Michael Olson <olson@cs.odu.edu>
- *   added a module option to allow selection of GPIO pin number 
- *   for external amp 
- *  v1.22 - Feb 28 2001 - Zach Brown <zab@zabbo.net>
- *   allocate mem at insmod/setup, rather than open
- *   limit pci dma addresses to 28bit, thanks guys.
- *  v1.21 - Feb 04 2001 - Zach Brown <zab@zabbo.net>
- *   fix up really dumb notifier -> suspend oops
- *  v1.20 - Jan 30 2001 - Zach Brown <zab@zabbo.net>
- *   get rid of pm callback and use pci_dev suspend/resume instead
- *   m3_probe cleanups, including pm oops think-o
- *  v1.10 - Jan 6 2001 - Zach Brown <zab@zabbo.net>
- *   revert to lame remap_page_range mmap() just to make it work
- *   record mmap fixed.
- *   fix up incredibly broken open/release resource management
- *   duh.  fix record format setting.
- *   add SMP locking and cleanup formatting here and there
- *  v1.00 - Dec 16 2000 - Zach Brown <zab@zabbo.net>
- *   port to sexy 2.4 interfaces
- *   properly align instance allocations so recording works
- *   clean up function namespace a little :/
- *   update PCI IDs based on mail from ESS
- *   arbitrarily bump version number to show its 2.4 now, 
- *      2.2 will stay 0., oss_audio port gets 2.
- *  v0.03 - Nov 05 2000 - Zach Brown <zab@zabbo.net>
- *   disable recording but allow dsp to be opened read 
- *   pull out most silly compat defines
- *  v0.02 - Nov 04 2000 - Zach Brown <zab@zabbo.net>
- *   changed clocking setup for m3, slowdown fixed.
- *   codec reset is hopefully reliable now
- *   rudimentary apm/power management makes suspend/resume work
- *  v0.01 - Oct 31 2000 - Zach Brown <zab@zabbo.net>
- *   first release
- *  v0.00 - Sep 09 2000 - Zach Brown <zab@zabbo.net>
- *   first pass derivation from maestro.c
- *
- * TODO
- *  in/out allocated contiguously so fullduplex mmap will work?
- *  no beep on init (mute)
- *  resetup msrc data memory if freq changes?
- *
- *  --
- *
- *  Allow me to ramble a bit about the m3 architecture.  The core of the
- *  chip is the 'assp', the custom ESS dsp that runs the show.  It has
- *  a small amount of code and data ram.  ESS drops binary dsp code images
- *  on our heads, but we don't get to see specs on the dsp.  
- *
- *  The constant piece of code on the dsp is the 'kernel'.  It also has a 
- *  chunk of the dsp memory that is statically set aside for its control
- *  info.  This is the KDATA defines in maestro3.h.  Part of its core
- *  data is a list of code addresses that point to the pieces of DSP code
- *  that it should walk through in its loop.  These other pieces of code
- *  do the real work.  The kernel presumably jumps into each of them in turn.
- *  These code images tend to have their own data area, and one can have
- *  multiple data areas representing different states for each of the 'client
- *  instance' code portions.  There is generally a list in the kernel data
- *  that points to the data instances for a given piece of code.
- *
- *  We've only been given the binary image for the 'minisrc', mini sample 
- *  rate converter.  This is rather annoying because it limits the work
- *  we can do on the dsp, but it also greatly simplifies the job of managing
- *  dsp data memory for the code and data for our playing streams :).  We
- *  statically allocate the minisrc code into a region we 'know' to be free
- *  based on the map of the binary kernel image we're loading.  We also 
- *  statically allocate the data areas for the maximum number of pcm streams
- *  we can be dealing with.  This max is set by the length of the static list
- *  in the kernel data that records the number of minisrc data regions we
- *  can have.  Thats right, all software dsp mixing with static code list
- *  limits.  Rock.
- *
- *  How sound goes in and out is still a relative mystery.  It appears
- *  that the dsp has the ability to get input and output through various
- *  'connections'.  To do IO from or to a connection, you put the address
- *  of the minisrc client area in the static kernel data lists for that 
- *  input or output.  so for pcm -> dsp -> mixer, we put the minisrc data
- *  instance in the DMA list and also in the list for the mixer.  I guess
- *  it Just Knows which is in/out, and we give some dma control info that
- *  helps.  There are all sorts of cool inputs/outputs that it seems we can't
- *  use without dsp code images that know how to use them.
- *
- *  So at init time we preload all the memory allocation stuff and set some
- *  system wide parameters.  When we really get a sound to play we build
- *  up its minisrc header (stream parameters, buffer addresses, input/output
- *  settings).  Then we throw its header on the various lists.  We also
- *  tickle some KDATA settings that ask the assp to raise clock interrupts
- *  and do some amount of software mixing before handing data to the ac97.
- *
- *  Sorry for the vague details.  Feel free to ask Eric or myself if you
- *  happen to be trying to use this driver elsewhere.  Please accept my
- *  apologies for the quality of the OSS support code, its passed through
- *  too many hands now and desperately wants to be rethought.
- */
-
-/*****************************************************************************/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/vmalloc.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/poll.h>
-#include <linux/reboot.h>
-#include <linux/spinlock.h>
-#include <linux/ac97_codec.h>
-#include <linux/wait.h>
-#include <linux/mutex.h>
-
-
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <asm/uaccess.h>
-
-#include "maestro3.h"
-
-#define M_DEBUG 1
-
-#define DRIVER_VERSION      "1.23"
-#define M3_MODULE_NAME      "maestro3"
-#define PFX                 M3_MODULE_NAME ": "
-
-#define M3_STATE_MAGIC      0x734d724d
-#define M3_CARD_MAGIC       0x646e6f50
-
-#define ESS_FMT_STEREO      0x01
-#define ESS_FMT_16BIT       0x02
-#define ESS_FMT_MASK        0x03
-#define ESS_DAC_SHIFT       0   
-#define ESS_ADC_SHIFT       4
-
-#define DAC_RUNNING         1
-#define ADC_RUNNING         2
-
-#define SND_DEV_DSP16       5 
-   
-#ifdef M_DEBUG
-static int debug;
-#define DPMOD   1   /* per module load */
-#define DPSTR   2   /* per 'stream' */
-#define DPSYS   3   /* per syscall */
-#define DPCRAP  4   /* stuff the user shouldn't see unless they're really debuggin */
-#define DPINT   5   /* per interrupt, LOTS */
-#define DPRINTK(DP, args...) {if (debug >= (DP)) printk(KERN_DEBUG PFX args);}
-#else
-#define DPRINTK(x)
-#endif
-
-struct m3_list {
-    int curlen;
-    u16 mem_addr;
-    int max;
-};
-
-static int external_amp = 1;
-static int gpio_pin = -1;
-
-struct m3_state {
-    unsigned int magic;
-    struct m3_card *card;
-    unsigned char fmt, enable;
-
-    int index;
-
-    /* this locks around the oss state in the driver */
-	/* no, this lock is removed - only use card->lock */
-	/* otherwise: against what are you protecting on SMP 
-		when irqhandler uses s->lock
-		and m3_assp_read uses card->lock ?
-		*/
-    struct mutex open_mutex;
-    wait_queue_head_t open_wait;
-    mode_t open_mode;
-
-    int dev_audio;
-
-    struct assp_instance {
-        u16 code, data;
-    } dac_inst, adc_inst;
-
-    /* should be in dmabuf */
-    unsigned int rateadc, ratedac;
-
-    struct dmabuf {
-        void *rawbuf;
-        unsigned buforder;
-        unsigned numfrag;
-        unsigned fragshift;
-        unsigned hwptr, swptr;
-        unsigned total_bytes;
-        int count;
-        unsigned error; /* over/underrun */
-        wait_queue_head_t wait;
-        /* redundant, but makes calculations easier */
-        unsigned fragsize;
-        unsigned dmasize;
-        unsigned fragsamples;
-        /* OSS stuff */
-        unsigned mapped:1;
-        unsigned ready:1;    
-        unsigned endcleared:1;
-        unsigned ossfragshift;
-        int ossmaxfrags;
-        unsigned subdivision;
-        /* new in m3 */
-        int mixer_index, dma_index, msrc_index, adc1_index;
-        int in_lists;
-        /* 2.4.. */
-        dma_addr_t handle;
-
-    } dma_dac, dma_adc;
-};
-    
-struct m3_card {
-    unsigned int magic;
-
-    struct m3_card *next;
-
-    struct ac97_codec *ac97;
-    spinlock_t ac97_lock;
-
-    int card_type;
-
-#define NR_DSPS 1
-#define MAX_DSPS NR_DSPS
-    struct m3_state channels[MAX_DSPS];
-
-    /* this locks around the physical registers on the card */
-    spinlock_t lock;
-
-    /* hardware resources */
-    struct pci_dev *pcidev;
-    u32 iobase;
-    u32 irq;
-
-    int dacs_active;
-
-    int timer_users;
-
-    struct m3_list  msrc_list,
-                    mixer_list,
-                    adc1_list,
-                    dma_list;
-
-    /* for storing reset state..*/
-    u8 reset_state;
-
-    u16 *suspend_mem;
-    int in_suspend;
-    wait_queue_head_t suspend_queue;
-};
-
-/*
- * an arbitrary volume we set the internal
- * volume settings to so that the ac97 volume
- * range is a little less insane.  0x7fff is 
- * max.
- */
-#define ARB_VOLUME ( 0x6800 )
-
-static const unsigned sample_shift[] = { 0, 1, 1, 2 };
-
-enum {
-    ESS_ALLEGRO,
-    ESS_MAESTRO3,
-    /*
-     * a maestro3 with 'hardware strapping', only
-     * found inside ESS?
-     */
-    ESS_MAESTRO3HW,
-};
-
-static char *card_names[] = {
-    [ESS_ALLEGRO] = "Allegro",
-    [ESS_MAESTRO3] = "Maestro3(i)",
-    [ESS_MAESTRO3HW] = "Maestro3(i)hw"
-};
-
-#ifndef PCI_VENDOR_ESS
-#define PCI_VENDOR_ESS      0x125D
-#endif
-
-#define M3_DEVICE(DEV, TYPE)			\
-{						\
-.vendor	     = PCI_VENDOR_ESS,			\
-.device	     = DEV,				\
-.subvendor   = PCI_ANY_ID,			\
-.subdevice   = PCI_ANY_ID,			\
-.class	     = PCI_CLASS_MULTIMEDIA_AUDIO << 8,	\
-.class_mask  = 0xffff << 8,			\
-.driver_data = TYPE,				\
-}
-
-static struct pci_device_id m3_id_table[] = {
-    M3_DEVICE(0x1988, ESS_ALLEGRO),
-    M3_DEVICE(0x1998, ESS_MAESTRO3),
-    M3_DEVICE(0x199a, ESS_MAESTRO3HW),
-    {0,}
-};
-
-MODULE_DEVICE_TABLE (pci, m3_id_table);
-
-/*
- * reports seem to indicate that the m3 is limited
- * to 28bit bus addresses.  aaaargggh...
- */
-#define M3_PCI_DMA_MASK 0x0fffffff
-
-static unsigned 
-ld2(unsigned int x)
-{
-    unsigned r = 0;
-    
-    if (x >= 0x10000) {
-        x >>= 16;
-        r += 16;
-    }
-    if (x >= 0x100) {
-        x >>= 8;
-        r += 8;
-    }
-    if (x >= 0x10) {
-        x >>= 4;
-        r += 4;
-    }
-    if (x >= 4) {
-        x >>= 2;
-        r += 2;
-    }
-    if (x >= 2)
-        r++;
-    return r;
-}
-
-static struct m3_card *devs;
-
-/*
- * I'm not very good at laying out functions in a file :)
- */
-static int m3_notifier(struct notifier_block *nb, unsigned long event, void *buf);
-static int m3_suspend(struct pci_dev *pci_dev, pm_message_t state);
-static void check_suspend(struct m3_card *card);
-
-static struct notifier_block m3_reboot_nb = {
-	.notifier_call = m3_notifier,
-};
-
-static void m3_outw(struct m3_card *card,
-        u16 value, unsigned long reg)
-{
-    check_suspend(card);
-    outw(value, card->iobase + reg);
-}
-
-static u16 m3_inw(struct m3_card *card, unsigned long reg)
-{
-    check_suspend(card);
-    return inw(card->iobase + reg);
-}
-static void m3_outb(struct m3_card *card, 
-        u8 value, unsigned long reg)
-{
-    check_suspend(card);
-    outb(value, card->iobase + reg);
-}
-static u8 m3_inb(struct m3_card *card, unsigned long reg)
-{
-    check_suspend(card);
-    return inb(card->iobase + reg);
-}
-
-/*
- * access 16bit words to the code or data regions of the dsp's memory.
- * index addresses 16bit words.
- */
-static u16 __m3_assp_read(struct m3_card *card, u16 region, u16 index)
-{
-    m3_outw(card, region & MEMTYPE_MASK, DSP_PORT_MEMORY_TYPE);
-    m3_outw(card, index, DSP_PORT_MEMORY_INDEX);
-    return m3_inw(card, DSP_PORT_MEMORY_DATA);
-}
-static u16 m3_assp_read(struct m3_card *card, u16 region, u16 index)
-{
-    unsigned long flags;
-    u16 ret;
-
-    spin_lock_irqsave(&(card->lock), flags);
-    ret = __m3_assp_read(card, region, index);
-    spin_unlock_irqrestore(&(card->lock), flags);
-
-    return ret;
-}
-
-static void __m3_assp_write(struct m3_card *card, 
-        u16 region, u16 index, u16 data)
-{
-    m3_outw(card, region & MEMTYPE_MASK, DSP_PORT_MEMORY_TYPE);
-    m3_outw(card, index, DSP_PORT_MEMORY_INDEX);
-    m3_outw(card, data, DSP_PORT_MEMORY_DATA);
-}
-static void m3_assp_write(struct m3_card *card, 
-        u16 region, u16 index, u16 data)
-{
-    unsigned long flags;
-
-    spin_lock_irqsave(&(card->lock), flags);
-    __m3_assp_write(card, region, index, data);
-    spin_unlock_irqrestore(&(card->lock), flags);
-}
-
-static void m3_assp_halt(struct m3_card *card)
-{
-    card->reset_state = m3_inb(card, DSP_PORT_CONTROL_REG_B) & ~REGB_STOP_CLOCK;
-    mdelay(10);
-    m3_outb(card, card->reset_state & ~REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);
-}
-
-static void m3_assp_continue(struct m3_card *card)
-{
-    m3_outb(card, card->reset_state | REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);
-}
-
-/*
- * This makes me sad. the maestro3 has lists
- * internally that must be packed.. 0 terminates,
- * apparently, or maybe all unused entries have
- * to be 0, the lists have static lengths set
- * by the binary code images.
- */
-
-static int m3_add_list(struct m3_card *card,
-        struct m3_list *list, u16 val)
-{
-    DPRINTK(DPSTR, "adding val 0x%x to list 0x%p at pos %d\n",
-            val, list, list->curlen);
-
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-            list->mem_addr + list->curlen,
-            val);
-
-    return list->curlen++;
-
-}
-
-static void m3_remove_list(struct m3_card *card,
-        struct m3_list *list, int index)
-{
-    u16  val;
-    int lastindex = list->curlen - 1;
-
-    DPRINTK(DPSTR, "removing ind %d from list 0x%p\n",
-            index, list);
-
-    if(index != lastindex) {
-        val = m3_assp_read(card, MEMTYPE_INTERNAL_DATA,
-                list->mem_addr + lastindex);
-        m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-                list->mem_addr + index,
-                val);
-    }
-
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-            list->mem_addr + lastindex,
-            0);
-
-    list->curlen--;
-}
-
-static void set_fmt(struct m3_state *s, unsigned char mask, unsigned char data)
-{
-    int tmp;
-
-    s->fmt = (s->fmt & mask) | data;
-
-    tmp = (s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK;
-
-    /* write to 'mono' word */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->dac_inst.data + SRC3_DIRECTION_OFFSET + 1, 
-            (tmp & ESS_FMT_STEREO) ? 0 : 1);
-    /* write to '8bit' word */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->dac_inst.data + SRC3_DIRECTION_OFFSET + 2, 
-            (tmp & ESS_FMT_16BIT) ? 0 : 1);
-
-    tmp = (s->fmt >> ESS_ADC_SHIFT) & ESS_FMT_MASK;
-
-    /* write to 'mono' word */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->adc_inst.data + SRC3_DIRECTION_OFFSET + 1, 
-            (tmp & ESS_FMT_STEREO) ? 0 : 1);
-    /* write to '8bit' word */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->adc_inst.data + SRC3_DIRECTION_OFFSET + 2, 
-            (tmp & ESS_FMT_16BIT) ? 0 : 1);
-}
-
-static void set_dac_rate(struct m3_state *s, unsigned int rate)
-{
-    u32 freq;
-
-    if (rate > 48000)
-        rate = 48000;
-    if (rate < 8000)
-        rate = 8000;
-
-    s->ratedac = rate;
-
-    freq = ((rate << 15) + 24000 ) / 48000;
-    if(freq) 
-        freq--;
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->dac_inst.data + CDATA_FREQUENCY,
-            freq);
-}
-
-static void set_adc_rate(struct m3_state *s, unsigned int rate)
-{
-    u32 freq;
-
-    if (rate > 48000)
-        rate = 48000;
-    if (rate < 8000)
-        rate = 8000;
-
-    s->rateadc = rate;
-
-    freq = ((rate << 15) + 24000 ) / 48000;
-    if(freq) 
-        freq--;
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->adc_inst.data + CDATA_FREQUENCY,
-            freq);
-}
-
-static void inc_timer_users(struct m3_card *card)
-{
-    unsigned long flags;
-
-    spin_lock_irqsave(&card->lock, flags);
-    
-    card->timer_users++;
-    DPRINTK(DPSYS, "inc timer users now %d\n",
-            card->timer_users);
-    if(card->timer_users != 1) 
-        goto out;
-
-    __m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-        KDATA_TIMER_COUNT_RELOAD,
-         240 ) ;
-
-    __m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-        KDATA_TIMER_COUNT_CURRENT,
-         240 ) ;
-
-    m3_outw(card,  
-            m3_inw(card, HOST_INT_CTRL) | CLKRUN_GEN_ENABLE,
-            HOST_INT_CTRL);
-out:
-    spin_unlock_irqrestore(&card->lock, flags);
-}
-
-static void dec_timer_users(struct m3_card *card)
-{
-    unsigned long flags;
-
-    spin_lock_irqsave(&card->lock, flags);
-
-    card->timer_users--;
-    DPRINTK(DPSYS, "dec timer users now %d\n",
-            card->timer_users);
-    if(card->timer_users > 0 ) 
-        goto out;
-
-    __m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-        KDATA_TIMER_COUNT_RELOAD,
-         0 ) ;
-
-    __m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-        KDATA_TIMER_COUNT_CURRENT,
-         0 ) ;
-
-    m3_outw(card,  m3_inw(card, HOST_INT_CTRL) & ~CLKRUN_GEN_ENABLE,
-            HOST_INT_CTRL);
-out:
-    spin_unlock_irqrestore(&card->lock, flags);
-}
-
-/*
- * {start,stop}_{adc,dac} should be called
- * while holding the 'state' lock and they
- * will try to grab the 'card' lock..
- */
-static void stop_adc(struct m3_state *s)
-{
-    if (! (s->enable & ADC_RUNNING)) 
-        return;
-
-    s->enable &= ~ADC_RUNNING;
-    dec_timer_users(s->card);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->adc_inst.data + CDATA_INSTANCE_READY, 0);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            KDATA_ADC1_REQUEST, 0);
-}    
-
-static void stop_dac(struct m3_state *s)
-{
-    if (! (s->enable & DAC_RUNNING)) 
-        return;
-
-    DPRINTK(DPSYS, "stop_dac()\n");
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->dac_inst.data + CDATA_INSTANCE_READY, 0);
-
-    s->enable &= ~DAC_RUNNING;
-    s->card->dacs_active--;
-    dec_timer_users(s->card);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            KDATA_MIXER_TASK_NUMBER, 
-            s->card->dacs_active ) ;
-}    
-
-static void start_dac(struct m3_state *s)
-{
-    if( (!s->dma_dac.mapped && s->dma_dac.count < 1) ||
-            !s->dma_dac.ready ||
-            (s->enable & DAC_RUNNING)) 
-        return;
-
-    DPRINTK(DPSYS, "start_dac()\n");
-
-    s->enable |= DAC_RUNNING;
-    s->card->dacs_active++;
-    inc_timer_users(s->card);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->dac_inst.data + CDATA_INSTANCE_READY, 1);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            KDATA_MIXER_TASK_NUMBER, 
-            s->card->dacs_active ) ;
-}    
-
-static void start_adc(struct m3_state *s)
-{
-    if ((! s->dma_adc.mapped &&
-                s->dma_adc.count >= (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize)) 
-        || !s->dma_adc.ready 
-        || (s->enable & ADC_RUNNING) ) 
-            return;
-
-    DPRINTK(DPSYS, "start_adc()\n");
-
-    s->enable |= ADC_RUNNING;
-    inc_timer_users(s->card);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            KDATA_ADC1_REQUEST, 1);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->adc_inst.data + CDATA_INSTANCE_READY, 1);
-}    
-
-static struct play_vals {
-    u16 addr, val;
-} pv[] = {
-    {CDATA_LEFT_VOLUME, ARB_VOLUME},
-    {CDATA_RIGHT_VOLUME, ARB_VOLUME},
-    {SRC3_DIRECTION_OFFSET, 0} ,
-    /* +1, +2 are stereo/16 bit */
-    {SRC3_DIRECTION_OFFSET + 3, 0x0000}, /* fraction? */
-    {SRC3_DIRECTION_OFFSET + 4, 0}, /* first l */
-    {SRC3_DIRECTION_OFFSET + 5, 0}, /* first r */
-    {SRC3_DIRECTION_OFFSET + 6, 0}, /* second l */
-    {SRC3_DIRECTION_OFFSET + 7, 0}, /* second r */
-    {SRC3_DIRECTION_OFFSET + 8, 0}, /* delta l */
-    {SRC3_DIRECTION_OFFSET + 9, 0}, /* delta r */
-    {SRC3_DIRECTION_OFFSET + 10, 0x8000}, /* round */
-    {SRC3_DIRECTION_OFFSET + 11, 0xFF00}, /* higher bute mark */
-    {SRC3_DIRECTION_OFFSET + 13, 0}, /* temp0 */
-    {SRC3_DIRECTION_OFFSET + 14, 0}, /* c fraction */
-    {SRC3_DIRECTION_OFFSET + 15, 0}, /* counter */
-    {SRC3_DIRECTION_OFFSET + 16, 8}, /* numin */
-    {SRC3_DIRECTION_OFFSET + 17, 50*2}, /* numout */
-    {SRC3_DIRECTION_OFFSET + 18, MINISRC_BIQUAD_STAGE - 1}, /* numstage */
-    {SRC3_DIRECTION_OFFSET + 20, 0}, /* filtertap */
-    {SRC3_DIRECTION_OFFSET + 21, 0} /* booster */
-};
-
-
-/* the mode passed should be already shifted and masked */
-static void m3_play_setup(struct m3_state *s, int mode, u32 rate, void *buffer, int size)
-{
-    int dsp_in_size = MINISRC_IN_BUFFER_SIZE - (0x20 * 2);
-    int dsp_out_size = MINISRC_OUT_BUFFER_SIZE - (0x20 * 2);
-    int dsp_in_buffer = s->dac_inst.data + (MINISRC_TMP_BUFFER_SIZE / 2);
-    int dsp_out_buffer = dsp_in_buffer + (dsp_in_size / 2) + 1;
-    struct dmabuf *db = &s->dma_dac;
-    int i;
-
-    DPRINTK(DPSTR, "mode=%d rate=%d buf=%p len=%d.\n",
-        mode, rate, buffer, size);
-
-#define LO(x) ((x) & 0xffff)
-#define HI(x) LO((x) >> 16)
-
-    /* host dma buffer pointers */
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_HOST_SRC_ADDRL,
-        LO(virt_to_bus(buffer)));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_HOST_SRC_ADDRH,
-        HI(virt_to_bus(buffer)));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_HOST_SRC_END_PLUS_1L,
-        LO(virt_to_bus(buffer) + size));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_HOST_SRC_END_PLUS_1H,
-        HI(virt_to_bus(buffer) + size));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_HOST_SRC_CURRENTL,
-        LO(virt_to_bus(buffer)));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_HOST_SRC_CURRENTH,
-        HI(virt_to_bus(buffer)));
-#undef LO
-#undef HI
-
-    /* dsp buffers */
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_IN_BUF_BEGIN,
-        dsp_in_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_IN_BUF_END_PLUS_1,
-        dsp_in_buffer + (dsp_in_size / 2));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_IN_BUF_HEAD,
-        dsp_in_buffer);
-    
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_IN_BUF_TAIL,
-        dsp_in_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_OUT_BUF_BEGIN,
-        dsp_out_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_OUT_BUF_END_PLUS_1,
-        dsp_out_buffer + (dsp_out_size / 2));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_OUT_BUF_HEAD,
-        dsp_out_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_OUT_BUF_TAIL,
-        dsp_out_buffer);
-
-    /*
-     * some per client initializers
-     */
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + SRC3_DIRECTION_OFFSET + 12,
-        s->dac_inst.data + 40 + 8);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + SRC3_DIRECTION_OFFSET + 19,
-        s->dac_inst.code + MINISRC_COEF_LOC);
-
-    /* enable or disable low pass filter? */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + SRC3_DIRECTION_OFFSET + 22,
-        s->ratedac > 45000 ? 0xff : 0 );
-    
-    /* tell it which way dma is going? */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->dac_inst.data + CDATA_DMA_CONTROL,
-        DMACONTROL_AUTOREPEAT + DMAC_PAGE3_SELECTOR + DMAC_BLOCKF_SELECTOR);
-
-    /*
-     * set an armload of static initializers
-     */
-    for(i = 0 ; i < (sizeof(pv) / sizeof(pv[0])) ; i++) 
-        m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->dac_inst.data + pv[i].addr, pv[i].val);
-
-    /* 
-     * put us in the lists if we're not already there
-     */
-
-    if(db->in_lists == 0) {
-
-        db->msrc_index = m3_add_list(s->card, &s->card->msrc_list, 
-                s->dac_inst.data >> DP_SHIFT_COUNT);
-
-        db->dma_index = m3_add_list(s->card, &s->card->dma_list, 
-                s->dac_inst.data >> DP_SHIFT_COUNT);
-
-        db->mixer_index = m3_add_list(s->card, &s->card->mixer_list, 
-                s->dac_inst.data >> DP_SHIFT_COUNT);
-
-        db->in_lists = 1;
-    }
-
-    set_dac_rate(s,rate);
-    start_dac(s);
-}
-
-/*
- *    Native record driver 
- */
-static struct rec_vals {
-    u16 addr, val;
-} rv[] = {
-    {CDATA_LEFT_VOLUME, ARB_VOLUME},
-    {CDATA_RIGHT_VOLUME, ARB_VOLUME},
-    {SRC3_DIRECTION_OFFSET, 1} ,
-    /* +1, +2 are stereo/16 bit */
-    {SRC3_DIRECTION_OFFSET + 3, 0x0000}, /* fraction? */
-    {SRC3_DIRECTION_OFFSET + 4, 0}, /* first l */
-    {SRC3_DIRECTION_OFFSET + 5, 0}, /* first r */
-    {SRC3_DIRECTION_OFFSET + 6, 0}, /* second l */
-    {SRC3_DIRECTION_OFFSET + 7, 0}, /* second r */
-    {SRC3_DIRECTION_OFFSET + 8, 0}, /* delta l */
-    {SRC3_DIRECTION_OFFSET + 9, 0}, /* delta r */
-    {SRC3_DIRECTION_OFFSET + 10, 0x8000}, /* round */
-    {SRC3_DIRECTION_OFFSET + 11, 0xFF00}, /* higher bute mark */
-    {SRC3_DIRECTION_OFFSET + 13, 0}, /* temp0 */
-    {SRC3_DIRECTION_OFFSET + 14, 0}, /* c fraction */
-    {SRC3_DIRECTION_OFFSET + 15, 0}, /* counter */
-    {SRC3_DIRECTION_OFFSET + 16, 50},/* numin */
-    {SRC3_DIRECTION_OFFSET + 17, 8}, /* numout */
-    {SRC3_DIRECTION_OFFSET + 18, 0}, /* numstage */
-    {SRC3_DIRECTION_OFFSET + 19, 0}, /* coef */
-    {SRC3_DIRECTION_OFFSET + 20, 0}, /* filtertap */
-    {SRC3_DIRECTION_OFFSET + 21, 0}, /* booster */
-    {SRC3_DIRECTION_OFFSET + 22, 0xff} /* skip lpf */
-};
-
-/* again, passed mode is alrady shifted/masked */
-static void m3_rec_setup(struct m3_state *s, int mode, u32 rate, void *buffer, int size)
-{
-    int dsp_in_size = MINISRC_IN_BUFFER_SIZE + (0x10 * 2);
-    int dsp_out_size = MINISRC_OUT_BUFFER_SIZE - (0x10 * 2);
-    int dsp_in_buffer = s->adc_inst.data + (MINISRC_TMP_BUFFER_SIZE / 2);
-    int dsp_out_buffer = dsp_in_buffer + (dsp_in_size / 2) + 1;
-    struct dmabuf *db = &s->dma_adc;
-    int i;
-
-    DPRINTK(DPSTR, "rec_setup mode=%d rate=%d buf=%p len=%d.\n",
-        mode, rate, buffer, size);
-
-#define LO(x) ((x) & 0xffff)
-#define HI(x) LO((x) >> 16)
-
-    /* host dma buffer pointers */
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_HOST_SRC_ADDRL,
-        LO(virt_to_bus(buffer)));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_HOST_SRC_ADDRH,
-        HI(virt_to_bus(buffer)));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_HOST_SRC_END_PLUS_1L,
-        LO(virt_to_bus(buffer) + size));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_HOST_SRC_END_PLUS_1H,
-        HI(virt_to_bus(buffer) + size));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_HOST_SRC_CURRENTL,
-        LO(virt_to_bus(buffer)));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_HOST_SRC_CURRENTH,
-        HI(virt_to_bus(buffer)));
-#undef LO
-#undef HI
-
-    /* dsp buffers */
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_IN_BUF_BEGIN,
-        dsp_in_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_IN_BUF_END_PLUS_1,
-        dsp_in_buffer + (dsp_in_size / 2));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_IN_BUF_HEAD,
-        dsp_in_buffer);
-    
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_IN_BUF_TAIL,
-        dsp_in_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_OUT_BUF_BEGIN,
-        dsp_out_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_OUT_BUF_END_PLUS_1,
-        dsp_out_buffer + (dsp_out_size / 2));
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_OUT_BUF_HEAD,
-        dsp_out_buffer);
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_OUT_BUF_TAIL,
-        dsp_out_buffer);
-
-    /*
-     * some per client initializers
-     */
-
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + SRC3_DIRECTION_OFFSET + 12,
-        s->adc_inst.data + 40 + 8);
-
-    /* tell it which way dma is going? */
-    m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-        s->adc_inst.data + CDATA_DMA_CONTROL,
-        DMACONTROL_DIRECTION + DMACONTROL_AUTOREPEAT + 
-        DMAC_PAGE3_SELECTOR + DMAC_BLOCKF_SELECTOR);
-
-    /*
-     * set an armload of static initializers
-     */
-    for(i = 0 ; i < (sizeof(rv) / sizeof(rv[0])) ; i++) 
-        m3_assp_write(s->card, MEMTYPE_INTERNAL_DATA,
-            s->adc_inst.data + rv[i].addr, rv[i].val);
-
-    /* 
-     * put us in the lists if we're not already there
-     */
-
-    if(db->in_lists == 0) {
-
-        db->adc1_index = m3_add_list(s->card, &s->card->adc1_list, 
-                s->adc_inst.data >> DP_SHIFT_COUNT);
-
-        db->dma_index = m3_add_list(s->card, &s->card->dma_list, 
-                s->adc_inst.data >> DP_SHIFT_COUNT);
-
-        db->msrc_index = m3_add_list(s->card, &s->card->msrc_list, 
-                s->adc_inst.data >> DP_SHIFT_COUNT);
-
-        db->in_lists = 1;
-    }
-
-    set_adc_rate(s,rate);
-    start_adc(s);
-}
-/* --------------------------------------------------------------------- */
-
-static void set_dmaa(struct m3_state *s, unsigned int addr, unsigned int count)
-{
-    DPRINTK(DPINT,"set_dmaa??\n");
-}
-
-static void set_dmac(struct m3_state *s, unsigned int addr, unsigned int count)
-{
-    DPRINTK(DPINT,"set_dmac??\n");
-}
-
-static u32 get_dma_pos(struct m3_card *card,
-		       int instance_addr)
-{
-    u16 hi = 0, lo = 0;
-    int retry = 10;
-
-    /*
-     * try and get a valid answer
-     */
-    while(retry--) {
-        hi =  m3_assp_read(card, MEMTYPE_INTERNAL_DATA,
-                instance_addr + CDATA_HOST_SRC_CURRENTH);
-
-        lo = m3_assp_read(card, MEMTYPE_INTERNAL_DATA,
-                instance_addr + CDATA_HOST_SRC_CURRENTL);
-
-        if(hi == m3_assp_read(card, MEMTYPE_INTERNAL_DATA,
-                instance_addr + CDATA_HOST_SRC_CURRENTH))
-            break;
-    }
-    return lo | (hi<<16);
-}
-
-static u32 get_dmaa(struct m3_state *s)
-{
-    u32 offset;
-
-    offset = get_dma_pos(s->card, s->dac_inst.data) - 
-        virt_to_bus(s->dma_dac.rawbuf);
-
-    DPRINTK(DPINT,"get_dmaa: 0x%08x\n",offset);
-
-    return offset;
-}
-
-static u32 get_dmac(struct m3_state *s)
-{
-    u32 offset;
-
-    offset = get_dma_pos(s->card, s->adc_inst.data) -
-        virt_to_bus(s->dma_adc.rawbuf);
-
-    DPRINTK(DPINT,"get_dmac: 0x%08x\n",offset);
-
-    return offset;
-
-}
-
-static int 
-prog_dmabuf(struct m3_state *s, unsigned rec)
-{
-    struct dmabuf *db = rec ? &s->dma_adc : &s->dma_dac;
-    unsigned rate = rec ? s->rateadc : s->ratedac;
-    unsigned bytepersec;
-    unsigned bufs;
-    unsigned char fmt;
-    unsigned long flags;
-
-    spin_lock_irqsave(&s->card->lock, flags);
-
-    fmt = s->fmt;
-    if (rec) {
-        stop_adc(s);
-        fmt >>= ESS_ADC_SHIFT;
-    } else {
-        stop_dac(s);
-        fmt >>= ESS_DAC_SHIFT;
-    }
-    fmt &= ESS_FMT_MASK;
-
-    db->hwptr = db->swptr = db->total_bytes = db->count = db->error = db->endcleared = 0;
-
-    bytepersec = rate << sample_shift[fmt];
-    bufs = PAGE_SIZE << db->buforder;
-    if (db->ossfragshift) {
-        if ((1000 << db->ossfragshift) < bytepersec)
-            db->fragshift = ld2(bytepersec/1000);
-        else
-            db->fragshift = db->ossfragshift;
-    } else {
-        db->fragshift = ld2(bytepersec/100/(db->subdivision ? db->subdivision : 1));
-        if (db->fragshift < 3)
-            db->fragshift = 3; 
-    }
-    db->numfrag = bufs >> db->fragshift;
-    while (db->numfrag < 4 && db->fragshift > 3) {
-        db->fragshift--;
-        db->numfrag = bufs >> db->fragshift;
-    }
-    db->fragsize = 1 << db->fragshift;
-    if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-        db->numfrag = db->ossmaxfrags;
-    db->fragsamples = db->fragsize >> sample_shift[fmt];
-    db->dmasize = db->numfrag << db->fragshift;
-
-    DPRINTK(DPSTR,"prog_dmabuf: numfrag: %d fragsize: %d dmasize: %d\n",db->numfrag,db->fragsize,db->dmasize);
-
-    memset(db->rawbuf, (fmt & ESS_FMT_16BIT) ? 0 : 0x80, db->dmasize);
-
-    if (rec) 
-        m3_rec_setup(s, fmt, s->rateadc, db->rawbuf, db->dmasize);
-    else 
-        m3_play_setup(s, fmt, s->ratedac, db->rawbuf, db->dmasize);
-
-    db->ready = 1;
-
-    spin_unlock_irqrestore(&s->card->lock, flags);
-
-    return 0;
-}
-
-static void clear_advance(struct m3_state *s)
-{
-    unsigned char c = ((s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_16BIT) ? 0 : 0x80;
-    
-    unsigned char *buf = s->dma_dac.rawbuf;
-    unsigned bsize = s->dma_dac.dmasize;
-    unsigned bptr = s->dma_dac.swptr;
-    unsigned len = s->dma_dac.fragsize;
-    
-    if (bptr + len > bsize) {
-        unsigned x = bsize - bptr;
-        memset(buf + bptr, c, x);
-        /* account for wrapping? */
-        bptr = 0;
-        len -= x;
-    }
-    memset(buf + bptr, c, len);
-}
-
-/* call with spinlock held! */
-static void m3_update_ptr(struct m3_state *s)
-{
-    unsigned hwptr;
-    int diff;
-
-    /* update ADC pointer */
-    if (s->dma_adc.ready) {
-        hwptr = get_dmac(s) % s->dma_adc.dmasize;
-        diff = (s->dma_adc.dmasize + hwptr - s->dma_adc.hwptr) % s->dma_adc.dmasize;
-        s->dma_adc.hwptr = hwptr;
-        s->dma_adc.total_bytes += diff;
-        s->dma_adc.count += diff;
-        if (s->dma_adc.count >= (signed)s->dma_adc.fragsize) 
-            wake_up(&s->dma_adc.wait);
-        if (!s->dma_adc.mapped) {
-            if (s->dma_adc.count > (signed)(s->dma_adc.dmasize - ((3 * s->dma_adc.fragsize) >> 1))) {
-                stop_adc(s); 
-                /* brute force everyone back in sync, sigh */
-                s->dma_adc.count = 0;
-                s->dma_adc.swptr = 0;
-                s->dma_adc.hwptr = 0;
-                s->dma_adc.error++;
-            }
-        }
-    }
-    /* update DAC pointer */
-    if (s->dma_dac.ready) {
-        hwptr = get_dmaa(s) % s->dma_dac.dmasize; 
-        diff = (s->dma_dac.dmasize + hwptr - s->dma_dac.hwptr) % s->dma_dac.dmasize;
-
-        DPRINTK(DPINT,"updating dac: hwptr: %6d diff: %6d count: %6d\n",
-                hwptr,diff,s->dma_dac.count);
-
-        s->dma_dac.hwptr = hwptr;
-        s->dma_dac.total_bytes += diff;
-
-        if (s->dma_dac.mapped) {
-            
-            s->dma_dac.count += diff;
-            if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) {
-                wake_up(&s->dma_dac.wait);
-            }
-        } else {
-
-            s->dma_dac.count -= diff;
-            
-            if (s->dma_dac.count <= 0) {
-                DPRINTK(DPCRAP,"underflow! diff: %d (0x%x) count: %d (0x%x) hw: %d (0x%x) sw: %d (0x%x)\n", 
-                        diff, diff, 
-                        s->dma_dac.count, 
-                        s->dma_dac.count, 
-                    hwptr, hwptr,
-                    s->dma_dac.swptr,
-                    s->dma_dac.swptr);
-                stop_dac(s);
-                /* brute force everyone back in sync, sigh */
-                s->dma_dac.count = 0; 
-                s->dma_dac.swptr = hwptr; 
-                s->dma_dac.error++;
-            } else if (s->dma_dac.count <= (signed)s->dma_dac.fragsize && !s->dma_dac.endcleared) {
-                clear_advance(s);
-                s->dma_dac.endcleared = 1;
-            }
-            if (s->dma_dac.count + (signed)s->dma_dac.fragsize <= (signed)s->dma_dac.dmasize) {
-                wake_up(&s->dma_dac.wait);
-                DPRINTK(DPINT,"waking up DAC count: %d sw: %d hw: %d\n",
-                        s->dma_dac.count, s->dma_dac.swptr, hwptr);
-            }
-        }
-    }
-}
-
-static irqreturn_t m3_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-    struct m3_card *c = (struct m3_card *)dev_id;
-    struct m3_state *s = &c->channels[0];
-    u8 status;
-
-    status = inb(c->iobase+0x1A);
-
-    if(status == 0xff)
-	return IRQ_NONE;
-   
-    /* presumably acking the ints? */
-    outw(status, c->iobase+0x1A); 
-
-    if(c->in_suspend)
-        return IRQ_HANDLED;
-
-    /*
-     * ack an assp int if its running
-     * and has an int pending
-     */
-    if( status & ASSP_INT_PENDING) {
-        u8 ctl = inb(c->iobase + ASSP_CONTROL_B);
-        if( !(ctl & STOP_ASSP_CLOCK)) {
-            ctl = inb(c->iobase + ASSP_HOST_INT_STATUS );
-            if(ctl & DSP2HOST_REQ_TIMER) {
-                outb( DSP2HOST_REQ_TIMER, c->iobase + ASSP_HOST_INT_STATUS);
-                /* update adc/dac info if it was a timer int */
-                spin_lock(&c->lock);
-                m3_update_ptr(s);
-                spin_unlock(&c->lock);
-            }
-        }
-    }
-
-    /* XXX is this needed? */
-    if(status & 0x40) 
-        outb(0x40, c->iobase+0x1A);
-    return IRQ_HANDLED;
-}
-
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT PFX "invalid magic value in %s\n";
-
-#define VALIDATE_MAGIC(FOO,MAG)                         \
-({                                                \
-    if (!(FOO) || (FOO)->magic != MAG) { \
-        printk(invalid_magic,__FUNCTION__);            \
-        return -ENXIO;                    \
-    }                                         \
-})
-
-#define VALIDATE_STATE(a) VALIDATE_MAGIC(a,M3_STATE_MAGIC)
-#define VALIDATE_CARD(a) VALIDATE_MAGIC(a,M3_CARD_MAGIC)
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct m3_state *s, int nonblock)
-{
-    DECLARE_WAITQUEUE(wait,current);
-    unsigned long flags;
-    int count;
-    signed long tmo;
-
-    if (s->dma_dac.mapped || !s->dma_dac.ready)
-        return 0;
-    set_current_state(TASK_INTERRUPTIBLE);
-    add_wait_queue(&s->dma_dac.wait, &wait);
-    for (;;) {
-        spin_lock_irqsave(&s->card->lock, flags);
-        count = s->dma_dac.count;
-        spin_unlock_irqrestore(&s->card->lock, flags);
-        if (count <= 0)
-            break;
-        if (signal_pending(current))
-            break;
-        if (nonblock) {
-            remove_wait_queue(&s->dma_dac.wait, &wait);
-            set_current_state(TASK_RUNNING);
-            return -EBUSY;
-        }
-        tmo = (count * HZ) / s->ratedac;
-        tmo >>= sample_shift[(s->fmt >> ESS_DAC_SHIFT) & ESS_FMT_MASK];
-        /* XXX this is just broken.  someone is waking us up alot, or schedule_timeout is broken.
-            or something.  who cares. - zach */
-        if (!schedule_timeout(tmo ? tmo : 1) && tmo)
-            DPRINTK(DPCRAP,"dma timed out?? %ld\n",jiffies);
-    }
-    remove_wait_queue(&s->dma_dac.wait, &wait);
-    set_current_state(TASK_RUNNING);
-    if (signal_pending(current))
-            return -ERESTARTSYS;
-    return 0;
-}
-
-static ssize_t m3_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-    struct m3_state *s = (struct m3_state *)file->private_data;
-    ssize_t ret;
-    unsigned long flags;
-    unsigned swptr;
-    int cnt;
-    
-    VALIDATE_STATE(s);
-    if (s->dma_adc.mapped)
-        return -ENXIO;
-    if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-        return ret;
-    if (!access_ok(VERIFY_WRITE, buffer, count))
-        return -EFAULT;
-    ret = 0;
-
-    spin_lock_irqsave(&s->card->lock, flags);
-
-    while (count > 0) {
-        int timed_out;
-
-        swptr = s->dma_adc.swptr;
-        cnt = s->dma_adc.dmasize-swptr;
-        if (s->dma_adc.count < cnt)
-            cnt = s->dma_adc.count;
-
-        if (cnt > count)
-            cnt = count;
-
-        if (cnt <= 0) {
-            start_adc(s);
-            if (file->f_flags & O_NONBLOCK) 
-            {
-                ret = ret ? ret : -EAGAIN;
-                goto out;
-            }
-
-            spin_unlock_irqrestore(&s->card->lock, flags);
-            timed_out = interruptible_sleep_on_timeout(&s->dma_adc.wait, HZ) == 0;
-            spin_lock_irqsave(&s->card->lock, flags);
-
-            if(timed_out) {
-                printk("read: chip lockup? dmasz %u fragsz %u count %u hwptr %u swptr %u\n",
-                       s->dma_adc.dmasize, s->dma_adc.fragsize, s->dma_adc.count, 
-                       s->dma_adc.hwptr, s->dma_adc.swptr);
-                stop_adc(s);
-                set_dmac(s, virt_to_bus(s->dma_adc.rawbuf), s->dma_adc.numfrag << s->dma_adc.fragshift);
-                s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
-            }
-            if (signal_pending(current)) 
-            {
-                ret = ret ? ret : -ERESTARTSYS;
-                goto out;
-            }
-            continue;
-        }
-    
-        spin_unlock_irqrestore(&s->card->lock, flags);
-        if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
-            ret = ret ? ret : -EFAULT;
-            return ret;
-        }
-        spin_lock_irqsave(&s->card->lock, flags);
-
-        swptr = (swptr + cnt) % s->dma_adc.dmasize;
-        s->dma_adc.swptr = swptr;
-        s->dma_adc.count -= cnt;
-        count -= cnt;
-        buffer += cnt;
-        ret += cnt;
-        start_adc(s);
-    }
-
-out:
-    spin_unlock_irqrestore(&s->card->lock, flags);
-    return ret;
-}
-
-static ssize_t m3_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-    struct m3_state *s = (struct m3_state *)file->private_data;
-    ssize_t ret;
-    unsigned long flags;
-    unsigned swptr;
-    int cnt;
-    
-    VALIDATE_STATE(s);
-    if (s->dma_dac.mapped)
-        return -ENXIO;
-    if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-        return ret;
-    if (!access_ok(VERIFY_READ, buffer, count))
-        return -EFAULT;
-    ret = 0;
-
-    spin_lock_irqsave(&s->card->lock, flags);
-
-    while (count > 0) {
-        int timed_out;
-
-        if (s->dma_dac.count < 0) {
-            s->dma_dac.count = 0;
-            s->dma_dac.swptr = s->dma_dac.hwptr;
-        }
-        swptr = s->dma_dac.swptr;
-
-        cnt = s->dma_dac.dmasize-swptr;
-
-        if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
-            cnt = s->dma_dac.dmasize - s->dma_dac.count;
-
-
-        if (cnt > count)
-            cnt = count;
-
-        if (cnt <= 0) {
-            start_dac(s);
-            if (file->f_flags & O_NONBLOCK) {
-                if(!ret) ret = -EAGAIN;
-                goto out;
-            }
-            spin_unlock_irqrestore(&s->card->lock, flags);
-            timed_out = interruptible_sleep_on_timeout(&s->dma_dac.wait, HZ) == 0;
-            spin_lock_irqsave(&s->card->lock, flags);
-            if(timed_out) {
-                DPRINTK(DPCRAP,"write: chip lockup? dmasz %u fragsz %u count %u hwptr %u swptr %u\n",
-                       s->dma_dac.dmasize, s->dma_dac.fragsize, s->dma_dac.count, 
-                       s->dma_dac.hwptr, s->dma_dac.swptr);
-                stop_dac(s);
-                set_dmaa(s, virt_to_bus(s->dma_dac.rawbuf), s->dma_dac.numfrag << s->dma_dac.fragshift);
-                s->dma_dac.count = s->dma_dac.hwptr = s->dma_dac.swptr = 0;
-            }
-            if (signal_pending(current)) {
-                if (!ret) ret = -ERESTARTSYS;
-                goto out;
-            }
-            continue;
-        }
-        spin_unlock_irqrestore(&s->card->lock, flags);
-        if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt)) {
-            if (!ret) ret = -EFAULT;
-            return ret;
-        }
-        spin_lock_irqsave(&s->card->lock, flags);
-
-        DPRINTK(DPSYS,"wrote %6d bytes at sw: %6d cnt: %6d while hw: %6d\n",
-                cnt, swptr, s->dma_dac.count, s->dma_dac.hwptr);
-        
-        swptr = (swptr + cnt) % s->dma_dac.dmasize;
-
-        s->dma_dac.swptr = swptr;
-        s->dma_dac.count += cnt;
-        s->dma_dac.endcleared = 0;
-        count -= cnt;
-        buffer += cnt;
-        ret += cnt;
-        start_dac(s);
-    }
-out:
-    spin_unlock_irqrestore(&s->card->lock, flags);
-    return ret;
-}
-
-static unsigned int m3_poll(struct file *file, struct poll_table_struct *wait)
-{
-    struct m3_state *s = (struct m3_state *)file->private_data;
-    unsigned long flags;
-    unsigned int mask = 0;
-
-    VALIDATE_STATE(s);
-    if (file->f_mode & FMODE_WRITE)
-        poll_wait(file, &s->dma_dac.wait, wait);
-    if (file->f_mode & FMODE_READ)
-        poll_wait(file, &s->dma_adc.wait, wait);
-
-    spin_lock_irqsave(&s->card->lock, flags);
-    m3_update_ptr(s);
-
-    if (file->f_mode & FMODE_READ) {
-        if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-            mask |= POLLIN | POLLRDNORM;
-    }
-    if (file->f_mode & FMODE_WRITE) {
-        if (s->dma_dac.mapped) {
-            if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) 
-                mask |= POLLOUT | POLLWRNORM;
-        } else {
-            if ((signed)s->dma_dac.dmasize >= s->dma_dac.count + (signed)s->dma_dac.fragsize)
-                mask |= POLLOUT | POLLWRNORM;
-        }
-    }
-
-    spin_unlock_irqrestore(&s->card->lock, flags);
-    return mask;
-}
-
-static int m3_mmap(struct file *file, struct vm_area_struct *vma)
-{
-    struct m3_state *s = (struct m3_state *)file->private_data;
-    unsigned long max_size, size, start, offset;
-    struct dmabuf *db;
-    int ret = -EINVAL;
-
-    VALIDATE_STATE(s);
-    if (vma->vm_flags & VM_WRITE) {
-        if ((ret = prog_dmabuf(s, 0)) != 0)
-            return ret;
-        db = &s->dma_dac;
-    } else 
-    if (vma->vm_flags & VM_READ) {
-        if ((ret = prog_dmabuf(s, 1)) != 0)
-            return ret;
-        db = &s->dma_adc;
-    } else  
-        return -EINVAL;
-
-    max_size = db->dmasize;
-
-    start = vma->vm_start;
-    offset = (vma->vm_pgoff << PAGE_SHIFT);
-    size = vma->vm_end - vma->vm_start;
-
-    if(size > max_size)
-        goto out;
-    if(offset > max_size - size)
-        goto out;
-
-    /*
-     * this will be ->nopage() once I can 
-     * ask Jeff what the hell I'm doing wrong.
-     */
-    ret = -EAGAIN;
-    if (remap_pfn_range(vma, vma->vm_start,
-			virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-			size, vma->vm_page_prot))
-        goto out;
-
-    db->mapped = 1;
-    ret = 0;
-
-out:
-    return ret;
-}
-
-/*
- * this function is a disaster..
- */
-#define get_user_ret(x, ptr,  ret) ({ if(get_user(x, ptr)) return ret; })
-static int m3_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-    struct m3_state *s = (struct m3_state *)file->private_data;
-	struct m3_card *card=s->card;
-    unsigned long flags;
-    audio_buf_info abinfo;
-    count_info cinfo;
-    int val, mapped, ret;
-    unsigned char fmtm, fmtd;
-    void __user *argp = (void __user *)arg;
-    int __user *p = argp;
-
-    VALIDATE_STATE(s);
-
-    mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-        ((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-
-    DPRINTK(DPSYS,"m3_ioctl: cmd %d\n", cmd);
-
-    switch (cmd) {
-    case OSS_GETVERSION:
-        return put_user(SOUND_VERSION, p);
-
-    case SNDCTL_DSP_SYNC:
-        if (file->f_mode & FMODE_WRITE)
-            return drain_dac(s, file->f_flags & O_NONBLOCK);
-        return 0;
-        
-    case SNDCTL_DSP_SETDUPLEX:
-        /* XXX fix */
-        return 0;
-
-    case SNDCTL_DSP_GETCAPS:
-        return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-        
-    case SNDCTL_DSP_RESET:
-        spin_lock_irqsave(&card->lock, flags);
-        if (file->f_mode & FMODE_WRITE) {
-            stop_dac(s);
-            synchronize_irq(s->card->pcidev->irq);
-            s->dma_dac.swptr = s->dma_dac.hwptr = s->dma_dac.count = s->dma_dac.total_bytes = 0;
-        }
-        if (file->f_mode & FMODE_READ) {
-            stop_adc(s);
-            synchronize_irq(s->card->pcidev->irq);
-            s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-        }
-        spin_unlock_irqrestore(&card->lock, flags);
-        return 0;
-
-    case SNDCTL_DSP_SPEED:
-        get_user_ret(val, p, -EFAULT);
-        spin_lock_irqsave(&card->lock, flags);
-        if (val >= 0) {
-            if (file->f_mode & FMODE_READ) {
-                stop_adc(s);
-                s->dma_adc.ready = 0;
-                set_adc_rate(s, val);
-            }
-            if (file->f_mode & FMODE_WRITE) {
-                stop_dac(s);
-                s->dma_dac.ready = 0;
-                set_dac_rate(s, val);
-            }
-        }
-        spin_unlock_irqrestore(&card->lock, flags);
-        return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-        
-    case SNDCTL_DSP_STEREO:
-        get_user_ret(val, p, -EFAULT);
-        spin_lock_irqsave(&card->lock, flags);
-        fmtd = 0;
-        fmtm = ~0;
-        if (file->f_mode & FMODE_READ) {
-            stop_adc(s);
-            s->dma_adc.ready = 0;
-            if (val)
-                fmtd |= ESS_FMT_STEREO << ESS_ADC_SHIFT;
-            else
-                fmtm &= ~(ESS_FMT_STEREO << ESS_ADC_SHIFT);
-        }
-        if (file->f_mode & FMODE_WRITE) {
-            stop_dac(s);
-            s->dma_dac.ready = 0;
-            if (val)
-                fmtd |= ESS_FMT_STEREO << ESS_DAC_SHIFT;
-            else
-                fmtm &= ~(ESS_FMT_STEREO << ESS_DAC_SHIFT);
-        }
-        set_fmt(s, fmtm, fmtd);
-        spin_unlock_irqrestore(&card->lock, flags);
-        return 0;
-
-    case SNDCTL_DSP_CHANNELS:
-        get_user_ret(val, p, -EFAULT);
-        spin_lock_irqsave(&card->lock, flags);
-        if (val != 0) {
-            fmtd = 0;
-            fmtm = ~0;
-            if (file->f_mode & FMODE_READ) {
-                stop_adc(s);
-                s->dma_adc.ready = 0;
-                if (val >= 2)
-                    fmtd |= ESS_FMT_STEREO << ESS_ADC_SHIFT;
-                else
-                    fmtm &= ~(ESS_FMT_STEREO << ESS_ADC_SHIFT);
-            }
-            if (file->f_mode & FMODE_WRITE) {
-                stop_dac(s);
-                s->dma_dac.ready = 0;
-                if (val >= 2)
-                    fmtd |= ESS_FMT_STEREO << ESS_DAC_SHIFT;
-                else
-                    fmtm &= ~(ESS_FMT_STEREO << ESS_DAC_SHIFT);
-            }
-            set_fmt(s, fmtm, fmtd);
-        }
-        spin_unlock_irqrestore(&card->lock, flags);
-        return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (ESS_FMT_STEREO << ESS_ADC_SHIFT) 
-                       : (ESS_FMT_STEREO << ESS_DAC_SHIFT))) ? 2 : 1, p);
-        
-    case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-        return put_user(AFMT_U8|AFMT_S16_LE, p);
-        
-    case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-        get_user_ret(val, p, -EFAULT);
-        spin_lock_irqsave(&card->lock, flags);
-        if (val != AFMT_QUERY) {
-            fmtd = 0;
-            fmtm = ~0;
-            if (file->f_mode & FMODE_READ) {
-                stop_adc(s);
-                s->dma_adc.ready = 0;
-                if (val == AFMT_S16_LE)
-                    fmtd |= ESS_FMT_16BIT << ESS_ADC_SHIFT;
-                else
-                    fmtm &= ~(ESS_FMT_16BIT << ESS_ADC_SHIFT);
-            }
-            if (file->f_mode & FMODE_WRITE) {
-                stop_dac(s);
-                s->dma_dac.ready = 0;
-                if (val == AFMT_S16_LE)
-                    fmtd |= ESS_FMT_16BIT << ESS_DAC_SHIFT;
-                else
-                    fmtm &= ~(ESS_FMT_16BIT << ESS_DAC_SHIFT);
-            }
-            set_fmt(s, fmtm, fmtd);
-        }
-        spin_unlock_irqrestore(&card->lock, flags);
-        return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? 
-            (ESS_FMT_16BIT << ESS_ADC_SHIFT) 
-            : (ESS_FMT_16BIT << ESS_DAC_SHIFT))) ? 
-                AFMT_S16_LE : 
-                AFMT_U8, 
-            p);
-        
-    case SNDCTL_DSP_POST:
-        return 0;
-
-    case SNDCTL_DSP_GETTRIGGER:
-        val = 0;
-        if ((file->f_mode & FMODE_READ) && (s->enable & ADC_RUNNING))
-            val |= PCM_ENABLE_INPUT;
-        if ((file->f_mode & FMODE_WRITE) && (s->enable & DAC_RUNNING)) 
-            val |= PCM_ENABLE_OUTPUT;
-        return put_user(val, p);
-        
-    case SNDCTL_DSP_SETTRIGGER:
-        get_user_ret(val, p, -EFAULT);
-        if (file->f_mode & FMODE_READ) {
-            if (val & PCM_ENABLE_INPUT) {
-                if (!s->dma_adc.ready && (ret =  prog_dmabuf(s, 1)))
-                    return ret;
-                start_adc(s);
-            } else
-                stop_adc(s);
-        }
-        if (file->f_mode & FMODE_WRITE) {
-            if (val & PCM_ENABLE_OUTPUT) {
-                if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-                    return ret;
-                start_dac(s);
-            } else
-                stop_dac(s);
-        }
-        return 0;
-
-    case SNDCTL_DSP_GETOSPACE:
-        if (!(file->f_mode & FMODE_WRITE))
-            return -EINVAL;
-        if (!(s->enable & DAC_RUNNING) && (val = prog_dmabuf(s, 0)) != 0)
-            return val;
-        spin_lock_irqsave(&card->lock, flags);
-        m3_update_ptr(s);
-        abinfo.fragsize = s->dma_dac.fragsize;
-        abinfo.bytes = s->dma_dac.dmasize - s->dma_dac.count;
-        abinfo.fragstotal = s->dma_dac.numfrag;
-        abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;      
-        spin_unlock_irqrestore(&card->lock, flags);
-        return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-    case SNDCTL_DSP_GETISPACE:
-        if (!(file->f_mode & FMODE_READ))
-            return -EINVAL;
-        if (!(s->enable & ADC_RUNNING) && (val = prog_dmabuf(s, 1)) != 0)
-            return val;
-        spin_lock_irqsave(&card->lock, flags);
-        m3_update_ptr(s);
-        abinfo.fragsize = s->dma_adc.fragsize;
-        abinfo.bytes = s->dma_adc.count;
-        abinfo.fragstotal = s->dma_adc.numfrag;
-        abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;      
-        spin_unlock_irqrestore(&card->lock, flags);
-        return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-        
-    case SNDCTL_DSP_NONBLOCK:
-        file->f_flags |= O_NONBLOCK;
-        return 0;
-
-    case SNDCTL_DSP_GETODELAY:
-        if (!(file->f_mode & FMODE_WRITE))
-            return -EINVAL;
-        spin_lock_irqsave(&card->lock, flags);
-        m3_update_ptr(s);
-        val = s->dma_dac.count;
-        spin_unlock_irqrestore(&card->lock, flags);
-        return put_user(val, p);
-
-    case SNDCTL_DSP_GETIPTR:
-        if (!(file->f_mode & FMODE_READ))
-            return -EINVAL;
-        spin_lock_irqsave(&card->lock, flags);
-        m3_update_ptr(s);
-        cinfo.bytes = s->dma_adc.total_bytes;
-        cinfo.blocks = s->dma_adc.count >> s->dma_adc.fragshift;
-        cinfo.ptr = s->dma_adc.hwptr;
-        if (s->dma_adc.mapped)
-            s->dma_adc.count &= s->dma_adc.fragsize-1;
-        spin_unlock_irqrestore(&card->lock, flags);
-	if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-		return -EFAULT;
-	return 0;
-
-    case SNDCTL_DSP_GETOPTR:
-        if (!(file->f_mode & FMODE_WRITE))
-            return -EINVAL;
-        spin_lock_irqsave(&card->lock, flags);
-        m3_update_ptr(s);
-        cinfo.bytes = s->dma_dac.total_bytes;
-        cinfo.blocks = s->dma_dac.count >> s->dma_dac.fragshift;
-        cinfo.ptr = s->dma_dac.hwptr;
-        if (s->dma_dac.mapped)
-            s->dma_dac.count &= s->dma_dac.fragsize-1;
-        spin_unlock_irqrestore(&card->lock, flags);
-	if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-		return -EFAULT;
-	return 0;
-
-    case SNDCTL_DSP_GETBLKSIZE:
-        if (file->f_mode & FMODE_WRITE) {
-            if ((val = prog_dmabuf(s, 0)))
-                return val;
-            return put_user(s->dma_dac.fragsize, p);
-        }
-        if ((val = prog_dmabuf(s, 1)))
-            return val;
-        return put_user(s->dma_adc.fragsize, p);
-
-    case SNDCTL_DSP_SETFRAGMENT:
-        get_user_ret(val, p, -EFAULT);
-        spin_lock_irqsave(&card->lock, flags);
-        if (file->f_mode & FMODE_READ) {
-            s->dma_adc.ossfragshift = val & 0xffff;
-            s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-            if (s->dma_adc.ossfragshift < 4)
-                s->dma_adc.ossfragshift = 4;
-            if (s->dma_adc.ossfragshift > 15)
-                s->dma_adc.ossfragshift = 15;
-            if (s->dma_adc.ossmaxfrags < 4)
-                s->dma_adc.ossmaxfrags = 4;
-        }
-        if (file->f_mode & FMODE_WRITE) {
-            s->dma_dac.ossfragshift = val & 0xffff;
-            s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-            if (s->dma_dac.ossfragshift < 4)
-                s->dma_dac.ossfragshift = 4;
-            if (s->dma_dac.ossfragshift > 15)
-                s->dma_dac.ossfragshift = 15;
-            if (s->dma_dac.ossmaxfrags < 4)
-                s->dma_dac.ossmaxfrags = 4;
-        }
-        spin_unlock_irqrestore(&card->lock, flags);
-        return 0;
-
-    case SNDCTL_DSP_SUBDIVIDE:
-        if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-            (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-            return -EINVAL;
-                get_user_ret(val, p, -EFAULT);
-        if (val != 1 && val != 2 && val != 4)
-            return -EINVAL;
-        if (file->f_mode & FMODE_READ)
-            s->dma_adc.subdivision = val;
-        if (file->f_mode & FMODE_WRITE)
-            s->dma_dac.subdivision = val;
-        return 0;
-
-    case SOUND_PCM_READ_RATE:
-        return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-
-    case SOUND_PCM_READ_CHANNELS:
-        return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (ESS_FMT_STEREO << ESS_ADC_SHIFT) 
-                       : (ESS_FMT_STEREO << ESS_DAC_SHIFT))) ? 2 : 1, p);
-
-    case SOUND_PCM_READ_BITS:
-        return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (ESS_FMT_16BIT << ESS_ADC_SHIFT) 
-                       : (ESS_FMT_16BIT << ESS_DAC_SHIFT))) ? 16 : 8, p);
-
-    case SOUND_PCM_WRITE_FILTER:
-    case SNDCTL_DSP_SETSYNCRO:
-    case SOUND_PCM_READ_FILTER:
-        return -EINVAL;
-        
-    }
-    return -EINVAL;
-}
-
-static int
-allocate_dmabuf(struct pci_dev *pci_dev, struct dmabuf *db)
-{
-    int order;
-
-    DPRINTK(DPSTR,"allocating for dmabuf %p\n", db);
-
-    /* 
-     * alloc as big a chunk as we can, start with 
-     * 64k 'cause we're insane.  based on order cause
-     * the amazingly complicated prog_dmabuf wants it.
-     *
-     * pci_alloc_sonsistent guarantees that it won't cross a natural
-     * boundary; the m3 hardware can't have dma cross a 64k bus
-     * address boundary.
-     */
-    for (order = 16-PAGE_SHIFT; order >= 1; order--) {
-        db->rawbuf = pci_alloc_consistent(pci_dev, PAGE_SIZE << order,
-                        &(db->handle));
-        if(db->rawbuf)
-            break;
-    }
-
-    if (!db->rawbuf)
-        return 1;
-
-    DPRINTK(DPSTR,"allocated %ld (%d) bytes at %p\n",
-            PAGE_SIZE<<order, order, db->rawbuf);
-
-    {
-        struct page *page, *pend;
-
-        pend = virt_to_page(db->rawbuf + (PAGE_SIZE << order) - 1);
-        for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-            SetPageReserved(page);
-    }
-
-
-    db->buforder = order;
-    db->ready = 0;
-    db->mapped = 0;
-
-    return 0;
-}
-
-static void
-nuke_lists(struct m3_card *card, struct dmabuf *db)
-{
-    m3_remove_list(card, &(card->dma_list), db->dma_index);
-    m3_remove_list(card, &(card->msrc_list), db->msrc_index);
-    db->in_lists = 0;
-}
-
-static void
-free_dmabuf(struct pci_dev *pci_dev, struct dmabuf *db)
-{
-    if(db->rawbuf == NULL)
-        return;
-
-    DPRINTK(DPSTR,"freeing %p from dmabuf %p\n",db->rawbuf, db);
-
-    {
-        struct page *page, *pend;
-        pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-        for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-            ClearPageReserved(page);
-    }
-
-
-    pci_free_consistent(pci_dev, PAGE_SIZE << db->buforder,
-            db->rawbuf, db->handle);
-
-    db->rawbuf = NULL;
-    db->buforder = 0;
-    db->mapped = 0;
-    db->ready = 0;
-}
-
-static int m3_open(struct inode *inode, struct file *file)
-{
-    unsigned int minor = iminor(inode);
-    struct m3_card *c;
-    struct m3_state *s = NULL;
-    int i;
-    unsigned char fmtm = ~0, fmts = 0;
-    unsigned long flags;
-
-    /*
-     *    Scan the cards and find the channel. We only
-     *    do this at open time so it is ok
-     */
-    for(c = devs ; c != NULL ; c = c->next) {
-
-        for(i=0;i<NR_DSPS;i++) {
-
-            if(c->channels[i].dev_audio < 0)
-                continue;
-            if((c->channels[i].dev_audio ^ minor) & ~0xf)
-                continue;
-
-            s = &c->channels[i];
-            break;
-        }
-    }
-        
-    if (!s)
-        return -ENODEV;
-        
-    VALIDATE_STATE(s);
-
-    file->private_data = s;
-
-    /* wait for device to become free */
-    mutex_lock(&s->open_mutex);
-    while (s->open_mode & file->f_mode) {
-        if (file->f_flags & O_NONBLOCK) {
-            mutex_unlock(&s->open_mutex);
-            return -EWOULDBLOCK;
-        }
-        mutex_unlock(&s->open_mutex);
-        interruptible_sleep_on(&s->open_wait);
-        if (signal_pending(current))
-            return -ERESTARTSYS;
-        mutex_lock(&s->open_mutex);
-    }
-    
-    spin_lock_irqsave(&c->lock, flags);
-
-    if (file->f_mode & FMODE_READ) {
-        fmtm &= ~((ESS_FMT_STEREO | ESS_FMT_16BIT) << ESS_ADC_SHIFT);
-        if ((minor & 0xf) == SND_DEV_DSP16)
-            fmts |= ESS_FMT_16BIT << ESS_ADC_SHIFT; 
-
-        s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
-        set_adc_rate(s, 8000);
-    }
-    if (file->f_mode & FMODE_WRITE) {
-        fmtm &= ~((ESS_FMT_STEREO | ESS_FMT_16BIT) << ESS_DAC_SHIFT);
-        if ((minor & 0xf) == SND_DEV_DSP16)
-            fmts |= ESS_FMT_16BIT << ESS_DAC_SHIFT;
-
-        s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags = s->dma_dac.subdivision = 0;
-        set_dac_rate(s, 8000);
-    }
-    set_fmt(s, fmtm, fmts);
-    s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-
-    mutex_unlock(&s->open_mutex);
-    spin_unlock_irqrestore(&c->lock, flags);
-    return nonseekable_open(inode, file);
-}
-
-static int m3_release(struct inode *inode, struct file *file)
-{
-    struct m3_state *s = (struct m3_state *)file->private_data;
-	struct m3_card *card=s->card;
-    unsigned long flags;
-
-    VALIDATE_STATE(s);
-    if (file->f_mode & FMODE_WRITE)
-        drain_dac(s, file->f_flags & O_NONBLOCK);
-
-    mutex_lock(&s->open_mutex);
-    spin_lock_irqsave(&card->lock, flags);
-
-    if (file->f_mode & FMODE_WRITE) {
-        stop_dac(s);
-        if(s->dma_dac.in_lists) {
-            m3_remove_list(s->card, &(s->card->mixer_list), s->dma_dac.mixer_index);
-            nuke_lists(s->card, &(s->dma_dac));
-        }
-    }
-    if (file->f_mode & FMODE_READ) {
-        stop_adc(s);
-        if(s->dma_adc.in_lists) {
-            m3_remove_list(s->card, &(s->card->adc1_list), s->dma_adc.adc1_index);
-            nuke_lists(s->card, &(s->dma_adc));
-        }
-    }
-        
-    s->open_mode &= (~file->f_mode) & (FMODE_READ|FMODE_WRITE);
-
-    spin_unlock_irqrestore(&card->lock, flags);
-    mutex_unlock(&s->open_mutex);
-    wake_up(&s->open_wait);
-
-    return 0;
-}
-
-/*
- * Wait for the ac97 serial bus to be free.
- * return nonzero if the bus is still busy.
- */
-static int m3_ac97_wait(struct m3_card *card)
-{
-    int i = 10000;
-
-    while( (m3_inb(card, 0x30) & 1) && i--) ;
-
-    return i == 0;
-}
-
-static u16 m3_ac97_read(struct ac97_codec *codec, u8 reg)
-{
-    u16 ret = 0;
-    struct m3_card *card = codec->private_data;
-
-    spin_lock(&card->ac97_lock);
-
-    if(m3_ac97_wait(card)) {
-        printk(KERN_ERR PFX "serial bus busy reading reg 0x%x\n",reg);
-        goto out;
-    }
-
-    m3_outb(card, 0x80 | (reg & 0x7f), 0x30);
-
-    if(m3_ac97_wait(card)) {
-        printk(KERN_ERR PFX "serial bus busy finishing read reg 0x%x\n",reg);
-        goto out;
-    }
-
-    ret =  m3_inw(card, 0x32);
-    DPRINTK(DPCRAP,"reading 0x%04x from 0x%02x\n",ret, reg);
-
-out:
-    spin_unlock(&card->ac97_lock);
-    return ret;
-}
-
-static void m3_ac97_write(struct ac97_codec *codec, u8 reg, u16 val)
-{
-    struct m3_card *card = codec->private_data;
-
-    spin_lock(&card->ac97_lock);
-
-    if(m3_ac97_wait(card)) {
-        printk(KERN_ERR PFX "serial bus busy writing 0x%x to 0x%x\n",val, reg);
-        goto out;
-    }
-    DPRINTK(DPCRAP,"writing 0x%04x  to  0x%02x\n", val, reg);
-
-    m3_outw(card, val, 0x32);
-    m3_outb(card, reg & 0x7f, 0x30);
-out:
-    spin_unlock(&card->ac97_lock);
-}
-/* OSS /dev/mixer file operation methods */
-static int m3_open_mixdev(struct inode *inode, struct file *file)
-{
-    unsigned int minor = iminor(inode);
-    struct m3_card *card = devs;
-
-    for (card = devs; card != NULL; card = card->next) {
-        if((card->ac97 != NULL) && (card->ac97->dev_mixer == minor))
-                break;
-    }
-
-    if (!card) {
-        return -ENODEV;
-    }
-
-    file->private_data = card->ac97;
-
-    return nonseekable_open(inode, file);
-}
-
-static int m3_release_mixdev(struct inode *inode, struct file *file)
-{
-    return 0;
-}
-
-static int m3_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd,
-                                    unsigned long arg)
-{
-    struct ac97_codec *codec = (struct ac97_codec *)file->private_data;
-
-    return codec->mixer_ioctl(codec, cmd, arg);
-}
-
-static struct file_operations m3_mixer_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek  = no_llseek,
-	.ioctl	 = m3_ioctl_mixdev,
-	.open	 = m3_open_mixdev,
-	.release = m3_release_mixdev,
-};
-
-static void remote_codec_config(int io, int isremote)
-{
-    isremote = isremote ? 1 : 0;
-
-    outw(  (inw(io + RING_BUS_CTRL_B) & ~SECOND_CODEC_ID_MASK) | isremote,
-            io + RING_BUS_CTRL_B);
-    outw(  (inw(io + SDO_OUT_DEST_CTRL) & ~COMMAND_ADDR_OUT) | isremote,
-            io + SDO_OUT_DEST_CTRL);
-    outw(  (inw(io + SDO_IN_DEST_CTRL) & ~STATUS_ADDR_IN) | isremote,
-            io + SDO_IN_DEST_CTRL);
-}
-
-/* 
- * hack, returns non zero on err 
- */
-static int try_read_vendor(struct m3_card *card)
-{
-    u16 ret;
-
-    if(m3_ac97_wait(card)) 
-        return 1;
-
-    m3_outb(card, 0x80 | (AC97_VENDOR_ID1 & 0x7f), 0x30);
-
-    if(m3_ac97_wait(card)) 
-        return 1;
-
-    ret =  m3_inw(card, 0x32);
-
-    return (ret == 0) || (ret == 0xffff);
-}
-
-static void m3_codec_reset(struct m3_card *card, int busywait)
-{
-    u16 dir;
-    int delay1 = 0, delay2 = 0, i;
-    int io = card->iobase;
-
-    switch (card->card_type) {
-        /*
-         * the onboard codec on the allegro seems 
-         * to want to wait a very long time before
-         * coming back to life 
-         */
-        case ESS_ALLEGRO:
-            delay1 = 50;
-            delay2 = 800;
-        break;
-        case ESS_MAESTRO3:
-        case ESS_MAESTRO3HW:
-            delay1 = 20;
-            delay2 = 500;
-        break;
-    }
-
-    for(i = 0; i < 5; i ++) {
-        dir = inw(io + GPIO_DIRECTION);
-        dir |= 0x10; /* assuming pci bus master? */
-
-        remote_codec_config(io, 0);
-
-        outw(IO_SRAM_ENABLE, io + RING_BUS_CTRL_A);
-        udelay(20);
-
-        outw(dir & ~GPO_PRIMARY_AC97 , io + GPIO_DIRECTION);
-        outw(~GPO_PRIMARY_AC97 , io + GPIO_MASK);
-        outw(0, io + GPIO_DATA);
-        outw(dir | GPO_PRIMARY_AC97, io + GPIO_DIRECTION);
-
-        if(busywait)  {
-            mdelay(delay1);
-        } else {
-            set_current_state(TASK_UNINTERRUPTIBLE);
-            schedule_timeout((delay1 * HZ) / 1000);
-        }
-
-        outw(GPO_PRIMARY_AC97, io + GPIO_DATA);
-        udelay(5);
-        /* ok, bring back the ac-link */
-        outw(IO_SRAM_ENABLE | SERIAL_AC_LINK_ENABLE, io + RING_BUS_CTRL_A);
-        outw(~0, io + GPIO_MASK);
-
-        if(busywait) {
-            mdelay(delay2);
-        } else {
-            set_current_state(TASK_UNINTERRUPTIBLE);
-            schedule_timeout((delay2 * HZ) / 1000);
-        }
-        if(! try_read_vendor(card))
-            break;
-
-        delay1 += 10;
-        delay2 += 100;
-
-        DPRINTK(DPMOD, "retrying codec reset with delays of %d and %d ms\n",
-                delay1, delay2);
-    }
-
-#if 0
-    /* more gung-ho reset that doesn't
-     * seem to work anywhere :)
-     */
-    tmp = inw(io + RING_BUS_CTRL_A);
-    outw(RAC_SDFS_ENABLE|LAC_SDFS_ENABLE, io + RING_BUS_CTRL_A);
-    mdelay(20);
-    outw(tmp, io + RING_BUS_CTRL_A);
-    mdelay(50);
-#endif
-}
-
-static int __devinit m3_codec_install(struct m3_card *card)
-{
-    struct ac97_codec *codec;
-
-    if ((codec = ac97_alloc_codec()) == NULL)
-        return -ENOMEM;
-
-    codec->private_data = card;
-    codec->codec_read = m3_ac97_read;
-    codec->codec_write = m3_ac97_write;
-    /* someday we should support secondary codecs.. */
-    codec->id = 0;
-
-    if (ac97_probe_codec(codec) == 0) {
-        printk(KERN_ERR PFX "codec probe failed\n");
-        ac97_release_codec(codec);
-        return -1;
-    }
-
-    if ((codec->dev_mixer = register_sound_mixer(&m3_mixer_fops, -1)) < 0) {
-        printk(KERN_ERR PFX "couldn't register mixer!\n");
-        ac97_release_codec(codec);
-        return -1;
-    }
-
-    card->ac97 = codec;
-
-    return 0;
-}
-
-
-#define MINISRC_LPF_LEN 10
-static u16 minisrc_lpf[MINISRC_LPF_LEN] = {
-    0X0743, 0X1104, 0X0A4C, 0XF88D, 0X242C,
-    0X1023, 0X1AA9, 0X0B60, 0XEFDD, 0X186F
-};
-static void m3_assp_init(struct m3_card *card)
-{
-    int i;
-
-    /* zero kernel data */
-    for(i = 0 ; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)
-        m3_assp_write(card, MEMTYPE_INTERNAL_DATA, 
-                KDATA_BASE_ADDR + i, 0);
-
-    /* zero mixer data? */
-    for(i = 0 ; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)
-        m3_assp_write(card, MEMTYPE_INTERNAL_DATA, 
-                KDATA_BASE_ADDR2 + i, 0);
-
-    /* init dma pointer */
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA, 
-            KDATA_CURRENT_DMA, 
-            KDATA_DMA_XFER0);
-
-    /* write kernel into code memory.. */
-    for(i = 0 ; i < sizeof(assp_kernel_image) / 2; i++) {
-        m3_assp_write(card, MEMTYPE_INTERNAL_CODE, 
-                REV_B_CODE_MEMORY_BEGIN + i, 
-                assp_kernel_image[i]);
-    }
-
-    /*
-     * We only have this one client and we know that 0x400
-     * is free in our kernel's mem map, so lets just
-     * drop it there.  It seems that the minisrc doesn't
-     * need vectors, so we won't bother with them..
-     */
-    for(i = 0 ; i < sizeof(assp_minisrc_image) / 2; i++) {
-        m3_assp_write(card, MEMTYPE_INTERNAL_CODE, 
-                0x400 + i, 
-                assp_minisrc_image[i]);
-    }
-
-    /*
-     * write the coefficients for the low pass filter?
-     */
-    for(i = 0; i < MINISRC_LPF_LEN ; i++) {
-        m3_assp_write(card, MEMTYPE_INTERNAL_CODE,
-            0x400 + MINISRC_COEF_LOC + i,
-            minisrc_lpf[i]);
-    }
-
-    m3_assp_write(card, MEMTYPE_INTERNAL_CODE,
-        0x400 + MINISRC_COEF_LOC + MINISRC_LPF_LEN,
-        0x8000);
-
-    /*
-     * the minisrc is the only thing on
-     * our task list..
-     */
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA, 
-            KDATA_TASK0, 
-            0x400);
-
-    /*
-     * init the mixer number..
-     */
-
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-            KDATA_MIXER_TASK_NUMBER,0);
-
-    /*
-     * EXTREME KERNEL MASTER VOLUME
-     */
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-        KDATA_DAC_LEFT_VOLUME, ARB_VOLUME);
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-        KDATA_DAC_RIGHT_VOLUME, ARB_VOLUME);
-
-    card->mixer_list.mem_addr = KDATA_MIXER_XFER0;
-    card->mixer_list.max = MAX_VIRTUAL_MIXER_CHANNELS;
-    card->adc1_list.mem_addr = KDATA_ADC1_XFER0;
-    card->adc1_list.max = MAX_VIRTUAL_ADC1_CHANNELS;
-    card->dma_list.mem_addr = KDATA_DMA_XFER0;
-    card->dma_list.max = MAX_VIRTUAL_DMA_CHANNELS;
-    card->msrc_list.mem_addr = KDATA_INSTANCE0_MINISRC;
-    card->msrc_list.max = MAX_INSTANCE_MINISRC;
-}
-
-static int setup_msrc(struct m3_card *card,
-        struct assp_instance *inst, int index)
-{
-    int data_bytes = 2 * ( MINISRC_TMP_BUFFER_SIZE / 2 + 
-            MINISRC_IN_BUFFER_SIZE / 2 +
-            1 + MINISRC_OUT_BUFFER_SIZE / 2 + 1 );
-    int address, i;
-
-    /*
-     * the revb memory map has 0x1100 through 0x1c00
-     * free.  
-     */
-
-    /*
-     * align instance address to 256 bytes so that it's
-     * shifted list address is aligned.  
-     * list address = (mem address >> 1) >> 7;
-     */
-    data_bytes = (data_bytes + 255) & ~255;
-    address = 0x1100 + ((data_bytes/2) * index);
-
-    if((address + (data_bytes/2)) >= 0x1c00) {
-        printk(KERN_ERR PFX "no memory for %d bytes at ind %d (addr 0x%x)\n",
-                data_bytes, index, address);
-        return -1;
-    }
-
-    for(i = 0; i < data_bytes/2 ; i++) 
-        m3_assp_write(card, MEMTYPE_INTERNAL_DATA,
-                address + i, 0);
-
-    inst->code = 0x400;
-    inst->data = address;
-
-    return 0;
-}
-
-static int m3_assp_client_init(struct m3_state *s)
-{
-    setup_msrc(s->card, &(s->dac_inst), s->index * 2);
-    setup_msrc(s->card, &(s->adc_inst), (s->index * 2) + 1);
-
-    return 0;
-}
-
-static void m3_amp_enable(struct m3_card *card, int enable)
-{
-    /* 
-     * this works for the reference board, have to find
-     * out about others
-     *
-     * this needs more magic for 4 speaker, but..
-     */
-    int io = card->iobase;
-    u16 gpo, polarity_port, polarity;
-
-    if(!external_amp)
-        return;
-
-    if (gpio_pin >= 0  && gpio_pin <= 15) {
-        polarity_port = 0x1000 + (0x100 * gpio_pin);
-    } else {
-        switch (card->card_type) {
-            case ESS_ALLEGRO:
-                polarity_port = 0x1800;
-                break;
-            default:
-                polarity_port = 0x1100;
-                /* Panasonic toughbook CF72 has to be different... */
-                if(card->pcidev->subsystem_vendor == 0x10F7 && card->pcidev->subsystem_device == 0x833D)
-                	polarity_port = 0x1D00;
-                break;
-        }
-    }
-
-    gpo = (polarity_port >> 8) & 0x0F;
-    polarity = polarity_port >> 12;
-    if ( enable )
-        polarity = !polarity;
-    polarity = polarity << gpo;
-    gpo = 1 << gpo;
-
-    outw(~gpo , io + GPIO_MASK);
-
-    outw( inw(io + GPIO_DIRECTION) | gpo ,
-            io + GPIO_DIRECTION);
-
-    outw( (GPO_SECONDARY_AC97 | GPO_PRIMARY_AC97 | polarity) ,
-            io + GPIO_DATA);
-
-    outw(0xffff , io + GPIO_MASK);
-}
-
-static int
-maestro_config(struct m3_card *card) 
-{
-    struct pci_dev *pcidev = card->pcidev;
-    u32 n;
-    u8  t; /* makes as much sense as 'n', no? */
-
-    pci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);
-    n &= REDUCED_DEBOUNCE;
-    n |= PM_CTRL_ENABLE | CLK_DIV_BY_49 | USE_PCI_TIMING;
-    pci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);
-
-    outb(RESET_ASSP, card->iobase + ASSP_CONTROL_B);
-    pci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);
-    n &= ~INT_CLK_SELECT;
-    if(card->card_type >= ESS_MAESTRO3)  {
-        n &= ~INT_CLK_MULT_ENABLE; 
-        n |= INT_CLK_SRC_NOT_PCI;
-    }
-    n &=  ~( CLK_MULT_MODE_SELECT | CLK_MULT_MODE_SELECT_2 );
-    pci_write_config_dword(pcidev, PCI_ALLEGRO_CONFIG, n);
-
-    if(card->card_type <= ESS_ALLEGRO) {
-        pci_read_config_dword(pcidev, PCI_USER_CONFIG, &n);
-        n |= IN_CLK_12MHZ_SELECT;
-        pci_write_config_dword(pcidev, PCI_USER_CONFIG, n);
-    }
-
-    t = inb(card->iobase + ASSP_CONTROL_A);
-    t &= ~( DSP_CLK_36MHZ_SELECT  | ASSP_CLK_49MHZ_SELECT);
-    t |= ASSP_CLK_49MHZ_SELECT;
-    t |= ASSP_0_WS_ENABLE; 
-    outb(t, card->iobase + ASSP_CONTROL_A);
-
-    outb(RUN_ASSP, card->iobase + ASSP_CONTROL_B); 
-
-    return 0;
-} 
-
-static void m3_enable_ints(struct m3_card *card)
-{
-    unsigned long io = card->iobase;
-
-    outw(ASSP_INT_ENABLE, io + HOST_INT_CTRL);
-    outb(inb(io + ASSP_CONTROL_C) | ASSP_HOST_INT_ENABLE,
-            io + ASSP_CONTROL_C);
-}
-
-static struct file_operations m3_audio_fops = {
-	.owner	 = THIS_MODULE,
-	.llseek	 = no_llseek,
-	.read	 = m3_read,
-	.write	 = m3_write,
-	.poll	 = m3_poll,
-	.ioctl	 = m3_ioctl,
-	.mmap	 = m3_mmap,
-	.open	 = m3_open,
-	.release = m3_release,
-};
-
-#ifdef CONFIG_PM
-static int alloc_dsp_suspendmem(struct m3_card *card)
-{
-    int len = sizeof(u16) * (REV_B_CODE_MEMORY_LENGTH + REV_B_DATA_MEMORY_LENGTH);
-
-    if( (card->suspend_mem = vmalloc(len)) == NULL)
-        return 1;
-
-    return 0;
-}
-
-#else
-#define alloc_dsp_suspendmem(args...) 0
-#endif
-
-/*
- * great day!  this function is ugly as hell.
- */
-static int __devinit m3_probe(struct pci_dev *pci_dev, const struct pci_device_id *pci_id)
-{
-    u32 n;
-    int i;
-    struct m3_card *card = NULL;
-    int ret = 0;
-    int card_type = pci_id->driver_data;
-
-    DPRINTK(DPMOD, "in maestro_install\n");
-
-    if (pci_enable_device(pci_dev))
-        return -EIO;
-
-    if (pci_set_dma_mask(pci_dev, M3_PCI_DMA_MASK)) {
-        printk(KERN_ERR PFX "architecture does not support limiting to 28bit PCI bus addresses\n");
-        return -ENODEV;
-    }
-        
-    pci_set_master(pci_dev);
-
-    if( (card = kmalloc(sizeof(struct m3_card), GFP_KERNEL)) == NULL) {
-        printk(KERN_WARNING PFX "out of memory\n");
-        return -ENOMEM;
-    }
-    memset(card, 0, sizeof(struct m3_card));
-    card->pcidev = pci_dev;
-    init_waitqueue_head(&card->suspend_queue);
-
-    if ( ! request_region(pci_resource_start(pci_dev, 0),
-                pci_resource_len (pci_dev, 0), M3_MODULE_NAME)) {
-
-        printk(KERN_WARNING PFX "unable to reserve I/O space.\n");
-        ret = -EBUSY;
-        goto out;
-    }
-
-    card->iobase = pci_resource_start(pci_dev, 0);
-
-    if(alloc_dsp_suspendmem(card)) {
-        printk(KERN_WARNING PFX "couldn't alloc %d bytes for saving dsp state on suspend\n",
-                REV_B_CODE_MEMORY_LENGTH + REV_B_DATA_MEMORY_LENGTH);
-        ret = -ENOMEM;
-        goto out;
-    }
-
-    card->card_type = card_type;
-    card->irq = pci_dev->irq;
-    card->next = devs;
-    card->magic = M3_CARD_MAGIC;
-    spin_lock_init(&card->lock);
-    spin_lock_init(&card->ac97_lock);
-    devs = card;
-    for(i = 0; i<NR_DSPS; i++) {
-        struct m3_state *s = &(card->channels[i]);
-        s->dev_audio = -1;
-    }
-
-    printk(KERN_INFO PFX "Configuring ESS %s found at IO 0x%04X IRQ %d\n", 
-        card_names[card->card_type], card->iobase, card->irq);
-
-    pci_read_config_dword(pci_dev, PCI_SUBSYSTEM_VENDOR_ID, &n);
-    printk(KERN_INFO PFX " subvendor id: 0x%08x\n",n); 
-
-    maestro_config(card);
-    m3_assp_halt(card);
-
-    m3_codec_reset(card, 0);
-
-    if(m3_codec_install(card))  {
-        ret = -EIO; 
-        goto out;
-    }
-
-    m3_assp_init(card);
-    m3_amp_enable(card, 1);
-    
-    for(i=0;i<NR_DSPS;i++) {
-        struct m3_state *s=&card->channels[i];
-
-        s->index = i;
-
-        s->card = card;
-        init_waitqueue_head(&s->dma_adc.wait);
-        init_waitqueue_head(&s->dma_dac.wait);
-        init_waitqueue_head(&s->open_wait);
-        mutex_init(&(s->open_mutex));
-        s->magic = M3_STATE_MAGIC;
-
-        m3_assp_client_init(s);
-        
-        if(s->dma_adc.ready || s->dma_dac.ready || s->dma_adc.rawbuf)
-            printk(KERN_WARNING PFX "initing a dsp device that is already in use?\n");
-        /* register devices */
-        if ((s->dev_audio = register_sound_dsp(&m3_audio_fops, -1)) < 0) {
-            break;
-        }
-
-        if( allocate_dmabuf(card->pcidev, &(s->dma_adc)) ||
-                allocate_dmabuf(card->pcidev, &(s->dma_dac)))  { 
-            ret = -ENOMEM;
-            goto out;
-        }
-    }
-    
-    if(request_irq(card->irq, m3_interrupt, IRQF_SHARED, card_names[card->card_type], card)) {
-
-        printk(KERN_ERR PFX "unable to allocate irq %d,\n", card->irq);
-
-        ret = -EIO;
-        goto out;
-    }
-
-    pci_set_drvdata(pci_dev, card);
-    
-    m3_enable_ints(card);
-    m3_assp_continue(card);
-
-out:
-    if(ret) {
-        if(card->iobase)
-            release_region(pci_resource_start(pci_dev, 0), pci_resource_len(pci_dev, 0));
-        vfree(card->suspend_mem);
-        if(card->ac97) {
-            unregister_sound_mixer(card->ac97->dev_mixer);
-            kfree(card->ac97);
-        }
-        for(i=0;i<NR_DSPS;i++)
-        {
-            struct m3_state *s = &card->channels[i];
-            if(s->dev_audio != -1)
-                unregister_sound_dsp(s->dev_audio);
-        }
-        kfree(card);
-    }
-
-    return ret; 
-}
-
-static void m3_remove(struct pci_dev *pci_dev)
-{
-    struct m3_card *card;
-
-    unregister_reboot_notifier(&m3_reboot_nb);
-
-    while ((card = devs)) {
-        int i;
-        devs = devs->next;
-    
-        free_irq(card->irq, card);
-        unregister_sound_mixer(card->ac97->dev_mixer);
-        kfree(card->ac97);
-
-        for(i=0;i<NR_DSPS;i++)
-        {
-            struct m3_state *s = &card->channels[i];
-            if(s->dev_audio < 0)
-                continue;
-
-            unregister_sound_dsp(s->dev_audio);
-            free_dmabuf(card->pcidev, &s->dma_adc);
-            free_dmabuf(card->pcidev, &s->dma_dac);
-        }
-
-        release_region(card->iobase, 256);
-        vfree(card->suspend_mem);
-        kfree(card);
-    }
-    devs = NULL;
-}
-
-/*
- * some bioses like the sound chip to be powered down
- * at shutdown.  We're just calling _suspend to
- * achieve that..
- */
-static int m3_notifier(struct notifier_block *nb, unsigned long event, void *buf)
-{
-    struct m3_card *card;
-
-    DPRINTK(DPMOD, "notifier suspending all cards\n");
-
-    for(card = devs; card != NULL; card = card->next) {
-        if(!card->in_suspend)
-            m3_suspend(card->pcidev, PMSG_SUSPEND); /* XXX legal? */
-    }
-    return 0;
-}
-
-static int m3_suspend(struct pci_dev *pci_dev, pm_message_t state)
-{
-    unsigned long flags;
-    int i;
-    struct m3_card *card = pci_get_drvdata(pci_dev);
-
-    /* must be a better way.. */
-	spin_lock_irqsave(&card->lock, flags);
-
-    DPRINTK(DPMOD, "pm in dev %p\n",card);
-
-    for(i=0;i<NR_DSPS;i++) {
-        struct m3_state *s = &card->channels[i];
-
-        if(s->dev_audio == -1)
-            continue;
-
-        DPRINTK(DPMOD, "stop_adc/dac() device %d\n",i);
-        stop_dac(s);
-        stop_adc(s);
-    }
-
-    mdelay(10); /* give the assp a chance to idle.. */
-
-    m3_assp_halt(card);
-
-    if(card->suspend_mem) {
-        int index = 0;
-
-        DPRINTK(DPMOD, "saving code\n");
-        for(i = REV_B_CODE_MEMORY_BEGIN ; i <= REV_B_CODE_MEMORY_END; i++)
-            card->suspend_mem[index++] = 
-                m3_assp_read(card, MEMTYPE_INTERNAL_CODE, i);
-        DPRINTK(DPMOD, "saving data\n");
-        for(i = REV_B_DATA_MEMORY_BEGIN ; i <= REV_B_DATA_MEMORY_END; i++)
-            card->suspend_mem[index++] = 
-                m3_assp_read(card, MEMTYPE_INTERNAL_DATA, i);
-    }
-
-    DPRINTK(DPMOD, "powering down apci regs\n");
-    m3_outw(card, 0xffff, 0x54);
-    m3_outw(card, 0xffff, 0x56);
-
-    card->in_suspend = 1;
-
-    spin_unlock_irqrestore(&card->lock, flags);
-
-    return 0;
-}
-
-static int m3_resume(struct pci_dev *pci_dev)
-{
-    unsigned long flags;
-    int index;
-    int i;
-    struct m3_card *card = pci_get_drvdata(pci_dev);
-
-	spin_lock_irqsave(&card->lock, flags);
-    card->in_suspend = 0;
-
-    DPRINTK(DPMOD, "resuming\n");
-
-    /* first lets just bring everything back. .*/
-
-    DPRINTK(DPMOD, "bringing power back on card 0x%p\n",card);
-    m3_outw(card, 0, 0x54);
-    m3_outw(card, 0, 0x56);
-
-    DPRINTK(DPMOD, "restoring pci configs and reseting codec\n");
-    maestro_config(card);
-    m3_assp_halt(card);
-    m3_codec_reset(card, 1);
-
-    DPRINTK(DPMOD, "restoring dsp code card\n");
-    index = 0;
-    for(i = REV_B_CODE_MEMORY_BEGIN ; i <= REV_B_CODE_MEMORY_END; i++)
-        m3_assp_write(card, MEMTYPE_INTERNAL_CODE, i, 
-            card->suspend_mem[index++]);
-    for(i = REV_B_DATA_MEMORY_BEGIN ; i <= REV_B_DATA_MEMORY_END; i++)
-        m3_assp_write(card, MEMTYPE_INTERNAL_DATA, i, 
-            card->suspend_mem[index++]);
-
-     /* tell the dma engine to restart itself */
-    m3_assp_write(card, MEMTYPE_INTERNAL_DATA, 
-        KDATA_DMA_ACTIVE, 0);
-
-    DPRINTK(DPMOD, "resuming dsp\n");
-    m3_assp_continue(card);
-
-    DPRINTK(DPMOD, "enabling ints\n");
-    m3_enable_ints(card);
-
-    /* bring back the old school flavor */
-    for(i = 0; i < SOUND_MIXER_NRDEVICES ; i++) {
-        int state = card->ac97->mixer_state[i];
-        if (!supported_mixer(card->ac97, i)) 
-                continue;
-
-        card->ac97->write_mixer(card->ac97, i, 
-                state & 0xff, (state >> 8) & 0xff);
-    }
-
-    m3_amp_enable(card, 1);
-
-    /* 
-     * now we flip on the music 
-     */
-    for(i=0;i<NR_DSPS;i++) {
-        struct m3_state *s = &card->channels[i];
-        if(s->dev_audio == -1)
-            continue;
-        /*
-         * db->ready makes it so these guys can be
-         * called unconditionally..
-         */
-        DPRINTK(DPMOD, "turning on dacs ind %d\n",i);
-        start_dac(s);    
-        start_adc(s);    
-    }
-
-    spin_unlock_irqrestore(&card->lock, flags);
-
-    /* 
-     * all right, we think things are ready, 
-     * wake up people who were using the device 
-     * when we suspended
-     */
-    wake_up(&card->suspend_queue);
-
-    return 0;
-}
-
-MODULE_AUTHOR("Zach Brown <zab@zabbo.net>");
-MODULE_DESCRIPTION("ESS Maestro3/Allegro Driver");
-MODULE_LICENSE("GPL");
-
-#ifdef M_DEBUG
-module_param(debug, int, 0);
-#endif
-module_param(external_amp, int, 0);
-module_param(gpio_pin, int, 0);
-
-static struct pci_driver m3_pci_driver = {
-	.name	  = "ess_m3_audio",
-	.id_table = m3_id_table,
-	.probe	  = m3_probe,
-	.remove	  = m3_remove,
-	.suspend  = m3_suspend,
-	.resume	  = m3_resume,
-};
-
-static int __init m3_init_module(void)
-{
-    printk(KERN_INFO PFX "version " DRIVER_VERSION " built at " __TIME__ " " __DATE__ "\n");
-
-    if (register_reboot_notifier(&m3_reboot_nb)) {
-        printk(KERN_WARNING PFX "reboot notifier registration failed\n");
-        return -ENODEV; /* ? */
-    }
-
-    if (pci_register_driver(&m3_pci_driver)) {
-        unregister_reboot_notifier(&m3_reboot_nb);
-        return -ENODEV;
-    }
-    return 0;
-}
-
-static void __exit m3_cleanup_module(void)
-{
-    pci_unregister_driver(&m3_pci_driver);
-}
-
-module_init(m3_init_module);
-module_exit(m3_cleanup_module);
-
-void check_suspend(struct m3_card *card)
-{
-    DECLARE_WAITQUEUE(wait, current);
-
-    if(!card->in_suspend) 
-        return;
-
-    card->in_suspend++;
-    add_wait_queue(&card->suspend_queue, &wait);
-    set_current_state(TASK_UNINTERRUPTIBLE);
-    schedule();
-    remove_wait_queue(&card->suspend_queue, &wait);
-    set_current_state(TASK_RUNNING);
-}
--- linux-2.6.18.noarch/sound/oss/sonicvibes.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sonicvibes.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2792 +0,0 @@
-/*****************************************************************************/
-
-/*
- *      sonicvibes.c  --  S3 Sonic Vibes audio driver.
- *
- *      Copyright (C) 1998-2001, 2003  Thomas Sailer (t.sailer@alumni.ethz.ch)
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Special thanks to David C. Niemi
- *
- *
- * Module command line parameters:
- *   none so far
- *
- *
- *  Supported devices:
- *  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible
- *  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
- *  /dev/midi   simple MIDI UART interface, no ioctl
- *
- *  The card has both an FM and a Wavetable synth, but I have to figure
- *  out first how to drive them...
- *
- *  Revision history
- *    06.05.1998   0.1   Initial release
- *    10.05.1998   0.2   Fixed many bugs, esp. ADC rate calculation
- *                       First stab at a simple midi interface (no bells&whistles)
- *    13.05.1998   0.3   Fix stupid cut&paste error: set_adc_rate was called instead of
- *                       set_dac_rate in the FMODE_WRITE case in sv_open
- *                       Fix hwptr out of bounds (now mpg123 works)
- *    14.05.1998   0.4   Don't allow excessive interrupt rates
- *    08.06.1998   0.5   First release using Alan Cox' soundcore instead of miscdevice
- *    03.08.1998   0.6   Do not include modversions.h
- *                       Now mixer behaviour can basically be selected between
- *                       "OSS documented" and "OSS actual" behaviour
- *    31.08.1998   0.7   Fix realplayer problems - dac.count issues
- *    10.12.1998   0.8   Fix drain_dac trying to wait on not yet initialized DMA
- *    16.12.1998   0.9   Fix a few f_file & FMODE_ bugs
- *    06.01.1999   0.10  remove the silly SA_INTERRUPT flag.
- *                       hopefully killed the egcs section type conflict
- *    12.03.1999   0.11  cinfo.blocks should be reset after GETxPTR ioctl.
- *                       reported by Johan Maes <joma@telindus.be>
- *    22.03.1999   0.12  return EAGAIN instead of EBUSY when O_NONBLOCK
- *                       read/write cannot be executed
- *    05.04.1999   0.13  added code to sv_read and sv_write which should detect
- *                       lockups of the sound chip and revive it. This is basically
- *                       an ugly hack, but at least applications using this driver
- *                       won't hang forever. I don't know why these lockups happen,
- *                       it might well be the motherboard chipset (an early 486 PCI
- *                       board with ALI chipset), since every busmastering 100MB
- *                       ethernet card I've tried (Realtek 8139 and Macronix tulip clone)
- *                       exhibit similar behaviour (they work for a couple of packets
- *                       and then lock up and can be revived by ifconfig down/up).
- *    07.04.1999   0.14  implemented the following ioctl's: SOUND_PCM_READ_RATE, 
- *                       SOUND_PCM_READ_CHANNELS, SOUND_PCM_READ_BITS; 
- *                       Alpha fixes reported by Peter Jones <pjones@redhat.com>
- *                       Note: dmaio hack might still be wrong on archs other than i386
- *    15.06.1999   0.15  Fix bad allocation bug.
- *                       Thanks to Deti Fliegl <fliegl@in.tum.de>
- *    28.06.1999   0.16  Add pci_set_master
- *    03.08.1999   0.17  adapt to Linus' new __setup/__initcall
- *                       added kernel command line options "sonicvibes=reverb" and "sonicvibesdmaio=dmaioaddr"
- *    12.08.1999   0.18  module_init/__setup fixes
- *    24.08.1999   0.19  get rid of the dmaio kludge, replace with allocate_resource
- *    31.08.1999   0.20  add spin_lock_init
- *                       use new resource allocation to allocate DDMA IO space
- *                       replaced current->state = x with set_current_state(x)
- *    03.09.1999   0.21  change read semantics for MIDI to match
- *                       OSS more closely; remove possible wakeup race
- *    28.10.1999   0.22  More waitqueue races fixed
- *    01.12.1999   0.23  New argument to allocate_resource
- *    07.12.1999   0.24  More allocate_resource semantics change
- *    08.01.2000   0.25  Prevent some ioctl's from returning bad count values on underrun/overrun;
- *                       Tim Janik's BSE (Bedevilled Sound Engine) found this
- *                       use Martin Mares' pci_assign_resource
- *    07.02.2000   0.26  Use pci_alloc_consistent and pci_register_driver
- *    21.11.2000   0.27  Initialize dma buffers in poll, otherwise poll may return a bogus mask
- *    12.12.2000   0.28  More dma buffer initializations, patch from
- *                       Tjeerd Mulder <tjeerd.mulder@fujitsu-siemens.com>
- *    31.01.2001   0.29  Register/Unregister gameport
- *                       Fix SETTRIGGER non OSS API conformity
- *    18.05.2001   0.30  PCI probing and error values cleaned up by Marcus
- *                       Meissner <mm@caldera.de>
- *    03.01.2003   0.31  open_mode fixes from Georg Acher <acher@in.tum.de>
- *
- */
-
-/*****************************************************************************/
-      
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/interrupt.h>
-#include <linux/wait.h>
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/spinlock.h>
-#include <linux/smp_lock.h>
-#include <linux/gameport.h>
-#include <linux/dma-mapping.h>
-#include <linux/mutex.h>
-
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-
-#include "dm.h"
-
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
-#define SUPPORT_JOYSTICK 1
-#endif
-
-/* --------------------------------------------------------------------- */
-
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-
-/* --------------------------------------------------------------------- */
-
-#ifndef PCI_VENDOR_ID_S3
-#define PCI_VENDOR_ID_S3             0x5333
-#endif
-#ifndef PCI_DEVICE_ID_S3_SONICVIBES
-#define PCI_DEVICE_ID_S3_SONICVIBES  0xca00
-#endif
-
-#define SV_MAGIC  ((PCI_VENDOR_ID_S3<<16)|PCI_DEVICE_ID_S3_SONICVIBES)
-
-#define SV_EXTENT_SB      0x10
-#define SV_EXTENT_ENH     0x10
-#define SV_EXTENT_SYNTH   0x4
-#define SV_EXTENT_MIDI    0x4
-#define SV_EXTENT_GAME    0x8
-#define SV_EXTENT_DMA     0x10
-
-/*
- * we are not a bridge and thus use a resource for DDMA that is used for bridges but
- * left empty for normal devices
- */
-#define RESOURCE_SB       0
-#define RESOURCE_ENH      1
-#define RESOURCE_SYNTH    2
-#define RESOURCE_MIDI     3
-#define RESOURCE_GAME     4
-#define RESOURCE_DDMA     7
-
-#define SV_MIDI_DATA      0
-#define SV_MIDI_COMMAND   1
-#define SV_MIDI_STATUS    1
-
-#define SV_DMA_ADDR0      0
-#define SV_DMA_ADDR1      1
-#define SV_DMA_ADDR2      2
-#define SV_DMA_ADDR3      3
-#define SV_DMA_COUNT0     4
-#define SV_DMA_COUNT1     5
-#define SV_DMA_COUNT2     6
-#define SV_DMA_MODE       0xb
-#define SV_DMA_RESET      0xd
-#define SV_DMA_MASK       0xf
-
-/*
- * DONT reset the DMA controllers unless you understand
- * the reset semantics. Assuming reset semantics as in
- * the 8237 does not work.
- */
-
-#define DMA_MODE_AUTOINIT 0x10
-#define DMA_MODE_READ     0x44    /* I/O to memory, no autoinit, increment, single mode */
-#define DMA_MODE_WRITE    0x48    /* memory to I/O, no autoinit, increment, single mode */
-
-#define SV_CODEC_CONTROL  0
-#define SV_CODEC_INTMASK  1
-#define SV_CODEC_STATUS   2
-#define SV_CODEC_IADDR    4
-#define SV_CODEC_IDATA    5
-
-#define SV_CCTRL_RESET      0x80
-#define SV_CCTRL_INTADRIVE  0x20
-#define SV_CCTRL_WAVETABLE  0x08
-#define SV_CCTRL_REVERB     0x04
-#define SV_CCTRL_ENHANCED   0x01
-
-#define SV_CINTMASK_DMAA    0x01
-#define SV_CINTMASK_DMAC    0x04
-#define SV_CINTMASK_SPECIAL 0x08
-#define SV_CINTMASK_UPDOWN  0x40
-#define SV_CINTMASK_MIDI    0x80
-
-#define SV_CSTAT_DMAA       0x01
-#define SV_CSTAT_DMAC	    0x04
-#define SV_CSTAT_SPECIAL    0x08
-#define SV_CSTAT_UPDOWN	    0x40
-#define SV_CSTAT_MIDI	    0x80
-
-#define SV_CIADDR_TRD       0x80
-#define SV_CIADDR_MCE       0x40
-
-/* codec indirect registers */
-#define SV_CIMIX_ADCINL     0x00
-#define SV_CIMIX_ADCINR     0x01
-#define SV_CIMIX_AUX1INL    0x02
-#define SV_CIMIX_AUX1INR    0x03
-#define SV_CIMIX_CDINL      0x04
-#define SV_CIMIX_CDINR      0x05
-#define SV_CIMIX_LINEINL    0x06
-#define SV_CIMIX_LINEINR    0x07
-#define SV_CIMIX_MICIN      0x08
-#define SV_CIMIX_SYNTHINL   0x0A
-#define SV_CIMIX_SYNTHINR   0x0B
-#define SV_CIMIX_AUX2INL    0x0C
-#define SV_CIMIX_AUX2INR    0x0D
-#define SV_CIMIX_ANALOGINL  0x0E
-#define SV_CIMIX_ANALOGINR  0x0F
-#define SV_CIMIX_PCMINL     0x10
-#define SV_CIMIX_PCMINR     0x11
-
-#define SV_CIGAMECONTROL    0x09
-#define SV_CIDATAFMT        0x12
-#define SV_CIENABLE         0x13
-#define SV_CIUPDOWN         0x14
-#define SV_CIREVISION       0x15
-#define SV_CIADCOUTPUT      0x16
-#define SV_CIDMAABASECOUNT1 0x18
-#define SV_CIDMAABASECOUNT0 0x19
-#define SV_CIDMACBASECOUNT1 0x1c
-#define SV_CIDMACBASECOUNT0 0x1d
-#define SV_CIPCMSR0         0x1e
-#define SV_CIPCMSR1         0x1f
-#define SV_CISYNTHSR0       0x20
-#define SV_CISYNTHSR1       0x21
-#define SV_CIADCCLKSOURCE   0x22
-#define SV_CIADCALTSR       0x23
-#define SV_CIADCPLLM        0x24
-#define SV_CIADCPLLN        0x25
-#define SV_CISYNTHPLLM      0x26
-#define SV_CISYNTHPLLN      0x27
-#define SV_CIUARTCONTROL    0x2a
-#define SV_CIDRIVECONTROL   0x2b
-#define SV_CISRSSPACE       0x2c
-#define SV_CISRSCENTER      0x2d
-#define SV_CIWAVETABLESRC   0x2e
-#define SV_CIANALOGPWRDOWN  0x30
-#define SV_CIDIGITALPWRDOWN 0x31
-
-
-#define SV_CIMIX_ADCSRC_CD     0x20
-#define SV_CIMIX_ADCSRC_DAC    0x40
-#define SV_CIMIX_ADCSRC_AUX2   0x60
-#define SV_CIMIX_ADCSRC_LINE   0x80
-#define SV_CIMIX_ADCSRC_AUX1   0xa0
-#define SV_CIMIX_ADCSRC_MIC    0xc0
-#define SV_CIMIX_ADCSRC_MIXOUT 0xe0
-#define SV_CIMIX_ADCSRC_MASK   0xe0
-
-#define SV_CFMT_STEREO     0x01
-#define SV_CFMT_16BIT      0x02
-#define SV_CFMT_MASK       0x03
-#define SV_CFMT_ASHIFT     0   
-#define SV_CFMT_CSHIFT     4
-
-static const unsigned sample_size[] = { 1, 2, 2, 4 };
-static const unsigned sample_shift[] = { 0, 1, 1, 2 };
-
-#define SV_CENABLE_PPE     0x4
-#define SV_CENABLE_RE      0x2
-#define SV_CENABLE_PE      0x1
-
-
-/* MIDI buffer sizes */
-
-#define MIDIINBUF  256
-#define MIDIOUTBUF 256
-
-#define FMODE_MIDI_SHIFT 2
-#define FMODE_MIDI_READ  (FMODE_READ << FMODE_MIDI_SHIFT)
-#define FMODE_MIDI_WRITE (FMODE_WRITE << FMODE_MIDI_SHIFT)
-
-#define FMODE_DMFM 0x10
-
-/* --------------------------------------------------------------------- */
-
-struct sv_state {
-	/* magic */
-	unsigned int magic;
-
-	/* list of sonicvibes devices */
-	struct list_head devs;
-
-	/* the corresponding pci_dev structure */
-	struct pci_dev *dev;
-
-	/* soundcore stuff */
-	int dev_audio;
-	int dev_mixer;
-	int dev_midi;
-	int dev_dmfm;
-
-	/* hardware resources */
-	unsigned long iosb, ioenh, iosynth, iomidi;  /* long for SPARC */
-	unsigned int iodmaa, iodmac, irq;
-
-        /* mixer stuff */
-        struct {
-                unsigned int modcnt;
-#ifndef OSS_DOCUMENTED_MIXER_SEMANTICS
-		unsigned short vol[13];
-#endif /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-        } mix;
-
-	/* wave stuff */
-	unsigned int rateadc, ratedac;
-	unsigned char fmt, enable;
-
-	spinlock_t lock;
-	struct mutex open_mutex;
-	mode_t open_mode;
-	wait_queue_head_t open_wait;
-
-	struct dmabuf {
-		void *rawbuf;
-		dma_addr_t dmaaddr;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-		unsigned hwptr, swptr;
-		unsigned total_bytes;
-		int count;
-		unsigned error; /* over/underrun */
-		wait_queue_head_t wait;
-		/* redundant, but makes calculations easier */
-		unsigned fragsize;
-		unsigned dmasize;
-		unsigned fragsamples;
-		/* OSS stuff */
-		unsigned mapped:1;
-		unsigned ready:1;
-		unsigned endcleared:1;
-		unsigned enabled:1;
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-	} dma_dac, dma_adc;
-
-	/* midi stuff */
-	struct {
-		unsigned ird, iwr, icnt;
-		unsigned ord, owr, ocnt;
-		wait_queue_head_t iwait;
-		wait_queue_head_t owait;
-		struct timer_list timer;
-		unsigned char ibuf[MIDIINBUF];
-		unsigned char obuf[MIDIOUTBUF];
-	} midi;
-
-#if SUPPORT_JOYSTICK
-	struct gameport *gameport;
-#endif
-};
-
-/* --------------------------------------------------------------------- */
-
-static LIST_HEAD(devs);
-static unsigned long wavetable_mem;
-
-/* --------------------------------------------------------------------- */
-
-static inline unsigned ld2(unsigned int x)
-{
-	unsigned r = 0;
-	
-	if (x >= 0x10000) {
-		x >>= 16;
-		r += 16;
-	}
-	if (x >= 0x100) {
-		x >>= 8;
-		r += 8;
-	}
-	if (x >= 0x10) {
-		x >>= 4;
-		r += 4;
-	}
-	if (x >= 4) {
-		x >>= 2;
-		r += 2;
-	}
-	if (x >= 2)
-		r++;
-	return r;
-}
-
-/* --------------------------------------------------------------------- */
-
-/*
- * Why use byte IO? Nobody knows, but S3 does it also in their Windows driver.
- */
-
-#undef DMABYTEIO
-
-static void set_dmaa(struct sv_state *s, unsigned int addr, unsigned int count)
-{
-#ifdef DMABYTEIO
-	unsigned io = s->iodmaa, u;
-
-	count--;
-	for (u = 4; u > 0; u--, addr >>= 8, io++)
-		outb(addr & 0xff, io);
-	for (u = 3; u > 0; u--, count >>= 8, io++)
-		outb(count & 0xff, io);
-#else /* DMABYTEIO */
-	count--;
-	outl(addr, s->iodmaa + SV_DMA_ADDR0);
-	outl(count, s->iodmaa + SV_DMA_COUNT0);
-#endif /* DMABYTEIO */
-	outb(0x18, s->iodmaa + SV_DMA_MODE);
-}
-
-static void set_dmac(struct sv_state *s, unsigned int addr, unsigned int count)
-{
-#ifdef DMABYTEIO
-	unsigned io = s->iodmac, u;
-
-	count >>= 1;
-	count--;
-	for (u = 4; u > 0; u--, addr >>= 8, io++)
-		outb(addr & 0xff, io);
-	for (u = 3; u > 0; u--, count >>= 8, io++)
-		outb(count & 0xff, io);
-#else /* DMABYTEIO */
-	count >>= 1;
-	count--;
-	outl(addr, s->iodmac + SV_DMA_ADDR0);
-	outl(count, s->iodmac + SV_DMA_COUNT0);
-#endif /* DMABYTEIO */
-	outb(0x14, s->iodmac + SV_DMA_MODE);
-}
-
-static inline unsigned get_dmaa(struct sv_state *s)
-{
-#ifdef DMABYTEIO
-	unsigned io = s->iodmaa+6, v = 0, u;
-
-	for (u = 3; u > 0; u--, io--) {
-		v <<= 8;
-		v |= inb(io);
-	}
-	return v + 1;
-#else /* DMABYTEIO */
-	return (inl(s->iodmaa + SV_DMA_COUNT0) & 0xffffff) + 1;
-#endif /* DMABYTEIO */
-}
-
-static inline unsigned get_dmac(struct sv_state *s)
-{
-#ifdef DMABYTEIO
-	unsigned io = s->iodmac+6, v = 0, u;
-
-	for (u = 3; u > 0; u--, io--) {
-		v <<= 8;
-		v |= inb(io);
-	}
-	return (v + 1) << 1;
-#else /* DMABYTEIO */
-	return ((inl(s->iodmac + SV_DMA_COUNT0) & 0xffffff) + 1) << 1;
-#endif /* DMABYTEIO */
-}
-
-static void wrindir(struct sv_state *s, unsigned char idx, unsigned char data)
-{
-	outb(idx & 0x3f, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	outb(data, s->ioenh + SV_CODEC_IDATA);
-	udelay(10);
-}
-
-static unsigned char rdindir(struct sv_state *s, unsigned char idx)
-{
-	unsigned char v;
-
-	outb(idx & 0x3f, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	v = inb(s->ioenh + SV_CODEC_IDATA);
-	udelay(10);
-	return v;
-}
-
-static void set_fmt(struct sv_state *s, unsigned char mask, unsigned char data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	outb(SV_CIDATAFMT | SV_CIADDR_MCE, s->ioenh + SV_CODEC_IADDR);
-	if (mask) {
-		s->fmt = inb(s->ioenh + SV_CODEC_IDATA);
-		udelay(10);
-	}
-	s->fmt = (s->fmt & mask) | data;
-	outb(s->fmt, s->ioenh + SV_CODEC_IDATA);
-	udelay(10);
-	outb(0, s->ioenh + SV_CODEC_IADDR);
-	spin_unlock_irqrestore(&s->lock, flags);
-	udelay(10);
-}
-
-static void frobindir(struct sv_state *s, unsigned char idx, unsigned char mask, unsigned char data)
-{
-	outb(idx & 0x3f, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	outb((inb(s->ioenh + SV_CODEC_IDATA) & mask) ^ data, s->ioenh + SV_CODEC_IDATA);
-	udelay(10);
-}
-
-#define REFFREQUENCY  24576000
-#define ADCMULT 512
-#define FULLRATE 48000
-
-static unsigned setpll(struct sv_state *s, unsigned char reg, unsigned rate)
-{
-	unsigned long flags;
-	unsigned char r, m=0, n=0;
-	unsigned xm, xn, xr, xd, metric = ~0U;
-	/* the warnings about m and n used uninitialized are bogus and may safely be ignored */
-
-	if (rate < 625000/ADCMULT)
-		rate = 625000/ADCMULT;
-	if (rate > 150000000/ADCMULT)
-		rate = 150000000/ADCMULT;
-	/* slight violation of specs, needed for continuous sampling rates */
-	for (r = 0; rate < 75000000/ADCMULT; r += 0x20, rate <<= 1);
-	for (xn = 3; xn < 35; xn++)
-		for (xm = 3; xm < 130; xm++) {
-			xr = REFFREQUENCY/ADCMULT * xm / xn;
-			xd = abs((signed)(xr - rate));
-			if (xd < metric) {
-				metric = xd;
-				m = xm - 2;
-				n = xn - 2;
-			}
-		}
-	reg &= 0x3f;
-	spin_lock_irqsave(&s->lock, flags);
-	outb(reg, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	outb(m, s->ioenh + SV_CODEC_IDATA);
-	udelay(10);
-	outb(reg+1, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	outb(r | n, s->ioenh + SV_CODEC_IDATA);
-	spin_unlock_irqrestore(&s->lock, flags);
-	udelay(10);
-	return (REFFREQUENCY/ADCMULT * (m + 2) / (n + 2)) >> ((r >> 5) & 7);
-}
-
-#if 0
-
-static unsigned getpll(struct sv_state *s, unsigned char reg)
-{
-	unsigned long flags;
-	unsigned char m, n;
-
-	reg &= 0x3f;
-	spin_lock_irqsave(&s->lock, flags);
-	outb(reg, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	m = inb(s->ioenh + SV_CODEC_IDATA);
-	udelay(10);
-	outb(reg+1, s->ioenh + SV_CODEC_IADDR);
-	udelay(10);
-	n = inb(s->ioenh + SV_CODEC_IDATA);
-	spin_unlock_irqrestore(&s->lock, flags);
-	udelay(10);
-	return (REFFREQUENCY/ADCMULT * (m + 2) / ((n & 0x1f) + 2)) >> ((n >> 5) & 7);
-}
-
-#endif
-
-static void set_dac_rate(struct sv_state *s, unsigned rate)
-{
-	unsigned div;
-	unsigned long flags;
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 4000)
-		rate = 4000;
-	div = (rate * 65536 + FULLRATE/2) / FULLRATE;
-	if (div > 65535)
-		div = 65535;
-	spin_lock_irqsave(&s->lock, flags);
-	wrindir(s, SV_CIPCMSR1, div >> 8);
-	wrindir(s, SV_CIPCMSR0, div);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->ratedac = (div * FULLRATE + 32768) / 65536;
-}
-
-static void set_adc_rate(struct sv_state *s, unsigned rate)
-{
-	unsigned long flags;
-	unsigned rate1, rate2, div;
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 4000)
-		rate = 4000;
-	rate1 = setpll(s, SV_CIADCPLLM, rate);
-	div = (48000 + rate/2) / rate;
-	if (div > 8)
-		div = 8;
-	rate2 = (48000 + div/2) / div;
-	spin_lock_irqsave(&s->lock, flags);
-	wrindir(s, SV_CIADCALTSR, (div-1) << 4);
-	if (abs((signed)(rate-rate2)) <= abs((signed)(rate-rate1))) {
-		wrindir(s, SV_CIADCCLKSOURCE, 0x10);
-		s->rateadc = rate2;
-	} else {
-		wrindir(s, SV_CIADCCLKSOURCE, 0x00);
-		s->rateadc = rate1;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}
-
-/* --------------------------------------------------------------------- */
-
-static inline void stop_adc(struct sv_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->enable &= ~SV_CENABLE_RE;
-	wrindir(s, SV_CIENABLE, s->enable);
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static inline void stop_dac(struct sv_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->enable &= ~(SV_CENABLE_PPE | SV_CENABLE_PE);
-	wrindir(s, SV_CIENABLE, s->enable);
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_dac(struct sv_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if ((s->dma_dac.mapped || s->dma_dac.count > 0) && s->dma_dac.ready) {
-		s->enable = (s->enable & ~SV_CENABLE_PPE) | SV_CENABLE_PE;
-		wrindir(s, SV_CIENABLE, s->enable);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_adc(struct sv_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if ((s->dma_adc.mapped || s->dma_adc.count < (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize)) 
-	    && s->dma_adc.ready) {
-		s->enable |= SV_CENABLE_RE;
-		wrindir(s, SV_CIENABLE, s->enable);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-/* --------------------------------------------------------------------- */
-
-#define DMABUF_DEFAULTORDER (17-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-static void dealloc_dmabuf(struct sv_state *s, struct dmabuf *db)
-{
-	struct page *page, *pend;
-
-	if (db->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			ClearPageReserved(page);
-		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder, db->rawbuf, db->dmaaddr);
-	}
-	db->rawbuf = NULL;
-	db->mapped = db->ready = 0;
-}
-
-
-/* DMAA is used for playback, DMAC is used for recording */
-
-static int prog_dmabuf(struct sv_state *s, unsigned rec)
-{
-	struct dmabuf *db = rec ? &s->dma_adc : &s->dma_dac;
-	unsigned rate = rec ? s->rateadc : s->ratedac;
-	int order;
-	unsigned bytepersec;
-	unsigned bufs;
-	struct page *page, *pend;
-	unsigned char fmt;
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	fmt = s->fmt;
-	if (rec) {
-		s->enable &= ~SV_CENABLE_RE;
-		fmt >>= SV_CFMT_CSHIFT;
-	} else {
-		s->enable &= ~SV_CENABLE_PE;
-		fmt >>= SV_CFMT_ASHIFT;
-	}
-	wrindir(s, SV_CIENABLE, s->enable);
-	spin_unlock_irqrestore(&s->lock, flags);
-	fmt &= SV_CFMT_MASK;
-	db->hwptr = db->swptr = db->total_bytes = db->count = db->error = db->endcleared = 0;
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-		for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = pci_alloc_consistent(s->dev, PAGE_SIZE << order, &db->dmaaddr)))
-				break;
-		if (!db->rawbuf)
-			return -ENOMEM;
-		db->buforder = order;
-		if ((virt_to_bus(db->rawbuf) ^ (virt_to_bus(db->rawbuf) + (PAGE_SIZE << db->buforder) - 1)) & ~0xffff)
-			printk(KERN_DEBUG "sv: DMA buffer crosses 64k boundary: busaddr 0x%lx  size %ld\n", 
-			       virt_to_bus(db->rawbuf), PAGE_SIZE << db->buforder);
-		if ((virt_to_bus(db->rawbuf) + (PAGE_SIZE << db->buforder) - 1) & ~0xffffff)
-			printk(KERN_DEBUG "sv: DMA buffer beyond 16MB: busaddr 0x%lx  size %ld\n", 
-			       virt_to_bus(db->rawbuf), PAGE_SIZE << db->buforder);
-		/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			SetPageReserved(page);
-	}
-	bytepersec = rate << sample_shift[fmt];
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < bytepersec)
-			db->fragshift = ld2(bytepersec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(bytepersec/100/(db->subdivision ? db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3;
-	}
-	db->numfrag = bufs >> db->fragshift;
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->numfrag = bufs >> db->fragshift;
-	}
-	db->fragsize = 1 << db->fragshift;
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
-	db->fragsamples = db->fragsize >> sample_shift[fmt];
-	db->dmasize = db->numfrag << db->fragshift;
-	memset(db->rawbuf, (fmt & SV_CFMT_16BIT) ? 0 : 0x80, db->dmasize);
-	spin_lock_irqsave(&s->lock, flags);
-	if (rec) {
-		set_dmac(s, db->dmaaddr, db->numfrag << db->fragshift);
-		/* program enhanced mode registers */
-		wrindir(s, SV_CIDMACBASECOUNT1, (db->fragsamples-1) >> 8);
-		wrindir(s, SV_CIDMACBASECOUNT0, db->fragsamples-1);
-	} else {
-		set_dmaa(s, db->dmaaddr, db->numfrag << db->fragshift);
-		/* program enhanced mode registers */
-		wrindir(s, SV_CIDMAABASECOUNT1, (db->fragsamples-1) >> 8);
-		wrindir(s, SV_CIDMAABASECOUNT0, db->fragsamples-1);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	db->enabled = 1;
-	db->ready = 1;
-	return 0;
-}
-
-static inline void clear_advance(struct sv_state *s)
-{
-	unsigned char c = (s->fmt & (SV_CFMT_16BIT << SV_CFMT_ASHIFT)) ? 0 : 0x80;
-	unsigned char *buf = s->dma_dac.rawbuf;
-	unsigned bsize = s->dma_dac.dmasize;
-	unsigned bptr = s->dma_dac.swptr;
-	unsigned len = s->dma_dac.fragsize;
-
-	if (bptr + len > bsize) {
-		unsigned x = bsize - bptr;
-		memset(buf + bptr, c, x);
-		bptr = 0;
-		len -= x;
-	}
-	memset(buf + bptr, c, len);
-}
-
-/* call with spinlock held! */
-static void sv_update_ptr(struct sv_state *s)
-{
-	unsigned hwptr;
-	int diff;
-
-	/* update ADC pointer */
-	if (s->dma_adc.ready) {
-		hwptr = (s->dma_adc.dmasize - get_dmac(s)) % s->dma_adc.dmasize;
-		diff = (s->dma_adc.dmasize + hwptr - s->dma_adc.hwptr) % s->dma_adc.dmasize;
-		s->dma_adc.hwptr = hwptr;
-		s->dma_adc.total_bytes += diff;
-		s->dma_adc.count += diff;
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize) 
-			wake_up(&s->dma_adc.wait);
-		if (!s->dma_adc.mapped) {
-			if (s->dma_adc.count > (signed)(s->dma_adc.dmasize - ((3 * s->dma_adc.fragsize) >> 1))) {
-				s->enable &= ~SV_CENABLE_RE;
-				wrindir(s, SV_CIENABLE, s->enable);
-				s->dma_adc.error++;
-			}
-		}
-	}
-	/* update DAC pointer */
-	if (s->dma_dac.ready) {
-		hwptr = (s->dma_dac.dmasize - get_dmaa(s)) % s->dma_dac.dmasize;
-		diff = (s->dma_dac.dmasize + hwptr - s->dma_dac.hwptr) % s->dma_dac.dmasize;
-		s->dma_dac.hwptr = hwptr;
-		s->dma_dac.total_bytes += diff;
-		if (s->dma_dac.mapped) {
-			s->dma_dac.count += diff;
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize)
-				wake_up(&s->dma_dac.wait);
-		} else {
-			s->dma_dac.count -= diff;
-			if (s->dma_dac.count <= 0) {
-				s->enable &= ~SV_CENABLE_PE;
-				wrindir(s, SV_CIENABLE, s->enable);
-				s->dma_dac.error++;
-			} else if (s->dma_dac.count <= (signed)s->dma_dac.fragsize && !s->dma_dac.endcleared) {
-				clear_advance(s);
-				s->dma_dac.endcleared = 1;
-			}
-			if (s->dma_dac.count + (signed)s->dma_dac.fragsize <= (signed)s->dma_dac.dmasize)
-				wake_up(&s->dma_dac.wait);
-		}
-	}
-}
-
-/* hold spinlock for the following! */
-static void sv_handle_midi(struct sv_state *s)
-{
-	unsigned char ch;
-	int wake;
-
-	wake = 0;
-	while (!(inb(s->iomidi+1) & 0x80)) {
-		ch = inb(s->iomidi);
-		if (s->midi.icnt < MIDIINBUF) {
-			s->midi.ibuf[s->midi.iwr] = ch;
-			s->midi.iwr = (s->midi.iwr + 1) % MIDIINBUF;
-			s->midi.icnt++;
-		}
-		wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.iwait);
-	wake = 0;
-	while (!(inb(s->iomidi+1) & 0x40) && s->midi.ocnt > 0) {
-		outb(s->midi.obuf[s->midi.ord], s->iomidi);
-		s->midi.ord = (s->midi.ord + 1) % MIDIOUTBUF;
-		s->midi.ocnt--;
-		if (s->midi.ocnt < MIDIOUTBUF-16)
-			wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.owait);
-}
-
-static irqreturn_t sv_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-        struct sv_state *s = (struct sv_state *)dev_id;
-	unsigned int intsrc;
-	
-	/* fastpath out, to ease interrupt sharing */
-	intsrc = inb(s->ioenh + SV_CODEC_STATUS);
-	if (!(intsrc & (SV_CSTAT_DMAA | SV_CSTAT_DMAC | SV_CSTAT_MIDI)))
-		return IRQ_NONE;
-	spin_lock(&s->lock);
-	sv_update_ptr(s);
-	sv_handle_midi(s);
-	spin_unlock(&s->lock);
-	return IRQ_HANDLED;
-}
-
-static void sv_midi_timer(unsigned long data)
-{
-	struct sv_state *s = (struct sv_state *)data;
-	unsigned long flags;
-	
-	spin_lock_irqsave(&s->lock, flags);
-	sv_handle_midi(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->midi.timer.expires = jiffies+1;
-	add_timer(&s->midi.timer);
-}
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT "sv: invalid magic value\n";
-
-#define VALIDATE_STATE(s)                         \
-({                                                \
-	if (!(s) || (s)->magic != SV_MAGIC) { \
-		printk(invalid_magic);            \
-		return -ENXIO;                    \
-	}                                         \
-})
-
-/* --------------------------------------------------------------------- */
-
-#define MT_4          1
-#define MT_5MUTE      2
-#define MT_4MUTEMONO  3
-#define MT_6MUTE      4
-
-static const struct {
-	unsigned left:5;
-	unsigned right:5;
-	unsigned type:3;
-	unsigned rec:3;
-} mixtable[SOUND_MIXER_NRDEVICES] = {
-	[SOUND_MIXER_RECLEV] = { SV_CIMIX_ADCINL,    SV_CIMIX_ADCINR,    MT_4,         0 },
-	[SOUND_MIXER_LINE1]  = { SV_CIMIX_AUX1INL,   SV_CIMIX_AUX1INR,   MT_5MUTE,     5 },
-	[SOUND_MIXER_CD]     = { SV_CIMIX_CDINL,     SV_CIMIX_CDINR,     MT_5MUTE,     1 },
-	[SOUND_MIXER_LINE]   = { SV_CIMIX_LINEINL,   SV_CIMIX_LINEINR,   MT_5MUTE,     4 },
-	[SOUND_MIXER_MIC]    = { SV_CIMIX_MICIN,     SV_CIMIX_ADCINL,    MT_4MUTEMONO, 6 },
-	[SOUND_MIXER_SYNTH]  = { SV_CIMIX_SYNTHINL,  SV_CIMIX_SYNTHINR,  MT_5MUTE,     2 },
-	[SOUND_MIXER_LINE2]  = { SV_CIMIX_AUX2INL,   SV_CIMIX_AUX2INR,   MT_5MUTE,     3 },
-	[SOUND_MIXER_VOLUME] = { SV_CIMIX_ANALOGINL, SV_CIMIX_ANALOGINR, MT_5MUTE,     7 },
-	[SOUND_MIXER_PCM]    = { SV_CIMIX_PCMINL,    SV_CIMIX_PCMINR,    MT_6MUTE,     0 }
-};
-
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-
-static int return_mixval(struct sv_state *s, unsigned i, int *arg)
-{
-	unsigned long flags;
-	unsigned char l, r, rl, rr;
-
-	spin_lock_irqsave(&s->lock, flags);
-	l = rdindir(s, mixtable[i].left);
-	r = rdindir(s, mixtable[i].right);
-	spin_unlock_irqrestore(&s->lock, flags);
-	switch (mixtable[i].type) {
-	case MT_4:
-		r &= 0xf;
-		l &= 0xf;
-		rl = 10 + 6 * (l & 15);
-		rr = 10 + 6 * (r & 15);
-		break;
-
-	case MT_4MUTEMONO:
-		rl = 55 - 3 * (l & 15);
-		if (r & 0x10)
-			rl += 45;
-		rr = rl;
-		r = l;
-		break;
-
-	case MT_5MUTE:
-	default:
-		rl = 100 - 3 * (l & 31);
-		rr = 100 - 3 * (r & 31);
-		break;
-				
-	case MT_6MUTE:
-		rl = 100 - 3 * (l & 63) / 2;
-		rr = 100 - 3 * (r & 63) / 2;
-		break;
-	}
-	if (l & 0x80)
-		rl = 0;
-	if (r & 0x80)
-		rr = 0;
-	return put_user((rr << 8) | rl, arg);
-}
-
-#else /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-
-static const unsigned char volidx[SOUND_MIXER_NRDEVICES] = 
-{
-	[SOUND_MIXER_RECLEV] = 1,
-	[SOUND_MIXER_LINE1]  = 2,
-	[SOUND_MIXER_CD]     = 3,
-	[SOUND_MIXER_LINE]   = 4,
-	[SOUND_MIXER_MIC]    = 5,
-	[SOUND_MIXER_SYNTH]  = 6,
-	[SOUND_MIXER_LINE2]  = 7,
-	[SOUND_MIXER_VOLUME] = 8,
-	[SOUND_MIXER_PCM]    = 9
-};
-
-#endif /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-
-static unsigned mixer_recmask(struct sv_state *s)
-{
-	unsigned long flags;
-	int i, j;
-
-	spin_lock_irqsave(&s->lock, flags);
-	j = rdindir(s, SV_CIMIX_ADCINL) >> 5;
-	spin_unlock_irqrestore(&s->lock, flags);
-	j &= 7;
-	for (i = 0; i < SOUND_MIXER_NRDEVICES && mixtable[i].rec != j; i++);
-	return 1 << i;
-}
-
-static int mixer_ioctl(struct sv_state *s, unsigned int cmd, unsigned long arg)
-{
-	unsigned long flags;
-	int i, val;
-	unsigned char l, r, rl, rr;
-	int __user *p = (int __user *)arg;
-
-	VALIDATE_STATE(s);
-        if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		memset(&info, 0, sizeof(info));
-		strlcpy(info.id, "SonicVibes", sizeof(info.id));
-		strlcpy(info.name, "S3 SonicVibes", sizeof(info.name));
-		info.modify_counter = s->mix.modcnt;
-		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == SOUND_OLD_MIXER_INFO) {
-		_old_mixer_info info;
-		memset(&info, 0, sizeof(info));
-		strlcpy(info.id, "SonicVibes", sizeof(info.id));
-		strlcpy(info.name, "S3 SonicVibes", sizeof(info.name));
-		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, p);
-	if (cmd == SOUND_MIXER_PRIVATE1) {  /* SRS settings */
-		if (get_user(val, p))
-			return -EFAULT;
-		spin_lock_irqsave(&s->lock, flags);
-		if (val & 1) {
-			if (val & 2) {
-				l = 4 - ((val >> 2) & 7);
-				if (l & ~3)
-					l = 4;
-				r = 4 - ((val >> 5) & 7);
-				if (r & ~3)
-					r = 4;
-				wrindir(s, SV_CISRSSPACE, l);
-				wrindir(s, SV_CISRSCENTER, r);
-			} else
-				wrindir(s, SV_CISRSSPACE, 0x80);
-		}
-		l = rdindir(s, SV_CISRSSPACE);
-		r = rdindir(s, SV_CISRSCENTER);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (l & 0x80)
-			return put_user(0, p);
-		return put_user(((4 - (l & 7)) << 2) | ((4 - (r & 7)) << 5) | 2, p);
-	}
-	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
-                return -EINVAL;
-        if (_SIOC_DIR(cmd) == _SIOC_READ) {
-                switch (_IOC_NR(cmd)) {
-                case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-			return put_user(mixer_recmask(s), p);
-			
-                case SOUND_MIXER_DEVMASK: /* Arg contains a bit for each supported device */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].type)
-					val |= 1 << i;
-			return put_user(val, p);
-
-                case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].rec)
-					val |= 1 << i;
-			return put_user(val, p);
-			
-                case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].type && mixtable[i].type != MT_4MUTEMONO)
-					val |= 1 << i;
-			return put_user(val, p);
-			
-                case SOUND_MIXER_CAPS:
-			return put_user(SOUND_CAP_EXCL_INPUT, p);
-
-		default:
-			i = _IOC_NR(cmd);
-                        if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].type)
-                                return -EINVAL;
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-			return return_mixval(s, i, p);
-#else /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-			if (!volidx[i])
-				return -EINVAL;
-			return put_user(s->mix.vol[volidx[i]-1], p);
-#endif /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-		}
-	}
-        if (_SIOC_DIR(cmd) != (_SIOC_READ|_SIOC_WRITE)) 
-		return -EINVAL;
-	s->mix.modcnt++;
-	switch (_IOC_NR(cmd)) {
-	case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-		if (get_user(val, p))
-			return -EFAULT;
-		i = hweight32(val);
-		if (i == 0)
-			return 0; /*val = mixer_recmask(s);*/
-		else if (i > 1) 
-			val &= ~mixer_recmask(s);
-		for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-			if (!(val & (1 << i)))
-				continue;
-			if (mixtable[i].rec)
-				break;
-		}
-		if (i == SOUND_MIXER_NRDEVICES)
-			return 0;
-		spin_lock_irqsave(&s->lock, flags);
-		frobindir(s, SV_CIMIX_ADCINL, 0x1f, mixtable[i].rec << 5);
-		frobindir(s, SV_CIMIX_ADCINR, 0x1f, mixtable[i].rec << 5);
-		spin_unlock_irqrestore(&s->lock, flags);
-		return 0;
-
-	default:
-		i = _IOC_NR(cmd);
-		if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].type)
-			return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		l = val & 0xff;
-		r = (val >> 8) & 0xff;
-		if (mixtable[i].type == MT_4MUTEMONO)
-			l = (r + l) / 2;
-		if (l > 100)
-			l = 100;
-		if (r > 100)
-			r = 100;
-		spin_lock_irqsave(&s->lock, flags);
-		switch (mixtable[i].type) {
-		case MT_4:
-			if (l >= 10)
-				l -= 10;
-			if (r >= 10)
-				r -= 10;
-			frobindir(s, mixtable[i].left, 0xf0, l / 6);
-			frobindir(s, mixtable[i].right, 0xf0, l / 6);
-			break;
-
-		case MT_4MUTEMONO:
-			rr = 0;
-			if (l < 10)
-				rl = 0x80;
-			else {
-				if (l >= 55) {
-					rr = 0x10;
-					l -= 45;
-				}
-				rl = (55 - l) / 3;
-			}
-			wrindir(s, mixtable[i].left, rl);
-			frobindir(s, mixtable[i].right, ~0x10, rr);
-			break;
-			
-		case MT_5MUTE:
-			if (l < 7)
-				rl = 0x80;
-			else
-				rl = (100 - l) / 3;
-			if (r < 7)
-				rr = 0x80;
-			else
-				rr = (100 - r) / 3;
-			wrindir(s, mixtable[i].left, rl);
-			wrindir(s, mixtable[i].right, rr);
-			break;
-				
-		case MT_6MUTE:
-			if (l < 6)
-				rl = 0x80;
-			else
-				rl = (100 - l) * 2 / 3;
-			if (r < 6)
-				rr = 0x80;
-			else
-				rr = (100 - r) * 2 / 3;
-			wrindir(s, mixtable[i].left, rl);
-			wrindir(s, mixtable[i].right, rr);
-			break;
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-                return return_mixval(s, i, p);
-#else /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-		if (!volidx[i])
-			return -EINVAL;
-		s->mix.vol[volidx[i]-1] = val;
-		return put_user(s->mix.vol[volidx[i]-1], p);
-#endif /* OSS_DOCUMENTED_MIXER_SEMANTICS */
-	}
-}
-
-/* --------------------------------------------------------------------- */
-
-static int sv_open_mixdev(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	struct list_head *list;
-	struct sv_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct sv_state, devs);
-		if (s->dev_mixer == minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	return nonseekable_open(inode, file);
-}
-
-static int sv_release_mixdev(struct inode *inode, struct file *file)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	
-	VALIDATE_STATE(s);
-	return 0;
-}
-
-static int sv_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	return mixer_ioctl((struct sv_state *)file->private_data, cmd, arg);
-}
-
-static /*const*/ struct file_operations sv_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= sv_ioctl_mixdev,
-	.open		= sv_open_mixdev,
-	.release	= sv_release_mixdev,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac(struct sv_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count, tmo;
-
-	if (s->dma_dac.mapped || !s->dma_dac.ready)
-		return 0;
-        add_wait_queue(&s->dma_dac.wait, &wait);
-        for (;;) {
-		__set_current_state(TASK_INTERRUPTIBLE);
-                spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac.count;
-                spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-                        break;
-                if (nonblock) {
-                        remove_wait_queue(&s->dma_dac.wait, &wait);
-                        set_current_state(TASK_RUNNING);
-                        return -EBUSY;
-                }
-		tmo = 3 * HZ * (count + s->dma_dac.fragsize) / 2 / s->ratedac;
-		tmo >>= sample_shift[(s->fmt >> SV_CFMT_ASHIFT) & SV_CFMT_MASK];
-		if (!schedule_timeout(tmo + 1))
-			printk(KERN_DEBUG "sv: dma timed out??\n");
-        }
-        remove_wait_queue(&s->dma_dac.wait, &wait);
-        set_current_state(TASK_RUNNING);
-        if (signal_pending(current))
-                return -ERESTARTSYS;
-        return 0;
-}
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t sv_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_adc.mapped)
-		return -ENXIO;
-	if (!s->dma_adc.ready && (ret = prog_dmabuf(s, 1)))
-		return ret;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-#if 0
-	spin_lock_irqsave(&s->lock, flags);
-	sv_update_ptr(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-#endif
-        add_wait_queue(&s->dma_adc.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		swptr = s->dma_adc.swptr;
-		cnt = s->dma_adc.dmasize-swptr;
-		if (s->dma_adc.count < cnt)
-			cnt = s->dma_adc.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_adc.enabled)
-				start_adc(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			if (!schedule_timeout(HZ)) {
-				printk(KERN_DEBUG "sv: read: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       s->dma_adc.dmasize, s->dma_adc.fragsize, s->dma_adc.count, 
-				       s->dma_adc.hwptr, s->dma_adc.swptr);
-				stop_adc(s);
-				spin_lock_irqsave(&s->lock, flags);
-				set_dmac(s, virt_to_bus(s->dma_adc.rawbuf), s->dma_adc.numfrag << s->dma_adc.fragshift);
-				/* program enhanced mode registers */
-				wrindir(s, SV_CIDMACBASECOUNT1, (s->dma_adc.fragsamples-1) >> 8);
-				wrindir(s, SV_CIDMACBASECOUNT0, s->dma_adc.fragsamples-1);
-				s->dma_adc.count = s->dma_adc.hwptr = s->dma_adc.swptr = 0;
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		swptr = (swptr + cnt) % s->dma_adc.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_adc.swptr = swptr;
-		s->dma_adc.count -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_adc.enabled)
-			start_adc(s);
-	}
-        remove_wait_queue(&s->dma_adc.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-static ssize_t sv_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_dac.mapped)
-		return -ENXIO;
-	if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-		return ret;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-#if 0
-	spin_lock_irqsave(&s->lock, flags);
-	sv_update_ptr(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-#endif
-        add_wait_queue(&s->dma_dac.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		if (s->dma_dac.count < 0) {
-			s->dma_dac.count = 0;
-			s->dma_dac.swptr = s->dma_dac.hwptr;
-		}
-		swptr = s->dma_dac.swptr;
-		cnt = s->dma_dac.dmasize-swptr;
-		if (s->dma_dac.count + cnt > s->dma_dac.dmasize)
-			cnt = s->dma_dac.dmasize - s->dma_dac.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_dac.enabled)
-				start_dac(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			if (!schedule_timeout(HZ)) {
-				printk(KERN_DEBUG "sv: write: chip lockup? dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       s->dma_dac.dmasize, s->dma_dac.fragsize, s->dma_dac.count, 
-				       s->dma_dac.hwptr, s->dma_dac.swptr);
-				stop_dac(s);
-				spin_lock_irqsave(&s->lock, flags);
-				set_dmaa(s, virt_to_bus(s->dma_dac.rawbuf), s->dma_dac.numfrag << s->dma_dac.fragshift);
-				/* program enhanced mode registers */
-				wrindir(s, SV_CIDMAABASECOUNT1, (s->dma_dac.fragsamples-1) >> 8);
-				wrindir(s, SV_CIDMAABASECOUNT0, s->dma_dac.fragsamples-1);
-				s->dma_dac.count = s->dma_dac.hwptr = s->dma_dac.swptr = 0;
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(s->dma_dac.rawbuf + swptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		swptr = (swptr + cnt) % s->dma_dac.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac.swptr = swptr;
-		s->dma_dac.count += cnt;
-		s->dma_dac.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_dac.enabled)
-			start_dac(s);
-	}
-        remove_wait_queue(&s->dma_dac.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int sv_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac.ready && prog_dmabuf(s, 1))
-			return 0;
-		poll_wait(file, &s->dma_dac.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!s->dma_adc.ready && prog_dmabuf(s, 0))
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	sv_update_ptr(s);
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac.mapped) {
-			if (s->dma_dac.count >= (signed)s->dma_dac.fragsize) 
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed)s->dma_dac.dmasize >= s->dma_dac.count + (signed)s->dma_dac.fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int sv_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	struct dmabuf *db;
-	int ret = -EINVAL;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf(s, 1)) != 0)
-			goto out;
-		db = &s->dma_dac;
-	} else if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf(s, 0)) != 0)
-			goto out;
-		db = &s->dma_adc;
-	} else 
-		goto out;
-	ret = -EINVAL;
-	if (vma->vm_pgoff != 0)
-		goto out;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder))
-		goto out;
-	ret = -EAGAIN;
-	if (remap_pfn_range(vma, vma->vm_start,
-				virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-				size, vma->vm_page_prot))
-		goto out;
-	db->mapped = 1;
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-static int sv_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int count;
-	int val, mapped, ret;
-	unsigned char fmtm, fmtd;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_STATE(s);
-        mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac(s, 0/*file->f_flags & O_NONBLOCK*/);
-		return 0;
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-		
-        case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			synchronize_irq(s->irq);
-			s->dma_dac.swptr = s->dma_dac.hwptr = s->dma_dac.count = s->dma_dac.total_bytes = 0;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->irq);
-			s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				set_adc_rate(s, val);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				set_dac_rate(s, val);
-			}
-		}
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-		
-        case SNDCTL_DSP_STEREO:
-                if (get_user(val, p))
-			return -EFAULT;
-		fmtd = 0;
-		fmtm = ~0;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ready = 0;
-			if (val)
-				fmtd |= SV_CFMT_STEREO << SV_CFMT_CSHIFT;
-			else
-				fmtm &= ~(SV_CFMT_STEREO << SV_CFMT_CSHIFT);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac(s);
-			s->dma_dac.ready = 0;
-			if (val)
-				fmtd |= SV_CFMT_STEREO << SV_CFMT_ASHIFT;
-			else
-				fmtm &= ~(SV_CFMT_STEREO << SV_CFMT_ASHIFT);
-		}
-		set_fmt(s, fmtm, fmtd);
-		return 0;
-
-        case SNDCTL_DSP_CHANNELS:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 0) {
-			fmtd = 0;
-			fmtm = ~0;
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val >= 2)
-					fmtd |= SV_CFMT_STEREO << SV_CFMT_CSHIFT;
-				else
-					fmtm &= ~(SV_CFMT_STEREO << SV_CFMT_CSHIFT);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val >= 2)
-					fmtd |= SV_CFMT_STEREO << SV_CFMT_ASHIFT;
-				else
-					fmtm &= ~(SV_CFMT_STEREO << SV_CFMT_ASHIFT);
-			}
-			set_fmt(s, fmtm, fmtd);
-		}
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (SV_CFMT_STEREO << SV_CFMT_CSHIFT) 
-					   : (SV_CFMT_STEREO << SV_CFMT_ASHIFT))) ? 2 : 1, p);
-		
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(AFMT_S16_LE|AFMT_U8, p);
-		
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			fmtd = 0;
-			fmtm = ~0;
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				if (val == AFMT_S16_LE)
-					fmtd |= SV_CFMT_16BIT << SV_CFMT_CSHIFT;
-				else
-					fmtm &= ~(SV_CFMT_16BIT << SV_CFMT_CSHIFT);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac(s);
-				s->dma_dac.ready = 0;
-				if (val == AFMT_S16_LE)
-					fmtd |= SV_CFMT_16BIT << SV_CFMT_ASHIFT;
-				else
-					fmtm &= ~(SV_CFMT_16BIT << SV_CFMT_ASHIFT);
-			}
-			set_fmt(s, fmtm, fmtd);
-		}
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (SV_CFMT_16BIT << SV_CFMT_CSHIFT) 
-					   : (SV_CFMT_16BIT << SV_CFMT_ASHIFT))) ? AFMT_S16_LE : AFMT_U8, p);
-		
-	case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if (file->f_mode & FMODE_READ && s->enable & SV_CENABLE_RE) 
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && s->enable & SV_CENABLE_PE) 
-			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, p);
-		
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready && (ret =  prog_dmabuf(s, 1)))
-					return ret;
-				s->dma_adc.enabled = 1;
-				start_adc(s);
-			} else {
-				s->dma_adc.enabled = 0;
-				stop_adc(s);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac.ready && (ret = prog_dmabuf(s, 0)))
-					return ret;
-				s->dma_dac.enabled = 1;
-				start_dac(s);
-			} else {
-				s->dma_dac.enabled = 0;
-				stop_dac(s);
-			}
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf(s, 0)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		sv_update_ptr(s);
-		abinfo.fragsize = s->dma_dac.fragsize;
-		count = s->dma_dac.count;
-		if (count < 0)
-			count = 0;
-                abinfo.bytes = s->dma_dac.dmasize - count;
-                abinfo.fragstotal = s->dma_dac.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf(s, 1)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		sv_update_ptr(s);
-		abinfo.fragsize = s->dma_adc.fragsize;
-		count = s->dma_adc.count;
-		if (count < 0)
-			count = 0;
-                abinfo.bytes = count;
-                abinfo.fragstotal = s->dma_adc.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-		
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf(s, 0)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		sv_update_ptr(s);
-                count = s->dma_dac.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		return put_user(count, p);
-
-        case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf(s, 1)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		sv_update_ptr(s);
-                cinfo.bytes = s->dma_adc.total_bytes;
-		count = s->dma_adc.count;
-		if (count < 0)
-			count = 0;
-                cinfo.blocks = count >> s->dma_adc.fragshift;
-                cinfo.ptr = s->dma_adc.hwptr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac.ready && (val = prog_dmabuf(s, 0)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		sv_update_ptr(s);
-                cinfo.bytes = s->dma_dac.total_bytes;
-		count = s->dma_dac.count;
-		if (count < 0)
-			count = 0;
-                cinfo.blocks = count >> s->dma_dac.fragshift;
-                cinfo.ptr = s->dma_dac.hwptr;
-		if (s->dma_dac.mapped)
-			s->dma_dac.count &= s->dma_dac.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-                if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf(s, 0)))
-				return val;
-			return put_user(s->dma_dac.fragsize, p);
-		}
-		if ((val = prog_dmabuf(s, 1)))
-			return val;
-		return put_user(s->dma_adc.fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			s->dma_dac.ossfragshift = val & 0xffff;
-			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac.ossfragshift < 4)
-				s->dma_dac.ossfragshift = 4;
-			if (s->dma_dac.ossfragshift > 15)
-				s->dma_dac.ossfragshift = 15;
-			if (s->dma_dac.ossmaxfrags < 4)
-				s->dma_dac.ossmaxfrags = 4;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
-			return -EINVAL;
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		if (file->f_mode & FMODE_WRITE)
-			s->dma_dac.subdivision = val;
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		return put_user((file->f_mode & FMODE_READ) ? s->rateadc : s->ratedac, p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (SV_CFMT_STEREO << SV_CFMT_CSHIFT) 
-					   : (SV_CFMT_STEREO << SV_CFMT_ASHIFT))) ? 2 : 1, p);
-
-        case SOUND_PCM_READ_BITS:
-		return put_user((s->fmt & ((file->f_mode & FMODE_READ) ? (SV_CFMT_16BIT << SV_CFMT_CSHIFT) 
-					   : (SV_CFMT_16BIT << SV_CFMT_ASHIFT))) ? 16 : 8, p);
-
-        case SOUND_PCM_WRITE_FILTER:
-        case SNDCTL_DSP_SETSYNCRO:
-        case SOUND_PCM_READ_FILTER:
-                return -EINVAL;
-		
-	}
-	return mixer_ioctl(s, cmd, arg);
-}
-
-static int sv_open(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned char fmtm = ~0, fmts = 0;
-	struct list_head *list;
-	struct sv_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct sv_state, devs);
-		if (!((s->dev_audio ^ minor) & ~0xf))
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & file->f_mode) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	if (file->f_mode & FMODE_READ) {
-		fmtm &= ~((SV_CFMT_STEREO | SV_CFMT_16BIT) << SV_CFMT_CSHIFT);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			fmts |= SV_CFMT_16BIT << SV_CFMT_CSHIFT;
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
-		s->dma_adc.enabled = 1;
-		set_adc_rate(s, 8000);
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		fmtm &= ~((SV_CFMT_STEREO | SV_CFMT_16BIT) << SV_CFMT_ASHIFT);
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			fmts |= SV_CFMT_16BIT << SV_CFMT_ASHIFT;
-		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags = s->dma_dac.subdivision = 0;
-		s->dma_dac.enabled = 1;
-		set_dac_rate(s, 8000);
-	}
-	set_fmt(s, fmtm, fmts);
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int sv_release(struct inode *inode, struct file *file)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE)
-		drain_dac(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac(s);
-		dealloc_dmabuf(s, &s->dma_dac);
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-		dealloc_dmabuf(s, &s->dma_adc);
-	}
-	s->open_mode &= ~(file->f_mode & (FMODE_READ|FMODE_WRITE));
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations sv_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= sv_read,
-	.write		= sv_write,
-	.poll		= sv_poll,
-	.ioctl		= sv_ioctl,
-	.mmap		= sv_mmap,
-	.open		= sv_open,
-	.release	= sv_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t sv_midi_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	if (count == 0)
-		return 0;
-	ret = 0;
-	add_wait_queue(&s->midi.iwait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.ird;
-		cnt = MIDIINBUF - ptr;
-		if (s->midi.icnt < cnt)
-			cnt = s->midi.icnt;
-		if (cnt <= 0)
-                      __set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-                      if (file->f_flags & O_NONBLOCK) {
-                              if (!ret)
-                                      ret = -EAGAIN;
-                              break;
-                      }
-                      schedule();
-                      if (signal_pending(current)) {
-                              if (!ret)
-                                      ret = -ERESTARTSYS;
-                              break;
-                      }
-			continue;
-		}
-		if (copy_to_user(buffer, s->midi.ibuf + ptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		ptr = (ptr + cnt) % MIDIINBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.ird = ptr;
-		s->midi.icnt -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		break;
-	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&s->midi.iwait, &wait);
-	return ret;
-}
-
-static ssize_t sv_midi_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	if (count == 0)
-		return 0;
-	ret = 0;
-        add_wait_queue(&s->midi.owait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.owr;
-		cnt = MIDIOUTBUF - ptr;
-		if (s->midi.ocnt + cnt > MIDIOUTBUF)
-			cnt = MIDIOUTBUF - s->midi.ocnt;
-		if (cnt <= 0) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			sv_handle_midi(s);
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(s->midi.obuf + ptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		ptr = (ptr + cnt) % MIDIOUTBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.owr = ptr;
-		s->midi.ocnt += cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		spin_lock_irqsave(&s->lock, flags);
-		sv_handle_midi(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&s->midi.owait, &wait);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int sv_midi_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE)
-		poll_wait(file, &s->midi.owait, wait);
-	if (file->f_mode & FMODE_READ)
-		poll_wait(file, &s->midi.iwait, wait);
-	spin_lock_irqsave(&s->lock, flags);
-	if (file->f_mode & FMODE_READ) {
-		if (s->midi.icnt > 0)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->midi.ocnt < MIDIOUTBUF)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int sv_midi_open(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	struct list_head *list;
-	struct sv_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct sv_state, devs);
-		if (s->dev_midi == minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & (file->f_mode << FMODE_MIDI_SHIFT)) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-		//outb(inb(s->ioenh + SV_CODEC_CONTROL) | SV_CCTRL_WAVETABLE, s->ioenh + SV_CODEC_CONTROL);
-		outb(inb(s->ioenh + SV_CODEC_INTMASK) | SV_CINTMASK_MIDI, s->ioenh + SV_CODEC_INTMASK);
-		wrindir(s, SV_CIUARTCONTROL, 5); /* output MIDI data to external and internal synth */
-		wrindir(s, SV_CIWAVETABLESRC, 1); /* Wavetable in PC RAM */
-		outb(0xff, s->iomidi+1); /* reset command */
-		outb(0x3f, s->iomidi+1); /* uart command */
-		if (!(inb(s->iomidi+1) & 0x80))
-			inb(s->iomidi);
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		init_timer(&s->midi.timer);
-		s->midi.timer.expires = jiffies+1;
-		s->midi.timer.data = (unsigned long)s;
-		s->midi.timer.function = sv_midi_timer;
-		add_timer(&s->midi.timer);
-	}
-	if (file->f_mode & FMODE_READ) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->open_mode |= (file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ | FMODE_MIDI_WRITE);
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int sv_midi_release(struct inode *inode, struct file *file)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	unsigned count, tmo;
-
-	VALIDATE_STATE(s);
-
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE) {
-		add_wait_queue(&s->midi.owait, &wait);
-		for (;;) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			spin_lock_irqsave(&s->lock, flags);
-			count = s->midi.ocnt;
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (count <= 0)
-				break;
-			if (signal_pending(current))
-				break;
-			if (file->f_flags & O_NONBLOCK) {
-				remove_wait_queue(&s->midi.owait, &wait);
-				set_current_state(TASK_RUNNING);
-				unlock_kernel();
-				return -EBUSY;
-			}
-			tmo = (count * HZ) / 3100;
-			if (!schedule_timeout(tmo ? : 1) && tmo)
-				printk(KERN_DEBUG "sv: midi timed out??\n");
-		}
-		remove_wait_queue(&s->midi.owait, &wait);
-		set_current_state(TASK_RUNNING);
-	}
-	mutex_lock(&s->open_mutex);
-	s->open_mode &= ~((file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ|FMODE_MIDI_WRITE));
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		outb(inb(s->ioenh + SV_CODEC_INTMASK) & ~SV_CINTMASK_MIDI, s->ioenh + SV_CODEC_INTMASK);
-		del_timer(&s->midi.timer);		
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations sv_midi_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= sv_midi_read,
-	.write		= sv_midi_write,
-	.poll		= sv_midi_poll,
-	.open		= sv_midi_open,
-	.release	= sv_midi_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int sv_dmfm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	static const unsigned char op_offset[18] = {
-		0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
-		0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
-		0x10, 0x11, 0x12, 0x13, 0x14, 0x15
-	};
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	struct dm_fm_voice v;
-	struct dm_fm_note n;
-	struct dm_fm_params p;
-	unsigned int io;
-	unsigned int regb;
-
-	switch (cmd) {		
-	case FM_IOCTL_RESET:
-		for (regb = 0xb0; regb < 0xb9; regb++) {
-			outb(regb, s->iosynth);
-			outb(0, s->iosynth+1);
-			outb(regb, s->iosynth+2);
-			outb(0, s->iosynth+3);
-		}
-		return 0;
-
-	case FM_IOCTL_PLAY_NOTE:
-		if (copy_from_user(&n, (void __user *)arg, sizeof(n)))
-			return -EFAULT;
-		if (n.voice >= 18)
-			return -EINVAL;
-		if (n.voice >= 9) {
-			regb = n.voice - 9;
-			io = s->iosynth+2;
-		} else {
-			regb = n.voice;
-			io = s->iosynth;
-		}
-		outb(0xa0 + regb, io);
-		outb(n.fnum & 0xff, io+1);
-		outb(0xb0 + regb, io);
-		outb(((n.fnum >> 8) & 3) | ((n.octave & 7) << 2) | ((n.key_on & 1) << 5), io+1);
-		return 0;
-
-	case FM_IOCTL_SET_VOICE:
-		if (copy_from_user(&v, (void __user *)arg, sizeof(v)))
-			return -EFAULT;
-		if (v.voice >= 18)
-			return -EINVAL;
-		regb = op_offset[v.voice];
-		io = s->iosynth + ((v.op & 1) << 1);
-		outb(0x20 + regb, io);
-		outb(((v.am & 1) << 7) | ((v.vibrato & 1) << 6) | ((v.do_sustain & 1) << 5) | 
-		     ((v.kbd_scale & 1) << 4) | (v.harmonic & 0xf), io+1);
-		outb(0x40 + regb, io);
-		outb(((v.scale_level & 0x3) << 6) | (v.volume & 0x3f), io+1);
-		outb(0x60 + regb, io);
-		outb(((v.attack & 0xf) << 4) | (v.decay & 0xf), io+1);
-		outb(0x80 + regb, io);
-		outb(((v.sustain & 0xf) << 4) | (v.release & 0xf), io+1);
-		outb(0xe0 + regb, io);
-		outb(v.waveform & 0x7, io+1);
-		if (n.voice >= 9) {
-			regb = n.voice - 9;
-			io = s->iosynth+2;
-		} else {
-			regb = n.voice;
-			io = s->iosynth;
-		}
-		outb(0xc0 + regb, io);
-		outb(((v.right & 1) << 5) | ((v.left & 1) << 4) | ((v.feedback & 7) << 1) |
-		     (v.connection & 1), io+1);
-		return 0;
-		
-	case FM_IOCTL_SET_PARAMS:
-		if (copy_from_user(&p, (void *__user )arg, sizeof(p)))
-			return -EFAULT;
-		outb(0x08, s->iosynth);
-		outb((p.kbd_split & 1) << 6, s->iosynth+1);
-		outb(0xbd, s->iosynth);
-		outb(((p.am_depth & 1) << 7) | ((p.vib_depth & 1) << 6) | ((p.rhythm & 1) << 5) | ((p.bass & 1) << 4) |
-		     ((p.snare & 1) << 3) | ((p.tomtom & 1) << 2) | ((p.cymbal & 1) << 1) | (p.hihat & 1), s->iosynth+1);
-		return 0;
-
-	case FM_IOCTL_SET_OPL:
-		outb(4, s->iosynth+2);
-		outb(arg, s->iosynth+3);
-		return 0;
-
-	case FM_IOCTL_SET_MODE:
-		outb(5, s->iosynth+2);
-		outb(arg & 1, s->iosynth+3);
-		return 0;
-
-	default:
-		return -EINVAL;
-	}
-}
-
-static int sv_dmfm_open(struct inode *inode, struct file *file)
-{
-	int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	struct list_head *list;
-	struct sv_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct sv_state, devs);
-		if (s->dev_dmfm == minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & FMODE_DMFM) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	/* init the stuff */
-	outb(1, s->iosynth);
-	outb(0x20, s->iosynth+1); /* enable waveforms */
-	outb(4, s->iosynth+2);
-	outb(0, s->iosynth+3);  /* no 4op enabled */
-	outb(5, s->iosynth+2);
-	outb(1, s->iosynth+3);  /* enable OPL3 */
-	s->open_mode |= FMODE_DMFM;
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int sv_dmfm_release(struct inode *inode, struct file *file)
-{
-	struct sv_state *s = (struct sv_state *)file->private_data;
-	unsigned int regb;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	mutex_lock(&s->open_mutex);
-	s->open_mode &= ~FMODE_DMFM;
-	for (regb = 0xb0; regb < 0xb9; regb++) {
-		outb(regb, s->iosynth);
-		outb(0, s->iosynth+1);
-		outb(regb, s->iosynth+2);
-		outb(0, s->iosynth+3);
-	}
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations sv_dmfm_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= sv_dmfm_ioctl,
-	.open		= sv_dmfm_open,
-	.release	= sv_dmfm_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-/* maximum number of devices; only used for command line params */
-#define NR_DEVICE 5
-
-static int reverb[NR_DEVICE];
-
-#if 0
-static int wavetable[NR_DEVICE];
-#endif
-
-static unsigned int devindex;
-
-module_param_array(reverb, bool, NULL, 0);
-MODULE_PARM_DESC(reverb, "if 1 enables the reverb circuitry. NOTE: your card must have the reverb RAM");
-#if 0
-MODULE_PARM(wavetable, "1-" __MODULE_STRING(NR_DEVICE) "i");
-MODULE_PARM_DESC(wavetable, "if 1 the wavetable synth is enabled");
-#endif
-
-MODULE_AUTHOR("Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu");
-MODULE_DESCRIPTION("S3 SonicVibes Driver");
-MODULE_LICENSE("GPL");
-
-
-/* --------------------------------------------------------------------- */
-
-static struct initvol {
-	int mixch;
-	int vol;
-} initvol[] __devinitdata = {
-	{ SOUND_MIXER_WRITE_RECLEV, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE1, 0x4040 },
-	{ SOUND_MIXER_WRITE_CD, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE, 0x4040 },
-	{ SOUND_MIXER_WRITE_MIC, 0x4040 },
-	{ SOUND_MIXER_WRITE_SYNTH, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE2, 0x4040 },
-	{ SOUND_MIXER_WRITE_VOLUME, 0x4040 },
-	{ SOUND_MIXER_WRITE_PCM, 0x4040 }
-};
-
-#define RSRCISIOREGION(dev,num) (pci_resource_start((dev), (num)) != 0 && \
-				 (pci_resource_flags((dev), (num)) & IORESOURCE_IO))
-
-#ifdef SUPPORT_JOYSTICK
-static int __devinit sv_register_gameport(struct sv_state *s, int io_port)
-{
-	struct gameport *gp;
-
-	if (!request_region(io_port, SV_EXTENT_GAME, "S3 SonicVibes Gameport")) {
-		printk(KERN_ERR "sv: gameport io ports are in use\n");
-		return -EBUSY;
-	}
-
-	s->gameport = gp = gameport_allocate_port();
-	if (!gp) {
-		printk(KERN_ERR "sv: can not allocate memory for gameport\n");
-		release_region(io_port, SV_EXTENT_GAME);
-		return -ENOMEM;
-	}
-
-	gameport_set_name(gp, "S3 SonicVibes Gameport");
-	gameport_set_phys(gp, "isa%04x/gameport0", io_port);
-	gp->dev.parent = &s->dev->dev;
-	gp->io = io_port;
-
-	gameport_register_port(gp);
-
-	return 0;
-}
-
-static inline void sv_unregister_gameport(struct sv_state *s)
-{
-	if (s->gameport) {
-		int gpio = s->gameport->io;
-		gameport_unregister_port(s->gameport);
-		release_region(gpio, SV_EXTENT_GAME);
-	}
-}
-#else
-static inline int sv_register_gameport(struct sv_state *s, int io_port) { return -ENOSYS; }
-static inline void sv_unregister_gameport(struct sv_state *s) { }
-#endif /* SUPPORT_JOYSTICK */
-
-static int __devinit sv_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
-{
-	static char __devinitdata sv_ddma_name[] = "S3 Inc. SonicVibes DDMA Controller";
-       	struct sv_state *s;
-	mm_segment_t fs;
-	int i, val, ret;
-	int gpio;
-	char *ddmaname;
-	unsigned ddmanamelen;
-
-	if ((ret=pci_enable_device(pcidev)))
-		return ret;
-
-	if (!RSRCISIOREGION(pcidev, RESOURCE_SB) ||
-	    !RSRCISIOREGION(pcidev, RESOURCE_ENH) ||
-	    !RSRCISIOREGION(pcidev, RESOURCE_SYNTH) ||
-	    !RSRCISIOREGION(pcidev, RESOURCE_MIDI) ||
-	    !RSRCISIOREGION(pcidev, RESOURCE_GAME))
-		return -ENODEV;
-	if (pcidev->irq == 0)
-		return -ENODEV;
-	if (pci_set_dma_mask(pcidev, DMA_24BIT_MASK)) {
-		printk(KERN_WARNING "sonicvibes: architecture does not support 24bit PCI busmaster DMA\n");
-		return -ENODEV;
-	}
-	/* try to allocate a DDMA resource if not already available */
-	if (!RSRCISIOREGION(pcidev, RESOURCE_DDMA)) {
-		pcidev->resource[RESOURCE_DDMA].start = 0;
-		pcidev->resource[RESOURCE_DDMA].end = 2*SV_EXTENT_DMA-1;
-		pcidev->resource[RESOURCE_DDMA].flags = PCI_BASE_ADDRESS_SPACE_IO | IORESOURCE_IO;
-		ddmanamelen = strlen(sv_ddma_name)+1;
-		if (!(ddmaname = kmalloc(ddmanamelen, GFP_KERNEL)))
-			return -1;
-		memcpy(ddmaname, sv_ddma_name, ddmanamelen);
-		pcidev->resource[RESOURCE_DDMA].name = ddmaname;
-		if (pci_assign_resource(pcidev, RESOURCE_DDMA)) {
-			pcidev->resource[RESOURCE_DDMA].name = NULL;
-			kfree(ddmaname);
-			printk(KERN_ERR "sv: cannot allocate DDMA controller io ports\n");
-			return -EBUSY;
-		}
-	}
-	if (!(s = kmalloc(sizeof(struct sv_state), GFP_KERNEL))) {
-		printk(KERN_WARNING "sv: out of memory\n");
-		return -ENOMEM;
-	}
-	memset(s, 0, sizeof(struct sv_state));
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac.wait);
-	init_waitqueue_head(&s->open_wait);
-	init_waitqueue_head(&s->midi.iwait);
-	init_waitqueue_head(&s->midi.owait);
-	mutex_init(&s->open_mutex);
-	spin_lock_init(&s->lock);
-	s->magic = SV_MAGIC;
-	s->dev = pcidev;
-	s->iosb = pci_resource_start(pcidev, RESOURCE_SB);
-	s->ioenh = pci_resource_start(pcidev, RESOURCE_ENH);
-	s->iosynth = pci_resource_start(pcidev, RESOURCE_SYNTH);
-	s->iomidi = pci_resource_start(pcidev, RESOURCE_MIDI);
-	s->iodmaa = pci_resource_start(pcidev, RESOURCE_DDMA);
-	s->iodmac = pci_resource_start(pcidev, RESOURCE_DDMA) + SV_EXTENT_DMA;
-	gpio = pci_resource_start(pcidev, RESOURCE_GAME);
-	pci_write_config_dword(pcidev, 0x40, s->iodmaa | 9);  /* enable and use extended mode */
-	pci_write_config_dword(pcidev, 0x48, s->iodmac | 9);  /* enable */
-	printk(KERN_DEBUG "sv: io ports: %#lx %#lx %#lx %#lx %#x %#x %#x\n",
-	       s->iosb, s->ioenh, s->iosynth, s->iomidi, gpio, s->iodmaa, s->iodmac);
-	s->irq = pcidev->irq;
-	
-	/* hack */
-	pci_write_config_dword(pcidev, 0x60, wavetable_mem >> 12);  /* wavetable base address */
-
-	ret = -EBUSY;
-	if (!request_region(s->ioenh, SV_EXTENT_ENH, "S3 SonicVibes PCM")) {
-		printk(KERN_ERR "sv: io ports %#lx-%#lx in use\n", s->ioenh, s->ioenh+SV_EXTENT_ENH-1);
-		goto err_region5;
-	}
-	if (!request_region(s->iodmaa, SV_EXTENT_DMA, "S3 SonicVibes DMAA")) {
-		printk(KERN_ERR "sv: io ports %#x-%#x in use\n", s->iodmaa, s->iodmaa+SV_EXTENT_DMA-1);
-		goto err_region4;
-	}
-	if (!request_region(s->iodmac, SV_EXTENT_DMA, "S3 SonicVibes DMAC")) {
-		printk(KERN_ERR "sv: io ports %#x-%#x in use\n", s->iodmac, s->iodmac+SV_EXTENT_DMA-1);
-		goto err_region3;
-	}
-	if (!request_region(s->iomidi, SV_EXTENT_MIDI, "S3 SonicVibes Midi")) {
-		printk(KERN_ERR "sv: io ports %#lx-%#lx in use\n", s->iomidi, s->iomidi+SV_EXTENT_MIDI-1);
-		goto err_region2;
-	}
-	if (!request_region(s->iosynth, SV_EXTENT_SYNTH, "S3 SonicVibes Synth")) {
-		printk(KERN_ERR "sv: io ports %#lx-%#lx in use\n", s->iosynth, s->iosynth+SV_EXTENT_SYNTH-1);
-		goto err_region1;
-	}
-
-	/* initialize codec registers */
-	outb(0x80, s->ioenh + SV_CODEC_CONTROL); /* assert reset */
-	udelay(50);
-	outb(0x00, s->ioenh + SV_CODEC_CONTROL); /* deassert reset */
-	udelay(50);
-	outb(SV_CCTRL_INTADRIVE | SV_CCTRL_ENHANCED /*| SV_CCTRL_WAVETABLE */
-	     | (reverb[devindex] ? SV_CCTRL_REVERB : 0), s->ioenh + SV_CODEC_CONTROL);
-	inb(s->ioenh + SV_CODEC_STATUS); /* clear ints */
-	wrindir(s, SV_CIDRIVECONTROL, 0);  /* drive current 16mA */
-	wrindir(s, SV_CIENABLE, s->enable = 0);  /* disable DMAA and DMAC */
-	outb(~(SV_CINTMASK_DMAA | SV_CINTMASK_DMAC), s->ioenh + SV_CODEC_INTMASK);
-	/* outb(0xff, s->iodmaa + SV_DMA_RESET); */
-	/* outb(0xff, s->iodmac + SV_DMA_RESET); */
-	inb(s->ioenh + SV_CODEC_STATUS); /* ack interrupts */
-	wrindir(s, SV_CIADCCLKSOURCE, 0); /* use pll as ADC clock source */
-	wrindir(s, SV_CIANALOGPWRDOWN, 0); /* power up the analog parts of the device */
-	wrindir(s, SV_CIDIGITALPWRDOWN, 0); /* power up the digital parts of the device */
-	setpll(s, SV_CIADCPLLM, 8000);
-	wrindir(s, SV_CISRSSPACE, 0x80); /* SRS off */
-	wrindir(s, SV_CIPCMSR0, (8000 * 65536 / FULLRATE) & 0xff);
-	wrindir(s, SV_CIPCMSR1, ((8000 * 65536 / FULLRATE) >> 8) & 0xff);
-	wrindir(s, SV_CIADCOUTPUT, 0);
-	/* request irq */
-	if ((ret=request_irq(s->irq,sv_interrupt,IRQF_SHARED,"S3 SonicVibes",s))) {
-		printk(KERN_ERR "sv: irq %u in use\n", s->irq);
-		goto err_irq;
-	}
-	printk(KERN_INFO "sv: found adapter at io %#lx irq %u dmaa %#06x dmac %#06x revision %u\n",
-	       s->ioenh, s->irq, s->iodmaa, s->iodmac, rdindir(s, SV_CIREVISION));
-	/* register devices */
-	if ((s->dev_audio = register_sound_dsp(&sv_audio_fops, -1)) < 0) {
-		ret = s->dev_audio;
-		goto err_dev1;
-	}
-	if ((s->dev_mixer = register_sound_mixer(&sv_mixer_fops, -1)) < 0) {
-		ret = s->dev_mixer;
-		goto err_dev2;
-	}
-	if ((s->dev_midi = register_sound_midi(&sv_midi_fops, -1)) < 0) {
-		ret = s->dev_midi;
-		goto err_dev3;
-	}
-	if ((s->dev_dmfm = register_sound_special(&sv_dmfm_fops, 15 /* ?? */)) < 0) {
-		ret = s->dev_dmfm;
-		goto err_dev4;
-	}
-	pci_set_master(pcidev);  /* enable bus mastering */
-	/* initialize the chips */
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	val = SOUND_MASK_LINE|SOUND_MASK_SYNTH;
-	mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
-	for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
-		val = initvol[i].vol;
-		mixer_ioctl(s, initvol[i].mixch, (unsigned long)&val);
-	}
-	set_fs(fs);
-	/* register gameport */
-	sv_register_gameport(s, gpio);
-	/* store it in the driver field */
-	pci_set_drvdata(pcidev, s);
-	/* put it into driver list */
-	list_add_tail(&s->devs, &devs);
-	/* increment devindex */
-	if (devindex < NR_DEVICE-1)
-		devindex++;
-	return 0;
-
- err_dev4:
-	unregister_sound_midi(s->dev_midi);
- err_dev3:
-	unregister_sound_mixer(s->dev_mixer);
- err_dev2:
-	unregister_sound_dsp(s->dev_audio);
- err_dev1:
-	printk(KERN_ERR "sv: cannot register misc device\n");
-	free_irq(s->irq, s);
- err_irq:
-	release_region(s->iosynth, SV_EXTENT_SYNTH);
- err_region1:
-	release_region(s->iomidi, SV_EXTENT_MIDI);
- err_region2:
-	release_region(s->iodmac, SV_EXTENT_DMA);
- err_region3:
-	release_region(s->iodmaa, SV_EXTENT_DMA);
- err_region4:
-	release_region(s->ioenh, SV_EXTENT_ENH);
- err_region5:
-	kfree(s);
-	return ret;
-}
-
-static void __devexit sv_remove(struct pci_dev *dev)
-{
-	struct sv_state *s = pci_get_drvdata(dev);
-
-	if (!s)
-		return;
-	list_del(&s->devs);
-	outb(~0, s->ioenh + SV_CODEC_INTMASK);  /* disable ints */
-	synchronize_irq(s->irq);
-	inb(s->ioenh + SV_CODEC_STATUS); /* ack interrupts */
-	wrindir(s, SV_CIENABLE, 0);     /* disable DMAA and DMAC */
-	/*outb(0, s->iodmaa + SV_DMA_RESET);*/
-	/*outb(0, s->iodmac + SV_DMA_RESET);*/
-	free_irq(s->irq, s);
-	sv_unregister_gameport(s);
-	release_region(s->iodmac, SV_EXTENT_DMA);
-	release_region(s->iodmaa, SV_EXTENT_DMA);
-	release_region(s->ioenh, SV_EXTENT_ENH);
-	release_region(s->iomidi, SV_EXTENT_MIDI);
-	release_region(s->iosynth, SV_EXTENT_SYNTH);
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->dev_mixer);
-	unregister_sound_midi(s->dev_midi);
-	unregister_sound_special(s->dev_dmfm);
-	kfree(s);
-	pci_set_drvdata(dev, NULL);
-}
-
-static struct pci_device_id id_table[] = {
-       { PCI_VENDOR_ID_S3, PCI_DEVICE_ID_S3_SONICVIBES, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
-       { 0, }
-};
-
-MODULE_DEVICE_TABLE(pci, id_table);
-
-static struct pci_driver sv_driver = {
-       .name		= "sonicvibes",
-       .id_table	= id_table,
-       .probe		= sv_probe,
-       .remove		= __devexit_p(sv_remove),
-};
- 
-static int __init init_sonicvibes(void)
-{
-	printk(KERN_INFO "sv: version v0.31 time " __TIME__ " " __DATE__ "\n");
-#if 0
-	if (!(wavetable_mem = __get_free_pages(GFP_KERNEL, 20-PAGE_SHIFT)))
-		printk(KERN_INFO "sv: cannot allocate 1MB of contiguous nonpageable memory for wavetable data\n");
-#endif
-	return pci_register_driver(&sv_driver);
-}
-
-static void __exit cleanup_sonicvibes(void)
-{
-	printk(KERN_INFO "sv: unloading\n");
-	pci_unregister_driver(&sv_driver);
- 	if (wavetable_mem)
-		free_pages(wavetable_mem, 20-PAGE_SHIFT);
-}
-
-module_init(init_sonicvibes);
-module_exit(cleanup_sonicvibes);
-
-/* --------------------------------------------------------------------- */
-
-#ifndef MODULE
-
-/* format is: sonicvibes=[reverb] sonicvibesdmaio=dmaioaddr */
-
-static int __init sonicvibes_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= NR_DEVICE)
-		return 0;
-#if 0
-	if (get_option(&str, &reverb[nr_dev]) == 2)
-		(void)get_option(&str, &wavetable[nr_dev]);
-#else
-	(void)get_option(&str, &reverb[nr_dev]);
-#endif
-
-	nr_dev++;
-	return 1;
-}
-
-__setup("sonicvibes=", sonicvibes_setup);
-
-#endif /* MODULE */
--- linux-2.6.18.noarch/sound/oss/ali5455.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ali5455.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,3735 +0,0 @@
-/*
- *	ALI  ali5455 and friends ICH driver for Linux
- *	LEI HU <Lei_Hu@ali.com.tw>
- *
- *  Built from:
- *	drivers/sound/i810_audio
- *
- *  	The ALi 5455 is similar but not quite identical to the Intel ICH
- *	series of controllers. Its easier to keep the driver separated from
- *	the i810 driver.
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	This program is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *	GNU General Public License for more details.
- *
- *	You should have received a copy of the GNU General Public License
- *	along with this program; if not, write to the Free Software
- *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
- *	ALi 5455 theory of operation
- *
- *	The chipset provides three DMA channels that talk to an AC97
- *	CODEC (AC97 is a digital/analog mixer standard). At its simplest
- *	you get 48Khz audio with basic volume and mixer controls. At the
- *	best you get rate adaption in the codec. We set the card up so
- *	that we never take completion interrupts but instead keep the card
- *	chasing its tail around a ring buffer. This is needed for mmap
- *	mode audio and happens to work rather well for non-mmap modes too.
- *
- *	The board has one output channel for PCM audio (supported) and
- *	a stereo line in and mono microphone input. Again these are normally
- *	locked to 48Khz only. Right now recording is not finished.
- *
- *	There is no midi support, no synth support. Use timidity. To get
- *	esd working you need to use esd -r 48000 as it won't probe 48KHz
- *	by default. mpg123 can't handle 48Khz only audio so use xmms.
- *
- *	If you need to force a specific rate set the clocking= option
- *
- */
-
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/spinlock.h>
-#include <linux/smp_lock.h>
-#include <linux/ac97_codec.h>
-#include <linux/interrupt.h>
-#include <linux/mutex.h>
-
-#include <asm/uaccess.h>
-
-#ifndef PCI_DEVICE_ID_ALI_5455
-#define PCI_DEVICE_ID_ALI_5455	0x5455
-#endif
-
-#ifndef PCI_VENDOR_ID_ALI
-#define PCI_VENDOR_ID_ALI	0x10b9
-#endif
-
-static int strict_clocking = 0;
-static unsigned int clocking = 0;
-static unsigned int codec_pcmout_share_spdif_locked = 0;
-static unsigned int codec_independent_spdif_locked = 0;
-static unsigned int controller_pcmout_share_spdif_locked = 0;
-static unsigned int controller_independent_spdif_locked = 0;
-static unsigned int globel = 0;
-
-#define ADC_RUNNING	1
-#define DAC_RUNNING	2
-#define CODEC_SPDIFOUT_RUNNING 8
-#define CONTROLLER_SPDIFOUT_RUNNING 4
-
-#define SPDIF_ENABLE_OUTPUT	4	/* bits 0,1 are PCM */
-
-#define ALI5455_FMT_16BIT	1
-#define ALI5455_FMT_STEREO	2
-#define ALI5455_FMT_MASK	3
-
-#define SPDIF_ON	0x0004
-#define SURR_ON		0x0010
-#define CENTER_LFE_ON	0x0020
-#define VOL_MUTED	0x8000
-
-
-#define ALI_SPDIF_OUT_CH_STATUS 0xbf
-/* the 810's array of pointers to data buffers */
-
-struct sg_item {
-#define BUSADDR_MASK	0xFFFFFFFE
-	u32 busaddr;
-#define CON_IOC 	0x80000000	/* interrupt on completion */
-#define CON_BUFPAD	0x40000000	/* pad underrun with last sample, else 0 */
-#define CON_BUFLEN_MASK	0x0000ffff	/* buffer length in samples */
-	u32 control;
-};
-
-/* an instance of the ali channel */
-#define SG_LEN 32
-struct ali_channel {
-	/* these sg guys should probably be allocated
-	   separately as nocache. Must be 8 byte aligned */
-	struct sg_item sg[SG_LEN];	/* 32*8 */
-	u32 offset;		/* 4 */
-	u32 port;		/* 4 */
-	u32 used;
-	u32 num;
-};
-
-/*
- * we have 3 separate dma engines.  pcm in, pcm out, and mic.
- * each dma engine has controlling registers.  These goofy
- * names are from the datasheet, but make it easy to write
- * code while leafing through it.
- */
-
-#define ENUM_ENGINE(PRE,DIG) 									\
-enum {												\
-	PRE##_BDBAR =	0x##DIG##0,		/* Buffer Descriptor list Base Address */	\
-	PRE##_CIV =	0x##DIG##4,		/* Current Index Value */			\
-	PRE##_LVI =	0x##DIG##5,		/* Last Valid Index */				\
-	PRE##_SR =	0x##DIG##6,		/* Status Register */				\
-	PRE##_PICB =	0x##DIG##8,		/* Position In Current Buffer */		\
-	PRE##_CR =	0x##DIG##b		/* Control Register */				\
-}
-
-ENUM_ENGINE(OFF, 0);		/* Offsets */
-ENUM_ENGINE(PI, 4);		/* PCM In */
-ENUM_ENGINE(PO, 5);		/* PCM Out */
-ENUM_ENGINE(MC, 6);		/* Mic In */
-ENUM_ENGINE(CODECSPDIFOUT, 7);	/* CODEC SPDIF OUT  */
-ENUM_ENGINE(CONTROLLERSPDIFIN, A);	/* CONTROLLER SPDIF In */
-ENUM_ENGINE(CONTROLLERSPDIFOUT, B);	/* CONTROLLER SPDIF OUT */
-
-
-enum {
-	ALI_SCR = 0x00,		/* System Control Register */
-	ALI_SSR = 0x04,		/* System Status Register  */
-	ALI_DMACR = 0x08,	/* DMA Control Register    */
-	ALI_FIFOCR1 = 0x0c,	/* FIFO Control Register 1  */
-	ALI_INTERFACECR = 0x10,	/* Interface Control Register */
-	ALI_INTERRUPTCR = 0x14,	/* Interrupt control Register */
-	ALI_INTERRUPTSR = 0x18,	/* Interrupt  Status Register */
-	ALI_FIFOCR2 = 0x1c,	/* FIFO Control Register 2   */
-	ALI_CPR = 0x20,		/* Command Port Register     */
-	ALI_SPR = 0x24,		/* Status Port Register      */
-	ALI_FIFOCR3 = 0x2c,	/* FIFO Control Register 3  */
-	ALI_TTSR = 0x30,	/* Transmit Tag Slot Register */
-	ALI_RTSR = 0x34,	/* Receive Tag Slot  Register */
-	ALI_CSPSR = 0x38,	/* Command/Status Port Status Register */
-	ALI_CAS = 0x3c,		/* Codec Write Semaphore Register */
-	ALI_SPDIFCSR = 0xf8,	/* spdif channel status register  */
-	ALI_SPDIFICS = 0xfc	/* spdif interface control/status  */
-};
-
-// x-status register(x:pcm in ,pcm out, mic in,)
-/* interrupts for a dma engine */
-#define DMA_INT_FIFO		(1<<4)	/* fifo under/over flow */
-#define DMA_INT_COMPLETE	(1<<3)	/* buffer read/write complete and ioc set */
-#define DMA_INT_LVI		(1<<2)	/* last valid done */
-#define DMA_INT_CELV		(1<<1)	/* last valid is current */
-#define DMA_INT_DCH		(1)	/* DMA Controller Halted (happens on LVI interrupts) */	//not eqult intel
-#define DMA_INT_MASK (DMA_INT_FIFO|DMA_INT_COMPLETE|DMA_INT_LVI)
-
-/* interrupts for the whole chip */// by interrupt status register finish
-
-#define INT_SPDIFOUT   (1<<23)	/* controller spdif out INTERRUPT */
-#define INT_SPDIFIN   (1<<22)
-#define INT_CODECSPDIFOUT   (1<<19)
-#define INT_MICIN   (1<<18)
-#define INT_PCMOUT   (1<<17)
-#define INT_PCMIN   (1<<16)
-#define INT_CPRAIS   (1<<7)
-#define INT_SPRAIS   (1<<5)
-#define INT_GPIO    (1<<1)
-#define INT_MASK   (INT_SPDIFOUT|INT_CODECSPDIFOUT|INT_MICIN|INT_PCMOUT|INT_PCMIN)
-
-#define DRIVER_VERSION "0.02ac"
-
-/* magic numbers to protect our data structures */
-#define ALI5455_CARD_MAGIC		0x5072696E	/* "Prin" */
-#define ALI5455_STATE_MAGIC		0x63657373	/* "cess" */
-#define ALI5455_DMA_MASK		0xffffffff	/* DMA buffer mask for pci_alloc_consist */
-#define NR_HW_CH			5	//I think 5 channel
-
-/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
-#define NR_AC97		2
-
-/* Please note that an 8bit mono stream is not valid on this card, you must have a 16bit */
-/* stream at a minimum for this card to be happy */
-static const unsigned sample_size[] = { 1, 2, 2, 4 };
-/* Samples are 16bit values, so we are shifting to a word, not to a byte, hence shift */
-/* values are one less than might be expected */
-static const unsigned sample_shift[] = { -1, 0, 0, 1 };
-
-#define ALI5455
-static char *card_names[] = {
-	"ALI 5455"
-};
-
-static struct pci_device_id ali_pci_tbl[] = {
-	{PCI_VENDOR_ID_ALI, PCI_DEVICE_ID_ALI_5455,
-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, ALI5455},
-	{0,}
-};
-
-MODULE_DEVICE_TABLE(pci, ali_pci_tbl);
-
-#ifdef CONFIG_PM
-#define PM_SUSPENDED(card) (card->pm_suspended)
-#else
-#define PM_SUSPENDED(card) (0)
-#endif
-
-/* "software" or virtual channel, an instance of opened /dev/dsp */
-struct ali_state {
-	unsigned int magic;
-	struct ali_card *card;	/* Card info */
-
-	/* single open lock mechanism, only used for recording */
-	struct mutex open_mutex;
-	wait_queue_head_t open_wait;
-
-	/* file mode */
-	mode_t open_mode;
-
-	/* virtual channel number */
-	int virt;
-
-#ifdef CONFIG_PM
-	unsigned int pm_saved_dac_rate, pm_saved_adc_rate;
-#endif
-	struct dmabuf {
-		/* wave sample stuff */
-		unsigned int rate;
-		unsigned char fmt, enable, trigger;
-
-		/* hardware channel */
-		struct ali_channel *read_channel;
-		struct ali_channel *write_channel;
-		struct ali_channel *codec_spdifout_channel;
-		struct ali_channel *controller_spdifout_channel;
-
-		/* OSS buffer management stuff */
-		void *rawbuf;
-		dma_addr_t dma_handle;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-
-		/* our buffer acts like a circular ring */
-		unsigned hwptr;	/* where dma last started, updated by update_ptr */
-		unsigned swptr;	/* where driver last clear/filled, updated by read/write */
-		int count;	/* bytes to be consumed or been generated by dma machine */
-		unsigned total_bytes;	/* total bytes dmaed by hardware */
-
-		unsigned error;	/* number of over/underruns */
-		wait_queue_head_t wait;	/* put process on wait queue when no more space in buffer */
-
-		/* redundant, but makes calculations easier */
-		/* what the hardware uses */
-		unsigned dmasize;
-		unsigned fragsize;
-		unsigned fragsamples;
-
-		/* what we tell the user to expect */
-		unsigned userfrags;
-		unsigned userfragsize;
-
-		/* OSS stuff */
-		unsigned mapped:1;
-		unsigned ready:1;
-		unsigned update_flag;
-		unsigned ossfragsize;
-		unsigned ossmaxfrags;
-		unsigned subdivision;
-	} dmabuf;
-};
-
-
-struct ali_card {
-	struct ali_channel channel[5];
-	unsigned int magic;
-
-	/* We keep ali5455 cards in a linked list */
-	struct ali_card *next;
-
-	/* The ali has a certain amount of cross channel interaction
-	   so we use a single per card lock */
-	spinlock_t lock;
-	spinlock_t ac97_lock;
-
-	/* PCI device stuff */
-	struct pci_dev *pci_dev;
-	u16 pci_id;
-#ifdef CONFIG_PM
-	u16 pm_suspended;
-	int pm_saved_mixer_settings[SOUND_MIXER_NRDEVICES][NR_AC97];
-#endif
-	/* soundcore stuff */
-	int dev_audio;
-
-	/* structures for abstraction of hardware facilities, codecs, banks and channels */
-	struct ac97_codec *ac97_codec[NR_AC97];
-	struct ali_state *states[NR_HW_CH];
-
-	u16 ac97_features;
-	u16 ac97_status;
-	u16 channels;
-
-	/* hardware resources */
-	unsigned long iobase;
-
-	u32 irq;
-
-	/* Function support */
-	struct ali_channel *(*alloc_pcm_channel) (struct ali_card *);
-	struct ali_channel *(*alloc_rec_pcm_channel) (struct ali_card *);
-	struct ali_channel *(*alloc_rec_mic_channel) (struct ali_card *);
-	struct ali_channel *(*alloc_codec_spdifout_channel) (struct ali_card *);
-	struct ali_channel *(*alloc_controller_spdifout_channel) (struct  ali_card *);
-	void (*free_pcm_channel) (struct ali_card *, int chan);
-
-	/* We have a *very* long init time possibly, so use this to block */
-	/* attempts to open our devices before we are ready (stops oops'es) */
-	int initializing;
-};
-
-
-static struct ali_card *devs = NULL;
-
-static int ali_open_mixdev(struct inode *inode, struct file *file);
-static int ali_ioctl_mixdev(struct inode *inode, struct file *file,
-			    unsigned int cmd, unsigned long arg);
-static u16 ali_ac97_get(struct ac97_codec *dev, u8 reg);
-static void ali_ac97_set(struct ac97_codec *dev, u8 reg, u16 data);
-
-static struct ali_channel *ali_alloc_pcm_channel(struct ali_card *card)
-{
-	if (card->channel[1].used == 1)
-		return NULL;
-	card->channel[1].used = 1;
-	return &card->channel[1];
-}
-
-static struct ali_channel *ali_alloc_rec_pcm_channel(struct ali_card *card)
-{
-	if (card->channel[0].used == 1)
-		return NULL;
-	card->channel[0].used = 1;
-	return &card->channel[0];
-}
-
-static struct ali_channel *ali_alloc_rec_mic_channel(struct ali_card *card)
-{
-	if (card->channel[2].used == 1)
-		return NULL;
-	card->channel[2].used = 1;
-	return &card->channel[2];
-}
-
-static struct ali_channel *ali_alloc_codec_spdifout_channel(struct ali_card *card)
-{
-	if (card->channel[3].used == 1)
-		return NULL;
-	card->channel[3].used = 1;
-	return &card->channel[3];
-}
-
-static struct ali_channel *ali_alloc_controller_spdifout_channel(struct ali_card *card)
-{
-	if (card->channel[4].used == 1)
-		return NULL;
-	card->channel[4].used = 1;
-	return &card->channel[4];
-}
-static void ali_free_pcm_channel(struct ali_card *card, int channel)
-{
-	card->channel[channel].used = 0;
-}
-
-
-//add support  codec spdif out 
-static int ali_valid_spdif_rate(struct ac97_codec *codec, int rate)
-{
-	unsigned long id = 0L;
-
-	id = (ali_ac97_get(codec, AC97_VENDOR_ID1) << 16);
-	id |= ali_ac97_get(codec, AC97_VENDOR_ID2) & 0xffff;
-	switch (id) {
-	case 0x41445361:	/* AD1886 */
-		if (rate == 48000) {
-			return 1;
-		}
-		break;
-	case 0x414c4720:	/* ALC650 */
-		if (rate == 48000) {
-			return 1;
-		}
-		break;
-	default:		/* all other codecs, until we know otherwiae */
-		if (rate == 48000 || rate == 44100 || rate == 32000) {
-			return 1;
-		}
-		break;
-	}
-	return (0);
-}
-
-/* ali_set_spdif_output
- * 
- *  Configure the S/PDIF output transmitter. When we turn on
- *  S/PDIF, we turn off the analog output. This may not be
- *  the right thing to do.
- *
- *  Assumptions:
- *     The DSP sample rate must already be set to a supported
- *     S/PDIF rate (32kHz, 44.1kHz, or 48kHz) or we abort.
- */
-static void ali_set_spdif_output(struct ali_state *state, int slots,
-				 int rate)
-{
-	int vol;
-	int aud_reg;
-	struct ac97_codec *codec = state->card->ac97_codec[0];
-
-	if (!(state->card->ac97_features & 4)) {
-		state->card->ac97_status &= ~SPDIF_ON;
-	} else {
-		if (slots == -1) {	/* Turn off S/PDIF */
-			aud_reg = ali_ac97_get(codec, AC97_EXTENDED_STATUS);
-			ali_ac97_set(codec, AC97_EXTENDED_STATUS, (aud_reg & ~AC97_EA_SPDIF));
-
-			/* If the volume wasn't muted before we turned on S/PDIF, unmute it */
-			if (!(state->card->ac97_status & VOL_MUTED)) {
-				aud_reg = ali_ac97_get(codec, AC97_MASTER_VOL_STEREO);
-				ali_ac97_set(codec, AC97_MASTER_VOL_STEREO,
-					     (aud_reg & ~VOL_MUTED));
-			}
-			state->card->ac97_status &= ~(VOL_MUTED | SPDIF_ON);
-			return;
-		}
-
-		vol = ali_ac97_get(codec, AC97_MASTER_VOL_STEREO);
-		state->card->ac97_status = vol & VOL_MUTED;
-
-		/* Set S/PDIF transmitter sample rate */
-		aud_reg = ali_ac97_get(codec, AC97_SPDIF_CONTROL);
-		switch (rate) {
-		case 32000:
-			aud_reg = (aud_reg & AC97_SC_SPSR_MASK) | AC97_SC_SPSR_32K;
-			break;
-		case 44100:
-			aud_reg = (aud_reg & AC97_SC_SPSR_MASK) | AC97_SC_SPSR_44K;
-			break;
-		case 48000:
-			aud_reg = (aud_reg & AC97_SC_SPSR_MASK) | AC97_SC_SPSR_48K;
-			break;
-		default:
-			/* turn off S/PDIF */
-			aud_reg = ali_ac97_get(codec, AC97_EXTENDED_STATUS);
-			ali_ac97_set(codec, AC97_EXTENDED_STATUS, (aud_reg & ~AC97_EA_SPDIF));
-			state->card->ac97_status &= ~SPDIF_ON;
-			return;
-		}
-
-		ali_ac97_set(codec, AC97_SPDIF_CONTROL, aud_reg);
-
-		aud_reg = ali_ac97_get(codec, AC97_EXTENDED_STATUS);
-		aud_reg = (aud_reg & AC97_EA_SLOT_MASK) | slots | AC97_EA_SPDIF;
-		ali_ac97_set(codec, AC97_EXTENDED_STATUS, aud_reg);
-
-		aud_reg = ali_ac97_get(codec, AC97_POWER_CONTROL);
-		aud_reg |= 0x0002;
-		ali_ac97_set(codec, AC97_POWER_CONTROL, aud_reg);
-		udelay(1);
-
-		state->card->ac97_status |= SPDIF_ON;
-
-		/* Check to make sure the configuration is valid */
-		aud_reg = ali_ac97_get(codec, AC97_EXTENDED_STATUS);
-		if (!(aud_reg & 0x0400)) {
-			/* turn off S/PDIF */
-			ali_ac97_set(codec, AC97_EXTENDED_STATUS, (aud_reg & ~AC97_EA_SPDIF));
-			state->card->ac97_status &= ~SPDIF_ON;
-			return;
-		}
-		if (codec_independent_spdif_locked > 0) {
-			aud_reg = ali_ac97_get(codec, 0x6a);
-			ali_ac97_set(codec, 0x6a, (aud_reg & 0xefff));
-		}
-		/* Mute the analog output */
-		/* Should this only mute the PCM volume??? */
-	}
-}
-
-/* ali_set_dac_channels
- *
- *  Configure the codec's multi-channel DACs
- *
- *  The logic is backwards. Setting the bit to 1 turns off the DAC. 
- *
- *  What about the ICH? We currently configure it using the
- *  SNDCTL_DSP_CHANNELS ioctl.  If we're turnning on the DAC, 
- *  does that imply that we want the ICH set to support
- *  these channels?
- *  
- *  TODO:
- *    vailidate that the codec really supports these DACs
- *    before turning them on. 
- */
-static void ali_set_dac_channels(struct ali_state *state, int channel)
-{
-	int aud_reg;
-	struct ac97_codec *codec = state->card->ac97_codec[0];
-
-	aud_reg = ali_ac97_get(codec, AC97_EXTENDED_STATUS);
-	aud_reg |= AC97_EA_PRI | AC97_EA_PRJ | AC97_EA_PRK;
-	state->card->ac97_status &= ~(SURR_ON | CENTER_LFE_ON);
-
-	switch (channel) {
-	case 2:		/* always enabled */
-		break;
-	case 4:
-		aud_reg &= ~AC97_EA_PRJ;
-		state->card->ac97_status |= SURR_ON;
-		break;
-	case 6:
-		aud_reg &= ~(AC97_EA_PRJ | AC97_EA_PRI | AC97_EA_PRK);
-		state->card->ac97_status |= SURR_ON | CENTER_LFE_ON;
-		break;
-	default:
-		break;
-	}
-	ali_ac97_set(codec, AC97_EXTENDED_STATUS, aud_reg);
-
-}
-
-/* set playback sample rate */
-static unsigned int ali_set_dac_rate(struct ali_state *state,
-				     unsigned int rate)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	u32 new_rate;
-	struct ac97_codec *codec = state->card->ac97_codec[0];
-
-	if (!(state->card->ac97_features & 0x0001)) {
-		dmabuf->rate = clocking;
-		return clocking;
-	}
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 8000)
-		rate = 8000;
-	dmabuf->rate = rate;
-
-	/*
-	 *      Adjust for misclocked crap
-	 */
-
-	rate = (rate * clocking) / 48000;
-
-	if (strict_clocking && rate < 8000) {
-		rate = 8000;
-		dmabuf->rate = (rate * 48000) / clocking;
-	}
-
-	new_rate = ac97_set_dac_rate(codec, rate);
-	if (new_rate != rate) {
-		dmabuf->rate = (new_rate * 48000) / clocking;
-	}
-	rate = new_rate;
-	return dmabuf->rate;
-}
-
-/* set recording sample rate */
-static unsigned int ali_set_adc_rate(struct ali_state *state,
-				     unsigned int rate)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	u32 new_rate;
-	struct ac97_codec *codec = state->card->ac97_codec[0];
-
-	if (!(state->card->ac97_features & 0x0001)) {
-		dmabuf->rate = clocking;
-		return clocking;
-	}
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 8000)
-		rate = 8000;
-	dmabuf->rate = rate;
-
-	/*
-	 *      Adjust for misclocked crap
-	 */
-
-	rate = (rate * clocking) / 48000;
-	if (strict_clocking && rate < 8000) {
-		rate = 8000;
-		dmabuf->rate = (rate * 48000) / clocking;
-	}
-
-	new_rate = ac97_set_adc_rate(codec, rate);
-
-	if (new_rate != rate) {
-		dmabuf->rate = (new_rate * 48000) / clocking;
-		rate = new_rate;
-	}
-	return dmabuf->rate;
-}
-
-/* set codec independent spdifout sample rate */
-static unsigned int ali_set_codecspdifout_rate(struct ali_state *state,
-					       unsigned int rate)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-
-	if (!(state->card->ac97_features & 0x0001)) {
-		dmabuf->rate = clocking;
-		return clocking;
-	}
-
-	if (rate > 48000)
-		rate = 48000;
-	if (rate < 8000)
-		rate = 8000;
-	dmabuf->rate = rate;
-
-	return dmabuf->rate;
-}
-
-/* set  controller independent spdif out function sample rate */
-static void ali_set_spdifout_rate(struct ali_state *state,
-				  unsigned int rate)
-{
-	unsigned char ch_st_sel;
-	unsigned short status_rate;
-
-	switch (rate) {
-	case 44100:
-		status_rate = 0;
-		break;
-	case 32000:
-		status_rate = 0x300;
-		break;
-	case 48000:
-	default:
-		status_rate = 0x200;
-		break;
-	}
-
-	ch_st_sel = inb(state->card->iobase + ALI_SPDIFICS) & ALI_SPDIF_OUT_CH_STATUS;	//select spdif_out
-
-	ch_st_sel |= 0x80;	//select right
-	outb(ch_st_sel, (state->card->iobase + ALI_SPDIFICS));
-	outb(status_rate | 0x20, (state->card->iobase + ALI_SPDIFCSR + 2));
-
-	ch_st_sel &= (~0x80);	//select left
-	outb(ch_st_sel, (state->card->iobase + ALI_SPDIFICS));
-	outw(status_rate | 0x10, (state->card->iobase + ALI_SPDIFCSR + 2));
-}
-
-/* get current playback/recording dma buffer pointer (byte offset from LBA),
-   called with spinlock held! */
-
-static inline unsigned ali_get_dma_addr(struct ali_state *state, int rec)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned int civ, offset, port, port_picb;
-	unsigned int data;
-
-	if (!dmabuf->enable)
-		return 0;
-
-	if (rec == 1)
-		port = state->card->iobase + dmabuf->read_channel->port;
-	else if (rec == 2)
-		port = state->card->iobase + dmabuf->codec_spdifout_channel->port;
-	else if (rec == 3)
-		port = state->card->iobase + dmabuf->controller_spdifout_channel->port;
-	else
-		port = state->card->iobase + dmabuf->write_channel->port;
-
-	port_picb = port + OFF_PICB;
-
-	do {
-		civ = inb(port + OFF_CIV) & 31;
-		offset = inw(port_picb);
-		/* Must have a delay here! */
-		if (offset == 0)
-			udelay(1);
-
-		/* Reread both registers and make sure that that total
-		 * offset from the first reading to the second is 0.
-		 * There is an issue with SiS hardware where it will count
-		 * picb down to 0, then update civ to the next value,
-		 * then set the new picb to fragsize bytes.  We can catch
-		 * it between the civ update and the picb update, making
-		 * it look as though we are 1 fragsize ahead of where we
-		 * are.  The next to we get the address though, it will
-		 * be back in thdelay is more than long enough
-		 * that we won't have to worry about the chip still being
-		 * out of sync with reality ;-)
-		 */
-	} while (civ != (inb(port + OFF_CIV) & 31) || offset != inw(port_picb));
-
-	data = ((civ + 1) * dmabuf->fragsize - (2 * offset)) % dmabuf->dmasize;
-	if (inw(port_picb) == 0)
-		data -= 2048;
-
-	return data;
-}
-
-/* Stop recording (lock held) */
-static inline void __stop_adc(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	struct ali_card *card = state->card;
-
-	dmabuf->enable &= ~ADC_RUNNING;
-
-	outl((1 << 18) | (1 << 16), card->iobase + ALI_DMACR);
-	udelay(1);
-
-	outb(0, card->iobase + PI_CR);
-	while (inb(card->iobase + PI_CR) != 0);
-
-	// now clear any latent interrupt bits (like the halt bit)
-	outb(inb(card->iobase + PI_SR) | 0x001e, card->iobase + PI_SR);
-	outl(inl(card->iobase + ALI_INTERRUPTSR) & INT_PCMIN, card->iobase + ALI_INTERRUPTSR);
-}
-
-static void stop_adc(struct ali_state *state)
-{
-	struct ali_card *card = state->card;
-	unsigned long flags;
-	spin_lock_irqsave(&card->lock, flags);
-	__stop_adc(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-}
-
-static inline void __start_adc(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-
-	if (dmabuf->count < dmabuf->dmasize && dmabuf->ready
-	    && !dmabuf->enable && (dmabuf->trigger & PCM_ENABLE_INPUT)) {
-		dmabuf->enable |= ADC_RUNNING;
-		outb((1 << 4) | (1 << 2), state->card->iobase + PI_CR);
-		if (state->card->channel[0].used == 1)
-			outl(1, state->card->iobase + ALI_DMACR);	// DMA CONTROL REGISTRER
-		udelay(100);
-		if (state->card->channel[2].used == 1)
-			outl((1 << 2), state->card->iobase + ALI_DMACR);	//DMA CONTROL REGISTER
-		udelay(100);
-	}
-}
-
-static void start_adc(struct ali_state *state)
-{
-	struct ali_card *card = state->card;
-	unsigned long flags;
-
-	spin_lock_irqsave(&card->lock, flags);
-	__start_adc(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-}
-
-/* stop playback (lock held) */
-static inline void __stop_dac(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	struct ali_card *card = state->card;
-
-	dmabuf->enable &= ~DAC_RUNNING;
-	outl(0x00020000, card->iobase + 0x08);
-	outb(0, card->iobase + PO_CR);
-	while (inb(card->iobase + PO_CR) != 0)
-		cpu_relax();
-
-	outb(inb(card->iobase + PO_SR) | 0x001e, card->iobase + PO_SR);
-
-	outl(inl(card->iobase + ALI_INTERRUPTSR) & INT_PCMOUT, card->iobase + ALI_INTERRUPTSR);
-}
-
-static void stop_dac(struct ali_state *state)
-{
-	struct ali_card *card = state->card;
-	unsigned long flags;
-	spin_lock_irqsave(&card->lock, flags);
-	__stop_dac(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-}
-
-static inline void __start_dac(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	if (dmabuf->count > 0 && dmabuf->ready && !dmabuf->enable &&
-	    (dmabuf->trigger & PCM_ENABLE_OUTPUT)) {
-		dmabuf->enable |= DAC_RUNNING;
-		outb((1 << 4) | (1 << 2), state->card->iobase + PO_CR);
-		outl((1 << 1), state->card->iobase + 0x08);	//dma control register
-	}
-}
-
-static void start_dac(struct ali_state *state)
-{
-	struct ali_card *card = state->card;
-	unsigned long flags;
-	spin_lock_irqsave(&card->lock, flags);
-	__start_dac(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-}
-
-/* stop codec and controller spdif out  (lock held) */
-static inline void __stop_spdifout(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	struct ali_card *card = state->card;
-
-	if (codec_independent_spdif_locked > 0) {
-		dmabuf->enable &= ~CODEC_SPDIFOUT_RUNNING;
-		outl((1 << 19), card->iobase + 0x08);
-		outb(0, card->iobase + CODECSPDIFOUT_CR);
-
-		while (inb(card->iobase + CODECSPDIFOUT_CR) != 0)
-			cpu_relax();
-
-		outb(inb(card->iobase + CODECSPDIFOUT_SR) | 0x001e, card->iobase + CODECSPDIFOUT_SR);
-		outl(inl(card->iobase + ALI_INTERRUPTSR) & INT_CODECSPDIFOUT, card->iobase + ALI_INTERRUPTSR);
-	} else {
-		if (controller_independent_spdif_locked > 0) {
-			dmabuf->enable &= ~CONTROLLER_SPDIFOUT_RUNNING;
-			outl((1 << 23), card->iobase + 0x08);
-			outb(0, card->iobase + CONTROLLERSPDIFOUT_CR);
-			while (inb(card->iobase + CONTROLLERSPDIFOUT_CR) != 0)
-				cpu_relax();
-			outb(inb(card->iobase + CONTROLLERSPDIFOUT_SR) | 0x001e, card->iobase + CONTROLLERSPDIFOUT_SR);
-			outl(inl(card->iobase + ALI_INTERRUPTSR) & INT_SPDIFOUT, card->iobase + ALI_INTERRUPTSR);
-		}
-	}
-}
-
-static void stop_spdifout(struct ali_state *state)
-{
-	struct ali_card *card = state->card;
-	unsigned long flags;
-	spin_lock_irqsave(&card->lock, flags);
-	__stop_spdifout(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-}
-
-static inline void __start_spdifout(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	if (dmabuf->count > 0 && dmabuf->ready && !dmabuf->enable &&
-	    (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)) {
-		if (codec_independent_spdif_locked > 0) {
-			dmabuf->enable |= CODEC_SPDIFOUT_RUNNING;
-			outb((1 << 4) | (1 << 2), state->card->iobase + CODECSPDIFOUT_CR);
-			outl((1 << 3), state->card->iobase + 0x08);	//dma control register
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				dmabuf->enable |= CONTROLLER_SPDIFOUT_RUNNING;
-				outb((1 << 4) | (1 << 2), state->card->iobase + CONTROLLERSPDIFOUT_CR);
-				outl((1 << 7), state->card->iobase + 0x08);	//dma control register
-			}
-		}
-	}
-}
-
-static void start_spdifout(struct ali_state *state)
-{
-	struct ali_card *card = state->card;
-	unsigned long flags;
-	spin_lock_irqsave(&card->lock, flags);
-	__start_spdifout(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-}
-
-#define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-/* allocate DMA buffer, playback , recording,spdif out  buffer should be allocated separately */
-static int alloc_dmabuf(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	void *rawbuf = NULL;
-	int order, size;
-	struct page *page, *pend;
-
-	/* If we don't have any oss frag params, then use our default ones */
-	if (dmabuf->ossmaxfrags == 0)
-		dmabuf->ossmaxfrags = 4;
-	if (dmabuf->ossfragsize == 0)
-		dmabuf->ossfragsize = (PAGE_SIZE << DMABUF_DEFAULTORDER) / dmabuf->ossmaxfrags;
-	size = dmabuf->ossfragsize * dmabuf->ossmaxfrags;
-
-	if (dmabuf->rawbuf && (PAGE_SIZE << dmabuf->buforder) == size)
-		return 0;
-	/* alloc enough to satisfy the oss params */
-	for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--) {
-		if ((PAGE_SIZE << order) > size)
-			continue;
-		if ((rawbuf = pci_alloc_consistent(state->card->pci_dev,
-						   PAGE_SIZE << order,
-						   &dmabuf->dma_handle)))
-			break;
-	}
-	if (!rawbuf)
-		return -ENOMEM;
-
-	dmabuf->ready = dmabuf->mapped = 0;
-	dmabuf->rawbuf = rawbuf;
-	dmabuf->buforder = order;
-
-	/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-	pend = virt_to_page(rawbuf + (PAGE_SIZE << order) - 1);
-	for (page = virt_to_page(rawbuf); page <= pend; page++)
-		SetPageReserved(page);
-	return 0;
-}
-
-/* free DMA buffer */
-static void dealloc_dmabuf(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	struct page *page, *pend;
-
-	if (dmabuf->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(dmabuf->rawbuf + (PAGE_SIZE << dmabuf->buforder) - 1);
-		for (page = virt_to_page(dmabuf->rawbuf); page <= pend; page++)
-			ClearPageReserved(page);
-		pci_free_consistent(state->card->pci_dev,
-				    PAGE_SIZE << dmabuf->buforder,
-				    dmabuf->rawbuf, dmabuf->dma_handle);
-	}
-	dmabuf->rawbuf = NULL;
-	dmabuf->mapped = dmabuf->ready = 0;
-}
-
-static int prog_dmabuf(struct ali_state *state, unsigned rec)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	struct ali_channel *c = NULL;
-	struct sg_item *sg;
-	unsigned long flags;
-	int ret;
-	unsigned fragint;
-	int i;
-
-	spin_lock_irqsave(&state->card->lock, flags);
-	if (dmabuf->enable & DAC_RUNNING)
-		__stop_dac(state);
-	if (dmabuf->enable & ADC_RUNNING)
-		__stop_adc(state);
-	if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-		__stop_spdifout(state);
-	if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-		__stop_spdifout(state);
-
-	dmabuf->total_bytes = 0;
-	dmabuf->count = dmabuf->error = 0;
-	dmabuf->swptr = dmabuf->hwptr = 0;
-	spin_unlock_irqrestore(&state->card->lock, flags);
-
-	/* allocate DMA buffer, let alloc_dmabuf determine if we are already
-	 * allocated well enough or if we should replace the current buffer
-	 * (assuming one is already allocated, if it isn't, then allocate it).
-	 */
-	if ((ret = alloc_dmabuf(state)))
-		return ret;
-
-	/* FIXME: figure out all this OSS fragment stuff */
-	/* I did, it now does what it should according to the OSS API.  DL */
-	/* We may not have realloced our dmabuf, but the fragment size to
-	 * fragment number ratio may have changed, so go ahead and reprogram
-	 * things
-	 */
-
-	dmabuf->dmasize = PAGE_SIZE << dmabuf->buforder;
-	dmabuf->numfrag = SG_LEN;
-	dmabuf->fragsize = dmabuf->dmasize / dmabuf->numfrag;
-	dmabuf->fragsamples = dmabuf->fragsize >> 1;
-	dmabuf->userfragsize = dmabuf->ossfragsize;
-	dmabuf->userfrags = dmabuf->dmasize / dmabuf->ossfragsize;
-
-	memset(dmabuf->rawbuf, 0, dmabuf->dmasize);
-
-	if (dmabuf->ossmaxfrags == 4) {
-		fragint = 8;
-		dmabuf->fragshift = 2;
-	} else if (dmabuf->ossmaxfrags == 8) {
-		fragint = 4;
-		dmabuf->fragshift = 3;
-	} else if (dmabuf->ossmaxfrags == 16) {
-		fragint = 2;
-		dmabuf->fragshift = 4;
-	} else {
-		fragint = 1;
-		dmabuf->fragshift = 5;
-	}
-	/*
-	 *      Now set up the ring 
-	 */
-
-	if (rec == 1)
-		c = dmabuf->read_channel;
-	else if (rec == 2)
-		c = dmabuf->codec_spdifout_channel;
-	else if (rec == 3)
-		c = dmabuf->controller_spdifout_channel;
-	else if (rec == 0)
-		c = dmabuf->write_channel;
-	if (c != NULL) {
-		sg = &c->sg[0];
-		/*
-		 *      Load up 32 sg entries and take an interrupt at half
-		 *      way (we might want more interrupts later..) 
-		 */
-		for (i = 0; i < dmabuf->numfrag; i++) {
-			sg->busaddr =
-			    virt_to_bus(dmabuf->rawbuf +
-					dmabuf->fragsize * i);
-			// the card will always be doing 16bit stereo
-			sg->control = dmabuf->fragsamples;
-			sg->control |= CON_BUFPAD;	//I modify
-			// set us up to get IOC interrupts as often as needed to
-			// satisfy numfrag requirements, no more
-			if (((i + 1) % fragint) == 0) {
-				sg->control |= CON_IOC;
-			}
-			sg++;
-		}
-		spin_lock_irqsave(&state->card->lock, flags);
-		outb(2, state->card->iobase + c->port + OFF_CR);	/* reset DMA machine */
-		outl(virt_to_bus(&c->sg[0]), state->card->iobase + c->port + OFF_BDBAR);
-		outb(0, state->card->iobase + c->port + OFF_CIV);
-		outb(0, state->card->iobase + c->port + OFF_LVI);
-		spin_unlock_irqrestore(&state->card->lock, flags);
-	}
-	/* set the ready flag for the dma buffer */
-	dmabuf->ready = 1;
-	return 0;
-}
-
-static void __ali_update_lvi(struct ali_state *state, int rec)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	int x, port;
-	port = state->card->iobase;
-	if (rec == 1)
-		port += dmabuf->read_channel->port;
-	else if (rec == 2)
-		port += dmabuf->codec_spdifout_channel->port;
-	else if (rec == 3)
-		port += dmabuf->controller_spdifout_channel->port;
-	else if (rec == 0)
-		port += dmabuf->write_channel->port;
-	/* if we are currently stopped, then our CIV is actually set to our
-	 * *last* sg segment and we are ready to wrap to the next.  However,
-	 * if we set our LVI to the last sg segment, then it won't wrap to
-	 * the next sg segment, it won't even get a start.  So, instead, when
-	 * we are stopped, we set both the LVI value and also we increment
-	 * the CIV value to the next sg segment to be played so that when
-	 * we call start_{dac,adc}, things will operate properly
-	 */
-	if (!dmabuf->enable && dmabuf->ready) {
-		if (rec && dmabuf->count < dmabuf->dmasize && (dmabuf->trigger & PCM_ENABLE_INPUT)) {
-			outb((inb(port + OFF_CIV) + 1) & 31, port + OFF_LVI);
-			__start_adc(state);
-			while (! (inb(port + OFF_CR) & ((1 << 4) | (1 << 2))))
-				cpu_relax();
-		} else if (!rec && dmabuf->count && (dmabuf->trigger & PCM_ENABLE_OUTPUT)) {
-			outb((inb(port + OFF_CIV) + 1) & 31, port + OFF_LVI);
-			__start_dac(state);
-			while (!(inb(port + OFF_CR) & ((1 << 4) | (1 << 2))))
-				cpu_relax();
-		} else if (rec && dmabuf->count && (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)) {
-			if (codec_independent_spdif_locked > 0) {
-				// outb((inb(port+OFF_CIV))&31, port+OFF_LVI);
-				outb((inb(port + OFF_CIV) + 1) & 31, port + OFF_LVI);
-				__start_spdifout(state);
-				while (!(inb(port + OFF_CR) & ((1 << 4) | (1 << 2))))
-					cpu_relax();
-			} else {
-				if (controller_independent_spdif_locked > 0) {
-					outb((inb(port + OFF_CIV) + 1) & 31, port + OFF_LVI);
-					__start_spdifout(state);
-					while (!(inb(port + OFF_CR) & ((1 << 4) | (1 << 2))))
-						cpu_relax();
-				}
-			}
-		}
-	}
-
-	/* swptr - 1 is the tail of our transfer */
-	x = (dmabuf->dmasize + dmabuf->swptr - 1) % dmabuf->dmasize;
-	x /= dmabuf->fragsize;
-	outb(x, port + OFF_LVI);
-}
-
-static void ali_update_lvi(struct ali_state *state, int rec)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned long flags;
-	if (!dmabuf->ready)
-		return;
-	spin_lock_irqsave(&state->card->lock, flags);
-	__ali_update_lvi(state, rec);
-	spin_unlock_irqrestore(&state->card->lock, flags);
-}
-
-/* update buffer manangement pointers, especially, dmabuf->count and dmabuf->hwptr */
-static void ali_update_ptr(struct ali_state *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned hwptr;
-	int diff;
-	
-	/* error handling and process wake up for DAC */
-	if (dmabuf->enable == ADC_RUNNING) {
-		/* update hardware pointer */
-		hwptr = ali_get_dma_addr(state, 1);
-		diff = (dmabuf->dmasize + hwptr - dmabuf->hwptr) % dmabuf->dmasize;
-		dmabuf->hwptr = hwptr;
-		dmabuf->total_bytes += diff;
-		dmabuf->count += diff;
-		if (dmabuf->count > dmabuf->dmasize) {
-			/* buffer underrun or buffer overrun */
-			/* this is normal for the end of a read */
-			/* only give an error if we went past the */
-			/* last valid sg entry */
-			if ((inb(state->card->iobase + PI_CIV) & 31) != (inb(state->card->iobase + PI_LVI) & 31)) {
-				printk(KERN_WARNING "ali_audio: DMA overrun on read\n");
-				dmabuf->error++;
-			}
-		}
-		if (dmabuf->count > dmabuf->userfragsize)
-			wake_up(&dmabuf->wait);
-	}
-	/* error handling and process wake up for DAC */
-	if (dmabuf->enable == DAC_RUNNING) {
-		/* update hardware pointer */
-		hwptr = ali_get_dma_addr(state, 0);
-		diff =
-		    (dmabuf->dmasize + hwptr -
-		     dmabuf->hwptr) % dmabuf->dmasize;
-#if defined(DEBUG_INTERRUPTS) || defined(DEBUG_MMAP)
-		printk("DAC HWP %d,%d,%d\n", hwptr, dmabuf->hwptr, diff);
-#endif
-		dmabuf->hwptr = hwptr;
-		dmabuf->total_bytes += diff;
-		dmabuf->count -= diff;
-		if (dmabuf->count < 0) {
-			/* buffer underrun or buffer overrun */
-			/* this is normal for the end of a write */
-			/* only give an error if we went past the */
-			/* last valid sg entry */
-			if ((inb(state->card->iobase + PO_CIV) & 31) != (inb(state->card->iobase + PO_LVI) & 31)) {
-				printk(KERN_WARNING "ali_audio: DMA overrun on write\n");
-				printk(KERN_DEBUG "ali_audio: CIV %d, LVI %d, hwptr %x, count %d\n",
-				     			inb(state->card->iobase + PO_CIV) & 31,
-				     			inb(state->card->iobase + PO_LVI) & 31, 
-							dmabuf->hwptr,
-							dmabuf->count);
-				dmabuf->error++;
-			}
-		}
-		if (dmabuf->count < (dmabuf->dmasize - dmabuf->userfragsize))
-		    	wake_up(&dmabuf->wait);
-	}
-
-	/* error handling and process wake up for CODEC SPDIF OUT */
-	if (dmabuf->enable == CODEC_SPDIFOUT_RUNNING) {
-		/* update hardware pointer */
-		hwptr = ali_get_dma_addr(state, 2);
-		diff = (dmabuf->dmasize + hwptr - dmabuf->hwptr) % dmabuf->dmasize;
-		dmabuf->hwptr = hwptr;
-		dmabuf->total_bytes += diff;
-		dmabuf->count -= diff;
-		if (dmabuf->count < 0) {
-			/* buffer underrun or buffer overrun */
-			/* this is normal for the end of a write */
-			/* only give an error if we went past the */
-			/* last valid sg entry */
-			if ((inb(state->card->iobase + CODECSPDIFOUT_CIV) & 31) != (inb(state->card->iobase + CODECSPDIFOUT_LVI) & 31)) {
-				printk(KERN_WARNING "ali_audio: DMA overrun on write\n");
-				printk(KERN_DEBUG "ali_audio: CIV %d, LVI %d, hwptr %x, count %d\n", 
-				        inb(state->card->iobase + CODECSPDIFOUT_CIV) & 31,
-					inb(state->card->iobase + CODECSPDIFOUT_LVI) & 31,
-					dmabuf->hwptr, dmabuf->count);
-				dmabuf->error++;
-			}
-		}
-		if (dmabuf->count < (dmabuf->dmasize - dmabuf->userfragsize))
-			wake_up(&dmabuf->wait);
-	}
-	/* error handling and process wake up for CONTROLLER SPDIF OUT */
-	if (dmabuf->enable == CONTROLLER_SPDIFOUT_RUNNING) {
-		/* update hardware pointer */
-		hwptr = ali_get_dma_addr(state, 3);
-		diff = (dmabuf->dmasize + hwptr - dmabuf->hwptr) % dmabuf->dmasize;
-		dmabuf->hwptr = hwptr;
-		dmabuf->total_bytes += diff;
-		dmabuf->count -= diff;
-		if (dmabuf->count < 0) {
-			/* buffer underrun or buffer overrun */
-			/* this is normal for the end of a write */
-			/* only give an error if we went past the */
-			/* last valid sg entry */
-			if ((inb(state->card->iobase + CONTROLLERSPDIFOUT_CIV) & 31) != (inb(state->card->iobase + CONTROLLERSPDIFOUT_LVI) & 31)) {
-				printk(KERN_WARNING
-				       "ali_audio: DMA overrun on write\n");
-				printk("ali_audio: CIV %d, LVI %d, hwptr %x, "
-					"count %d\n",
-				     		inb(state->card->iobase + CONTROLLERSPDIFOUT_CIV) & 31,
-				     		inb(state->card->iobase + CONTROLLERSPDIFOUT_LVI) & 31,
-				     		dmabuf->hwptr, dmabuf->count);
-				dmabuf->error++;
-			}
-		}
-		if (dmabuf->count < (dmabuf->dmasize - dmabuf->userfragsize))
-			wake_up(&dmabuf->wait);
-	}
-}
-
-static inline int ali_get_free_write_space(struct
-					   ali_state
-					   *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	int free;
-
-	if (dmabuf->count < 0) {
-		dmabuf->count = 0;
-		dmabuf->swptr = dmabuf->hwptr;
-	}
-	free = dmabuf->dmasize - dmabuf->swptr;
-	if ((dmabuf->count + free) > dmabuf->dmasize){
-		free = dmabuf->dmasize - dmabuf->count;
-	}
-	return free;
-}
-
-static inline int ali_get_available_read_data(struct
-					      ali_state
-					      *state)
-{
-	struct dmabuf *dmabuf = &state->dmabuf;
-	int avail;
-	ali_update_ptr(state);
-	// catch overruns during record
-	if (dmabuf->count > dmabuf->dmasize) {
-		dmabuf->count = dmabuf->dmasize;
-		dmabuf->swptr = dmabuf->hwptr;
-	}
-	avail = dmabuf->count;
-	avail -= (dmabuf->hwptr % dmabuf->fragsize);
-	if (avail < 0)
-		return (0);
-	return (avail);
-}
-
-static int drain_dac(struct ali_state *state, int signals_allowed)
-{
-
-	DECLARE_WAITQUEUE(wait, current);
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned long flags;
-	unsigned long tmo;
-	int count;
-	if (!dmabuf->ready)
-		return 0;
-	if (dmabuf->mapped) {
-		stop_dac(state);
-		return 0;
-	}
-	add_wait_queue(&dmabuf->wait, &wait);
-	for (;;) {
-
-		spin_lock_irqsave(&state->card->lock, flags);
-		ali_update_ptr(state);
-		count = dmabuf->count;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-		if (count <= 0)
-			break;
-		/* 
-		 * This will make sure that our LVI is correct, that our
-		 * pointer is updated, and that the DAC is running.  We
-		 * have to force the setting of dmabuf->trigger to avoid
-		 * any possible deadlocks.
-		 */
-		if (!dmabuf->enable) {
-			dmabuf->trigger = PCM_ENABLE_OUTPUT;
-			ali_update_lvi(state, 0);
-		}
-		if (signal_pending(current) && signals_allowed) {
-			break;
-		}
-
-		/* It seems that we have to set the current state to
-		 * TASK_INTERRUPTIBLE every time to make the process
-		 * really go to sleep.  This also has to be *after* the
-		 * update_ptr() call because update_ptr is likely to
-		 * do a wake_up() which will unset this before we ever
-		 * try to sleep, resuling in a tight loop in this code
-		 * instead of actually sleeping and waiting for an
-		 * interrupt to wake us up!
-		 */
-		set_current_state(TASK_INTERRUPTIBLE);
-		/*
-		 * set the timeout to significantly longer than it *should*
-		 * take for the DAC to drain the DMA buffer
-		 */
-		tmo = (count * HZ) / (dmabuf->rate);
-		if (!schedule_timeout(tmo >= 2 ? tmo : 2)) {
-			printk(KERN_ERR "ali_audio: drain_dac, dma timeout?\n");
-			count = 0;
-			break;
-		}
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dmabuf->wait, &wait);
-	if (count > 0 && signal_pending(current) && signals_allowed)
-		return -ERESTARTSYS;
-	stop_dac(state);
-	return 0;
-}
-
-
-static int drain_spdifout(struct ali_state *state, int signals_allowed)
-{
-
-	DECLARE_WAITQUEUE(wait, current);
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned long flags;
-	unsigned long tmo;
-	int count;
-	if (!dmabuf->ready)
-		return 0;
-	if (dmabuf->mapped) {
-		stop_spdifout(state);
-		return 0;
-	}
-	add_wait_queue(&dmabuf->wait, &wait);
-	for (;;) {
-
-		spin_lock_irqsave(&state->card->lock, flags);
-		ali_update_ptr(state);
-		count = dmabuf->count;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-		if (count <= 0)
-			break;
-		/* 
-		 * This will make sure that our LVI is correct, that our
-		 * pointer is updated, and that the DAC is running.  We
-		 * have to force the setting of dmabuf->trigger to avoid
-		 * any possible deadlocks.
-		 */
-		if (!dmabuf->enable) {
-			if (codec_independent_spdif_locked > 0) {
-				dmabuf->trigger = SPDIF_ENABLE_OUTPUT;
-				ali_update_lvi(state, 2);
-			} else {
-				if (controller_independent_spdif_locked > 0) {
-					dmabuf->trigger = SPDIF_ENABLE_OUTPUT;
-					ali_update_lvi(state, 3);
-				}
-			}
-		}
-		if (signal_pending(current) && signals_allowed) {
-			break;
-		}
-
-		/* It seems that we have to set the current state to
-		 * TASK_INTERRUPTIBLE every time to make the process
-		 * really go to sleep.  This also has to be *after* the
-		 * update_ptr() call because update_ptr is likely to
-		 * do a wake_up() which will unset this before we ever
-		 * try to sleep, resuling in a tight loop in this code
-		 * instead of actually sleeping and waiting for an
-		 * interrupt to wake us up!
-		 */
-		set_current_state(TASK_INTERRUPTIBLE);
-		/*
-		 * set the timeout to significantly longer than it *should*
-		 * take for the DAC to drain the DMA buffer
-		 */
-		tmo = (count * HZ) / (dmabuf->rate);
-		if (!schedule_timeout(tmo >= 2 ? tmo : 2)) {
-			printk(KERN_ERR "ali_audio: drain_spdifout, dma timeout?\n");
-			count = 0;
-			break;
-		}
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dmabuf->wait, &wait);
-	if (count > 0 && signal_pending(current) && signals_allowed)
-		return -ERESTARTSYS;
-	stop_spdifout(state);
-	return 0;
-}
-
-static void ali_channel_interrupt(struct ali_card *card)
-{
-	int i, count;
-	
-	for (i = 0; i < NR_HW_CH; i++) {
-		struct ali_state *state = card->states[i];
-		struct ali_channel *c = NULL;
-		struct dmabuf *dmabuf;
-		unsigned long port = card->iobase;
-		u16 status;
-		if (!state)
-			continue;
-		if (!state->dmabuf.ready)
-			continue;
-		dmabuf = &state->dmabuf;
-		if (codec_independent_spdif_locked > 0) {
-			if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING) {
-				c = dmabuf->codec_spdifout_channel;
-			}
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-					c = dmabuf->controller_spdifout_channel;
-			} else {
-				if (dmabuf->enable & DAC_RUNNING) {
-					c = dmabuf->write_channel;
-				} else if (dmabuf->enable & ADC_RUNNING) {
-					c = dmabuf->read_channel;
-				} else
-					continue;
-			}
-		}
-		port += c->port;
-
-		status = inw(port + OFF_SR);
-
-		if (status & DMA_INT_COMPLETE) {
-			/* only wake_up() waiters if this interrupt signals
-			 * us being beyond a userfragsize of data open or
-			 * available, and ali_update_ptr() does that for
-			 * us
-			 */
-			ali_update_ptr(state);
-		}
-
-		if (status & DMA_INT_LVI) {
-			ali_update_ptr(state);
-			wake_up(&dmabuf->wait);
-
-			if (dmabuf->enable & DAC_RUNNING)
-				count = dmabuf->count;
-			else if (dmabuf->enable & ADC_RUNNING)
-				count = dmabuf->dmasize - dmabuf->count;
-			else if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-				count = dmabuf->count;
-			else if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-				count = dmabuf->count;
-			else count = 0;
-
-			if (count > 0) {
-				if (dmabuf->enable & DAC_RUNNING)
-					outl((1 << 1), state->card->iobase + ALI_DMACR);
-				else if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-						outl((1 << 3), state->card->iobase + ALI_DMACR);
-				else if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-					outl((1 << 7), state->card->iobase + ALI_DMACR);
-			} else {
-				if (dmabuf->enable & DAC_RUNNING)
-					__stop_dac(state);
-				if (dmabuf->enable & ADC_RUNNING)
-					__stop_adc(state);
-				if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-					__stop_spdifout(state);
-				if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-					__stop_spdifout(state);
-				dmabuf->enable = 0;
-				wake_up(&dmabuf->wait);
-			}
-
-		}
-		if (!(status & DMA_INT_DCH)) {
-			ali_update_ptr(state);
-			wake_up(&dmabuf->wait);
-			if (dmabuf->enable & DAC_RUNNING)
-				count = dmabuf->count;
-			else if (dmabuf->enable & ADC_RUNNING)
-				count = dmabuf->dmasize - dmabuf->count;
-			else if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-				count = dmabuf->count;
-			else if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-				count = dmabuf->count;
-			else
-				count = 0;
-
-			if (count > 0) {
-				if (dmabuf->enable & DAC_RUNNING)
-					outl((1 << 1), state->card->iobase + ALI_DMACR);
-				else if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-					outl((1 << 3), state->card->iobase + ALI_DMACR);
-				else if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-					outl((1 << 7), state->card->iobase + ALI_DMACR);
-			} else {
-				if (dmabuf->enable & DAC_RUNNING)
-					__stop_dac(state);
-				if (dmabuf->enable & ADC_RUNNING)
-					__stop_adc(state);
-				if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING)
-					__stop_spdifout(state);
-				if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)
-					__stop_spdifout(state);
-				dmabuf->enable = 0;
-				wake_up(&dmabuf->wait);
-			}
-		}
-		outw(status & DMA_INT_MASK, port + OFF_SR);
-	}
-}
-
-static irqreturn_t ali_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct ali_card *card = (struct ali_card *) dev_id;
-	u32 status;
-	u16 status2;
-
-	spin_lock(&card->lock);
-	status = inl(card->iobase + ALI_INTERRUPTSR);
-	if (!(status & INT_MASK)) {
-		spin_unlock(&card->lock);
-		return IRQ_NONE;		/* not for us */
-	}
-
-	if (codec_independent_spdif_locked > 0) {
-		if (globel == 0) {
-			globel += 1;
-			status2 = inw(card->iobase + 0x76);
-			outw(status2 | 0x000c, card->iobase + 0x76);
-		} else {
-			if (status & (INT_PCMOUT | INT_PCMIN | INT_MICIN | INT_SPDIFOUT | INT_CODECSPDIFOUT))
-				ali_channel_interrupt(card);
-		}
-	} else {
-		if (status & (INT_PCMOUT | INT_PCMIN | INT_MICIN | INT_SPDIFOUT | INT_CODECSPDIFOUT))
-			ali_channel_interrupt(card);
-	}
-
-	/* clear 'em */
-	outl(status & INT_MASK, card->iobase + ALI_INTERRUPTSR);
-	spin_unlock(&card->lock);
-	return IRQ_HANDLED;
-}
-
-/* in this loop, dmabuf.count signifies the amount of data that is
-   waiting to be copied to the user's buffer.  It is filled by the dma
-   machine and drained by this loop. */
-
-static ssize_t ali_read(struct file *file, char __user *buffer,
-			size_t count, loff_t * ppos)
-{
-	struct ali_state *state = (struct ali_state *) file->private_data;
-	struct ali_card *card = state ? state->card : NULL;
-	struct dmabuf *dmabuf = &state->dmabuf;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned int swptr;
-	int cnt;
-	DECLARE_WAITQUEUE(waita, current);
-#ifdef DEBUG2
-	printk("ali_audio: ali_read called, count = %d\n", count);
-#endif
-	if (dmabuf->mapped)
-		return -ENXIO;
-	if (dmabuf->enable & DAC_RUNNING)
-		return -ENODEV;
-	if (!dmabuf->read_channel) {
-		dmabuf->ready = 0;
-		dmabuf->read_channel = card->alloc_rec_pcm_channel(card);
-		if (!dmabuf->read_channel) {
-			return -EBUSY;
-		}
-	}
-	if (!dmabuf->ready && (ret = prog_dmabuf(state, 1)))
-		return ret;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	ret = 0;
-	add_wait_queue(&dmabuf->wait, &waita);
-	while (count > 0) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		spin_lock_irqsave(&card->lock, flags);
-		if (PM_SUSPENDED(card)) {
-			spin_unlock_irqrestore(&card->lock, flags);
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			continue;
-		}
-		swptr = dmabuf->swptr;
-		cnt = ali_get_available_read_data(state);
-		// this is to make the copy_to_user simpler below
-		if (cnt > (dmabuf->dmasize - swptr))
-			cnt = dmabuf->dmasize - swptr;
-		spin_unlock_irqrestore(&card->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		/* Lop off the last two bits to force the code to always
-		 * write in full samples.  This keeps software that sets
-		 * O_NONBLOCK but doesn't check the return value of the
-		 * write call from getting things out of state where they
-		 * think a full 4 byte sample was written when really only
-		 * a portion was, resulting in odd sound and stereo
-		 * hysteresis.
-		 */
-		cnt &= ~0x3;
-		if (cnt <= 0) {
-			unsigned long tmo;
-			/*
-			 * Don't let us deadlock.  The ADC won't start if
-			 * dmabuf->trigger isn't set.  A call to SETTRIGGER
-			 * could have turned it off after we set it to on
-			 * previously.
-			 */
-			dmabuf->trigger = PCM_ENABLE_INPUT;
-			/*
-			 * This does three things.  Updates LVI to be correct,
-			 * makes sure the ADC is running, and updates the
-			 * hwptr.
-			 */
-			ali_update_lvi(state, 1);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				goto done;
-			}
-			/* Set the timeout to how long it would take to fill
-			 * two of our buffers.  If we haven't been woke up
-			 * by then, then we know something is wrong.
-			 */
-			tmo = (dmabuf->dmasize * HZ * 2) / (dmabuf->rate * 4);
-			    
-			/* There are two situations when sleep_on_timeout returns, one is when
-			   the interrupt is serviced correctly and the process is waked up by
-			   ISR ON TIME. Another is when timeout is expired, which means that
-			   either interrupt is NOT serviced correctly (pending interrupt) or it
-			   is TOO LATE for the process to be scheduled to run (scheduler latency)
-			   which results in a (potential) buffer overrun. And worse, there is
-			   NOTHING we can do to prevent it. */
-			if (!schedule_timeout(tmo >= 2 ? tmo : 2)) {
-				printk(KERN_ERR
-				       "ali_audio: recording schedule timeout, "
-				       "dmasz %u fragsz %u count %i hwptr %u swptr %u\n",
-				       dmabuf->dmasize, dmabuf->fragsize,
-				       dmabuf->count, dmabuf->hwptr,
-				       dmabuf->swptr);
-				/* a buffer overrun, we delay the recovery until next time the
-				   while loop begin and we REALLY have space to record */
-			}
-			if (signal_pending(current)) {
-				ret = ret ? ret : -ERESTARTSYS;
-				goto done;
-			}
-			continue;
-		}
-
-		if (copy_to_user(buffer, dmabuf->rawbuf + swptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			goto done;
-		}
-
-		swptr = (swptr + cnt) % dmabuf->dmasize;
-		spin_lock_irqsave(&card->lock, flags);
-		if (PM_SUSPENDED(card)) {
-			spin_unlock_irqrestore(&card->lock, flags);
-			continue;
-		}
-		dmabuf->swptr = swptr;
-		dmabuf->count -= cnt;
-		spin_unlock_irqrestore(&card->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-	}
-done:
-	ali_update_lvi(state, 1);
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dmabuf->wait, &waita);
-	return ret;
-}
-
-/* in this loop, dmabuf.count signifies the amount of data that is waiting to be dma to
-   the soundcard.  it is drained by the dma machine and filled by this loop. */
-static ssize_t ali_write(struct file *file,
-			 const char __user *buffer, size_t count, loff_t * ppos)
-{
-	struct ali_state *state = (struct ali_state *) file->private_data;
-	struct ali_card *card = state ? state->card : NULL;
-	struct dmabuf *dmabuf = &state->dmabuf;
-	ssize_t ret;
-	unsigned long flags;
-	unsigned int swptr = 0;
-	int cnt, x;
-	DECLARE_WAITQUEUE(waita, current);
-#ifdef DEBUG2
-	printk("ali_audio: ali_write called, count = %d\n", count);
-#endif
-	if (dmabuf->mapped)
-		return -ENXIO;
-	if (dmabuf->enable & ADC_RUNNING)
-		return -ENODEV;
-	if (codec_independent_spdif_locked > 0) {
-		if (!dmabuf->codec_spdifout_channel) {
-			dmabuf->ready = 0;
-			dmabuf->codec_spdifout_channel = card->alloc_codec_spdifout_channel(card);
-			if (!dmabuf->codec_spdifout_channel)
-				return -EBUSY;
-		}
-	} else {
-		if (controller_independent_spdif_locked > 0) {
-			if (!dmabuf->controller_spdifout_channel) {
-				dmabuf->ready = 0;
-				dmabuf->controller_spdifout_channel = card->alloc_controller_spdifout_channel(card);
-				if (!dmabuf->controller_spdifout_channel)
-					return -EBUSY;
-			}
-		} else {
-			if (!dmabuf->write_channel) {
-				dmabuf->ready = 0;
-				dmabuf->write_channel =
-				    card->alloc_pcm_channel(card);
-				if (!dmabuf->write_channel)
-					return -EBUSY;
-			}
-		}
-	}
-
-	if (codec_independent_spdif_locked > 0) {
-		if (!dmabuf->ready && (ret = prog_dmabuf(state, 2)))
-			return ret;
-	} else {
-		if (controller_independent_spdif_locked > 0) {
-			if (!dmabuf->ready && (ret = prog_dmabuf(state, 3)))
-				return ret;
-		} else {
-
-			if (!dmabuf->ready && (ret = prog_dmabuf(state, 0)))
-				return ret;
-		}
-	}
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	ret = 0;
-	add_wait_queue(&dmabuf->wait, &waita);
-	while (count > 0) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		spin_lock_irqsave(&state->card->lock, flags);
-		if (PM_SUSPENDED(card)) {
-			spin_unlock_irqrestore(&card->lock, flags);
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			continue;
-		}
-
-		swptr = dmabuf->swptr;
-		cnt = ali_get_free_write_space(state);
-		/* Bound the maximum size to how much we can copy to the
-		 * dma buffer before we hit the end.  If we have more to
-		 * copy then it will get done in a second pass of this
-		 * loop starting from the beginning of the buffer.
-		 */
-		if (cnt > (dmabuf->dmasize - swptr))
-			cnt = dmabuf->dmasize - swptr;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-#ifdef DEBUG2
-		printk(KERN_INFO
-		       "ali_audio: ali_write: %d bytes available space\n",
-		       cnt);
-#endif
-		if (cnt > count)
-			cnt = count;
-		/* Lop off the last two bits to force the code to always
-		 * write in full samples.  This keeps software that sets
-		 * O_NONBLOCK but doesn't check the return value of the
-		 * write call from getting things out of state where they
-		 * think a full 4 byte sample was written when really only
-		 * a portion was, resulting in odd sound and stereo
-		 * hysteresis.
-		 */
-		cnt &= ~0x3;
-		if (cnt <= 0) {
-			unsigned long tmo;
-			// There is data waiting to be played
-			/*
-			 * Force the trigger setting since we would
-			 * deadlock with it set any other way
-			 */
-			if (codec_independent_spdif_locked > 0) {
-				dmabuf->trigger = SPDIF_ENABLE_OUTPUT;
-				ali_update_lvi(state, 2);
-			} else {
-				if (controller_independent_spdif_locked > 0) {
-					dmabuf->trigger = SPDIF_ENABLE_OUTPUT;
-					ali_update_lvi(state, 3);
-				} else {
-
-					dmabuf->trigger = PCM_ENABLE_OUTPUT;
-					ali_update_lvi(state, 0);
-				}
-			}
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				goto ret;
-			}
-			/* Not strictly correct but works */
-			tmo = (dmabuf->dmasize * HZ * 2) / (dmabuf->rate * 4);
-			/* There are two situations when sleep_on_timeout returns, one is when
-			   the interrupt is serviced correctly and the process is waked up by
-			   ISR ON TIME. Another is when timeout is expired, which means that
-			   either interrupt is NOT serviced correctly (pending interrupt) or it
-			   is TOO LATE for the process to be scheduled to run (scheduler latency)
-			   which results in a (potential) buffer underrun. And worse, there is
-			   NOTHING we can do to prevent it. */
-			   
-			/* FIXME - do timeout handling here !! */
-			schedule_timeout(tmo >= 2 ? tmo : 2);
-
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				goto ret;
-			}
-			continue;
-		}
-		if (copy_from_user(dmabuf->rawbuf + swptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			goto ret;
-		}
-
-		swptr = (swptr + cnt) % dmabuf->dmasize;
-		spin_lock_irqsave(&state->card->lock, flags);
-		if (PM_SUSPENDED(card)) {
-			spin_unlock_irqrestore(&card->lock, flags);
-			continue;
-		}
-
-		dmabuf->swptr = swptr;
-		dmabuf->count += cnt;
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-	}
-	if (swptr % dmabuf->fragsize) {
-		x = dmabuf->fragsize - (swptr % dmabuf->fragsize);
-		memset(dmabuf->rawbuf + swptr, '\0', x);
-	}
-ret:
-	if (codec_independent_spdif_locked > 0) {
-		ali_update_lvi(state, 2);
-	} else {
-		if (controller_independent_spdif_locked > 0) {
-			ali_update_lvi(state, 3);
-		} else {
-			ali_update_lvi(state, 0);
-		}
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&dmabuf->wait, &waita);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int ali_poll(struct file *file, struct poll_table_struct
-			     *wait)
-{
-	struct ali_state *state = (struct ali_state *) file->private_data;
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned long flags;
-	unsigned int mask = 0;
-	if (!dmabuf->ready)
-		return 0;
-	poll_wait(file, &dmabuf->wait, wait);
-	spin_lock_irqsave(&state->card->lock, flags);
-	ali_update_ptr(state);
-	if (file->f_mode & FMODE_READ && dmabuf->enable & ADC_RUNNING) {
-		if (dmabuf->count >= (signed) dmabuf->fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE  && (dmabuf->enable & (DAC_RUNNING|CODEC_SPDIFOUT_RUNNING|CONTROLLER_SPDIFOUT_RUNNING))) {
-		if ((signed) dmabuf->dmasize >= dmabuf->count + (signed) dmabuf->fragsize)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-	spin_unlock_irqrestore(&state->card->lock, flags);
-	return mask;
-}
-
-static int ali_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct ali_state *state = (struct ali_state *) file->private_data;
-	struct dmabuf *dmabuf = &state->dmabuf;
-	int ret = -EINVAL;
-	unsigned long size;
-	lock_kernel();
-	if (vma->vm_flags & VM_WRITE) {
-		if (!dmabuf->write_channel && (dmabuf->write_channel = state->card->alloc_pcm_channel(state->card)) == NULL) {
-			ret = -EBUSY;
-			goto out;
-		}
-	}
-	if (vma->vm_flags & VM_READ) {
-		if (!dmabuf->read_channel && (dmabuf->read_channel = state->card->alloc_rec_pcm_channel(state->card)) == NULL) {
-			ret = -EBUSY;
-			goto out;
-		}
-	}
-	if ((ret = prog_dmabuf(state, 0)) != 0)
-		goto out;
-	ret = -EINVAL;
-	if (vma->vm_pgoff != 0)
-		goto out;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << dmabuf->buforder))
-		goto out;
-	ret = -EAGAIN;
-	if (remap_pfn_range(vma, vma->vm_start,
-				virt_to_phys(dmabuf->rawbuf) >> PAGE_SHIFT,
-				size, vma->vm_page_prot))
-		goto out;
-	dmabuf->mapped = 1;
-	dmabuf->trigger = 0;
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-static int ali_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct ali_state *state = (struct ali_state *) file->private_data;
-	struct ali_channel *c = NULL;
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned long flags;
-	audio_buf_info abinfo;
-	count_info cinfo;
-	unsigned int i_scr;
-	int val = 0, ret;
-	struct ac97_codec *codec = state->card->ac97_codec[0];
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-#ifdef DEBUG
-	printk("ali_audio: ali_ioctl, arg=0x%x, cmd=",
-	       arg ? *p : 0);
-#endif
-	switch (cmd) {
-	case OSS_GETVERSION:
-#ifdef DEBUG
-		printk("OSS_GETVERSION\n");
-#endif
-		return put_user(SOUND_VERSION, p);
-	case SNDCTL_DSP_RESET:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_RESET\n");
-#endif
-		spin_lock_irqsave(&state->card->lock, flags);
-		if (dmabuf->enable == DAC_RUNNING) {
-			c = dmabuf->write_channel;
-			__stop_dac(state);
-		}
-		if (dmabuf->enable == ADC_RUNNING) {
-			c = dmabuf->read_channel;
-			__stop_adc(state);
-		}
-		if (dmabuf->enable == CODEC_SPDIFOUT_RUNNING) {
-			c = dmabuf->codec_spdifout_channel;
-			__stop_spdifout(state);
-		}
-		if (dmabuf->enable == CONTROLLER_SPDIFOUT_RUNNING) {
-			c = dmabuf->controller_spdifout_channel;
-			__stop_spdifout(state);
-		}
-		if (c != NULL) {
-			outb(2, state->card->iobase + c->port + OFF_CR);	/* reset DMA machine */
-			outl(virt_to_bus(&c->sg[0]),
-			     state->card->iobase + c->port + OFF_BDBAR);
-			outb(0, state->card->iobase + c->port + OFF_CIV);
-			outb(0, state->card->iobase + c->port + OFF_LVI);
-		}
-
-		spin_unlock_irqrestore(&state->card->lock, flags);
-		synchronize_irq(state->card->pci_dev->irq);
-		dmabuf->ready = 0;
-		dmabuf->swptr = dmabuf->hwptr = 0;
-		dmabuf->count = dmabuf->total_bytes = 0;
-		return 0;
-	case SNDCTL_DSP_SYNC:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SYNC\n");
-#endif
-		if (codec_independent_spdif_locked > 0) {
-			if (dmabuf->enable != CODEC_SPDIFOUT_RUNNING
-			    || file->f_flags & O_NONBLOCK)
-				return 0;
-			if ((val = drain_spdifout(state, 1)))
-				return val;
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if (dmabuf->enable !=
-				    CONTROLLER_SPDIFOUT_RUNNING
-				    || file->f_flags & O_NONBLOCK)
-					return 0;
-				if ((val = drain_spdifout(state, 1)))
-					return val;
-			} else {
-				if (dmabuf->enable != DAC_RUNNING
-				    || file->f_flags & O_NONBLOCK)
-					return 0;
-				if ((val = drain_dac(state, 1)))
-					return val;
-			}
-		}
-		dmabuf->total_bytes = 0;
-		return 0;
-	case SNDCTL_DSP_SPEED:	/* set smaple rate */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SPEED\n");
-#endif
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			if (file->f_mode & FMODE_WRITE) {
-				if ((state->card->ac97_status & SPDIF_ON)) {	/* S/PDIF Enabled */
-					/* RELTEK ALC650 only support 48000, need to check that */
-					if (ali_valid_spdif_rate(codec, val)) {
-						if (codec_independent_spdif_locked > 0) {
-							ali_set_spdif_output(state, -1, 0);
-							stop_spdifout(state);
-							dmabuf->ready = 0;
-							/* I add test codec independent spdif out */
-							spin_lock_irqsave(&state->card->lock, flags);
-							ali_set_codecspdifout_rate(state, val);	// I modified
-							spin_unlock_irqrestore(&state->card->lock, flags);
-							/* Set S/PDIF transmitter rate. */
-							i_scr = inl(state->card->iobase + ALI_SCR);
-							if ((i_scr & 0x00300000) == 0x00100000) {
-								ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
-							} else {
-								if ((i_scr&0x00300000)  == 0x00200000)
-								{
-									ali_set_spdif_output(state, AC97_EA_SPSA_6_9, codec_independent_spdif_locked);
-								} else {
-									if ((i_scr & 0x00300000) == 0x00300000) {
-										ali_set_spdif_output(state, AC97_EA_SPSA_10_11, codec_independent_spdif_locked);
-									} else {
-										ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
-									}
-								}
-							}
-
-							if (!(state->card->ac97_status & SPDIF_ON)) {
-								val = dmabuf->rate;
-							}
-						} else {
-							if (controller_independent_spdif_locked > 0) 
-							{
-								stop_spdifout(state);
-								dmabuf->ready = 0;
-								spin_lock_irqsave(&state->card->lock, flags);
-								ali_set_spdifout_rate(state, controller_independent_spdif_locked);
-								spin_unlock_irqrestore(&state->card->lock, flags);
-							} else {
-								/* Set DAC rate */
-								ali_set_spdif_output(state, -1, 0);
-								stop_dac(state);
-								dmabuf->ready = 0;
-								spin_lock_irqsave(&state->card->lock, flags);
-								ali_set_dac_rate(state, val);
-								spin_unlock_irqrestore(&state->card->lock, flags);
-								/* Set S/PDIF transmitter rate. */
-								ali_set_spdif_output(state, AC97_EA_SPSA_3_4, val);
-								if (!(state->card->ac97_status & SPDIF_ON))
-								{
-									val = dmabuf->rate;
-								}
-							}
-						}
-					} else {	/* Not a valid rate for S/PDIF, ignore it */
-						val = dmabuf->rate;
-					}
-				} else {
-					stop_dac(state);
-					dmabuf->ready = 0;
-					spin_lock_irqsave(&state->card->lock, flags);
-					ali_set_dac_rate(state, val);
-					spin_unlock_irqrestore(&state->card->lock, flags);
-				}
-			}
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(state);
-				dmabuf->ready = 0;
-				spin_lock_irqsave(&state->card->lock, flags);
-				ali_set_adc_rate(state, val);
-				spin_unlock_irqrestore(&state->card->lock, flags);
-			}
-		}
-		return put_user(dmabuf->rate, p);
-	case SNDCTL_DSP_STEREO:	/* set stereo or mono channel */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_STEREO\n");
-#endif
-		if (dmabuf->enable & DAC_RUNNING) {
-			stop_dac(state);
-		}
-		if (dmabuf->enable & ADC_RUNNING) {
-			stop_adc(state);
-		}
-		if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING) {
-			stop_spdifout(state);
-		}
-		if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING) {
-			stop_spdifout(state);
-		}
-		return put_user(1, p);
-	case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if (codec_independent_spdif_locked > 0) {
-				if (!dmabuf->ready && (val = prog_dmabuf(state, 2)))
-					return val;
-			} else {
-				if (controller_independent_spdif_locked > 0) {
-					if (!dmabuf->ready && (val = prog_dmabuf(state, 3)))
-						return val;
-				} else {
-					if (!dmabuf->ready && (val = prog_dmabuf(state, 0)))
-						return val;
-				}
-			}
-		}
-
-		if (file->f_mode & FMODE_READ) {
-			if (!dmabuf->ready && (val = prog_dmabuf(state, 1)))
-				return val;
-		}
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETBLKSIZE %d\n", dmabuf->userfragsize);
-#endif
-		return put_user(dmabuf->userfragsize, p);
-	case SNDCTL_DSP_GETFMTS:	/* Returns a mask of supported sample format */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETFMTS\n");
-#endif
-		return put_user(AFMT_S16_LE, p);
-	case SNDCTL_DSP_SETFMT:	/* Select sample format */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SETFMT\n");
-#endif
-		return put_user(AFMT_S16_LE, p);
-	case SNDCTL_DSP_CHANNELS:	// add support 4,6 channel 
-#ifdef DEBUG
-		printk("SNDCTL_DSP_CHANNELS\n");
-#endif
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val > 0) {
-			if (dmabuf->enable & DAC_RUNNING) {
-				stop_dac(state);
-			}
-			if (dmabuf->enable & CODEC_SPDIFOUT_RUNNING) {
-				stop_spdifout(state);
-			}
-			if (dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING) {
-				stop_spdifout(state);
-			}
-			if (dmabuf->enable & ADC_RUNNING) {
-				stop_adc(state);
-			}
-		} else {
-			return put_user(state->card->channels, p);
-		}
-
-		i_scr = inl(state->card->iobase + ALI_SCR);
-		/* Current # of channels enabled */
-		if (i_scr & 0x00000100)
-			ret = 4;
-		else if (i_scr & 0x00000200)
-			ret = 6;
-		else
-			ret = 2;
-		switch (val) {
-		case 2:	/* 2 channels is always supported */
-			if (codec_independent_spdif_locked > 0) {
-				outl(((i_scr & 0xfffffcff) | 0x00100000), (state->card->iobase + ALI_SCR));
-			} else
-				outl((i_scr & 0xfffffcff), (state->card->iobase + ALI_SCR));
-			/* Do we need to change mixer settings????  */
-			break;
-		case 4:	/* Supported on some chipsets, better check first */
-			if (codec_independent_spdif_locked > 0) {
-				outl(((i_scr & 0xfffffcff) | 0x00000100 | 0x00200000), (state->card->iobase + ALI_SCR));
-			} else
-				outl(((i_scr & 0xfffffcff) | 0x00000100), (state->card->iobase + ALI_SCR));
-			break;
-		case 6:	/* Supported on some chipsets, better check first */
-			if (codec_independent_spdif_locked > 0) {
-				outl(((i_scr & 0xfffffcff) | 0x00000200 | 0x00008000 | 0x00300000), (state->card->iobase + ALI_SCR));
-			} else
-				outl(((i_scr & 0xfffffcff) | 0x00000200 | 0x00008000), (state->card->iobase + ALI_SCR));
-			break;
-		default:	/* nothing else is ever supported by the chipset */
-			val = ret;
-			break;
-		}
-		return put_user(val, p);
-	case SNDCTL_DSP_POST:	/* the user has sent all data and is notifying us */
-		/* we update the swptr to the end of the last sg segment then return */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_POST\n");
-#endif
-		if (codec_independent_spdif_locked > 0) {
-			if (!dmabuf->ready || (dmabuf->enable != CODEC_SPDIFOUT_RUNNING))
-				return 0;
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if (!dmabuf->ready || (dmabuf->enable != CONTROLLER_SPDIFOUT_RUNNING))
-					return 0;
-			} else {
-				if (!dmabuf->ready || (dmabuf->enable != DAC_RUNNING))
-					return 0;
-			}
-		}
-		if ((dmabuf->swptr % dmabuf->fragsize) != 0) {
-			val = dmabuf->fragsize - (dmabuf->swptr % dmabuf->fragsize);
-			dmabuf->swptr += val;
-			dmabuf->count += val;
-		}
-		return 0;
-	case SNDCTL_DSP_SUBDIVIDE:
-		if (dmabuf->subdivision)
-			return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SUBDIVIDE %d\n", val);
-#endif
-		dmabuf->subdivision = val;
-		dmabuf->ready = 0;
-		return 0;
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, p))
-			return -EFAULT;
-		dmabuf->ossfragsize = 1 << (val & 0xffff);
-		dmabuf->ossmaxfrags = (val >> 16) & 0xffff;
-		if (!dmabuf->ossfragsize || !dmabuf->ossmaxfrags)
-			return -EINVAL;
-		/*
-		 * Bound the frag size into our allowed range of 256 - 4096
-		 */
-		if (dmabuf->ossfragsize < 256)
-			dmabuf->ossfragsize = 256;
-		else if (dmabuf->ossfragsize > 4096)
-			dmabuf->ossfragsize = 4096;
-		/*
-		 * The numfrags could be something reasonable, or it could
-		 * be 0xffff meaning "Give me as much as possible".  So,
-		 * we check the numfrags * fragsize doesn't exceed our
-		 * 64k buffer limit, nor is it less than our 8k minimum.
-		 * If it fails either one of these checks, then adjust the
-		 * number of fragments, not the size of them.  It's OK if
-		 * our number of fragments doesn't equal 32 or anything
-		 * like our hardware based number now since we are using
-		 * a different frag count for the hardware.  Before we get
-		 * into this though, bound the maxfrags to avoid overflow
-		 * issues.  A reasonable bound would be 64k / 256 since our
-		 * maximum buffer size is 64k and our minimum frag size is
-		 * 256.  On the other end, our minimum buffer size is 8k and
-		 * our maximum frag size is 4k, so the lower bound should
-		 * be 2.
-		 */
-		if (dmabuf->ossmaxfrags > 256)
-			dmabuf->ossmaxfrags = 256;
-		else if (dmabuf->ossmaxfrags < 2)
-			dmabuf->ossmaxfrags = 2;
-		val = dmabuf->ossfragsize * dmabuf->ossmaxfrags;
-		while (val < 8192) {
-			val <<= 1;
-			dmabuf->ossmaxfrags <<= 1;
-		}
-		while (val > 65536) {
-			val >>= 1;
-			dmabuf->ossmaxfrags >>= 1;
-		}
-		dmabuf->ready = 0;
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SETFRAGMENT 0x%x, %d, %d\n", val,
-		       dmabuf->ossfragsize, dmabuf->ossmaxfrags);
-#endif
-		return 0;
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (codec_independent_spdif_locked > 0) {
-			if (!dmabuf->ready && (val = prog_dmabuf(state, 2)) != 0)
-				return val;
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if (!dmabuf->ready && (val = prog_dmabuf(state, 3)) != 0)
-					return val;
-			} else {
-				if (!dmabuf->ready && (val = prog_dmabuf(state, 0)) != 0)
-					return val;
-			}
-		}
-		spin_lock_irqsave(&state->card->lock, flags);
-		ali_update_ptr(state);
-		abinfo.fragsize = dmabuf->userfragsize;
-		abinfo.fragstotal = dmabuf->userfrags;
-		if (dmabuf->mapped)
-			abinfo.bytes = dmabuf->dmasize;
-		else
-			abinfo.bytes = ali_get_free_write_space(state);
-		abinfo.fragments = abinfo.bytes / dmabuf->userfragsize;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-#if defined(DEBUG) || defined(DEBUG_MMAP)
-		printk("SNDCTL_DSP_GETOSPACE %d, %d, %d, %d\n",
-		       abinfo.bytes, abinfo.fragsize, abinfo.fragments,
-		       abinfo.fragstotal);
-#endif
-		return copy_to_user(argp, &abinfo,
-				    sizeof(abinfo)) ? -EFAULT : 0;
-	case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (codec_independent_spdif_locked > 0) {
-			if (!dmabuf->ready && (val = prog_dmabuf(state, 2)) != 0)
-				return val;
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if (!dmabuf->ready && (val = prog_dmabuf(state, 3)) != 0)
-					return val;
-			} else {
-				if (!dmabuf->ready && (val = prog_dmabuf(state, 0)) != 0)
-					return val;
-			}
-		}
-		spin_lock_irqsave(&state->card->lock, flags);
-		val = ali_get_free_write_space(state);
-		cinfo.bytes = dmabuf->total_bytes;
-		cinfo.ptr = dmabuf->hwptr;
-		cinfo.blocks = val / dmabuf->userfragsize;
-		if (codec_independent_spdif_locked > 0) {
-			if (dmabuf->mapped && (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)) {
-				dmabuf->count += val;
-				dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
-				__ali_update_lvi(state, 2);
-			}
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if (dmabuf->mapped && (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)) {
-					dmabuf->count += val;
-					dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
-					__ali_update_lvi(state, 3);
-				}
-			} else {
-				if (dmabuf->mapped && (dmabuf->trigger & PCM_ENABLE_OUTPUT)) {
-					dmabuf->count += val;
-					dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
-					__ali_update_lvi(state, 0);
-				}
-			}
-		}
-		spin_unlock_irqrestore(&state->card->lock, flags);
-#if defined(DEBUG) || defined(DEBUG_MMAP)
-		printk("SNDCTL_DSP_GETOPTR %d, %d, %d, %d\n", cinfo.bytes,
-		       cinfo.blocks, cinfo.ptr, dmabuf->count);
-#endif
-		return copy_to_user(argp, &cinfo, sizeof(cinfo))? -EFAULT : 0;
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!dmabuf->ready && (val = prog_dmabuf(state, 1)) != 0)
-			return val;
-		spin_lock_irqsave(&state->card->lock, flags);
-		abinfo.bytes = ali_get_available_read_data(state);
-		abinfo.fragsize = dmabuf->userfragsize;
-		abinfo.fragstotal = dmabuf->userfrags;
-		abinfo.fragments = abinfo.bytes / dmabuf->userfragsize;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-#if defined(DEBUG) || defined(DEBUG_MMAP)
-		printk("SNDCTL_DSP_GETISPACE %d, %d, %d, %d\n",
-		       abinfo.bytes, abinfo.fragsize, abinfo.fragments,
-		       abinfo.fragstotal);
-#endif
-		return copy_to_user(argp, &abinfo,
-				    sizeof(abinfo)) ? -EFAULT : 0;
-	case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!dmabuf->ready && (val = prog_dmabuf(state, 0)) != 0)
-			return val;
-		spin_lock_irqsave(&state->card->lock, flags);
-		val = ali_get_available_read_data(state);
-		cinfo.bytes = dmabuf->total_bytes;
-		cinfo.blocks = val / dmabuf->userfragsize;
-		cinfo.ptr = dmabuf->hwptr;
-		if (dmabuf->mapped && (dmabuf->trigger & PCM_ENABLE_INPUT)) {
-			dmabuf->count -= val;
-			dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
-			__ali_update_lvi(state, 1);
-		}
-		spin_unlock_irqrestore(&state->card->lock, flags);
-#if defined(DEBUG) || defined(DEBUG_MMAP)
-		printk("SNDCTL_DSP_GETIPTR %d, %d, %d, %d\n", cinfo.bytes,
-		       cinfo.blocks, cinfo.ptr, dmabuf->count);
-#endif
-		return copy_to_user(argp, &cinfo, sizeof(cinfo))? -EFAULT: 0;
-	case SNDCTL_DSP_NONBLOCK:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_NONBLOCK\n");
-#endif
-		file->f_flags |= O_NONBLOCK;
-		return 0;
-	case SNDCTL_DSP_GETCAPS:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETCAPS\n");
-#endif
-		return put_user(DSP_CAP_REALTIME | DSP_CAP_TRIGGER |
-				DSP_CAP_MMAP | DSP_CAP_BIND, p);
-	case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETTRIGGER 0x%x\n", dmabuf->trigger);
-#endif
-		return put_user(dmabuf->trigger, p);
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-#if defined(DEBUG) || defined(DEBUG_MMAP)
-		printk("SNDCTL_DSP_SETTRIGGER 0x%x\n", val);
-#endif
-		if (!(val & PCM_ENABLE_INPUT) && dmabuf->enable == ADC_RUNNING) {
-			stop_adc(state);
-		}
-		if (!(val & PCM_ENABLE_OUTPUT) && dmabuf->enable == DAC_RUNNING) {
-			stop_dac(state);
-		}
-		if (!(val & SPDIF_ENABLE_OUTPUT) && dmabuf->enable == CODEC_SPDIFOUT_RUNNING) {
-			stop_spdifout(state);
-		}
-		if (!(val & SPDIF_ENABLE_OUTPUT) && dmabuf->enable == CONTROLLER_SPDIFOUT_RUNNING) {
-			stop_spdifout(state);
-		}
-		dmabuf->trigger = val;
-		if (val & PCM_ENABLE_OUTPUT && !(dmabuf->enable & DAC_RUNNING)) {
-			if (!dmabuf->write_channel) {
-				dmabuf->ready = 0;
-				dmabuf->write_channel = state->card->alloc_pcm_channel(state->card);
-				if (!dmabuf->write_channel)
-					return -EBUSY;
-			}
-			if (!dmabuf->ready && (ret = prog_dmabuf(state, 0)))
-				return ret;
-			if (dmabuf->mapped) {
-				spin_lock_irqsave(&state->card->lock, flags);
-				ali_update_ptr(state);
-				dmabuf->count = 0;
-				dmabuf->swptr = dmabuf->hwptr;
-				dmabuf->count = ali_get_free_write_space(state);
-				dmabuf->swptr = (dmabuf->swptr + dmabuf->count) % dmabuf->dmasize;
-				__ali_update_lvi(state, 0);
-				spin_unlock_irqrestore(&state->card->lock,
-						       flags);
-			} else
-				start_dac(state);
-		}
-		if (val & SPDIF_ENABLE_OUTPUT && !(dmabuf->enable & CODEC_SPDIFOUT_RUNNING)) {
-			if (!dmabuf->codec_spdifout_channel) {
-				dmabuf->ready = 0;
-				dmabuf->codec_spdifout_channel = state->card->alloc_codec_spdifout_channel(state->card);
-				if (!dmabuf->codec_spdifout_channel)
-					return -EBUSY;
-			}
-			if (!dmabuf->ready && (ret = prog_dmabuf(state, 2)))
-				return ret;
-			if (dmabuf->mapped) {
-				spin_lock_irqsave(&state->card->lock, flags);
-				ali_update_ptr(state);
-				dmabuf->count = 0;
-				dmabuf->swptr = dmabuf->hwptr;
-				dmabuf->count = ali_get_free_write_space(state);
-				dmabuf->swptr = (dmabuf->swptr + dmabuf->count) % dmabuf->dmasize;
-				__ali_update_lvi(state, 2);
-				spin_unlock_irqrestore(&state->card->lock,
-						       flags);
-			} else
-				start_spdifout(state);
-		}
-		if (val & SPDIF_ENABLE_OUTPUT && !(dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)) {
-			if (!dmabuf->controller_spdifout_channel) {
-				dmabuf->ready = 0;
-				dmabuf->controller_spdifout_channel = state->card->alloc_controller_spdifout_channel(state->card);
-				if (!dmabuf->controller_spdifout_channel)
-					return -EBUSY;
-			}
-			if (!dmabuf->ready && (ret = prog_dmabuf(state, 3)))
-				return ret;
-			if (dmabuf->mapped) {
-				spin_lock_irqsave(&state->card->lock, flags);
-				ali_update_ptr(state);
-				dmabuf->count = 0;
-				dmabuf->swptr = dmabuf->hwptr;
-				dmabuf->count = ali_get_free_write_space(state);
-				dmabuf->swptr = (dmabuf->swptr + dmabuf->count) % dmabuf->dmasize;
-				__ali_update_lvi(state, 3);
-				spin_unlock_irqrestore(&state->card->lock, flags);
-			} else
-				start_spdifout(state);
-		}
-		if (val & PCM_ENABLE_INPUT && !(dmabuf->enable & ADC_RUNNING)) {
-			if (!dmabuf->read_channel) {
-				dmabuf->ready = 0;
-				dmabuf->read_channel = state->card->alloc_rec_pcm_channel(state->card);
-				if (!dmabuf->read_channel)
-					return -EBUSY;
-			}
-			if (!dmabuf->ready && (ret = prog_dmabuf(state, 1)))
-				return ret;
-			if (dmabuf->mapped) {
-				spin_lock_irqsave(&state->card->lock,
-						  flags);
-				ali_update_ptr(state);
-				dmabuf->swptr = dmabuf->hwptr;
-				dmabuf->count = 0;
-				spin_unlock_irqrestore(&state->card->lock, flags);
-			}
-			ali_update_lvi(state, 1);
-			start_adc(state);
-		}
-		return 0;
-	case SNDCTL_DSP_SETDUPLEX:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SETDUPLEX\n");
-#endif
-		return -EINVAL;
-	case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		spin_lock_irqsave(&state->card->lock, flags);
-		ali_update_ptr(state);
-		val = dmabuf->count;
-		spin_unlock_irqrestore(&state->card->lock, flags);
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETODELAY %d\n", dmabuf->count);
-#endif
-		return put_user(val, p);
-	case SOUND_PCM_READ_RATE:
-#ifdef DEBUG
-		printk("SOUND_PCM_READ_RATE %d\n", dmabuf->rate);
-#endif
-		return put_user(dmabuf->rate, p);
-	case SOUND_PCM_READ_CHANNELS:
-#ifdef DEBUG
-		printk("SOUND_PCM_READ_CHANNELS\n");
-#endif
-		return put_user(2, p);
-	case SOUND_PCM_READ_BITS:
-#ifdef DEBUG
-		printk("SOUND_PCM_READ_BITS\n");
-#endif
-		return put_user(AFMT_S16_LE, p);
-	case SNDCTL_DSP_SETSPDIF:	/* Set S/PDIF Control register */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_SETSPDIF\n");
-#endif
-		if (get_user(val, p))
-			return -EFAULT;
-		/* Check to make sure the codec supports S/PDIF transmitter */
-		if ((state->card->ac97_features & 4)) {
-			/* mask out the transmitter speed bits so the user can't set them */
-			val &= ~0x3000;
-			/* Add the current transmitter speed bits to the passed value */
-			ret = ali_ac97_get(codec, AC97_SPDIF_CONTROL);
-			val |= (ret & 0x3000);
-			ali_ac97_set(codec, AC97_SPDIF_CONTROL, val);
-			if (ali_ac97_get(codec, AC97_SPDIF_CONTROL) != val) {
-				printk(KERN_ERR "ali_audio: Unable to set S/PDIF configuration to 0x%04x.\n", val);
-				return -EFAULT;
-			}
-		}
-#ifdef DEBUG
-		else
-			printk(KERN_WARNING "ali_audio: S/PDIF transmitter not avalible.\n");
-#endif
-		return put_user(val, p);
-	case SNDCTL_DSP_GETSPDIF:	/* Get S/PDIF Control register */
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETSPDIF\n");
-#endif
-		if (get_user(val, p))
-			return -EFAULT;
-		/* Check to make sure the codec supports S/PDIF transmitter */
-		if (!(state->card->ac97_features & 4)) {
-#ifdef DEBUG
-			printk(KERN_WARNING "ali_audio: S/PDIF transmitter not avalible.\n");
-#endif
-			val = 0;
-		} else {
-			val = ali_ac97_get(codec, AC97_SPDIF_CONTROL);
-		}
-
-		return put_user(val, p);
-//end add support spdif out
-//add support 4,6 channel
-	case SNDCTL_DSP_GETCHANNELMASK:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_GETCHANNELMASK\n");
-#endif
-		if (get_user(val, p))
-			return -EFAULT;
-		/* Based on AC'97 DAC support, not ICH hardware */
-		val = DSP_BIND_FRONT;
-		if (state->card->ac97_features & 0x0004)
-			val |= DSP_BIND_SPDIF;
-		if (state->card->ac97_features & 0x0080)
-			val |= DSP_BIND_SURR;
-		if (state->card->ac97_features & 0x0140)
-			val |= DSP_BIND_CENTER_LFE;
-		return put_user(val, p);
-	case SNDCTL_DSP_BIND_CHANNEL:
-#ifdef DEBUG
-		printk("SNDCTL_DSP_BIND_CHANNEL\n");
-#endif
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val == DSP_BIND_QUERY) {
-			val = DSP_BIND_FRONT;	/* Always report this as being enabled */
-			if (state->card->ac97_status & SPDIF_ON)
-				val |= DSP_BIND_SPDIF;
-			else {
-				if (state->card->ac97_status & SURR_ON)
-					val |= DSP_BIND_SURR;
-				if (state->card->
-				    ac97_status & CENTER_LFE_ON)
-					val |= DSP_BIND_CENTER_LFE;
-			}
-		} else {	/* Not a query, set it */
-			if (!(file->f_mode & FMODE_WRITE))
-				return -EINVAL;
-			if (dmabuf->enable == DAC_RUNNING) {
-				stop_dac(state);
-			}
-			if (val & DSP_BIND_SPDIF) {	/* Turn on SPDIF */
-				/*  Ok, this should probably define what slots
-				 *  to use. For now, we'll only set it to the
-				 *  defaults:
-				 * 
-				 *   non multichannel codec maps to slots 3&4
-				 *   2 channel codec maps to slots 7&8
-				 *   4 channel codec maps to slots 6&9
-				 *   6 channel codec maps to slots 10&11
-				 *
-				 *  there should be some way for the app to
-				 *  select the slot assignment.
-				 */
-				i_scr = inl(state->card->iobase + ALI_SCR);
-				if (codec_independent_spdif_locked > 0) {
-
-					if ((i_scr & 0x00300000) == 0x00100000) {
-						ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
-					} else {
-						if ((i_scr & 0x00300000) == 0x00200000) {
-							ali_set_spdif_output(state, AC97_EA_SPSA_6_9, codec_independent_spdif_locked);
-						} else {
-							if ((i_scr & 0x00300000) == 0x00300000) {
-								ali_set_spdif_output(state, AC97_EA_SPSA_10_11, codec_independent_spdif_locked);
-							}
-						}
-					}
-				} else {	/* codec spdif out (pcm out share ) */
-					ali_set_spdif_output(state, AC97_EA_SPSA_3_4, dmabuf->rate);	//I do not modify
-				}
-
-				if (!(state->card->ac97_status & SPDIF_ON))
-					val &= ~DSP_BIND_SPDIF;
-			} else {
-				int mask;
-				int channels;
-				/* Turn off S/PDIF if it was on */
-				if (state->card->ac97_status & SPDIF_ON)
-					ali_set_spdif_output(state, -1, 0);
-				mask =
-				    val & (DSP_BIND_FRONT | DSP_BIND_SURR |
-					   DSP_BIND_CENTER_LFE);
-				switch (mask) {
-				case DSP_BIND_FRONT:
-					channels = 2;
-					break;
-				case DSP_BIND_FRONT | DSP_BIND_SURR:
-					channels = 4;
-					break;
-				case DSP_BIND_FRONT | DSP_BIND_SURR | DSP_BIND_CENTER_LFE:
-					channels = 6;
-					break;
-				default:
-					val = DSP_BIND_FRONT;
-					channels = 2;
-					break;
-				}
-				ali_set_dac_channels(state, channels);
-				/* check that they really got turned on */
-				if (!state->card->ac97_status & SURR_ON)
-					val &= ~DSP_BIND_SURR;
-				if (!state->card->
-				    ac97_status & CENTER_LFE_ON)
-					val &= ~DSP_BIND_CENTER_LFE;
-			}
-		}
-		return put_user(val, p);
-	case SNDCTL_DSP_MAPINBUF:
-	case SNDCTL_DSP_MAPOUTBUF:
-	case SNDCTL_DSP_SETSYNCRO:
-	case SOUND_PCM_WRITE_FILTER:
-	case SOUND_PCM_READ_FILTER:
-		return -EINVAL;
-	}
-	return -EINVAL;
-}
-
-static int ali_open(struct inode *inode, struct file *file)
-{
-	int i = 0;
-	struct ali_card *card = devs;
-	struct ali_state *state = NULL;
-	struct dmabuf *dmabuf = NULL;
-	unsigned int i_scr;
-	
-	/* find an available virtual channel (instance of /dev/dsp) */
-	
-	while (card != NULL) {
-
-		/*
-		 * If we are initializing and then fail, card could go
-		 * away unuexpectedly while we are in the for() loop.
-		 * So, check for card on each iteration before we check
-		 * for card->initializing to avoid a possible oops.
-		 * This usually only matters for times when the driver is
-		 * autoloaded by kmod.
-		 */
-		for (i = 0; i < 50 && card && card->initializing; i++) {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(HZ / 20);
-		}
-
-		for (i = 0; i < NR_HW_CH && card && !card->initializing; i++) {
-			if (card->states[i] == NULL) {
-				state = card->states[i] = (struct ali_state *) kmalloc(sizeof(struct ali_state), GFP_KERNEL);
-				if (state == NULL)
-					return -ENOMEM;
-				memset(state, 0, sizeof(struct ali_state));
-				dmabuf = &state->dmabuf;
-				goto found_virt;
-			}
-		}
-		card = card->next;
-	}
-
-	/* no more virtual channel avaiable */
-	if (!state)
-		return -ENODEV;
-found_virt:
-	/* initialize the virtual channel */
-
-	state->virt = i;
-	state->card = card;
-	state->magic = ALI5455_STATE_MAGIC;
-	init_waitqueue_head(&dmabuf->wait);
-	mutex_init(&state->open_mutex);
-	file->private_data = state;
-	dmabuf->trigger = 0;
-	/* allocate hardware channels */
-	if (file->f_mode & FMODE_READ) {
-		if ((dmabuf->read_channel =
-		     card->alloc_rec_pcm_channel(card)) == NULL) {
-			kfree(card->states[i]);
-			card->states[i] = NULL;
-			return -EBUSY;
-		}
-		dmabuf->trigger |= PCM_ENABLE_INPUT;
-		ali_set_adc_rate(state, 8000);
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (codec_independent_spdif_locked > 0) {
-			if ((dmabuf->codec_spdifout_channel = card->alloc_codec_spdifout_channel(card)) == NULL) {
-				kfree(card->states[i]);
-				card->states[i] = NULL;
-				return -EBUSY;
-			}
-			dmabuf->trigger |= SPDIF_ENABLE_OUTPUT;
-			ali_set_codecspdifout_rate(state, codec_independent_spdif_locked);	//It must add
-			i_scr = inl(state->card->iobase + ALI_SCR);
-			if ((i_scr & 0x00300000) == 0x00100000) {
-				ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
-			} else {
-				if ((i_scr & 0x00300000) == 0x00200000) {
-					ali_set_spdif_output(state, AC97_EA_SPSA_6_9, codec_independent_spdif_locked);
-				} else {
-					if ((i_scr & 0x00300000) == 0x00300000) {
-						ali_set_spdif_output(state, AC97_EA_SPSA_10_11, codec_independent_spdif_locked);
-					} else {
-						ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
-					}
-				}
-
-			}
-		} else {
-			if (controller_independent_spdif_locked > 0) {
-				if ((dmabuf->controller_spdifout_channel = card->alloc_controller_spdifout_channel(card)) == NULL) {
-					kfree(card->states[i]);
-					card->states[i] = NULL;
-					return -EBUSY;
-				}
-				dmabuf->trigger |= SPDIF_ENABLE_OUTPUT;
-				ali_set_spdifout_rate(state, controller_independent_spdif_locked);
-			} else {
-				if ((dmabuf->write_channel = card->alloc_pcm_channel(card)) == NULL) {
-					kfree(card->states[i]);
-					card->states[i] = NULL;
-					return -EBUSY;
-				}
-				/* Initialize to 8kHz?  What if we don't support 8kHz? */
-				/*  Let's change this to check for S/PDIF stuff */
-
-				dmabuf->trigger |= PCM_ENABLE_OUTPUT;
-				if (codec_pcmout_share_spdif_locked) {
-					ali_set_dac_rate(state, codec_pcmout_share_spdif_locked);
-					ali_set_spdif_output(state, AC97_EA_SPSA_3_4, codec_pcmout_share_spdif_locked);
-				} else {
-					ali_set_dac_rate(state, 8000);
-				}
-			}
-
-		}
-	}
-
-	/* set default sample format. According to OSS Programmer's Guide  /dev/dsp
-	   should be default to unsigned 8-bits, mono, with sample rate 8kHz and
-	   /dev/dspW will accept 16-bits sample, but we don't support those so we
-	   set it immediately to stereo and 16bit, which is all we do support */
-	dmabuf->fmt |= ALI5455_FMT_16BIT | ALI5455_FMT_STEREO;
-	dmabuf->ossfragsize = 0;
-	dmabuf->ossmaxfrags = 0;
-	dmabuf->subdivision = 0;
-	state->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	outl(0x00000000, card->iobase + ALI_INTERRUPTCR);
-	outl(0x00000000, card->iobase + ALI_INTERRUPTSR);
-	return nonseekable_open(inode, file);
-}
-
-static int ali_release(struct inode *inode, struct file *file)
-{
-	struct ali_state *state = (struct ali_state *) file->private_data;
-	struct ali_card *card = state->card;
-	struct dmabuf *dmabuf = &state->dmabuf;
-	unsigned long flags;
-	lock_kernel();
-	
-	/* stop DMA state machine and free DMA buffers/channels */
-	if (dmabuf->trigger & PCM_ENABLE_OUTPUT)
-		drain_dac(state, 0);
-
-	if (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)
-		drain_spdifout(state, 0);
-	
-	if (dmabuf->trigger & PCM_ENABLE_INPUT)
-		stop_adc(state);
-	
-	spin_lock_irqsave(&card->lock, flags);
-	dealloc_dmabuf(state);
-	if (file->f_mode & FMODE_WRITE) {
-		if (codec_independent_spdif_locked > 0) {
-			state->card->free_pcm_channel(state->card, dmabuf->codec_spdifout_channel->num);
-		} else {
-			if (controller_independent_spdif_locked > 0)
-				state->card->free_pcm_channel(state->card,
-							      dmabuf->controller_spdifout_channel->num);
-			else state->card->free_pcm_channel(state->card,
-							      dmabuf->write_channel->num);
-		}
-	}
-	if (file->f_mode & FMODE_READ)
-		state->card->free_pcm_channel(state->card, dmabuf->read_channel->num);
-
-	state->card->states[state->virt] = NULL;
-	kfree(state);
-	spin_unlock_irqrestore(&card->lock, flags);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const */ struct file_operations ali_audio_fops = {
-	.owner		= THIS_MODULE, 
-	.llseek		= no_llseek, 
-	.read		= ali_read,
-	.write		= ali_write, 
-	.poll		= ali_poll,
-	.ioctl		= ali_ioctl,
-	.mmap		= ali_mmap,
-	.open		= ali_open,
-	.release	= ali_release,
-};
-
-/* Read AC97 codec registers */
-static u16 ali_ac97_get(struct ac97_codec *dev, u8 reg)
-{
-	struct ali_card *card = dev->private_data;
-	int count1 = 100;
-	char val;
-	unsigned short int data = 0, count, addr1, addr2 = 0;
-
-	spin_lock(&card->ac97_lock);
-	while (count1-- && (inl(card->iobase + ALI_CAS) & 0x80000000))
-		udelay(1);
-
-	addr1 = reg;
-	reg |= 0x0080;
-	for (count = 0; count < 0x7f; count++) {
-		val = inb(card->iobase + ALI_CSPSR);
-		if (val & 0x08)
-			break;
-	}
-	if (count == 0x7f)
-	{
-		spin_unlock(&card->ac97_lock);
-		return -1;
-	}
-	outw(reg, (card->iobase + ALI_CPR) + 2);
-	for (count = 0; count < 0x7f; count++) {
-		val = inb(card->iobase + ALI_CSPSR);
-		if (val & 0x02) {
-			data = inw(card->iobase + ALI_SPR);
-			addr2 = inw((card->iobase + ALI_SPR) + 2);
-			break;
-		}
-	}
-	spin_unlock(&card->ac97_lock);
-	if (count == 0x7f)
-		return -1;
-	if (addr2 != addr1)
-		return -1;
-	return ((u16) data);
-}
-
-/* write ac97 codec register   */
-
-static void ali_ac97_set(struct ac97_codec *dev, u8 reg, u16 data)
-{
-	struct ali_card *card = dev->private_data;
-	int count1 = 100;
-	char val;
-	unsigned short int count;
-
-	spin_lock(&card->ac97_lock);
-	while (count1-- && (inl(card->iobase + ALI_CAS) & 0x80000000))
-		udelay(1);
-
-	for (count = 0; count < 0x7f; count++) {
-		val = inb(card->iobase + ALI_CSPSR);
-		if (val & 0x08)
-			break;
-	}
-	if (count == 0x7f) {
-		printk(KERN_WARNING "ali_ac97_set: AC97 codec register access timed out. \n");
-		spin_unlock(&card->ac97_lock);
-		return;
-	}
-	outw(data, (card->iobase + ALI_CPR));
-	outb(reg, (card->iobase + ALI_CPR) + 2);
-	for (count = 0; count < 0x7f; count++) {
-		val = inb(card->iobase + ALI_CSPSR);
-		if (val & 0x01)
-			break;
-	}
-	spin_unlock(&card->ac97_lock);
-	if (count == 0x7f)
-		printk(KERN_WARNING "ali_ac97_set: AC97 codec register access timed out. \n");
-	return;
-}
-
-/* OSS /dev/mixer file operation methods */
-
-static int ali_open_mixdev(struct inode *inode, struct file *file)
-{
-	int i;
-	int minor = iminor(inode);
-	struct ali_card *card = devs;
-	for (card = devs; card != NULL; card = card->next) {
-		/*
-		 * If we are initializing and then fail, card could go
-		 * away unuexpectedly while we are in the for() loop.
-		 * So, check for card on each iteration before we check
-		 * for card->initializing to avoid a possible oops.
-		 * This usually only matters for times when the driver is
-		 * autoloaded by kmod.
-		 */
-		for (i = 0; i < 50 && card && card->initializing; i++) {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(HZ / 20);
-		}
-		for (i = 0; i < NR_AC97 && card && !card->initializing; i++)
-			if (card->ac97_codec[i] != NULL
-			    && card->ac97_codec[i]->dev_mixer == minor) {
-				file->private_data = card->ac97_codec[i];
-				return nonseekable_open(inode, file);
-			}
-	}
-	return -ENODEV;
-}
-
-static int ali_ioctl_mixdev(struct inode *inode,
-			    struct file *file,
-			    unsigned int cmd, unsigned long arg)
-{
-	struct ac97_codec *codec = (struct ac97_codec *) file->private_data;
-	return codec->mixer_ioctl(codec, cmd, arg);
-}
-
-static /*const */ struct file_operations ali_mixer_fops = {
-	.owner	= THIS_MODULE, 
-	.llseek	= no_llseek, 
-	.ioctl	= ali_ioctl_mixdev,
-	.open	= ali_open_mixdev,
-};
-
-/* AC97 codec initialisation.  These small functions exist so we don't
-   duplicate code between module init and apm resume */
-
-static inline int ali_ac97_exists(struct ali_card *card, int ac97_number)
-{
-	unsigned int i = 1;
-	u32 reg = inl(card->iobase + ALI_RTSR);
-	if (ac97_number) {
-		while (i < 100) {
-
-			reg = inl(card->iobase + ALI_RTSR);
-			if (reg & 0x40) {
-				break;
-			} else {
-				outl(reg | 0x00000040,
-				     card->iobase + 0x34);
-				udelay(1);
-			}
-			i++;
-		}
-
-	} else {
-		while (i < 100) {
-			reg = inl(card->iobase + ALI_RTSR);
-			if (reg & 0x80) {
-				break;
-			} else {
-				outl(reg | 0x00000080,
-				     card->iobase + 0x34);
-				udelay(1);
-			}
-			i++;
-		}
-	}
-
-	if (ac97_number)
-		return reg & 0x40;
-	else
-		return reg & 0x80;
-}
-
-static inline int ali_ac97_enable_variable_rate(struct ac97_codec *codec)
-{
-	ali_ac97_set(codec, AC97_EXTENDED_STATUS, 9);
-	ali_ac97_set(codec, AC97_EXTENDED_STATUS, ali_ac97_get(codec, AC97_EXTENDED_STATUS) | 0xE800);
-	return (ali_ac97_get(codec, AC97_EXTENDED_STATUS) & 1);
-}
-
-
-static int ali_ac97_probe_and_powerup(struct ali_card *card, struct ac97_codec *codec)
-{
-	/* Returns 0 on failure */
-	int i;
-	u16 addr;
-	if (ac97_probe_codec(codec) == 0)
-		return 0;
-	/* ac97_probe_codec is success ,then begin to init codec */
-	ali_ac97_set(codec, AC97_RESET, 0xffff);
-	if (card->channel[0].used == 1) {
-		ali_ac97_set(codec, AC97_RECORD_SELECT, 0x0000);
-		ali_ac97_set(codec, AC97_LINEIN_VOL, 0x0808);
-		ali_ac97_set(codec, AC97_RECORD_GAIN, 0x0F0F);
-	}
-
-	if (card->channel[2].used == 1)	//if MICin then init codec
-	{
-		ali_ac97_set(codec, AC97_RECORD_SELECT, 0x0000);
-		ali_ac97_set(codec, AC97_MIC_VOL, 0x8808);
-		ali_ac97_set(codec, AC97_RECORD_GAIN, 0x0F0F);
-		ali_ac97_set(codec, AC97_RECORD_GAIN_MIC, 0x0000);
-	}
-
-	ali_ac97_set(codec, AC97_MASTER_VOL_STEREO, 0x0000);
-	ali_ac97_set(codec, AC97_HEADPHONE_VOL, 0x0000);
-	ali_ac97_set(codec, AC97_PCMOUT_VOL, 0x0000);
-	ali_ac97_set(codec, AC97_CD_VOL, 0x0808);
-	ali_ac97_set(codec, AC97_VIDEO_VOL, 0x0808);
-	ali_ac97_set(codec, AC97_AUX_VOL, 0x0808);
-	ali_ac97_set(codec, AC97_PHONE_VOL, 0x8048);
-	ali_ac97_set(codec, AC97_PCBEEP_VOL, 0x0000);
-	ali_ac97_set(codec, AC97_GENERAL_PURPOSE, AC97_GP_MIX);
-	ali_ac97_set(codec, AC97_MASTER_VOL_MONO, 0x0000);
-	ali_ac97_set(codec, 0x38, 0x0000);
-	addr = ali_ac97_get(codec, 0x2a);
-	ali_ac97_set(codec, 0x2a, addr | 0x0001);
-	addr = ali_ac97_get(codec, 0x2a);
-	addr = ali_ac97_get(codec, 0x28);
-	ali_ac97_set(codec, 0x2c, 0xbb80);
-	addr = ali_ac97_get(codec, 0x2c);
-	/* power it all up */
-	ali_ac97_set(codec, AC97_POWER_CONTROL,
-		     ali_ac97_get(codec, AC97_POWER_CONTROL) & ~0x7f00);
-	/* wait for analog ready */
-	for (i = 10; i && ((ali_ac97_get(codec, AC97_POWER_CONTROL) & 0xf) != 0xf); i--) {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ / 20);
-	}
-	/* FIXME !! */
-	i++;
-	return i;
-}
-
-
-/* I clone ali5455(2.4.7 )  not clone i810_audio(2.4.18)  */
-
-static int ali_reset_5455(struct ali_card *card)
-{
-	outl(0x80000003, card->iobase + ALI_SCR);
-	outl(0x83838383, card->iobase + ALI_FIFOCR1);
-	outl(0x83838383, card->iobase + ALI_FIFOCR2);
-	if (controller_pcmout_share_spdif_locked > 0) {
-		outl((inl(card->iobase + ALI_SPDIFICS) | 0x00000001),
-		     card->iobase + ALI_SPDIFICS);
-		outl(0x0408000a, card->iobase + ALI_INTERFACECR);
-	} else {
-		if (codec_independent_spdif_locked > 0) {
-			outl((inl(card->iobase + ALI_SCR) | 0x00100000), card->iobase + ALI_SCR);	// now I select slot 7 & 8
-			outl(0x00200000, card->iobase + ALI_INTERFACECR);	//enable codec independent spdifout 
-		} else
-			outl(0x04080002, card->iobase + ALI_INTERFACECR);
-	}
-
-	outl(0x00000000, card->iobase + ALI_INTERRUPTCR);
-	outl(0x00000000, card->iobase + ALI_INTERRUPTSR);
-	if (controller_independent_spdif_locked > 0)
-		outl((inl(card->iobase + ALI_SPDIFICS) | 0x00000001),
-		     card->iobase + ALI_SPDIFICS);
-	return 1;
-}
-
-
-static int ali_ac97_random_init_stuff(struct ali_card
-				      *card)
-{
-	u32 reg = inl(card->iobase + ALI_SCR);
-	int i = 0;
-	reg = inl(card->iobase + ALI_SCR);
-	if ((reg & 2) == 0)	/* Cold required */
-		reg |= 2;
-	else
-		reg |= 1;	/* Warm */
-	reg &= ~0x80000000;	/* ACLink on */
-	outl(reg, card->iobase + ALI_SCR);
-
-	while (i < 10) {
-		if ((inl(card->iobase + 0x18) & (1 << 1)) == 0)
-			break;
-		current->state = TASK_UNINTERRUPTIBLE;
-		schedule_timeout(HZ / 20);
-		i++;
-	}
-	if (i == 10) {
-		printk(KERN_ERR "ali_audio: AC'97 reset failed.\n");
-		return 0;
-	}
-
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(HZ / 2);
-	return 1;
-}
-
-/* AC97 codec initialisation. */
-
-static int __devinit ali_ac97_init(struct ali_card *card)
-{
-	int num_ac97 = 0;
-	int total_channels = 0;
-	struct ac97_codec *codec;
-	u16 eid;
-
-	if (!ali_ac97_random_init_stuff(card))
-		return 0;
-
-	/* Number of channels supported */
-	/* What about the codec?  Just because the ICH supports */
-	/* multiple channels doesn't mean the codec does.       */
-	/* we'll have to modify this in the codec section below */
-	/* to reflect what the codec has.                       */
-	/* ICH and ICH0 only support 2 channels so don't bother */
-	/* to check....                                         */
-	inl(card->iobase + ALI_CPR);
-	card->channels = 2;
-
-	for (num_ac97 = 0; num_ac97 < NR_AC97; num_ac97++) {
-
-		/* Assume codec isn't available until we go through the
-		 * gauntlet below */
-		card->ac97_codec[num_ac97] = NULL;
-		/* The ICH programmer's reference says you should   */
-		/* check the ready status before probing. So we chk */
-		/*   What do we do if it's not ready?  Wait and try */
-		/*   again, or abort?                               */
-		if (!ali_ac97_exists(card, num_ac97)) {
-			if (num_ac97 == 0)
-				printk(KERN_ERR "ali_audio: Primary codec not ready.\n");
-			break;
-		}
-
-		if ((codec = ac97_alloc_codec()) == NULL)
-			return -ENOMEM;
-		/* initialize some basic codec information, other fields will be filled
-		   in ac97_probe_codec */
-		codec->private_data = card;
-		codec->id = num_ac97;
-		codec->codec_read = ali_ac97_get;
-		codec->codec_write = ali_ac97_set;
-		if (!ali_ac97_probe_and_powerup(card, codec)) {
-			printk(KERN_ERR "ali_audio: timed out waiting for codec %d analog ready",
-			     num_ac97);
-			kfree(codec);
-			break;	/* it didn't work */
-		}
-		
-		/* Store state information about S/PDIF transmitter */
-		card->ac97_status = 0;
-		/* Don't attempt to get eid until powerup is complete */
-		eid = ali_ac97_get(codec, AC97_EXTENDED_ID);
-		if (eid == 0xFFFF) {
-			printk(KERN_ERR "ali_audio: no codec attached ?\n");
-			kfree(codec);
-			break;
-		}
-
-		card->ac97_features = eid;
-		/* Now check the codec for useful features to make up for
-		   the dumbness of the ali5455 hardware engine */
-		if (!(eid & 0x0001))
-			printk(KERN_WARNING
-			       "ali_audio: only 48Khz playback available.\n");
-		else {
-			if (!ali_ac97_enable_variable_rate(codec)) {
-				printk(KERN_WARNING
-				       "ali_audio: Codec refused to allow VRA, using 48Khz only.\n");
-				card->ac97_features &= ~1;
-			}
-		}
-
-		/* Determine how many channels the codec(s) support   */
-		/*   - The primary codec always supports 2            */
-		/*   - If the codec supports AMAP, surround DACs will */
-		/*     automaticlly get assigned to slots.            */
-		/*     * Check for surround DACs and increment if     */
-		/*       found.                                       */
-		/*   - Else check if the codec is revision 2.2        */
-		/*     * If surround DACs exist, assign them to slots */
-		/*       and increment channel count.                 */
-
-		/* All of this only applies to ICH2 and above. ICH    */
-		/* and ICH0 only support 2 channels.  ICH2 will only  */
-		/* support multiple codecs in a "split audio" config. */
-		/* as described above.                                */
-
-		/* TODO: Remove all the debugging messages!           */
-
-		if ((eid & 0xc000) == 0)	/* primary codec */
-			total_channels += 2;
-		if ((codec->dev_mixer = register_sound_mixer(&ali_mixer_fops, -1)) < 0) {
-			printk(KERN_ERR "ali_audio: couldn't register mixer!\n");
-			kfree(codec);
-			break;
-		}
-		card->ac97_codec[num_ac97] = codec;
-	}
-	/* pick the minimum of channels supported by ICHx or codec(s) */
-	card->channels = (card->channels > total_channels) ? total_channels : card->channels;
-	return num_ac97;
-}
-
-static void __devinit ali_configure_clocking(void)
-{
-	struct ali_card *card;
-	struct ali_state *state;
-	struct dmabuf *dmabuf;
-	unsigned int i, offset, new_offset;
-	unsigned long flags;
-	card = devs;
-
-	/* We could try to set the clocking for multiple cards, but can you even have
-	 * more than one ali in a machine?  Besides, clocking is global, so unless
-	 * someone actually thinks more than one ali in a machine is possible and
-	 * decides to rewrite that little bit, setting the rate for more than one card
-	 * is a waste of time.
-	 */
-	if (card != NULL) {
-		state = card->states[0] = (struct ali_state *)
-		    kmalloc(sizeof(struct ali_state), GFP_KERNEL);
-		if (state == NULL)
-			return;
-		memset(state, 0, sizeof(struct ali_state));
-		dmabuf = &state->dmabuf;
-		dmabuf->write_channel = card->alloc_pcm_channel(card);
-		state->virt = 0;
-		state->card = card;
-		state->magic = ALI5455_STATE_MAGIC;
-		init_waitqueue_head(&dmabuf->wait);
-		mutex_init(&state->open_mutex);
-		dmabuf->fmt = ALI5455_FMT_STEREO | ALI5455_FMT_16BIT;
-		dmabuf->trigger = PCM_ENABLE_OUTPUT;
-		ali_set_dac_rate(state, 48000);
-		if (prog_dmabuf(state, 0) != 0)
-			goto config_out_nodmabuf;
-		
-		if (dmabuf->dmasize < 16384)
-			goto config_out;
-		
-		dmabuf->count = dmabuf->dmasize;
-		outb(31, card->iobase + dmabuf->write_channel->port + OFF_LVI);
-
-		local_irq_save(flags);
-		start_dac(state);
-		offset = ali_get_dma_addr(state, 0);
-		mdelay(50);
-		new_offset = ali_get_dma_addr(state, 0);
-		stop_dac(state);
-		
-		outb(2, card->iobase + dmabuf->write_channel->port + OFF_CR);
-		local_irq_restore(flags);
-
-		i = new_offset - offset;
-
-		if (i == 0)
-			goto config_out;
-		i = i / 4 * 20;
-		if (i > 48500 || i < 47500) {
-			clocking = clocking * clocking / i;
-		}
-config_out:
-		dealloc_dmabuf(state);
-config_out_nodmabuf:
-		state->card->free_pcm_channel(state->card, state->dmabuf. write_channel->num);
-		kfree(state);
-		card->states[0] = NULL;
-	}
-}
-
-/* install the driver, we do not allocate hardware channel nor DMA buffer now, they are defered 
-   until "ACCESS" time (in prog_dmabuf called by open/read/write/ioctl/mmap) */
-
-static int __devinit ali_probe(struct pci_dev *pci_dev,
-			       const struct pci_device_id *pci_id)
-{
-	struct ali_card *card;
-	if (pci_enable_device(pci_dev))
-		return -EIO;
-	if (pci_set_dma_mask(pci_dev, ALI5455_DMA_MASK)) {
-		printk(KERN_ERR "ali5455: architecture does not support"
-		       " 32bit PCI busmaster DMA\n");
-		return -ENODEV;
-	}
-
-	if ((card = kmalloc(sizeof(struct ali_card), GFP_KERNEL)) == NULL) {
-		printk(KERN_ERR "ali_audio: out of memory\n");
-		return -ENOMEM;
-	}
-	memset(card, 0, sizeof(*card));
-	card->initializing = 1;
-	card->iobase = pci_resource_start(pci_dev, 0);
-	card->pci_dev = pci_dev;
-	card->pci_id = pci_id->device;
-	card->irq = pci_dev->irq;
-	card->next = devs;
-	card->magic = ALI5455_CARD_MAGIC;
-#ifdef CONFIG_PM
-	card->pm_suspended = 0;
-#endif
-	spin_lock_init(&card->lock);
-	spin_lock_init(&card->ac97_lock);
-	devs = card;
-	pci_set_master(pci_dev);
-	printk(KERN_INFO "ali: %s found at IO 0x%04lx, IRQ %d\n",
-	       card_names[pci_id->driver_data], card->iobase, card->irq);
-	card->alloc_pcm_channel = ali_alloc_pcm_channel;
-	card->alloc_rec_pcm_channel = ali_alloc_rec_pcm_channel;
-	card->alloc_rec_mic_channel = ali_alloc_rec_mic_channel;
-	card->alloc_codec_spdifout_channel = ali_alloc_codec_spdifout_channel;
-	card->alloc_controller_spdifout_channel = ali_alloc_controller_spdifout_channel;
-	card->free_pcm_channel = ali_free_pcm_channel;
-	card->channel[0].offset = 0;
-	card->channel[0].port = 0x40;
-	card->channel[0].num = 0;
-	card->channel[1].offset = 0;
-	card->channel[1].port = 0x50;
-	card->channel[1].num = 1;
-	card->channel[2].offset = 0;
-	card->channel[2].port = 0x60;
-	card->channel[2].num = 2;
-	card->channel[3].offset = 0;
-	card->channel[3].port = 0x70;
-	card->channel[3].num = 3;
-	card->channel[4].offset = 0;
-	card->channel[4].port = 0xb0;
-	card->channel[4].num = 4;
-	/* claim our iospace and irq */
-	request_region(card->iobase, 256, card_names[pci_id->driver_data]);
-	if (request_irq(card->irq, &ali_interrupt, IRQF_SHARED,
-			card_names[pci_id->driver_data], card)) {
-		printk(KERN_ERR "ali_audio: unable to allocate irq %d\n",
-		       card->irq);
-		release_region(card->iobase, 256);
-		kfree(card);
-		return -ENODEV;
-	}
-
-	if (ali_reset_5455(card) <= 0) {
-		unregister_sound_dsp(card->dev_audio);
-		release_region(card->iobase, 256);
-		free_irq(card->irq, card);
-		kfree(card);
-		return -ENODEV;
-	}
-
-	/* initialize AC97 codec and register /dev/mixer */
-	if (ali_ac97_init(card) < 0) {
-		release_region(card->iobase, 256);
-		free_irq(card->irq, card);
-		kfree(card);
-		return -ENODEV;
-	}
-	
-	pci_set_drvdata(pci_dev, card);
-	
-	if (clocking == 0) {
-		clocking = 48000;
-		ali_configure_clocking();
-	}
-
-	/* register /dev/dsp */
-	if ((card->dev_audio = register_sound_dsp(&ali_audio_fops, -1)) < 0) {
-		int i;
-		printk(KERN_ERR"ali_audio: couldn't register DSP device!\n");
-		release_region(card->iobase, 256);
-		free_irq(card->irq, card);
-		for (i = 0; i < NR_AC97; i++)
-			if (card->ac97_codec[i] != NULL) {
-				unregister_sound_mixer(card->ac97_codec[i]->dev_mixer);
-				kfree(card->ac97_codec[i]);
-			}
-		kfree(card);
-		return -ENODEV;
-	}
-	card->initializing = 0;
-	return 0;
-}
-
-static void __devexit ali_remove(struct pci_dev *pci_dev)
-{
-	int i;
-	struct ali_card *card = pci_get_drvdata(pci_dev);
-	/* free hardware resources */
-	free_irq(card->irq, devs);
-	release_region(card->iobase, 256);
-	/* unregister audio devices */
-	for (i = 0; i < NR_AC97; i++)
-		if (card->ac97_codec[i] != NULL) {
-			unregister_sound_mixer(card->ac97_codec[i]->
-					       dev_mixer);
-			ac97_release_codec(card->ac97_codec[i]);
-			card->ac97_codec[i] = NULL;
-		}
-	unregister_sound_dsp(card->dev_audio);
-	kfree(card);
-}
-
-#ifdef CONFIG_PM
-static int ali_pm_suspend(struct pci_dev *dev, pm_message_t pm_state)
-{
-	struct ali_card *card = pci_get_drvdata(dev);
-	struct ali_state *state;
-	unsigned long flags;
-	struct dmabuf *dmabuf;
-	int i, num_ac97;
-
-	if (!card)
-		return 0;
-	spin_lock_irqsave(&card->lock, flags);
-	card->pm_suspended = 1;
-	for (i = 0; i < NR_HW_CH; i++) {
-		state = card->states[i];
-		if (!state)
-			continue;
-		/* this happens only if there are open files */
-		dmabuf = &state->dmabuf;
-		if (dmabuf->enable & DAC_RUNNING ||
-		    (dmabuf->count
-		     && (dmabuf->trigger & PCM_ENABLE_OUTPUT))) {
-			state->pm_saved_dac_rate = dmabuf->rate;
-			stop_dac(state);
-		} else {
-			state->pm_saved_dac_rate = 0;
-		}
-		if (dmabuf->enable & ADC_RUNNING) {
-			state->pm_saved_adc_rate = dmabuf->rate;
-			stop_adc(state);
-		} else {
-			state->pm_saved_adc_rate = 0;
-		}
-		dmabuf->ready = 0;
-		dmabuf->swptr = dmabuf->hwptr = 0;
-		dmabuf->count = dmabuf->total_bytes = 0;
-	}
-
-	spin_unlock_irqrestore(&card->lock, flags);
-	/* save mixer settings */
-	for (num_ac97 = 0; num_ac97 < NR_AC97; num_ac97++) {
-		struct ac97_codec *codec = card->ac97_codec[num_ac97];
-		if (!codec)
-			continue;
-		for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-			if ((supported_mixer(codec, i)) && (codec->read_mixer)) {
-				card->pm_saved_mixer_settings[i][num_ac97] = codec->read_mixer(codec, i);
-			}
-		}
-	}
-	pci_save_state(dev);	/* XXX do we need this? */
-	pci_disable_device(dev);	/* disable busmastering */
-	pci_set_power_state(dev, 3);	/* Zzz. */
-	return 0;
-}
-
-
-static int ali_pm_resume(struct pci_dev *dev)
-{
-	int num_ac97, i = 0;
-	struct ali_card *card = pci_get_drvdata(dev);
-	pci_enable_device(dev);
-	pci_restore_state(dev);
-	/* observation of a toshiba portege 3440ct suggests that the 
-	   hardware has to be more or less completely reinitialized from
-	   scratch after an apm suspend.  Works For Me.   -dan */
-	ali_ac97_random_init_stuff(card);
-	for (num_ac97 = 0; num_ac97 < NR_AC97; num_ac97++) {
-		struct ac97_codec *codec = card->ac97_codec[num_ac97];
-		/* check they haven't stolen the hardware while we were
-		   away */
-		if (!codec || !ali_ac97_exists(card, num_ac97)) {
-			if (num_ac97)
-				continue;
-			else
-				BUG();
-		}
-		if (!ali_ac97_probe_and_powerup(card, codec))
-			BUG();
-		if ((card->ac97_features & 0x0001)) {
-			/* at probe time we found we could do variable
-			   rates, but APM suspend has made it forget
-			   its magical powers */
-			if (!ali_ac97_enable_variable_rate(codec))
-				BUG();
-		}
-		/* we lost our mixer settings, so restore them */
-		for (i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-			if (supported_mixer(codec, i)) {
-				int val = card->pm_saved_mixer_settings[i][num_ac97];
-				codec->mixer_state[i] = val;
-				codec->write_mixer(codec, i,
-						   (val & 0xff),
-						   ((val >> 8) & 0xff));
-			}
-		}
-	}
-
-	/* we need to restore the sample rate from whatever it was */
-	for (i = 0; i < NR_HW_CH; i++) {
-		struct ali_state *state = card->states[i];
-		if (state) {
-			if (state->pm_saved_adc_rate)
-				ali_set_adc_rate(state, state->pm_saved_adc_rate);
-			if (state->pm_saved_dac_rate)
-				ali_set_dac_rate(state, state->pm_saved_dac_rate);
-		}
-	}
-
-	card->pm_suspended = 0;
-	/* any processes that were reading/writing during the suspend
-	   probably ended up here */
-	for (i = 0; i < NR_HW_CH; i++) {
-		struct ali_state *state = card->states[i];
-		if (state)
-			wake_up(&state->dmabuf.wait);
-	}
-	return 0;
-}
-#endif				/* CONFIG_PM */
-
-MODULE_AUTHOR("");
-MODULE_DESCRIPTION("ALI 5455 audio support");
-MODULE_LICENSE("GPL");
-module_param(clocking, int, 0);
-/* FIXME: bool? */
-module_param(strict_clocking, uint, 0);
-module_param(codec_pcmout_share_spdif_locked, uint, 0);
-module_param(codec_independent_spdif_locked, uint, 0);
-module_param(controller_pcmout_share_spdif_locked, uint, 0);
-module_param(controller_independent_spdif_locked, uint, 0);
-#define ALI5455_MODULE_NAME "ali5455"
-static struct pci_driver ali_pci_driver = {
-	.name		= ALI5455_MODULE_NAME,
-	.id_table	= ali_pci_tbl,
-	.probe		= ali_probe,
-	.remove		= __devexit_p(ali_remove),
-#ifdef CONFIG_PM
-	.suspend	= ali_pm_suspend,
-	.resume		= ali_pm_resume,
-#endif				/* CONFIG_PM */
-};
-
-static int __init ali_init_module(void)
-{
-	printk(KERN_INFO "ALI 5455 + AC97 Audio, version "
-	       DRIVER_VERSION ", " __TIME__ " " __DATE__ "\n");
-
-	if (codec_independent_spdif_locked > 0) {
-		if (codec_independent_spdif_locked == 32000
-		    || codec_independent_spdif_locked == 44100
-		    || codec_independent_spdif_locked == 48000) {
-			printk(KERN_INFO "ali_audio: Enabling S/PDIF at sample rate %dHz.\n", codec_independent_spdif_locked);
-		} else {
-			printk(KERN_INFO "ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.\n");
-			codec_independent_spdif_locked = 0;
-		}
-	}
-	if (controller_independent_spdif_locked > 0) {
-		if (controller_independent_spdif_locked == 32000
-		    || controller_independent_spdif_locked == 44100
-		    || controller_independent_spdif_locked == 48000) {
-			printk(KERN_INFO "ali_audio: Enabling S/PDIF at sample rate %dHz.\n", controller_independent_spdif_locked);
-		} else {
-			printk(KERN_INFO "ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.\n");
-			controller_independent_spdif_locked = 0;
-		}
-	}
-
-	if (codec_pcmout_share_spdif_locked > 0) {
-		if (codec_pcmout_share_spdif_locked == 32000
-		    || codec_pcmout_share_spdif_locked == 44100
-		    || codec_pcmout_share_spdif_locked == 48000) {
-			printk(KERN_INFO "ali_audio: Enabling S/PDIF at sample rate %dHz.\n", codec_pcmout_share_spdif_locked);
-		} else {
-			printk(KERN_INFO "ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.\n");
-			codec_pcmout_share_spdif_locked = 0;
-		}
-	}
-	if (controller_pcmout_share_spdif_locked > 0) {
-		if (controller_pcmout_share_spdif_locked == 32000
-		    || controller_pcmout_share_spdif_locked == 44100
-		    || controller_pcmout_share_spdif_locked == 48000) {
-			printk(KERN_INFO "ali_audio: Enabling controller S/PDIF at sample rate %dHz.\n", controller_pcmout_share_spdif_locked);
-		} else {
-			printk(KERN_INFO "ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.\n");
-			controller_pcmout_share_spdif_locked = 0;
-		}
-	}
-	return pci_register_driver(&ali_pci_driver);
-}
-
-static void __exit ali_cleanup_module(void)
-{
-	pci_unregister_driver(&ali_pci_driver);
-}
-
-module_init(ali_init_module);
-module_exit(ali_cleanup_module);
-/*
-Local Variables:
-c-basic-offset: 8
-End:
-*/
--- linux-2.6.18.noarch/sound/oss/i810_audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/i810_audio.c	2007-06-05 17:44:14.000000000 -0400
@@ -101,6 +101,7 @@
 #include <linux/ac97_codec.h>
 #include <linux/bitops.h>
 #include <linux/mutex.h>
+#include <linux/mm.h>
 
 #include <asm/uaccess.h>
 
@@ -1523,9 +1524,9 @@
 #endif
 }
 
-static irqreturn_t i810_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t i810_interrupt(int irq, void *dev_id)
 {
-	struct i810_card *card = (struct i810_card *)dev_id;
+	struct i810_card *card = dev_id;
 	u32 status;
 
 	spin_lock(&card->lock);
@@ -2579,10 +2580,9 @@
 		for (i = 0; i < NR_HW_CH && card && !card->initializing; i++) {
 			if (card->states[i] == NULL) {
 				state = card->states[i] = (struct i810_state *)
-					kmalloc(sizeof(struct i810_state), GFP_KERNEL);
+					kzalloc(sizeof(struct i810_state), GFP_KERNEL);
 				if (state == NULL)
 					return -ENOMEM;
-				memset(state, 0, sizeof(struct i810_state));
 				dmabuf = &state->dmabuf;
 				goto found_virt;
 			}
@@ -3204,10 +3204,9 @@
 	 */
 	if(card != NULL) {
 		state = card->states[0] = (struct i810_state *)
-					kmalloc(sizeof(struct i810_state), GFP_KERNEL);
+					kzalloc(sizeof(struct i810_state), GFP_KERNEL);
 		if (state == NULL)
 			return;
-		memset(state, 0, sizeof(struct i810_state));
 		dmabuf = &state->dmabuf;
 
 		dmabuf->write_channel = card->alloc_pcm_channel(card);
@@ -3272,11 +3271,10 @@
 		return -ENODEV;
 	}
 	
-	if ((card = kmalloc(sizeof(struct i810_card), GFP_KERNEL)) == NULL) {
+	if ((card = kzalloc(sizeof(struct i810_card), GFP_KERNEL)) == NULL) {
 		printk(KERN_ERR "i810_audio: out of memory\n");
 		return -ENOMEM;
 	}
-	memset(card, 0, sizeof(*card));
 
 	card->initializing = 1;
 	card->pci_dev = pci_dev;
--- linux-2.6.18.noarch/sound/oss/swarm_cs4297a.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/swarm_cs4297a.c	2007-06-05 17:44:14.000000000 -0400
@@ -77,6 +77,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/mutex.h>
+#include <linux/kernel.h>
 
 #include <asm/byteorder.h>
 #include <asm/dma.h>
@@ -615,25 +616,23 @@
 
         /* Descriptors */
         dma->ringsz = DMA_DESCR;
-        dma->descrtab = kmalloc(dma->ringsz * sizeof(serdma_descr_t), GFP_KERNEL);
+        dma->descrtab = kzalloc(dma->ringsz * sizeof(serdma_descr_t), GFP_KERNEL);
         if (!dma->descrtab) {
-                printk(KERN_ERR "cs4297a: kmalloc descrtab failed\n");
+                printk(KERN_ERR "cs4297a: kzalloc descrtab failed\n");
                 return -1;
         }
-        memset(dma->descrtab, 0, dma->ringsz * sizeof(serdma_descr_t));
         dma->descrtab_end = dma->descrtab + dma->ringsz;
 	/* XXX bloddy mess, use proper DMA API here ...  */
 	dma->descrtab_phys = CPHYSADDR((long)dma->descrtab);
         dma->descr_add = dma->descr_rem = dma->descrtab;
 
         /* Frame buffer area */
-        dma->dma_buf = kmalloc(DMA_BUF_SIZE, GFP_KERNEL);
+        dma->dma_buf = kzalloc(DMA_BUF_SIZE, GFP_KERNEL);
         if (!dma->dma_buf) {
-                printk(KERN_ERR "cs4297a: kmalloc dma_buf failed\n");
+                printk(KERN_ERR "cs4297a: kzalloc dma_buf failed\n");
                 kfree(dma->descrtab);
                 return -1;
         }
-        memset(dma->dma_buf, 0, DMA_BUF_SIZE);
         dma->dma_buf_phys = CPHYSADDR((long)dma->dma_buf);
 
         /* Samples buffer area */
@@ -725,7 +724,7 @@
         serdma_t *d = &s->dma_dac;
         u64 *data_p;
         unsigned swptr;
-        int flags;
+        unsigned long flags;
         serdma_descr_t *descr;
 
         if (s->reg_request) {
@@ -2505,7 +2504,7 @@
 	.release	= cs4297a_release,
 };
 
-static void cs4297a_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static void cs4297a_interrupt(int irq, void *dev_id)
 {
 	struct cs4297a_state *s = (struct cs4297a_state *) dev_id;
         u32 status;
@@ -2618,12 +2617,11 @@
         udelay(100);
 #endif
 
-	if (!(s = kmalloc(sizeof(struct cs4297a_state), GFP_KERNEL))) {
+	if (!(s = kzalloc(sizeof(struct cs4297a_state), GFP_KERNEL))) {
 		CS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR
 		      "cs4297a: probe() no memory for state struct.\n"));
 		return -1;
 	}
-	memset(s, 0, sizeof(struct cs4297a_state));
         s->magic = CS4297a_MAGIC;
 	init_waitqueue_head(&s->dma_adc.wait);
 	init_waitqueue_head(&s->dma_dac.wait);
@@ -2676,7 +2674,7 @@
 #if 0
                 val = SOUND_MASK_LINE;
                 mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long) &val);
-                for (i = 0; i < sizeof(initvol) / sizeof(initvol[0]); i++) {
+                for (i = 0; i < ARRAY_SIZE(initvol); i++) {
                         val = initvol[i].vol;
                         mixer_ioctl(s, initvol[i].mixch, (unsigned long) &val);
                 }
--- linux-2.6.18.noarch/sound/oss/sh_dac_audio.c.orig	2007-06-05 16:46:39.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sh_dac_audio.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,3 +1,14 @@
+/*
+ * sound/oss/sh_dac_audio.c
+ *
+ * SH DAC based sound :(
+ *
+ *  Copyright (C) 2004,2005  Andriy Skulysh
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/sched.h>
@@ -6,18 +17,17 @@
 #include <linux/fs.h>
 #include <linux/sound.h>
 #include <linux/soundcard.h>
+#include <linux/interrupt.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/irq.h>
 #include <asm/delay.h>
-#include <linux/interrupt.h>
-
+#include <asm/clock.h>
 #include <asm/cpu/dac.h>
-
-#ifdef MACH_HP600
-#include <asm/hp6xx/hp6xx.h>
-#include <asm/hd64461/hd64461.h>
-#endif
+#include <asm/cpu/timer.h>
+#include <asm/machvec.h>
+#include <asm/hp6xx.h>
+#include <asm/hd64461.h>
 
 #define MODNAME "sh_dac_audio"
 
@@ -26,11 +36,6 @@
 #define TMU1_TCR_INIT	0x0020	/* Clock/4, rising edge; interrupt on */
 #define TMU1_TSTR_INIT  0x02	/* Bit to turn on TMU1 */
 
-#define TMU_TSTR	0xfffffe92
-#define TMU1_TCOR	0xfffffea0
-#define TMU1_TCNT	0xfffffea4
-#define TMU1_TCR	0xfffffea8
-
 #define BUFFER_SIZE 48000
 
 static int rate;
@@ -71,34 +76,37 @@
 
 static void dac_audio_start(void)
 {
-#ifdef MACH_HP600
-	u16 v;
-	v = inw(HD64461_GPADR);
-	v &= ~HD64461_GPADR_SPEAKER;
-	outw(v, HD64461_GPADR);
-#endif
+	if (mach_is_hp6xx()) {
+		u16 v = inw(HD64461_GPADR);
+		v &= ~HD64461_GPADR_SPEAKER;
+		outw(v, HD64461_GPADR);
+	}
+
 	sh_dac_enable(CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
 	ctrl_outw(TMU1_TCR_INIT, TMU1_TCR);
 }
 static void dac_audio_stop(void)
 {
-#ifdef MACH_HP600
-	u16 v;
-#endif
 	dac_audio_stop_timer();
-#ifdef MACH_HP600
-	v = inw(HD64461_GPADR);
-	v |= HD64461_GPADR_SPEAKER;
-	outw(v, HD64461_GPADR);
-#endif
+
+	if (mach_is_hp6xx()) {
+		u16 v = inw(HD64461_GPADR);
+		v |= HD64461_GPADR_SPEAKER;
+		outw(v, HD64461_GPADR);
+	}
+
+ 	sh_dac_output(0, CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
 	sh_dac_disable(CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
 }
 
 static void dac_audio_set_rate(void)
 {
 	unsigned long interval;
+ 	struct clk *clk;
 
-	interval = (current_cpu_data.module_clock / 4) / rate;
+ 	clk = clk_get("module_clk");
+ 	interval = (clk_get_rate(clk) / 4) / rate;
+ 	clk_put(clk);
 	ctrl_outl(interval, TMU1_TCOR);
 	ctrl_outl(interval, TMU1_TCNT);
 }
@@ -247,7 +255,7 @@
 	return 0;
 }
 
-struct file_operations dac_audio_fops = {
+const struct file_operations dac_audio_fops = {
       .read =		dac_audio_read,
       .write =	dac_audio_write,
       .ioctl =	dac_audio_ioctl,
@@ -255,7 +263,7 @@
       .release =	dac_audio_release,
 };
 
-static irqreturn_t timer1_interrupt(int irq, void *dev, struct pt_regs *regs)
+static irqreturn_t timer1_interrupt(int irq, void *dev)
 {
 	unsigned long timer_status;
 
--- linux-2.6.18.noarch/sound/oss/ac97.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/ac97.h	2007-06-05 17:44:14.000000000 -0400
@@ -192,9 +192,6 @@
 extern int ac97_mixer_ioctl (struct ac97_hwint *dev, unsigned int cmd,
 			     void __user * arg);
 
-/* Do a complete reset on the AC97 mixer, restoring all mixer registers to
-   the current values.  Normally used after an APM resume event.  */
-extern int ac97_reset (struct ac97_hwint *dev);
 #endif
 
 /*
--- linux-2.6.18.noarch/sound/oss/emu10k1/cardwi.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/cardwi.h	2007-06-05 17:44:33.000000000 -0400
@@ -83,7 +83,7 @@
 void emu10k1_wavein_start(struct emu10k1_wavedevice *);
 void emu10k1_wavein_stop(struct emu10k1_wavedevice *);
 void emu10k1_wavein_getxfersize(struct wiinst *, u32 *);
-void emu10k1_wavein_xferdata(struct wiinst *, u8 __user *, u32 *);
+int emu10k1_wavein_xferdata(struct wiinst *, u8 __user *, u32 *);
 int emu10k1_wavein_setformat(struct emu10k1_wavedevice *, struct wave_format *);
 void emu10k1_wavein_update(struct emu10k1_card *, struct wiinst *);
 
--- linux-2.6.18.noarch/sound/oss/emu10k1/cardwi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/cardwi.c	2007-06-05 17:44:33.000000000 -0400
@@ -304,11 +304,12 @@
 	}
 }
 
-static void copy_block(u8 __user *dst, u8 * src, u32 str, u32 len, u8 cov)
+static int copy_block(u8 __user *dst, u8 * src, u32 str, u32 len, u8 cov)
 {
-	if (cov == 1)
-		__copy_to_user(dst, src + str, len);
-	else {
+	if (cov == 1) {
+		if (__copy_to_user(dst, src + str, len))
+			return -EFAULT;
+	} else {
 		u8 byte;
 		u32 i;
 
@@ -316,22 +317,26 @@
 
 		for (i = 0; i < len; i++) {
 			byte = src[2 * i] ^ 0x80;
-			__copy_to_user(dst + i, &byte, 1);
+			if (__copy_to_user(dst + i, &byte, 1))
+				return -EFAULT;
 		}
 	}
+
+	return 0;
 }
 
-void emu10k1_wavein_xferdata(struct wiinst *wiinst, u8 __user *data, u32 * size)
+int emu10k1_wavein_xferdata(struct wiinst *wiinst, u8 __user *data, u32 * size)
 {
 	struct wavein_buffer *buffer = &wiinst->buffer;
 	u32 sizetocopy, sizetocopy_now, start;
 	unsigned long flags;
+	int ret;
 
 	sizetocopy = min_t(u32, buffer->size, *size);
 	*size = sizetocopy;
 
 	if (!sizetocopy)
-		return;
+		return 0;
 
 	spin_lock_irqsave(&wiinst->lock, flags);
 	start = buffer->pos;
@@ -345,11 +350,17 @@
 	if (sizetocopy > sizetocopy_now) {
 		sizetocopy -= sizetocopy_now;
 
-		copy_block(data, buffer->addr, start, sizetocopy_now, buffer->cov);
-		copy_block(data + sizetocopy_now, buffer->addr, 0, sizetocopy, buffer->cov);
+		ret = copy_block(data, buffer->addr, start, sizetocopy_now,
+				 buffer->cov);
+		if (ret == 0)
+			ret = copy_block(data + sizetocopy_now, buffer->addr, 0,
+					 sizetocopy, buffer->cov);
 	} else {
-		copy_block(data, buffer->addr, start, sizetocopy, buffer->cov);
+		ret = copy_block(data, buffer->addr, start, sizetocopy,
+				 buffer->cov);
 	}
+
+	return ret;
 }
 
 void emu10k1_wavein_update(struct emu10k1_card *card, struct wiinst *wiinst)
--- linux-2.6.18.noarch/sound/oss/emu10k1/mixer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/mixer.c	2007-06-05 17:44:33.000000000 -0400
@@ -194,7 +194,7 @@
 
 	case SOUND_MIXER_PRIVATE3:
 
-		ctl = (struct mixer_private_ioctl *) kmalloc(sizeof(struct mixer_private_ioctl), GFP_KERNEL);
+		ctl = kmalloc(sizeof(struct mixer_private_ioctl), GFP_KERNEL);
 		if (ctl == NULL)
 			return -ENOMEM;
 
@@ -681,7 +681,7 @@
 	return 0;
 }
 
-struct file_operations emu10k1_mixer_fops = {
+const struct file_operations emu10k1_mixer_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.ioctl		= emu10k1_mixer_ioctl,
--- linux-2.6.18.noarch/sound/oss/emu10k1/cardmi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/cardmi.c	2007-06-05 17:44:33.000000000 -0400
@@ -157,7 +157,7 @@
 	midihdr->flags |= MIDIBUF_INQUEUE;	/* set */
 	midihdr->flags &= ~MIDIBUF_DONE;	/* clear */
 
-	if ((midiq = (struct midi_queue *) kmalloc(sizeof(struct midi_queue), GFP_ATOMIC)) == NULL) {
+	if ((midiq = kmalloc(sizeof(struct midi_queue), GFP_ATOMIC)) == NULL) {
 		/* Message lost */
 		return -1;
 	}
--- linux-2.6.18.noarch/sound/oss/emu10k1/audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/audio.c	2007-06-05 17:44:33.000000000 -0400
@@ -36,6 +36,7 @@
 #include <linux/bitops.h>
 #include <asm/io.h>
 #include <linux/sched.h>
+#include <linux/mm.h>
 #include <linux/smp_lock.h>
 
 #include "hwaccess.h"
@@ -110,9 +111,15 @@
 
 		if ((bytestocopy >= wiinst->buffer.fragment_size)
 		    || (bytestocopy >= count)) {
+			int rc;
+
 			bytestocopy = min_t(u32, bytestocopy, count);
 
-			emu10k1_wavein_xferdata(wiinst, (u8 __user *)buffer, &bytestocopy);
+			rc = emu10k1_wavein_xferdata(wiinst,
+						     (u8 __user *)buffer,
+						     &bytestocopy);
+			if (rc)
+				return rc;
 
 			count -= bytestocopy;
 			buffer += bytestocopy;
@@ -1132,7 +1139,7 @@
 
 match:
 
-	wave_dev = (struct emu10k1_wavedevice *) kmalloc(sizeof(struct emu10k1_wavedevice), GFP_KERNEL);
+	wave_dev = kmalloc(sizeof(struct emu10k1_wavedevice), GFP_KERNEL);
 
 	if (wave_dev == NULL) { 
 		ERROR();
@@ -1148,7 +1155,7 @@
 		/* Recording */
 		struct wiinst *wiinst;
 
-		if ((wiinst = (struct wiinst *) kmalloc(sizeof(struct wiinst), GFP_KERNEL)) == NULL) {
+		if ((wiinst = kmalloc(sizeof(struct wiinst), GFP_KERNEL)) == NULL) {
 			ERROR();
 			kfree(wave_dev);
 			return -ENOMEM;
@@ -1204,7 +1211,7 @@
 		struct woinst *woinst;
 		int i;
 
-		if ((woinst = (struct woinst *) kmalloc(sizeof(struct woinst), GFP_KERNEL)) == NULL) {
+		if ((woinst = kmalloc(sizeof(struct woinst), GFP_KERNEL)) == NULL) {
 			ERROR();
 			kfree(wave_dev);
 			return -ENOMEM;
@@ -1575,7 +1582,7 @@
 	return;
 }
 
-struct file_operations emu10k1_audio_fops = {
+const struct file_operations emu10k1_audio_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
 	.read		= emu10k1_audio_read,
--- linux-2.6.18.noarch/sound/oss/emu10k1/passthrough.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/passthrough.c	2007-06-05 17:44:33.000000000 -0400
@@ -162,12 +162,15 @@
 
 		DPD(3, "prepend size %d, prepending %d bytes\n", pt->prepend_size, needed);
 		if (count < needed) {
-			copy_from_user(pt->buf + pt->prepend_size, buffer, count);
+			if (copy_from_user(pt->buf + pt->prepend_size,
+					   buffer, count))
+				return -EFAULT;
 			pt->prepend_size += count;
 			DPD(3, "prepend size now %d\n", pt->prepend_size);
 			return count;
 		}
-		copy_from_user(pt->buf + pt->prepend_size, buffer, needed);
+		if (copy_from_user(pt->buf + pt->prepend_size, buffer, needed))
+			return -EFAULT;
 		r = pt_putblock(wave_dev, (u16 *) pt->buf, nonblock);
 		if (r)
 			return r;
@@ -178,7 +181,8 @@
 	blocks_copied = 0;
 	while (blocks > 0) {
 		u16 __user *bufptr = (u16 __user *) buffer + (bytes_copied/2);
-		copy_from_user(pt->buf, bufptr, PT_BLOCKSIZE);
+		if (copy_from_user(pt->buf, bufptr, PT_BLOCKSIZE))
+			return -EFAULT;
 		r = pt_putblock(wave_dev, (u16 *)pt->buf, nonblock);
 		if (r) {
 			if (bytes_copied)
@@ -193,7 +197,8 @@
 	i = count - bytes_copied;
 	if (i) {
 		pt->prepend_size = i;
-		copy_from_user(pt->buf, buffer + bytes_copied, i);
+		if (copy_from_user(pt->buf, buffer + bytes_copied, i))
+			return -EFAULT;
 		bytes_copied += i;
 		DPD(3, "filling prepend buffer with %d bytes", i);
 	}
--- linux-2.6.18.noarch/sound/oss/emu10k1/irqmgr.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/irqmgr.c	2007-06-05 17:44:33.000000000 -0400
@@ -37,7 +37,7 @@
 
 /* Interrupt handler */
 
-irqreturn_t emu10k1_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t emu10k1_interrupt(int irq, void *dev_id)
 {
 	struct emu10k1_card *card = (struct emu10k1_card *) dev_id;
 	u32 irqstatus, irqstatus_tmp;
--- linux-2.6.18.noarch/sound/oss/emu10k1/cardmo.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/cardmo.c	2007-06-05 17:44:33.000000000 -0400
@@ -117,7 +117,7 @@
 	midihdr->flags |= MIDIBUF_INQUEUE;
 	midihdr->flags &= ~MIDIBUF_DONE;
 
-	if ((midiq = (struct midi_queue *) kmalloc(sizeof(struct midi_queue), GFP_KERNEL)) == NULL) {
+	if ((midiq = kmalloc(sizeof(struct midi_queue), GFP_KERNEL)) == NULL) {
 		/* Message lost */
 		return -1;
 	}
--- linux-2.6.18.noarch/sound/oss/emu10k1/main.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/main.c	2007-06-05 17:44:33.000000000 -0400
@@ -167,7 +167,7 @@
 static struct midi_operations emu10k1_midi_operations;
 #endif
 
-extern irqreturn_t emu10k1_interrupt(int, void *, struct pt_regs *s);
+extern irqreturn_t emu10k1_interrupt(int, void *);
 
 static int __devinit emu10k1_audio_init(struct emu10k1_card *card)
 {
@@ -455,15 +455,13 @@
 {
 	int ret;
 
-	card->mpuout = kmalloc(sizeof(struct emu10k1_mpuout), GFP_KERNEL);
+	card->mpuout = kzalloc(sizeof(struct emu10k1_mpuout), GFP_KERNEL);
 	if (card->mpuout == NULL) {
 		printk(KERN_WARNING "emu10k1: Unable to allocate emu10k1_mpuout: out of memory\n");
 		ret = -ENOMEM;
 		goto err_out1;
 	}
 
-	memset(card->mpuout, 0, sizeof(struct emu10k1_mpuout));
-
 	card->mpuout->intr = 1;
 	card->mpuout->status = FLAGS_AVAILABLE;
 	card->mpuout->state = CARDMIDIOUT_STATE_DEFAULT;
@@ -472,15 +470,13 @@
 
 	spin_lock_init(&card->mpuout->lock);
 
-	card->mpuin = kmalloc(sizeof(struct emu10k1_mpuin), GFP_KERNEL);
+	card->mpuin = kzalloc(sizeof(struct emu10k1_mpuin), GFP_KERNEL);
 	if (card->mpuin == NULL) {
 		printk(KERN_WARNING "emu10k1: Unable to allocate emu10k1_mpuin: out of memory\n");
 		ret = -ENOMEM;
                 goto err_out2;
 	}
 
-	memset(card->mpuin, 0, sizeof(struct emu10k1_mpuin));
-
 	card->mpuin->status = FLAGS_AVAILABLE;
 
 	tasklet_init(&card->mpuin->tasklet, emu10k1_mpuin_bh, (unsigned long) card->mpuin);
@@ -1280,11 +1276,10 @@
 
 	pci_set_master(pci_dev);
 
-	if ((card = kmalloc(sizeof(struct emu10k1_card), GFP_KERNEL)) == NULL) {
+	if ((card = kzalloc(sizeof(struct emu10k1_card), GFP_KERNEL)) == NULL) {
                 printk(KERN_ERR "emu10k1: out of memory\n");
                 return -ENOMEM;
         }
-        memset(card, 0, sizeof(struct emu10k1_card));
 
 	card->iobase = pci_resource_start(pci_dev, 0);
 	card->length = pci_resource_len(pci_dev, 0); 
--- linux-2.6.18.noarch/sound/oss/emu10k1/midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/emu10k1/midi.c	2007-06-05 17:44:33.000000000 -0400
@@ -58,7 +58,7 @@
 {
 	struct midi_hdr *midihdr;
 
-	if ((midihdr = (struct midi_hdr *) kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL) {
+	if ((midihdr = kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL) {
 		ERROR();
 		return -EINVAL;
 	}
@@ -128,7 +128,7 @@
 		mutex_lock(&card->open_sem);
 	}
 
-	if ((midi_dev = (struct emu10k1_mididevice *) kmalloc(sizeof(*midi_dev), GFP_KERNEL)) == NULL)
+	if ((midi_dev = kmalloc(sizeof(*midi_dev), GFP_KERNEL)) == NULL)
 		return -EINVAL;
 
 	midi_dev->card = card;
@@ -328,7 +328,7 @@
 	if (!access_ok(VERIFY_READ, buffer, count))
 		return -EFAULT;
 
-	if ((midihdr = (struct midi_hdr *) kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL)
+	if ((midihdr = kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL)
 		return -EINVAL;
 
 	midihdr->bufferlength = count;
@@ -458,7 +458,7 @@
 }
 
 /* MIDI file operations */
-struct file_operations emu10k1_midi_fops = {
+const struct file_operations emu10k1_midi_fops = {
 	.owner		= THIS_MODULE,
 	.read		= emu10k1_midi_read,
 	.write		= emu10k1_midi_write,
@@ -490,7 +490,7 @@
 			
 	DPF(2, "emu10k1_seq_midi_open()\n");
 	
-	if ((midi_dev = (struct emu10k1_mididevice *) kmalloc(sizeof(*midi_dev), GFP_KERNEL)) == NULL)
+	if ((midi_dev = kmalloc(sizeof(*midi_dev), GFP_KERNEL)) == NULL)
 		return -EINVAL;
 
 	midi_dev->card = card;
@@ -540,7 +540,7 @@
 
 	card = midi_devs[dev]->devc;
 
-	if ((midihdr = (struct midi_hdr *) kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL)
+	if ((midihdr = kmalloc(sizeof(struct midi_hdr), GFP_KERNEL)) == NULL)
 		return -EINVAL;
 
 	midihdr->bufferlength = 1;
--- linux-2.6.18.noarch/sound/oss/es1370.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/es1370.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,2819 +0,0 @@
-/*****************************************************************************/
-
-/*
- *      es1370.c  --  Ensoniq ES1370/Asahi Kasei AK4531 audio driver.
- *
- *      Copyright (C) 1998-2001, 2003  Thomas Sailer (t.sailer@alumni.ethz.ch)
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Special thanks to David C. Niemi
- *
- *
- * Module command line parameters:
- *   lineout  if 1 the LINE jack is used as an output instead of an input.
- *            LINE then contains the unmixed dsp output. This can be used
- *            to make the card a four channel one: use dsp to output two
- *            channels to LINE and dac to output the other two channels to
- *            SPKR. Set the mixer to only output synth to SPKR.
- *   micbias  sets the +5V bias to the mic if using an electretmic.
- *            
- *
- *  Note: sync mode is not yet supported (i.e. running dsp and dac from the same
- *  clock source)
- *
- *  Supported devices:
- *  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible
- *  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible
- *  /dev/dsp1   additional DAC, like /dev/dsp, but output only,
- *              only 5512, 11025, 22050 and 44100 samples/s,
- *              outputs to mixer "SYNTH" setting
- *  /dev/midi   simple MIDI UART interface, no ioctl
- *
- *  NOTE: the card does not have any FM/Wavetable synthesizer, it is supposed
- *  to be done in software. That is what /dev/dac is for. By now (Q2 1998)
- *  there are several MIDI to PCM (WAV) packages, one of them is timidity.
- *
- *  Revision history
- *    26.03.1998   0.1   Initial release
- *    31.03.1998   0.2   Fix bug in GETOSPACE
- *    04.04.1998   0.3   Make it work (again) under 2.0.33
- *                       Fix mixer write operation not returning the actual
- *                       settings
- *    05.04.1998   0.4   First attempt at using the new PCI stuff
- *    29.04.1998   0.5   Fix hang when ^C is pressed on amp
- *    07.05.1998   0.6   Don't double lock around stop_*() in *_release()
- *    10.05.1998   0.7   First stab at a simple midi interface (no bells&whistles)
- *    14.05.1998   0.8   Don't allow excessive interrupt rates
- *    08.06.1998   0.9   First release using Alan Cox' soundcore instead of
- *                       miscdevice
- *    05.07.1998   0.10  Fixed the driver to correctly maintin OSS style volume
- *                       settings (not sure if this should be standard)
- *                       Fixed many references: f_flags should be f_mode
- *                       -- Gerald Britton <gbritton@mit.edu>
- *    03.08.1998   0.11  Now mixer behaviour can basically be selected between
- *                       "OSS documented" and "OSS actual" behaviour
- *                       Fixed mixer table thanks to Hakan.Lennestal@lu.erisoft.se
- *                       On module startup, set DAC2 to 11kSPS instead of 5.5kSPS,
- *                       as it produces an annoying ssssh in the lower sampling rate
- *                       Do not include modversions.h
- *    22.08.1998   0.12  Mixer registers actually have 5 instead of 4 bits
- *                       pointed out by Itai Nahshon
- *    31.08.1998   0.13  Fix realplayer problems - dac.count issues
- *    08.10.1998   0.14  Joystick support fixed
- *		         -- Oliver Neukum <c188@org.chemie.uni-muenchen.de>
- *    10.12.1998   0.15  Fix drain_dac trying to wait on not yet initialized DMA
- *    16.12.1998   0.16  Don't wake up app until there are fragsize bytes to read/write
- *    06.01.1999   0.17  remove the silly SA_INTERRUPT flag.
- *                       hopefully killed the egcs section type conflict
- *    12.03.1999   0.18  cinfo.blocks should be reset after GETxPTR ioctl.
- *                       reported by Johan Maes <joma@telindus.be>
- *    22.03.1999   0.19  return EAGAIN instead of EBUSY when O_NONBLOCK
- *                       read/write cannot be executed
- *    07.04.1999   0.20  implemented the following ioctl's: SOUND_PCM_READ_RATE, 
- *                       SOUND_PCM_READ_CHANNELS, SOUND_PCM_READ_BITS; 
- *                       Alpha fixes reported by Peter Jones <pjones@redhat.com>
- *                       Note: joystick address handling might still be wrong on archs
- *                       other than i386
- *    10.05.1999   0.21  Added support for an electret mic for SB PCI64
- *                       to the Linux kernel sound driver. This mod also straighten
- *                       out the question marks around the mic impedance setting
- *                       (micz). From Kim.Berts@fisub.mail.abb.com
- *    11.05.1999   0.22  Implemented the IMIX call to mute recording monitor.
- *                       Guenter Geiger <geiger@epy.co.at>
- *    15.06.1999   0.23  Fix bad allocation bug.
- *                       Thanks to Deti Fliegl <fliegl@in.tum.de>
- *    28.06.1999   0.24  Add pci_set_master
- *    02.08.1999   0.25  Added workaround for the "phantom write" bug first
- *                       documented by Dave Sharpless from Anchor Games
- *    03.08.1999   0.26  adapt to Linus' new __setup/__initcall
- *                       added kernel command line option "es1370=joystick[,lineout[,micbias]]"
- *                       removed CONFIG_SOUND_ES1370_JOYPORT_BOOT kludge
- *    12.08.1999   0.27  module_init/__setup fixes
- *    19.08.1999   0.28  SOUND_MIXER_IMIX fixes, reported by Gianluca <gialluca@mail.tiscalinet.it>
- *    31.08.1999   0.29  add spin_lock_init
- *                       replaced current->state = x with set_current_state(x)
- *    03.09.1999   0.30  change read semantics for MIDI to match
- *                       OSS more closely; remove possible wakeup race
- *    28.10.1999   0.31  More waitqueue races fixed
- *    08.01.2000   0.32  Prevent some ioctl's from returning bad count values on underrun/overrun;
- *                       Tim Janik's BSE (Bedevilled Sound Engine) found this
- *    07.02.2000   0.33  Use pci_alloc_consistent and pci_register_driver
- *    21.11.2000   0.34  Initialize dma buffers in poll, otherwise poll may return a bogus mask
- *    12.12.2000   0.35  More dma buffer initializations, patch from
- *                       Tjeerd Mulder <tjeerd.mulder@fujitsu-siemens.com>
- *    07.01.2001   0.36  Timeout change in wrcodec as requested by Frank Klemm <pfk@fuchs.offl.uni-jena.de>
- *    31.01.2001   0.37  Register/Unregister gameport
- *                       Fix SETTRIGGER non OSS API conformity
- *    03.01.2003   0.38  open_mode fixes from Georg Acher <acher@in.tum.de>
- *
- * some important things missing in Ensoniq documentation:
- *
- * Experimental PCLKDIV results:  play the same waveforms on both DAC1 and DAC2
- * and vary PCLKDIV to obtain zero beat.
- *  5512sps:  254
- * 44100sps:   30
- * seems to be fs = 1411200/(PCLKDIV+2)
- *
- * should find out when curr_sample_ct is cleared and
- * where exactly the CCB fetches data
- *
- * The card uses a 22.5792 MHz crystal.
- * The LINEIN jack may be converted to an AOUT jack by
- * setting pin 47 (XCTL0) of the ES1370 to high.
- * Pin 48 (XCTL1) of the ES1370 sets the +5V bias for an electretmic
- * 
- *
- */
-
-/*****************************************************************************/
-      
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/sound.h>
-#include <linux/slab.h>
-#include <linux/soundcard.h>
-#include <linux/pci.h>
-#include <linux/smp_lock.h>
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/spinlock.h>
-#include <linux/gameport.h>
-#include <linux/wait.h>
-#include <linux/dma-mapping.h>
-#include <linux/mutex.h>
-
-#include <asm/io.h>
-#include <asm/page.h>
-#include <asm/uaccess.h>
-
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
-#define SUPPORT_JOYSTICK
-#endif
-
-/* --------------------------------------------------------------------- */
-
-#undef OSS_DOCUMENTED_MIXER_SEMANTICS
-#define DBG(x) {}
-/*#define DBG(x) {x}*/
-
-/* --------------------------------------------------------------------- */
-
-#ifndef PCI_VENDOR_ID_ENSONIQ
-#define PCI_VENDOR_ID_ENSONIQ        0x1274    
-#endif
-
-#ifndef PCI_DEVICE_ID_ENSONIQ_ES1370
-#define PCI_DEVICE_ID_ENSONIQ_ES1370 0x5000
-#endif
-
-#define ES1370_MAGIC  ((PCI_VENDOR_ID_ENSONIQ<<16)|PCI_DEVICE_ID_ENSONIQ_ES1370)
-
-#define ES1370_EXTENT             0x40
-#define JOY_EXTENT                8
-
-#define ES1370_REG_CONTROL        0x00
-#define ES1370_REG_STATUS         0x04
-#define ES1370_REG_UART_DATA      0x08
-#define ES1370_REG_UART_STATUS    0x09
-#define ES1370_REG_UART_CONTROL   0x09
-#define ES1370_REG_UART_TEST      0x0a
-#define ES1370_REG_MEMPAGE        0x0c
-#define ES1370_REG_CODEC          0x10
-#define ES1370_REG_SERIAL_CONTROL 0x20
-#define ES1370_REG_DAC1_SCOUNT    0x24
-#define ES1370_REG_DAC2_SCOUNT    0x28
-#define ES1370_REG_ADC_SCOUNT     0x2c
-
-#define ES1370_REG_DAC1_FRAMEADR    0xc30
-#define ES1370_REG_DAC1_FRAMECNT    0xc34
-#define ES1370_REG_DAC2_FRAMEADR    0xc38
-#define ES1370_REG_DAC2_FRAMECNT    0xc3c
-#define ES1370_REG_ADC_FRAMEADR     0xd30
-#define ES1370_REG_ADC_FRAMECNT     0xd34
-#define ES1370_REG_PHANTOM_FRAMEADR 0xd38
-#define ES1370_REG_PHANTOM_FRAMECNT 0xd3c
-
-#define ES1370_FMT_U8_MONO     0
-#define ES1370_FMT_U8_STEREO   1
-#define ES1370_FMT_S16_MONO    2
-#define ES1370_FMT_S16_STEREO  3
-#define ES1370_FMT_STEREO      1
-#define ES1370_FMT_S16         2
-#define ES1370_FMT_MASK        3
-
-static const unsigned sample_size[] = { 1, 2, 2, 4 };
-static const unsigned sample_shift[] = { 0, 1, 1, 2 };
-
-static const unsigned dac1_samplerate[] = { 5512, 11025, 22050, 44100 };
-
-#define DAC2_SRTODIV(x) (((1411200+(x)/2)/(x))-2)
-#define DAC2_DIVTOSR(x) (1411200/((x)+2))
-
-#define CTRL_ADC_STOP   0x80000000  /* 1 = ADC stopped */
-#define CTRL_XCTL1      0x40000000  /* electret mic bias */
-#define CTRL_OPEN       0x20000000  /* no function, can be read and written */
-#define CTRL_PCLKDIV    0x1fff0000  /* ADC/DAC2 clock divider */
-#define CTRL_SH_PCLKDIV 16
-#define CTRL_MSFMTSEL   0x00008000  /* MPEG serial data fmt: 0 = Sony, 1 = I2S */
-#define CTRL_M_SBB      0x00004000  /* DAC2 clock: 0 = PCLKDIV, 1 = MPEG */
-#define CTRL_WTSRSEL    0x00003000  /* DAC1 clock freq: 0=5512, 1=11025, 2=22050, 3=44100 */
-#define CTRL_SH_WTSRSEL 12
-#define CTRL_DAC_SYNC   0x00000800  /* 1 = DAC2 runs off DAC1 clock */
-#define CTRL_CCB_INTRM  0x00000400  /* 1 = CCB "voice" ints enabled */
-#define CTRL_M_CB       0x00000200  /* recording source: 0 = ADC, 1 = MPEG */
-#define CTRL_XCTL0      0x00000100  /* 0 = Line in, 1 = Line out */
-#define CTRL_BREQ       0x00000080  /* 1 = test mode (internal mem test) */
-#define CTRL_DAC1_EN    0x00000040  /* enable DAC1 */
-#define CTRL_DAC2_EN    0x00000020  /* enable DAC2 */
-#define CTRL_ADC_EN     0x00000010  /* enable ADC */
-#define CTRL_UART_EN    0x00000008  /* enable MIDI uart */
-#define CTRL_JYSTK_EN   0x00000004  /* enable Joystick port (presumably at address 0x200) */
-#define CTRL_CDC_EN     0x00000002  /* enable serial (CODEC) interface */
-#define CTRL_SERR_DIS   0x00000001  /* 1 = disable PCI SERR signal */
-
-#define STAT_INTR       0x80000000  /* wired or of all interrupt bits */
-#define STAT_CSTAT      0x00000400  /* 1 = codec busy or codec write in progress */
-#define STAT_CBUSY      0x00000200  /* 1 = codec busy */
-#define STAT_CWRIP      0x00000100  /* 1 = codec write in progress */
-#define STAT_VC         0x00000060  /* CCB int source, 0=DAC1, 1=DAC2, 2=ADC, 3=undef */
-#define STAT_SH_VC      5
-#define STAT_MCCB       0x00000010  /* CCB int pending */
-#define STAT_UART       0x00000008  /* UART int pending */
-#define STAT_DAC1       0x00000004  /* DAC1 int pending */
-#define STAT_DAC2       0x00000002  /* DAC2 int pending */
-#define STAT_ADC        0x00000001  /* ADC int pending */
-
-#define USTAT_RXINT     0x80        /* UART rx int pending */
-#define USTAT_TXINT     0x04        /* UART tx int pending */
-#define USTAT_TXRDY     0x02        /* UART tx ready */
-#define USTAT_RXRDY     0x01        /* UART rx ready */
-
-#define UCTRL_RXINTEN   0x80        /* 1 = enable RX ints */
-#define UCTRL_TXINTEN   0x60        /* TX int enable field mask */
-#define UCTRL_ENA_TXINT 0x20        /* enable TX int */
-#define UCTRL_CNTRL     0x03        /* control field */
-#define UCTRL_CNTRL_SWR 0x03        /* software reset command */
-
-#define SCTRL_P2ENDINC    0x00380000  /*  */
-#define SCTRL_SH_P2ENDINC 19
-#define SCTRL_P2STINC     0x00070000  /*  */
-#define SCTRL_SH_P2STINC  16
-#define SCTRL_R1LOOPSEL   0x00008000  /* 0 = loop mode */
-#define SCTRL_P2LOOPSEL   0x00004000  /* 0 = loop mode */
-#define SCTRL_P1LOOPSEL   0x00002000  /* 0 = loop mode */
-#define SCTRL_P2PAUSE     0x00001000  /* 1 = pause mode */
-#define SCTRL_P1PAUSE     0x00000800  /* 1 = pause mode */
-#define SCTRL_R1INTEN     0x00000400  /* enable interrupt */
-#define SCTRL_P2INTEN     0x00000200  /* enable interrupt */
-#define SCTRL_P1INTEN     0x00000100  /* enable interrupt */
-#define SCTRL_P1SCTRLD    0x00000080  /* reload sample count register for DAC1 */
-#define SCTRL_P2DACSEN    0x00000040  /* 1 = DAC2 play back last sample when disabled */
-#define SCTRL_R1SEB       0x00000020  /* 1 = 16bit */
-#define SCTRL_R1SMB       0x00000010  /* 1 = stereo */
-#define SCTRL_R1FMT       0x00000030  /* format mask */
-#define SCTRL_SH_R1FMT    4
-#define SCTRL_P2SEB       0x00000008  /* 1 = 16bit */
-#define SCTRL_P2SMB       0x00000004  /* 1 = stereo */
-#define SCTRL_P2FMT       0x0000000c  /* format mask */
-#define SCTRL_SH_P2FMT    2
-#define SCTRL_P1SEB       0x00000002  /* 1 = 16bit */
-#define SCTRL_P1SMB       0x00000001  /* 1 = stereo */
-#define SCTRL_P1FMT       0x00000003  /* format mask */
-#define SCTRL_SH_P1FMT    0
-
-/* misc stuff */
-
-#define FMODE_DAC         4           /* slight misuse of mode_t */
-
-/* MIDI buffer sizes */
-
-#define MIDIINBUF  256
-#define MIDIOUTBUF 256
-
-#define FMODE_MIDI_SHIFT 3
-#define FMODE_MIDI_READ  (FMODE_READ << FMODE_MIDI_SHIFT)
-#define FMODE_MIDI_WRITE (FMODE_WRITE << FMODE_MIDI_SHIFT)
-
-/* --------------------------------------------------------------------- */
-
-struct es1370_state {
-	/* magic */
-	unsigned int magic;
-
-	/* list of es1370 devices */
-	struct list_head devs;
-
-	/* the corresponding pci_dev structure */
-	struct pci_dev *dev;
-
-	/* soundcore stuff */
-	int dev_audio;
-	int dev_mixer;
-	int dev_dac;
-	int dev_midi;
-	
-	/* hardware resources */
-	unsigned long io; /* long for SPARC */
-	unsigned int irq;
-
-	/* mixer registers; there is no HW readback */
-	struct {
-		unsigned short vol[10];
-		unsigned int recsrc;
-		unsigned int modcnt;
-		unsigned short micpreamp;
-	        unsigned int imix;
-	} mix;
-
-	/* wave stuff */
-	unsigned ctrl;
-	unsigned sctrl;
-
-	spinlock_t lock;
-	struct mutex open_mutex;
-	mode_t open_mode;
-	wait_queue_head_t open_wait;
-
-	struct dmabuf {
-		void *rawbuf;
-		dma_addr_t dmaaddr;
-		unsigned buforder;
-		unsigned numfrag;
-		unsigned fragshift;
-		unsigned hwptr, swptr;
-		unsigned total_bytes;
-		int count;
-		unsigned error; /* over/underrun */
-		wait_queue_head_t wait;
-		/* redundant, but makes calculations easier */
-		unsigned fragsize;
-		unsigned dmasize;
-		unsigned fragsamples;
-		/* OSS stuff */
-		unsigned mapped:1;
-		unsigned ready:1;
-		unsigned endcleared:1;
-		unsigned enabled:1;
-		unsigned ossfragshift;
-		int ossmaxfrags;
-		unsigned subdivision;
-	} dma_dac1, dma_dac2, dma_adc;
-
-	/* The following buffer is used to point the phantom write channel to. */
-	unsigned char *bugbuf_cpu;
-	dma_addr_t bugbuf_dma;
-
-	/* midi stuff */
-	struct {
-		unsigned ird, iwr, icnt;
-		unsigned ord, owr, ocnt;
-		wait_queue_head_t iwait;
-		wait_queue_head_t owait;
-		unsigned char ibuf[MIDIINBUF];
-		unsigned char obuf[MIDIOUTBUF];
-	} midi;
-
-#ifdef SUPPORT_JOYSTICK
-	struct gameport *gameport;
-#endif
-
-	struct mutex mutex;
-};
-
-/* --------------------------------------------------------------------- */
-
-static LIST_HEAD(devs);
-
-/* --------------------------------------------------------------------- */
-
-static inline unsigned ld2(unsigned int x)
-{
-	unsigned r = 0;
-	
-	if (x >= 0x10000) {
-		x >>= 16;
-		r += 16;
-	}
-	if (x >= 0x100) {
-		x >>= 8;
-		r += 8;
-	}
-	if (x >= 0x10) {
-		x >>= 4;
-		r += 4;
-	}
-	if (x >= 4) {
-		x >>= 2;
-		r += 2;
-	}
-	if (x >= 2)
-		r++;
-	return r;
-}
-
-/* --------------------------------------------------------------------- */
-
-static void wrcodec(struct es1370_state *s, unsigned char idx, unsigned char data)
-{
-	unsigned long tmo = jiffies + HZ/10, j;
-	
-	do {
-		j = jiffies;
-		if (!(inl(s->io+ES1370_REG_STATUS) & STAT_CSTAT)) {
-			outw((((unsigned short)idx)<<8)|data, s->io+ES1370_REG_CODEC);
-			return;
-		}
-		schedule();
-	} while ((signed)(tmo-j) > 0);
-	printk(KERN_ERR "es1370: write to codec register timeout\n");
-}
-
-/* --------------------------------------------------------------------- */
-
-static inline void stop_adc(struct es1370_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->ctrl &= ~CTRL_ADC_EN;
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static inline void stop_dac1(struct es1370_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->ctrl &= ~CTRL_DAC1_EN;
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static inline void stop_dac2(struct es1370_state *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&s->lock, flags);
-	s->ctrl &= ~CTRL_DAC2_EN;
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_dac1(struct es1370_state *s)
-{
-	unsigned long flags;
-	unsigned fragremain, fshift;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->ctrl & CTRL_DAC1_EN) && (s->dma_dac1.mapped || s->dma_dac1.count > 0)
-	    && s->dma_dac1.ready) {
-		s->ctrl |= CTRL_DAC1_EN;
-		s->sctrl = (s->sctrl & ~(SCTRL_P1LOOPSEL | SCTRL_P1PAUSE | SCTRL_P1SCTRLD)) | SCTRL_P1INTEN;
-		outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-		fragremain = ((- s->dma_dac1.hwptr) & (s->dma_dac1.fragsize-1));
-		fshift = sample_shift[(s->sctrl & SCTRL_P1FMT) >> SCTRL_SH_P1FMT];
-		if (fragremain < 2*fshift)
-			fragremain = s->dma_dac1.fragsize;
-		outl((fragremain >> fshift) - 1, s->io+ES1370_REG_DAC1_SCOUNT);
-		outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-		outl((s->dma_dac1.fragsize >> fshift) - 1, s->io+ES1370_REG_DAC1_SCOUNT);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_dac2(struct es1370_state *s)
-{
-	unsigned long flags;
-	unsigned fragremain, fshift;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->ctrl & CTRL_DAC2_EN) && (s->dma_dac2.mapped || s->dma_dac2.count > 0)
-	    && s->dma_dac2.ready) {
-		s->ctrl |= CTRL_DAC2_EN;
-		s->sctrl = (s->sctrl & ~(SCTRL_P2LOOPSEL | SCTRL_P2PAUSE | SCTRL_P2DACSEN | 
-					 SCTRL_P2ENDINC | SCTRL_P2STINC)) | SCTRL_P2INTEN |
-			(((s->sctrl & SCTRL_P2FMT) ? 2 : 1) << SCTRL_SH_P2ENDINC) | 
-			(0 << SCTRL_SH_P2STINC);
-		outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-		fragremain = ((- s->dma_dac2.hwptr) & (s->dma_dac2.fragsize-1));
-		fshift = sample_shift[(s->sctrl & SCTRL_P2FMT) >> SCTRL_SH_P2FMT];
-		if (fragremain < 2*fshift)
-			fragremain = s->dma_dac2.fragsize;
-		outl((fragremain >> fshift) - 1, s->io+ES1370_REG_DAC2_SCOUNT);
-		outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-		outl((s->dma_dac2.fragsize >> fshift) - 1, s->io+ES1370_REG_DAC2_SCOUNT);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-static void start_adc(struct es1370_state *s)
-{
-	unsigned long flags;
-	unsigned fragremain, fshift;
-
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->ctrl & CTRL_ADC_EN) && (s->dma_adc.mapped || s->dma_adc.count < (signed)(s->dma_adc.dmasize - 2*s->dma_adc.fragsize))
-	    && s->dma_adc.ready) {
-		s->ctrl |= CTRL_ADC_EN;
-		s->sctrl = (s->sctrl & ~SCTRL_R1LOOPSEL) | SCTRL_R1INTEN;
-		outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-		fragremain = ((- s->dma_adc.hwptr) & (s->dma_adc.fragsize-1));
-		fshift = sample_shift[(s->sctrl & SCTRL_R1FMT) >> SCTRL_SH_R1FMT];
-		if (fragremain < 2*fshift)
-			fragremain = s->dma_adc.fragsize;
-		outl((fragremain >> fshift) - 1, s->io+ES1370_REG_ADC_SCOUNT);
-		outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-		outl((s->dma_adc.fragsize >> fshift) - 1, s->io+ES1370_REG_ADC_SCOUNT);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-}	
-
-/* --------------------------------------------------------------------- */
-
-#define DMABUF_DEFAULTORDER (17-PAGE_SHIFT)
-#define DMABUF_MINORDER 1
-
-static inline void dealloc_dmabuf(struct es1370_state *s, struct dmabuf *db)
-{
-	struct page *page, *pend;
-
-	if (db->rawbuf) {
-		/* undo marking the pages as reserved */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			ClearPageReserved(page);
-		pci_free_consistent(s->dev, PAGE_SIZE << db->buforder, db->rawbuf, db->dmaaddr);
-	}
-	db->rawbuf = NULL;
-	db->mapped = db->ready = 0;
-}
-
-static int prog_dmabuf(struct es1370_state *s, struct dmabuf *db, unsigned rate, unsigned fmt, unsigned reg)
-{
-	int order;
-	unsigned bytepersec;
-	unsigned bufs;
-	struct page *page, *pend;
-
-	db->hwptr = db->swptr = db->total_bytes = db->count = db->error = db->endcleared = 0;
-	if (!db->rawbuf) {
-		db->ready = db->mapped = 0;
-		for (order = DMABUF_DEFAULTORDER; order >= DMABUF_MINORDER; order--)
-			if ((db->rawbuf = pci_alloc_consistent(s->dev, PAGE_SIZE << order, &db->dmaaddr)))
-				break;
-		if (!db->rawbuf)
-			return -ENOMEM;
-		db->buforder = order;
-		/* now mark the pages as reserved; otherwise remap_pfn_range doesn't do what we want */
-		pend = virt_to_page(db->rawbuf + (PAGE_SIZE << db->buforder) - 1);
-		for (page = virt_to_page(db->rawbuf); page <= pend; page++)
-			SetPageReserved(page);
-	}
-	fmt &= ES1370_FMT_MASK;
-	bytepersec = rate << sample_shift[fmt];
-	bufs = PAGE_SIZE << db->buforder;
-	if (db->ossfragshift) {
-		if ((1000 << db->ossfragshift) < bytepersec)
-			db->fragshift = ld2(bytepersec/1000);
-		else
-			db->fragshift = db->ossfragshift;
-	} else {
-		db->fragshift = ld2(bytepersec/100/(db->subdivision ? db->subdivision : 1));
-		if (db->fragshift < 3)
-			db->fragshift = 3;
-	}
-	db->numfrag = bufs >> db->fragshift;
-	while (db->numfrag < 4 && db->fragshift > 3) {
-		db->fragshift--;
-		db->numfrag = bufs >> db->fragshift;
-	}
-	db->fragsize = 1 << db->fragshift;
-	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
-		db->numfrag = db->ossmaxfrags;
-	db->fragsamples = db->fragsize >> sample_shift[fmt];
-	db->dmasize = db->numfrag << db->fragshift;
-	memset(db->rawbuf, (fmt & ES1370_FMT_S16) ? 0 : 0x80, db->dmasize);
-	outl((reg >> 8) & 15, s->io+ES1370_REG_MEMPAGE);
-	outl(db->dmaaddr, s->io+(reg & 0xff));
-	outl((db->dmasize >> 2)-1, s->io+((reg + 4) & 0xff));
-	db->enabled = 1;
-	db->ready = 1;
-	return 0;
-}
-
-static inline int prog_dmabuf_adc(struct es1370_state *s)
-{
-	stop_adc(s);
-	return prog_dmabuf(s, &s->dma_adc, DAC2_DIVTOSR((s->ctrl & CTRL_PCLKDIV) >> CTRL_SH_PCLKDIV),
-			   (s->sctrl >> SCTRL_SH_R1FMT) & ES1370_FMT_MASK, ES1370_REG_ADC_FRAMEADR);
-}
-
-static inline int prog_dmabuf_dac2(struct es1370_state *s)
-{
-	stop_dac2(s);
-	return prog_dmabuf(s, &s->dma_dac2, DAC2_DIVTOSR((s->ctrl & CTRL_PCLKDIV) >> CTRL_SH_PCLKDIV),
-			   (s->sctrl >> SCTRL_SH_P2FMT) & ES1370_FMT_MASK, ES1370_REG_DAC2_FRAMEADR);
-}
-
-static inline int prog_dmabuf_dac1(struct es1370_state *s)
-{
-	stop_dac1(s);
-	return prog_dmabuf(s, &s->dma_dac1, dac1_samplerate[(s->ctrl & CTRL_WTSRSEL) >> CTRL_SH_WTSRSEL],
-			   (s->sctrl >> SCTRL_SH_P1FMT) & ES1370_FMT_MASK, ES1370_REG_DAC1_FRAMEADR);
-}
-
-static inline unsigned get_hwptr(struct es1370_state *s, struct dmabuf *db, unsigned reg)
-{
-	unsigned hwptr, diff;
-
-	outl((reg >> 8) & 15, s->io+ES1370_REG_MEMPAGE);
-	hwptr = (inl(s->io+(reg & 0xff)) >> 14) & 0x3fffc;
-	diff = (db->dmasize + hwptr - db->hwptr) % db->dmasize;
-	db->hwptr = hwptr;
-	return diff;
-}
-
-static inline void clear_advance(void *buf, unsigned bsize, unsigned bptr, unsigned len, unsigned char c)
-{
-	if (bptr + len > bsize) {
-		unsigned x = bsize - bptr;
-		memset(((char *)buf) + bptr, c, x);
-		bptr = 0;
-		len -= x;
-	}
-	memset(((char *)buf) + bptr, c, len);
-}
-
-/* call with spinlock held! */
-static void es1370_update_ptr(struct es1370_state *s)
-{
-	int diff;
-
-	/* update ADC pointer */
-	if (s->ctrl & CTRL_ADC_EN) {
-		diff = get_hwptr(s, &s->dma_adc, ES1370_REG_ADC_FRAMECNT);
-		s->dma_adc.total_bytes += diff;
-		s->dma_adc.count += diff;
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize) 
-			wake_up(&s->dma_adc.wait);
-		if (!s->dma_adc.mapped) {
-			if (s->dma_adc.count > (signed)(s->dma_adc.dmasize - ((3 * s->dma_adc.fragsize) >> 1))) {
-				s->ctrl &= ~CTRL_ADC_EN;
-				outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-				s->dma_adc.error++;
-			}
-		}
-	}
-	/* update DAC1 pointer */
-	if (s->ctrl & CTRL_DAC1_EN) {
-		diff = get_hwptr(s, &s->dma_dac1, ES1370_REG_DAC1_FRAMECNT);
-		s->dma_dac1.total_bytes += diff;
-		if (s->dma_dac1.mapped) {
-			s->dma_dac1.count += diff;
-			if (s->dma_dac1.count >= (signed)s->dma_dac1.fragsize)
-				wake_up(&s->dma_dac1.wait);
-		} else {
-			s->dma_dac1.count -= diff;
-			if (s->dma_dac1.count <= 0) {
-				s->ctrl &= ~CTRL_DAC1_EN;
-				outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-				s->dma_dac1.error++;
-			} else if (s->dma_dac1.count <= (signed)s->dma_dac1.fragsize && !s->dma_dac1.endcleared) {
-				clear_advance(s->dma_dac1.rawbuf, s->dma_dac1.dmasize, s->dma_dac1.swptr, 
-					      s->dma_dac1.fragsize, (s->sctrl & SCTRL_P1SEB) ? 0 : 0x80);
-				s->dma_dac1.endcleared = 1;
-			}
-			if (s->dma_dac1.count + (signed)s->dma_dac1.fragsize <= (signed)s->dma_dac1.dmasize)
-				wake_up(&s->dma_dac1.wait);
-		}
-	}
-	/* update DAC2 pointer */
-	if (s->ctrl & CTRL_DAC2_EN) {
-		diff = get_hwptr(s, &s->dma_dac2, ES1370_REG_DAC2_FRAMECNT);
-		s->dma_dac2.total_bytes += diff;
-		if (s->dma_dac2.mapped) {
-			s->dma_dac2.count += diff;
-			if (s->dma_dac2.count >= (signed)s->dma_dac2.fragsize)
-				wake_up(&s->dma_dac2.wait);
-		} else {
-			s->dma_dac2.count -= diff;
-			if (s->dma_dac2.count <= 0) {
-				s->ctrl &= ~CTRL_DAC2_EN;
-				outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-				s->dma_dac2.error++;
-			} else if (s->dma_dac2.count <= (signed)s->dma_dac2.fragsize && !s->dma_dac2.endcleared) {
-				clear_advance(s->dma_dac2.rawbuf, s->dma_dac2.dmasize, s->dma_dac2.swptr, 
-					      s->dma_dac2.fragsize, (s->sctrl & SCTRL_P2SEB) ? 0 : 0x80);
-				s->dma_dac2.endcleared = 1;
-			}
-			if (s->dma_dac2.count + (signed)s->dma_dac2.fragsize <= (signed)s->dma_dac2.dmasize)
-				wake_up(&s->dma_dac2.wait);
-		}
-	}
-}
-
-/* hold spinlock for the following! */
-static void es1370_handle_midi(struct es1370_state *s)
-{
-	unsigned char ch;
-	int wake;
-
-	if (!(s->ctrl & CTRL_UART_EN))
-		return;
-	wake = 0;
-	while (inb(s->io+ES1370_REG_UART_STATUS) & USTAT_RXRDY) {
-		ch = inb(s->io+ES1370_REG_UART_DATA);
-		if (s->midi.icnt < MIDIINBUF) {
-			s->midi.ibuf[s->midi.iwr] = ch;
-			s->midi.iwr = (s->midi.iwr + 1) % MIDIINBUF;
-			s->midi.icnt++;
-		}
-		wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.iwait);
-	wake = 0;
-	while ((inb(s->io+ES1370_REG_UART_STATUS) & USTAT_TXRDY) && s->midi.ocnt > 0) {
-		outb(s->midi.obuf[s->midi.ord], s->io+ES1370_REG_UART_DATA);
-		s->midi.ord = (s->midi.ord + 1) % MIDIOUTBUF;
-		s->midi.ocnt--;
-		if (s->midi.ocnt < MIDIOUTBUF-16)
-			wake = 1;
-	}
-	if (wake)
-		wake_up(&s->midi.owait);
-	outb((s->midi.ocnt > 0) ? UCTRL_RXINTEN | UCTRL_ENA_TXINT : UCTRL_RXINTEN, s->io+ES1370_REG_UART_CONTROL);
-}
-
-static irqreturn_t es1370_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-        struct es1370_state *s = (struct es1370_state *)dev_id;
-	unsigned int intsrc, sctl;
-	
-	/* fastpath out, to ease interrupt sharing */
-	intsrc = inl(s->io+ES1370_REG_STATUS);
-	if (!(intsrc & 0x80000000))
-		return IRQ_NONE;
-	spin_lock(&s->lock);
-	/* clear audio interrupts first */
-	sctl = s->sctrl;
-	if (intsrc & STAT_ADC)
-		sctl &= ~SCTRL_R1INTEN;
-	if (intsrc & STAT_DAC1)
-		sctl &= ~SCTRL_P1INTEN;
-	if (intsrc & STAT_DAC2)
-		sctl &= ~SCTRL_P2INTEN;
-	outl(sctl, s->io+ES1370_REG_SERIAL_CONTROL);
-	outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-	es1370_update_ptr(s);
-	es1370_handle_midi(s);
-	spin_unlock(&s->lock);
-	return IRQ_HANDLED;
-}
-
-/* --------------------------------------------------------------------- */
-
-static const char invalid_magic[] = KERN_CRIT "es1370: invalid magic value\n";
-
-#define VALIDATE_STATE(s)                         \
-({                                                \
-	if (!(s) || (s)->magic != ES1370_MAGIC) { \
-		printk(invalid_magic);            \
-		return -ENXIO;                    \
-	}                                         \
-})
-
-/* --------------------------------------------------------------------- */
-
-static const struct {
-	unsigned volidx:4;
-	unsigned left:4;
-	unsigned right:4;
-	unsigned stereo:1;
-	unsigned recmask:13;
-	unsigned avail:1;
-} mixtable[SOUND_MIXER_NRDEVICES] = {
-	[SOUND_MIXER_VOLUME] = { 0, 0x0, 0x1, 1, 0x0000, 1 },   /* master */
-	[SOUND_MIXER_PCM]    = { 1, 0x2, 0x3, 1, 0x0400, 1 },   /* voice */
-	[SOUND_MIXER_SYNTH]  = { 2, 0x4, 0x5, 1, 0x0060, 1 },   /* FM */
-	[SOUND_MIXER_CD]     = { 3, 0x6, 0x7, 1, 0x0006, 1 },   /* CD */
-	[SOUND_MIXER_LINE]   = { 4, 0x8, 0x9, 1, 0x0018, 1 },   /* Line */
-	[SOUND_MIXER_LINE1]  = { 5, 0xa, 0xb, 1, 0x1800, 1 },   /* AUX */
-	[SOUND_MIXER_LINE2]  = { 6, 0xc, 0x0, 0, 0x0100, 1 },   /* Mono1 */
-	[SOUND_MIXER_LINE3]  = { 7, 0xd, 0x0, 0, 0x0200, 1 },   /* Mono2 */
-	[SOUND_MIXER_MIC]    = { 8, 0xe, 0x0, 0, 0x0001, 1 },   /* Mic */
-	[SOUND_MIXER_OGAIN]  = { 9, 0xf, 0x0, 0, 0x0000, 1 }    /* mono out */
-};
-
-static void set_recsrc(struct es1370_state *s, unsigned int val)
-{
-	unsigned int i, j;
-
-	for (j = i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
-		if (!(val & (1 << i)))
-			continue;
-		if (!mixtable[i].recmask) {
-			val &= ~(1 << i);
-			continue;
-		}
-		j |= mixtable[i].recmask;
-	}
-	s->mix.recsrc = val;
-	wrcodec(s, 0x12, j & 0xd5);
-	wrcodec(s, 0x13, j & 0xaa);
-	wrcodec(s, 0x14, (j >> 8) & 0x17);
-	wrcodec(s, 0x15, (j >> 8) & 0x0f);
-	i = (j & 0x37f) | ((j << 1) & 0x3000) | 0xc60;
-	if (!s->mix.imix) {
-		i &= 0xff60;  /* mute record and line monitor */
-	}
-	wrcodec(s, 0x10, i);
-	wrcodec(s, 0x11, i >> 8);
-}
-
-static int mixer_ioctl(struct es1370_state *s, unsigned int cmd, unsigned long arg)
-{
-	unsigned long flags;
-	int i, val;
-	unsigned char l, r, rl, rr;
-	int __user *p = (int __user *)arg;
-
-	VALIDATE_STATE(s);
-	if (cmd == SOUND_MIXER_PRIVATE1) {
-		/* enable/disable/query mixer preamp */
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != -1) {
-			s->mix.micpreamp = !!val;
-			wrcodec(s, 0x19, s->mix.micpreamp);
-		}
-		return put_user(s->mix.micpreamp, p);
-	}
-	if (cmd == SOUND_MIXER_PRIVATE2) {
-		/* enable/disable/query use of linein as second lineout */
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != -1) {
-			spin_lock_irqsave(&s->lock, flags);
-			if (val)
-				s->ctrl |= CTRL_XCTL0;
-			else
-				s->ctrl &= ~CTRL_XCTL0;
-			outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		return put_user((s->ctrl & CTRL_XCTL0) ? 1 : 0, p);
-	}
-	if (cmd == SOUND_MIXER_PRIVATE3) {
-		/* enable/disable/query microphone impedance setting */
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != -1) {
-			spin_lock_irqsave(&s->lock, flags);
-			if (val)
-				s->ctrl |= CTRL_XCTL1;
-			else
-				s->ctrl &= ~CTRL_XCTL1;
-			outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		return put_user((s->ctrl & CTRL_XCTL1) ? 1 : 0, p);
-	}
-        if (cmd == SOUND_MIXER_INFO) {
-		mixer_info info;
-		strncpy(info.id, "ES1370", sizeof(info.id));
-		strncpy(info.name, "Ensoniq ES1370", sizeof(info.name));
-		info.modify_counter = s->mix.modcnt;
-		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == SOUND_OLD_MIXER_INFO) {
-		_old_mixer_info info;
-		strncpy(info.id, "ES1370", sizeof(info.id));
-		strncpy(info.name, "Ensoniq ES1370", sizeof(info.name));
-		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-	if (cmd == OSS_GETVERSION)
-		return put_user(SOUND_VERSION, p);
-	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
-                return -EINVAL;
-        if (_SIOC_DIR(cmd) == _SIOC_READ) {
-                switch (_IOC_NR(cmd)) {
-                case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-			return put_user(s->mix.recsrc, p);
-			
-                case SOUND_MIXER_DEVMASK: /* Arg contains a bit for each supported device */
-			val = SOUND_MASK_IMIX;
-			for (i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].avail)
-					val |= 1 << i;
-			return put_user(val, p);
-
-                case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].recmask)
-					val |= 1 << i;
-			return put_user(val, p);
-			
-                case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
-			for (val = i = 0; i < SOUND_MIXER_NRDEVICES; i++)
-				if (mixtable[i].stereo)
-					val |= 1 << i;
-			return put_user(val, p);
-			
-                case SOUND_MIXER_CAPS:
-			return put_user(0, p);
-		
-		case SOUND_MIXER_IMIX:
-			return put_user(s->mix.imix, p);
-
-		default:
-			i = _IOC_NR(cmd);
-                        if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].avail)
-                                return -EINVAL;
-			return put_user(s->mix.vol[mixtable[i].volidx], p);
-		}
-	}
-        if (_SIOC_DIR(cmd) != (_SIOC_READ|_SIOC_WRITE)) 
-		return -EINVAL;
-	s->mix.modcnt++;
-	switch (_IOC_NR(cmd)) {
-
-	case SOUND_MIXER_IMIX:
-		if (get_user(s->mix.imix, p))
-			return -EFAULT;
-		set_recsrc(s, s->mix.recsrc);
-		return 0;
-
-	case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
-		if (get_user(val, p))
-			return -EFAULT;
-		set_recsrc(s, val);
-		return 0;
-
-	default:
-		i = _IOC_NR(cmd);
-		if (i >= SOUND_MIXER_NRDEVICES || !mixtable[i].avail)
-			return -EINVAL;
-		if (get_user(val, p))
-			return -EFAULT;
-		l = val & 0xff;
-		if (l > 100)
-			l = 100;
-		if (mixtable[i].stereo) {
-			r = (val >> 8) & 0xff;
-			if (r > 100)
-				r = 100;
-			if (l < 7) {
-				rl = 0x80;
-				l = 0;
-			} else {
-				rl = 31 - ((l - 7) / 3);
-				l = (31 - rl) * 3 + 7;
-			}
-			if (r < 7) {
-				rr = 0x80;
-				r = 0;
-			} else {
-				rr =  31 - ((r - 7) / 3);
-				r = (31 - rr) * 3 + 7;
-			}
-			wrcodec(s, mixtable[i].right, rr);
-		} else { 
-			if (mixtable[i].left == 15) {
-				if (l < 2) {
-					rr = rl = 0x80;
-					r = l = 0;
-				} else {
-					rl = 7 - ((l - 2) / 14);
-					r = l = (7 - rl) * 14 + 2;
-				}
-			} else {
-				if (l < 7) {
-					rl = 0x80;
-					r = l = 0;
-				} else {
-					rl = 31 - ((l - 7) / 3);
-					r = l = (31 - rl) * 3 + 7;
-				}
-			}
-		}
-		wrcodec(s, mixtable[i].left, rl);
-#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
-		s->mix.vol[mixtable[i].volidx] = ((unsigned int)r << 8) | l;
-#else
-		s->mix.vol[mixtable[i].volidx] = val;
-#endif
-                return put_user(s->mix.vol[mixtable[i].volidx], p);
-	}
-}
-
-/* --------------------------------------------------------------------- */
-
-static int es1370_open_mixdev(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	struct list_head *list;
-	struct es1370_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct es1370_state, devs);
-		if (s->dev_mixer == minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	return nonseekable_open(inode, file);
-}
-
-static int es1370_release_mixdev(struct inode *inode, struct file *file)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	
-	VALIDATE_STATE(s);
-	return 0;
-}
-
-static int es1370_ioctl_mixdev(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	return mixer_ioctl((struct es1370_state *)file->private_data, cmd, arg);
-}
-
-static /*const*/ struct file_operations es1370_mixer_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.ioctl		= es1370_ioctl_mixdev,
-	.open		= es1370_open_mixdev,
-	.release	= es1370_release_mixdev,
-};
-
-/* --------------------------------------------------------------------- */
-
-static int drain_dac1(struct es1370_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count, tmo;
-	
-	if (s->dma_dac1.mapped || !s->dma_dac1.ready)
-		return 0;
-        add_wait_queue(&s->dma_dac1.wait, &wait);
-        for (;;) {
-		__set_current_state(TASK_INTERRUPTIBLE);
-                spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac1.count;
-                spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-                        break;
-                if (nonblock) {
-                        remove_wait_queue(&s->dma_dac1.wait, &wait);
-                        set_current_state(TASK_RUNNING);
-                        return -EBUSY;
-                }
-		tmo = 3 * HZ * (count + s->dma_dac1.fragsize) / 2
-			/ dac1_samplerate[(s->ctrl & CTRL_WTSRSEL) >> CTRL_SH_WTSRSEL];
-		tmo >>= sample_shift[(s->sctrl & SCTRL_P1FMT) >> SCTRL_SH_P1FMT];
-		if (!schedule_timeout(tmo + 1))
-			DBG(printk(KERN_DEBUG "es1370: dma timed out??\n");)
-        }
-        remove_wait_queue(&s->dma_dac1.wait, &wait);
-        set_current_state(TASK_RUNNING);
-        if (signal_pending(current))
-                return -ERESTARTSYS;
-        return 0;
-}
-
-static int drain_dac2(struct es1370_state *s, int nonblock)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	int count, tmo;
-
-	if (s->dma_dac2.mapped || !s->dma_dac2.ready)
-		return 0;
-        add_wait_queue(&s->dma_dac2.wait, &wait);
-        for (;;) {
-		__set_current_state(TASK_INTERRUPTIBLE);
-                spin_lock_irqsave(&s->lock, flags);
-		count = s->dma_dac2.count;
-                spin_unlock_irqrestore(&s->lock, flags);
-		if (count <= 0)
-			break;
-		if (signal_pending(current))
-                        break;
-                if (nonblock) {
-                        remove_wait_queue(&s->dma_dac2.wait, &wait);
-                        set_current_state(TASK_RUNNING);
-                        return -EBUSY;
-                }
-		tmo = 3 * HZ * (count + s->dma_dac2.fragsize) / 2
-			/ DAC2_DIVTOSR((s->ctrl & CTRL_PCLKDIV) >> CTRL_SH_PCLKDIV);
-		tmo >>= sample_shift[(s->sctrl & SCTRL_P2FMT) >> SCTRL_SH_P2FMT];
-		if (!schedule_timeout(tmo + 1))
-			DBG(printk(KERN_DEBUG "es1370: dma timed out??\n");)
-        }
-        remove_wait_queue(&s->dma_dac2.wait, &wait);
-        set_current_state(TASK_RUNNING);
-        if (signal_pending(current))
-                return -ERESTARTSYS;
-        return 0;
-}
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t es1370_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret = 0;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_adc.mapped)
-		return -ENXIO;
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	mutex_lock(&s->mutex);
-	if (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))
-		goto out;
-        
-	add_wait_queue(&s->dma_adc.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		swptr = s->dma_adc.swptr;
-		cnt = s->dma_adc.dmasize-swptr;
-		if (s->dma_adc.count < cnt)
-			cnt = s->dma_adc.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_adc.enabled)
-				start_adc(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				goto out;
-			}
-			mutex_unlock(&s->mutex);
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				goto out;
-			}
-			mutex_lock(&s->mutex);
-			if (s->dma_adc.mapped)
-			{
-				ret = -ENXIO;
-				goto out;
-			}
-			continue;
-		}
-		if (copy_to_user(buffer, s->dma_adc.rawbuf + swptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			goto out;
-		}
-		swptr = (swptr + cnt) % s->dma_adc.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_adc.swptr = swptr;
-		s->dma_adc.count -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_adc.enabled)
-			start_adc(s);
-	}
-out:
-	mutex_unlock(&s->mutex);
-        remove_wait_queue(&s->dma_adc.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-static ssize_t es1370_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret = 0;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_dac2.mapped)
-		return -ENXIO;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	mutex_lock(&s->mutex);
-	if (!s->dma_dac2.ready && (ret = prog_dmabuf_dac2(s)))
-		goto out;
-	ret = 0;
-        add_wait_queue(&s->dma_dac2.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		if (s->dma_dac2.count < 0) {
-			s->dma_dac2.count = 0;
-			s->dma_dac2.swptr = s->dma_dac2.hwptr;
-		}
-		swptr = s->dma_dac2.swptr;
-		cnt = s->dma_dac2.dmasize-swptr;
-		if (s->dma_dac2.count + cnt > s->dma_dac2.dmasize)
-			cnt = s->dma_dac2.dmasize - s->dma_dac2.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_dac2.enabled)
-				start_dac2(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				goto out;
-			}
-			mutex_unlock(&s->mutex);
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				goto out;	
-			}
-			mutex_lock(&s->mutex);
-			if (s->dma_dac2.mapped)
-			{
-			ret = -ENXIO;
-			goto out;
-			}
-			continue;
-		}
-		if (copy_from_user(s->dma_dac2.rawbuf + swptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			goto out;
-		}
-		swptr = (swptr + cnt) % s->dma_dac2.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac2.swptr = swptr;
-		s->dma_dac2.count += cnt;
-		s->dma_dac2.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_dac2.enabled)
-			start_dac2(s);
-	}
-out:
-	mutex_unlock(&s->mutex);
-        remove_wait_queue(&s->dma_dac2.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int es1370_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE) {
-		if (!s->dma_dac2.ready && prog_dmabuf_dac2(s))
-			return 0;
-		poll_wait(file, &s->dma_dac2.wait, wait);
-	}
-	if (file->f_mode & FMODE_READ) {
-		if (!s->dma_adc.ready && prog_dmabuf_adc(s))
-			return 0;
-		poll_wait(file, &s->dma_adc.wait, wait);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	es1370_update_ptr(s);
-	if (file->f_mode & FMODE_READ) {
-		if (s->dma_adc.count >= (signed)s->dma_adc.fragsize)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->dma_dac2.mapped) {
-			if (s->dma_dac2.count >= (signed)s->dma_dac2.fragsize) 
-				mask |= POLLOUT | POLLWRNORM;
-		} else {
-			if ((signed)s->dma_dac2.dmasize >= s->dma_dac2.count + (signed)s->dma_dac2.fragsize)
-				mask |= POLLOUT | POLLWRNORM;
-		}
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int es1370_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	struct dmabuf *db;
-	int ret = 0;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	mutex_lock(&s->mutex);
-	if (vma->vm_flags & VM_WRITE) {
-		if ((ret = prog_dmabuf_dac2(s)) != 0) {
-			goto out;
-		}
-		db = &s->dma_dac2;
-	} else if (vma->vm_flags & VM_READ) {
-		if ((ret = prog_dmabuf_adc(s)) != 0) {
-			goto out;
-		}
-		db = &s->dma_adc;
-	} else  {
-		ret = -EINVAL;
-		goto out;
-	}
-	if (vma->vm_pgoff != 0) {
-		ret = -EINVAL;
-		goto out;
-	}
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << db->buforder)) {
-		ret = -EINVAL;
-		goto out;
-	}
-	if (remap_pfn_range(vma, vma->vm_start,
-				virt_to_phys(db->rawbuf) >> PAGE_SHIFT,
-				size, vma->vm_page_prot)) {
-		ret = -EAGAIN;
-		goto out;
-	}
-	db->mapped = 1;
-out:
-	mutex_unlock(&s->mutex);
-	unlock_kernel();
-	return ret;
-}
-
-static int es1370_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int count;
-	int val, mapped, ret;
-	void __user *argp = (void __user *)arg;
-	int __user *p = argp;
-
-	VALIDATE_STATE(s);
-        mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac2.mapped) ||
-		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		if (file->f_mode & FMODE_WRITE)
-			return drain_dac2(s, 0/*file->f_flags & O_NONBLOCK*/);
-		return 0;
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		return 0;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-		
-        case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac2(s);
-			synchronize_irq(s->irq);
-			s->dma_dac2.swptr = s->dma_dac2.hwptr = s->dma_dac2.count = s->dma_dac2.total_bytes = 0;
-		}
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			synchronize_irq(s->irq);
-			s->dma_adc.swptr = s->dma_adc.hwptr = s->dma_adc.count = s->dma_adc.total_bytes = 0;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			if (s->open_mode & (~file->f_mode) & (FMODE_READ|FMODE_WRITE))
-				return -EINVAL;
-			if (val < 4000)
-				val = 4000;
-			if (val > 50000)
-				val = 50000;
-			stop_adc(s);
-			stop_dac2(s);
-			s->dma_adc.ready = s->dma_dac2.ready = 0;
-			spin_lock_irqsave(&s->lock, flags);
-			s->ctrl = (s->ctrl & ~CTRL_PCLKDIV) | (DAC2_SRTODIV(val) << CTRL_SH_PCLKDIV);
-			outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		return put_user(DAC2_DIVTOSR((s->ctrl & CTRL_PCLKDIV) >> CTRL_SH_PCLKDIV), p);
-		
-        case SNDCTL_DSP_STEREO:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			stop_adc(s);
-			s->dma_adc.ready = 0;
-			spin_lock_irqsave(&s->lock, flags);
-			if (val)
-				s->sctrl |= SCTRL_R1SMB;
-			else
-				s->sctrl &= ~SCTRL_R1SMB;
-			outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			stop_dac2(s);
-			s->dma_dac2.ready = 0;
-			spin_lock_irqsave(&s->lock, flags);
-			if (val)
-				s->sctrl |= SCTRL_P2SMB;
-			else
-				s->sctrl &= ~SCTRL_P2SMB;
-			outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-                }
-		return 0;
-
-        case SNDCTL_DSP_CHANNELS:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 0) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				spin_lock_irqsave(&s->lock, flags);
-				if (val >= 2)
-					s->sctrl |= SCTRL_R1SMB;
-				else
-					s->sctrl &= ~SCTRL_R1SMB;
-				outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac2(s);
-				s->dma_dac2.ready = 0;
-				spin_lock_irqsave(&s->lock, flags);
-				if (val >= 2)
-					s->sctrl |= SCTRL_P2SMB;
-				else
-					s->sctrl &= ~SCTRL_P2SMB;
-				outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-		}
-		return put_user((s->sctrl & ((file->f_mode & FMODE_READ) ? SCTRL_R1SMB : SCTRL_P2SMB)) ? 2 : 1, p);
-		
-	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(AFMT_S16_LE|AFMT_U8, p);
-		
-	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			if (file->f_mode & FMODE_READ) {
-				stop_adc(s);
-				s->dma_adc.ready = 0;
-				spin_lock_irqsave(&s->lock, flags);
-				if (val == AFMT_S16_LE)
-					s->sctrl |= SCTRL_R1SEB;
-				else
-					s->sctrl &= ~SCTRL_R1SEB;
-				outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-			if (file->f_mode & FMODE_WRITE) {
-				stop_dac2(s);
-				s->dma_dac2.ready = 0;
-				spin_lock_irqsave(&s->lock, flags);
-				if (val == AFMT_S16_LE)
-					s->sctrl |= SCTRL_P2SEB;
-				else
-					s->sctrl &= ~SCTRL_P2SEB;
-				outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-				spin_unlock_irqrestore(&s->lock, flags);
-			}
-		}
-		return put_user((s->sctrl & ((file->f_mode & FMODE_READ) ? SCTRL_R1SEB : SCTRL_P2SEB)) ? 
-				AFMT_S16_LE : AFMT_U8, p);
-		
-	case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if (file->f_mode & FMODE_READ && s->ctrl & CTRL_ADC_EN) 
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && s->ctrl & CTRL_DAC2_EN) 
-			val |= PCM_ENABLE_OUTPUT;
-		return put_user(val, p);
-		
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				if (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))
-					return ret;
-				s->dma_adc.enabled = 1;
-				start_adc(s);
-			} else {
-				s->dma_adc.enabled = 0;
-				stop_adc(s);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				if (!s->dma_dac2.ready && (ret = prog_dmabuf_dac2(s)))
-					return ret;
-				s->dma_dac2.enabled = 1;
-				start_dac2(s);
-			} else {
-				s->dma_dac2.enabled = 0;
-				stop_dac2(s);
-			}
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac2.ready && (val = prog_dmabuf_dac2(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-		abinfo.fragsize = s->dma_dac2.fragsize;
-		count = s->dma_dac2.count;
-		if (count < 0)
-			count = 0;
-                abinfo.bytes = s->dma_dac2.dmasize - count;
-                abinfo.fragstotal = s->dma_dac2.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_dac2.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-	case SNDCTL_DSP_GETISPACE:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf_adc(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-		abinfo.fragsize = s->dma_adc.fragsize;
-		count = s->dma_adc.count;
-		if (count < 0)
-			count = 0;
-                abinfo.bytes = count;
-                abinfo.fragstotal = s->dma_adc.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user(argp, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-		
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac2.ready && (val = prog_dmabuf_dac2(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-                count = s->dma_dac2.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		return put_user(count, p);
-
-        case SNDCTL_DSP_GETIPTR:
-		if (!(file->f_mode & FMODE_READ))
-			return -EINVAL;
-		if (!s->dma_adc.ready && (val = prog_dmabuf_adc(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-                cinfo.bytes = s->dma_adc.total_bytes;
-		count = s->dma_adc.count;
-		if (count < 0)
-			count = 0;
-                cinfo.blocks = count >> s->dma_adc.fragshift;
-                cinfo.ptr = s->dma_adc.hwptr;
-		if (s->dma_adc.mapped)
-			s->dma_adc.count &= s->dma_adc.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!(file->f_mode & FMODE_WRITE))
-			return -EINVAL;
-		if (!s->dma_dac2.ready && (val = prog_dmabuf_dac2(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-                cinfo.bytes = s->dma_dac2.total_bytes;
-		count = s->dma_dac2.count;
-		if (count < 0)
-			count = 0;
-                cinfo.blocks = count >> s->dma_dac2.fragshift;
-                cinfo.ptr = s->dma_dac2.hwptr;
-		if (s->dma_dac2.mapped)
-			s->dma_dac2.count &= s->dma_dac2.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user(argp, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE) {
-			if ((val = prog_dmabuf_dac2(s)))
-				return val;
-			return put_user(s->dma_dac2.fragsize, p);
-		}
-		if ((val = prog_dmabuf_adc(s)))
-			return val;
-		return put_user(s->dma_adc.fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (file->f_mode & FMODE_READ) {
-			s->dma_adc.ossfragshift = val & 0xffff;
-			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_adc.ossfragshift < 4)
-				s->dma_adc.ossfragshift = 4;
-			if (s->dma_adc.ossfragshift > 15)
-				s->dma_adc.ossfragshift = 15;
-			if (s->dma_adc.ossmaxfrags < 4)
-				s->dma_adc.ossmaxfrags = 4;
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			s->dma_dac2.ossfragshift = val & 0xffff;
-			s->dma_dac2.ossmaxfrags = (val >> 16) & 0xffff;
-			if (s->dma_dac2.ossfragshift < 4)
-				s->dma_dac2.ossfragshift = 4;
-			if (s->dma_dac2.ossfragshift > 15)
-				s->dma_dac2.ossfragshift = 15;
-			if (s->dma_dac2.ossmaxfrags < 4)
-				s->dma_dac2.ossmaxfrags = 4;
-		}
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
-		    (file->f_mode & FMODE_WRITE && s->dma_dac2.subdivision))
-			return -EINVAL;
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		if (file->f_mode & FMODE_READ)
-			s->dma_adc.subdivision = val;
-		if (file->f_mode & FMODE_WRITE)
-			s->dma_dac2.subdivision = val;
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		return put_user(DAC2_DIVTOSR((s->ctrl & CTRL_PCLKDIV) >> CTRL_SH_PCLKDIV), p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user((s->sctrl & ((file->f_mode & FMODE_READ) ? SCTRL_R1SMB : SCTRL_P2SMB)) ?
-				2 : 1, p);
-
-        case SOUND_PCM_READ_BITS:
-		return put_user((s->sctrl & ((file->f_mode & FMODE_READ) ? SCTRL_R1SEB : SCTRL_P2SEB)) ? 
-				16 : 8, p);
-
-        case SOUND_PCM_WRITE_FILTER:
-        case SNDCTL_DSP_SETSYNCRO:
-        case SOUND_PCM_READ_FILTER:
-                return -EINVAL;
-		
-	}
-	return mixer_ioctl(s, cmd, arg);
-}
-
-static int es1370_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	struct list_head *list;
-	struct es1370_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct es1370_state, devs);
-		if (!((s->dev_audio ^ minor) & ~0xf))
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & file->f_mode) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_READ|FMODE_WRITE)))
-		s->ctrl = (s->ctrl & ~CTRL_PCLKDIV) | (DAC2_SRTODIV(8000) << CTRL_SH_PCLKDIV);
-	if (file->f_mode & FMODE_READ) {
-		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags = s->dma_adc.subdivision = 0;
-		s->dma_adc.enabled = 1;
-		s->sctrl &= ~SCTRL_R1FMT;
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			s->sctrl |= ES1370_FMT_S16_MONO << SCTRL_SH_R1FMT;
-		else
-			s->sctrl |= ES1370_FMT_U8_MONO << SCTRL_SH_R1FMT;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->dma_dac2.ossfragshift = s->dma_dac2.ossmaxfrags = s->dma_dac2.subdivision = 0;
-		s->dma_dac2.enabled = 1;
-		s->sctrl &= ~SCTRL_P2FMT;
-		if ((minor & 0xf) == SND_DEV_DSP16)
-			s->sctrl |= ES1370_FMT_S16_MONO << SCTRL_SH_P2FMT;
-		else
-			s->sctrl |= ES1370_FMT_U8_MONO << SCTRL_SH_P2FMT;
-	}
-	outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
-	mutex_unlock(&s->open_mutex);
-	mutex_init(&s->mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int es1370_release(struct inode *inode, struct file *file)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE)
-		drain_dac2(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	if (file->f_mode & FMODE_WRITE) {
-		stop_dac2(s);
-		synchronize_irq(s->irq);
-		dealloc_dmabuf(s, &s->dma_dac2);
-	}
-	if (file->f_mode & FMODE_READ) {
-		stop_adc(s);
-		dealloc_dmabuf(s, &s->dma_adc);
-	}
-	s->open_mode &= ~(file->f_mode & (FMODE_READ|FMODE_WRITE));
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations es1370_audio_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= es1370_read,
-	.write		= es1370_write,
-	.poll		= es1370_poll,
-	.ioctl		= es1370_ioctl,
-	.mmap		= es1370_mmap,
-	.open		= es1370_open,
-	.release	= es1370_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t es1370_write_dac(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret = 0;
-	unsigned long flags;
-	unsigned swptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (s->dma_dac1.mapped)
-		return -ENXIO;
-	if (!s->dma_dac1.ready && (ret = prog_dmabuf_dac1(s)))
-		return ret;
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-        add_wait_queue(&s->dma_dac1.wait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		if (s->dma_dac1.count < 0) {
-			s->dma_dac1.count = 0;
-			s->dma_dac1.swptr = s->dma_dac1.hwptr;
-		}
-		swptr = s->dma_dac1.swptr;
-		cnt = s->dma_dac1.dmasize-swptr;
-		if (s->dma_dac1.count + cnt > s->dma_dac1.dmasize)
-			cnt = s->dma_dac1.dmasize - s->dma_dac1.count;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (s->dma_dac1.enabled)
-				start_dac1(s);
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(s->dma_dac1.rawbuf + swptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		swptr = (swptr + cnt) % s->dma_dac1.dmasize;
-		spin_lock_irqsave(&s->lock, flags);
-		s->dma_dac1.swptr = swptr;
-		s->dma_dac1.count += cnt;
-		s->dma_dac1.endcleared = 0;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		if (s->dma_dac1.enabled)
-			start_dac1(s);
-	}
-        remove_wait_queue(&s->dma_dac1.wait, &wait);
-	set_current_state(TASK_RUNNING);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int es1370_poll_dac(struct file *file, struct poll_table_struct *wait)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (!s->dma_dac1.ready && prog_dmabuf_dac1(s))
-		return 0;
-	poll_wait(file, &s->dma_dac1.wait, wait);
-	spin_lock_irqsave(&s->lock, flags);
-	es1370_update_ptr(s);
-	if (s->dma_dac1.mapped) {
-		if (s->dma_dac1.count >= (signed)s->dma_dac1.fragsize)
-			mask |= POLLOUT | POLLWRNORM;
-	} else {
-		if ((signed)s->dma_dac1.dmasize >= s->dma_dac1.count + (signed)s->dma_dac1.fragsize)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int es1370_mmap_dac(struct file *file, struct vm_area_struct *vma)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	int ret;
-	unsigned long size;
-
-	VALIDATE_STATE(s);
-	if (!(vma->vm_flags & VM_WRITE))
-		return -EINVAL;
-	lock_kernel();
-	if ((ret = prog_dmabuf_dac1(s)) != 0)
-		goto out;
-	ret = -EINVAL;
-	if (vma->vm_pgoff != 0)
-		goto out;
-	size = vma->vm_end - vma->vm_start;
-	if (size > (PAGE_SIZE << s->dma_dac1.buforder))
-		goto out;
-	ret = -EAGAIN;
-	if (remap_pfn_range(vma, vma->vm_start,
-			virt_to_phys(s->dma_dac1.rawbuf) >> PAGE_SHIFT,
-			size, vma->vm_page_prot))
-		goto out;
-	s->dma_dac1.mapped = 1;
-	ret = 0;
-out:
-	unlock_kernel();
-	return ret;
-}
-
-static int es1370_ioctl_dac(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	unsigned long flags;
-        audio_buf_info abinfo;
-        count_info cinfo;
-	int count;
-	unsigned ctrl;
-	int val, ret;
-	int __user *p = (int __user *)arg;
-
-	VALIDATE_STATE(s);
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, p);
-
-	case SNDCTL_DSP_SYNC:
-		return drain_dac1(s, 0/*file->f_flags & O_NONBLOCK*/);
-		
-	case SNDCTL_DSP_SETDUPLEX:
-		return -EINVAL;
-
-	case SNDCTL_DSP_GETCAPS:
-		return put_user(DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP, p);
-		
-        case SNDCTL_DSP_RESET:
-		stop_dac1(s);
-		synchronize_irq(s->irq);
-		s->dma_dac1.swptr = s->dma_dac1.hwptr = s->dma_dac1.count = s->dma_dac1.total_bytes = 0;
-		return 0;
-
-        case SNDCTL_DSP_SPEED:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val >= 0) {
-			stop_dac1(s);
-			s->dma_dac1.ready = 0;
-			for (ctrl = 0; ctrl <= 2; ctrl++)
-				if (val < (dac1_samplerate[ctrl] + dac1_samplerate[ctrl+1]) / 2)
-					break;
-			spin_lock_irqsave(&s->lock, flags);
-			s->ctrl = (s->ctrl & ~CTRL_WTSRSEL) | (ctrl << CTRL_SH_WTSRSEL);
-			outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		return put_user(dac1_samplerate[(s->ctrl & CTRL_WTSRSEL) >> CTRL_SH_WTSRSEL], p);
-		
-        case SNDCTL_DSP_STEREO:
-                if (get_user(val, p))
-			return -EFAULT;
-		stop_dac1(s);
-		s->dma_dac1.ready = 0;
-		spin_lock_irqsave(&s->lock, flags);
-		if (val)
-			s->sctrl |= SCTRL_P1SMB;
-		else
-			s->sctrl &= ~SCTRL_P1SMB;
-		outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-		spin_unlock_irqrestore(&s->lock, flags);
-		return 0;
-
-        case SNDCTL_DSP_CHANNELS:
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 0) {
-			if (s->dma_dac1.mapped)
-				return -EINVAL;
-			stop_dac1(s);
-			s->dma_dac1.ready = 0;
-			spin_lock_irqsave(&s->lock, flags);
-			if (val >= 2)
-				s->sctrl |= SCTRL_P1SMB;
-			else
-				s->sctrl &= ~SCTRL_P1SMB;
-			outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		return put_user((s->sctrl & SCTRL_P1SMB) ? 2 : 1, p);
-		
-        case SNDCTL_DSP_GETFMTS: /* Returns a mask */
-                return put_user(AFMT_S16_LE|AFMT_U8, p);
-		
-        case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val != AFMT_QUERY) {
-			stop_dac1(s);
-			s->dma_dac1.ready = 0;
-			spin_lock_irqsave(&s->lock, flags);
-			if (val == AFMT_S16_LE)
-				s->sctrl |= SCTRL_P1SEB;
-			else
-				s->sctrl &= ~SCTRL_P1SEB;
-			outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-			spin_unlock_irqrestore(&s->lock, flags);
-		}
-		return put_user((s->sctrl & SCTRL_P1SEB) ? AFMT_S16_LE : AFMT_U8, p);
-
-        case SNDCTL_DSP_POST:
-                return 0;
-
-        case SNDCTL_DSP_GETTRIGGER:
-		return put_user((s->ctrl & CTRL_DAC1_EN) ? PCM_ENABLE_OUTPUT : 0, p);
-						
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, p))
-			return -EFAULT;
-		if (val & PCM_ENABLE_OUTPUT) {
-			if (!s->dma_dac1.ready && (ret = prog_dmabuf_dac1(s)))
-				return ret;
-			s->dma_dac1.enabled = 1;
-			start_dac1(s);
-		} else {
-			s->dma_dac1.enabled = 0;
-			stop_dac1(s);
-		}
-		return 0;
-
-	case SNDCTL_DSP_GETOSPACE:
-		if (!s->dma_dac1.ready && (val = prog_dmabuf_dac1(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-		abinfo.fragsize = s->dma_dac1.fragsize;
-		count = s->dma_dac1.count;
-		if (count < 0)
-			count = 0;
-                abinfo.bytes = s->dma_dac1.dmasize - count;
-                abinfo.fragstotal = s->dma_dac1.numfrag;
-                abinfo.fragments = abinfo.bytes >> s->dma_dac1.fragshift;      
-		spin_unlock_irqrestore(&s->lock, flags);
-		return copy_to_user((void __user *)arg, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
-
-        case SNDCTL_DSP_NONBLOCK:
-                file->f_flags |= O_NONBLOCK;
-                return 0;
-
-        case SNDCTL_DSP_GETODELAY:
-		if (!s->dma_dac1.ready && (val = prog_dmabuf_dac1(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-                count = s->dma_dac1.count;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (count < 0)
-			count = 0;
-		return put_user(count, p);
-
-        case SNDCTL_DSP_GETOPTR:
-		if (!s->dma_dac1.ready && (val = prog_dmabuf_dac1(s)) != 0)
-			return val;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_update_ptr(s);
-                cinfo.bytes = s->dma_dac1.total_bytes;
-		count = s->dma_dac1.count;
-		if (count < 0)
-			count = 0;
-                cinfo.blocks = count >> s->dma_dac1.fragshift;
-                cinfo.ptr = s->dma_dac1.hwptr;
-		if (s->dma_dac1.mapped)
-			s->dma_dac1.count &= s->dma_dac1.fragsize-1;
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (copy_to_user((void __user *)arg, &cinfo, sizeof(cinfo)))
-			return -EFAULT;
-		return 0;
-
-        case SNDCTL_DSP_GETBLKSIZE:
-		if ((val = prog_dmabuf_dac1(s)))
-			return val;
-                return put_user(s->dma_dac1.fragsize, p);
-
-        case SNDCTL_DSP_SETFRAGMENT:
-                if (get_user(val, p))
-			return -EFAULT;
-		s->dma_dac1.ossfragshift = val & 0xffff;
-		s->dma_dac1.ossmaxfrags = (val >> 16) & 0xffff;
-		if (s->dma_dac1.ossfragshift < 4)
-			s->dma_dac1.ossfragshift = 4;
-		if (s->dma_dac1.ossfragshift > 15)
-			s->dma_dac1.ossfragshift = 15;
-		if (s->dma_dac1.ossmaxfrags < 4)
-			s->dma_dac1.ossmaxfrags = 4;
-		return 0;
-
-        case SNDCTL_DSP_SUBDIVIDE:
-		if (s->dma_dac1.subdivision)
-			return -EINVAL;
-                if (get_user(val, p))
-			return -EFAULT;
-		if (val != 1 && val != 2 && val != 4)
-			return -EINVAL;
-		s->dma_dac1.subdivision = val;
-		return 0;
-
-        case SOUND_PCM_READ_RATE:
-		return put_user(dac1_samplerate[(s->ctrl & CTRL_WTSRSEL) >> CTRL_SH_WTSRSEL], p);
-
-        case SOUND_PCM_READ_CHANNELS:
-		return put_user((s->sctrl & SCTRL_P1SMB) ? 2 : 1, p);
-
-        case SOUND_PCM_READ_BITS:
-		return put_user((s->sctrl & SCTRL_P1SEB) ? 16 : 8, p);
-
-        case SOUND_PCM_WRITE_FILTER:
-        case SNDCTL_DSP_SETSYNCRO:
-        case SOUND_PCM_READ_FILTER:
-                return -EINVAL;
-		
-	}
-	return mixer_ioctl(s, cmd, arg);
-}
-
-static int es1370_open_dac(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	struct list_head *list;
-	struct es1370_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct es1370_state, devs);
-		if (!((s->dev_dac ^ minor) & ~0xf))
-			break;
-	}
-       	VALIDATE_STATE(s);
-       	/* we allow opening with O_RDWR, most programs do it although they will only write */
-#if 0
-	if (file->f_mode & FMODE_READ)
-		return -EPERM;
-#endif
-	if (!(file->f_mode & FMODE_WRITE))
-		return -EINVAL;
-       	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & FMODE_DAC) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	s->dma_dac1.ossfragshift = s->dma_dac1.ossmaxfrags = s->dma_dac1.subdivision = 0;
-	s->dma_dac1.enabled = 1;
-	spin_lock_irqsave(&s->lock, flags);
-	s->ctrl = (s->ctrl & ~CTRL_WTSRSEL) | (1 << CTRL_SH_WTSRSEL);
-      	s->sctrl &= ~SCTRL_P1FMT;
-	if ((minor & 0xf) == SND_DEV_DSP16)
-		s->sctrl |= ES1370_FMT_S16_MONO << SCTRL_SH_P1FMT;
-	else
-		s->sctrl |= ES1370_FMT_U8_MONO << SCTRL_SH_P1FMT;
-	outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->open_mode |= FMODE_DAC;
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int es1370_release_dac(struct inode *inode, struct file *file)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-
-	VALIDATE_STATE(s);
-	lock_kernel();
-	drain_dac1(s, file->f_flags & O_NONBLOCK);
-	mutex_lock(&s->open_mutex);
-	stop_dac1(s);
-	dealloc_dmabuf(s, &s->dma_dac1);
-	s->open_mode &= ~FMODE_DAC;
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations es1370_dac_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.write		= es1370_write_dac,
-	.poll		= es1370_poll_dac,
-	.ioctl		= es1370_ioctl_dac,
-	.mmap		= es1370_mmap_dac,
-	.open		= es1370_open_dac,
-	.release	= es1370_release_dac,
-};
-
-/* --------------------------------------------------------------------- */
-
-static ssize_t es1370_midi_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_WRITE, buffer, count))
-		return -EFAULT;
-	if (count == 0)
-		return 0;
-	ret = 0;
-        add_wait_queue(&s->midi.iwait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.ird;
-		cnt = MIDIINBUF - ptr;
-		if (s->midi.icnt < cnt)
-			cnt = s->midi.icnt;
-		if (cnt <= 0)
-			__set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_to_user(buffer, s->midi.ibuf + ptr, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		ptr = (ptr + cnt) % MIDIINBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.ird = ptr;
-		s->midi.icnt -= cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		break;
-	}
-	__set_current_state(TASK_RUNNING);
-        remove_wait_queue(&s->midi.iwait, &wait);
-	return ret;
-}
-
-static ssize_t es1370_midi_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	ssize_t ret;
-	unsigned long flags;
-	unsigned ptr;
-	int cnt;
-
-	VALIDATE_STATE(s);
-	if (!access_ok(VERIFY_READ, buffer, count))
-		return -EFAULT;
-	if (count == 0)
-		return 0;
-	ret = 0;
-        add_wait_queue(&s->midi.owait, &wait);
-	while (count > 0) {
-		spin_lock_irqsave(&s->lock, flags);
-		ptr = s->midi.owr;
-		cnt = MIDIOUTBUF - ptr;
-		if (s->midi.ocnt + cnt > MIDIOUTBUF)
-			cnt = MIDIOUTBUF - s->midi.ocnt;
-		if (cnt <= 0) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			es1370_handle_midi(s);
-		}
-		spin_unlock_irqrestore(&s->lock, flags);
-		if (cnt > count)
-			cnt = count;
-		if (cnt <= 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				if (!ret)
-					ret = -EAGAIN;
-				break;
-			}
-			schedule();
-			if (signal_pending(current)) {
-				if (!ret)
-					ret = -ERESTARTSYS;
-				break;
-			}
-			continue;
-		}
-		if (copy_from_user(s->midi.obuf + ptr, buffer, cnt)) {
-			if (!ret)
-				ret = -EFAULT;
-			break;
-		}
-		ptr = (ptr + cnt) % MIDIOUTBUF;
-		spin_lock_irqsave(&s->lock, flags);
-		s->midi.owr = ptr;
-		s->midi.ocnt += cnt;
-		spin_unlock_irqrestore(&s->lock, flags);
-		count -= cnt;
-		buffer += cnt;
-		ret += cnt;
-		spin_lock_irqsave(&s->lock, flags);
-		es1370_handle_midi(s);
-		spin_unlock_irqrestore(&s->lock, flags);
-	}
-	__set_current_state(TASK_RUNNING);
-        remove_wait_queue(&s->midi.owait, &wait);
-	return ret;
-}
-
-/* No kernel lock - we have our own spinlock */
-static unsigned int es1370_midi_poll(struct file *file, struct poll_table_struct *wait)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	VALIDATE_STATE(s);
-	if (file->f_mode & FMODE_WRITE)
-		poll_wait(file, &s->midi.owait, wait);
-	if (file->f_mode & FMODE_READ)
-		poll_wait(file, &s->midi.iwait, wait);
-	spin_lock_irqsave(&s->lock, flags);
-	if (file->f_mode & FMODE_READ) {
-		if (s->midi.icnt > 0)
-			mask |= POLLIN | POLLRDNORM;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		if (s->midi.ocnt < MIDIOUTBUF)
-			mask |= POLLOUT | POLLWRNORM;
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	return mask;
-}
-
-static int es1370_midi_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode);
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	struct list_head *list;
-	struct es1370_state *s;
-
-	for (list = devs.next; ; list = list->next) {
-		if (list == &devs)
-			return -ENODEV;
-		s = list_entry(list, struct es1370_state, devs);
-		if (s->dev_midi == minor)
-			break;
-	}
-       	VALIDATE_STATE(s);
-	file->private_data = s;
-	/* wait for device to become free */
-	mutex_lock(&s->open_mutex);
-	while (s->open_mode & (file->f_mode << FMODE_MIDI_SHIFT)) {
-		if (file->f_flags & O_NONBLOCK) {
-			mutex_unlock(&s->open_mutex);
-			return -EBUSY;
-		}
-		add_wait_queue(&s->open_wait, &wait);
-		__set_current_state(TASK_INTERRUPTIBLE);
-		mutex_unlock(&s->open_mutex);
-		schedule();
-		remove_wait_queue(&s->open_wait, &wait);
-		set_current_state(TASK_RUNNING);
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-		mutex_lock(&s->open_mutex);
-	}
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-		outb(UCTRL_CNTRL_SWR, s->io+ES1370_REG_UART_CONTROL);
-		outb(0, s->io+ES1370_REG_UART_CONTROL);
-		outb(0, s->io+ES1370_REG_UART_TEST);
-	}
-	if (file->f_mode & FMODE_READ) {
-		s->midi.ird = s->midi.iwr = s->midi.icnt = 0;
-	}
-	if (file->f_mode & FMODE_WRITE) {
-		s->midi.ord = s->midi.owr = s->midi.ocnt = 0;
-	}
-	s->ctrl |= CTRL_UART_EN;
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	es1370_handle_midi(s);
-	spin_unlock_irqrestore(&s->lock, flags);
-	s->open_mode |= (file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ | FMODE_MIDI_WRITE);
-	mutex_unlock(&s->open_mutex);
-	return nonseekable_open(inode, file);
-}
-
-static int es1370_midi_release(struct inode *inode, struct file *file)
-{
-	struct es1370_state *s = (struct es1370_state *)file->private_data;
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long flags;
-	unsigned count, tmo;
-
-	VALIDATE_STATE(s);
-
-	lock_kernel();
-	if (file->f_mode & FMODE_WRITE) {
-		add_wait_queue(&s->midi.owait, &wait);
-		for (;;) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			spin_lock_irqsave(&s->lock, flags);
-			count = s->midi.ocnt;
-			spin_unlock_irqrestore(&s->lock, flags);
-			if (count <= 0)
-				break;
-			if (signal_pending(current))
-				break;
-			if (file->f_flags & O_NONBLOCK) 
-				break;
-			tmo = (count * HZ) / 3100;
-			if (!schedule_timeout(tmo ? : 1) && tmo)
-				DBG(printk(KERN_DEBUG "es1370: midi timed out??\n");)
-		}
-		remove_wait_queue(&s->midi.owait, &wait);
-		set_current_state(TASK_RUNNING);
-	}
-	mutex_lock(&s->open_mutex);
-	s->open_mode &= ~((file->f_mode << FMODE_MIDI_SHIFT) & (FMODE_MIDI_READ|FMODE_MIDI_WRITE));
-	spin_lock_irqsave(&s->lock, flags);
-	if (!(s->open_mode & (FMODE_MIDI_READ | FMODE_MIDI_WRITE))) {
-		s->ctrl &= ~CTRL_UART_EN;
-		outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	}
-	spin_unlock_irqrestore(&s->lock, flags);
-	wake_up(&s->open_wait);
-	mutex_unlock(&s->open_mutex);
-	unlock_kernel();
-	return 0;
-}
-
-static /*const*/ struct file_operations es1370_midi_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= es1370_midi_read,
-	.write		= es1370_midi_write,
-	.poll		= es1370_midi_poll,
-	.open		= es1370_midi_open,
-	.release	= es1370_midi_release,
-};
-
-/* --------------------------------------------------------------------- */
-
-/* maximum number of devices; only used for command line params */
-#define NR_DEVICE 5
-
-static int lineout[NR_DEVICE];
-static int micbias[NR_DEVICE];
-
-static unsigned int devindex;
-
-module_param_array(lineout, bool, NULL, 0);
-MODULE_PARM_DESC(lineout, "if 1 the LINE input is converted to LINE out");
-module_param_array(micbias, bool, NULL, 0);
-MODULE_PARM_DESC(micbias, "sets the +5V bias for an electret microphone");
-
-MODULE_AUTHOR("Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu");
-MODULE_DESCRIPTION("ES1370 AudioPCI Driver");
-MODULE_LICENSE("GPL");
-
-
-/* --------------------------------------------------------------------- */
-
-static struct initvol {
-	int mixch;
-	int vol;
-} initvol[] __devinitdata = {
-	{ SOUND_MIXER_WRITE_VOLUME, 0x4040 },
-	{ SOUND_MIXER_WRITE_PCM, 0x4040 },
-	{ SOUND_MIXER_WRITE_SYNTH, 0x4040 },
-	{ SOUND_MIXER_WRITE_CD, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE1, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE2, 0x4040 },
-	{ SOUND_MIXER_WRITE_LINE3, 0x4040 },
-	{ SOUND_MIXER_WRITE_MIC, 0x4040 },
-	{ SOUND_MIXER_WRITE_OGAIN, 0x4040 }
-};
-
-#ifdef SUPPORT_JOYSTICK
-
-static int __devinit es1370_register_gameport(struct es1370_state *s)
-{
-	struct gameport *gp;
-
-	if (!request_region(0x200, JOY_EXTENT, "es1370")) {
-		printk(KERN_ERR "es1370: joystick io port 0x200 in use\n");
-		return -EBUSY;
-	}
-
-	s->gameport = gp = gameport_allocate_port();
-	if (!gp) {
-		printk(KERN_ERR "es1370: can not allocate memory for gameport\n");
-		release_region(0x200, JOY_EXTENT);
-		return -ENOMEM;
-	}
-
-	gameport_set_name(gp, "ESS1370");
-	gameport_set_phys(gp, "pci%s/gameport0", pci_name(s->dev));
-	gp->dev.parent = &s->dev->dev;
-	gp->io = 0x200;
-
-	s->ctrl |= CTRL_JYSTK_EN;
-	outl(s->ctrl, s->io + ES1370_REG_CONTROL);
-
-	gameport_register_port(gp);
-
-	return 0;
-}
-
-static inline void es1370_unregister_gameport(struct es1370_state *s)
-{
-	if (s->gameport) {
-		int gpio = s->gameport->io;
-		gameport_unregister_port(s->gameport);
-		release_region(gpio, JOY_EXTENT);
-
-	}
-}
-
-#else
-static inline int es1370_register_gameport(struct es1370_state *s) { return -ENOSYS; }
-static inline void es1370_unregister_gameport(struct es1370_state *s) { }
-#endif /* SUPPORT_JOYSTICK */
-
-static int __devinit es1370_probe(struct pci_dev *pcidev, const struct pci_device_id *pciid)
-{
-	struct es1370_state *s;
-	mm_segment_t fs;
-	int i, val, ret;
-
-	if ((ret=pci_enable_device(pcidev)))
-		return ret;
-
-	if ( !(pci_resource_flags(pcidev, 0) & IORESOURCE_IO) ||
-	     !pci_resource_start(pcidev, 0)
-	)
-		return -ENODEV;
-	if (pcidev->irq == 0) 
-		return -ENODEV;
-	i = pci_set_dma_mask(pcidev, DMA_32BIT_MASK);
-	if (i) {
-		printk(KERN_WARNING "es1370: architecture does not support 32bit PCI busmaster DMA\n");
-		return i;
-	}
-	if (!(s = kmalloc(sizeof(struct es1370_state), GFP_KERNEL))) {
-		printk(KERN_WARNING "es1370: out of memory\n");
-		return -ENOMEM;
-	}
-	memset(s, 0, sizeof(struct es1370_state));
-	init_waitqueue_head(&s->dma_adc.wait);
-	init_waitqueue_head(&s->dma_dac1.wait);
-	init_waitqueue_head(&s->dma_dac2.wait);
-	init_waitqueue_head(&s->open_wait);
-	init_waitqueue_head(&s->midi.iwait);
-	init_waitqueue_head(&s->midi.owait);
-	mutex_init(&s->open_mutex);
-	spin_lock_init(&s->lock);
-	s->magic = ES1370_MAGIC;
-	s->dev = pcidev;
-	s->io = pci_resource_start(pcidev, 0);
-	s->irq = pcidev->irq;
-	if (!request_region(s->io, ES1370_EXTENT, "es1370")) {
-		printk(KERN_ERR "es1370: io ports %#lx-%#lx in use\n", s->io, s->io+ES1370_EXTENT-1);
-		ret = -EBUSY;
-		goto err_region;
-	}
-	if ((ret=request_irq(s->irq, es1370_interrupt, IRQF_SHARED, "es1370",s))) {
-		printk(KERN_ERR "es1370: irq %u in use\n", s->irq);
-		goto err_irq;
-	}
-
-	/* initialize codec registers */
-	/* note: setting CTRL_SERR_DIS is reported to break
-	 * mic bias setting (by Kim.Berts@fisub.mail.abb.com) */
-	s->ctrl = CTRL_CDC_EN | (DAC2_SRTODIV(8000) << CTRL_SH_PCLKDIV) | (1 << CTRL_SH_WTSRSEL);
-	if (lineout[devindex])
-		s->ctrl |= CTRL_XCTL0;
-	if (micbias[devindex])
-		s->ctrl |= CTRL_XCTL1;
-	s->sctrl = 0;
-	printk(KERN_INFO "es1370: adapter at io %#lx irq %u, line %s, mic impedance %s\n",
-	       s->io, s->irq, (s->ctrl & CTRL_XCTL0) ? "out" : "in",
-	       (s->ctrl & CTRL_XCTL1) ? "1" : "0");
-	/* register devices */
-	if ((s->dev_audio = register_sound_dsp(&es1370_audio_fops, -1)) < 0) {
-		ret = s->dev_audio;
-		goto err_dev1;
-	}
-	if ((s->dev_mixer = register_sound_mixer(&es1370_mixer_fops, -1)) < 0) {
-		ret = s->dev_mixer;
-		goto err_dev2;
-	}
-	if ((s->dev_dac = register_sound_dsp(&es1370_dac_fops, -1)) < 0) {
-		ret = s->dev_dac;
-		goto err_dev3;
-	}
-	if ((s->dev_midi = register_sound_midi(&es1370_midi_fops, -1)) < 0) {
-		ret = s->dev_midi;
-		goto err_dev4;
-	}
-	/* initialize the chips */
-	outl(s->ctrl, s->io+ES1370_REG_CONTROL);
-	outl(s->sctrl, s->io+ES1370_REG_SERIAL_CONTROL);
-	/* point phantom write channel to "bugbuf" */
-	s->bugbuf_cpu = pci_alloc_consistent(pcidev,16,&s->bugbuf_dma);
-	if (!s->bugbuf_cpu) {
-		ret = -ENOMEM;
-		goto err_dev5;
-	}
-	outl((ES1370_REG_PHANTOM_FRAMEADR >> 8) & 15, s->io+ES1370_REG_MEMPAGE);
-	outl(s->bugbuf_dma, s->io+(ES1370_REG_PHANTOM_FRAMEADR & 0xff));
-	outl(0, s->io+(ES1370_REG_PHANTOM_FRAMECNT & 0xff));
-	pci_set_master(pcidev);  /* enable bus mastering */
-	wrcodec(s, 0x16, 3); /* no RST, PD */
-	wrcodec(s, 0x17, 0); /* CODEC ADC and CODEC DAC use {LR,B}CLK2 and run off the LRCLK2 PLL; program DAC_SYNC=0!!  */
-	wrcodec(s, 0x18, 0); /* recording source is mixer */
-	wrcodec(s, 0x19, s->mix.micpreamp = 1); /* turn on MIC preamp */
-	s->mix.imix = 1;
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	val = SOUND_MASK_LINE|SOUND_MASK_SYNTH|SOUND_MASK_CD;
-	mixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long)&val);
-	for (i = 0; i < sizeof(initvol)/sizeof(initvol[0]); i++) {
-		val = initvol[i].vol;
-		mixer_ioctl(s, initvol[i].mixch, (unsigned long)&val);
-	}
-	set_fs(fs);
-
-	es1370_register_gameport(s);
-
-	/* store it in the driver field */
-	pci_set_drvdata(pcidev, s);
-	/* put it into driver list */
-	list_add_tail(&s->devs, &devs);
-	/* increment devindex */
-	if (devindex < NR_DEVICE-1)
-		devindex++;
-	return 0;
-
- err_dev5:
-	unregister_sound_midi(s->dev_midi);
- err_dev4:
-	unregister_sound_dsp(s->dev_dac);
- err_dev3:
-	unregister_sound_mixer(s->dev_mixer);
- err_dev2:
-	unregister_sound_dsp(s->dev_audio);
- err_dev1:
-	printk(KERN_ERR "es1370: cannot register misc device\n");
-	free_irq(s->irq, s);
- err_irq:
-	release_region(s->io, ES1370_EXTENT);
- err_region:
-	kfree(s);
-	return ret;
-}
-
-static void __devexit es1370_remove(struct pci_dev *dev)
-{
-	struct es1370_state *s = pci_get_drvdata(dev);
-
-	if (!s)
-		return;
-	list_del(&s->devs);
-	outl(CTRL_SERR_DIS | (1 << CTRL_SH_WTSRSEL), s->io+ES1370_REG_CONTROL); /* switch everything off */
-	outl(0, s->io+ES1370_REG_SERIAL_CONTROL); /* clear serial interrupts */
-	synchronize_irq(s->irq);
-	free_irq(s->irq, s);
-	es1370_unregister_gameport(s);
-	release_region(s->io, ES1370_EXTENT);
-	unregister_sound_dsp(s->dev_audio);
-	unregister_sound_mixer(s->dev_mixer);
-	unregister_sound_dsp(s->dev_dac);
-	unregister_sound_midi(s->dev_midi);
-	pci_free_consistent(dev, 16, s->bugbuf_cpu, s->bugbuf_dma);
-	kfree(s);
-	pci_set_drvdata(dev, NULL);
-}
-
-static struct pci_device_id id_table[] = {
-	{ PCI_VENDOR_ID_ENSONIQ, PCI_DEVICE_ID_ENSONIQ_ES1370, PCI_ANY_ID, PCI_ANY_ID, 0, 0 },
-	{ 0, }
-};
-
-MODULE_DEVICE_TABLE(pci, id_table);
-
-static struct pci_driver es1370_driver = {
-	.name		= "es1370",
-	.id_table	= id_table,
-	.probe		= es1370_probe,
-	.remove		= __devexit_p(es1370_remove),
-};
-
-static int __init init_es1370(void)
-{
-	printk(KERN_INFO "es1370: version v0.38 time " __TIME__ " " __DATE__ "\n");
-	return pci_register_driver(&es1370_driver);
-}
-
-static void __exit cleanup_es1370(void)
-{
-	printk(KERN_INFO "es1370: unloading\n");
-	pci_unregister_driver(&es1370_driver);
-}
-
-module_init(init_es1370);
-module_exit(cleanup_es1370);
-
-/* --------------------------------------------------------------------- */
-
-#ifndef MODULE
-
-/* format is: es1370=lineout[,micbias]] */
-
-static int __init es1370_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= NR_DEVICE)
-		return 0;
-
-	(void)
-	((get_option(&str,&lineout [nr_dev]) == 2)
-	 && get_option(&str,&micbias [nr_dev])
-	);
-
-	nr_dev++;
-	return 1;
-}
-
-__setup("es1370=", es1370_setup);
-
-#endif /* MODULE */
--- linux-2.6.18.noarch/sound/oss/sb_common.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/sb_common.c	2007-06-05 17:44:14.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * sound/sb_common.c
+ * sound/oss/sb_common.c
  *
  * Common routines for Sound Blaster compatible cards.
  *
@@ -132,7 +132,7 @@
 
 		if (src & 4)						/* MPU401 interrupt */
 			if(devc->midi_irq_cookie)
-				uart401intr(devc->irq, devc->midi_irq_cookie, NULL);
+				uart401intr(devc->irq, devc->midi_irq_cookie);
 
 		if (!(src & 3))
 			return;	/* Not a DSP interrupt */
@@ -200,7 +200,7 @@
 		sb_intr(devc);
 }
 
-static irqreturn_t sbintr(int irq, void *dev_id, struct pt_regs *dummy)
+static irqreturn_t sbintr(int irq, void *dev_id)
 {
 	sb_devc *devc = dev_id;
 
@@ -625,7 +625,7 @@
 	 */
 
 
-	detected_devc = (sb_devc *)kmalloc(sizeof(sb_devc), GFP_KERNEL);
+	detected_devc = kmalloc(sizeof(sb_devc), GFP_KERNEL);
 	if (detected_devc == NULL)
 	{
 		printk(KERN_ERR "sb: Can't allocate memory for device information\n");
--- linux-2.6.18.noarch/sound/oss/gus_hw.h.orig	2007-06-05 16:07:56.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/gus_hw.h	2007-06-05 17:44:14.000000000 -0400
@@ -1,50 +0,0 @@
-
-/*
- * I/O addresses
- */
-
-#define u_Base			(gus_base + 0x000)
-#define u_Mixer			u_Base
-#define u_Status		(gus_base + 0x006)
-#define u_TimerControl		(gus_base + 0x008)
-#define u_TimerData		(gus_base + 0x009)
-#define u_IRQDMAControl		(gus_base + 0x00b)
-#define u_MidiControl		(gus_base + 0x100)
-#define 	MIDI_RESET		0x03
-#define		MIDI_ENABLE_XMIT	0x20
-#define		MIDI_ENABLE_RCV		0x80
-#define u_MidiStatus		u_MidiControl
-#define		MIDI_RCV_FULL		0x01
-#define 	MIDI_XMIT_EMPTY		0x02
-#define 	MIDI_FRAME_ERR		0x10
-#define 	MIDI_OVERRUN		0x20
-#define 	MIDI_IRQ_PEND		0x80
-#define u_MidiData		(gus_base + 0x101)
-#define u_Voice			(gus_base + 0x102)
-#define u_Command		(gus_base + 0x103)
-#define u_DataLo		(gus_base + 0x104)
-#define u_DataHi		(gus_base + 0x105)
-#define u_MixData               (gus_base + 0x106)   /* Rev. 3.7+ mixing */
-#define u_MixSelect             (gus_base + 0x506)   /* registers.       */
-#define u_IrqStatus		u_Status
-#	define MIDI_TX_IRQ		0x01	/* pending MIDI xmit IRQ */
-#	define MIDI_RX_IRQ		0x02	/* pending MIDI recv IRQ */
-#	define GF1_TIMER1_IRQ		0x04	/* general purpose timer */
-#	define GF1_TIMER2_IRQ		0x08	/* general purpose timer */
-#	define WAVETABLE_IRQ		0x20	/* pending wavetable IRQ */
-#	define ENVELOPE_IRQ		0x40	/* pending volume envelope IRQ */
-#	define DMA_TC_IRQ		0x80	/* pending dma tc IRQ */
-
-#define ICS2101		1
-#	define ICS_MIXDEVS	6
-#	define DEV_MIC		0
-#	define DEV_LINE		1
-#	define DEV_CD		2
-#	define DEV_GF1		3
-#	define DEV_UNUSED	4
-#	define DEV_VOL		5
-
-#	define CHN_LEFT		0
-#	define CHN_RIGHT	1
-#define CS4231		2
-#define u_DRAMIO		(gus_base + 0x107)
--- linux-2.6.18.noarch/sound/oss/COPYING.orig	2007-06-05 16:07:55.000000000 -0400
+++ linux-2.6.18.noarch/sound/oss/COPYING	2007-06-05 17:44:14.000000000 -0400
@@ -1,339 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	Appendix: How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 19yy  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) 19yy name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
--- linux-2.6.18.noarch/sound/ac97_bus.c.orig	2007-06-05 16:46:37.000000000 -0400
+++ linux-2.6.18.noarch/sound/ac97_bus.c	2007-06-05 17:39:02.000000000 -0400
@@ -0,0 +1,76 @@
+/*
+ * Linux driver model AC97 bus interface
+ *
+ * Author:	Nicolas Pitre
+ * Created:	Jan 14, 2005
+ * Copyright:	(C) MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/string.h>
+
+/*
+ * Let drivers decide whether they want to support given codec from their
+ * probe method.  Drivers have direct access to the struct snd_ac97 structure and may
+ * decide based on the id field amongst other things.
+ */
+static int ac97_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+#ifdef CONFIG_PM
+static int ac97_bus_suspend(struct device *dev, pm_message_t state)
+{
+	int ret = 0;
+
+	if (dev->driver && dev->driver->suspend)
+		ret = dev->driver->suspend(dev, state);
+
+	return ret;
+}
+
+static int ac97_bus_resume(struct device *dev)
+{
+	int ret = 0;
+
+	if (dev->driver && dev->driver->resume)
+		ret = dev->driver->resume(dev);
+
+	return ret;
+}
+#endif /* CONFIG_PM */
+
+struct bus_type ac97_bus_type = {
+	.name		= "ac97",
+	.match		= ac97_bus_match,
+#ifdef CONFIG_PM
+	.suspend	= ac97_bus_suspend,
+	.resume		= ac97_bus_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init ac97_bus_init(void)
+{
+	return bus_register(&ac97_bus_type);
+}
+
+subsys_initcall(ac97_bus_init);
+
+static void __exit ac97_bus_exit(void)
+{
+	bus_unregister(&ac97_bus_type);
+}
+
+module_exit(ac97_bus_exit);
+
+EXPORT_SYMBOL(ac97_bus_type);
+
+MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/pci/cs46xx/dsp_spos.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs46xx/dsp_spos.c	2007-06-05 17:45:41.000000000 -0400
@@ -868,35 +868,23 @@
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
-	if (ins->proc_sym_info_entry) {
-		snd_info_unregister(ins->proc_sym_info_entry);
-		ins->proc_sym_info_entry = NULL;
-	}
-  
-	if (ins->proc_modules_info_entry) {
-		snd_info_unregister(ins->proc_modules_info_entry);
-		ins->proc_modules_info_entry = NULL;
-	}
- 
-	if (ins->proc_parameter_dump_info_entry) {
-		snd_info_unregister(ins->proc_parameter_dump_info_entry);
-		ins->proc_parameter_dump_info_entry = NULL;
-	}
-  
-	if (ins->proc_sample_dump_info_entry) {
-		snd_info_unregister(ins->proc_sample_dump_info_entry);
-		ins->proc_sample_dump_info_entry = NULL;
-	}
-  
-	if (ins->proc_scb_info_entry) {
-		snd_info_unregister(ins->proc_scb_info_entry);
-		ins->proc_scb_info_entry = NULL;
-	}
-  
-	if (ins->proc_task_info_entry) {
-		snd_info_unregister(ins->proc_task_info_entry);
-		ins->proc_task_info_entry = NULL;
-	}
+	snd_info_free_entry(ins->proc_sym_info_entry);
+	ins->proc_sym_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_modules_info_entry);
+	ins->proc_modules_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_parameter_dump_info_entry);
+	ins->proc_parameter_dump_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_sample_dump_info_entry);
+	ins->proc_sample_dump_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_scb_info_entry);
+	ins->proc_scb_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_task_info_entry);
+	ins->proc_task_info_entry = NULL;
 
 	mutex_lock(&chip->spos_mutex);
 	for (i = 0; i < ins->nscb; ++i) {
@@ -905,10 +893,8 @@
 	}
 	mutex_unlock(&chip->spos_mutex);
 
-	if (ins->proc_dsp_dir) {
-		snd_info_unregister (ins->proc_dsp_dir);
-		ins->proc_dsp_dir = NULL;
-	}
+	snd_info_free_entry(ins->proc_dsp_dir);
+	ins->proc_dsp_dir = NULL;
 
 	return 0;
 }
--- linux-2.6.18.noarch/sound/pci/cs46xx/dsp_spos_scb_lib.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs46xx/dsp_spos_scb_lib.c	2007-06-05 17:45:41.000000000 -0400
@@ -233,7 +233,7 @@
 
 		snd_printdd("cs46xx_dsp_proc_free_scb_desc: freeing %s\n",scb->scb_name);
 
-		snd_info_unregister(scb->proc_info);
+		snd_info_free_entry(scb->proc_info);
 		scb->proc_info = NULL;
 
 		snd_assert (scb_info != NULL, return);
--- linux-2.6.18.noarch/sound/pci/cs46xx/cs46xx_lib.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs46xx/cs46xx_lib.c	2007-06-05 17:45:41.000000000 -0400
@@ -3687,8 +3687,10 @@
 	/* disable CLKRUN */
 	chip->active_ctrl(chip, -chip->amplifier);
 	chip->amplifier = amp_saved; /* restore the status */
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -3698,9 +3700,16 @@
 	struct snd_cs46xx *chip = card->private_data;
 	int amp_saved;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "cs46xx: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
+
 	amp_saved = chip->amplifier;
 	chip->amplifier = 0;
 	chip->active_ctrl(chip, 1); /* force to on */
--- linux-2.6.18.noarch/sound/pci/hda/hda_codec.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_codec.c	2007-06-05 17:46:40.000000000 -0400
@@ -26,9 +26,11 @@
 #include <linux/pci.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
+#include <linux/workqueue.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include <sound/asoundef.h>
+#include <sound/tlv.h>
 #include <sound/initval.h>
 #include "hda_local.h"
 
@@ -50,8 +52,11 @@
 /* codec vendor labels */
 static struct hda_vendor_id hda_vendor_ids[] = {
 	{ 0x10ec, "Realtek" },
+	{ 0x1057, "Motorola" },
+	{ 0x1106, "VIA" },
 	{ 0x11d4, "Analog Devices" },
 	{ 0x13f6, "C-Media" },
+	{ 0x14f1, "Conexant" },
 	{ 0x434d, "C-Media" },
 	{ 0x8384, "SigmaTel" },
 	{} /* terminator */
@@ -259,7 +264,7 @@
 	unsol->queue[wp] = res;
 	unsol->queue[wp + 1] = res_ex;
 
-	queue_work(unsol->workq, &unsol->work);
+	schedule_work(&unsol->work);
 
 	return 0;
 }
@@ -269,10 +274,11 @@
 /*
  * process queueud unsolicited events
  */
-static void process_unsol_events(void *data)
+static void process_unsol_events(struct work_struct *work)
 {
-	struct hda_bus *bus = data;
-	struct hda_bus_unsolicited *unsol = bus->unsol;
+	struct hda_bus_unsolicited *unsol =
+		container_of(work, struct hda_bus_unsolicited, work);
+	struct hda_bus *bus = unsol->bus;
 	struct hda_codec *codec;
 	unsigned int rp, caddr, res;
 
@@ -305,13 +311,8 @@
 		snd_printk(KERN_ERR "hda_codec: can't allocate unsolicited queue\n");
 		return -ENOMEM;
 	}
-	unsol->workq = create_singlethread_workqueue("hda_codec");
-	if (! unsol->workq) {
-		snd_printk(KERN_ERR "hda_codec: can't create workqueue\n");
-		kfree(unsol);
-		return -ENOMEM;
-	}
-	INIT_WORK(&unsol->work, process_unsol_events, bus);
+	INIT_WORK(&unsol->work, process_unsol_events, &unsol);
+	unsol->bus = bus;
 	bus->unsol = unsol;
 	return 0;
 }
@@ -328,7 +329,7 @@
 	if (! bus)
 		return 0;
 	if (bus->unsol) {
-		destroy_workqueue(bus->unsol->workq);
+		flush_scheduled_work();
 		kfree(bus->unsol);
 	}
 	list_for_each_safe(p, n, &bus->codec_list) {
@@ -841,6 +842,31 @@
 	return change;
 }
 
+int snd_hda_mixer_amp_tlv(struct snd_kcontrol *kcontrol, int op_flag,
+			  unsigned int size, unsigned int __user *_tlv)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = get_amp_nid(kcontrol);
+	int dir = get_amp_direction(kcontrol);
+	u32 caps, val1, val2;
+
+	if (size < 4 * sizeof(unsigned int))
+		return -ENOMEM;
+	caps = query_amp_caps(codec, nid, dir);
+	val2 = (((caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT) + 1) * 25;
+	val1 = -((caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT);
+	val1 = ((int)val1) * ((int)val2);
+	if (put_user(SNDRV_CTL_TLVT_DB_SCALE, _tlv))
+		return -EFAULT;
+	if (put_user(2 * sizeof(unsigned int), _tlv + 1))
+		return -EFAULT;
+	if (put_user(val1, _tlv + 2))
+		return -EFAULT;
+	if (put_user(val2, _tlv + 3))
+		return -EFAULT;
+	return 0;
+}
+
 /* switch */
 int snd_hda_mixer_amp_switch_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -1337,9 +1363,6 @@
 	{ 176400, SNDRV_PCM_RATE_176400, 0x5800 },/* 4 x 44 */
 	{ 192000, SNDRV_PCM_RATE_192000, 0x1800 }, /* 4 x 48 */
 
-	/* not autodetected value */
-	{ 9600, SNDRV_PCM_RATE_KNOT, 0x0400 }, /* 1/5 x 48 */
-
 	{ 0 } /* terminator */
 };
 
@@ -1477,10 +1500,10 @@
 				formats |= SNDRV_PCM_FMTBIT_S32_LE;
 				if (val & AC_SUPPCM_BITS_32)
 					bps = 32;
-				else if (val & AC_SUPPCM_BITS_20)
-					bps = 20;
 				else if (val & AC_SUPPCM_BITS_24)
 					bps = 24;
+				else if (val & AC_SUPPCM_BITS_20)
+					bps = 20;
 			}
 		}
 		else if (streams == AC_SUPFMT_FLOAT32) { /* should be exclusive */
@@ -1687,6 +1710,8 @@
 /**
  * snd_hda_check_board_config - compare the current codec with the config table
  * @codec: the HDA codec
+ * @num_configs: number of config enums
+ * @models: array of model name strings
  * @tbl: configuration table, terminated by null entries
  *
  * Compares the modelname or PCI subsystem id of the current codec with the
@@ -1695,33 +1720,44 @@
  *
  * If no entries are matching, the function returns a negative value.
  */
-int snd_hda_check_board_config(struct hda_codec *codec, const struct hda_board_config *tbl)
-{
-	const struct hda_board_config *c;
-
-	if (codec->bus->modelname) {
-		for (c = tbl; c->modelname || c->pci_subvendor; c++) {
-			if (c->modelname &&
-			    ! strcmp(codec->bus->modelname, c->modelname)) {
-				snd_printd(KERN_INFO "hda_codec: model '%s' is selected\n", c->modelname);
-				return c->config;
+int snd_hda_check_board_config(struct hda_codec *codec,
+			       int num_configs, const char **models,
+			       const struct snd_pci_quirk *tbl)
+{
+	if (codec->bus->modelname && models) {
+		int i;
+		for (i = 0; i < num_configs; i++) {
+			if (models[i] &&
+			    !strcmp(codec->bus->modelname, models[i])) {
+				snd_printd(KERN_INFO "hda_codec: model '%s' is "
+					   "selected\n", models[i]);
+				return i;
 			}
 		}
 	}
 
-	if (codec->bus->pci) {
-		u16 subsystem_vendor, subsystem_device;
-		pci_read_config_word(codec->bus->pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
-		pci_read_config_word(codec->bus->pci, PCI_SUBSYSTEM_ID, &subsystem_device);
-		for (c = tbl; c->modelname || c->pci_subvendor; c++) {
-			if (c->pci_subvendor == subsystem_vendor &&
-			    (! c->pci_subdevice /* all match */||
-			     (c->pci_subdevice == subsystem_device))) {
-				snd_printdd(KERN_INFO "hda_codec: PCI %x:%x, codec config %d is selected\n",
-					    subsystem_vendor, subsystem_device, c->config);
-				return c->config;
-			}
-		}
+	if (!codec->bus->pci || !tbl)
+		return -1;
+
+	tbl = snd_pci_quirk_lookup(codec->bus->pci, tbl);
+	if (!tbl)
+		return -1;
+	if (tbl->value >= 0 && tbl->value < num_configs) {
+#ifdef CONFIG_SND_DEBUG_DETECT
+		char tmp[10];
+		const char *model = NULL;
+		if (models)
+			model = models[tbl->value];
+		if (!model) {
+			sprintf(tmp, "#%d", tbl->value);
+			model = tmp;
+		}
+		snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
+			    "for config %x:%x (%s)\n",
+			    model, tbl->subvendor, tbl->subdevice,
+			    (tbl->name ? tbl->name : "Unknown device"));
+#endif
+		return tbl->value;
 	}
 	return -1;
 }
@@ -1916,7 +1952,7 @@
 
 	/* front */
 	snd_hda_codec_setup_stream(codec, nids[HDA_FRONT], stream_tag, 0, format);
-	if (mout->hp_nid)
+	if (mout->hp_nid && mout->hp_nid != nids[HDA_FRONT])
 		/* headphone out will just decode front left/right (stereo) */
 		snd_hda_codec_setup_stream(codec, mout->hp_nid, stream_tag, 0, format);
 	/* extra outputs copied from front */
@@ -1984,7 +2020,7 @@
  * in the order of front, rear, CLFE, side, ...
  *
  * If more extra outputs (speaker and headphone) are found, the pins are
- * assisnged to hp_pin and speaker_pins[], respectively.  If no line-out jack
+ * assisnged to hp_pins[] and speaker_pins[], respectively.  If no line-out jack
  * is detected, one of speaker of HP pins is assigned as the primary
  * output, i.e. to line_out_pins[0].  So, line_outs is always positive
  * if any analog output exists.
@@ -2046,14 +2082,26 @@
 			cfg->speaker_outs++;
 			break;
 		case AC_JACK_HP_OUT:
-			cfg->hp_pin = nid;
+			if (cfg->hp_outs >= ARRAY_SIZE(cfg->hp_pins))
+				continue;
+			cfg->hp_pins[cfg->hp_outs] = nid;
+			cfg->hp_outs++;
 			break;
-		case AC_JACK_MIC_IN:
-			if (loc == AC_JACK_LOC_FRONT)
-				cfg->input_pins[AUTO_PIN_FRONT_MIC] = nid;
-			else
-				cfg->input_pins[AUTO_PIN_MIC] = nid;
+		case AC_JACK_MIC_IN: {
+			int preferred, alt;
+			if (loc == AC_JACK_LOC_FRONT) {
+				preferred = AUTO_PIN_FRONT_MIC;
+				alt = AUTO_PIN_MIC;
+			} else {
+				preferred = AUTO_PIN_MIC;
+				alt = AUTO_PIN_FRONT_MIC;
+			}
+			if (!cfg->input_pins[preferred])
+				cfg->input_pins[preferred] = nid;
+			else if (!cfg->input_pins[alt])
+				cfg->input_pins[alt] = nid;
 			break;
+		}
 		case AC_JACK_LINE_IN:
 			if (loc == AC_JACK_LOC_FRONT)
 				cfg->input_pins[AUTO_PIN_FRONT_LINE] = nid;
@@ -2119,8 +2167,10 @@
 		   cfg->speaker_outs, cfg->speaker_pins[0],
 		   cfg->speaker_pins[1], cfg->speaker_pins[2],
 		   cfg->speaker_pins[3], cfg->speaker_pins[4]);
-	snd_printd("   hp=0x%x, dig_out=0x%x, din_in=0x%x\n",
-		   cfg->hp_pin, cfg->dig_out_pin, cfg->dig_in_pin);
+	snd_printd("   hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+		   cfg->hp_outs, cfg->hp_pins[0],
+		   cfg->hp_pins[1], cfg->hp_pins[2],
+		   cfg->hp_pins[3], cfg->hp_pins[4]);
 	snd_printd("   inputs: mic=0x%x, fmic=0x%x, line=0x%x, fline=0x%x,"
 		   " cd=0x%x, aux=0x%x\n",
 		   cfg->input_pins[AUTO_PIN_MIC],
@@ -2141,10 +2191,12 @@
 			       sizeof(cfg->speaker_pins));
 			cfg->speaker_outs = 0;
 			memset(cfg->speaker_pins, 0, sizeof(cfg->speaker_pins));
-		} else if (cfg->hp_pin) {
-			cfg->line_outs = 1;
-			cfg->line_out_pins[0] = cfg->hp_pin;
-			cfg->hp_pin = 0;
+		} else if (cfg->hp_outs) {
+			cfg->line_outs = cfg->hp_outs;
+			memcpy(cfg->line_out_pins, cfg->hp_pins,
+			       sizeof(cfg->hp_pins));
+			cfg->hp_outs = 0;
+			memset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));
 		}
 	}
 
--- linux-2.6.18.noarch/sound/pci/hda/hda_proc.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_proc.c	2007-06-05 17:46:40.000000000 -0400
@@ -45,17 +45,16 @@
 	if (names[wid_value])
 		return names[wid_value];
 	else
-		return "UNKOWN Widget";
+		return "UNKNOWN Widget";
 }
 
 static void print_amp_caps(struct snd_info_buffer *buffer,
 			   struct hda_codec *codec, hda_nid_t nid, int dir)
 {
 	unsigned int caps;
-	if (dir == HDA_OUTPUT)
-		caps = snd_hda_param_read(codec, nid, AC_PAR_AMP_OUT_CAP);
-	else
-		caps = snd_hda_param_read(codec, nid, AC_PAR_AMP_IN_CAP);
+	caps = snd_hda_param_read(codec, nid,
+				  dir == HDA_OUTPUT ?
+				    AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);
 	if (caps == -1 || caps == 0) {
 		snd_iprintf(buffer, "N/A\n");
 		return;
@@ -74,10 +73,7 @@
 	unsigned int val;
 	int i;
 
-	if (dir == HDA_OUTPUT)
-		dir = AC_AMP_GET_OUTPUT;
-	else
-		dir = AC_AMP_GET_INPUT;
+	dir = dir == HDA_OUTPUT ? AC_AMP_GET_OUTPUT : AC_AMP_GET_INPUT;
 	for (i = 0; i < indices; i++) {
 		snd_iprintf(buffer, " [");
 		if (stereo) {
@@ -92,6 +88,48 @@
 	snd_iprintf(buffer, "\n");
 }
 
+static void print_pcm_rates(struct snd_info_buffer *buffer, unsigned int pcm)
+{
+	static unsigned int rates[] = {
+		8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200,
+		96000, 176400, 192000, 384000
+	};
+	int i;
+
+	pcm &= AC_SUPPCM_RATES;
+	snd_iprintf(buffer, "    rates [0x%x]:", pcm);
+	for (i = 0; i < ARRAY_SIZE(rates); i++) 
+		if (pcm & (1 << i))
+			snd_iprintf(buffer, " %d", rates[i]);
+	snd_iprintf(buffer, "\n");
+}
+
+static void print_pcm_bits(struct snd_info_buffer *buffer, unsigned int pcm)
+{
+	static unsigned int bits[] = { 8, 16, 20, 24, 32 };
+	int i;
+
+	pcm = (pcm >> 16) & 0xff;
+	snd_iprintf(buffer, "    bits [0x%x]:", pcm);
+	for (i = 0; i < ARRAY_SIZE(bits); i++)
+		if (pcm & (1 << i))
+			snd_iprintf(buffer, " %d", bits[i]);
+	snd_iprintf(buffer, "\n");
+}
+
+static void print_pcm_formats(struct snd_info_buffer *buffer,
+			      unsigned int streams)
+{
+	snd_iprintf(buffer, "    formats [0x%x]:", streams & 0xf);
+	if (streams & AC_SUPFMT_PCM)
+		snd_iprintf(buffer, " PCM");
+	if (streams & AC_SUPFMT_FLOAT32)
+		snd_iprintf(buffer, " FLOAT");
+	if (streams & AC_SUPFMT_AC3)
+		snd_iprintf(buffer, " AC3");
+	snd_iprintf(buffer, "\n");
+}
+
 static void print_pcm_caps(struct snd_info_buffer *buffer,
 			   struct hda_codec *codec, hda_nid_t nid)
 {
@@ -101,8 +139,9 @@
 		snd_iprintf(buffer, "N/A\n");
 		return;
 	}
-	snd_iprintf(buffer, "rates 0x%03x, bits 0x%02x, types 0x%x\n",
-		    pcm & AC_SUPPCM_RATES, (pcm >> 16) & 0xff, stream & 0xf);
+	print_pcm_rates(buffer, pcm);
+	print_pcm_bits(buffer, pcm);
+	print_pcm_formats(buffer, stream);
 }
 
 static const char *get_jack_location(u32 cfg)
@@ -214,7 +253,7 @@
 	snd_iprintf(buffer, "Revision Id: 0x%x\n", codec->revision_id);
 	if (! codec->afg)
 		return;
-	snd_iprintf(buffer, "Default PCM: ");
+	snd_iprintf(buffer, "Default PCM:\n");
 	print_pcm_caps(buffer, codec, codec->afg);
 	snd_iprintf(buffer, "Default Amp-In caps: ");
 	print_amp_caps(buffer, codec, codec->afg, HDA_INPUT);
@@ -282,7 +321,7 @@
 
 		if ((wid_type == AC_WID_AUD_OUT || wid_type == AC_WID_AUD_IN) &&
 		    (wid_caps & AC_WCAP_FORMAT_OVRD)) {
-			snd_iprintf(buffer, "  PCM: ");
+			snd_iprintf(buffer, "  PCM:\n");
 			print_pcm_caps(buffer, codec, nid);
 		}
 
--- linux-2.6.18.noarch/sound/pci/hda/hda_generic.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_generic.c	2007-06-05 17:46:40.000000000 -0400
@@ -46,11 +46,18 @@
 };
 
 /* patch-specific record */
+
+#define MAX_PCM_VOLS	2
+struct pcm_vol {
+	struct hda_gnode *node;	/* Node for PCM volume */
+	unsigned int index;	/* connection of PCM volume */
+};
+
 struct hda_gspec {
 	struct hda_gnode *dac_node[2];	/* DAC node */
 	struct hda_gnode *out_pin_node[2];	/* Output pin (Line-Out) node */
-	struct hda_gnode *pcm_vol_node[2];	/* Node for PCM volume */
-	unsigned int pcm_vol_index[2];	/* connection of PCM volume */
+	struct pcm_vol pcm_vol[MAX_PCM_VOLS];	/* PCM volumes */
+	unsigned int pcm_vol_nodes;	/* number of PCM volumes */
 
 	struct hda_gnode *adc_node;	/* ADC node */
 	struct hda_gnode *cap_vol_node;	/* Node for capture volume */
@@ -285,9 +292,11 @@
 			return node == spec->dac_node[dac_idx];
 		}
 		spec->dac_node[dac_idx] = node;
-		if (node->wid_caps & AC_WCAP_OUT_AMP) {
-			spec->pcm_vol_node[dac_idx] = node;
-			spec->pcm_vol_index[dac_idx] = 0;
+		if ((node->wid_caps & AC_WCAP_OUT_AMP) &&
+		    spec->pcm_vol_nodes < MAX_PCM_VOLS) {
+			spec->pcm_vol[spec->pcm_vol_nodes].node = node;
+			spec->pcm_vol[spec->pcm_vol_nodes].index = 0;
+			spec->pcm_vol_nodes++;
 		}
 		return 1; /* found */
 	}
@@ -307,13 +316,16 @@
 				select_input_connection(codec, node, i);
 			unmute_input(codec, node, i);
 			unmute_output(codec, node);
-			if (! spec->pcm_vol_node[dac_idx]) {
-				if (node->wid_caps & AC_WCAP_IN_AMP) {
-					spec->pcm_vol_node[dac_idx] = node;
-					spec->pcm_vol_index[dac_idx] = i;
-				} else if (node->wid_caps & AC_WCAP_OUT_AMP) {
-					spec->pcm_vol_node[dac_idx] = node;
-					spec->pcm_vol_index[dac_idx] = 0;
+			if (spec->dac_node[dac_idx] &&
+			    spec->pcm_vol_nodes < MAX_PCM_VOLS &&
+			    !(spec->dac_node[dac_idx]->wid_caps &
+			      AC_WCAP_OUT_AMP)) {
+				if ((node->wid_caps & AC_WCAP_IN_AMP) ||
+				    (node->wid_caps & AC_WCAP_OUT_AMP)) {
+					int n = spec->pcm_vol_nodes;
+					spec->pcm_vol[n].node = node;
+					spec->pcm_vol[n].index = i;
+					spec->pcm_vol_nodes++;
 				}
 			}
 			return 1;
@@ -370,7 +382,9 @@
 			/* set PIN-Out enable */
 			snd_hda_codec_write(codec, node->nid, 0,
 					    AC_VERB_SET_PIN_WIDGET_CONTROL,
-					    AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN);
+					    AC_PINCTL_OUT_EN |
+					    ((node->pin_caps & AC_PINCAP_HP_DRV) ?
+					     AC_PINCTL_HP_EN : 0));
 			return node;
 		}
 	}
@@ -461,14 +475,20 @@
 			return "Front Line";
 		return "Line";
 	case AC_JACK_CD:
+#if 0
 		if (pinctl)
 			*pinctl |= AC_PINCTL_VREF_GRD;
+#endif
 		return "CD";
 	case AC_JACK_AUX:
 		if ((location & 0x0f) == AC_JACK_LOC_FRONT)
 			return "Front Aux";
 		return "Aux";
 	case AC_JACK_MIC_IN:
+		if (pinctl &&
+		    (node->pin_caps &
+		     (AC_PINCAP_VREF_80 << AC_PINCAP_VREF_SHIFT)))
+			*pinctl |= AC_PINCTL_VREF_80;
 		if ((location & 0x0f) == AC_JACK_LOC_FRONT)
 			return "Front Mic";
 		return "Mic";
@@ -556,6 +576,29 @@
 	return 1; /* found */
 }
 
+/* add a capture source element */
+static void add_cap_src(struct hda_gspec *spec, int idx)
+{
+	struct hda_input_mux_item *csrc;
+	char *buf;
+	int num, ocap;
+
+	num = spec->input_mux.num_items;
+	csrc = &spec->input_mux.items[num];
+	buf = spec->cap_labels[num];
+	for (ocap = 0; ocap < num; ocap++) {
+		if (! strcmp(buf, spec->cap_labels[ocap])) {
+			/* same label already exists,
+			 * put the index number to be unique
+			 */
+			sprintf(buf, "%s %d", spec->cap_labels[ocap], num);
+			break;
+		}
+	}
+	csrc->index = idx;
+	spec->input_mux.num_items++;
+}
+
 /*
  * parse input
  */
@@ -576,28 +619,26 @@
 	 * if it reaches to a proper input PIN, add the path as the
 	 * input path.
 	 */
+	/* first, check the direct connections to PIN widgets */
 	for (i = 0; i < adc_node->nconns; i++) {
 		node = hda_get_node(spec, adc_node->conn_list[i]);
-		if (! node)
-			continue;
-		err = parse_adc_sub_nodes(codec, spec, node);
-		if (err < 0)
-			return err;
-		else if (err > 0) {
-			struct hda_input_mux_item *csrc = &spec->input_mux.items[spec->input_mux.num_items];
-			char *buf = spec->cap_labels[spec->input_mux.num_items];
-			int ocap;
-			for (ocap = 0; ocap < spec->input_mux.num_items; ocap++) {
-				if (! strcmp(buf, spec->cap_labels[ocap])) {
-					/* same label already exists,
-					 * put the index number to be unique
-					 */
-					sprintf(buf, "%s %d", spec->cap_labels[ocap],
-						spec->input_mux.num_items);
-				}
-			}
-			csrc->index = i;
-			spec->input_mux.num_items++;
+		if (node && node->type == AC_WID_PIN) {
+			err = parse_adc_sub_nodes(codec, spec, node);
+			if (err < 0)
+				return err;
+			else if (err > 0)
+				add_cap_src(spec, i);
+		}
+	}
+	/* ... then check the rests, more complicated connections */
+	for (i = 0; i < adc_node->nconns; i++) {
+		node = hda_get_node(spec, adc_node->conn_list[i]);
+		if (node && node->type != AC_WID_PIN) {
+			err = parse_adc_sub_nodes(codec, spec, node);
+			if (err < 0)
+				return err;
+			else if (err > 0)
+				add_cap_src(spec, i);
 		}
 	}
 
@@ -647,9 +688,6 @@
 /*
  * create mixer controls if possible
  */
-#define DIR_OUT		0x1
-#define DIR_IN		0x2
-
 static int create_mixer(struct hda_codec *codec, struct hda_gnode *node,
 			unsigned int index, const char *type, const char *dir_sfx)
 {
@@ -722,49 +760,97 @@
 /*
  * build output mixer controls
  */
-static int build_output_controls(struct hda_codec *codec)
+static int create_output_mixers(struct hda_codec *codec, const char **names)
 {
 	struct hda_gspec *spec = codec->spec;
-	static const char *types[2] = { "Master", "Headphone" };
 	int i, err;
 
-	for (i = 0; i < 2 && spec->pcm_vol_node[i]; i++) {
-		err = create_mixer(codec, spec->pcm_vol_node[i],
-				   spec->pcm_vol_index[i],
-				   types[i], "Playback");
+	for (i = 0; i < spec->pcm_vol_nodes; i++) {
+		err = create_mixer(codec, spec->pcm_vol[i].node,
+				   spec->pcm_vol[i].index,
+				   names[i], "Playback");
 		if (err < 0)
 			return err;
 	}
 	return 0;
 }
 
+static int build_output_controls(struct hda_codec *codec)
+{
+	struct hda_gspec *spec = codec->spec;
+	static const char *types_speaker[] = { "Speaker", "Headphone" };
+	static const char *types_line[] = { "Front", "Headphone" };
+
+	switch (spec->pcm_vol_nodes) {
+	case 1:
+		return create_mixer(codec, spec->pcm_vol[0].node,
+				    spec->pcm_vol[0].index,
+				    "Master", "Playback");
+	case 2:
+		if (defcfg_type(spec->out_pin_node[0]) == AC_JACK_SPEAKER)
+			return create_output_mixers(codec, types_speaker);
+		else
+			return create_output_mixers(codec, types_line);
+	}
+	return 0;
+}
+
 /* create capture volume/switch */
 static int build_input_controls(struct hda_codec *codec)
 {
 	struct hda_gspec *spec = codec->spec;
 	struct hda_gnode *adc_node = spec->adc_node;
-	int err;
+	int i, err;
+	static struct snd_kcontrol_new cap_sel = {
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = capture_source_info,
+		.get = capture_source_get,
+		.put = capture_source_put,
+	};
 
-	if (! adc_node)
+	if (! adc_node || ! spec->input_mux.num_items)
 		return 0; /* not found */
 
+	spec->cur_cap_src = 0;
+	select_input_connection(codec, adc_node,
+				spec->input_mux.items[0].index);
+
 	/* create capture volume and switch controls if the ADC has an amp */
-	err = create_mixer(codec, adc_node, 0, NULL, "Capture");
+	/* do we have only a single item? */
+	if (spec->input_mux.num_items == 1) {
+		err = create_mixer(codec, adc_node,
+				   spec->input_mux.items[0].index,
+				   NULL, "Capture");
+		if (err < 0)
+			return err;
+		return 0;
+	}
 
 	/* create input MUX if multiple sources are available */
-	if (spec->input_mux.num_items > 1) {
-		static struct snd_kcontrol_new cap_sel = {
-			.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-			.name = "Capture Source",
-			.info = capture_source_info,
-			.get = capture_source_get,
-			.put = capture_source_put,
-		};
-		if ((err = snd_ctl_add(codec->bus->card, snd_ctl_new1(&cap_sel, codec))) < 0)
+	if ((err = snd_ctl_add(codec->bus->card,
+			       snd_ctl_new1(&cap_sel, codec))) < 0)
+		return err;
+
+	/* no volume control? */
+	if (! (adc_node->wid_caps & AC_WCAP_IN_AMP) ||
+	    ! (adc_node->amp_in_caps & AC_AMPCAP_NUM_STEPS))
+		return 0;
+
+	for (i = 0; i < spec->input_mux.num_items; i++) {
+		struct snd_kcontrol_new knew;
+		char name[32];
+		sprintf(name, "%s Capture Volume",
+			spec->input_mux.items[i].label);
+		knew = (struct snd_kcontrol_new)
+			HDA_CODEC_VOLUME(name, adc_node->nid,
+					 spec->input_mux.items[i].index,
+					 HDA_INPUT);
+		if ((err = snd_ctl_add(codec->bus->card,
+				       snd_ctl_new1(&knew, codec))) < 0)
 			return err;
-		spec->cur_cap_src = 0;
-		select_input_connection(codec, adc_node, spec->input_mux.items[0].index);
 	}
+
 	return 0;
 }
 
--- linux-2.6.18.noarch/sound/pci/hda/Makefile.orig	2007-06-05 16:07:57.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/Makefile	2007-06-05 17:46:40.000000000 -0400
@@ -1,5 +1,14 @@
 snd-hda-intel-objs := hda_intel.o
-snd-hda-codec-objs := hda_codec.o hda_generic.o patch_realtek.o patch_cmedia.o patch_analog.o patch_sigmatel.o patch_si3054.o patch_atihdmi.o
+snd-hda-codec-objs := hda_codec.o \
+	hda_generic.o \
+	patch_realtek.o \
+	patch_cmedia.o \
+	patch_analog.o \
+	patch_sigmatel.o \
+	patch_si3054.o \
+	patch_atihdmi.o \
+	patch_conexant.o \
+	patch_via.o
 ifdef CONFIG_PROC_FS
 snd-hda-codec-objs += hda_proc.o
 endif
--- linux-2.6.18.noarch/sound/pci/hda/hda_intel.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_intel.c	2007-06-06 12:37:55.000000000 -0400
@@ -55,6 +55,7 @@
 static int position_fix;
 static int probe_mask = -1;
 static int single_cmd;
+static int enable_msi;
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for Intel HD audio interface.");
@@ -68,6 +69,8 @@
 MODULE_PARM_DESC(probe_mask, "Bitmask to probe codecs (default = -1).");
 module_param(single_cmd, bool, 0444);
 MODULE_PARM_DESC(single_cmd, "Use single command to communicate with codecs (for debugging only).");
+module_param(enable_msi, int, 0);
+MODULE_PARM_DESC(enable_msi, "Enable Message Signaled Interrupt (MSI)");
 
 
 /* just for backward compatibility */
@@ -84,6 +87,7 @@
 			 "{ATI, SB450},"
 			 "{ATI, SB600},"
 			 "{ATI, RS600},"
+			 "{ATI, RS690},"
 			 "{VIA, VT8251},"
 			 "{VIA, VT8237A},"
 			 "{SiS, SIS966},"
@@ -195,7 +199,6 @@
 
 /* STATESTS int mask: SD2,SD1,SD0 */
 #define STATESTS_INT_MASK	0x07
-#define AZX_MAX_CODECS		4
 
 /* SD_CTL bits */
 #define SD_CTL_STREAM_RESET	0x01	/* stream reset bit */
@@ -253,7 +256,7 @@
 struct azx_dev {
 	u32 *bdl;			/* virtual address of the BDL */
 	dma_addr_t bdl_addr;		/* physical address of the BDL */
-	volatile u32 *posbuf;			/* position buffer pointer */
+	u32 *posbuf;			/* position buffer pointer */
 
 	unsigned int bufsize;		/* size of the play buffer in bytes */
 	unsigned int fragsize;		/* size of each period in bytes */
@@ -272,8 +275,8 @@
 	/* for sanity check of position buffer */
 	unsigned int period_intr;
 
-	unsigned int opened: 1;
-	unsigned int running: 1;
+	unsigned int opened :1;
+	unsigned int running :1;
 };
 
 /* CORB/RIRB */
@@ -331,8 +334,10 @@
 
 	/* flags */
 	int position_fix;
-	unsigned int initialized: 1;
-	unsigned int single_cmd: 1;
+	unsigned int initialized :1;
+	unsigned int single_cmd :1;
+	unsigned int polling_mode :1;
+	unsigned int msi :1;
 };
 
 /* driver types */
@@ -393,6 +398,7 @@
  */
 #define upper_32bit(addr) (sizeof(addr) > 4 ? (u32)((addr) >> 32) : (u32)0)
 
+static int azx_acquire_irq(struct azx *chip, int do_disconnect);
 
 /*
  * Interface for HD codec
@@ -517,23 +523,48 @@
 static unsigned int azx_rirb_get_response(struct hda_codec *codec)
 {
 	struct azx *chip = codec->bus->private_data;
-	int timeout = 50;
+	unsigned long timeout;
 
-	while (chip->rirb.cmds) {
-		if (! --timeout) {
-			snd_printk(KERN_ERR
-				   "hda_intel: azx_get_response timeout, "
-				   "switching to single_cmd mode...\n");
-			chip->rirb.rp = azx_readb(chip, RIRBWP);
-			chip->rirb.cmds = 0;
-			/* switch to single_cmd mode */
-			chip->single_cmd = 1;
-			azx_free_cmd_io(chip);
-			return -1;
+ again:
+	timeout = jiffies + msecs_to_jiffies(1000);
+	do {
+		if (chip->polling_mode) {
+			spin_lock_irq(&chip->reg_lock);
+			azx_update_rirb(chip);
+			spin_unlock_irq(&chip->reg_lock);
 		}
-		msleep(1);
+		if (! chip->rirb.cmds)
+			return chip->rirb.res; /* the last value */
+		schedule_timeout(1);
+	} while (time_after_eq(timeout, jiffies));
+
+	if (chip->msi) {
+		snd_printk(KERN_WARNING "hda_intel: No response from codec, "
+			   "disabling MSI...\n");
+		free_irq(chip->irq, chip);
+		chip->irq = -1;
+		pci_disable_msi(chip->pci);
+		chip->msi = 0;
+		if (azx_acquire_irq(chip, 1) < 0)
+			return -1;
+		goto again;
 	}
-	return chip->rirb.res; /* the last value */
+
+	if (!chip->polling_mode) {
+		snd_printk(KERN_WARNING "hda_intel: azx_get_response timeout, "
+			   "switching to polling mode...\n");
+		chip->polling_mode = 1;
+		goto again;
+	}
+
+	snd_printk(KERN_ERR "hda_intel: azx_get_response timeout, "
+		   "switching to single_cmd mode...\n");
+	chip->rirb.rp = azx_readb(chip, RIRBWP);
+	chip->rirb.cmds = 0;
+	/* switch to single_cmd mode */
+	chip->single_cmd = 1;
+	azx_free_cmd_io(chip);
+	return -1;
 }
 
 /*
@@ -643,14 +674,14 @@
 	azx_writeb(chip, GCTL, azx_readb(chip, GCTL) | ICH6_GCTL_RESET);
 
 	count = 50;
-	while (! azx_readb(chip, GCTL) && --count)
+	while (!azx_readb(chip, GCTL) && --count)
 		msleep(1);
 
-	/* Brent Chartrand said to wait >= 540us for codecs to intialize */
+	/* Brent Chartrand said to wait >= 540us for codecs to initialize */
 	msleep(1);
 
 	/* check to see if controller is ready */
-	if (! azx_readb(chip, GCTL)) {
+	if (!azx_readb(chip, GCTL)) {
 		snd_printd("azx_reset: controller not ready!\n");
 		return -EBUSY;
 	}
@@ -659,7 +690,7 @@
 	azx_writel(chip, GCTL, azx_readl(chip, GCTL) | ICH6_GCTL_UREN);
 
 	/* detect codecs */
-	if (! chip->codec_mask) {
+	if (!chip->codec_mask) {
 		chip->codec_mask = azx_readw(chip, STATESTS);
 		snd_printdd("codec_mask = 0x%x\n", chip->codec_mask);
 	}
@@ -767,7 +798,7 @@
 	azx_int_enable(chip);
 
 	/* initialize the codec command I/O */
-	if (! chip->single_cmd)
+	if (!chip->single_cmd)
 		azx_init_cmd_io(chip);
 
 	/* program the position buffer */
@@ -934,6 +965,16 @@
  * Codec initialization
  */
 
+static unsigned int azx_max_codecs[] __devinitdata = {
+	[AZX_DRIVER_ICH] = 3,
+	[AZX_DRIVER_ATI] = 4,
+	[AZX_DRIVER_ATIHDMI] = 4,
+	[AZX_DRIVER_VIA] = 3,		/* FIXME: correct? */
+	[AZX_DRIVER_SIS] = 3,		/* FIXME: correct? */
+	[AZX_DRIVER_ULI] = 3,		/* FIXME: correct? */
+	[AZX_DRIVER_NVIDIA] = 3,	/* FIXME: correct? */
+};
+
 static int __devinit azx_codec_create(struct azx *chip, const char *model)
 {
 	struct hda_bus_template bus_temp;
@@ -950,7 +991,7 @@
 		return err;
 
 	codecs = 0;
-	for (c = 0; c < AZX_MAX_CODECS; c++) {
+	for (c = 0; c < azx_max_codecs[chip->driver_type]; c++) {
 		if ((chip->codec_mask & (1 << c)) & probe_mask) {
 			err = snd_hda_codec_new(chip->bus, c, NULL);
 			if (err < 0)
@@ -1000,8 +1041,9 @@
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID |
-				 SNDRV_PCM_INFO_PAUSE /*|*/
-				 /*SNDRV_PCM_INFO_RESUME*/),
+				 /* No full-resume yet implemented */
+				 /* SNDRV_PCM_INFO_RESUME |*/
+				 SNDRV_PCM_INFO_PAUSE),
 	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_48000,
 	.rate_min =		48000,
@@ -1045,6 +1087,10 @@
 	runtime->hw.rates = hinfo->rates;
 	snd_pcm_limit_hw_rates(runtime);
 	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   128);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+				   128);
 	if ((err = hinfo->ops.open(hinfo, apcm->codec, substream)) < 0) {
 		azx_release_device(azx_dev);
 		mutex_unlock(&chip->open_mutex);
@@ -1179,7 +1225,7 @@
 	if (chip->position_fix == POS_FIX_POSBUF ||
 	    chip->position_fix == POS_FIX_AUTO) {
 		/* use the position buffer */
-		pos = *azx_dev->posbuf;
+		pos = le32_to_cpu(*azx_dev->posbuf);
 		if (chip->position_fix == POS_FIX_AUTO &&
 		    azx_dev->period_intr == 1 && ! pos) {
 			printk(KERN_WARNING
@@ -1223,7 +1269,12 @@
 	struct snd_pcm *pcm;
 	struct azx_pcm *apcm;
 
-	snd_assert(cpcm->stream[0].substreams || cpcm->stream[1].substreams, return -EINVAL);
+	/* if no substreams are defined for both playback and capture,
+	 * it's just a placeholder.  ignore it.
+	 */
+	if (!cpcm->stream[0].substreams && !cpcm->stream[1].substreams)
+		return 0;
+
 	snd_assert(cpcm->name, return -EINVAL);
 
 	err = snd_pcm_new(chip->card, cpcm->name, pcm_dev,
@@ -1247,9 +1298,10 @@
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &azx_pcm_ops);
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(chip->pci),
-					      1024 * 64, 1024 * 128);
+					      1024 * 64, 1024 * 1024);
 	chip->pcm[pcm_dev] = pcm;
-	chip->pcm_devs = pcm_dev + 1;
+	if (chip->pcm_devs < pcm_dev + 1)
+		chip->pcm_devs = pcm_dev + 1;
 
 	return 0;
 }
@@ -1327,7 +1379,7 @@
 		struct azx_dev *azx_dev = &chip->azx_dev[i];
 		azx_dev->bdl = (u32 *)(chip->bdl.area + off);
 		azx_dev->bdl_addr = chip->bdl.addr + off;
-		azx_dev->posbuf = (volatile u32 *)(chip->posbuf.area + i * 8);
+		azx_dev->posbuf = (u32 __iomem *)(chip->posbuf.area + i * 8);
 		/* offset: SDI0=0x80, SDI1=0xa0, ... SDO3=0x160 */
 		azx_dev->sd_addr = chip->remap_addr + (0x20 * i + 0x80);
 		/* int mask: SDI0=0x01, SDI1=0x02, ... SDO3=0x80 */
@@ -1340,6 +1392,22 @@
 	return 0;
 }
 
+static int azx_acquire_irq(struct azx *chip, int do_disconnect)
+{
+	if (request_irq(chip->pci->irq, azx_interrupt,
+			chip->msi ? 0 : IRQF_SHARED,
+			"HDA Intel", chip)) {
+		printk(KERN_ERR "hda-intel: unable to grab IRQ %d, "
+		       "disabling device\n", chip->pci->irq);
+		if (do_disconnect)
+			snd_card_disconnect(chip->card);
+		return -1;
+	}
+	chip->irq = chip->pci->irq;
+	pci_intx(chip->pci, !chip->msi);
+	return 0;
+}
+
 
 #ifdef CONFIG_PM
 /*
@@ -1356,8 +1424,16 @@
 		snd_pcm_suspend_all(chip->pcm[i]);
 	snd_hda_suspend(chip->bus, state);
 	azx_free_cmd_io(chip);
+	if (chip->irq >= 0) {
+		synchronize_irq(chip->irq);
+		free_irq(chip->irq, chip);
+		chip->irq = -1;
+	}
+	if (chip->msi)
+		pci_disable_msi(chip->pci);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1366,9 +1442,20 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct azx *chip = card->private_data;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "hda-intel: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
+	if (chip->msi)
+		if (pci_enable_msi(pci) < 0)
+			chip->msi = 0;
+	if (azx_acquire_irq(chip, 1) < 0)
+		return -EIO;
 	azx_init_chip(chip);
 	snd_hda_resume(chip->bus);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
@@ -1398,13 +1485,14 @@
 		/* disable position buffer */
 		azx_writel(chip, DPLBASE, 0);
 		azx_writel(chip, DPUBASE, 0);
-
-		/* wait a little for interrupts to finish */
-		msleep(1);
 	}
 
-	if (chip->irq >= 0)
+	if (chip->irq >= 0) {
+		synchronize_irq(chip->irq);
 		free_irq(chip->irq, (void*)chip);
+	}
+	if (chip->msi)
+		pci_disable_msi(chip->pci);
 	if (chip->remap_addr)
 		iounmap(chip->remap_addr);
 
@@ -1428,6 +1516,31 @@
 }
 
 /*
+ * white/black-listing for position_fix
+ */
+static const struct snd_pci_quirk position_fix_list[] __devinitdata = {
+	SND_PCI_QUIRK(0x1028, 0x01cc, "Dell D820", POS_FIX_NONE),
+	{}
+};
+
+static int __devinit check_position_fix(struct azx *chip, int fix)
+{
+	const struct snd_pci_quirk *q;
+
+	if (fix == POS_FIX_AUTO) {
+		q = snd_pci_quirk_lookup(chip->pci, position_fix_list);
+		if (q) {
+			snd_printdd(KERN_INFO
+				    "hda_intel: position_fix set to %d "
+				    "for device %04x:%04x\n",
+				    q->value, q->subvendor, q->subdevice);
+			return q->value;
+		}
+	}
+	return fix;
+}
+
+/*
  * constructor
  */
 static int __devinit azx_create(struct snd_card *card, struct pci_dev *pci,
@@ -1435,19 +1548,19 @@
 				struct azx **rchip)
 {
 	struct azx *chip;
-	int err = 0;
+	int err;
 	static struct snd_device_ops ops = {
 		.dev_free = azx_dev_free,
 	};
 
 	*rchip = NULL;
 	
-	if ((err = pci_enable_device(pci)) < 0)
+	err = pci_enable_device(pci);
+	if (err < 0)
 		return err;
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
-	
-	if (NULL == chip) {
+	if (!chip) {
 		snd_printk(KERN_ERR SFX "cannot allocate chip\n");
 		pci_disable_device(pci);
 		return -ENOMEM;
@@ -1459,8 +1572,10 @@
 	chip->pci = pci;
 	chip->irq = -1;
 	chip->driver_type = driver_type;
+	chip->msi = enable_msi;
+
+	chip->position_fix = check_position_fix(chip, position_fix);
 
-	chip->position_fix = position_fix;
 	chip->single_cmd = single_cmd;
 
 #if BITS_PER_LONG != 64
@@ -1473,13 +1588,14 @@
 	}
 #endif
 
-	if ((err = pci_request_regions(pci, "ICH HD audio")) < 0) {
+	err = pci_request_regions(pci, "ICH HD audio");
+	if (err < 0) {
 		kfree(chip);
 		pci_disable_device(pci);
 		return err;
 	}
 
-	chip->addr = pci_resource_start(pci,0);
+	chip->addr = pci_resource_start(pci, 0);
 	chip->remap_addr = ioremap_nocache(chip->addr, pci_resource_len(pci,0));
 	if (chip->remap_addr == NULL) {
 		snd_printk(KERN_ERR SFX "ioremap error\n");
@@ -1487,13 +1603,14 @@
 		goto errout;
 	}
 
-	if (request_irq(pci->irq, azx_interrupt, IRQF_DISABLED|IRQF_SHARED,
-			"HDA Intel", (void*)chip)) {
-		snd_printk(KERN_ERR SFX "unable to grab IRQ %d\n", pci->irq);
+	if (chip->msi)
+		if (pci_enable_msi(pci) < 0)
+			chip->msi = 0;
+
+	if (azx_acquire_irq(chip, 0) < 0) {
 		err = -EBUSY;
 		goto errout;
 	}
-	chip->irq = pci->irq;
 
 	pci_set_master(pci);
 	synchronize_irq(chip->irq);
@@ -1520,7 +1637,7 @@
 	}
 	chip->num_streams = chip->playback_streams + chip->capture_streams;
 	chip->azx_dev = kcalloc(chip->num_streams, sizeof(*chip->azx_dev), GFP_KERNEL);
-	if (! chip->azx_dev) {
+	if (!chip->azx_dev) {
 		snd_printk(KERN_ERR "cannot malloc azx_dev\n");
 		goto errout;
 	}
@@ -1551,7 +1668,7 @@
 	chip->initialized = 1;
 
 	/* codec detection */
-	if (! chip->codec_mask) {
+	if (!chip->codec_mask) {
 		snd_printk(KERN_ERR SFX "no codecs found!\n");
 		err = -ENODEV;
 		goto errout;
@@ -1578,16 +1695,16 @@
 {
 	struct snd_card *card;
 	struct azx *chip;
-	int err = 0;
+	int err;
 
 	card = snd_card_new(index, id, THIS_MODULE, 0);
-	if (NULL == card) {
+	if (!card) {
 		snd_printk(KERN_ERR SFX "Error creating card!\n");
 		return -ENOMEM;
 	}
 
-	if ((err = azx_create(card, pci, pci_id->driver_data,
-			      &chip)) < 0) {
+	err = azx_create(card, pci, pci_id->driver_data, &chip);
+	if (err < 0) {
 		snd_card_free(card);
 		return err;
 	}
@@ -1640,11 +1757,18 @@
 	{ 0x1002, 0x437b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ATI }, /* ATI SB450 */
 	{ 0x1002, 0x4383, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ATI }, /* ATI SB600 */
 	{ 0x1002, 0x793b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ATIHDMI }, /* ATI RS600 HDMI */
+	{ 0x1002, 0x7919, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ATIHDMI }, /* ATI RS690 HDMI */
 	{ 0x1106, 0x3288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_VIA }, /* VIA VT8251/VT8237A */
 	{ 0x1039, 0x7502, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_SIS }, /* SIS966 */
 	{ 0x10b9, 0x5461, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_ULI }, /* ULI M5461 */
-	{ 0x10de, 0x026c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA 026c */
-	{ 0x10de, 0x0371, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA 0371 */
+	{ 0x10de, 0x026c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP51 */
+	{ 0x10de, 0x0371, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP55 */
+	{ 0x10de, 0x03e4, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP61 */
+	{ 0x10de, 0x03f0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP61 */
+	{ 0x10de, 0x044a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP65 */
+	{ 0x10de, 0x044b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP65 */
+	{ 0x10de, 0x055c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP67 */
+	{ 0x10de, 0x055d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, AZX_DRIVER_NVIDIA }, /* NVIDIA MCP67 */
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, azx_ids);
--- linux-2.6.18.noarch/sound/pci/hda/patch_si3054.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_si3054.c	2007-06-05 17:46:40.000000000 -0400
@@ -243,7 +243,8 @@
 
 	if((val&SI3054_MEI_READY) != SI3054_MEI_READY) {
 		snd_printk(KERN_ERR "si3054: cannot initialize. EXT MID = %04x\n", val);
-		return -EACCES;
+		/* let's pray that this is no fatal error */
+		/* return -EACCES; */
 	}
 
 	SET_REG(codec, SI3054_GPIO_POLARITY, 0xffff);
@@ -297,7 +298,13 @@
 struct hda_codec_preset snd_hda_preset_si3054[] = {
  	{ .id = 0x163c3055, .name = "Si3054", .patch = patch_si3054 },
  	{ .id = 0x163c3155, .name = "Si3054", .patch = patch_si3054 },
+ 	{ .id = 0x11c11040, .name = "Si3054", .patch = patch_si3054 },
  	{ .id = 0x11c13026, .name = "Si3054", .patch = patch_si3054 },
+ 	{ .id = 0x11c13055, .name = "Si3054", .patch = patch_si3054 },
+ 	{ .id = 0x11c13155, .name = "Si3054", .patch = patch_si3054 },
+ 	{ .id = 0x10573055, .name = "Si3054", .patch = patch_si3054 },
+ 	{ .id = 0x10573057, .name = "Si3054", .patch = patch_si3054 },
+ 	{ .id = 0x10573155, .name = "Si3054", .patch = patch_si3054 },
 	{}
 };
 
--- linux-2.6.18.noarch/sound/pci/hda/patch_conexant.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_conexant.c	2007-06-05 17:46:40.000000000 -0400
@@ -0,0 +1,1414 @@
+/*
+ * HD audio interface patch for Conexant HDA audio codec
+ *
+ * Copyright (c) 2006 Pototskiy Akex <alex.pototskiy@gmail.com>
+ * 		      Takashi Iwai <tiwai@suse.de>
+ * 		      Tobin Davis  <tdavis@dsl-only.net>
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <sound/core.h>
+#include "hda_codec.h"
+#include "hda_local.h"
+
+#define CXT_PIN_DIR_IN              0x00
+#define CXT_PIN_DIR_OUT             0x01
+#define CXT_PIN_DIR_INOUT           0x02
+#define CXT_PIN_DIR_IN_NOMICBIAS    0x03
+#define CXT_PIN_DIR_INOUT_NOMICBIAS 0x04
+
+#define CONEXANT_HP_EVENT	0x37
+#define CONEXANT_MIC_EVENT	0x38
+
+
+
+struct conexant_spec {
+
+	struct snd_kcontrol_new *mixers[5];
+	int num_mixers;
+
+	const struct hda_verb *init_verbs[5];	/* initialization verbs
+						 * don't forget NULL
+						 * termination!
+						 */
+	unsigned int num_init_verbs;
+
+	/* playback */
+	struct hda_multi_out multiout;	/* playback set-up
+					 * max_channels, dacs must be set
+					 * dig_out_nid and hp_nid are optional
+					 */
+	unsigned int cur_eapd;
+	unsigned int hp_present;
+	unsigned int need_dac_fix;
+
+	/* capture */
+	unsigned int num_adc_nids;
+	hda_nid_t *adc_nids;
+	hda_nid_t dig_in_nid;		/* digital-in NID; optional */
+
+	/* capture source */
+	const struct hda_input_mux *input_mux;
+	hda_nid_t *capsrc_nids;
+	unsigned int cur_mux[3];
+
+	/* channel model */
+	const struct hda_channel_mode *channel_mode;
+	int num_channel_mode;
+
+	/* PCM information */
+	struct hda_pcm pcm_rec[2];	/* used in build_pcms() */
+
+	struct mutex amp_mutex;	/* PCM volume/mute control mutex */
+	unsigned int spdif_route;
+
+	/* dynamic controls, init_verbs and input_mux */
+	struct auto_pin_cfg autocfg;
+	unsigned int num_kctl_alloc, num_kctl_used;
+	struct snd_kcontrol_new *kctl_alloc;
+	struct hda_input_mux private_imux;
+	hda_nid_t private_dac_nids[4];
+
+};
+
+static int conexant_playback_pcm_open(struct hda_pcm_stream *hinfo,
+				      struct hda_codec *codec,
+				      struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_multi_out_analog_open(codec, &spec->multiout, substream);
+}
+
+static int conexant_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
+					 struct hda_codec *codec,
+					 unsigned int stream_tag,
+					 unsigned int format,
+					 struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_multi_out_analog_prepare(codec, &spec->multiout,
+						stream_tag,
+						format, substream);
+}
+
+static int conexant_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,
+					 struct hda_codec *codec,
+					 struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);
+}
+
+/*
+ * Digital out
+ */
+static int conexant_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,
+					  struct hda_codec *codec,
+					  struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_multi_out_dig_open(codec, &spec->multiout);
+}
+
+static int conexant_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,
+					 struct hda_codec *codec,
+					 struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_multi_out_dig_close(codec, &spec->multiout);
+}
+
+/*
+ * Analog capture
+ */
+static int conexant_capture_pcm_prepare(struct hda_pcm_stream *hinfo,
+				      struct hda_codec *codec,
+				      unsigned int stream_tag,
+				      unsigned int format,
+				      struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	snd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],
+				   stream_tag, 0, format);
+	return 0;
+}
+
+static int conexant_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,
+				      struct hda_codec *codec,
+				      struct snd_pcm_substream *substream)
+{
+	struct conexant_spec *spec = codec->spec;
+	snd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],
+				   0, 0, 0);
+	return 0;
+}
+
+
+
+static struct hda_pcm_stream conexant_pcm_analog_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0, /* fill later */
+	.ops = {
+		.open = conexant_playback_pcm_open,
+		.prepare = conexant_playback_pcm_prepare,
+		.cleanup = conexant_playback_pcm_cleanup
+	},
+};
+
+static struct hda_pcm_stream conexant_pcm_analog_capture = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0, /* fill later */
+	.ops = {
+		.prepare = conexant_capture_pcm_prepare,
+		.cleanup = conexant_capture_pcm_cleanup
+	},
+};
+
+
+static struct hda_pcm_stream conexant_pcm_digital_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0, /* fill later */
+	.ops = {
+		.open = conexant_dig_playback_pcm_open,
+		.close = conexant_dig_playback_pcm_close
+	},
+};
+
+static struct hda_pcm_stream conexant_pcm_digital_capture = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	/* NID is set in alc_build_pcms */
+};
+
+static int conexant_build_pcms(struct hda_codec *codec)
+{
+	struct conexant_spec *spec = codec->spec;
+	struct hda_pcm *info = spec->pcm_rec;
+
+	codec->num_pcms = 1;
+	codec->pcm_info = info;
+
+	info->name = "CONEXANT Analog";
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK] = conexant_pcm_analog_playback;
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =
+		spec->multiout.max_channels;
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid =
+		spec->multiout.dac_nids[0];
+	info->stream[SNDRV_PCM_STREAM_CAPTURE] = conexant_pcm_analog_capture;
+	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = spec->num_adc_nids;
+	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adc_nids[0];
+
+	if (spec->multiout.dig_out_nid) {
+		info++;
+		codec->num_pcms++;
+		info->name = "Conexant Digital";
+		info->stream[SNDRV_PCM_STREAM_PLAYBACK] =
+			conexant_pcm_digital_playback;
+		info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid =
+			spec->multiout.dig_out_nid;
+		if (spec->dig_in_nid) {
+			info->stream[SNDRV_PCM_STREAM_CAPTURE] =
+				conexant_pcm_digital_capture;
+			info->stream[SNDRV_PCM_STREAM_CAPTURE].nid =
+				spec->dig_in_nid;
+		}
+	}
+
+	return 0;
+}
+
+static int conexant_mux_enum_info(struct snd_kcontrol *kcontrol,
+	       			  struct snd_ctl_elem_info *uinfo)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+
+	return snd_hda_input_mux_info(spec->input_mux, uinfo);
+}
+
+static int conexant_mux_enum_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	unsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+
+	ucontrol->value.enumerated.item[0] = spec->cur_mux[adc_idx];
+	return 0;
+}
+
+static int conexant_mux_enum_put(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	unsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+
+	return snd_hda_input_mux_put(codec, spec->input_mux, ucontrol,
+				     spec->capsrc_nids[adc_idx],
+				     &spec->cur_mux[adc_idx]);
+}
+
+static int conexant_init(struct hda_codec *codec)
+{
+	struct conexant_spec *spec = codec->spec;
+	int i;
+
+	for (i = 0; i < spec->num_init_verbs; i++)
+		snd_hda_sequence_write(codec, spec->init_verbs[i]);
+	return 0;
+}
+
+static void conexant_free(struct hda_codec *codec)
+{
+        struct conexant_spec *spec = codec->spec;
+        unsigned int i;
+
+        if (spec->kctl_alloc) {
+                for (i = 0; i < spec->num_kctl_used; i++)
+                        kfree(spec->kctl_alloc[i].name);
+                kfree(spec->kctl_alloc);
+        }
+
+	kfree(codec->spec);
+}
+
+#ifdef CONFIG_PM
+static int conexant_resume(struct hda_codec *codec)
+{
+	struct conexant_spec *spec = codec->spec;
+	int i;
+
+	codec->patch_ops.init(codec);
+	for (i = 0; i < spec->num_mixers; i++)
+		snd_hda_resume_ctls(codec, spec->mixers[i]);
+	if (spec->multiout.dig_out_nid)
+		snd_hda_resume_spdif_out(codec);
+	if (spec->dig_in_nid)
+		snd_hda_resume_spdif_in(codec);
+	return 0;
+}
+#endif
+
+static int conexant_build_controls(struct hda_codec *codec)
+{
+	struct conexant_spec *spec = codec->spec;
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < spec->num_mixers; i++) {
+		err = snd_hda_add_new_ctls(codec, spec->mixers[i]);
+		if (err < 0)
+			return err;
+	}
+	if (spec->multiout.dig_out_nid) {
+		err = snd_hda_create_spdif_out_ctls(codec,
+						    spec->multiout.dig_out_nid);
+		if (err < 0)
+			return err;
+	} 
+	if (spec->dig_in_nid) {
+		err = snd_hda_create_spdif_in_ctls(codec,spec->dig_in_nid);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static struct hda_codec_ops conexant_patch_ops = {
+	.build_controls = conexant_build_controls,
+	.build_pcms = conexant_build_pcms,
+	.init = conexant_init,
+	.free = conexant_free,
+#ifdef CONFIG_PM
+	.resume = conexant_resume,
+#endif
+};
+
+/*
+ * EAPD control
+ * the private value = nid | (invert << 8)
+ */
+
+static int cxt_eapd_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int cxt_eapd_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	int invert = (kcontrol->private_value >> 8) & 1;
+	if (invert)
+		ucontrol->value.integer.value[0] = !spec->cur_eapd;
+	else
+		ucontrol->value.integer.value[0] = spec->cur_eapd;
+	return 0;
+
+}
+
+static int cxt_eapd_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	int invert = (kcontrol->private_value >> 8) & 1;
+	hda_nid_t nid = kcontrol->private_value & 0xff;
+	unsigned int eapd;
+
+	eapd = ucontrol->value.integer.value[0];
+	if (invert)
+		eapd = !eapd;
+	if (eapd == spec->cur_eapd && !codec->in_resume)
+		return 0;
+	
+	spec->cur_eapd = eapd;
+	snd_hda_codec_write(codec, nid,
+			    0, AC_VERB_SET_EAPD_BTLENABLE,
+			    eapd ? 0x02 : 0x00);
+	return 1;
+}
+
+/* controls for test mode */
+#ifdef CONFIG_SND_DEBUG
+
+#define CXT_EAPD_SWITCH(xname, nid, mask) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0,  \
+	  .info = cxt_eapd_info, \
+	  .get = cxt_eapd_get, \
+	  .put = cxt_eapd_put, \
+	  .private_value = nid | (mask<<16) }
+
+
+
+static int conexant_ch_mode_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_ch_mode_info(codec, uinfo, spec->channel_mode,
+				    spec->num_channel_mode);
+}
+
+static int conexant_ch_mode_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	return snd_hda_ch_mode_get(codec, ucontrol, spec->channel_mode,
+				   spec->num_channel_mode,
+				   spec->multiout.max_channels);
+}
+
+static int conexant_ch_mode_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	int err = snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,
+				      spec->num_channel_mode,
+				      &spec->multiout.max_channels);
+	if (err >= 0 && spec->need_dac_fix)
+		spec->multiout.num_dacs = spec->multiout.max_channels / 2;
+	return err;
+}
+
+#define CXT_PIN_MODE(xname, nid, dir) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0,  \
+	  .info = conexant_ch_mode_info, \
+	  .get = conexant_ch_mode_get, \
+	  .put = conexant_ch_mode_put, \
+	  .private_value = nid | (dir<<16) }
+
+static int cxt_gpio_data_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}                                
+
+static int cxt_gpio_data_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = kcontrol->private_value & 0xffff;
+	unsigned char mask = (kcontrol->private_value >> 16) & 0xff;
+	long *valp = ucontrol->value.integer.value;
+	unsigned int val = snd_hda_codec_read(codec, nid, 0,
+					      AC_VERB_GET_GPIO_DATA, 0x00);
+
+	*valp = (val & mask) != 0;
+	return 0;
+}
+
+static int cxt_gpio_data_put(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = kcontrol->private_value & 0xffff;
+	unsigned char mask = (kcontrol->private_value >> 16) & 0xff;
+	long val = *ucontrol->value.integer.value;
+	unsigned int gpio_data = snd_hda_codec_read(codec, nid, 0,
+						    AC_VERB_GET_GPIO_DATA,
+						    0x00);
+	unsigned int old_data = gpio_data;
+
+	/* Set/unset the masked GPIO bit(s) as needed */
+	if (val == 0)
+		gpio_data &= ~mask;
+	else
+		gpio_data |= mask;
+	if (gpio_data == old_data && !codec->in_resume)
+		return 0;
+	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_GPIO_DATA, gpio_data);
+	return 1;
+}
+
+#define CXT_GPIO_DATA_SWITCH(xname, nid, mask) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0,  \
+	  .info = cxt_gpio_data_info, \
+	  .get = cxt_gpio_data_get, \
+	  .put = cxt_gpio_data_put, \
+	  .private_value = nid | (mask<<16) }
+#if 0
+static int cxt_spdif_ctrl_info(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}                                
+
+static int cxt_spdif_ctrl_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = kcontrol->private_value & 0xffff;
+	unsigned char mask = (kcontrol->private_value >> 16) & 0xff;
+	long *valp = ucontrol->value.integer.value;
+	unsigned int val = snd_hda_codec_read(codec, nid, 0,
+					      AC_VERB_GET_DIGI_CONVERT, 0x00);
+
+	*valp = (val & mask) != 0;
+	return 0;
+}
+
+static int cxt_spdif_ctrl_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	hda_nid_t nid = kcontrol->private_value & 0xffff;
+	unsigned char mask = (kcontrol->private_value >> 16) & 0xff;
+	long val = *ucontrol->value.integer.value;
+	unsigned int ctrl_data = snd_hda_codec_read(codec, nid, 0,
+						    AC_VERB_GET_DIGI_CONVERT,
+						    0x00);
+	unsigned int old_data = ctrl_data;
+
+	/* Set/unset the masked control bit(s) as needed */
+	if (val == 0)
+		ctrl_data &= ~mask;
+	else
+		ctrl_data |= mask;
+	if (ctrl_data == old_data && !codec->in_resume)
+		return 0;
+	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_DIGI_CONVERT_1,
+			    ctrl_data);
+	return 1;
+}
+
+#define CXT_SPDIF_CTRL_SWITCH(xname, nid, mask) \
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0,  \
+	  .info = cxt_spdif_ctrl_info, \
+	  .get = cxt_spdif_ctrl_get, \
+	  .put = cxt_spdif_ctrl_put, \
+	  .private_value = nid | (mask<<16) }
+#endif
+#endif /* CONFIG_SND_DEBUG */
+
+/* Conexant 5045 specific */
+
+static hda_nid_t cxt5045_dac_nids[1] = { 0x19 };
+static hda_nid_t cxt5045_adc_nids[1] = { 0x1a };
+static hda_nid_t cxt5045_capsrc_nids[1] = { 0x1a };
+#define CXT5045_SPDIF_OUT	0x13
+
+static struct hda_channel_mode cxt5045_modes[1] = {
+	{ 2, NULL },
+};
+
+static struct hda_input_mux cxt5045_capture_source = {
+	.num_items = 2,
+	.items = {
+		{ "IntMic", 0x1 },
+		{ "LineIn", 0x2 },
+	}
+};
+
+/* turn on/off EAPD (+ mute HP) as a master switch */
+static int cxt5045_hp_master_sw_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	unsigned int bits;
+
+	if (!cxt_eapd_put(kcontrol, ucontrol))
+		return 0;
+
+	/* toggle internal speakers mute depending of presence of
+	 * the headphone jack
+	 */
+	bits = (!spec->hp_present && spec->cur_eapd) ? 0 : 0x80;
+	snd_hda_codec_amp_update(codec, 0x10, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x10, 1, HDA_OUTPUT, 0, 0x80, bits);
+	bits = spec->cur_eapd ? 0 : 0x80;
+	snd_hda_codec_amp_update(codec, 0x11, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x11, 1, HDA_OUTPUT, 0, 0x80, bits);
+	return 1;
+}
+
+/* bind volumes of both NID 0x10 and 0x11 */
+static int cxt5045_hp_master_vol_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	long *valp = ucontrol->value.integer.value;
+	int change;
+
+	change = snd_hda_codec_amp_update(codec, 0x10, 0, HDA_OUTPUT, 0,
+					  0x7f, valp[0] & 0x7f);
+	change |= snd_hda_codec_amp_update(codec, 0x10, 1, HDA_OUTPUT, 0,
+					   0x7f, valp[1] & 0x7f);
+	snd_hda_codec_amp_update(codec, 0x11, 0, HDA_OUTPUT, 0,
+				 0x7f, valp[0] & 0x7f);
+	snd_hda_codec_amp_update(codec, 0x11, 1, HDA_OUTPUT, 0,
+				 0x7f, valp[1] & 0x7f);
+	return change;
+}
+
+
+/* mute internal speaker if HP is plugged */
+static void cxt5045_hp_automute(struct hda_codec *codec)
+{
+	struct conexant_spec *spec = codec->spec;
+	unsigned int bits;
+
+	spec->hp_present = snd_hda_codec_read(codec, 0x11, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+
+	bits = (spec->hp_present || !spec->cur_eapd) ? 0x80 : 0;
+	snd_hda_codec_amp_update(codec, 0x10, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x10, 1, HDA_OUTPUT, 0, 0x80, bits);
+}
+
+/* unsolicited event for HP jack sensing */
+static void cxt5045_hp_unsol_event(struct hda_codec *codec,
+				   unsigned int res)
+{
+	res >>= 26;
+	switch (res) {
+	case CONEXANT_HP_EVENT:
+		cxt5045_hp_automute(codec);
+		break;
+	}
+}
+
+static struct snd_kcontrol_new cxt5045_mixers[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = conexant_mux_enum_info,
+		.get = conexant_mux_enum_get,
+		.put = conexant_mux_enum_put
+	},
+	HDA_CODEC_VOLUME("Int Mic Volume", 0x17, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Int Mic Switch", 0x17, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("Ext Mic Volume", 0x17, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Ext Mic Switch", 0x17, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x1a, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x1a, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Volume",
+		.info = snd_hda_mixer_amp_volume_info,
+		.get = snd_hda_mixer_amp_volume_get,
+		.put = cxt5045_hp_master_vol_put,
+		.private_value = HDA_COMPOSE_AMP_VAL(0x10, 3, 0, HDA_OUTPUT),
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = cxt_eapd_info,
+		.get = cxt_eapd_get,
+		.put = cxt5045_hp_master_sw_put,
+		.private_value = 0x10,
+	},
+
+	{}
+};
+
+static struct hda_verb cxt5045_init_verbs[] = {
+	/* Line in, Mic */
+	{0x12, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN },
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN|AC_PINCTL_VREF_50 },
+	/* HP, Amp  */
+	{0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP },
+	{0x17, AC_VERB_SET_CONNECT_SEL,0x01},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_OUTPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x01},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_OUTPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x02},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_OUTPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x03},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_OUTPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x04},
+	/* Record selector: Int mic */
+	{0x1a, AC_VERB_SET_CONNECT_SEL,0x0},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_INPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x17},
+	/* SPDIF route: PCM */
+	{ 0x13, AC_VERB_SET_CONNECT_SEL, 0x0 },
+	/* pin sensing on HP and Mic jacks */
+	{0x11, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | CONEXANT_HP_EVENT},
+	/* EAPD */
+	{0x10, AC_VERB_SET_EAPD_BTLENABLE, 0x2 }, /* default on */ 
+	{ } /* end */
+};
+
+#ifdef CONFIG_SND_DEBUG
+/* Test configuration for debugging, modelled after the ALC260 test
+ * configuration.
+ */
+static struct hda_input_mux cxt5045_test_capture_source = {
+	.num_items = 5,
+	.items = {
+		{ "MIXER", 0x0 },
+		{ "MIC1 pin", 0x1 },
+		{ "LINE1 pin", 0x2 },
+		{ "HP-OUT pin", 0x3 },
+		{ "CD pin", 0x4 },
+        },
+};
+
+static struct snd_kcontrol_new cxt5045_test_mixer[] = {
+
+	/* Output controls */
+	HDA_CODEC_VOLUME("Speaker Playback Volume", 0x10, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Speaker Playback Switch", 0x10, 0x0, HDA_OUTPUT),
+	
+	/* Modes for retasking pin widgets */
+	CXT_PIN_MODE("HP-OUT pin mode", 0x11, CXT_PIN_DIR_INOUT),
+	CXT_PIN_MODE("LINE1 pin mode", 0x12, CXT_PIN_DIR_INOUT),
+
+	/* EAPD Switch Control */
+	CXT_EAPD_SWITCH("External Amplifier", 0x10, 0x0),
+
+	/* Loopback mixer controls */
+	HDA_CODEC_VOLUME("MIC1 Playback Volume", 0x17, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("MIC1 Playback Switch", 0x17, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("LINE loopback Playback Volume", 0x17, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("LINE loopback Playback Switch", 0x17, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("HP-OUT loopback Playback Volume", 0x17, 0x03, HDA_INPUT),
+	HDA_CODEC_MUTE("HP-OUT loopback Playback Switch", 0x17, 0x03, HDA_INPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x17, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x17, 0x04, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Capture-1 Volume", 0x17, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-1 Switch", 0x17, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-2 Volume", 0x17, 0x1, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-2 Switch", 0x17, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-3 Volume", 0x17, 0x2, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-3 Switch", 0x17, 0x2, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-4 Volume", 0x17, 0x3, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-4 Switch", 0x17, 0x3, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-5 Volume", 0x17, 0x4, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-5 Switch", 0x17, 0x4, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Input Source",
+		.info = conexant_mux_enum_info,
+		.get = conexant_mux_enum_get,
+		.put = conexant_mux_enum_put,
+	},
+
+	{ } /* end */
+};
+
+static struct hda_verb cxt5045_test_init_verbs[] = {
+	/* Enable retasking pins as output, initially without power amp */
+	{0x12, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+
+	/* Disable digital (SPDIF) pins initially, but users can enable
+	 * them via a mixer switch.  In the case of SPDIF-out, this initverb
+	 * payload also sets the generation to 0, output to be in "consumer"
+	 * PCM format, copyright asserted, no pre-emphasis and no validity
+	 * control.
+	 */
+	{0x13, AC_VERB_SET_DIGI_CONVERT_1, 0},
+
+	/* Start with output sum widgets muted and their output gains at min */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+
+	/* Unmute retasking pin widget output buffers since the default
+	 * state appears to be output.  As the pin mode is changed by the
+	 * user the pin mode control will take care of enabling the pin's
+	 * input/output buffers as needed.
+	 */
+	{0x12, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x11, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+
+	/* Mute capture amp left and right */
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+
+	/* Set ADC connection select to match default mixer setting (mic1
+	 * pin)
+	 */
+	{0x1a, AC_VERB_SET_CONNECT_SEL, 0x00},
+
+	/* Mute all inputs to mixer widget (even unconnected ones) */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)}, /* Mixer pin */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)}, /* Mic1 pin */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2)}, /* Line pin */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(3)}, /* HP pin */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(4)}, /* CD pin */
+
+	{ }
+};
+#endif
+
+
+/* initialize jack-sensing, too */
+static int cxt5045_init(struct hda_codec *codec)
+{
+	conexant_init(codec);
+	cxt5045_hp_automute(codec);
+	return 0;
+}
+
+
+enum {
+	CXT5045_LAPTOP,	/* Laptops w/ EAPD support */
+#ifdef CONFIG_SND_DEBUG
+	CXT5045_TEST,
+#endif
+	CXT5045_MODELS
+};
+
+static const char *cxt5045_models[CXT5045_MODELS] = {
+	[CXT5045_LAPTOP]	= "laptop",
+#ifdef CONFIG_SND_DEBUG
+	[CXT5045_TEST]		= "test",
+#endif
+};
+
+static struct snd_pci_quirk cxt5045_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x103c, 0x30b7, "HP DV6000Z", CXT5045_LAPTOP),
+	SND_PCI_QUIRK(0x103c, 0x30bb, "HP DV8000", CXT5045_LAPTOP),
+	SND_PCI_QUIRK(0x1734, 0x10ad, "Fujitsu Si1520", CXT5045_LAPTOP),
+	{}
+};
+
+static int patch_cxt5045(struct hda_codec *codec)
+{
+	struct conexant_spec *spec;
+	int board_config;
+
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (!spec)
+		return -ENOMEM;
+	mutex_init(&spec->amp_mutex);
+	codec->spec = spec;
+
+	spec->multiout.max_channels = 2;
+	spec->multiout.num_dacs = ARRAY_SIZE(cxt5045_dac_nids);
+	spec->multiout.dac_nids = cxt5045_dac_nids;
+	spec->multiout.dig_out_nid = CXT5045_SPDIF_OUT;
+	spec->num_adc_nids = 1;
+	spec->adc_nids = cxt5045_adc_nids;
+	spec->capsrc_nids = cxt5045_capsrc_nids;
+	spec->input_mux = &cxt5045_capture_source;
+	spec->num_mixers = 1;
+	spec->mixers[0] = cxt5045_mixers;
+	spec->num_init_verbs = 1;
+	spec->init_verbs[0] = cxt5045_init_verbs;
+	spec->spdif_route = 0;
+	spec->num_channel_mode = ARRAY_SIZE(cxt5045_modes),
+	spec->channel_mode = cxt5045_modes,
+
+
+	codec->patch_ops = conexant_patch_ops;
+	codec->patch_ops.unsol_event = cxt5045_hp_unsol_event;
+
+	board_config = snd_hda_check_board_config(codec, CXT5045_MODELS,
+						  cxt5045_models,
+						  cxt5045_cfg_tbl);
+	switch (board_config) {
+	case CXT5045_LAPTOP:
+		spec->input_mux = &cxt5045_capture_source;
+		spec->num_init_verbs = 2;
+		spec->init_verbs[1] = cxt5045_init_verbs;
+		spec->mixers[0] = cxt5045_mixers;
+		codec->patch_ops.init = cxt5045_init;
+		break;
+#ifdef CONFIG_SND_DEBUG
+	case CXT5045_TEST:
+		spec->input_mux = &cxt5045_test_capture_source;
+		spec->mixers[0] = cxt5045_test_mixer;
+		spec->init_verbs[0] = cxt5045_test_init_verbs;
+#endif	
+	}
+	return 0;
+}
+
+
+/* Conexant 5047 specific */
+#define CXT5047_SPDIF_OUT	0x11
+
+static hda_nid_t cxt5047_dac_nids[2] = { 0x10, 0x1c };
+static hda_nid_t cxt5047_adc_nids[1] = { 0x12 };
+static hda_nid_t cxt5047_capsrc_nids[1] = { 0x1a };
+
+static struct hda_channel_mode cxt5047_modes[1] = {
+	{ 2, NULL },
+};
+
+static struct hda_input_mux cxt5047_capture_source = {
+	.num_items = 2,
+	.items = {
+		{ "ExtMic", 0x0 },
+		{ "IntMic", 0x1 },
+	}
+};
+
+static struct hda_input_mux cxt5047_hp_capture_source = {
+	.num_items = 1,
+	.items = {
+		{ "ExtMic", 0x2 },
+	}
+};
+
+static struct hda_input_mux cxt5047_toshiba_capture_source = {
+	.num_items = 2,
+	.items = {
+		{ "ExtMic", 0x2 },
+		{ "Line-In", 0x1 },
+	}
+};
+
+/* turn on/off EAPD (+ mute HP) as a master switch */
+static int cxt5047_hp_master_sw_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct conexant_spec *spec = codec->spec;
+	unsigned int bits;
+
+	if (!cxt_eapd_put(kcontrol, ucontrol))
+		return 0;
+
+	/* toggle internal speakers mute depending of presence of
+	 * the headphone jack
+	 */
+	bits = (!spec->hp_present && spec->cur_eapd) ? 0 : 0x80;
+	snd_hda_codec_amp_update(codec, 0x1d, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x1d, 1, HDA_OUTPUT, 0, 0x80, bits);
+	bits = spec->cur_eapd ? 0 : 0x80;
+	snd_hda_codec_amp_update(codec, 0x13, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x13, 1, HDA_OUTPUT, 0, 0x80, bits);
+	return 1;
+}
+
+/* bind volumes of both NID 0x13 (Headphones) and 0x1d (Speakers) */
+static int cxt5047_hp_master_vol_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	long *valp = ucontrol->value.integer.value;
+	int change;
+
+	change = snd_hda_codec_amp_update(codec, 0x1d, 0, HDA_OUTPUT, 0,
+					  0x7f, valp[0] & 0x7f);
+	change |= snd_hda_codec_amp_update(codec, 0x1d, 1, HDA_OUTPUT, 0,
+					   0x7f, valp[1] & 0x7f);
+	snd_hda_codec_amp_update(codec, 0x13, 0, HDA_OUTPUT, 0,
+				 0x7f, valp[0] & 0x7f);
+	snd_hda_codec_amp_update(codec, 0x13, 1, HDA_OUTPUT, 0,
+				 0x7f, valp[1] & 0x7f);
+	return change;
+}
+
+/* mute internal speaker if HP is plugged */
+static void cxt5047_hp_automute(struct hda_codec *codec)
+{
+	struct conexant_spec *spec = codec->spec;
+	unsigned int bits;
+
+	spec->hp_present = snd_hda_codec_read(codec, 0x13, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+
+	bits = (spec->hp_present || !spec->cur_eapd) ? 0x80 : 0;
+	snd_hda_codec_amp_update(codec, 0x1d, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x1d, 1, HDA_OUTPUT, 0, 0x80, bits);
+	/* Mute/Unmute PCM 2 for good measure - some systems need this */
+	snd_hda_codec_amp_update(codec, 0x1c, 0, HDA_OUTPUT, 0, 0x80, bits);
+	snd_hda_codec_amp_update(codec, 0x1c, 1, HDA_OUTPUT, 0, 0x80, bits);
+}
+
+/* toggle input of built-in and mic jack appropriately */
+static void cxt5047_hp_automic(struct hda_codec *codec)
+{
+	static struct hda_verb mic_jack_on[] = {
+		{0x15, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
+		{0x17, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
+		{}
+	};
+	static struct hda_verb mic_jack_off[] = {
+		{0x17, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080},
+		{0x15, AC_VERB_SET_AMP_GAIN_MUTE, 0xb000},
+		{}
+	};
+	unsigned int present;
+
+	present = snd_hda_codec_read(codec, 0x08, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+	if (present)
+		snd_hda_sequence_write(codec, mic_jack_on);
+	else
+		snd_hda_sequence_write(codec, mic_jack_off);
+}
+
+/* unsolicited event for HP jack sensing */
+static void cxt5047_hp_unsol_event(struct hda_codec *codec,
+				  unsigned int res)
+{
+	res >>= 26;
+	switch (res) {
+	case CONEXANT_HP_EVENT:
+		cxt5047_hp_automute(codec);
+		break;
+	case CONEXANT_MIC_EVENT:
+		cxt5047_hp_automic(codec);
+		break;
+	}
+}
+
+static struct snd_kcontrol_new cxt5047_mixers[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = conexant_mux_enum_info,
+		.get = conexant_mux_enum_get,
+		.put = conexant_mux_enum_put
+	},
+	HDA_CODEC_VOLUME("Mic Bypass Capture Volume", 0x19, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Bypass Capture Switch", 0x19, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x12, 0x03, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x12, 0x03, HDA_INPUT),
+	HDA_CODEC_VOLUME("PCM Volume", 0x10, 0x00, HDA_OUTPUT),
+	HDA_CODEC_MUTE("PCM Switch", 0x10, 0x00, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("PCM-2 Volume", 0x1c, 0x00, HDA_OUTPUT),
+	HDA_CODEC_MUTE("PCM-2 Switch", 0x1c, 0x00, HDA_OUTPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Volume",
+		.info = snd_hda_mixer_amp_volume_info,
+		.get = snd_hda_mixer_amp_volume_get,
+		.put = cxt5047_hp_master_vol_put,
+		.private_value = HDA_COMPOSE_AMP_VAL(0x13, 3, 0, HDA_OUTPUT),
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = cxt_eapd_info,
+		.get = cxt_eapd_get,
+		.put = cxt5047_hp_master_sw_put,
+		.private_value = 0x13,
+	},
+
+	{}
+};
+
+static struct snd_kcontrol_new cxt5047_toshiba_mixers[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = conexant_mux_enum_info,
+		.get = conexant_mux_enum_get,
+		.put = conexant_mux_enum_put
+	},
+	HDA_CODEC_VOLUME("Mic Bypass Capture Volume", 0x19, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Bypass Capture Switch", 0x19, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x12, 0x03, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x12, 0x03, HDA_INPUT),
+	HDA_CODEC_VOLUME("PCM Volume", 0x10, 0x00, HDA_OUTPUT),
+	HDA_CODEC_MUTE("PCM Switch", 0x10, 0x00, HDA_OUTPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Volume",
+		.info = snd_hda_mixer_amp_volume_info,
+		.get = snd_hda_mixer_amp_volume_get,
+		.put = cxt5047_hp_master_vol_put,
+		.private_value = HDA_COMPOSE_AMP_VAL(0x13, 3, 0, HDA_OUTPUT),
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = cxt_eapd_info,
+		.get = cxt_eapd_get,
+		.put = cxt5047_hp_master_sw_put,
+		.private_value = 0x13,
+	},
+
+	{}
+};
+
+static struct snd_kcontrol_new cxt5047_hp_mixers[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = conexant_mux_enum_info,
+		.get = conexant_mux_enum_get,
+		.put = conexant_mux_enum_put
+	},
+	HDA_CODEC_VOLUME("Mic Bypass Capture Volume", 0x19, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Bypass Capture Switch", 0x19,0x02,HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x12, 0x03, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x12, 0x03, HDA_INPUT),
+	HDA_CODEC_VOLUME("PCM Volume", 0x10, 0x00, HDA_OUTPUT),
+	HDA_CODEC_MUTE("PCM Switch", 0x10, 0x00, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Master Playback Volume", 0x13, 0x00, HDA_OUTPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = cxt_eapd_info,
+		.get = cxt_eapd_get,
+		.put = cxt5047_hp_master_sw_put,
+		.private_value = 0x13,
+	},
+	{ } /* end */
+};
+
+static struct hda_verb cxt5047_init_verbs[] = {
+	/* Line in, Mic, Built-in Mic */
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN },
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN|AC_PINCTL_VREF_50 },
+	{0x17, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN|AC_PINCTL_VREF_50 },
+	/* HP, Amp, Speaker  */
+	{0x13, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{0x1A, AC_VERB_SET_CONNECT_SEL,0x00},
+	{0x1A, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_OUTPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x00},
+	{0x1A, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_OUTPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x03},
+	{0x1d, AC_VERB_SET_CONNECT_SEL,0x0},
+	/* Record selector: Front mic */
+	{0x12, AC_VERB_SET_CONNECT_SEL,0x03},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_INPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x17},
+	/* SPDIF route: PCM */
+	{ 0x18, AC_VERB_SET_CONNECT_SEL, 0x0 },
+	/* Enable unsolicited events */
+	{0x13, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | CONEXANT_HP_EVENT},
+	{0x15, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | CONEXANT_MIC_EVENT},
+	{ } /* end */
+};
+
+/* configuration for Toshiba Laptops */
+static struct hda_verb cxt5047_toshiba_init_verbs[] = {
+	{0x13, AC_VERB_SET_EAPD_BTLENABLE, 0x0 }, /* default on */
+	/* pin sensing on HP and Mic jacks */
+	{0x13, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | CONEXANT_HP_EVENT},
+	{0x15, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | CONEXANT_MIC_EVENT},
+	/* Speaker routing */
+	{0x1d, AC_VERB_SET_CONNECT_SEL,0x1},
+	/* Change default to ExtMic for recording */
+	{0x1a, AC_VERB_SET_CONNECT_SEL,0x2},
+	{}
+};
+
+/* configuration for HP Laptops */
+static struct hda_verb cxt5047_hp_init_verbs[] = {
+	/* pin sensing on HP jack */
+	{0x13, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | CONEXANT_HP_EVENT},
+	/* Record selector: Ext Mic */
+	{0x12, AC_VERB_SET_CONNECT_SEL,0x03},
+	{0x1a, AC_VERB_SET_CONNECT_SEL,0x02},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE,
+	 AC_AMP_SET_INPUT|AC_AMP_SET_RIGHT|AC_AMP_SET_LEFT|0x17},
+	/* Speaker routing */
+	{0x1d, AC_VERB_SET_CONNECT_SEL,0x1},
+	{}
+};
+
+/* Test configuration for debugging, modelled after the ALC260 test
+ * configuration.
+ */
+#ifdef CONFIG_SND_DEBUG
+static struct hda_input_mux cxt5047_test_capture_source = {
+	.num_items = 4,
+	.items = {
+		{ "LINE1 pin", 0x0 },
+		{ "MIC1 pin", 0x1 },
+		{ "MIC2 pin", 0x2 },
+		{ "CD pin", 0x3 },
+        },
+};
+
+static struct snd_kcontrol_new cxt5047_test_mixer[] = {
+
+	/* Output only controls */
+	HDA_CODEC_VOLUME("OutAmp-1 Volume", 0x10, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("OutAmp-1 Switch", 0x10,0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("OutAmp-2 Volume", 0x1c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("OutAmp-2 Switch", 0x1c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Speaker Playback Volume", 0x1d, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Speaker Playback Switch", 0x1d, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("HeadPhone Playback Volume", 0x13, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("HeadPhone Playback Switch", 0x13, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Line1-Out Playback Volume", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Line1-Out Playback Switch", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Line2-Out Playback Volume", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Line2-Out Playback Switch", 0x15, 0x0, HDA_OUTPUT),
+
+	/* Modes for retasking pin widgets */
+	CXT_PIN_MODE("LINE1 pin mode", 0x14, CXT_PIN_DIR_INOUT),
+	CXT_PIN_MODE("MIC1 pin mode", 0x15, CXT_PIN_DIR_INOUT),
+
+	/* EAPD Switch Control */
+	CXT_EAPD_SWITCH("External Amplifier", 0x13, 0x0),
+
+	/* Loopback mixer controls */
+	HDA_CODEC_VOLUME("MIC1 Playback Volume", 0x12, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("MIC1 Playback Switch", 0x12, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("MIC2 Playback Volume", 0x12, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("MIC2 Playback Switch", 0x12, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("LINE Playback Volume", 0x12, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("LINE Playback Switch", 0x12, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x12, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x12, 0x04, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Capture-1 Volume", 0x19, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-1 Switch", 0x19, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-2 Volume", 0x19, 0x1, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-2 Switch", 0x19, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-3 Volume", 0x19, 0x2, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-3 Switch", 0x19, 0x2, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture-4 Volume", 0x19, 0x3, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture-4 Switch", 0x19, 0x3, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Input Source",
+		.info = conexant_mux_enum_info,
+		.get = conexant_mux_enum_get,
+		.put = conexant_mux_enum_put,
+	},
+       /* Controls for GPIO pins, assuming they exist and are configured
+	* as outputs
+	*/
+	CXT_GPIO_DATA_SWITCH("GPIO pin 0", 0x01, 0x01),
+	CXT_GPIO_DATA_SWITCH("GPIO pin 1", 0x01, 0x02),
+	CXT_GPIO_DATA_SWITCH("GPIO pin 2", 0x01, 0x04),
+	CXT_GPIO_DATA_SWITCH("GPIO pin 3", 0x01, 0x08),
+
+	{ } /* end */
+};
+
+static struct hda_verb cxt5047_test_init_verbs[] = {
+	/* Enable retasking pins as output, initially without power amp */
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x13, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+
+	/* Disable digital (SPDIF) pins initially, but users can enable
+	 * them via a mixer switch.  In the case of SPDIF-out, this initverb
+	 * payload also sets the generation to 0, output to be in "consumer"
+	 * PCM format, copyright asserted, no pre-emphasis and no validity
+	 * control.
+	 */
+	{0x18, AC_VERB_SET_DIGI_CONVERT_1, 0},
+
+	/* Ensure mic1, mic2, line1 pin widgets take input from the 
+	 * OUT1 sum bus when acting as an output.
+	 */
+	{0x1a, AC_VERB_SET_CONNECT_SEL, 0},
+	{0x1b, AC_VERB_SET_CONNECT_SEL, 0},
+
+	/* Start with output sum widgets muted and their output gains at min */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+
+	/* Unmute retasking pin widget output buffers since the default
+	 * state appears to be output.  As the pin mode is changed by the
+	 * user the pin mode control will take care of enabling the pin's
+	 * input/output buffers as needed.
+	 */
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x13, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+
+	/* Mute capture amp left and right */
+	{0x12, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+
+	/* Set ADC connection select to match default mixer setting (mic1
+	 * pin)
+	 */
+	{0x12, AC_VERB_SET_CONNECT_SEL, 0x00},
+
+	/* Mute all inputs to mixer widget (even unconnected ones) */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)}, /* mic1 pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)}, /* mic2 pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2)}, /* line1 pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(3)}, /* line2 pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(4)}, /* CD pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(5)}, /* Beep-gen pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(6)}, /* Line-out pin */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(7)}, /* HP-pin pin */
+
+	{ }
+};
+#endif
+
+
+/* initialize jack-sensing, too */
+static int cxt5047_hp_init(struct hda_codec *codec)
+{
+	conexant_init(codec);
+	cxt5047_hp_automute(codec);
+	return 0;
+}
+
+
+enum {
+	CXT5047_LAPTOP,		/* Laptops w/o EAPD support */
+	CXT5047_LAPTOP_HP,	/* Some HP laptops */
+	CXT5047_LAPTOP_EAPD,	/* Laptops with EAPD support */
+#ifdef CONFIG_SND_DEBUG
+	CXT5047_TEST,
+#endif
+	CXT5047_MODELS
+};
+
+static const char *cxt5047_models[CXT5047_MODELS] = {
+	[CXT5047_LAPTOP]	= "laptop",
+	[CXT5047_LAPTOP_HP]	= "laptop-hp",
+	[CXT5047_LAPTOP_EAPD]	= "laptop-eapd",
+#ifdef CONFIG_SND_DEBUG
+	[CXT5047_TEST]		= "test",
+#endif
+};
+
+static struct snd_pci_quirk cxt5047_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x103c, 0x30a0, "HP DV1000", CXT5047_LAPTOP),
+	SND_PCI_QUIRK(0x103c, 0x30b2, "HP DV2000T/DV3000T", CXT5047_LAPTOP),
+	SND_PCI_QUIRK(0x103c, 0x30b5, "HP DV2000Z", CXT5047_LAPTOP),
+	SND_PCI_QUIRK(0x103c, 0x30a5, "HP DV5200T/DV8000T", CXT5047_LAPTOP_HP),
+	SND_PCI_QUIRK(0x1179, 0xff31, "Toshiba P100", CXT5047_LAPTOP_EAPD),
+	{}
+};
+
+static int patch_cxt5047(struct hda_codec *codec)
+{
+	struct conexant_spec *spec;
+	int board_config;
+
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (!spec)
+		return -ENOMEM;
+	mutex_init(&spec->amp_mutex);
+	codec->spec = spec;
+
+	spec->multiout.max_channels = 2;
+	spec->multiout.num_dacs = ARRAY_SIZE(cxt5047_dac_nids);
+	spec->multiout.dac_nids = cxt5047_dac_nids;
+	spec->multiout.dig_out_nid = CXT5047_SPDIF_OUT;
+	spec->num_adc_nids = 1;
+	spec->adc_nids = cxt5047_adc_nids;
+	spec->capsrc_nids = cxt5047_capsrc_nids;
+	spec->input_mux = &cxt5047_capture_source;
+	spec->num_mixers = 1;
+	spec->mixers[0] = cxt5047_mixers;
+	spec->num_init_verbs = 1;
+	spec->init_verbs[0] = cxt5047_init_verbs;
+	spec->spdif_route = 0;
+	spec->num_channel_mode = ARRAY_SIZE(cxt5047_modes),
+	spec->channel_mode = cxt5047_modes,
+
+	codec->patch_ops = conexant_patch_ops;
+	codec->patch_ops.unsol_event = cxt5047_hp_unsol_event;
+
+	board_config = snd_hda_check_board_config(codec, CXT5047_MODELS,
+						  cxt5047_models,
+						  cxt5047_cfg_tbl);
+	switch (board_config) {
+	case CXT5047_LAPTOP:
+		break;
+	case CXT5047_LAPTOP_HP:
+		spec->input_mux = &cxt5047_hp_capture_source;
+		spec->num_init_verbs = 2;
+		spec->init_verbs[1] = cxt5047_hp_init_verbs;
+		spec->mixers[0] = cxt5047_hp_mixers;
+		codec->patch_ops.init = cxt5047_hp_init;
+		break;
+	case CXT5047_LAPTOP_EAPD:
+		spec->input_mux = &cxt5047_toshiba_capture_source;
+		spec->num_init_verbs = 2;
+		spec->init_verbs[1] = cxt5047_toshiba_init_verbs;
+		spec->mixers[0] = cxt5047_toshiba_mixers;
+		break;
+#ifdef CONFIG_SND_DEBUG
+	case CXT5047_TEST:
+		spec->input_mux = &cxt5047_test_capture_source;
+		spec->mixers[0] = cxt5047_test_mixer;
+		spec->init_verbs[0] = cxt5047_test_init_verbs;
+#endif	
+	}
+	return 0;
+}
+
+struct hda_codec_preset snd_hda_preset_conexant[] = {
+	{ .id = 0x14f15045, .name = "CX20549 (Venice)",
+	  .patch = patch_cxt5045 },
+	{ .id = 0x14f15047, .name = "CX20551 (Waikiki)",
+	  .patch = patch_cxt5047 },
+	{} /* terminator */
+};
--- linux-2.6.18.noarch/sound/pci/hda/patch_via.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_via.c	2007-06-05 17:46:40.000000000 -0400
@@ -0,0 +1,1396 @@
+/*
+ * Universal Interface for Intel High Definition Audio Codec
+ *
+ * HD audio interface patch for VIA VT1708 codec
+ *
+ * Copyright (c) 2006 Lydia Wang <lydiawang@viatech.com>
+ *                    Takashi Iwai <tiwai@suse.de>
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/* * * * * * * * * * * * * * Release History * * * * * * * * * * * * * * * * */
+/*                                                                           */
+/* 2006-03-03  Lydia Wang  Create the basic patch to support VT1708 codec    */
+/* 2006-03-14  Lydia Wang  Modify hard code for some pin widget nid          */
+/* 2006-08-02  Lydia Wang  Add support to VT1709 codec                       */
+/* 2006-09-08  Lydia Wang  Fix internal loopback recording source select bug */
+/*                                                                           */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <sound/core.h>
+#include "hda_codec.h"
+#include "hda_local.h"
+
+
+/* amp values */
+#define AMP_VAL_IDX_SHIFT	19
+#define AMP_VAL_IDX_MASK	(0x0f<<19)
+
+#define NUM_CONTROL_ALLOC	32
+#define NUM_VERB_ALLOC		32
+
+/* Pin Widget NID */
+#define VT1708_HP_NID		0x13
+#define VT1708_DIGOUT_NID	0x14
+#define VT1708_DIGIN_NID	0x16
+
+#define VT1709_HP_DAC_NID	0x28
+#define VT1709_DIGOUT_NID	0x13
+#define VT1709_DIGIN_NID	0x17
+
+#define IS_VT1708_VENDORID(x)		((x) >= 0x11061708 && (x) <= 0x1106170b)
+#define IS_VT1709_10CH_VENDORID(x)	((x) >= 0x1106e710 && (x) <= 0x1106e713)
+#define IS_VT1709_6CH_VENDORID(x)	((x) >= 0x1106e714 && (x) <= 0x1106e717)
+
+
+enum {
+	VIA_CTL_WIDGET_VOL,
+	VIA_CTL_WIDGET_MUTE,
+};
+
+enum {
+	AUTO_SEQ_FRONT,
+	AUTO_SEQ_SURROUND,
+	AUTO_SEQ_CENLFE,
+	AUTO_SEQ_SIDE
+};
+
+static struct snd_kcontrol_new vt1708_control_templates[] = {
+	HDA_CODEC_VOLUME(NULL, 0, 0, 0),
+	HDA_CODEC_MUTE(NULL, 0, 0, 0),
+};
+
+
+struct via_spec {
+	/* codec parameterization */
+	struct snd_kcontrol_new *mixers[3];
+	unsigned int num_mixers;
+
+	struct hda_verb *init_verbs;
+
+	char *stream_name_analog;
+	struct hda_pcm_stream *stream_analog_playback;
+	struct hda_pcm_stream *stream_analog_capture;
+
+	char *stream_name_digital;
+	struct hda_pcm_stream *stream_digital_playback;
+	struct hda_pcm_stream *stream_digital_capture;
+
+	/* playback */
+	struct hda_multi_out multiout;
+
+	/* capture */
+	unsigned int num_adc_nids;
+	hda_nid_t *adc_nids;
+	hda_nid_t dig_in_nid;
+
+	/* capture source */
+	const struct hda_input_mux *input_mux;
+	unsigned int cur_mux[3];
+
+	/* PCM information */
+	struct hda_pcm pcm_rec[2];
+
+	/* dynamic controls, init_verbs and input_mux */
+	struct auto_pin_cfg autocfg;
+	unsigned int num_kctl_alloc, num_kctl_used;
+	struct snd_kcontrol_new *kctl_alloc;
+	struct hda_input_mux private_imux;
+	hda_nid_t private_dac_nids[4];	
+};
+
+static hda_nid_t vt1708_adc_nids[2] = {
+	/* ADC1-2 */
+	0x15, 0x27
+};
+
+static hda_nid_t vt1709_adc_nids[3] = {
+	/* ADC1-2 */
+	0x14, 0x15, 0x16
+};
+
+/* add dynamic controls */
+static int via_add_control(struct via_spec *spec, int type, const char *name,
+			   unsigned long val)
+{
+	struct snd_kcontrol_new *knew;
+
+	if (spec->num_kctl_used >= spec->num_kctl_alloc) {
+		int num = spec->num_kctl_alloc + NUM_CONTROL_ALLOC;
+
+		/* array + terminator */
+		knew = kcalloc(num + 1, sizeof(*knew), GFP_KERNEL);
+		if (!knew)
+			return -ENOMEM;
+		if (spec->kctl_alloc) {
+			memcpy(knew, spec->kctl_alloc,
+			       sizeof(*knew) * spec->num_kctl_alloc);
+			kfree(spec->kctl_alloc);
+		}
+		spec->kctl_alloc = knew;
+		spec->num_kctl_alloc = num;
+	}
+
+	knew = &spec->kctl_alloc[spec->num_kctl_used];
+	*knew = vt1708_control_templates[type];
+	knew->name = kstrdup(name, GFP_KERNEL);
+
+	if (!knew->name)
+		return -ENOMEM;
+	knew->private_value = val;
+	spec->num_kctl_used++;
+	return 0;
+}
+
+/* create input playback/capture controls for the given pin */
+static int via_new_analog_input(struct via_spec *spec, hda_nid_t pin,
+				const char *ctlname, int idx, int mix_nid)
+{
+	char name[32];
+	int err;
+
+	sprintf(name, "%s Playback Volume", ctlname);
+	err = via_add_control(spec, VIA_CTL_WIDGET_VOL, name,
+			      HDA_COMPOSE_AMP_VAL(mix_nid, 3, idx, HDA_INPUT));
+	if (err < 0)
+		return err;
+	sprintf(name, "%s Playback Switch", ctlname);
+	err = via_add_control(spec, VIA_CTL_WIDGET_MUTE, name,
+			      HDA_COMPOSE_AMP_VAL(mix_nid, 3, idx, HDA_INPUT));
+	if (err < 0)
+		return err;
+	return 0;
+}
+
+static void via_auto_set_output_and_unmute(struct hda_codec *codec,
+					   hda_nid_t nid, int pin_type,
+					   int dac_idx)
+{
+	/* set as output */
+	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_PIN_WIDGET_CONTROL,
+			    pin_type);
+	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_AMP_GAIN_MUTE,
+			    AMP_OUT_UNMUTE);
+}
+
+
+static void via_auto_init_multi_out(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	int i;
+
+	for (i = 0; i <= AUTO_SEQ_SIDE; i++) {
+		hda_nid_t nid = spec->autocfg.line_out_pins[i];
+		if (nid)
+			via_auto_set_output_and_unmute(codec, nid, PIN_OUT, i);
+	}
+}
+
+static void via_auto_init_hp_out(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	hda_nid_t pin;
+
+	pin = spec->autocfg.hp_pins[0];
+	if (pin) /* connect to front */
+		via_auto_set_output_and_unmute(codec, pin, PIN_HP, 0);
+}
+
+static void via_auto_init_analog_input(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	int i;
+
+	for (i = 0; i < AUTO_PIN_LAST; i++) {
+		hda_nid_t nid = spec->autocfg.input_pins[i];
+
+		snd_hda_codec_write(codec, nid, 0,
+				    AC_VERB_SET_PIN_WIDGET_CONTROL,
+				    (i <= AUTO_PIN_FRONT_MIC ?
+				     PIN_VREF50 : PIN_IN));
+
+	}
+}
+/*
+ * input MUX handling
+ */
+static int via_mux_enum_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct via_spec *spec = codec->spec;
+	return snd_hda_input_mux_info(spec->input_mux, uinfo);
+}
+
+static int via_mux_enum_get(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct via_spec *spec = codec->spec;
+	unsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+
+	ucontrol->value.enumerated.item[0] = spec->cur_mux[adc_idx];
+	return 0;
+}
+
+static int via_mux_enum_put(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct via_spec *spec = codec->spec;
+	unsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	unsigned int vendor_id = codec->vendor_id;
+
+	/* AIW0  lydia 060801 add for correct sw0 input select */
+	if (IS_VT1708_VENDORID(vendor_id) && (adc_idx == 0))
+		return snd_hda_input_mux_put(codec, spec->input_mux, ucontrol,
+					     0x18, &spec->cur_mux[adc_idx]);
+	else if ((IS_VT1709_10CH_VENDORID(vendor_id) ||
+		  IS_VT1709_6CH_VENDORID(vendor_id)) && (adc_idx == 0) )
+		return snd_hda_input_mux_put(codec, spec->input_mux, ucontrol,
+					     0x19, &spec->cur_mux[adc_idx]);
+	else
+		return snd_hda_input_mux_put(codec, spec->input_mux, ucontrol,
+					     spec->adc_nids[adc_idx],
+					     &spec->cur_mux[adc_idx]);
+}
+
+/* capture mixer elements */
+static struct snd_kcontrol_new vt1708_capture_mixer[] = {
+	HDA_CODEC_VOLUME("Capture Volume", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x27, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x27, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		/* The multiple "Capture Source" controls confuse alsamixer
+		 * So call somewhat different..
+		 * FIXME: the controls appear in the "playback" view!
+		 */
+		/* .name = "Capture Source", */
+		.name = "Input Source",
+		.count = 1,
+		.info = via_mux_enum_info,
+		.get = via_mux_enum_get,
+		.put = via_mux_enum_put,
+	},
+	{ } /* end */
+};
+/*
+ * generic initialization of ADC, input mixers and output mixers
+ */
+static struct hda_verb vt1708_volume_init_verbs[] = {
+	/*
+	 * Unmute ADC0-1 and set the default input to mic-in
+	 */
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x27, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+
+
+	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of the analog-loopback
+	 * mixer widget
+	 */
+	/* Amp Indices: CD = 1, Mic1 = 2, Line = 3, Mic2 = 4 */
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(4)},
+
+	/*
+	 * Set up output mixers (0x19 - 0x1b)
+	 */
+	/* set vol=0 to output mixers */
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	
+	/* Setup default input to PW4 */
+	{0x20, AC_VERB_SET_CONNECT_SEL, 0x1},
+	/* Set mic as default input of sw0 */
+	{0x18, AC_VERB_SET_CONNECT_SEL, 0x2},
+	/* PW9 Output enable */
+	{0x25, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40},
+};
+
+static int via_playback_pcm_open(struct hda_pcm_stream *hinfo,
+				 struct hda_codec *codec,
+				 struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+	return snd_hda_multi_out_analog_open(codec, &spec->multiout, substream);
+}
+
+static int via_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
+				    struct hda_codec *codec,
+				    unsigned int stream_tag,
+				    unsigned int format,
+				    struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+	return snd_hda_multi_out_analog_prepare(codec, &spec->multiout,
+						stream_tag, format, substream);
+}
+
+static int via_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,
+				    struct hda_codec *codec,
+				    struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+	return snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);
+}
+
+/*
+ * Digital out
+ */
+static int via_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,
+				     struct hda_codec *codec,
+				     struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+	return snd_hda_multi_out_dig_open(codec, &spec->multiout);
+}
+
+static int via_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,
+				      struct hda_codec *codec,
+				      struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+	return snd_hda_multi_out_dig_close(codec, &spec->multiout);
+}
+
+/*
+ * Analog capture
+ */
+static int via_capture_pcm_prepare(struct hda_pcm_stream *hinfo,
+				   struct hda_codec *codec,
+				   unsigned int stream_tag,
+				   unsigned int format,
+				   struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+
+	snd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],
+				   stream_tag, 0, format);
+	return 0;
+}
+
+static int via_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,
+				   struct hda_codec *codec,
+				   struct snd_pcm_substream *substream)
+{
+	struct via_spec *spec = codec->spec;
+	snd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],
+				   0, 0, 0);
+	return 0;
+}
+
+static struct hda_pcm_stream vt1708_pcm_analog_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 8,
+	.nid = 0x10, /* NID to query formats and rates */
+	.ops = {
+		.open = via_playback_pcm_open,
+		.prepare = via_playback_pcm_prepare,
+		.cleanup = via_playback_pcm_cleanup
+	},
+};
+
+static struct hda_pcm_stream vt1708_pcm_analog_capture = {
+	.substreams = 2,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0x15, /* NID to query formats and rates */
+	.ops = {
+		.prepare = via_capture_pcm_prepare,
+		.cleanup = via_capture_pcm_cleanup
+	},
+};
+
+static struct hda_pcm_stream vt1708_pcm_digital_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	/* NID is set in via_build_pcms */
+	.ops = {
+		.open = via_dig_playback_pcm_open,
+		.close = via_dig_playback_pcm_close
+	},
+};
+
+static struct hda_pcm_stream vt1708_pcm_digital_capture = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+
+static int via_build_controls(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	int err;
+	int i;
+
+	for (i = 0; i < spec->num_mixers; i++) {
+		err = snd_hda_add_new_ctls(codec, spec->mixers[i]);
+		if (err < 0)
+			return err;
+	}
+
+	if (spec->multiout.dig_out_nid) {
+		err = snd_hda_create_spdif_out_ctls(codec,
+						    spec->multiout.dig_out_nid);
+		if (err < 0)
+			return err;
+	}
+	if (spec->dig_in_nid) {
+		err = snd_hda_create_spdif_in_ctls(codec, spec->dig_in_nid);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static int via_build_pcms(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	struct hda_pcm *info = spec->pcm_rec;
+
+	codec->num_pcms = 1;
+	codec->pcm_info = info;
+
+	info->name = spec->stream_name_analog;
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK] = *(spec->stream_analog_playback);
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->multiout.dac_nids[0];
+	info->stream[SNDRV_PCM_STREAM_CAPTURE] = *(spec->stream_analog_capture);
+	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adc_nids[0];
+
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =
+		spec->multiout.max_channels;
+
+	if (spec->multiout.dig_out_nid || spec->dig_in_nid) {
+		codec->num_pcms++;
+		info++;
+		info->name = spec->stream_name_digital;
+		if (spec->multiout.dig_out_nid) {
+			info->stream[SNDRV_PCM_STREAM_PLAYBACK] =
+				*(spec->stream_digital_playback);
+			info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid =
+				spec->multiout.dig_out_nid;
+		}
+		if (spec->dig_in_nid) {
+			info->stream[SNDRV_PCM_STREAM_CAPTURE] =
+				*(spec->stream_digital_capture);
+			info->stream[SNDRV_PCM_STREAM_CAPTURE].nid =
+				spec->dig_in_nid;
+		}
+	}
+
+	return 0;
+}
+
+static void via_free(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	unsigned int i;
+
+	if (!spec)
+		return;
+
+	if (spec->kctl_alloc) {
+		for (i = 0; i < spec->num_kctl_used; i++)
+			kfree(spec->kctl_alloc[i].name);
+		kfree(spec->kctl_alloc);
+	}
+
+	kfree(codec->spec);
+}
+
+static int via_init(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	snd_hda_sequence_write(codec, spec->init_verbs);
+ 	return 0;
+}
+
+#ifdef CONFIG_PM
+/*
+ * resume
+ */
+static int via_resume(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	int i;
+
+	via_init(codec);
+	for (i = 0; i < spec->num_mixers; i++)
+		snd_hda_resume_ctls(codec, spec->mixers[i]);
+	if (spec->multiout.dig_out_nid)
+		snd_hda_resume_spdif_out(codec);
+	if (spec->dig_in_nid)
+		snd_hda_resume_spdif_in(codec);
+
+	return 0;
+}
+#endif
+
+/*
+ */
+static struct hda_codec_ops via_patch_ops = {
+	.build_controls = via_build_controls,
+	.build_pcms = via_build_pcms,
+	.init = via_init,
+	.free = via_free,
+#ifdef CONFIG_PM
+	.resume = via_resume,
+#endif
+};
+
+/* fill in the dac_nids table from the parsed pin configuration */
+static int vt1708_auto_fill_dac_nids(struct via_spec *spec,
+				     const struct auto_pin_cfg *cfg)
+{
+	int i;
+	hda_nid_t nid;
+
+	spec->multiout.num_dacs = cfg->line_outs;
+
+	spec->multiout.dac_nids = spec->private_dac_nids;
+ 	
+	for(i = 0; i < 4; i++) {
+		nid = cfg->line_out_pins[i];
+		if (nid) {
+			/* config dac list */
+			switch (i) {
+			case AUTO_SEQ_FRONT:
+				spec->multiout.dac_nids[i] = 0x10;
+				break;
+			case AUTO_SEQ_CENLFE:
+				spec->multiout.dac_nids[i] = 0x12;
+				break;
+			case AUTO_SEQ_SURROUND:
+				spec->multiout.dac_nids[i] = 0x13;
+				break;
+			case AUTO_SEQ_SIDE:
+				spec->multiout.dac_nids[i] = 0x11;
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* add playback controls from the parsed DAC table */
+static int vt1708_auto_create_multi_out_ctls(struct via_spec *spec,
+					     const struct auto_pin_cfg *cfg)
+{
+	char name[32];
+	static const char *chname[4] = { "Front", "Surround", "C/LFE", "Side" };
+	hda_nid_t nid, nid_vol = 0;
+	int i, err;
+
+	for (i = 0; i <= AUTO_SEQ_SIDE; i++) {
+		nid = cfg->line_out_pins[i];
+
+		if (!nid)
+			continue;
+		
+		if (i != AUTO_SEQ_FRONT)
+			nid_vol = 0x1b - i + 1;
+
+		if (i == AUTO_SEQ_CENLFE) {
+			/* Center/LFE */
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+					      "Center Playback Volume",
+					      HDA_COMPOSE_AMP_VAL(nid_vol, 1, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+					      "LFE Playback Volume",
+					      HDA_COMPOSE_AMP_VAL(nid_vol, 2, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+					      "Center Playback Switch",
+					      HDA_COMPOSE_AMP_VAL(nid_vol, 1, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+					      "LFE Playback Switch",
+					      HDA_COMPOSE_AMP_VAL(nid_vol, 2, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		} else if (i == AUTO_SEQ_FRONT){
+			/* add control to mixer index 0 */
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+					      "Master Front Playback Volume",
+					      HDA_COMPOSE_AMP_VAL(0x17, 3, 0, HDA_INPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+					      "Master Front Playback Switch",
+					      HDA_COMPOSE_AMP_VAL(0x17, 3, 0, HDA_INPUT));
+			if (err < 0)
+				return err;
+			
+			/* add control to PW3 */
+			sprintf(name, "%s Playback Volume", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL, name,
+					      HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			sprintf(name, "%s Playback Switch", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE, name,
+					      HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		} else {
+			sprintf(name, "%s Playback Volume", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL, name,
+					      HDA_COMPOSE_AMP_VAL(nid_vol, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			sprintf(name, "%s Playback Switch", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE, name,
+					      HDA_COMPOSE_AMP_VAL(nid_vol, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int vt1708_auto_create_hp_ctls(struct via_spec *spec, hda_nid_t pin)
+{
+	int err;
+
+	if (!pin)
+		return 0;
+
+	spec->multiout.hp_nid = VT1708_HP_NID; /* AOW3 */
+
+	err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+			      "Headphone Playback Volume",
+			      HDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_OUTPUT));
+	if (err < 0)
+		return err;
+	err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+			      "Headphone Playback Switch",
+			      HDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_OUTPUT));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/* create playback/capture controls for input pins */
+static int vt1708_auto_create_analog_input_ctls(struct via_spec *spec,
+						const struct auto_pin_cfg *cfg)
+{
+	static char *labels[] = {
+		"Mic", "Front Mic", "Line", "Front Line", "CD", "Aux", NULL
+	};
+	struct hda_input_mux *imux = &spec->private_imux;
+	int i, err, idx = 0;
+
+	/* for internal loopback recording select */
+	imux->items[imux->num_items].label = "Stereo Mixer";
+	imux->items[imux->num_items].index = idx;
+	imux->num_items++;
+
+	for (i = 0; i < AUTO_PIN_LAST; i++) {
+		if (!cfg->input_pins[i])
+			continue;
+
+		switch (cfg->input_pins[i]) {
+		case 0x1d: /* Mic */
+			idx = 2;
+			break;
+				
+		case 0x1e: /* Line In */
+			idx = 3;
+			break;
+
+		case 0x21: /* Front Mic */
+			idx = 4;
+			break;
+
+		case 0x24: /* CD */
+			idx = 1;
+			break;
+		}
+		err = via_new_analog_input(spec, cfg->input_pins[i], labels[i],
+					   idx, 0x17);
+		if (err < 0)
+			return err;
+		imux->items[imux->num_items].label = labels[i];
+		imux->items[imux->num_items].index = idx;
+		imux->num_items++;
+	}
+	return 0;
+}
+
+static int vt1708_parse_auto_config(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	int err;
+
+	err = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);
+	if (err < 0)
+		return err;
+	err = vt1708_auto_fill_dac_nids(spec, &spec->autocfg);
+	if (err < 0)
+		return err;
+	if (!spec->autocfg.line_outs && !spec->autocfg.hp_pins[0])
+		return 0; /* can't find valid BIOS pin config */
+
+	err = vt1708_auto_create_multi_out_ctls(spec, &spec->autocfg);
+	if (err < 0)
+		return err;
+	err = vt1708_auto_create_hp_ctls(spec, spec->autocfg.hp_pins[0]);
+	if (err < 0)
+		return err;
+	err = vt1708_auto_create_analog_input_ctls(spec, &spec->autocfg);
+	if (err < 0)
+		return err;
+
+	spec->multiout.max_channels = spec->multiout.num_dacs * 2;
+
+	if (spec->autocfg.dig_out_pin)
+		spec->multiout.dig_out_nid = VT1708_DIGOUT_NID;
+	if (spec->autocfg.dig_in_pin)
+		spec->dig_in_nid = VT1708_DIGIN_NID;
+
+	if (spec->kctl_alloc)
+		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
+
+	spec->init_verbs = vt1708_volume_init_verbs;	
+
+	spec->input_mux = &spec->private_imux;
+
+	return 1;
+}
+
+/* init callback for auto-configuration model -- overriding the default init */
+static int via_auto_init(struct hda_codec *codec)
+{
+	via_init(codec);
+	via_auto_init_multi_out(codec);
+	via_auto_init_hp_out(codec);
+	via_auto_init_analog_input(codec);
+	return 0;
+}
+
+static int patch_vt1708(struct hda_codec *codec)
+{
+	struct via_spec *spec;
+	int err;
+
+	/* create a codec specific record */
+	spec = kcalloc(1, sizeof(*spec), GFP_KERNEL);
+	if (spec == NULL)
+		return -ENOMEM;
+
+	codec->spec = spec;
+
+	/* automatic parse from the BIOS config */
+	err = vt1708_parse_auto_config(codec);
+	if (err < 0) {
+		via_free(codec);
+		return err;
+	} else if (!err) {
+		printk(KERN_INFO "hda_codec: Cannot set up configuration "
+		       "from BIOS.  Using genenic mode...\n");
+	}
+
+	
+	spec->stream_name_analog = "VT1708 Analog";
+	spec->stream_analog_playback = &vt1708_pcm_analog_playback;
+	spec->stream_analog_capture = &vt1708_pcm_analog_capture;
+
+	spec->stream_name_digital = "VT1708 Digital";
+	spec->stream_digital_playback = &vt1708_pcm_digital_playback;
+	spec->stream_digital_capture = &vt1708_pcm_digital_capture;
+
+	
+	if (!spec->adc_nids && spec->input_mux) {
+		spec->adc_nids = vt1708_adc_nids;
+		spec->num_adc_nids = ARRAY_SIZE(vt1708_adc_nids);
+		spec->mixers[spec->num_mixers] = vt1708_capture_mixer;
+		spec->num_mixers++;
+	}
+
+	codec->patch_ops = via_patch_ops;
+
+	codec->patch_ops.init = via_auto_init;
+
+	return 0;
+}
+
+/* capture mixer elements */
+static struct snd_kcontrol_new vt1709_capture_mixer[] = {
+	HDA_CODEC_VOLUME("Capture Volume", 0x14, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x14, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 2, 0x16, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 2, 0x16, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		/* The multiple "Capture Source" controls confuse alsamixer
+		 * So call somewhat different..
+		 * FIXME: the controls appear in the "playback" view!
+		 */
+		/* .name = "Capture Source", */
+		.name = "Input Source",
+		.count = 1,
+		.info = via_mux_enum_info,
+		.get = via_mux_enum_get,
+		.put = via_mux_enum_put,
+	},
+	{ } /* end */
+};
+
+/*
+ * generic initialization of ADC, input mixers and output mixers
+ */
+static struct hda_verb vt1709_10ch_volume_init_verbs[] = {
+	/*
+	 * Unmute ADC0-2 and set the default input to mic-in
+	 */
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+
+
+	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of the analog-loopback
+	 * mixer widget
+	 */
+	/* Amp Indices: AOW0=0, CD = 1, Mic1 = 2, Line = 3, Mic2 = 4 */
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(4)},
+
+	/*
+	 * Set up output selector (0x1a, 0x1b, 0x29)
+	 */
+	/* set vol=0 to output mixers */
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x29, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+
+	/*
+	 *  Unmute PW3 and PW4
+	 */
+	{0x1f, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x20, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+
+	/* Set input of PW4 as AOW4 */
+	{0x20, AC_VERB_SET_CONNECT_SEL, 0x1},
+	/* Set mic as default input of sw0 */
+	{0x19, AC_VERB_SET_CONNECT_SEL, 0x2},
+	/* PW9 Output enable */
+	{0x24, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40},
+	{ }
+};
+
+static struct hda_pcm_stream vt1709_10ch_pcm_analog_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 10,
+	.nid = 0x10, /* NID to query formats and rates */
+	.ops = {
+		.open = via_playback_pcm_open,
+		.prepare = via_playback_pcm_prepare,
+		.cleanup = via_playback_pcm_cleanup
+	},
+};
+
+static struct hda_pcm_stream vt1709_6ch_pcm_analog_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 6,
+	.nid = 0x10, /* NID to query formats and rates */
+	.ops = {
+		.open = via_playback_pcm_open,
+		.prepare = via_playback_pcm_prepare,
+		.cleanup = via_playback_pcm_cleanup
+	},
+};
+
+static struct hda_pcm_stream vt1709_pcm_analog_capture = {
+	.substreams = 2,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0x14, /* NID to query formats and rates */
+	.ops = {
+		.prepare = via_capture_pcm_prepare,
+		.cleanup = via_capture_pcm_cleanup
+	},
+};
+
+static struct hda_pcm_stream vt1709_pcm_digital_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	/* NID is set in via_build_pcms */
+	.ops = {
+		.open = via_dig_playback_pcm_open,
+		.close = via_dig_playback_pcm_close
+	},
+};
+
+static struct hda_pcm_stream vt1709_pcm_digital_capture = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+
+static int vt1709_auto_fill_dac_nids(struct via_spec *spec,
+				     const struct auto_pin_cfg *cfg)
+{
+	int i;
+	hda_nid_t nid;
+
+	if (cfg->line_outs == 4)  /* 10 channels */
+		spec->multiout.num_dacs = cfg->line_outs+1; /* AOW0~AOW4 */
+	else if (cfg->line_outs == 3) /* 6 channels */
+		spec->multiout.num_dacs = cfg->line_outs; /* AOW0~AOW2 */
+
+	spec->multiout.dac_nids = spec->private_dac_nids;
+
+	if (cfg->line_outs == 4) { /* 10 channels */
+		for (i = 0; i < cfg->line_outs; i++) {
+			nid = cfg->line_out_pins[i];
+			if (nid) {
+				/* config dac list */
+				switch (i) {
+				case AUTO_SEQ_FRONT:
+					/* AOW0 */
+					spec->multiout.dac_nids[i] = 0x10;
+					break;
+				case AUTO_SEQ_CENLFE:
+					/* AOW2 */
+					spec->multiout.dac_nids[i] = 0x12;
+					break;
+				case AUTO_SEQ_SURROUND:
+					/* AOW3 */
+					spec->multiout.dac_nids[i] = 0x27;
+					break;
+				case AUTO_SEQ_SIDE:
+					/* AOW1 */
+					spec->multiout.dac_nids[i] = 0x11;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+		spec->multiout.dac_nids[cfg->line_outs] = 0x28; /* AOW4 */
+
+	} else if (cfg->line_outs == 3) { /* 6 channels */
+		for(i = 0; i < cfg->line_outs; i++) {
+			nid = cfg->line_out_pins[i];
+			if (nid) {
+				/* config dac list */
+				switch(i) {
+				case AUTO_SEQ_FRONT:
+					/* AOW0 */
+					spec->multiout.dac_nids[i] = 0x10;
+					break;
+				case AUTO_SEQ_CENLFE:
+					/* AOW2 */
+					spec->multiout.dac_nids[i] = 0x12;
+					break;
+				case AUTO_SEQ_SURROUND:
+					/* AOW1 */
+					spec->multiout.dac_nids[i] = 0x11;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* add playback controls from the parsed DAC table */
+static int vt1709_auto_create_multi_out_ctls(struct via_spec *spec,
+					     const struct auto_pin_cfg *cfg)
+{
+	char name[32];
+	static const char *chname[4] = { "Front", "Surround", "C/LFE", "Side" };
+	hda_nid_t nid = 0;
+	int i, err;
+
+	for (i = 0; i <= AUTO_SEQ_SIDE; i++) {
+		nid = cfg->line_out_pins[i];
+
+		if (!nid)	
+			continue;
+
+		if (i == AUTO_SEQ_CENLFE) {
+			/* Center/LFE */
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+					      "Center Playback Volume",
+					      HDA_COMPOSE_AMP_VAL(0x1b, 1, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+					      "LFE Playback Volume",
+					      HDA_COMPOSE_AMP_VAL(0x1b, 2, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+					      "Center Playback Switch",
+					      HDA_COMPOSE_AMP_VAL(0x1b, 1, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+					      "LFE Playback Switch",
+					      HDA_COMPOSE_AMP_VAL(0x1b, 2, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		} else if (i == AUTO_SEQ_FRONT){
+			/* add control to mixer index 0 */
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+					      "Master Front Playback Volume",
+					      HDA_COMPOSE_AMP_VAL(0x18, 3, 0, HDA_INPUT));
+			if (err < 0)
+				return err;
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+					      "Master Front Playback Switch",
+					      HDA_COMPOSE_AMP_VAL(0x18, 3, 0, HDA_INPUT));
+			if (err < 0)
+				return err;
+			
+			/* add control to PW3 */
+			sprintf(name, "%s Playback Volume", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL, name,
+					      HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			sprintf(name, "%s Playback Switch", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE, name,
+					      HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		} else if (i == AUTO_SEQ_SURROUND) {
+			sprintf(name, "%s Playback Volume", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL, name,
+					      HDA_COMPOSE_AMP_VAL(0x29, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			sprintf(name, "%s Playback Switch", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE, name,
+					      HDA_COMPOSE_AMP_VAL(0x29, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		} else if (i == AUTO_SEQ_SIDE) {
+			sprintf(name, "%s Playback Volume", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_VOL, name,
+					      HDA_COMPOSE_AMP_VAL(0x1a, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+			sprintf(name, "%s Playback Switch", chname[i]);
+			err = via_add_control(spec, VIA_CTL_WIDGET_MUTE, name,
+					      HDA_COMPOSE_AMP_VAL(0x1a, 3, 0, HDA_OUTPUT));
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int vt1709_auto_create_hp_ctls(struct via_spec *spec, hda_nid_t pin)
+{
+	int err;
+
+	if (!pin)
+		return 0;
+
+	if (spec->multiout.num_dacs == 5) /* 10 channels */
+		spec->multiout.hp_nid = VT1709_HP_DAC_NID;
+	else if (spec->multiout.num_dacs == 3) /* 6 channels */
+		spec->multiout.hp_nid = 0;
+
+	err = via_add_control(spec, VIA_CTL_WIDGET_VOL,
+			      "Headphone Playback Volume",
+			      HDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_OUTPUT));
+	if (err < 0)
+		return err;
+	err = via_add_control(spec, VIA_CTL_WIDGET_MUTE,
+			      "Headphone Playback Switch",
+			      HDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_OUTPUT));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/* create playback/capture controls for input pins */
+static int vt1709_auto_create_analog_input_ctls(struct via_spec *spec,
+						const struct auto_pin_cfg *cfg)
+{
+	static char *labels[] = {
+		"Mic", "Front Mic", "Line", "Front Line", "CD", "Aux", NULL
+	};
+	struct hda_input_mux *imux = &spec->private_imux;
+	int i, err, idx = 0;
+
+	/* for internal loopback recording select */
+	imux->items[imux->num_items].label = "Stereo Mixer";
+	imux->items[imux->num_items].index = idx;
+	imux->num_items++;
+
+	for (i = 0; i < AUTO_PIN_LAST; i++) {
+		if (!cfg->input_pins[i])
+			continue;
+
+		switch (cfg->input_pins[i]) {
+		case 0x1d: /* Mic */
+			idx = 2;
+			break;
+				
+		case 0x1e: /* Line In */
+			idx = 3;
+			break;
+
+		case 0x21: /* Front Mic */
+			idx = 4;
+			break;
+
+		case 0x23: /* CD */
+			idx = 1;
+			break;
+		}
+		err = via_new_analog_input(spec, cfg->input_pins[i], labels[i],
+					   idx, 0x18);
+		if (err < 0)
+			return err;
+		imux->items[imux->num_items].label = labels[i];
+		imux->items[imux->num_items].index = idx;
+		imux->num_items++;
+	}
+	return 0;
+}
+
+static int vt1709_parse_auto_config(struct hda_codec *codec)
+{
+	struct via_spec *spec = codec->spec;
+	int err;
+
+	err = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);
+	if (err < 0)
+		return err;
+	err = vt1709_auto_fill_dac_nids(spec, &spec->autocfg);
+	if (err < 0)
+		return err;
+	if (!spec->autocfg.line_outs && !spec->autocfg.hp_pins[0])
+		return 0; /* can't find valid BIOS pin config */
+
+	err = vt1709_auto_create_multi_out_ctls(spec, &spec->autocfg);
+	if (err < 0)
+		return err;
+	err = vt1709_auto_create_hp_ctls(spec, spec->autocfg.hp_pins[0]);
+	if (err < 0)
+		return err;
+	err = vt1709_auto_create_analog_input_ctls(spec, &spec->autocfg);
+	if (err < 0)
+		return err;
+
+	spec->multiout.max_channels = spec->multiout.num_dacs * 2;
+
+	if (spec->autocfg.dig_out_pin)
+		spec->multiout.dig_out_nid = VT1709_DIGOUT_NID;
+	if (spec->autocfg.dig_in_pin)
+		spec->dig_in_nid = VT1709_DIGIN_NID;
+
+	if (spec->kctl_alloc)
+		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
+
+	spec->input_mux = &spec->private_imux;
+
+	return 1;
+}
+
+static int patch_vt1709_10ch(struct hda_codec *codec)
+{
+	struct via_spec *spec;
+	int err;
+
+	/* create a codec specific record */
+	spec = kcalloc(1, sizeof(*spec), GFP_KERNEL);
+	if (spec == NULL)
+		return -ENOMEM;
+
+	codec->spec = spec;
+
+	err = vt1709_parse_auto_config(codec);
+	if (err < 0) {
+		via_free(codec);
+		return err;
+	} else if (!err) {
+		printk(KERN_INFO "hda_codec: Cannot set up configuration.  "
+		       "Using genenic mode...\n");
+	}
+
+	spec->init_verbs = vt1709_10ch_volume_init_verbs;	
+
+	spec->stream_name_analog = "VT1709 Analog";
+	spec->stream_analog_playback = &vt1709_10ch_pcm_analog_playback;
+	spec->stream_analog_capture = &vt1709_pcm_analog_capture;
+
+	spec->stream_name_digital = "VT1709 Digital";
+	spec->stream_digital_playback = &vt1709_pcm_digital_playback;
+	spec->stream_digital_capture = &vt1709_pcm_digital_capture;
+
+	
+	if (!spec->adc_nids && spec->input_mux) {
+		spec->adc_nids = vt1709_adc_nids;
+		spec->num_adc_nids = ARRAY_SIZE(vt1709_adc_nids);
+		spec->mixers[spec->num_mixers] = vt1709_capture_mixer;
+		spec->num_mixers++;
+	}
+
+	codec->patch_ops = via_patch_ops;
+
+	codec->patch_ops.init = via_auto_init;
+
+	return 0;
+}
+/*
+ * generic initialization of ADC, input mixers and output mixers
+ */
+static struct hda_verb vt1709_6ch_volume_init_verbs[] = {
+	/*
+	 * Unmute ADC0-2 and set the default input to mic-in
+	 */
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+
+
+	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of the analog-loopback
+	 * mixer widget
+	 */
+	/* Amp Indices: AOW0=0, CD = 1, Mic1 = 2, Line = 3, Mic2 = 4 */
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(4)},
+
+	/*
+	 * Set up output selector (0x1a, 0x1b, 0x29)
+	 */
+	/* set vol=0 to output mixers */
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x29, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+
+	/*
+	 *  Unmute PW3 and PW4
+	 */
+	{0x1f, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x20, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+
+	/* Set input of PW4 as MW0 */
+	{0x20, AC_VERB_SET_CONNECT_SEL, 0},
+	/* Set mic as default input of sw0 */
+	{0x19, AC_VERB_SET_CONNECT_SEL, 0x2},
+	/* PW9 Output enable */
+	{0x24, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40},
+	{ }
+};
+
+static int patch_vt1709_6ch(struct hda_codec *codec)
+{
+	struct via_spec *spec;
+	int err;
+
+	/* create a codec specific record */
+	spec = kcalloc(1, sizeof(*spec), GFP_KERNEL);
+	if (spec == NULL)
+		return -ENOMEM;
+
+	codec->spec = spec;
+
+	err = vt1709_parse_auto_config(codec);
+	if (err < 0) {
+		via_free(codec);
+		return err;
+	} else if (!err) {
+		printk(KERN_INFO "hda_codec: Cannot set up configuration.  "
+		       "Using genenic mode...\n");
+	}
+
+	spec->init_verbs = vt1709_6ch_volume_init_verbs;	
+
+	spec->stream_name_analog = "VT1709 Analog";
+	spec->stream_analog_playback = &vt1709_6ch_pcm_analog_playback;
+	spec->stream_analog_capture = &vt1709_pcm_analog_capture;
+
+	spec->stream_name_digital = "VT1709 Digital";
+	spec->stream_digital_playback = &vt1709_pcm_digital_playback;
+	spec->stream_digital_capture = &vt1709_pcm_digital_capture;
+
+	
+	if (!spec->adc_nids && spec->input_mux) {
+		spec->adc_nids = vt1709_adc_nids;
+		spec->num_adc_nids = ARRAY_SIZE(vt1709_adc_nids);
+		spec->mixers[spec->num_mixers] = vt1709_capture_mixer;
+		spec->num_mixers++;
+	}
+
+	codec->patch_ops = via_patch_ops;
+
+	codec->patch_ops.init = via_auto_init;
+
+	return 0;
+}
+
+/*
+ * patch entries
+ */
+struct hda_codec_preset snd_hda_preset_via[] = {
+	{ .id = 0x11061708, .name = "VIA VT1708", .patch = patch_vt1708},
+	{ .id = 0x11061709, .name = "VIA VT1708", .patch = patch_vt1708},
+	{ .id = 0x1106170A, .name = "VIA VT1708", .patch = patch_vt1708},
+	{ .id = 0x1106170B, .name = "VIA VT1708", .patch = patch_vt1708},
+	{ .id = 0x1106E710, .name = "VIA VT1709 10-Ch", .patch = patch_vt1709_10ch},
+	{ .id = 0x1106E711, .name = "VIA VT1709 10-Ch", .patch = patch_vt1709_10ch},
+	{ .id = 0x1106E712, .name = "VIA VT1709 10-Ch", .patch = patch_vt1709_10ch},
+	{ .id = 0x1106E713, .name = "VIA VT1709 10-Ch", .patch = patch_vt1709_10ch},
+	{ .id = 0x1106E714, .name = "VIA VT1709 6-Ch", .patch = patch_vt1709_6ch},
+	{ .id = 0x1106E715, .name = "VIA VT1709 6-Ch", .patch = patch_vt1709_6ch},
+	{ .id = 0x1106E716, .name = "VIA VT1709 6-Ch", .patch = patch_vt1709_6ch},
+	{ .id = 0x1106E717, .name = "VIA VT1709 6-Ch", .patch = patch_vt1709_6ch},
+	{} /* terminator */
+};
--- linux-2.6.18.noarch/sound/pci/hda/patch_cmedia.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_cmedia.c	2007-06-05 17:46:40.000000000 -0400
@@ -40,6 +40,7 @@
 	CMI_FULL_DIG,	/* back 6-jack + front-panel 2-jack + digital I/O */
 	CMI_ALLOUT,	/* back 5-jack + front-panel 2-jack + digital out */
 	CMI_AUTO,	/* let driver guess it */
+	CMI_MODELS
 };
 
 struct cmi_spec {
@@ -603,14 +604,17 @@
 /*
  */
 
-static struct hda_board_config cmi9880_cfg_tbl[] = {
-	{ .modelname = "minimal", .config = CMI_MINIMAL },
-	{ .modelname = "min_fp", .config = CMI_MIN_FP },
-	{ .modelname = "full", .config = CMI_FULL },
-	{ .modelname = "full_dig", .config = CMI_FULL_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x813d, .config = CMI_FULL_DIG }, /* ASUS P5AD2 */
-	{ .modelname = "allout", .config = CMI_ALLOUT },
-	{ .modelname = "auto", .config = CMI_AUTO },
+static const char *cmi9880_models[CMI_MODELS] = {
+	[CMI_MINIMAL]	= "minimal",
+	[CMI_MIN_FP]	= "min_fp",
+	[CMI_FULL]	= "full",
+	[CMI_FULL_DIG]	= "full_dig",
+	[CMI_ALLOUT]	= "allout",
+	[CMI_AUTO]	= "auto",
+};
+
+static struct snd_pci_quirk cmi9880_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1043, 0x813d, "ASUS P5AD2", CMI_FULL_DIG),
 	{} /* terminator */
 };
 
@@ -633,7 +637,9 @@
 		return -ENOMEM;
 
 	codec->spec = spec;
-	spec->board_config = snd_hda_check_board_config(codec, cmi9880_cfg_tbl);
+	spec->board_config = snd_hda_check_board_config(codec, CMI_MODELS,
+							cmi9880_models,
+							cmi9880_cfg_tbl);
 	if (spec->board_config < 0) {
 		snd_printdd(KERN_INFO "hda_codec: Unknown model for CMI9880\n");
 		spec->board_config = CMI_AUTO; /* try everything */
--- linux-2.6.18.noarch/sound/pci/hda/hda_patch.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_patch.h	2007-06-05 17:46:40.000000000 -0400
@@ -14,6 +14,10 @@
 extern struct hda_codec_preset snd_hda_preset_si3054[];
 /* ATI HDMI codecs */
 extern struct hda_codec_preset snd_hda_preset_atihdmi[];
+/* Conexant audio codec */
+extern struct hda_codec_preset snd_hda_preset_conexant[];
+/* VIA codecs */
+extern struct hda_codec_preset snd_hda_preset_via[];
 
 static const struct hda_codec_preset *hda_preset_tables[] = {
 	snd_hda_preset_realtek,
@@ -22,5 +26,7 @@
 	snd_hda_preset_sigmatel,
 	snd_hda_preset_si3054,
 	snd_hda_preset_atihdmi,
+	snd_hda_preset_conexant,
+	snd_hda_preset_via,
 	NULL
 };
--- linux-2.6.18.noarch/sound/pci/hda/hda_local.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_local.h	2007-06-05 17:46:40.000000000 -0400
@@ -30,9 +30,13 @@
 /* mono volume with index (index=0,1,...) (channel=1,2) */
 #define HDA_CODEC_VOLUME_MONO_IDX(xname, xcidx, nid, channel, xindex, direction) \
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xcidx,  \
+	  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+	  	    SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
+	  	    SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \
 	  .info = snd_hda_mixer_amp_volume_info, \
 	  .get = snd_hda_mixer_amp_volume_get, \
 	  .put = snd_hda_mixer_amp_volume_put, \
+	  .tlv = { .c = snd_hda_mixer_amp_tlv },		\
 	  .private_value = HDA_COMPOSE_AMP_VAL(nid, channel, xindex, direction) }
 /* stereo volume with index */
 #define HDA_CODEC_VOLUME_IDX(xname, xcidx, nid, xindex, direction) \
@@ -63,6 +67,7 @@
 int snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo);
 int snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
 int snd_hda_mixer_amp_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+int snd_hda_mixer_amp_tlv(struct snd_kcontrol *kcontrol, int op_flag, unsigned int size, unsigned int __user *tlv);
 int snd_hda_mixer_amp_switch_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo);
 int snd_hda_mixer_amp_switch_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
 int snd_hda_mixer_amp_switch_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
@@ -168,14 +173,9 @@
 /*
  * Misc
  */
-struct hda_board_config {
-	const char *modelname;
-	int config;
-	unsigned short pci_subvendor;
-	unsigned short pci_subdevice;
-};
-
-int snd_hda_check_board_config(struct hda_codec *codec, const struct hda_board_config *tbl);
+int snd_hda_check_board_config(struct hda_codec *codec, int num_configs,
+			       const char **modelnames,
+			       const struct snd_pci_quirk *pci_list);
 int snd_hda_add_new_ctls(struct hda_codec *codec, struct snd_kcontrol_new *knew);
 
 /*
@@ -199,8 +199,8 @@
 	unsigned int rp, wp;
 
 	/* workqueue */
-	struct workqueue_struct *workq;
 	struct work_struct work;
+	struct hda_bus *bus;
 };
 
 /*
@@ -224,7 +224,8 @@
 	hda_nid_t line_out_pins[5]; /* sorted in the order of Front/Surr/CLFE/Side */
 	int speaker_outs;
 	hda_nid_t speaker_pins[5];
-	hda_nid_t hp_pin;
+	int hp_outs;
+	hda_nid_t hp_pins[5];
 	hda_nid_t input_pins[AUTO_PIN_LAST];
 	hda_nid_t dig_out_pin;
 	hda_nid_t dig_in_pin;
--- linux-2.6.18.noarch/sound/pci/hda/patch_realtek.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_realtek.c	2007-06-06 13:09:27.000000000 -0400
@@ -32,6 +32,10 @@
 #include "hda_codec.h"
 #include "hda_local.h"
 
+#define ALC880_FRONT_EVENT		0x01
+#define ALC880_DCVOL_EVENT		0x02
+#define ALC880_HP_EVENT			0x04
+#define ALC880_MIC_EVENT		0x08
 
 /* ALC880 board config type */
 enum {
@@ -48,7 +52,10 @@
 	ALC880_ASUS_DIG,
 	ALC880_ASUS_W1V,
 	ALC880_ASUS_DIG2,
+	ALC880_FUJITSU,
 	ALC880_UNIWILL_DIG,
+	ALC880_UNIWILL,
+	ALC880_UNIWILL_P53,
 	ALC880_CLEVO,
 	ALC880_TCL_S700,
 	ALC880_LG,
@@ -77,8 +84,13 @@
 /* ALC262 models */
 enum {
 	ALC262_BASIC,
+	ALC262_HIPPO,
+	ALC262_HIPPO_1,
 	ALC262_FUJITSU,
 	ALC262_HP_BPC,
+	ALC262_HP_BPC_D7000_WL,
+	ALC262_HP_BPC_D7000_WF,
+	ALC262_BENQ_ED8,
 	ALC262_AUTO,
 	ALC262_MODEL_LAST /* last tag */
 };
@@ -89,15 +101,31 @@
 	ALC660_3ST,
 	ALC861_3ST_DIG,
 	ALC861_6ST_DIG,
+	ALC861_UNIWILL_M31,
+	ALC861_TOSHIBA,
+	ALC861_ASUS,
+	ALC861_ASUS_LAPTOP,
 	ALC861_AUTO,
 	ALC861_MODEL_LAST,
 };
 
+/* ALC861-VD models */
+enum {
+	ALC660VD_3ST,
+	ALC861VD_3ST,
+	ALC861VD_3ST_DIG,
+	ALC861VD_6ST_DIG,
+	ALC861VD_AUTO,
+	ALC861VD_MODEL_LAST,
+};
+
 /* ALC882 models */
 enum {
 	ALC882_3ST_DIG,
 	ALC882_6ST_DIG,
+	ALC882_ARIMA,
 	ALC882_AUTO,
+	ALC885_MACPRO,
 	ALC882_MODEL_LAST,
 };
 
@@ -107,7 +135,12 @@
 	ALC883_3ST_6ch_DIG,
 	ALC883_3ST_6ch,
 	ALC883_6ST_DIG,
+	ALC883_TARGA_DIG,
+	ALC883_TARGA_2ch_DIG,
 	ALC888_DEMO_BOARD,
+	ALC883_ACER,
+	ALC883_MEDION,
+	ALC883_LAPTOP_EAPD,
 	ALC883_AUTO,
 	ALC883_MODEL_LAST,
 };
@@ -153,6 +186,7 @@
 	/* channel model */
 	const struct hda_channel_mode *channel_mode;
 	int num_channel_mode;
+	int need_dac_fix;
 
 	/* PCM information */
 	struct hda_pcm pcm_rec[3];	/* used in alc_build_pcms() */
@@ -190,6 +224,7 @@
 	hda_nid_t dig_in_nid;
 	unsigned int num_channel_mode;
 	const struct hda_channel_mode *channel_mode;
+	int need_dac_fix;
 	unsigned int num_mux_defs;
 	const struct hda_input_mux *input_mux;
 	void (*unsol_event)(struct hda_codec *, unsigned int);
@@ -262,9 +297,12 @@
 {
 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct alc_spec *spec = codec->spec;
-	return snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,
-				   spec->num_channel_mode,
-				   &spec->multiout.max_channels);
+	int err = snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,
+				      spec->num_channel_mode,
+				      &spec->multiout.max_channels);
+	if (err >= 0 && spec->need_dac_fix)
+		spec->multiout.num_dacs = spec->multiout.max_channels / 2;
+	return err;
 }
 
 /*
@@ -544,6 +582,7 @@
 	
 	spec->channel_mode = preset->channel_mode;
 	spec->num_channel_mode = preset->num_channel_mode;
+	spec->need_dac_fix = preset->need_dac_fix;
 
 	spec->multiout.max_channels = spec->channel_mode[0].channels;
 
@@ -1005,6 +1044,60 @@
 	{ } /* end */
 };
 
+/* Uniwill */
+static struct snd_kcontrol_new alc880_uniwill_mixer[] = {
+	HDA_CODEC_VOLUME("HPhone Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("HPhone Playback Switch", 0x0c, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("iSpeaker Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("iSpeaker Playback Switch", 0x0d, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x0e, 1, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE_MONO("Center Playback Switch", 0x0e, 1, 2, HDA_INPUT),
+	HDA_BIND_MUTE_MONO("LFE Playback Switch", 0x0e, 2, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
+	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Channel Mode",
+		.info = alc_ch_mode_info,
+		.get = alc_ch_mode_get,
+		.put = alc_ch_mode_put,
+	},
+	{ } /* end */
+};
+
+static struct snd_kcontrol_new alc880_fujitsu_mixer[] = {
+	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Headphone Playback Switch", 0x0c, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("Speaker Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Speaker Playback Switch", 0x0d, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("Ext Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Ext Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Int Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_MUTE("Int Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
+	{ } /* end */
+};
+
+static struct snd_kcontrol_new alc880_uniwill_p53_mixer[] = {
+	HDA_CODEC_VOLUME("HPhone Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("HPhone Playback Switch", 0x0c, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("iSpeaker Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("iSpeaker Playback Switch", 0x0d, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	{ } /* end */
+};
+
 /*
  * build control elements
  */
@@ -1238,6 +1331,159 @@
 	{ }
 };
 
+/*
+ * Uniwill pin configuration:
+ * HP = 0x14, InternalSpeaker = 0x15, mic = 0x18, internal mic = 0x19,
+ * line = 0x1a
+ */
+static struct hda_verb alc880_uniwill_init_verbs[] = {
+	{0x13, AC_VERB_SET_CONNECT_SEL, 0x00}, /* HP */
+
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x16, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x17, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+
+	{0x18, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* {0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP}, */
+	/* {0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE}, */
+	{0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+
+	{0x14, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_HP_EVENT},
+	{0x18, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_MIC_EVENT},
+
+	{ }
+};
+
+/*
+* Uniwill P53
+* HP = 0x14, InternalSpeaker = 0x15, mic = 0x19, 
+ */
+static struct hda_verb alc880_uniwill_p53_init_verbs[] = {
+	{0x13, AC_VERB_SET_CONNECT_SEL, 0x00}, /* HP */
+
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x16, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+
+	{0x18, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+
+	{0x14, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_HP_EVENT},
+	{0x21, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_DCVOL_EVENT},
+
+	{ }
+};
+
+static struct hda_verb alc880_beep_init_verbs[] = {
+	{ 0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(5) },
+	{ }
+};
+
+/* toggle speaker-output according to the hp-jack state */
+static void alc880_uniwill_automute(struct hda_codec *codec)
+{
+ 	unsigned int present;
+
+ 	present = snd_hda_codec_read(codec, 0x14, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+	snd_hda_codec_amp_update(codec, 0x15, 0, HDA_OUTPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x15, 1, HDA_OUTPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x16, 0, HDA_OUTPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x16, 1, HDA_OUTPUT, 0,
+				 0x80, present ? 0x80 : 0);
+
+	present = snd_hda_codec_read(codec, 0x18, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+	snd_hda_codec_write(codec, 0x0b, 0, AC_VERB_SET_AMP_GAIN_MUTE,
+			    0x7000 | (0x01 << 8) | (present ? 0x80 : 0));
+}
+
+static void alc880_uniwill_unsol_event(struct hda_codec *codec,
+				       unsigned int res)
+{
+	/* Looks like the unsol event is incompatible with the standard
+	 * definition.  4bit tag is placed at 28 bit!
+	 */
+	if ((res >> 28) == ALC880_HP_EVENT ||
+	    (res >> 28) == ALC880_MIC_EVENT)
+		alc880_uniwill_automute(codec);
+}
+
+static void alc880_uniwill_p53_hp_automute(struct hda_codec *codec)
+{
+ 	unsigned int present;
+
+ 	present = snd_hda_codec_read(codec, 0x14, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+
+	snd_hda_codec_amp_update(codec, 0x15, 0, HDA_INPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x15, 1, HDA_INPUT, 0,
+				 0x80, present ? 0x80 : 0);
+}
+
+static void alc880_uniwill_p53_dcvol_automute(struct hda_codec *codec)
+{
+	unsigned int present;
+	
+	present = snd_hda_codec_read(codec, 0x21, 0,
+				     AC_VERB_GET_VOLUME_KNOB_CONTROL, 0) & 0x7f;
+
+	snd_hda_codec_amp_update(codec, 0x0c, 0, HDA_OUTPUT, 0,
+				 0x7f, present);
+	snd_hda_codec_amp_update(codec, 0x0c, 1, HDA_OUTPUT, 0,
+				 0x7f,  present);
+
+	snd_hda_codec_amp_update(codec, 0x0d, 0, HDA_OUTPUT, 0,
+				 0x7f,  present);
+	snd_hda_codec_amp_update(codec, 0x0d, 1, HDA_OUTPUT, 0,
+				 0x7f, present);
+
+}
+static void alc880_uniwill_p53_unsol_event(struct hda_codec *codec,
+					   unsigned int res)
+{
+	/* Looks like the unsol event is incompatible with the standard
+	 * definition.  4bit tag is placed at 28 bit!
+	 */
+	if ((res >> 28) == ALC880_HP_EVENT)
+		alc880_uniwill_p53_hp_automute(codec);
+	if ((res >> 28) == ALC880_DCVOL_EVENT) 
+		alc880_uniwill_p53_dcvol_automute(codec);
+}
+
 /* FIXME! */
 /*
  * F1734 pin configuration:
@@ -1348,6 +1594,10 @@
 };
 
 static struct hda_verb alc880_pin_tcl_S700_init_verbs[] = {
+	/* change to EAPD mode */
+	{0x20, AC_VERB_SET_COEF_INDEX, 0x07},
+	{0x20, AC_VERB_SET_PROC_COEF,  0x3060},
+
 	/* Headphone output */
 	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
 	/* Front output*/
@@ -1782,26 +2032,10 @@
 		}
 	}
 
-	/* If the use of more than one ADC is requested for the current
-	 * model, configure a second analog capture-only PCM.
-	 */
-	if (spec->num_adc_nids > 1) {
-		codec->num_pcms++;
-		info++;
-		info->name = spec->stream_name_analog;
-		/* No playback stream for second PCM */
-		info->stream[SNDRV_PCM_STREAM_PLAYBACK] = alc_pcm_null_playback;
-		info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = 0;
-		if (spec->stream_analog_capture) {
-			snd_assert(spec->adc_nids, return -EINVAL);
-			info->stream[SNDRV_PCM_STREAM_CAPTURE] = *(spec->stream_analog_capture);
-			info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adc_nids[1];
-		}
-	}
-
+	/* SPDIF for stream index #1 */
 	if (spec->multiout.dig_out_nid || spec->dig_in_nid) {
-		codec->num_pcms++;
-		info++;
+		codec->num_pcms = 2;
+		info = spec->pcm_rec + 1;
 		info->name = spec->stream_name_digital;
 		if (spec->multiout.dig_out_nid &&
 		    spec->stream_digital_playback) {
@@ -1815,6 +2049,24 @@
 		}
 	}
 
+	/* If the use of more than one ADC is requested for the current
+	 * model, configure a second analog capture-only PCM.
+	 */
+	/* Additional Analaog capture for index #2 */
+	if (spec->num_adc_nids > 1 && spec->stream_analog_capture &&
+	    spec->adc_nids) {
+		codec->num_pcms = 3;
+		info = spec->pcm_rec + 2;
+		info->name = spec->stream_name_analog;
+		/* No playback stream for second PCM */
+		info->stream[SNDRV_PCM_STREAM_PLAYBACK] = alc_pcm_null_playback;
+		info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = 0;
+		if (spec->stream_analog_capture) {
+			info->stream[SNDRV_PCM_STREAM_CAPTURE] = *(spec->stream_analog_capture);
+			info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adc_nids[1];
+		}
+	}
+
 	return 0;
 }
 
@@ -2109,145 +2361,112 @@
 /*
  */
 
-static struct hda_board_config alc880_cfg_tbl[] = {
-	/* Back 3 jack, front 2 jack */
-	{ .modelname = "3stack", .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe200, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe201, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe202, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe203, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe204, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe205, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe206, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe207, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe208, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe209, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe20a, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe20b, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe20c, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe20d, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe20e, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe20f, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe210, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe211, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe214, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe302, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe303, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe304, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe306, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe307, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe404, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xa101, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x3031, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x4036, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x4037, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x4038, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x4040, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x4041, .config = ALC880_3ST },
-	/* TCL S700 */
-	{ .pci_subvendor = 0x19db, .pci_subdevice = 0x4188, .config = ALC880_TCL_S700 },
-
-	/* Back 3 jack, front 2 jack (Internal add Aux-In) */
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0xe310, .config = ALC880_3ST },
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81d6, .config = ALC880_3ST }, 
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81a0, .config = ALC880_3ST },
-
-	/* Back 3 jack plus 1 SPDIF out jack, front 2 jack */
-	{ .modelname = "3stack-digout", .config = ALC880_3ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe308, .config = ALC880_3ST_DIG },
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0x0070, .config = ALC880_3ST_DIG },
-	/* Clevo m520G NB */
-	{ .pci_subvendor = 0x1558, .pci_subdevice = 0x0520, .config = ALC880_CLEVO },
-
-	/* Back 3 jack plus 1 SPDIF out jack, front 2 jack (Internal add Aux-In)*/
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe305, .config = ALC880_3ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xd402, .config = ALC880_3ST_DIG },
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0xe309, .config = ALC880_3ST_DIG },
-
-	/* Back 5 jack, front 2 jack */
-	{ .modelname = "5stack", .config = ALC880_5ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x3033, .config = ALC880_5ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x4039, .config = ALC880_5ST },
-	{ .pci_subvendor = 0x107b, .pci_subdevice = 0x3032, .config = ALC880_5ST },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x2a09, .config = ALC880_5ST },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x814e, .config = ALC880_5ST },
-
-	/* Back 5 jack plus 1 SPDIF out jack, front 2 jack */
-	{ .modelname = "5stack-digout", .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe224, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe400, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe401, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xe402, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xd400, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xd401, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xa100, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x1565, .pci_subdevice = 0x8202, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0x1019, .pci_subdevice = 0xa880, .config = ALC880_5ST_DIG },
-	{ .pci_subvendor = 0xa0a0, .pci_subdevice = 0x0560,
-	  .config = ALC880_5ST_DIG }, /* Aopen i915GMm-HFS */
-	/* { .pci_subvendor = 0x1019, .pci_subdevice = 0xa884, .config = ALC880_5ST_DIG }, */ /* conflict with 6stack */
-	{ .pci_subvendor = 0x1695, .pci_subdevice = 0x400d, .config = ALC880_5ST_DIG },
-	/* note subvendor = 0 below */
-	/* { .pci_subvendor = 0x0000, .pci_subdevice = 0x8086, .config = ALC880_5ST_DIG }, */
-
-	{ .modelname = "w810", .config = ALC880_W810 },
-	{ .pci_subvendor = 0x161f, .pci_subdevice = 0x203d, .config = ALC880_W810 },
-
-	{ .modelname = "z71v", .config = ALC880_Z71V },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1964, .config = ALC880_Z71V },
-
-	{ .modelname = "6stack", .config = ALC880_6ST },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x8196, .config = ALC880_6ST }, /* ASUS P5GD1-HVM */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x81b4, .config = ALC880_6ST },
-	{ .pci_subvendor = 0x1019, .pci_subdevice = 0xa884, .config = ALC880_6ST }, /* Acer APFV */
-	{ .pci_subvendor = 0x1458, .pci_subdevice = 0xa102, .config = ALC880_6ST }, /* Gigabyte K8N51 */
-
-	{ .modelname = "6stack-digout", .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x2668, .pci_subdevice = 0x8086, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0x2668, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x1462, .pci_subdevice = 0x1150, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0xe803, .pci_subdevice = 0x1019, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x1039, .pci_subdevice = 0x1234, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0x0077, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0x0078, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0x0087, .config = ALC880_6ST_DIG },
-	{ .pci_subvendor = 0x1297, .pci_subdevice = 0xc790, .config = ALC880_6ST_DIG }, /* Shuttle ST20G5 */
-	{ .pci_subvendor = 0x1509, .pci_subdevice = 0x925d, .config = ALC880_6ST_DIG }, /* FIC P4M-915GD1 */
-	{ .pci_subvendor = 0x1695, .pci_subdevice = 0x4012, .config = ALC880_5ST_DIG }, /* Epox EP-5LDA+ GLi */
-
-	{ .modelname = "asus", .config = ALC880_ASUS },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1964, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1973, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x19b3, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1113, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1173, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1993, .config = ALC880_ASUS },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x10c3, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1133, .config = ALC880_ASUS },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1123, .config = ALC880_ASUS_DIG },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1143, .config = ALC880_ASUS },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x10b3, .config = ALC880_ASUS_W1V },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x8181, .config = ALC880_ASUS_DIG }, /* ASUS P4GPL-X */
-	{ .pci_subvendor = 0x1558, .pci_subdevice = 0x5401, .config = ALC880_ASUS_DIG2 },
-
-	{ .modelname = "uniwill", .config = ALC880_UNIWILL_DIG },
-	{ .pci_subvendor = 0x1584, .pci_subdevice = 0x9050, .config = ALC880_UNIWILL_DIG },	
-
-	{ .modelname = "F1734", .config = ALC880_F1734 },
-	{ .pci_subvendor = 0x1734, .pci_subdevice = 0x107c, .config = ALC880_F1734 },
-	{ .pci_subvendor = 0x1584, .pci_subdevice = 0x9054, .config = ALC880_F1734 },
-
-	{ .modelname = "lg", .config = ALC880_LG },
-	{ .pci_subvendor = 0x1854, .pci_subdevice = 0x003b, .config = ALC880_LG },
-	{ .pci_subvendor = 0x1854, .pci_subdevice = 0x0068, .config = ALC880_LG },
-
-	{ .modelname = "lg-lw", .config = ALC880_LG_LW },
-	{ .pci_subvendor = 0x1854, .pci_subdevice = 0x0018, .config = ALC880_LG_LW },
-
+static const char *alc880_models[ALC880_MODEL_LAST] = {
+	[ALC880_3ST]		= "3stack",
+	[ALC880_TCL_S700]	= "tcl",
+	[ALC880_3ST_DIG]	= "3stack-digout",
+	[ALC880_CLEVO]		= "clevo",
+	[ALC880_5ST]		= "5stack",
+	[ALC880_5ST_DIG]	= "5stack-digout",
+	[ALC880_W810]		= "w810",
+	[ALC880_Z71V]		= "z71v",
+	[ALC880_6ST]		= "6stack",
+	[ALC880_6ST_DIG]	= "6stack-digout",
+	[ALC880_ASUS]		= "asus",
+	[ALC880_ASUS_W1V]	= "asus-w1v",
+	[ALC880_ASUS_DIG]	= "asus-dig",
+	[ALC880_ASUS_DIG2]	= "asus-dig2",
+	[ALC880_UNIWILL_DIG]	= "uniwill",
+	[ALC880_UNIWILL_P53]	= "uniwill-p53",
+	[ALC880_FUJITSU]	= "fujitsu",
+	[ALC880_F1734]		= "F1734",
+	[ALC880_LG]		= "lg",
+	[ALC880_LG_LW]		= "lg-lw",
 #ifdef CONFIG_SND_DEBUG
-	{ .modelname = "test", .config = ALC880_TEST },
+	[ALC880_TEST]		= "test",
 #endif
-	{ .modelname = "auto", .config = ALC880_AUTO },
+	[ALC880_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc880_cfg_tbl[] = {
+	/* Broken BIOS configuration */
+	SND_PCI_QUIRK(0x2668, 0x8086, NULL, ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0x2668, NULL, ALC880_6ST_DIG),
+
+	SND_PCI_QUIRK(0x1019, 0xa880, "ECS", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x1019, 0xa884, "Acer APFV", ALC880_6ST),
+	SND_PCI_QUIRK(0x1019, 0x0f69, "Coeus G610P", ALC880_W810),
+	SND_PCI_QUIRK(0x1025, 0x0070, "ULI", ALC880_3ST_DIG),
+	SND_PCI_QUIRK(0x1025, 0x0077, "ULI", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1025, 0x0078, "ULI", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1025, 0x0087, "ULI", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1025, 0xe309, "ULI", ALC880_3ST_DIG),
+	SND_PCI_QUIRK(0x1025, 0xe310, "ULI", ALC880_3ST),
+
+	SND_PCI_QUIRK(0x1039, 0x1234, NULL, ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x103c, 0x2a09, "HP", ALC880_5ST),
+
+	SND_PCI_QUIRK(0x1043, 0x10b3, "ASUS W1V", ALC880_ASUS_W1V),
+	SND_PCI_QUIRK(0x1043, 0x10c2, "ASUS W6A", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x10c3, "ASUS Wxx", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x1113, "ASUS", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x1123, "ASUS", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x1173, "ASUS", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x1964, "ASUS Z71V", ALC880_Z71V),
+	/* SND_PCI_QUIRK(0x1043, 0x1964, "ASUS", ALC880_ASUS_DIG), */
+	SND_PCI_QUIRK(0x1043, 0x1973, "ASUS", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x19b3, "ASUS", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x814e, "ASUS", ALC880_ASUS),
+	SND_PCI_QUIRK(0x1043, 0x8181, "ASUS P4GPL", ALC880_ASUS_DIG),
+	SND_PCI_QUIRK(0x1043, 0x8196, "ASUS P5GD1", ALC880_6ST),
+	SND_PCI_QUIRK(0x1043, 0x81b4, "ASUS", ALC880_6ST),
+	SND_PCI_QUIRK(0x1043, 0, "ASUS", ALC880_ASUS),
+
+	SND_PCI_QUIRK(0x104d, 0x81d6, "Sony", ALC880_3ST),
+	SND_PCI_QUIRK(0x104d, 0x81a0, "Sony", ALC880_3ST),
+	SND_PCI_QUIRK(0x107b, 0x3033, "Gateway", ALC880_5ST),
+	SND_PCI_QUIRK(0x107b, 0x4039, "Gateway", ALC880_5ST),
+	SND_PCI_QUIRK(0x107b, 0x3032, "Gateway", ALC880_5ST),
+	SND_PCI_QUIRK(0x1558, 0x0520, "Clevo m520G", ALC880_CLEVO),
+	SND_PCI_QUIRK(0x1558, 0x0660, "Clevo m655n", ALC880_CLEVO),
+	SND_PCI_QUIRK(0x1565, 0x8202, "Biostar", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x161f, 0x203d, "W810", ALC880_W810),
+	SND_PCI_QUIRK(0x1695, 0x400d, "EPoX", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x19db, 0x4188, "TCL S700", ALC880_TCL_S700),
+	SND_PCI_QUIRK(0xa0a0, 0x0560, "AOpen i915GMm-HFS", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0xe803, 0x1019, NULL, ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1297, 0xc790, "Shuttle ST20G5", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1458, 0xa102, "Gigabyte K8", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1462, 0x1150, "MSI", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1509, 0x925d, "FIC P4M", ALC880_6ST_DIG),
+	SND_PCI_QUIRK(0x1558, 0x5401, "ASUS", ALC880_ASUS_DIG2),
+
+	SND_PCI_QUIRK(0x1584, 0x9050, "Uniwill", ALC880_UNIWILL_DIG),
+	SND_PCI_QUIRK(0x1584, 0x9070, "Uniwill", ALC880_UNIWILL),
+	SND_PCI_QUIRK(0x1584, 0x9077, "Uniwill P53", ALC880_UNIWILL_P53),
+	SND_PCI_QUIRK(0x1584, 0x9054, "Uniwlll", ALC880_F1734),
+
+	SND_PCI_QUIRK(0x1695, 0x4012, "EPox EP-5LDA", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x1734, 0x10ac, "FSC", ALC880_UNIWILL),
+	SND_PCI_QUIRK(0x1734, 0x107c, "FSC F1734", ALC880_F1734),
+	SND_PCI_QUIRK(0x1734, 0x10b0, "Fujitsu", ALC880_FUJITSU),
+
+	SND_PCI_QUIRK(0x1854, 0x003b, "LG", ALC880_LG),
+	SND_PCI_QUIRK(0x1854, 0x0068, "LG w1", ALC880_LG),
+	SND_PCI_QUIRK(0x1854, 0x0018, "LG LW20", ALC880_LG_LW),
+	SND_PCI_QUIRK(0x1854, 0x0077, "LG LW25", ALC880_LG_LW),
+
+	SND_PCI_QUIRK(0x8086, 0xe308, "Intel mobo", ALC880_3ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xe305, "Intel mobo", ALC880_3ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xd402, "Intel mobo", ALC880_3ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xd400, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xd401, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xe224, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xe400, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xe401, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xe402, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0xa100, "Intel mobo", ALC880_5ST_DIG),
+	SND_PCI_QUIRK(0x8086, 0, "Intel mobo", ALC880_3ST),
 
 	{}
 };
@@ -2263,6 +2482,7 @@
 		.dac_nids = alc880_dac_nids,
 		.num_channel_mode = ARRAY_SIZE(alc880_threestack_modes),
 		.channel_mode = alc880_threestack_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_3ST_DIG] = {
@@ -2273,6 +2493,7 @@
 		.dig_out_nid = ALC880_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc880_threestack_modes),
 		.channel_mode = alc880_threestack_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_TCL_S700] = {
@@ -2365,6 +2586,7 @@
 		.dac_nids = alc880_asus_dac_nids,
 		.num_channel_mode = ARRAY_SIZE(alc880_asus_modes),
 		.channel_mode = alc880_asus_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_ASUS_DIG] = {
@@ -2376,6 +2598,7 @@
 		.dig_out_nid = ALC880_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc880_asus_modes),
 		.channel_mode = alc880_asus_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_ASUS_DIG2] = {
@@ -2387,6 +2610,7 @@
 		.dig_out_nid = ALC880_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc880_asus_modes),
 		.channel_mode = alc880_asus_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_ASUS_W1V] = {
@@ -2398,17 +2622,60 @@
 		.dig_out_nid = ALC880_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc880_asus_modes),
 		.channel_mode = alc880_asus_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_UNIWILL_DIG] = {
 		.mixers = { alc880_asus_mixer, alc880_pcbeep_mixer },
-		.init_verbs = { alc880_volume_init_verbs, alc880_pin_asus_init_verbs },
+		.init_verbs = { alc880_volume_init_verbs,
+				alc880_pin_asus_init_verbs },
 		.num_dacs = ARRAY_SIZE(alc880_asus_dac_nids),
 		.dac_nids = alc880_asus_dac_nids,
 		.dig_out_nid = ALC880_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc880_asus_modes),
 		.channel_mode = alc880_asus_modes,
+		.need_dac_fix = 1,
+		.input_mux = &alc880_capture_source,
+	},
+	[ALC880_UNIWILL] = {
+		.mixers = { alc880_uniwill_mixer },
+		.init_verbs = { alc880_volume_init_verbs,
+				alc880_uniwill_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc880_asus_dac_nids),
+		.dac_nids = alc880_asus_dac_nids,
+		.dig_out_nid = ALC880_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc880_threestack_modes),
+		.channel_mode = alc880_threestack_modes,
+		.need_dac_fix = 1,
+		.input_mux = &alc880_capture_source,
+		.unsol_event = alc880_uniwill_unsol_event,
+		.init_hook = alc880_uniwill_automute,
+	},
+	[ALC880_UNIWILL_P53] = {
+		.mixers = { alc880_uniwill_p53_mixer },
+		.init_verbs = { alc880_volume_init_verbs,
+				alc880_uniwill_p53_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc880_asus_dac_nids),
+		.dac_nids = alc880_asus_dac_nids,
+		.num_channel_mode = ARRAY_SIZE(alc880_w810_modes),
+		.channel_mode = alc880_threestack_modes,
+		.input_mux = &alc880_capture_source,
+		.unsol_event = alc880_uniwill_p53_unsol_event,
+		.init_hook = alc880_uniwill_p53_hp_automute,
+	},
+	[ALC880_FUJITSU] = {
+		.mixers = { alc880_fujitsu_mixer, 
+			    alc880_pcbeep_mixer, },
+		.init_verbs = { alc880_volume_init_verbs,
+				alc880_uniwill_p53_init_verbs,
+	       			alc880_beep_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc880_dac_nids),
+		.dac_nids = alc880_dac_nids,
+		.num_channel_mode = ARRAY_SIZE(alc880_2_jack_modes),
+		.channel_mode = alc880_2_jack_modes,
 		.input_mux = &alc880_capture_source,
+		.unsol_event = alc880_uniwill_p53_unsol_event,
+		.init_hook = alc880_uniwill_p53_hp_automute,
 	},
 	[ALC880_CLEVO] = {
 		.mixers = { alc880_three_stack_mixer },
@@ -2419,6 +2686,7 @@
 		.hp_nid = 0x03,
 		.num_channel_mode = ARRAY_SIZE(alc880_threestack_modes),
 		.channel_mode = alc880_threestack_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_capture_source,
 	},
 	[ALC880_LG] = {
@@ -2430,6 +2698,7 @@
 		.dig_out_nid = ALC880_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc880_lg_ch_modes),
 		.channel_mode = alc880_lg_ch_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc880_lg_capture_source,
 		.unsol_event = alc880_lg_unsol_event,
 		.init_hook = alc880_lg_automute,
@@ -2714,7 +2983,7 @@
 	pin = spec->autocfg.speaker_pins[0];
 	if (pin) /* connect to front */
 		alc880_auto_set_output_and_unmute(codec, pin, PIN_OUT, 0);
-	pin = spec->autocfg.hp_pin;
+	pin = spec->autocfg.hp_pins[0];
 	if (pin) /* connect to front */
 		alc880_auto_set_output_and_unmute(codec, pin, PIN_HP, 0);
 }
@@ -2755,7 +3024,7 @@
 	    (err = alc880_auto_create_extra_out(spec,
 						spec->autocfg.speaker_pins[0],
 						"Speaker")) < 0 ||
-	    (err = alc880_auto_create_extra_out(spec, spec->autocfg.hp_pin,
+	    (err = alc880_auto_create_extra_out(spec, spec->autocfg.hp_pins[0],
 						"Headphone")) < 0 ||
 	    (err = alc880_auto_create_analog_input_ctls(spec, &spec->autocfg)) < 0)
 		return err;
@@ -2802,8 +3071,10 @@
 
 	codec->spec = spec;
 
-	board_config = snd_hda_check_board_config(codec, alc880_cfg_tbl);
-	if (board_config < 0 || board_config >= ALC880_MODEL_LAST) {
+	board_config = snd_hda_check_board_config(codec, ALC880_MODEL_LAST,
+						  alc880_models,
+						  alc880_cfg_tbl);
+	if (board_config < 0) {
 		printk(KERN_INFO "hda_codec: Unknown model for ALC880, "
 		       "trying auto-probe from BIOS...\n");
 		board_config = ALC880_AUTO;
@@ -3051,11 +3322,20 @@
  * and the output jack.  If this turns out to be the case for all such
  * models the "Line Jack Mode" mode could be changed from ALC_PIN_DIR_INOUT
  * to ALC_PIN_DIR_INOUT_NOMICBIAS.
+ *
+ * The C20x Tablet series have a mono internal speaker which is controlled
+ * via the chip's Mono sum widget and pin complex, so include the necessary
+ * controls for such models.  On models without a "mono speaker" the control
+ * won't do anything.
  */
 static struct snd_kcontrol_new alc260_acer_mixer[] = {
 	HDA_CODEC_VOLUME("Master Playback Volume", 0x08, 0x0, HDA_OUTPUT),
 	HDA_BIND_MUTE("Master Playback Switch", 0x08, 2, HDA_INPUT),
 	ALC_PIN_MODE("Headphone Jack Mode", 0x0f, ALC_PIN_DIR_INOUT),
+	HDA_CODEC_VOLUME_MONO("Mono Speaker Playback Volume", 0x0a, 1, 0x0,
+			      HDA_OUTPUT),
+	HDA_BIND_MUTE_MONO("Mono Speaker Playback Switch", 0x0a, 1, 2,
+			   HDA_INPUT),
 	HDA_CODEC_VOLUME("CD Playback Volume", 0x07, 0x04, HDA_INPUT),
 	HDA_CODEC_MUTE("CD Playback Switch", 0x07, 0x04, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x07, 0x0, HDA_INPUT),
@@ -3370,11 +3650,11 @@
 	{0x12, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF50},
 	/* Line In jack is connected to Line1 pin */
 	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+	/* Some Acers (eg: C20x Tablets) use Mono pin for internal speaker */
+	{0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
 	/* Ensure all other unused pins are disabled and muted. */
 	{0x10, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},
 	{0x10, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
-	{0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},
-	{0x11, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
 	{0x13, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},
 	{0x13, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
 	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, 0},
@@ -3402,6 +3682,8 @@
 
 	/* Unmute Line-out pin widget amp left and right (no equiv mixer ctrl) */
 	{0x0f, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	/* Unmute mono pin widget amp output (no equiv mixer ctrl) */
+	{0x11, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
 	/* Unmute Mic1 and Line1 pin widget input buffers since they start as
 	 * inputs. If the pin mode is changed by the user the pin mode control
 	 * will take care of enabling the pin's input/output buffers as needed.
@@ -3697,7 +3979,7 @@
 			return err;
 	}
 
-	nid = cfg->hp_pin;
+	nid = cfg->hp_pins[0];
 	if (nid) {
 		err = alc260_add_playback_controls(spec, nid, "Headphone");
 		if (err < 0)
@@ -3767,7 +4049,7 @@
 	if (nid)
 		alc260_auto_set_output_and_unmute(codec, nid, PIN_OUT, 0);
 
-	nid = spec->autocfg.hp_pin;
+	nid = spec->autocfg.hp_pins[0];
 	if (nid)
 		alc260_auto_set_output_and_unmute(codec, nid, PIN_OUT, 0);
 }	
@@ -3889,32 +4171,35 @@
 /*
  * ALC260 configurations
  */
-static struct hda_board_config alc260_cfg_tbl[] = {
-	{ .modelname = "basic", .config = ALC260_BASIC },
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81bb,
-	  .config = ALC260_BASIC }, /* Sony VAIO */
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81cc,
-	  .config = ALC260_BASIC }, /* Sony VAIO VGN-S3HP */
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81cd,
-	  .config = ALC260_BASIC }, /* Sony VAIO */
-	{ .pci_subvendor = 0x152d, .pci_subdevice = 0x0729,
-	  .config = ALC260_BASIC }, /* CTL Travel Master U553W */
-	{ .modelname = "hp", .config = ALC260_HP },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3010, .config = ALC260_HP },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3011, .config = ALC260_HP },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3012, .config = ALC260_HP_3013 },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3013, .config = ALC260_HP_3013 },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3014, .config = ALC260_HP },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3015, .config = ALC260_HP },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3016, .config = ALC260_HP },
-	{ .modelname = "fujitsu", .config = ALC260_FUJITSU_S702X },
-	{ .pci_subvendor = 0x10cf, .pci_subdevice = 0x1326, .config = ALC260_FUJITSU_S702X },
-	{ .modelname = "acer", .config = ALC260_ACER },
-	{ .pci_subvendor = 0x1025, .pci_subdevice = 0x008f, .config = ALC260_ACER },
+static const char *alc260_models[ALC260_MODEL_LAST] = {
+	[ALC260_BASIC]		= "basic",
+	[ALC260_HP]		= "hp",
+	[ALC260_HP_3013]	= "hp-3013",
+	[ALC260_FUJITSU_S702X]	= "fujitsu",
+	[ALC260_ACER]		= "acer",
 #ifdef CONFIG_SND_DEBUG
-	{ .modelname = "test", .config = ALC260_TEST },
+	[ALC260_TEST]		= "test",
 #endif
-	{ .modelname = "auto", .config = ALC260_AUTO },
+	[ALC260_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc260_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1025, 0x007b, "Acer C20x", ALC260_ACER),
+	SND_PCI_QUIRK(0x1025, 0x008f, "Acer", ALC260_ACER),
+	SND_PCI_QUIRK(0x103c, 0x2808, "HP d5700", ALC260_HP_3013),
+	SND_PCI_QUIRK(0x103c, 0x280a, "HP d5750", ALC260_HP_3013),
+	SND_PCI_QUIRK(0x103c, 0x3010, "HP", ALC260_HP_3013),
+	SND_PCI_QUIRK(0x103c, 0x3011, "HP", ALC260_HP),
+	SND_PCI_QUIRK(0x103c, 0x3012, "HP", ALC260_HP_3013),
+	SND_PCI_QUIRK(0x103c, 0x3013, "HP", ALC260_HP_3013),
+	SND_PCI_QUIRK(0x103c, 0x3014, "HP", ALC260_HP),
+	SND_PCI_QUIRK(0x103c, 0x3015, "HP", ALC260_HP),
+	SND_PCI_QUIRK(0x103c, 0x3016, "HP", ALC260_HP),
+	SND_PCI_QUIRK(0x104d, 0x81bb, "Sony VAIO", ALC260_BASIC),
+	SND_PCI_QUIRK(0x104d, 0x81cc, "Sony VAIO", ALC260_BASIC),
+	SND_PCI_QUIRK(0x104d, 0x81cd, "Sony VAIO", ALC260_BASIC),
+	SND_PCI_QUIRK(0x10cf, 0x1326, "Fujitsu S702X", ALC260_FUJITSU_S702X),
+	SND_PCI_QUIRK(0x152d, 0x0729, "CTL U553W", ALC260_BASIC),
 	{}
 };
 
@@ -4013,8 +4298,10 @@
 
 	codec->spec = spec;
 
-	board_config = snd_hda_check_board_config(codec, alc260_cfg_tbl);
-	if (board_config < 0 || board_config >= ALC260_MODEL_LAST) {
+	board_config = snd_hda_check_board_config(codec, ALC260_MODEL_LAST,
+						  alc260_models,
+						  alc260_cfg_tbl);
+	if (board_config < 0) {
 		snd_printd(KERN_INFO "hda_codec: Unknown model for ALC260, "
 			   "trying auto-probe from BIOS...\n");
 		board_config = ALC260_AUTO;
@@ -4167,8 +4454,10 @@
 	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
@@ -4266,24 +4555,125 @@
 	{ }
 };
 
-/*
- * generic initialization of ADC, input mixers and output mixers
- */
-static struct hda_verb alc882_auto_init_verbs[] = {
-	/*
-	 * Unmute ADC0-2 and set the default input to mic-in
-	 */
+static struct hda_verb alc882_eapd_verbs[] = {
+	/* change to EAPD mode */
+	{0x20, AC_VERB_SET_COEF_INDEX, 0x07},
+	{0x20, AC_VERB_SET_PROC_COEF, 0x3060},
+	{ } 
+};
+
+/* Mac Pro test */
+static struct snd_kcontrol_new alc882_macpro_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Front Playback Switch", 0x0c, 2, HDA_INPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x18, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	{ } /* end */
+};
+
+static struct hda_verb alc882_macpro_init_verbs[] = {
+	/* Front mixer: unmute input/output amp left and right (volume = 0) */
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+	/* Front Pin: output 0 (0x0c) */
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x15, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* Front Mic pin: input vref at 80% */
+	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Speaker:  output */
+	{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x1a, AC_VERB_SET_CONNECT_SEL, 0x04},
+	/* Headphone output (output 0 - 0x0c) */
+	{0x18, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x18, AC_VERB_SET_CONNECT_SEL, 0x00},
+
+	/* FIXME: use matrix-type input source selection */
+	/* Mixer elements: 0x18, 19, 1a, 1b, 1c, 1d, 14, 15, 16, 17, 0b */
+	/* Input mixer1: unmute Mic, F-Mic, Line, CD inputs */
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(3)},
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2)},
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(4)},
+	/* Input mixer2 */
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(3)},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2)},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(4)},
+	/* Input mixer3 */
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(3)},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2)},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(4)},
+	/* ADC1: mute amp left and right */
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
 	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
-	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	/* ADC2: mute amp left and right */
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
 	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
-	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	/* ADC3: mute amp left and right */
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
 	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
-	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
 
-	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of the analog-loopback
-	 * mixer widget
-	 * Note: PASD motherboards uses the Line In 2 as the input for front panel
-	 * mic (mic 2)
+	{ }
+};
+static void alc882_gpio_mute(struct hda_codec *codec, int pin, int muted)
+{
+	unsigned int gpiostate, gpiomask, gpiodir;
+
+	gpiostate = snd_hda_codec_read(codec, codec->afg, 0,
+				       AC_VERB_GET_GPIO_DATA, 0);
+
+	if (!muted)
+		gpiostate |= (1 << pin);
+	else
+		gpiostate &= ~(1 << pin);
+
+	gpiomask = snd_hda_codec_read(codec, codec->afg, 0,
+				      AC_VERB_GET_GPIO_MASK, 0);
+	gpiomask |= (1 << pin);
+
+	gpiodir = snd_hda_codec_read(codec, codec->afg, 0,
+				     AC_VERB_GET_GPIO_DIRECTION, 0);
+	gpiodir |= (1 << pin);
+
+
+	snd_hda_codec_write(codec, codec->afg, 0,
+			    AC_VERB_SET_GPIO_MASK, gpiomask);
+	snd_hda_codec_write(codec, codec->afg, 0,
+			    AC_VERB_SET_GPIO_DIRECTION, gpiodir);
+
+	msleep(1);
+
+	snd_hda_codec_write(codec, codec->afg, 0,
+			    AC_VERB_SET_GPIO_DATA, gpiostate);
+}
+
+/*
+ * generic initialization of ADC, input mixers and output mixers
+ */
+static struct hda_verb alc882_auto_init_verbs[] = {
+	/*
+	 * Unmute ADC0-2 and set the default input to mic-in
+	 */
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+
+	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of the analog-loopback
+	 * mixer widget
+	 * Note: PASD motherboards uses the Line In 2 as the input for front panel
+	 * mic (mic 2)
 	 */
 	/* Amp Indices: Mic1 = 0, Mic2 = 1, Line1 = 2, Line2 = 3, CD = 4 */
 	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
@@ -4388,16 +4778,20 @@
 /*
  * configuration and preset
  */
-static struct hda_board_config alc882_cfg_tbl[] = {
-	{ .modelname = "3stack-dig", .config = ALC882_3ST_DIG },
-	{ .modelname = "6stack-dig", .config = ALC882_6ST_DIG },
-	{ .pci_subvendor = 0x1462, .pci_subdevice = 0x6668,
-	  .config = ALC882_6ST_DIG }, /* MSI  */
-	{ .pci_subvendor = 0x105b, .pci_subdevice = 0x6668,
-	  .config = ALC882_6ST_DIG }, /* Foxconn */
-	{ .pci_subvendor = 0x1019, .pci_subdevice = 0x6668,
-	  .config = ALC882_6ST_DIG }, /* ECS to Intel*/
-	{ .modelname = "auto", .config = ALC882_AUTO },
+static const char *alc882_models[ALC882_MODEL_LAST] = {
+	[ALC882_3ST_DIG]	= "3stack-dig",
+	[ALC882_6ST_DIG]	= "6stack-dig",
+	[ALC882_ARIMA]		= "arima",
+	[ALC885_MACPRO]		= "macpro",
+	[ALC882_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc882_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1019, 0x6668, "ECS", ALC882_6ST_DIG),
+	SND_PCI_QUIRK(0x105b, 0x6668, "Foxconn", ALC882_6ST_DIG),
+	SND_PCI_QUIRK(0x1462, 0x6668, "MSI", ALC882_6ST_DIG),
+	SND_PCI_QUIRK(0x161f, 0x2054, "Arima W820", ALC882_ARIMA),
+	SND_PCI_QUIRK(0x1043, 0x81d8, "Asus P5WD", ALC882_6ST_DIG),
 	{}
 };
 
@@ -4411,6 +4805,7 @@
 		.dig_in_nid = ALC882_DIGIN_NID,
 		.num_channel_mode = ARRAY_SIZE(alc882_ch_modes),
 		.channel_mode = alc882_ch_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc882_capture_source,
 	},
 	[ALC882_6ST_DIG] = {
@@ -4424,6 +4819,26 @@
 		.channel_mode = alc882_sixstack_modes,
 		.input_mux = &alc882_capture_source,
 	},
+	[ALC882_ARIMA] = {
+		.mixers = { alc882_base_mixer, alc882_chmode_mixer },
+		.init_verbs = { alc882_init_verbs, alc882_eapd_verbs },
+		.num_dacs = ARRAY_SIZE(alc882_dac_nids),
+		.dac_nids = alc882_dac_nids,
+		.num_channel_mode = ARRAY_SIZE(alc882_sixstack_modes),
+		.channel_mode = alc882_sixstack_modes,
+		.input_mux = &alc882_capture_source,
+	},
+	[ALC885_MACPRO] = {
+		.mixers = { alc882_macpro_mixer },
+		.init_verbs = { alc882_macpro_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc882_dac_nids),
+		.dac_nids = alc882_dac_nids,
+		.dig_out_nid = ALC882_DIGOUT_NID,
+		.dig_in_nid = ALC882_DIGIN_NID,
+		.num_channel_mode = ARRAY_SIZE(alc882_ch_modes),
+		.channel_mode = alc882_ch_modes,
+		.input_mux = &alc882_capture_source,
+	},
 };
 
 
@@ -4466,7 +4881,7 @@
 	struct alc_spec *spec = codec->spec;
 	hda_nid_t pin;
 
-	pin = spec->autocfg.hp_pin;
+	pin = spec->autocfg.hp_pins[0];
 	if (pin) /* connect to front */
 		alc882_auto_set_output_and_unmute(codec, pin, PIN_HP, 0); /* use dac 0 */
 }
@@ -4524,12 +4939,21 @@
 
 	codec->spec = spec;
 
-	board_config = snd_hda_check_board_config(codec, alc882_cfg_tbl);
+	board_config = snd_hda_check_board_config(codec, ALC882_MODEL_LAST,
+						  alc882_models,
+						  alc882_cfg_tbl);
 
 	if (board_config < 0 || board_config >= ALC882_MODEL_LAST) {
-		printk(KERN_INFO "hda_codec: Unknown model for ALC882, "
-		       "trying auto-probe from BIOS...\n");
-		board_config = ALC882_AUTO;
+		/* Pick up systems that don't supply PCI SSID */
+		switch (codec->subsystem_id) {
+		case 0x106b0c00: /* Mac Pro */
+			board_config = ALC885_MACPRO;
+			break;
+		default:
+			printk(KERN_INFO "hda_codec: Unknown model for ALC882, "
+		       			 "trying auto-probe from BIOS...\n");
+			board_config = ALC882_AUTO;
+		}
 	}
 
 	if (board_config == ALC882_AUTO) {
@@ -4549,6 +4973,11 @@
 	if (board_config != ALC882_AUTO)
 		setup_preset(spec, &alc882_presets[board_config]);
 
+	if (board_config == ALC885_MACPRO) {
+		alc882_gpio_mute(codec, 0, 0);
+		alc882_gpio_mute(codec, 1, 0);
+	}
+
 	spec->stream_name_analog = "ALC882 Analog";
 	spec->stream_analog_playback = &alc882_pcm_analog_playback;
 	spec->stream_analog_capture = &alc882_pcm_analog_capture;
@@ -4707,6 +5136,13 @@
 	{ 8, alc883_sixstack_ch8_init },
 };
 
+static struct hda_verb alc883_medion_eapd_verbs[] = {
+        /* eanable EAPD on medion laptop */
+	{0x20, AC_VERB_SET_COEF_INDEX, 0x07},
+	{0x20, AC_VERB_SET_PROC_COEF, 0x3070},
+	{ }
+};
+
 /* Pin assignment: Front=0x14, Rear=0x15, CLFE=0x16, Side=0x17
  *                 Mic=0x18, Front Mic=0x19, Line-In=0x1a, HP=0x1b
  */
@@ -4728,8 +5164,10 @@
 	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
@@ -4758,8 +5196,10 @@
 	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
@@ -4794,8 +5234,10 @@
 	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
@@ -4815,6 +5257,101 @@
 	{ } /* end */
 };
 
+static struct snd_kcontrol_new alc883_fivestack_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Surround Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Surround Playback Switch", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x0e, 1, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x16, 1, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x16, 2, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
+	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		/* .name = "Capture Source", */
+		.name = "Input Source",
+		.count = 1,
+		.info = alc883_mux_enum_info,
+		.get = alc883_mux_enum_get,
+		.put = alc883_mux_enum_put,
+	},
+	{ } /* end */
+};
+
+static struct snd_kcontrol_new alc883_tagra_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Front Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Surround Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Surround Playback Switch", 0x0d, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x0e, 1, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE_MONO("Center Playback Switch", 0x0e, 1, 2, HDA_INPUT),
+	HDA_BIND_MUTE_MONO("LFE Playback Switch", 0x0e, 2, 2, HDA_INPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x09, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x09, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		/* .name = "Capture Source", */
+		.name = "Input Source",
+		.count = 2,
+		.info = alc883_mux_enum_info,
+		.get = alc883_mux_enum_get,
+		.put = alc883_mux_enum_put,
+	},
+	{ } /* end */
+};	
+
+static struct snd_kcontrol_new alc883_tagra_2ch_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Front Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME_IDX("Capture Volume", 1, 0x09, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE_IDX("Capture Switch", 1, 0x09, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		/* .name = "Capture Source", */
+		.name = "Input Source",
+		.count = 2,
+		.info = alc883_mux_enum_info,
+		.get = alc883_mux_enum_get,
+		.put = alc883_mux_enum_put,
+	},
+	{ } /* end */
+};	
+
 static struct snd_kcontrol_new alc883_chmode_mixer[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -4903,6 +5440,45 @@
 	{ }
 };
 
+static struct hda_verb alc883_tagra_verbs[] = {
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	
+	{0x18, AC_VERB_SET_CONNECT_SEL, 0x02}, /* mic/clfe */
+	{0x1a, AC_VERB_SET_CONNECT_SEL, 0x01}, /* line/surround */
+	{0x1b, AC_VERB_SET_CONNECT_SEL, 0x00}, /* HP */
+
+	{0x14, AC_VERB_SET_UNSOLICITED_ENABLE, ALC880_HP_EVENT | AC_USRSP_EN},
+	{0x01, AC_VERB_SET_GPIO_MASK, 0x03}, 
+	{0x01, AC_VERB_SET_GPIO_DIRECTION, 0x03}, 
+	{0x01, AC_VERB_SET_GPIO_DATA, 0x03}, 
+
+	{ } /* end */
+};
+
+/* toggle speaker-output according to the hp-jack state */
+static void alc883_tagra_automute(struct hda_codec *codec)
+{
+ 	unsigned int present;
+
+ 	present = snd_hda_codec_read(codec, 0x14, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+	snd_hda_codec_amp_update(codec, 0x1b, 0, HDA_OUTPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x1b, 1, HDA_OUTPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_write(codec, 1, 0, AC_VERB_SET_GPIO_DATA, present ? 1 : 3);
+}
+
+static void alc883_tagra_unsol_event(struct hda_codec *codec, unsigned int res)
+{
+	if ((res >> 26) == ALC880_HP_EVENT)
+		alc883_tagra_automute(codec);
+}
+
 /*
  * generic initialization of ADC, input mixers and output mixers
  */
@@ -4997,19 +5573,42 @@
 /*
  * configuration and preset
  */
-static struct hda_board_config alc883_cfg_tbl[] = {
-	{ .modelname = "3stack-dig", .config = ALC883_3ST_2ch_DIG },
-	{ .modelname = "6stack-dig", .config = ALC883_6ST_DIG },
-	{ .modelname = "6stack-dig-demo", .config = ALC888_DEMO_BOARD },
-	{ .pci_subvendor = 0x1462, .pci_subdevice = 0x6668,
-	  .config = ALC883_6ST_DIG }, /* MSI  */
-	{ .pci_subvendor = 0x105b, .pci_subdevice = 0x6668,
-	  .config = ALC883_6ST_DIG }, /* Foxconn */
-	{ .pci_subvendor = 0x1019, .pci_subdevice = 0x6668,
-	  .config = ALC883_3ST_6ch_DIG }, /* ECS to Intel*/
-	{ .pci_subvendor = 0x108e, .pci_subdevice = 0x534d,
-	  .config = ALC883_3ST_6ch },
-	{ .modelname = "auto", .config = ALC883_AUTO },
+static const char *alc883_models[ALC883_MODEL_LAST] = {
+	[ALC883_3ST_2ch_DIG]	= "3stack-dig",
+	[ALC883_3ST_6ch_DIG]	= "3stack-6ch-dig",
+	[ALC883_3ST_6ch]	= "3stack-6ch",
+	[ALC883_6ST_DIG]	= "6stack-dig",
+	[ALC883_TARGA_DIG]	= "targa-dig",
+	[ALC883_TARGA_2ch_DIG]	= "targa-2ch-dig",
+	[ALC888_DEMO_BOARD]	= "6stack-dig-demo",
+	[ALC883_ACER]		= "acer",
+	[ALC883_MEDION]		= "medion",
+	[ALC883_LAPTOP_EAPD]	= "laptop-eapd",
+	[ALC883_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc883_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1019, 0x6668, "ECS", ALC883_3ST_6ch_DIG),
+	SND_PCI_QUIRK(0x108e, 0x534d, NULL, ALC883_3ST_6ch),
+	SND_PCI_QUIRK(0x1558, 0, "Clevo laptop", ALC883_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x105b, 0x6668, "Foxconn", ALC883_6ST_DIG),
+	SND_PCI_QUIRK(0x1462, 0x6668, "MSI", ALC883_6ST_DIG),
+	SND_PCI_QUIRK(0x1462, 0x7187, "MSI", ALC883_6ST_DIG),
+	SND_PCI_QUIRK(0x1462, 0x7280, "MSI", ALC883_6ST_DIG),
+	SND_PCI_QUIRK(0x1462, 0x0579, "MSI", ALC883_TARGA_2ch_DIG),
+	SND_PCI_QUIRK(0x1462, 0x3ef9, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0x3b7f, "MSI", ALC883_TARGA_2ch_DIG),
+	SND_PCI_QUIRK(0x1462, 0x3fcc, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0x3fc1, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0x3fc3, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0x4314, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0x4319, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0x4324, "MSI", ALC883_TARGA_DIG),
+	SND_PCI_QUIRK(0x1462, 0xa422, "MSI", ALC883_TARGA_2ch_DIG),
+	SND_PCI_QUIRK(0x1025, 0, "Acer laptop", ALC883_ACER),
+	SND_PCI_QUIRK(0x161f, 0x2054, "Medion laptop", ALC883_MEDION),
+	SND_PCI_QUIRK(0x1071, 0x8258, "Evesham Voyaeger", ALC883_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x8086, 0xd601, "D102GGC", ALC883_3ST_6ch),
 	{}
 };
 
@@ -5038,6 +5637,7 @@
 		.dig_in_nid = ALC883_DIGIN_NID,
 		.num_channel_mode = ARRAY_SIZE(alc883_3ST_6ch_modes),
 		.channel_mode = alc883_3ST_6ch_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc883_capture_source,
 	},	
 	[ALC883_3ST_6ch] = {
@@ -5049,6 +5649,7 @@
 		.adc_nids = alc883_adc_nids,
 		.num_channel_mode = ARRAY_SIZE(alc883_3ST_6ch_modes),
 		.channel_mode = alc883_3ST_6ch_modes,
+		.need_dac_fix = 1,
 		.input_mux = &alc883_capture_source,
 	},	
 	[ALC883_6ST_DIG] = {
@@ -5064,6 +5665,35 @@
 		.channel_mode = alc883_sixstack_modes,
 		.input_mux = &alc883_capture_source,
 	},
+	[ALC883_TARGA_DIG] = {
+		.mixers = { alc883_tagra_mixer, alc883_chmode_mixer },
+		.init_verbs = { alc883_init_verbs, alc883_tagra_verbs},
+		.num_dacs = ARRAY_SIZE(alc883_dac_nids),
+		.dac_nids = alc883_dac_nids,
+		.dig_out_nid = ALC883_DIGOUT_NID,
+		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids),
+		.adc_nids = alc883_adc_nids,
+		.num_channel_mode = ARRAY_SIZE(alc883_3ST_6ch_modes),
+		.channel_mode = alc883_3ST_6ch_modes,
+		.need_dac_fix = 1,
+		.input_mux = &alc883_capture_source,
+		.unsol_event = alc883_tagra_unsol_event,
+		.init_hook = alc883_tagra_automute,
+	},
+	[ALC883_TARGA_2ch_DIG] = {
+		.mixers = { alc883_tagra_2ch_mixer},
+		.init_verbs = { alc883_init_verbs, alc883_tagra_verbs},
+		.num_dacs = ARRAY_SIZE(alc883_dac_nids),
+		.dac_nids = alc883_dac_nids,
+		.dig_out_nid = ALC883_DIGOUT_NID,
+		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids),
+		.adc_nids = alc883_adc_nids,
+		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
+		.channel_mode = alc883_3ST_2ch_modes,
+		.input_mux = &alc883_capture_source,
+		.unsol_event = alc883_tagra_unsol_event,
+		.init_hook = alc883_tagra_automute,
+	},
 	[ALC888_DEMO_BOARD] = {
 		.mixers = { alc883_base_mixer, alc883_chmode_mixer },
 		.init_verbs = { alc883_init_verbs },
@@ -5077,6 +5707,48 @@
 		.channel_mode = alc883_sixstack_modes,
 		.input_mux = &alc883_capture_source,
 	},
+	[ALC883_ACER] = {
+		.mixers = { alc883_base_mixer,
+			    alc883_chmode_mixer },
+		/* On TravelMate laptops, GPIO 0 enables the internal speaker
+		 * and the headphone jack.  Turn this on and rely on the
+		 * standard mute methods whenever the user wants to turn
+		 * these outputs off.
+		 */
+		.init_verbs = { alc883_init_verbs, alc880_gpio1_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc883_dac_nids),
+		.dac_nids = alc883_dac_nids,
+		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids),
+		.adc_nids = alc883_adc_nids,
+		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
+		.channel_mode = alc883_3ST_2ch_modes,
+		.input_mux = &alc883_capture_source,
+	},
+	[ALC883_MEDION] = {
+		.mixers = { alc883_fivestack_mixer,
+			    alc883_chmode_mixer },
+		.init_verbs = { alc883_init_verbs,
+				alc883_medion_eapd_verbs },
+		.num_dacs = ARRAY_SIZE(alc883_dac_nids),
+		.dac_nids = alc883_dac_nids,
+		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids),
+		.adc_nids = alc883_adc_nids,
+		.num_channel_mode = ARRAY_SIZE(alc883_sixstack_modes),
+		.channel_mode = alc883_sixstack_modes,
+		.input_mux = &alc883_capture_source,
+	},
+	[ALC883_LAPTOP_EAPD] = {
+		.mixers = { alc883_base_mixer,
+			    alc883_chmode_mixer },
+		.init_verbs = { alc883_init_verbs, alc882_eapd_verbs },
+		.num_dacs = ARRAY_SIZE(alc883_dac_nids),
+		.dac_nids = alc883_dac_nids,
+		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids),
+		.adc_nids = alc883_adc_nids,
+		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
+		.channel_mode = alc883_3ST_2ch_modes,
+		.input_mux = &alc883_capture_source,
+	},
 };
 
 
@@ -5121,7 +5793,7 @@
 	struct alc_spec *spec = codec->spec;
 	hda_nid_t pin;
 
-	pin = spec->autocfg.hp_pin;
+	pin = spec->autocfg.hp_pins[0];
 	if (pin) /* connect to front */
 		/* use dac 0 */
 		alc883_auto_set_output_and_unmute(codec, pin, PIN_HP, 0);
@@ -5185,8 +5857,10 @@
 
 	codec->spec = spec;
 
-	board_config = snd_hda_check_board_config(codec, alc883_cfg_tbl);
-	if (board_config < 0 || board_config >= ALC883_MODEL_LAST) {
+	board_config = snd_hda_check_board_config(codec, ALC883_MODEL_LAST,
+						  alc883_models,
+						  alc883_cfg_tbl);
+	if (board_config < 0) {
 		printk(KERN_INFO "hda_codec: Unknown model for ALC883, "
 		       "trying auto-probe from BIOS...\n");
 		board_config = ALC883_AUTO;
@@ -5217,8 +5891,10 @@
 	spec->stream_digital_playback = &alc883_pcm_digital_playback;
 	spec->stream_digital_capture = &alc883_pcm_digital_capture;
 
-	spec->adc_nids = alc883_adc_nids;
-	spec->num_adc_nids = ARRAY_SIZE(alc883_adc_nids);
+	if (! spec->adc_nids && spec->input_mux) {
+		spec->adc_nids = alc883_adc_nids;
+		spec->num_adc_nids = ARRAY_SIZE(alc883_adc_nids);
+	}
 
 	codec->patch_ops = alc_patch_ops;
 	if (board_config == ALC883_AUTO)
@@ -5250,8 +5926,10 @@
 	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x01, HDA_INPUT),
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
 	/* HDA_CODEC_VOLUME("PC Beep Playback Volume", 0x0b, 0x05, HDA_INPUT),
 	   HDA_CODEC_MUTE("PC Beelp Playback Switch", 0x0b, 0x05, HDA_INPUT), */
 	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0D, 0x0, HDA_OUTPUT),
@@ -5261,6 +5939,26 @@
 	{ } /* end */
 };
 
+static struct snd_kcontrol_new alc262_hippo1_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
+	/* HDA_CODEC_VOLUME("PC Beep Playback Volume", 0x0b, 0x05, HDA_INPUT),
+	   HDA_CODEC_MUTE("PC Beelp Playback Switch", 0x0b, 0x05, HDA_INPUT), */
+	/*HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0D, 0x0, HDA_OUTPUT),*/
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+	{ } /* end */
+};
+
 static struct snd_kcontrol_new alc262_HP_BPC_mixer[] = {
 	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Front Playback Switch", 0x15, 0x0, HDA_OUTPUT),
@@ -5270,8 +5968,10 @@
 
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x01, HDA_INPUT),
 	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
 	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
@@ -5283,6 +5983,32 @@
 	{ } /* end */
 };
 
+static struct snd_kcontrol_new alc262_HP_BPC_WildWest_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x0c, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Front Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0d, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME_MONO("Mono Playback Volume", 0x0e, 2, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("Mono Playback Switch", 0x16, 2, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x1a, 0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x01, HDA_INPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_VOLUME("PC Beep Playback Volume", 0x0b, 0x05, HDA_INPUT),
+	HDA_CODEC_MUTE("PC Beep Playback Switch", 0x0b, 0x05, HDA_INPUT),
+	{ } /* end */
+};
+
+static struct snd_kcontrol_new alc262_HP_BPC_WildWest_option_mixer[] = {
+	HDA_CODEC_VOLUME("Rear Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Rear Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Rear Mic Boost", 0x18, 0, HDA_INPUT),
+	{ } /* end */
+};
+
 #define alc262_capture_mixer		alc882_capture_mixer
 #define alc262_capture_alt_mixer	alc882_capture_alt_mixer
 
@@ -5365,11 +6091,108 @@
 	{ }
 };
 
-/*
- * fujitsu model
- *  0x14 = headphone/spdif-out, 0x15 = internal speaker
- */
-
+static struct hda_verb alc262_hippo_unsol_verbs[] = {
+	{0x15, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_HP_EVENT},
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{}
+};
+
+static struct hda_verb alc262_hippo1_unsol_verbs[] = {
+	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0xc0},
+	{0x1b, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, 0x0000},
+
+	{0x1b, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_HP_EVENT},
+	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{}
+};
+
+/* mute/unmute internal speaker according to the hp jack and mute state */
+static void alc262_hippo_automute(struct hda_codec *codec, int force)
+{
+	struct alc_spec *spec = codec->spec;
+	unsigned int mute;
+
+	if (force || ! spec->sense_updated) {
+		unsigned int present;
+		/* need to execute and sync at first */
+		snd_hda_codec_read(codec, 0x15, 0, AC_VERB_SET_PIN_SENSE, 0);
+		present = snd_hda_codec_read(codec, 0x15, 0,
+				    	 AC_VERB_GET_PIN_SENSE, 0);
+		spec->jack_present = (present & 0x80000000) != 0;
+		spec->sense_updated = 1;
+	}
+	if (spec->jack_present) {
+		/* mute internal speaker */
+		snd_hda_codec_amp_update(codec, 0x14, 0, HDA_OUTPUT, 0,
+					 0x80, 0x80);
+		snd_hda_codec_amp_update(codec, 0x14, 1, HDA_OUTPUT, 0,
+					 0x80, 0x80);
+	} else {
+		/* unmute internal speaker if necessary */
+		mute = snd_hda_codec_amp_read(codec, 0x15, 0, HDA_OUTPUT, 0);
+		snd_hda_codec_amp_update(codec, 0x14, 0, HDA_OUTPUT, 0,
+					 0x80, mute & 0x80);
+		mute = snd_hda_codec_amp_read(codec, 0x15, 1, HDA_OUTPUT, 0);
+		snd_hda_codec_amp_update(codec, 0x14, 1, HDA_OUTPUT, 0,
+					 0x80, mute & 0x80);
+	}
+}
+
+/* unsolicited event for HP jack sensing */
+static void alc262_hippo_unsol_event(struct hda_codec *codec,
+				       unsigned int res)
+{
+	if ((res >> 26) != ALC880_HP_EVENT)
+		return;
+	alc262_hippo_automute(codec, 1);
+}
+
+static void alc262_hippo1_automute(struct hda_codec *codec, int force)
+{
+	struct alc_spec *spec = codec->spec;
+	unsigned int mute;
+
+	if (force || ! spec->sense_updated) {
+		unsigned int present;
+		/* need to execute and sync at first */
+		snd_hda_codec_read(codec, 0x1b, 0, AC_VERB_SET_PIN_SENSE, 0);
+		present = snd_hda_codec_read(codec, 0x1b, 0,
+				    	 AC_VERB_GET_PIN_SENSE, 0);
+		spec->jack_present = (present & 0x80000000) != 0;
+		spec->sense_updated = 1;
+	}
+	if (spec->jack_present) {
+		/* mute internal speaker */
+		snd_hda_codec_amp_update(codec, 0x14, 0, HDA_OUTPUT, 0,
+					 0x80, 0x80);
+		snd_hda_codec_amp_update(codec, 0x14, 1, HDA_OUTPUT, 0,
+					 0x80, 0x80);
+	} else {
+		/* unmute internal speaker if necessary */
+		mute = snd_hda_codec_amp_read(codec, 0x1b, 0, HDA_OUTPUT, 0);
+		snd_hda_codec_amp_update(codec, 0x14, 0, HDA_OUTPUT, 0,
+					 0x80, mute & 0x80);
+		mute = snd_hda_codec_amp_read(codec, 0x1b, 1, HDA_OUTPUT, 0);
+		snd_hda_codec_amp_update(codec, 0x14, 1, HDA_OUTPUT, 0,
+					 0x80, mute & 0x80);
+	}
+}
+
+/* unsolicited event for HP jack sensing */
+static void alc262_hippo1_unsol_event(struct hda_codec *codec,
+				       unsigned int res)
+{
+	if ((res >> 26) != ALC880_HP_EVENT)
+		return;
+	alc262_hippo1_automute(codec, 1);
+}
+
+/*
+ * fujitsu model
+ *  0x14 = headphone/spdif-out, 0x15 = internal speaker
+ */
+
 #define ALC_HP_EVENT	0x37
 
 static struct hda_verb alc262_fujitsu_unsol_verbs[] = {
@@ -5481,6 +6304,7 @@
 		.info = snd_hda_mixer_amp_volume_info,
 		.get = snd_hda_mixer_amp_volume_get,
 		.put = alc262_fujitsu_master_vol_put,
+		.tlv = { .c = snd_hda_mixer_amp_tlv },
 		.private_value = HDA_COMPOSE_AMP_VAL(0x0c, 3, 0, HDA_OUTPUT),
 	},
 	{
@@ -5499,6 +6323,13 @@
 	{ } /* end */
 };
 
+/* additional init verbs for Benq laptops */
+static struct hda_verb alc262_EAPD_verbs[] = {
+	{0x20, AC_VERB_SET_COEF_INDEX, 0x07},
+	{0x20, AC_VERB_SET_PROC_COEF,  0x3070},
+	{}
+};
+
 /* add playback controls from the parsed DAC table */
 static int alc262_auto_create_multi_out_ctls(struct alc_spec *spec, const struct auto_pin_cfg *cfg)
 {
@@ -5534,7 +6365,7 @@
 				return err;
 		}
 	}
-	nid = cfg->hp_pin;
+	nid = cfg->hp_pins[0];
 	if (nid) {
 		/* spec->multiout.hp_nid = 2; */
 		if (nid == 0x16) {
@@ -5707,6 +6538,100 @@
 	{ }
 };
 
+static struct hda_verb alc262_HP_BPC_WildWest_init_verbs[] = {
+	/*
+	 * Unmute ADC0-2 and set the default input to mic-in
+	 */
+	{0x07, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+
+	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of the analog-loopback
+	 * mixer widget
+	 * Note: PASD motherboards uses the Line In 2 as the input for front
+	 * panel mic (mic 2)
+	 */
+	/* Amp Indices: Mic1 = 0, Mic2 = 1, Line1 = 2, Line2 = 3, CD = 4 */
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(4)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(5)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(6)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(7)},
+	/*
+	 * Set up output mixers (0x0c - 0x0e)
+	 */
+	/* set vol=0 to output mixers */
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+
+	/* set up input amps for analog loopback */
+	/* Amp Indices: DAC = 0, mixer = 1 */
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+
+
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP },	/* HP */
+	{0x16, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },	/* Mono */
+	{0x18, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80 },	/* rear MIC */
+	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN },	/* Line in */
+	{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80 },	/* Front MIC */
+	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },	/* Line out */
+	{0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN },	/* CD in */
+
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE },
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE },
+
+	{0x1b, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x15, AC_VERB_SET_CONNECT_SEL, 0x01},
+
+	/* {0x14, AC_VERB_SET_AMP_GAIN_MUTE, 0x7023 }, */
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000 },
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000 },
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, 0x7023 },
+	{0x1c, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000 },
+	{0x1d, AC_VERB_SET_AMP_GAIN_MUTE, 0x7000 },
+
+	/* FIXME: use matrix-type input source selection */
+	/* Mixer elements: 0x18, 19, 1a, 1b, 1c, 1d, 14, 15, 16, 17, 0b */
+	/* Input mixer1: unmute Mic, F-Mic, Line, CD inputs */
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))}, /*rear MIC*/
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))}, /*Line in*/
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x02 << 8))}, /*F MIC*/
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x03 << 8))}, /*Front*/
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x04 << 8))}, /*CD*/
+        /* {0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x06 << 8))},  */
+	{0x24, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x07 << 8))}, /*HP*/
+	/* Input mixer2 */
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x02 << 8))},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x03 << 8))},
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x04 << 8))},
+        /* {0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x06 << 8))}, */
+	{0x23, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x07 << 8))},
+	/* Input mixer3 */
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x00 << 8))},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8))},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x02 << 8))},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x03 << 8))},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x04 << 8))},
+        /* {0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x06 << 8))}, */
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x07 << 8))},
+
+	{ }
+};
+
 /* pcm configuration: identiacal with ALC880 */
 #define alc262_pcm_analog_playback	alc880_pcm_analog_playback
 #define alc262_pcm_analog_capture	alc880_pcm_analog_capture
@@ -5764,20 +6689,38 @@
 /*
  * configuration and preset
  */
-static struct hda_board_config alc262_cfg_tbl[] = {
-	{ .modelname = "basic", .config = ALC262_BASIC },
-	{ .modelname = "fujitsu", .config = ALC262_FUJITSU },
-	{ .pci_subvendor = 0x10cf, .pci_subdevice = 0x1397,
-	  .config = ALC262_FUJITSU },
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x280c,
-	  .config = ALC262_HP_BPC }, /* xw4400 */
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3014,
-	  .config = ALC262_HP_BPC }, /* xw6400 */
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x3015,
-	  .config = ALC262_HP_BPC }, /* xw8400 */
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x12fe,
-	  .config = ALC262_HP_BPC }, /* xw9400 */
-	{ .modelname = "auto", .config = ALC262_AUTO },
+static const char *alc262_models[ALC262_MODEL_LAST] = {
+	[ALC262_BASIC]		= "basic",
+	[ALC262_HIPPO]		= "hippo",
+	[ALC262_HIPPO_1]	= "hippo_1",
+	[ALC262_FUJITSU]	= "fujitsu",
+	[ALC262_HP_BPC]		= "hp-bpc",
+	[ALC262_HP_BPC_D7000_WL]= "hp-bpc-d7000",
+	[ALC262_BENQ_ED8]	= "benq",
+	[ALC262_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc262_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1002, 0x437b, "Hippo", ALC262_HIPPO),
+	SND_PCI_QUIRK(0x103c, 0x12fe, "HP xw9400", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x280c, "HP xw4400", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x3014, "HP xw6400", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x3015, "HP xw8400", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x1308, "HP xw4600", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x1307, "HP xw6600", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x1306, "HP xw8600", ALC262_HP_BPC),
+	SND_PCI_QUIRK(0x103c, 0x2800, "HP D7000", ALC262_HP_BPC_D7000_WL),
+	SND_PCI_QUIRK(0x103c, 0x2802, "HP D7000", ALC262_HP_BPC_D7000_WL),
+	SND_PCI_QUIRK(0x103c, 0x2804, "HP D7000", ALC262_HP_BPC_D7000_WL),
+	SND_PCI_QUIRK(0x103c, 0x2806, "HP D7000", ALC262_HP_BPC_D7000_WL),
+	SND_PCI_QUIRK(0x103c, 0x2801, "HP D7000", ALC262_HP_BPC_D7000_WF),
+	SND_PCI_QUIRK(0x103c, 0x2803, "HP D7000", ALC262_HP_BPC_D7000_WF),
+	SND_PCI_QUIRK(0x103c, 0x2805, "HP D7000", ALC262_HP_BPC_D7000_WF),
+	SND_PCI_QUIRK(0x103c, 0x2807, "HP D7000", ALC262_HP_BPC_D7000_WF),
+	SND_PCI_QUIRK(0x104d, 0x8203, "Sony UX-90", ALC262_HIPPO),
+	SND_PCI_QUIRK(0x10cf, 0x1397, "Fujitsu", ALC262_FUJITSU),
+	SND_PCI_QUIRK(0x17ff, 0x058f, "Benq Hippo", ALC262_HIPPO_1),
+	SND_PCI_QUIRK(0x17ff, 0x0560, "Benq ED8", ALC262_BENQ_ED8),
 	{}
 };
 
@@ -5792,6 +6735,30 @@
 		.channel_mode = alc262_modes,
 		.input_mux = &alc262_capture_source,
 	},
+	[ALC262_HIPPO] = {
+		.mixers = { alc262_base_mixer },
+		.init_verbs = { alc262_init_verbs, alc262_hippo_unsol_verbs},
+		.num_dacs = ARRAY_SIZE(alc262_dac_nids),
+		.dac_nids = alc262_dac_nids,
+		.hp_nid = 0x03,
+		.dig_out_nid = ALC262_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc262_modes),
+		.channel_mode = alc262_modes,
+		.input_mux = &alc262_capture_source,
+		.unsol_event = alc262_hippo_unsol_event,
+	},
+	[ALC262_HIPPO_1] = {
+		.mixers = { alc262_hippo1_mixer },
+		.init_verbs = { alc262_init_verbs, alc262_hippo1_unsol_verbs},
+		.num_dacs = ARRAY_SIZE(alc262_dac_nids),
+		.dac_nids = alc262_dac_nids,
+		.hp_nid = 0x02,
+		.dig_out_nid = ALC262_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc262_modes),
+		.channel_mode = alc262_modes,
+		.input_mux = &alc262_capture_source,
+		.unsol_event = alc262_hippo1_unsol_event,
+	},
 	[ALC262_FUJITSU] = {
 		.mixers = { alc262_fujitsu_mixer },
 		.init_verbs = { alc262_init_verbs, alc262_fujitsu_unsol_verbs },
@@ -5814,6 +6781,37 @@
 		.channel_mode = alc262_modes,
 		.input_mux = &alc262_HP_capture_source,
 	},	
+	[ALC262_HP_BPC_D7000_WF] = {
+		.mixers = { alc262_HP_BPC_WildWest_mixer },
+		.init_verbs = { alc262_HP_BPC_WildWest_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc262_dac_nids),
+		.dac_nids = alc262_dac_nids,
+		.hp_nid = 0x03,
+		.num_channel_mode = ARRAY_SIZE(alc262_modes),
+		.channel_mode = alc262_modes,
+		.input_mux = &alc262_HP_capture_source,
+	},	
+	[ALC262_HP_BPC_D7000_WL] = {
+		.mixers = { alc262_HP_BPC_WildWest_mixer,
+			    alc262_HP_BPC_WildWest_option_mixer },
+		.init_verbs = { alc262_HP_BPC_WildWest_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc262_dac_nids),
+		.dac_nids = alc262_dac_nids,
+		.hp_nid = 0x03,
+		.num_channel_mode = ARRAY_SIZE(alc262_modes),
+		.channel_mode = alc262_modes,
+		.input_mux = &alc262_HP_capture_source,
+	},	
+	[ALC262_BENQ_ED8] = {
+		.mixers = { alc262_base_mixer },
+		.init_verbs = { alc262_init_verbs, alc262_EAPD_verbs },
+		.num_dacs = ARRAY_SIZE(alc262_dac_nids),
+		.dac_nids = alc262_dac_nids,
+		.hp_nid = 0x03,
+		.num_channel_mode = ARRAY_SIZE(alc262_modes),
+		.channel_mode = alc262_modes,
+		.input_mux = &alc262_capture_source,
+	},		
 };
 
 static int patch_alc262(struct hda_codec *codec)
@@ -5822,7 +6820,7 @@
 	int board_config;
 	int err;
 
-	spec = kcalloc(1, sizeof(*spec), GFP_KERNEL);
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
 	if (spec == NULL)
 		return -ENOMEM;
 
@@ -5838,9 +6836,11 @@
 	}
 #endif
 
-	board_config = snd_hda_check_board_config(codec, alc262_cfg_tbl);
-	
-	if (board_config < 0 || board_config >= ALC262_MODEL_LAST) {
+	board_config = snd_hda_check_board_config(codec, ALC262_MODEL_LAST,
+						  alc262_models,
+						  alc262_cfg_tbl);
+
+	if (board_config < 0) {
 		printk(KERN_INFO "hda_codec: Unknown model for ALC262, "
 		       "trying auto-probe from BIOS...\n");
 		board_config = ALC262_AUTO;
@@ -5942,6 +6942,61 @@
 	{ 2, alc861_threestack_ch2_init },
 	{ 6, alc861_threestack_ch6_init },
 };
+/* Set mic1 as input and unmute the mixer */
+static struct hda_verb alc861_uniwill_m31_ch2_init[] = {
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, (0x7080 | (0x01 << 8)) }, /*mic*/
+	{ } /* end */
+};
+/* Set mic1 as output and mute mixer */
+static struct hda_verb alc861_uniwill_m31_ch4_init[] = {
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8)) }, /*mic*/
+	{ } /* end */
+};
+
+static struct hda_channel_mode alc861_uniwill_m31_modes[2] = {
+	{ 2, alc861_uniwill_m31_ch2_init },
+	{ 4, alc861_uniwill_m31_ch4_init },
+};
+
+/* Set mic1 and line-in as input and unmute the mixer */
+static struct hda_verb alc861_asus_ch2_init[] = {
+	/* set pin widget 1Ah (line in) for input */
+	{ 0x0c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
+	/* set pin widget 18h (mic1/2) for input, for mic also enable the vref */
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, 0xb00c },
+#if 0
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x01 << 8)) }, /*mic*/
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, (0x7000 | (0x02 << 8)) }, /*line-in*/
+#endif
+	{ } /* end */
+};
+/* Set mic1 nad line-in as output and mute mixer */
+static struct hda_verb alc861_asus_ch6_init[] = {
+	/* set pin widget 1Ah (line in) for output (Back Surround)*/
+	{ 0x0c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	/* { 0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE }, */
+	/* set pin widget 18h (mic1) for output (CLFE)*/
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	/* { 0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE }, */
+	{ 0x0c, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	{ 0x0d, AC_VERB_SET_CONNECT_SEL, 0x00 },
+
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080 },
+#if 0
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, (0x7080 | (0x01 << 8)) }, /*mic*/
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, (0x7080 | (0x02 << 8)) }, /*line in*/
+#endif
+	{ } /* end */
+};
+
+static struct hda_channel_mode alc861_asus_modes[2] = {
+	{ 2, alc861_asus_ch2_init },
+	{ 6, alc861_asus_ch6_init },
+};
 
 /* patch-ALC861 */
 
@@ -6019,30 +7074,144 @@
                 .private_value = ARRAY_SIZE(alc861_threestack_modes),
 	},
 	{ } /* end */
-};			
+};
+
+static struct snd_kcontrol_new alc861_toshiba_mixer[] = {
+        /* output mixer control */
+	HDA_CODEC_MUTE("Master Playback Switch", 0x03, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x15, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x15, 0x01, HDA_INPUT),
 	
-/*
- * generic initialization of ADC, input mixers and output mixers
- */
-static struct hda_verb alc861_base_init_verbs[] = {
-	/*
-	 * Unmute ADC0 and set the default input to mic-in
-	 */
-	/* port-A for surround (rear panel) */
-	{ 0x0e, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
-	{ 0x0e, AC_VERB_SET_CONNECT_SEL, 0x00 },
-	/* port-B for mic-in (rear panel) with vref */
-	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
-	/* port-C for line-in (rear panel) */
-	{ 0x0c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
-	/* port-D for Front */
-	{ 0x0b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
-	{ 0x0b, AC_VERB_SET_CONNECT_SEL, 0x00 },
-	/* port-E for HP out (front panel) */
-	{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0xc0 },
-	/* route front PCM to HP */
-	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x01 },
-	/* port-F for mic-in (front panel) with vref */
+        /*Capture mixer control */
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.count = 1,
+		.info = alc_mux_enum_info,
+		.get = alc_mux_enum_get,
+		.put = alc_mux_enum_put,
+	},
+
+	{ } /* end */
+};	
+
+static struct snd_kcontrol_new alc861_uniwill_m31_mixer[] = {
+        /* output mixer control */
+	HDA_CODEC_MUTE("Front Playback Switch", 0x03, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Surround Playback Switch", 0x06, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x05, 1, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x05, 2, 0x0, HDA_OUTPUT),
+	/*HDA_CODEC_MUTE("Side Playback Switch", 0x04, 0x0, HDA_OUTPUT), */
+
+	/* Input mixer control */
+	/* HDA_CODEC_VOLUME("Input Playback Volume", 0x15, 0x0, HDA_OUTPUT),
+	   HDA_CODEC_MUTE("Input Playback Switch", 0x15, 0x0, HDA_OUTPUT), */
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x15, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x15, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x15, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x15, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x10, 0x01, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1a, 0x03, HDA_INPUT),
+ 
+	/* Capture mixer control */
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.count = 1,
+		.info = alc_mux_enum_info,
+		.get = alc_mux_enum_get,
+		.put = alc_mux_enum_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Channel Mode",
+		.info = alc_ch_mode_info,
+		.get = alc_ch_mode_get,
+		.put = alc_ch_mode_put,
+                .private_value = ARRAY_SIZE(alc861_uniwill_m31_modes),
+	},
+	{ } /* end */
+};			
+
+static struct snd_kcontrol_new alc861_asus_mixer[] = {
+        /* output mixer control */
+	HDA_CODEC_MUTE("Front Playback Switch", 0x03, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Surround Playback Switch", 0x06, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x05, 1, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x05, 2, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Side Playback Switch", 0x04, 0x0, HDA_OUTPUT),
+
+	/* Input mixer control */
+	HDA_CODEC_VOLUME("Input Playback Volume", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Input Playback Switch", 0x15, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x15, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x15, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x15, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x15, 0x01, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x10, 0x01, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1a, 0x03, HDA_OUTPUT), /* was HDA_INPUT (why?) */
+ 
+	/* Capture mixer control */
+	HDA_CODEC_VOLUME("Capture Volume", 0x08, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x08, 0x0, HDA_INPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.count = 1,
+		.info = alc_mux_enum_info,
+		.get = alc_mux_enum_get,
+		.put = alc_mux_enum_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Channel Mode",
+		.info = alc_ch_mode_info,
+		.get = alc_ch_mode_get,
+		.put = alc_ch_mode_put,
+                .private_value = ARRAY_SIZE(alc861_asus_modes),
+	},
+	{ }
+};
+
+/* additional mixer */
+static struct snd_kcontrol_new alc861_asus_laptop_mixer[] = {
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x15, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("PC Beep Playback Volume", 0x23, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("PC Beep Playback Switch", 0x23, 0x0, HDA_OUTPUT),
+	{ }
+};
+
+/*
+ * generic initialization of ADC, input mixers and output mixers
+ */
+static struct hda_verb alc861_base_init_verbs[] = {
+	/*
+	 * Unmute ADC0 and set the default input to mic-in
+	 */
+	/* port-A for surround (rear panel) */
+	{ 0x0e, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x0e, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-B for mic-in (rear panel) with vref */
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	/* port-C for line-in (rear panel) */
+	{ 0x0c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
+	/* port-D for Front */
+	{ 0x0b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x0b, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-E for HP out (front panel) */
+	{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0xc0 },
+	/* route front PCM to HP */
+	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-F for mic-in (front panel) with vref */
 	{ 0x10, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
 	/* port-G for CLFE (rear panel) */
 	{ 0x1f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
@@ -6105,7 +7274,67 @@
 	/* port-E for HP out (front panel) */
 	{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0xc0 },
 	/* route front PCM to HP */
-	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x01 },
+	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-F for mic-in (front panel) with vref */
+	{ 0x10, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	/* port-G for CLFE (rear panel) */
+	{ 0x1f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x00 },
+	/* port-H for side (rear panel) */
+	{ 0x20, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x00 },
+	/* CD-in */
+	{ 0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
+	/* route front mic to ADC1*/
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	/* Unmute DAC0~3 & spdif out*/
+	{0x03, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x04, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x05, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x06, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	
+	/* Unmute Mixer 14 (mic) 1c (Line in)*/
+	{0x014, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+        {0x014, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x01c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+        {0x01c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	
+	/* Unmute Stereo Mixer 15 */
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, 0xb00c          }, //Output 0~12 step
+
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)}, // hp used DAC 3 (Front)
+        {0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{ }
+};
+
+static struct hda_verb alc861_uniwill_m31_init_verbs[] = {
+	/*
+	 * Unmute ADC0 and set the default input to mic-in
+	 */
+	/* port-A for surround (rear panel) */
+	{ 0x0e, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x00 },
+	/* port-B for mic-in (rear panel) with vref */
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	/* port-C for line-in (rear panel) */
+	{ 0x0c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
+	/* port-D for Front */
+	{ 0x0b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x0b, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-E for HP out (front panel) */
+	{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 }, // this has to be set to VREF80
+	/* route front PCM to HP */
+	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x00 },
 	/* port-F for mic-in (front panel) with vref */
 	{ 0x10, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
 	/* port-G for CLFE (rear panel) */
@@ -6148,6 +7377,75 @@
         {0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
 	{ }
 };
+
+static struct hda_verb alc861_asus_init_verbs[] = {
+	/*
+	 * Unmute ADC0 and set the default input to mic-in
+	 */
+	/* port-A for surround (rear panel) | according to codec#0 this is the HP jack*/
+	{ 0x0e, AC_VERB_SET_PIN_WIDGET_CONTROL, 0xc0 }, /* was 0x00 */
+	/* route front PCM to HP */
+	{ 0x0e, AC_VERB_SET_CONNECT_SEL, 0x01 },
+	/* port-B for mic-in (rear panel) with vref */
+	{ 0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	/* port-C for line-in (rear panel) */
+	{ 0x0c, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
+	/* port-D for Front */
+	{ 0x0b, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	{ 0x0b, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-E for HP out (front panel) */
+	{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 }, /* this has to be set to VREF80 */
+	/* route front PCM to HP */
+	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x00 },
+	/* port-F for mic-in (front panel) with vref */
+	{ 0x10, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	/* port-G for CLFE (rear panel) */
+	{ 0x1f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	/* port-H for side (rear panel) */
+	{ 0x20, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x40 },
+	/* CD-in */
+	{ 0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x20 },
+	/* route front mic to ADC1*/
+	{0x08, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x08, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	/* Unmute DAC0~3 & spdif out*/
+	{0x03, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x04, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x05, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x06, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	/* Unmute Mixer 14 (mic) 1c (Line in)*/
+	{0x014, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+        {0x014, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x01c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+        {0x01c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	
+	/* Unmute Stereo Mixer 15 */
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, 0xb00c          }, /* Output 0~12 step */
+
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)}, /* hp used DAC 3 (Front) */
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{ }
+};
+
+/* additional init verbs for ASUS laptops */
+static struct hda_verb alc861_asus_laptop_init_verbs[] = {
+	{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x45 }, /* HP-out */
+	{ 0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(2) }, /* mute line-in */
+	{ }
+};
+
 /*
  * generic initialization of ADC, input mixers and output mixers
  */
@@ -6200,6 +7498,39 @@
 	{ }
 };
 
+static struct hda_verb alc861_toshiba_init_verbs[] = {
+	{0x0f, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | ALC880_HP_EVENT},
+        
+	{ }
+};
+
+/* toggle speaker-output according to the hp-jack state */
+static void alc861_toshiba_automute(struct hda_codec *codec)
+{
+	unsigned int present;
+
+	present = snd_hda_codec_read(codec, 0x0f, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+	snd_hda_codec_amp_update(codec, 0x16, 0, HDA_INPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x16, 1, HDA_INPUT, 0,
+				 0x80, present ? 0x80 : 0);
+	snd_hda_codec_amp_update(codec, 0x1a, 0, HDA_INPUT, 3,
+				 0x80, present ? 0 : 0x80);
+	snd_hda_codec_amp_update(codec, 0x1a, 1, HDA_INPUT, 3,
+				 0x80, present ? 0 : 0x80);
+}
+
+static void alc861_toshiba_unsol_event(struct hda_codec *codec,
+				       unsigned int res)
+{
+	/* Looks like the unsol event is incompatible with the standard
+	 * definition.  6bit tag is placed at 26 bit!
+	 */
+	if ((res >> 26) == ALC880_HP_EVENT)
+		alc861_toshiba_automute(codec);
+}
+
 /* pcm configuration: identiacal with ALC880 */
 #define alc861_pcm_analog_playback	alc880_pcm_analog_playback
 #define alc861_pcm_analog_capture	alc880_pcm_analog_capture
@@ -6401,7 +7732,7 @@
 	struct alc_spec *spec = codec->spec;
 	hda_nid_t pin;
 
-	pin = spec->autocfg.hp_pin;
+	pin = spec->autocfg.hp_pins[0];
 	if (pin) /* connect to front */
 		alc861_auto_set_output_and_unmute(codec, pin, PIN_HP, spec->multiout.dac_nids[0]);
 }
@@ -6436,7 +7767,7 @@
 
 	if ((err = alc861_auto_fill_dac_nids(spec, &spec->autocfg)) < 0 ||
 	    (err = alc861_auto_create_multi_out_ctls(spec, &spec->autocfg)) < 0 ||
-	    (err = alc861_auto_create_hp_ctls(spec, spec->autocfg.hp_pin)) < 0 ||
+	    (err = alc861_auto_create_hp_ctls(spec, spec->autocfg.hp_pins[0])) < 0 ||
 	    (err = alc861_auto_create_analog_input_ctls(spec, &spec->autocfg)) < 0)
 		return err;
 
@@ -6473,15 +7804,29 @@
 /*
  * configuration and preset
  */
-static struct hda_board_config alc861_cfg_tbl[] = {
-	{ .modelname = "3stack", .config = ALC861_3ST },
-	{ .pci_subvendor = 0x8086, .pci_subdevice = 0xd600,
-	  .config = ALC861_3ST },
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x81e7,
-	  .config = ALC660_3ST },
-	{ .modelname = "3stack-dig", .config = ALC861_3ST_DIG },
-	{ .modelname = "6stack-dig", .config = ALC861_6ST_DIG },
-	{ .modelname = "auto", .config = ALC861_AUTO },
+static const char *alc861_models[ALC861_MODEL_LAST] = {
+	[ALC861_3ST]		= "3stack",
+	[ALC660_3ST]		= "3stack-660",
+	[ALC861_3ST_DIG]	= "3stack-dig",
+	[ALC861_6ST_DIG]	= "6stack-dig",
+	[ALC861_UNIWILL_M31]	= "uniwill-m31",
+	[ALC861_TOSHIBA]	= "toshiba",
+	[ALC861_ASUS]		= "asus",
+	[ALC861_ASUS_LAPTOP]	= "asus-laptop",
+	[ALC861_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc861_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1043, 0x1205, "ASUS W7J", ALC861_3ST),
+	SND_PCI_QUIRK(0x1043, 0x1335, "ASUS F2/3", ALC861_ASUS_LAPTOP),
+	SND_PCI_QUIRK(0x1043, 0x1338, "ASUS F2/3", ALC861_ASUS_LAPTOP),
+	SND_PCI_QUIRK(0x1043, 0x1393, "ASUS", ALC861_ASUS),
+	SND_PCI_QUIRK(0x1043, 0x81e7, "ASUS", ALC660_3ST),
+	SND_PCI_QUIRK(0x1179, 0xff00, "Toshiba", ALC861_TOSHIBA),
+	SND_PCI_QUIRK(0x1179, 0xff10, "Toshiba", ALC861_TOSHIBA),
+	SND_PCI_QUIRK(0x1584, 0x9072, "Uniwill m31", ALC861_UNIWILL_M31),
+	SND_PCI_QUIRK(0x1584, 0x2b01, "Uniwill X40AIx", ALC861_UNIWILL_M31),
+	SND_PCI_QUIRK(0x8086, 0xd600, "Intel", ALC861_3ST),
 	{}
 };
 
@@ -6493,6 +7838,7 @@
 		.dac_nids = alc861_dac_nids,
 		.num_channel_mode = ARRAY_SIZE(alc861_threestack_modes),
 		.channel_mode = alc861_threestack_modes,
+		.need_dac_fix = 1,
 		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
 		.adc_nids = alc861_adc_nids,
 		.input_mux = &alc861_capture_source,
@@ -6505,6 +7851,7 @@
 		.dig_out_nid = ALC861_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc861_threestack_modes),
 		.channel_mode = alc861_threestack_modes,
+		.need_dac_fix = 1,
 		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
 		.adc_nids = alc861_adc_nids,
 		.input_mux = &alc861_capture_source,
@@ -6528,28 +7875,85 @@
 		.dac_nids = alc660_dac_nids,
 		.num_channel_mode = ARRAY_SIZE(alc861_threestack_modes),
 		.channel_mode = alc861_threestack_modes,
+		.need_dac_fix = 1,
 		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
 		.adc_nids = alc861_adc_nids,
 		.input_mux = &alc861_capture_source,
 	},
-};	
-
-
-static int patch_alc861(struct hda_codec *codec)
-{
-	struct alc_spec *spec;
-	int board_config;
-	int err;
+	[ALC861_UNIWILL_M31] = {
+		.mixers = { alc861_uniwill_m31_mixer },
+		.init_verbs = { alc861_uniwill_m31_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861_dac_nids),
+		.dac_nids = alc861_dac_nids,
+		.dig_out_nid = ALC861_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc861_uniwill_m31_modes),
+		.channel_mode = alc861_uniwill_m31_modes,
+		.need_dac_fix = 1,
+		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
+		.adc_nids = alc861_adc_nids,
+		.input_mux = &alc861_capture_source,
+	},
+	[ALC861_TOSHIBA] = {
+		.mixers = { alc861_toshiba_mixer },
+		.init_verbs = { alc861_base_init_verbs, alc861_toshiba_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861_dac_nids),
+		.dac_nids = alc861_dac_nids,
+		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
+		.channel_mode = alc883_3ST_2ch_modes,
+		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
+		.adc_nids = alc861_adc_nids,
+		.input_mux = &alc861_capture_source,
+		.unsol_event = alc861_toshiba_unsol_event,
+		.init_hook = alc861_toshiba_automute,
+	},
+	[ALC861_ASUS] = {
+		.mixers = { alc861_asus_mixer },
+		.init_verbs = { alc861_asus_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861_dac_nids),
+		.dac_nids = alc861_dac_nids,
+		.dig_out_nid = ALC861_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc861_asus_modes),
+		.channel_mode = alc861_asus_modes,
+		.need_dac_fix = 1,
+		.hp_nid = 0x06,
+		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
+		.adc_nids = alc861_adc_nids,
+		.input_mux = &alc861_capture_source,
+	},
+	[ALC861_ASUS_LAPTOP] = {
+		.mixers = { alc861_toshiba_mixer, alc861_asus_laptop_mixer },
+		.init_verbs = { alc861_asus_init_verbs,
+				alc861_asus_laptop_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861_dac_nids),
+		.dac_nids = alc861_dac_nids,
+		.dig_out_nid = ALC861_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
+		.channel_mode = alc883_3ST_2ch_modes,
+		.need_dac_fix = 1,
+		.num_adc_nids = ARRAY_SIZE(alc861_adc_nids),
+		.adc_nids = alc861_adc_nids,
+		.input_mux = &alc861_capture_source,
+	},
+};
+
+
+static int patch_alc861(struct hda_codec *codec)
+{
+	struct alc_spec *spec;
+	int board_config;
+	int err;
 
-	spec = kcalloc(1, sizeof(*spec), GFP_KERNEL);
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
 	if (spec == NULL)
 		return -ENOMEM;
 
 	codec->spec = spec;	
 
-        board_config = snd_hda_check_board_config(codec, alc861_cfg_tbl);
+        board_config = snd_hda_check_board_config(codec, ALC861_MODEL_LAST,
+						  alc861_models,
+						  alc861_cfg_tbl);
 
-	if (board_config < 0 || board_config >= ALC861_MODEL_LAST) {
+	if (board_config < 0) {
 		printk(KERN_INFO "hda_codec: Unknown model for ALC861, "
 		       "trying auto-probe from BIOS...\n");
 		board_config = ALC861_AUTO;
@@ -6588,19 +7992,706 @@
 }
 
 /*
+ * ALC861-VD support
+ *
+ * Based on ALC882
+ *
+ * In addition, an independent DAC
+ */
+#define ALC861VD_DIGOUT_NID	0x06
+
+static hda_nid_t alc861vd_dac_nids[4] = {
+	/* front, surr, clfe, side surr */
+	0x02, 0x03, 0x04, 0x05
+};
+
+/* dac_nids for ALC660vd are in a different order - according to
+ * Realtek's driver.
+ * This should probably tesult in a different mixer for 6stack models
+ * of ALC660vd codecs, but for now there is only 3stack mixer
+ * - and it is the same as in 861vd.
+ * adc_nids in ALC660vd are (is) the same as in 861vd
+ */
+static hda_nid_t alc660vd_dac_nids[3] = {
+	/* front, rear, clfe, rear_surr */
+	0x02, 0x04, 0x03
+};
+
+static hda_nid_t alc861vd_adc_nids[1] = {
+	/* ADC0 */
+	0x09,
+};
+
+/* input MUX */
+/* FIXME: should be a matrix-type input source selection */
+static struct hda_input_mux alc861vd_capture_source = {
+	.num_items = 4,
+	.items = {
+		{ "Mic", 0x0 },
+		{ "Front Mic", 0x1 },
+		{ "Line", 0x2 },
+		{ "CD", 0x4 },
+	},
+};
+
+#define alc861vd_mux_enum_info alc_mux_enum_info
+#define alc861vd_mux_enum_get alc_mux_enum_get
+
+static int alc861vd_mux_enum_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct alc_spec *spec = codec->spec;
+	const struct hda_input_mux *imux = spec->input_mux;
+	unsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	static hda_nid_t capture_mixers[1] = { 0x22 };
+	hda_nid_t nid = capture_mixers[adc_idx];
+	unsigned int *cur_val = &spec->cur_mux[adc_idx];
+	unsigned int i, idx;
+
+	idx = ucontrol->value.enumerated.item[0];
+	if (idx >= imux->num_items)
+		idx = imux->num_items - 1;
+	if (*cur_val == idx && ! codec->in_resume)
+		return 0;
+	for (i = 0; i < imux->num_items; i++) {
+		unsigned int v = (i == idx) ? 0x7000 : 0x7080;
+		snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_AMP_GAIN_MUTE,
+				    v | (imux->items[i].index << 8));
+	}
+	*cur_val = idx;
+	return 1;
+}
+
+/*
+ * 2ch mode
+ */
+static struct hda_channel_mode alc861vd_3stack_2ch_modes[1] = {
+	{ 2, NULL }
+};
+
+/*
+ * 6ch mode
+ */
+static struct hda_verb alc861vd_6stack_ch6_init[] = {
+	{ 0x17, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x00 },
+	{ 0x16, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ 0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ 0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ } /* end */
+};
+
+/*
+ * 8ch mode
+ */
+static struct hda_verb alc861vd_6stack_ch8_init[] = {
+	{ 0x17, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ 0x16, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ 0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ 0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },
+	{ } /* end */
+};
+
+static struct hda_channel_mode alc861vd_6stack_modes[2] = {
+	{ 6, alc861vd_6stack_ch6_init },
+	{ 8, alc861vd_6stack_ch8_init },
+};
+
+static struct snd_kcontrol_new alc861vd_chmode_mixer[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Channel Mode",
+		.info = alc_ch_mode_info,
+		.get = alc_ch_mode_get,
+		.put = alc_ch_mode_put,
+	},
+	{ } /* end */
+};
+
+static struct snd_kcontrol_new alc861vd_capture_mixer[] = {
+	HDA_CODEC_VOLUME("Capture Volume", 0x09, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x09, 0x0, HDA_INPUT),
+
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		/* The multiple "Capture Source" controls confuse alsamixer
+		 * So call somewhat different..
+		 *FIXME: the controls appear in the "playback" view!
+		 */
+		/* .name = "Capture Source", */
+		.name = "Input Source",
+		.count = 1,
+		.info = alc861vd_mux_enum_info,
+		.get = alc861vd_mux_enum_get,
+		.put = alc861vd_mux_enum_put,
+	},
+	{ } /* end */
+};
+
+/* Pin assignment: Front=0x14, Rear=0x15, CLFE=0x16, Side=0x17
+ *                 Mic=0x18, Front Mic=0x19, Line-In=0x1a, HP=0x1b
+ */
+static struct snd_kcontrol_new alc861vd_6st_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x02, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Front Playback Switch", 0x0c, 2, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Surround Playback Volume", 0x03, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Surround Playback Switch", 0x0d, 2, HDA_INPUT),
+
+	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x04, 1, 0x0,
+				HDA_OUTPUT),
+	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x04, 2, 0x0,
+				HDA_OUTPUT),
+	HDA_BIND_MUTE_MONO("Center Playback Switch", 0x0e, 1, 2, HDA_INPUT),
+	HDA_BIND_MUTE_MONO("LFE Playback Switch", 0x0e, 2, 2, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Side Playback Volume", 0x05, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Side Playback Switch", 0x0f, 2, HDA_INPUT),
+
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
+	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
+
+	{ } /* end */
+};
+
+static struct snd_kcontrol_new alc861vd_3st_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x02, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("Front Playback Switch", 0x0c, 2, HDA_INPUT),
+
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x1b, 0x0, HDA_OUTPUT),
+
+	HDA_CODEC_VOLUME("Mic Boost", 0x18, 0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Mic Playback Switch", 0x0b, 0x0, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Front Mic Boost", 0x19, 0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Front Mic Playback Volume", 0x0b, 0x1, HDA_INPUT),
+	HDA_CODEC_MUTE("Front Mic Playback Switch", 0x0b, 0x1, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
+	HDA_CODEC_MUTE("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("CD Playback Volume", 0x0b, 0x04, HDA_INPUT),
+	HDA_CODEC_MUTE("CD Playback Switch", 0x0b, 0x04, HDA_INPUT),
+
+	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x0b, 0x05, HDA_INPUT),
+	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x0b, 0x05, HDA_INPUT),
+
+	{ } /* end */
+};
+
+/*
+ * generic initialization of ADC, input mixers and output mixers
+ */
+static struct hda_verb alc861vd_volume_init_verbs[] = {
+	/*
+	 * Unmute ADC0 and set the default input to mic-in
+	 */
+	{0x09, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+
+	/* Unmute input amps (CD, Line In, Mic 1 & Mic 2) of
+	 * the analog-loopback mixer widget
+	 */
+	/* Amp Indices: Mic1 = 0, Mic2 = 1, Line1 = 2, Line2 = 3, CD = 4 */
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(1)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(2)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(3)},
+	{0x0b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(4)},
+
+	/* Capture mixer: unmute Mic, F-Mic, Line, CD inputs */
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(4)},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(5)},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(6)},
+	{0x22, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(8)},
+
+	/*
+	 * Set up output mixers (0x02 - 0x05)
+	 */
+	/* set vol=0 to output mixers */
+	{0x02, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x03, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x04, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+	{0x05, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO},
+
+	/* set up input amps for analog loopback */
+	/* Amp Indices: DAC = 0, mixer = 1 */
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x0d, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x0e, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+	{0x0f, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)},
+	{0x0f, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(1)},
+
+	{ }
+};
+
+/*
+ * 3-stack pin configuration:
+ * front = 0x14, mic/clfe = 0x18, HP = 0x19, line/surr = 0x1a, f-mic = 0x1b
+ */
+static struct hda_verb alc861vd_3stack_init_verbs[] = {
+	/*
+	 * Set pin mode and muting
+	 */
+	/* set front pin widgets 0x14 for output */
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x14, AC_VERB_SET_CONNECT_SEL, 0x00},
+
+	/* Mic (rear) pin: input vref at 80% */
+	{0x18, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Front Mic pin: input vref at 80% */
+	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Line In pin: input */
+	{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Line-2 In: Headphone output (output 0 - 0x0c) */
+	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x1b, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* CD pin widget for input */
+	{0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+
+	{ }
+};
+
+/*
+ * 6-stack pin configuration:
+ */
+static struct hda_verb alc861vd_6stack_init_verbs[] = {
+	/*
+	 * Set pin mode and muting
+	 */
+	/* set front pin widgets 0x14 for output */
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x14, AC_VERB_SET_CONNECT_SEL, 0x00},
+
+	/* Rear Pin: output 1 (0x0d) */
+	{0x15, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x15, AC_VERB_SET_CONNECT_SEL, 0x01},
+	/* CLFE Pin: output 2 (0x0e) */
+	{0x16, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x16, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x16, AC_VERB_SET_CONNECT_SEL, 0x02},
+	/* Side Pin: output 3 (0x0f) */
+	{0x17, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
+	{0x17, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x17, AC_VERB_SET_CONNECT_SEL, 0x03},
+
+	/* Mic (rear) pin: input vref at 80% */
+	{0x18, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x18, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Front Mic pin: input vref at 80% */
+	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
+	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Line In pin: input */
+	{0x1a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+	{0x1a, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
+	/* Line-2 In: Headphone output (output 0 - 0x0c) */
+	{0x1b, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP},
+	{0x1b, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
+	{0x1b, AC_VERB_SET_CONNECT_SEL, 0x00},
+	/* CD pin widget for input */
+	{0x1c, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN},
+
+	{ }
+};
+
+/* pcm configuration: identiacal with ALC880 */
+#define alc861vd_pcm_analog_playback	alc880_pcm_analog_playback
+#define alc861vd_pcm_analog_capture	alc880_pcm_analog_capture
+#define alc861vd_pcm_digital_playback	alc880_pcm_digital_playback
+#define alc861vd_pcm_digital_capture	alc880_pcm_digital_capture
+
+/*
+ * configuration and preset
+ */
+static const char *alc861vd_models[ALC861VD_MODEL_LAST] = {
+	[ALC660VD_3ST]		= "3stack-660",
+	[ALC861VD_3ST]		= "3stack",
+	[ALC861VD_3ST_DIG]	= "3stack-digout",
+	[ALC861VD_6ST_DIG]	= "6stack-digout",
+	[ALC861VD_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk alc861vd_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1043, 0x1339, "Asus G1", ALC660VD_3ST),
+	SND_PCI_QUIRK(0x10de, 0x03f0, "Realtek ALC660 demo", ALC660VD_3ST),
+	SND_PCI_QUIRK(0x1019, 0xa88d, "Realtek ALC660 demo", ALC660VD_3ST),
+
+	SND_PCI_QUIRK(0x17aa, 0x3802, "Lenovo 3000 C200", ALC861VD_3ST),
+	{}
+};
+
+static struct alc_config_preset alc861vd_presets[] = {
+	[ALC660VD_3ST] = {
+		.mixers = { alc861vd_3st_mixer },
+		.init_verbs = { alc861vd_volume_init_verbs,
+				 alc861vd_3stack_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc660vd_dac_nids),
+		.dac_nids = alc660vd_dac_nids,
+		.num_adc_nids = ARRAY_SIZE(alc861vd_adc_nids),
+		.adc_nids = alc861vd_adc_nids,
+		.num_channel_mode = ARRAY_SIZE(alc861vd_3stack_2ch_modes),
+		.channel_mode = alc861vd_3stack_2ch_modes,
+		.input_mux = &alc861vd_capture_source,
+	},
+	[ALC861VD_3ST] = {
+		.mixers = { alc861vd_3st_mixer },
+		.init_verbs = { alc861vd_volume_init_verbs,
+				 alc861vd_3stack_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861vd_dac_nids),
+		.dac_nids = alc861vd_dac_nids,
+		.num_channel_mode = ARRAY_SIZE(alc861vd_3stack_2ch_modes),
+		.channel_mode = alc861vd_3stack_2ch_modes,
+		.input_mux = &alc861vd_capture_source,
+	},
+	[ALC861VD_3ST_DIG] = {
+		.mixers = { alc861vd_3st_mixer },
+		.init_verbs = { alc861vd_volume_init_verbs,
+		 		 alc861vd_3stack_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861vd_dac_nids),
+		.dac_nids = alc861vd_dac_nids,
+		.dig_out_nid = ALC861VD_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc861vd_3stack_2ch_modes),
+		.channel_mode = alc861vd_3stack_2ch_modes,
+		.input_mux = &alc861vd_capture_source,
+	},
+	[ALC861VD_6ST_DIG] = {
+		.mixers = { alc861vd_6st_mixer, alc861vd_chmode_mixer },
+		.init_verbs = { alc861vd_volume_init_verbs,
+				alc861vd_6stack_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc861vd_dac_nids),
+		.dac_nids = alc861vd_dac_nids,
+		.dig_out_nid = ALC861VD_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc861vd_6stack_modes),
+		.channel_mode = alc861vd_6stack_modes,
+		.input_mux = &alc861vd_capture_source,
+	},
+};
+
+/*
+ * BIOS auto configuration
+ */
+static void alc861vd_auto_set_output_and_unmute(struct hda_codec *codec,
+				hda_nid_t nid, int pin_type, int dac_idx)
+{
+	/* set as output */
+	snd_hda_codec_write(codec, nid, 0,
+				AC_VERB_SET_PIN_WIDGET_CONTROL, pin_type);
+	snd_hda_codec_write(codec, nid, 0,
+				AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE);
+}
+
+static void alc861vd_auto_init_multi_out(struct hda_codec *codec)
+{
+	struct alc_spec *spec = codec->spec;
+	int i;
+
+	for (i = 0; i <= HDA_SIDE; i++) {
+		hda_nid_t nid = spec->autocfg.line_out_pins[i];
+		if (nid)
+			alc861vd_auto_set_output_and_unmute(codec, nid,
+								PIN_OUT, i);
+	}
+}
+
+
+static void alc861vd_auto_init_hp_out(struct hda_codec *codec)
+{
+	struct alc_spec *spec = codec->spec;
+	hda_nid_t pin;
+
+	pin = spec->autocfg.hp_pins[0];
+	if (pin) /* connect to front and  use dac 0 */
+		alc861vd_auto_set_output_and_unmute(codec, pin, PIN_HP, 0);
+}
+
+#define alc861vd_is_input_pin(nid)	alc880_is_input_pin(nid)
+#define ALC861VD_PIN_CD_NID		ALC880_PIN_CD_NID
+
+static void alc861vd_auto_init_analog_input(struct hda_codec *codec)
+{
+	struct alc_spec *spec = codec->spec;
+	int i;
+
+	for (i = 0; i < AUTO_PIN_LAST; i++) {
+		hda_nid_t nid = spec->autocfg.input_pins[i];
+		if (alc861vd_is_input_pin(nid)) {
+			snd_hda_codec_write(codec, nid, 0,
+					AC_VERB_SET_PIN_WIDGET_CONTROL,
+					i <= AUTO_PIN_FRONT_MIC ?
+							PIN_VREF80 : PIN_IN);
+			if (nid != ALC861VD_PIN_CD_NID)
+				snd_hda_codec_write(codec, nid, 0,
+						AC_VERB_SET_AMP_GAIN_MUTE,
+						AMP_OUT_MUTE);
+		}
+	}
+}
+
+#define alc861vd_idx_to_mixer_vol(nid)		((nid) + 0x02)
+#define alc861vd_idx_to_mixer_switch(nid)	((nid) + 0x0c)
+
+/* add playback controls from the parsed DAC table */
+/* Based on ALC880 version. But ALC861VD has separate,
+ * different NIDs for mute/unmute switch and volume control */
+static int alc861vd_auto_create_multi_out_ctls(struct alc_spec *spec,
+					     const struct auto_pin_cfg *cfg)
+{
+	char name[32];
+	static const char *chname[4] = {"Front", "Surround", "CLFE", "Side"};
+	hda_nid_t nid_v, nid_s;
+	int i, err;
+
+	for (i = 0; i < cfg->line_outs; i++) {
+		if (! spec->multiout.dac_nids[i])
+			continue;
+		nid_v = alc861vd_idx_to_mixer_vol(
+				alc880_dac_to_idx(
+					spec->multiout.dac_nids[i]));
+		nid_s = alc861vd_idx_to_mixer_switch(
+				alc880_dac_to_idx(
+					spec->multiout.dac_nids[i]));
+
+		if (i == 2) {
+			/* Center/LFE */
+			if ((err = add_control(spec, ALC_CTL_WIDGET_VOL,
+						"Center Playback Volume",
+						HDA_COMPOSE_AMP_VAL(nid_v, 1,
+							0, HDA_OUTPUT))) < 0)
+				return err;
+			if ((err = add_control(spec, ALC_CTL_WIDGET_VOL,
+						"LFE Playback Volume",
+						HDA_COMPOSE_AMP_VAL(nid_v, 2,
+							0, HDA_OUTPUT))) < 0)
+				return err;
+			if ((err = add_control(spec, ALC_CTL_BIND_MUTE,
+						"Center Playback Switch",
+						HDA_COMPOSE_AMP_VAL(nid_s, 1,
+						2, HDA_INPUT))) < 0)
+				return err;
+			if ((err = add_control(spec, ALC_CTL_BIND_MUTE,
+						"LFE Playback Switch",
+						HDA_COMPOSE_AMP_VAL(nid_s, 2,
+						2, HDA_INPUT))) < 0)
+				return err;
+		} else {
+			sprintf(name, "%s Playback Volume", chname[i]);
+			if ((err = add_control(spec, ALC_CTL_WIDGET_VOL, name,
+						HDA_COMPOSE_AMP_VAL(nid_v, 3,
+							0, HDA_OUTPUT))) < 0)
+				return err;
+			sprintf(name, "%s Playback Switch", chname[i]);
+			if ((err = add_control(spec, ALC_CTL_BIND_MUTE, name,
+						HDA_COMPOSE_AMP_VAL(nid_v, 3,
+							2, HDA_INPUT))) < 0)
+				return err;
+		}
+	}
+	return 0;
+}
+
+/* add playback controls for speaker and HP outputs */
+/* Based on ALC880 version. But ALC861VD has separate,
+ * different NIDs for mute/unmute switch and volume control */
+static int alc861vd_auto_create_extra_out(struct alc_spec *spec,
+					hda_nid_t pin, const char *pfx)
+{
+	hda_nid_t nid_v, nid_s;
+	int err;
+	char name[32];
+
+	if (! pin)
+		return 0;
+
+	if (alc880_is_fixed_pin(pin)) {
+		nid_v = alc880_idx_to_dac(alc880_fixed_pin_idx(pin));
+		/* specify the DAC as the extra output */
+		if (! spec->multiout.hp_nid)
+			spec->multiout.hp_nid = nid_v;
+		else
+			spec->multiout.extra_out_nid[0] = nid_v;
+		/* control HP volume/switch on the output mixer amp */
+		nid_v = alc861vd_idx_to_mixer_vol(
+				alc880_fixed_pin_idx(pin));
+		nid_s = alc861vd_idx_to_mixer_switch(
+				alc880_fixed_pin_idx(pin));
+
+		sprintf(name, "%s Playback Volume", pfx);
+		if ((err = add_control(spec, ALC_CTL_WIDGET_VOL, name,
+				HDA_COMPOSE_AMP_VAL(nid_v, 3, 0,
+							HDA_OUTPUT))) < 0)
+			return err;
+		sprintf(name, "%s Playback Switch", pfx);
+		if ((err = add_control(spec, ALC_CTL_BIND_MUTE, name,
+				HDA_COMPOSE_AMP_VAL(nid_s, 3, 2,
+							HDA_INPUT))) < 0)
+			return err;
+	} else if (alc880_is_multi_pin(pin)) {
+		/* set manual connection */
+		/* we have only a switch on HP-out PIN */
+		sprintf(name, "%s Playback Switch", pfx);
+		if ((err = add_control(spec, ALC_CTL_WIDGET_MUTE, name,
+				HDA_COMPOSE_AMP_VAL(pin, 3, 0,
+							HDA_OUTPUT))) < 0)
+			return err;
+	}
+	return 0;
+}
+
+/* parse the BIOS configuration and set up the alc_spec
+ * return 1 if successful, 0 if the proper config is not found,
+ * or a negative error code
+ * Based on ALC880 version - had to change it to override
+ * alc880_auto_create_extra_out and alc880_auto_create_multi_out_ctls */
+static int alc861vd_parse_auto_config(struct hda_codec *codec)
+{
+	struct alc_spec *spec = codec->spec;
+	int err;
+	static hda_nid_t alc861vd_ignore[] = { 0x1d, 0 };
+
+	if ((err = snd_hda_parse_pin_def_config(codec, &spec->autocfg,
+						alc861vd_ignore)) < 0)
+		return err;
+	if (! spec->autocfg.line_outs)
+		return 0; /* can't find valid BIOS pin config */
+
+	if ((err = alc880_auto_fill_dac_nids(spec, &spec->autocfg)) < 0 ||
+		(err = alc861vd_auto_create_multi_out_ctls(spec,
+			&spec->autocfg)) < 0 ||
+		(err = alc861vd_auto_create_extra_out(spec,
+			spec->autocfg.speaker_pins[0], "Speaker")) < 0 ||
+		(err = alc861vd_auto_create_extra_out(spec,
+			spec->autocfg.hp_pins[0], "Headphone")) < 0 ||
+		(err = alc880_auto_create_analog_input_ctls(spec,
+			&spec->autocfg)) < 0)
+		return err;
+
+	spec->multiout.max_channels = spec->multiout.num_dacs * 2;
+
+	if (spec->autocfg.dig_out_pin)
+		spec->multiout.dig_out_nid = ALC861VD_DIGOUT_NID;
+
+	if (spec->kctl_alloc)
+		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
+
+	spec->init_verbs[spec->num_init_verbs++]
+		= alc861vd_volume_init_verbs;
+
+	spec->num_mux_defs = 1;
+	spec->input_mux = &spec->private_imux;
+
+	return 1;
+}
+
+/* additional initialization for auto-configuration model */
+static void alc861vd_auto_init(struct hda_codec *codec)
+{
+	alc861vd_auto_init_multi_out(codec);
+	alc861vd_auto_init_hp_out(codec);
+	alc861vd_auto_init_analog_input(codec);
+}
+
+static int patch_alc861vd(struct hda_codec *codec)
+{
+	struct alc_spec *spec;
+	int err, board_config;
+
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (spec == NULL)
+		return -ENOMEM;
+
+	codec->spec = spec;
+
+	board_config = snd_hda_check_board_config(codec, ALC861VD_MODEL_LAST,
+						  alc861vd_models,
+						  alc861vd_cfg_tbl);
+
+	if (board_config < 0 || board_config >= ALC861VD_MODEL_LAST) {
+		printk(KERN_INFO "hda_codec: Unknown model for ALC660VD/"
+			"ALC861VD, trying auto-probe from BIOS...\n");
+		board_config = ALC861VD_AUTO;
+	}
+
+	if (board_config == ALC861VD_AUTO) {
+		/* automatic parse from the BIOS config */
+		err = alc861vd_parse_auto_config(codec);
+		if (err < 0) {
+			alc_free(codec);
+			return err;
+		} else if (! err) {
+			printk(KERN_INFO
+			       "hda_codec: Cannot set up configuration "
+			       "from BIOS.  Using base mode...\n");
+			board_config = ALC861VD_3ST;
+		}
+	}
+
+	if (board_config != ALC861VD_AUTO)
+		setup_preset(spec, &alc861vd_presets[board_config]);
+
+	spec->stream_name_analog = "ALC861VD Analog";
+	spec->stream_analog_playback = &alc861vd_pcm_analog_playback;
+	spec->stream_analog_capture = &alc861vd_pcm_analog_capture;
+
+	spec->stream_name_digital = "ALC861VD Digital";
+	spec->stream_digital_playback = &alc861vd_pcm_digital_playback;
+	spec->stream_digital_capture = &alc861vd_pcm_digital_capture;
+
+	spec->adc_nids = alc861vd_adc_nids;
+	spec->num_adc_nids = ARRAY_SIZE(alc861vd_adc_nids);
+
+	spec->mixers[spec->num_mixers] = alc861vd_capture_mixer;
+	spec->num_mixers++;
+
+	codec->patch_ops = alc_patch_ops;
+
+	if (board_config == ALC861VD_AUTO)
+		spec->init_hook = alc861vd_auto_init;
+
+	return 0;
+}
+
+/*
  * patch entries
  */
 struct hda_codec_preset snd_hda_preset_realtek[] = {
 	{ .id = 0x10ec0260, .name = "ALC260", .patch = patch_alc260 },
 	{ .id = 0x10ec0262, .name = "ALC262", .patch = patch_alc262 },
- 	{ .id = 0x10ec0880, .name = "ALC880", .patch = patch_alc880 },
+	{ .id = 0x10ec0861, .rev = 0x100340, .name = "ALC660",
+		.patch = patch_alc861 },
+	{ .id = 0x10ec0660, .name = "ALC660-VD", .patch = patch_alc861vd },
+	{ .id = 0x10ec0861, .name = "ALC861", .patch = patch_alc861 },
+	{ .id = 0x10ec0862, .name = "ALC861-VD", .patch = patch_alc861vd },
+	{ .id = 0x10ec0880, .name = "ALC880", .patch = patch_alc880 },
 	{ .id = 0x10ec0882, .name = "ALC882", .patch = patch_alc882 },
 	{ .id = 0x10ec0883, .name = "ALC883", .patch = patch_alc883 },
 	{ .id = 0x10ec0885, .name = "ALC885", .patch = patch_alc882 },
 	{ .id = 0x10ec0888, .name = "ALC888", .patch = patch_alc883 },
-	{ .id = 0x10ec0861, .rev = 0x100300, .name = "ALC861",
-	  .patch = patch_alc861 },
-        { .id = 0x10ec0861, .rev = 0x100340, .name = "ALC660",
-	  .patch = patch_alc861 },
 	{} /* terminator */
 };
--- linux-2.6.18.noarch/sound/pci/hda/patch_atihdmi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_atihdmi.c	2007-06-05 17:46:40.000000000 -0400
@@ -161,5 +161,6 @@
  */
 struct hda_codec_preset snd_hda_preset_atihdmi[] = {
 	{ .id = 0x1002793c, .name = "ATI RS600 HDMI", .patch = patch_atihdmi },
+	{ .id = 0x1002791a, .name = "ATI RS690 HDMI", .patch = patch_atihdmi },
 	{} /* terminator */
 };
--- linux-2.6.18.noarch/sound/pci/hda/patch_analog.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_analog.c	2007-06-05 17:46:40.000000000 -0400
@@ -488,9 +488,13 @@
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "PCM Playback Volume",
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			  SNDRV_CTL_ELEM_ACCESS_TLV_READ |
+			  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,
 		.info = ad1986a_pcm_amp_vol_info,
 		.get = ad1986a_pcm_amp_vol_get,
 		.put = ad1986a_pcm_amp_vol_put,
+		.tlv = { .c = snd_hda_mixer_amp_tlv },
 		.private_value = HDA_COMPOSE_AMP_VAL(AD1986A_FRONT_DAC, 3, 0, HDA_OUTPUT)
 	},
 	{
@@ -519,6 +523,7 @@
 	HDA_CODEC_MUTE("Aux Playback Switch", 0x16, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x13, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x13, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x0f, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x18, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x18, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("Mono Playback Volume", 0x1e, 0x0, HDA_OUTPUT),
@@ -566,6 +571,7 @@
 	HDA_CODEC_MUTE("Aux Playback Switch", 0x16, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x13, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x13, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x0f, 0x0, HDA_OUTPUT),
 	/* HDA_CODEC_VOLUME("PC Speaker Playback Volume", 0x18, 0x0, HDA_OUTPUT),
 	   HDA_CODEC_MUTE("PC Speaker Playback Switch", 0x18, 0x0, HDA_OUTPUT),
 	   HDA_CODEC_VOLUME("Mono Playback Volume", 0x1e, 0x0, HDA_OUTPUT),
@@ -637,6 +643,7 @@
 		.info = snd_hda_mixer_amp_volume_info,
 		.get = snd_hda_mixer_amp_volume_get,
 		.put = ad1986a_laptop_master_vol_put,
+		.tlv = { .c = snd_hda_mixer_amp_tlv },
 		.private_value = HDA_COMPOSE_AMP_VAL(0x1a, 3, 0, HDA_OUTPUT),
 	},
 	{
@@ -653,6 +660,7 @@
 	HDA_CODEC_MUTE("Internal Mic Playback Switch", 0x17, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x13, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Mic Playback Switch", 0x13, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Mic Boost", 0x0f, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("Capture Volume", 0x12, 0x0, HDA_OUTPUT),
 	HDA_CODEC_MUTE("Capture Switch", 0x12, 0x0, HDA_OUTPUT),
 	{
@@ -777,44 +785,65 @@
 
 /* eapd initialization */
 static struct hda_verb ad1986a_eapd_init_verbs[] = {
-	{0x1b, AC_VERB_SET_EAPD_BTLENABLE, 0x00},
+	{0x1b, AC_VERB_SET_EAPD_BTLENABLE, 0x00 },
 	{}
 };
 
-/* models */
-enum { AD1986A_6STACK, AD1986A_3STACK, AD1986A_LAPTOP, AD1986A_LAPTOP_EAPD };
+/* Ultra initialization */
+static struct hda_verb ad1986a_ultra_init[] = {
+	/* eapd initialization */
+	{ 0x1b, AC_VERB_SET_EAPD_BTLENABLE, 0x00 },
+	/* CLFE -> Mic in */
+	{ 0x0f, AC_VERB_SET_CONNECT_SEL, 0x2 },
+	{ 0x1d, AC_VERB_SET_PIN_WIDGET_CONTROL, 0x24 },
+	{ 0x1d, AC_VERB_SET_AMP_GAIN_MUTE, 0xb080 },
+	{ } /* end */
+};
 
-static struct hda_board_config ad1986a_cfg_tbl[] = {
-	{ .modelname = "6stack",	.config = AD1986A_6STACK },
-	{ .modelname = "3stack",	.config = AD1986A_3STACK },
-	{ .pci_subvendor = 0x10de, .pci_subdevice = 0xcb84,
-	  .config = AD1986A_3STACK }, /* ASUS A8N-VM CSM */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x81b3,
-	  .config = AD1986A_3STACK }, /* ASUS P5RD2-VM / P5GPL-X SE */
-	{ .modelname = "laptop",	.config = AD1986A_LAPTOP },
-	{ .pci_subvendor = 0x144d, .pci_subdevice = 0xc01e,
-	  .config = AD1986A_LAPTOP }, /* FSC V2060 */
-	{ .pci_subvendor = 0x17c0, .pci_subdevice = 0x2017,
-	  .config = AD1986A_LAPTOP }, /* Samsung M50 */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x818f,
-	  .config = AD1986A_LAPTOP }, /* ASUS P5GV-MX */
-	{ .modelname = "laptop-eapd",	.config = AD1986A_LAPTOP_EAPD },
-	{ .pci_subvendor = 0x144d, .pci_subdevice = 0xc023,
-	  .config = AD1986A_LAPTOP_EAPD }, /* Samsung X60 Chane */
-	{ .pci_subvendor = 0x144d, .pci_subdevice = 0xc024,
-	  .config = AD1986A_LAPTOP_EAPD }, /* Samsung R65-T2300 Charis */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1153,
-	  .config = AD1986A_LAPTOP_EAPD }, /* ASUS M9 */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1213,
-	  .config = AD1986A_LAPTOP_EAPD }, /* ASUS A6J */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x11f7,
-	  .config = AD1986A_LAPTOP_EAPD }, /* ASUS U5A */
-	{ .pci_subvendor = 0x1043, .pci_subdevice = 0x1297,
-	  .config = AD1986A_LAPTOP_EAPD }, /* ASUS Z62F */
-	{ .pci_subvendor = 0x103c, .pci_subdevice = 0x30af,
-	  .config = AD1986A_LAPTOP_EAPD }, /* HP Compaq Presario B2800 */
-	{ .pci_subvendor = 0x17aa, .pci_subdevice = 0x2066,
-	  .config = AD1986A_LAPTOP_EAPD }, /* Lenovo 3000 N100-07684JU */
+/* models */
+enum {
+	AD1986A_6STACK,
+	AD1986A_3STACK,
+	AD1986A_LAPTOP,
+	AD1986A_LAPTOP_EAPD,
+	AD1986A_ULTRA,
+	AD1986A_MODELS
+};
+
+static const char *ad1986a_models[AD1986A_MODELS] = {
+	[AD1986A_6STACK]	= "6stack",
+	[AD1986A_3STACK]	= "3stack",
+	[AD1986A_LAPTOP]	= "laptop",
+	[AD1986A_LAPTOP_EAPD]	= "laptop-eapd",
+	[AD1986A_ULTRA]		= "ultra",
+};
+
+static struct snd_pci_quirk ad1986a_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x103c, 0x30af, "HP B2800", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x10de, 0xcb84, "ASUS A8N-VM", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x1043, 0x1153, "ASUS M9", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x1213, "ASUS A6J", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x11f7, "ASUS U5A", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x1263, "ASUS U5F", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x1297, "ASUS Z62F", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x12b3, "ASUS V1j", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x1302, "ASUS W3j", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x1043, 0x817f, "ASUS P5", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x1043, 0x818f, "ASUS P5", AD1986A_LAPTOP),
+	SND_PCI_QUIRK(0x1043, 0x81b3, "ASUS P5", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x1043, 0x81cb, "ASUS M2N", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x1043, 0x8234, "ASUS M2N", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x144d, 0xb03c, "Samsung R55", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x144d, 0xc01e, "FSC V2060", AD1986A_LAPTOP),
+	SND_PCI_QUIRK(0x144d, 0xc023, "Samsung X60", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x144d, 0xc024, "Samsung R65", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x144d, 0xc026, "Samsung X11", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x144d, 0xc504, "Samsung Q35", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x144d, 0xc027, "Samsung Q1", AD1986A_ULTRA),
+	SND_PCI_QUIRK(0x17aa, 0x1011, "Lenovo M55", AD1986A_LAPTOP),
+	SND_PCI_QUIRK(0x17aa, 0x1017, "Lenovo A60", AD1986A_3STACK),
+	SND_PCI_QUIRK(0x17aa, 0x2066, "Lenovo N100", AD1986A_LAPTOP_EAPD),
+	SND_PCI_QUIRK(0x17c0, 0x2017, "Samsung M50", AD1986A_LAPTOP),
 	{}
 };
 
@@ -846,7 +875,9 @@
 	codec->patch_ops = ad198x_patch_ops;
 
 	/* override some parameters */
-	board_config = snd_hda_check_board_config(codec, ad1986a_cfg_tbl);
+	board_config = snd_hda_check_board_config(codec, AD1986A_MODELS,
+						  ad1986a_models,
+						  ad1986a_cfg_tbl);
 	switch (board_config) {
 	case AD1986A_3STACK:
 		spec->num_mixers = 2;
@@ -876,6 +907,15 @@
 		spec->multiout.dig_out_nid = 0;
 		spec->input_mux = &ad1986a_laptop_eapd_capture_source;
 		break;
+	case AD1986A_ULTRA:
+		spec->mixers[0] = ad1986a_laptop_eapd_mixers;
+		spec->num_init_verbs = 2;
+		spec->init_verbs[1] = ad1986a_ultra_init;
+		spec->multiout.max_channels = 2;
+		spec->multiout.num_dacs = 1;
+		spec->multiout.dac_nids = ad1986a_laptop_dac_nids;
+		spec->multiout.dig_out_nid = 0;
+		break;
 	}
 
 	return 0;
@@ -1167,7 +1207,7 @@
 /*
  * Patch for HP nx6320
  *
- * nx6320 uses EAPD in the reserve way - EAPD-on means the internal
+ * nx6320 uses EAPD in the reverse way - EAPD-on means the internal
  * speaker output enabled _and_ mute-LED off.
  */
 
@@ -1335,6 +1375,21 @@
 	return 0;
 }
 
+/* configuration for Toshiba Laptops */
+static struct hda_verb ad1981_toshiba_init_verbs[] = {
+	{0x05, AC_VERB_SET_EAPD_BTLENABLE, 0x01 }, /* default on */
+	/* pin sensing on HP and Mic jacks */
+	{0x06, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | AD1981_HP_EVENT},
+	{0x08, AC_VERB_SET_UNSOLICITED_ENABLE, AC_USRSP_EN | AD1981_MIC_EVENT},
+	{}
+};
+
+static struct snd_kcontrol_new ad1981_toshiba_mixers[] = {
+	HDA_CODEC_VOLUME("Amp Volume", 0x1a, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Amp Switch", 0x1a, 0x0, HDA_OUTPUT),
+	{ }
+};
+
 /* configuration for Lenovo Thinkpad T60 */
 static struct snd_kcontrol_new ad1981_thinkpad_mixers[] = {
 	HDA_CODEC_VOLUME("Master Playback Volume", 0x05, 0x0, HDA_OUTPUT),
@@ -1376,20 +1431,30 @@
 };
 
 /* models */
-enum { AD1981_BASIC, AD1981_HP, AD1981_THINKPAD };
+enum {
+	AD1981_BASIC,
+	AD1981_HP,
+	AD1981_THINKPAD,
+	AD1981_TOSHIBA,
+	AD1981_MODELS
+};
+
+static const char *ad1981_models[AD1981_MODELS] = {
+	[AD1981_HP]		= "hp",
+	[AD1981_THINKPAD]	= "thinkpad",
+	[AD1981_BASIC]		= "basic",
+	[AD1981_TOSHIBA]	= "toshiba"
+};
 
-static struct hda_board_config ad1981_cfg_tbl[] = {
-	{ .modelname = "hp", .config = AD1981_HP },
+static struct snd_pci_quirk ad1981_cfg_tbl[] = {
 	/* All HP models */
-	{ .pci_subvendor = 0x103c, .config = AD1981_HP },
-	{ .pci_subvendor = 0x30b0, .pci_subdevice = 0x103c,
-	  .config = AD1981_HP }, /* HP nx6320 (reversed SSID, H/W bug) */
-	{ .modelname = "thinkpad", .config = AD1981_THINKPAD },
+	SND_PCI_QUIRK(0x103c, 0, "HP nx", AD1981_HP),
+	/* HP nx6320 (reversed SSID, H/W bug) */
+	SND_PCI_QUIRK(0x30b0, 0x103c, "HP nx6320", AD1981_HP),
 	/* Lenovo Thinkpad T60/X60/Z6xx */
-	{ .pci_subvendor = 0x17aa, .config = AD1981_THINKPAD },
-	{ .pci_subvendor = 0x1014, .pci_subdevice = 0x0597,
-	  .config = AD1981_THINKPAD }, /* Z60m/t */
-	{ .modelname = "basic", .config = AD1981_BASIC },
+	SND_PCI_QUIRK(0x17aa, 0, "Lenovo Thinkpad", AD1981_THINKPAD),
+	SND_PCI_QUIRK(0x1014, 0x0597, "Lenovo Z60", AD1981_THINKPAD),
+	SND_PCI_QUIRK(0x1179, 0x0001, "Toshiba U205", AD1981_TOSHIBA),
 	{}
 };
 
@@ -1422,7 +1487,9 @@
 	codec->patch_ops = ad198x_patch_ops;
 
 	/* override some parameters */
-	board_config = snd_hda_check_board_config(codec, ad1981_cfg_tbl);
+	board_config = snd_hda_check_board_config(codec, AD1981_MODELS,
+						  ad1981_models,
+						  ad1981_cfg_tbl);
 	switch (board_config) {
 	case AD1981_HP:
 		spec->mixers[0] = ad1981_hp_mixers;
@@ -1438,8 +1505,17 @@
 		spec->mixers[0] = ad1981_thinkpad_mixers;
 		spec->input_mux = &ad1981_thinkpad_capture_source;
 		break;
+	case AD1981_TOSHIBA:
+		spec->mixers[0] = ad1981_hp_mixers;
+		spec->mixers[1] = ad1981_toshiba_mixers;
+		spec->num_init_verbs = 2;
+		spec->init_verbs[1] = ad1981_toshiba_init_verbs;
+		spec->multiout.dig_out_nid = 0;
+		spec->input_mux = &ad1981_hp_capture_source;
+		codec->patch_ops.init = ad1981_hp_init;
+		codec->patch_ops.unsol_event = ad1981_hp_unsol_event;
+		break;
 	}
-
 	return 0;
 }
 
@@ -1626,10 +1702,12 @@
 {
 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ad198x_spec *spec = codec->spec;
-	if (spec->need_dac_fix)
+	int err = snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,
+				      spec->num_channel_mode,
+				      &spec->multiout.max_channels);
+	if (err >= 0 && spec->need_dac_fix)
 		spec->multiout.num_dacs = spec->multiout.max_channels / 2;
-	return snd_hda_ch_mode_put(codec, ucontrol, spec->channel_mode,
-				   spec->num_channel_mode, &spec->multiout.max_channels);
+	return err;
 }
 
 /* 6-stack mode */
@@ -2460,7 +2538,7 @@
 	pin = spec->autocfg.speaker_pins[0];
 	if (pin) /* connect to front */
 		ad1988_auto_set_output_and_unmute(codec, pin, PIN_OUT, 0);
-	pin = spec->autocfg.hp_pin;
+	pin = spec->autocfg.hp_pins[0];
 	if (pin) /* connect to front */
 		ad1988_auto_set_output_and_unmute(codec, pin, PIN_HP, 0);
 }
@@ -2512,7 +2590,7 @@
 	    (err = ad1988_auto_create_extra_out(codec,
 						spec->autocfg.speaker_pins[0],
 						"Speaker")) < 0 ||
-	    (err = ad1988_auto_create_extra_out(codec, spec->autocfg.hp_pin,
+	    (err = ad1988_auto_create_extra_out(codec, spec->autocfg.hp_pins[0],
 						"Headphone")) < 0 ||
 	    (err = ad1988_auto_create_analog_input_ctls(spec, &spec->autocfg)) < 0)
 		return err;
@@ -2548,14 +2626,19 @@
 /*
  */
 
-static struct hda_board_config ad1988_cfg_tbl[] = {
-	{ .modelname = "6stack",	.config = AD1988_6STACK },
-	{ .modelname = "6stack-dig",	.config = AD1988_6STACK_DIG },
-	{ .modelname = "3stack",	.config = AD1988_3STACK },
-	{ .modelname = "3stack-dig",	.config = AD1988_3STACK_DIG },
-	{ .modelname = "laptop",	.config = AD1988_LAPTOP },
-	{ .modelname = "laptop-dig",	.config = AD1988_LAPTOP_DIG },
-	{ .modelname = "auto",		.config = AD1988_AUTO },
+static const char *ad1988_models[AD1988_MODEL_LAST] = {
+	[AD1988_6STACK]		= "6stack",
+	[AD1988_6STACK_DIG]	= "6stack-dig",
+	[AD1988_3STACK]		= "3stack",
+	[AD1988_3STACK_DIG]	= "3stack-dig",
+	[AD1988_LAPTOP]		= "laptop",
+	[AD1988_LAPTOP_DIG]	= "laptop-dig",
+	[AD1988_AUTO]		= "auto",
+};
+
+static struct snd_pci_quirk ad1988_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x1043, 0x81f6, "Asus M2N-SLI", AD1988_6STACK_DIG),
+	SND_PCI_QUIRK(0x1043, 0x81ec, "Asus P5B-DLX", AD1988_6STACK_DIG),
 	{}
 };
 
@@ -2574,8 +2657,9 @@
 	if (is_rev2(codec))
 		snd_printk(KERN_INFO "patch_analog: AD1988A rev.2 is detected, enable workarounds\n");
 
-	board_config = snd_hda_check_board_config(codec, ad1988_cfg_tbl);
-	if (board_config < 0 || board_config >= AD1988_MODEL_LAST) {
+	board_config = snd_hda_check_board_config(codec, AD1988_MODEL_LAST,
+						  ad1988_models, ad1988_cfg_tbl);
+	if (board_config < 0) {
 		printk(KERN_INFO "hda_codec: Unknown model for AD1988, trying auto-probe from BIOS...\n");
 		board_config = AD1988_AUTO;
 	}
--- linux-2.6.18.noarch/sound/pci/hda/patch_sigmatel.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/patch_sigmatel.c	2007-06-05 17:46:40.000000000 -0400
@@ -36,16 +36,41 @@
 
 #define NUM_CONTROL_ALLOC	32
 #define STAC_HP_EVENT		0x37
-#define STAC_UNSOL_ENABLE 	(AC_USRSP_EN | STAC_HP_EVENT)
 
-#define STAC_REF		0
-#define STAC_D945GTP3		1
-#define STAC_D945GTP5		2
-#define STAC_MACMINI		3
-#define STAC_922X_MODELS	4	/* number of 922x models */
-#define STAC_D965_3ST		5
-#define STAC_D965_5ST		6
-#define STAC_927X_MODELS	7	/* number of 922x models */
+enum {
+	STAC_REF,
+	STAC_9200_MODELS
+};
+
+enum {
+	STAC_9205_REF,
+	STAC_9205_MODELS
+};
+
+enum {
+	STAC_925x_REF,
+	STAC_M2_2,
+	STAC_MA6,
+	STAC_925x_MODELS
+};
+
+enum {
+	STAC_D945_REF,
+	STAC_D945GTP3,
+	STAC_D945GTP5,
+	STAC_MACMINI,
+	STAC_MACBOOK,
+	STAC_MACBOOK_PRO_V1,
+	STAC_MACBOOK_PRO_V2,
+	STAC_922X_MODELS
+};
+
+enum {
+	STAC_D965_REF,
+	STAC_D965_3ST,
+	STAC_D965_5ST,
+	STAC_927X_MODELS
+};
 
 struct sigmatel_spec {
 	struct snd_kcontrol_new *mixers[4];
@@ -68,18 +93,24 @@
 	unsigned int num_adcs;
 	hda_nid_t *mux_nids;
 	unsigned int num_muxes;
+	hda_nid_t *dmic_nids;
+	unsigned int num_dmics;
+	hda_nid_t dmux_nid;
 	hda_nid_t dig_in_nid;
 
 	/* pin widgets */
 	hda_nid_t *pin_nids;
 	unsigned int num_pins;
 	unsigned int *pin_configs;
+	unsigned int *bios_pin_configs;
 
 	/* codec specific stuff */
 	struct hda_verb *init;
 	struct snd_kcontrol_new *mixer;
 
 	/* capture source */
+	struct hda_input_mux *dinput_mux;
+	unsigned int cur_dmux;
 	struct hda_input_mux *input_mux;
 	unsigned int cur_mux[3];
 
@@ -92,6 +123,7 @@
 	struct auto_pin_cfg autocfg;
 	unsigned int num_kctl_alloc, num_kctl_used;
 	struct snd_kcontrol_new *kctl_alloc;
+	struct hda_input_mux private_dimux;
 	struct hda_input_mux private_imux;
 };
 
@@ -107,6 +139,18 @@
         0x02,
 };
 
+static hda_nid_t stac925x_adc_nids[1] = {
+        0x03,
+};
+
+static hda_nid_t stac925x_mux_nids[1] = {
+        0x0f,
+};
+
+static hda_nid_t stac925x_dac_nids[1] = {
+        0x02,
+};
+
 static hda_nid_t stac922x_adc_nids[2] = {
         0x06, 0x07,
 };
@@ -131,11 +175,20 @@
         0x19, 0x1a
 };
 
+static hda_nid_t stac9205_dmic_nids[3] = {
+        0x17, 0x18, 0
+};
+
 static hda_nid_t stac9200_pin_nids[8] = {
 	0x08, 0x09, 0x0d, 0x0e, 
 	0x0f, 0x10, 0x11, 0x12,
 };
 
+static hda_nid_t stac925x_pin_nids[8] = {
+	0x07, 0x08, 0x0a, 0x0b, 
+	0x0c, 0x0d, 0x10, 0x11,
+};
+
 static hda_nid_t stac922x_pin_nids[10] = {
 	0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
 	0x0f, 0x10, 0x11, 0x15, 0x1b,
@@ -154,6 +207,34 @@
 	
 };
 
+static int stac92xx_dmux_enum_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct sigmatel_spec *spec = codec->spec;
+	return snd_hda_input_mux_info(spec->dinput_mux, uinfo);
+}
+
+static int stac92xx_dmux_enum_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct sigmatel_spec *spec = codec->spec;
+
+	ucontrol->value.enumerated.item[0] = spec->cur_dmux;
+	return 0;
+}
+
+static int stac92xx_dmux_enum_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct sigmatel_spec *spec = codec->spec;
+
+	return snd_hda_input_mux_put(codec, spec->dinput_mux, ucontrol,
+				     spec->dmux_nid, &spec->cur_dmux);
+}
+
 static int stac92xx_mux_enum_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
@@ -187,6 +268,12 @@
 	{}
 };
 
+static struct hda_verb stac925x_core_init[] = {
+	/* set dac0mux for dac converter */
+	{ 0x06, AC_VERB_SET_CONNECT_SEL, 0x00},
+	{}
+};
+
 static struct hda_verb stac922x_core_init[] = {
 	/* set master volume and direct control */	
 	{ 0x16, AC_VERB_SET_VOLUME_KNOB_CONTROL, 0xff},
@@ -232,6 +319,23 @@
 	{ } /* end */
 };
 
+static struct snd_kcontrol_new stac925x_mixer[] = {
+	HDA_CODEC_VOLUME("Master Playback Volume", 0xe, 0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Master Playback Switch", 0xe, 0, HDA_OUTPUT),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Input Source",
+		.count = 1,
+		.info = stac92xx_mux_enum_info,
+		.get = stac92xx_mux_enum_get,
+		.put = stac92xx_mux_enum_put,
+	},
+	HDA_CODEC_VOLUME("Capture Volume", 0x09, 0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x09, 0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Capture Mux Volume", 0x0f, 0, HDA_OUTPUT),
+	{ } /* end */
+};
+
 /* This needs to be generated dynamically based on sequence */
 static struct snd_kcontrol_new stac922x_mixer[] = {
 	{
@@ -263,7 +367,7 @@
 	{ } /* end */
 };
 
-static snd_kcontrol_new_t stac927x_mixer[] = {
+static struct snd_kcontrol_new stac927x_mixer[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Input Source",
@@ -278,7 +382,15 @@
 	{ } /* end */
 };
 
-static snd_kcontrol_new_t stac9205_mixer[] = {
+static struct snd_kcontrol_new stac9205_mixer[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Digital Input Source",
+		.count = 1,
+		.info = stac92xx_dmux_enum_info,
+		.get = stac92xx_dmux_enum_get,
+		.put = stac92xx_dmux_enum_put,
+	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Input Source",
@@ -327,15 +439,70 @@
 	0x02a19020, 0x01a19021, 0x90100140, 0x01813122,
 };
 
-static unsigned int *stac9200_brd_tbl[] = {
-	ref9200_pin_configs,
+static unsigned int *stac9200_brd_tbl[STAC_9200_MODELS] = {
+	[STAC_REF] = ref9200_pin_configs,
 };
 
-static struct hda_board_config stac9200_cfg_tbl[] = {
-	{ .modelname = "ref",
-	  .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2668,	/* DFI LanParty */
-	  .config = STAC_REF },
+static const char *stac9200_models[STAC_9200_MODELS] = {
+	[STAC_REF] = "ref",
+};
+
+static struct snd_pci_quirk stac9200_cfg_tbl[] = {
+	/* SigmaTel reference board */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2668,
+		      "DFI LanParty", STAC_REF),
+	/* Dell laptops have BIOS problem */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01b5,
+		      "Dell Inspiron 630m", STAC_REF),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01c2,
+		      "Dell Latitude D620", STAC_REF),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01cb,
+		      "Dell Latitude 120L", STAC_REF),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01cc,
+		      "Dell Latitude D820", STAC_REF),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01cd,
+		      "Dell Inspiron E1705/9400", STAC_REF),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01ce,
+		      "Dell XPS M1710", STAC_REF),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x01cf,
+		      "Dell Precision M90", STAC_REF),
+	{} /* terminator */
+};
+
+static unsigned int ref925x_pin_configs[8] = {
+	0x40c003f0, 0x424503f2, 0x01813022, 0x02a19021,
+	0x90a70320, 0x02214210, 0x400003f1, 0x9033032e,
+};
+
+static unsigned int stac925x_MA6_pin_configs[8] = {
+	0x40c003f0, 0x424503f2, 0x01813022, 0x02a19021,
+	0x90a70320, 0x90100211, 0x400003f1, 0x9033032e,
+};
+
+static unsigned int stac925xM2_2_pin_configs[8] = {
+	0x40c003f3, 0x424503f2, 0x041800f4, 0x02a19020,
+	0x50a103F0, 0x90100210, 0x400003f1, 0x9033032e,
+};
+
+static unsigned int *stac925x_brd_tbl[STAC_925x_MODELS] = {
+	[STAC_REF] = ref925x_pin_configs,
+	[STAC_M2_2] = stac925xM2_2_pin_configs,
+	[STAC_MA6] = stac925x_MA6_pin_configs,
+};
+
+static const char *stac925x_models[STAC_925x_MODELS] = {
+	[STAC_REF] = "ref",
+	[STAC_M2_2] = "m2-2",
+	[STAC_MA6] = "m6",
+};
+
+static struct snd_pci_quirk stac925x_cfg_tbl[] = {
+	/* SigmaTel reference board */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2668, "DFI LanParty", STAC_REF),
+	SND_PCI_QUIRK(0x107b, 0x0316, "Gateway M255", STAC_REF),
+	SND_PCI_QUIRK(0x107b, 0x0366, "Gateway MP6954", STAC_REF),
+	SND_PCI_QUIRK(0x107b, 0x0461, "Gateway NX560XL", STAC_MA6),
+	SND_PCI_QUIRK(0x1002, 0x437b, "Gateway MX6453", STAC_M2_2),
 	{} /* terminator */
 };
 
@@ -357,101 +524,105 @@
 	0x02a19320, 0x40000100,
 };
 
+static unsigned int macbook_pin_configs[10] = {
+	0x0321e230, 0x03a1e020, 0x400000fd, 0x9017e110,
+	0x400000fe, 0x0381e021, 0x1345e240, 0x13c5e22e,
+	0x400000fc, 0x400000fb,
+};
+
+static unsigned int macbook_pro_v1_pin_configs[10] = {
+	0x0321e230, 0x03a1e020, 0x9017e110, 0x01014010,
+	0x01a19021, 0x0381e021, 0x1345e240, 0x13c5e22e,
+	0x02a19320, 0x400000fb
+};
+
+static unsigned int macbook_pro_v2_pin_configs[10] = {
+	0x0221401f, 0x90a70120, 0x01813024, 0x01014010,
+	0x400000fd, 0x01016011, 0x1345e240, 0x13c5e22e,
+	0x400000fc, 0x400000fb,
+};
+
 static unsigned int *stac922x_brd_tbl[STAC_922X_MODELS] = {
-	[STAC_REF] =	ref922x_pin_configs,
+	[STAC_D945_REF] = ref922x_pin_configs,
 	[STAC_D945GTP3] = d945gtp3_pin_configs,
 	[STAC_D945GTP5] = d945gtp5_pin_configs,
 	[STAC_MACMINI] = d945gtp5_pin_configs,
-};
-
-static struct hda_board_config stac922x_cfg_tbl[] = {
-	{ .modelname = "5stack", .config = STAC_D945GTP5 },
-	{ .modelname = "3stack", .config = STAC_D945GTP3 },
-	{ .modelname = "ref",
-	  .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2668,	/* DFI LanParty */
-	  .config = STAC_REF },		/* SigmaTel reference board */
-         /* Intel 945G based systems */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0101,
-	  .config = STAC_D945GTP3 },	/* Intel D945GTP - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0202,
-	  .config = STAC_D945GTP3 },	/* Intel D945GNT - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0606,
-	  .config = STAC_D945GTP3 },	/* Intel D945GTP - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0601,
-	  .config = STAC_D945GTP3 },	/* Intel D945GTP - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0111,
-	  .config = STAC_D945GTP3 },	/* Intel D945GZP - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x1115,
-	  .config = STAC_D945GTP3 },	/* Intel D945GPM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x1116,
-	  .config = STAC_D945GTP3 },	/* Intel D945GBO - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x1117,
-	  .config = STAC_D945GTP3 },	/* Intel D945GPM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x1118,
-	  .config = STAC_D945GTP3 },	/* Intel D945GPM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x1119,
-	  .config = STAC_D945GTP3 },	/* Intel D945GPM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x8826,
-	  .config = STAC_D945GTP3 },	/* Intel D945GPM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x5049,
-	  .config = STAC_D945GTP3 },	/* Intel D945GCZ - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x5055,
-	  .config = STAC_D945GTP3 },	/* Intel D945GCZ - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x5048,
-	  .config = STAC_D945GTP3 },	/* Intel D945GPB - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0110,
-	  .config = STAC_D945GTP3 },	/* Intel D945GLR - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0404,
-	  .config = STAC_D945GTP5 },	/* Intel D945GTP - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0303,
-	  .config = STAC_D945GTP5 },	/* Intel D945GNT - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0013,
-	  .config = STAC_D945GTP5 },	/* Intel D955XBK - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0417,
-	  .config = STAC_D945GTP5 },	/* Intel D975XBK - 5 Stack */
-	  /* Intel 945P based systems */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0b0b,
-	  .config = STAC_D945GTP3 },	/* Intel D945PSN - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0112,
-	  .config = STAC_D945GTP3 },	/* Intel D945PLN - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0d0d,
-	  .config = STAC_D945GTP3 },	/* Intel D945PLM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0909,
-	  .config = STAC_D945GTP3 },	/* Intel D945PAW - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0505,
-	  .config = STAC_D945GTP3 },	/* Intel D945PLM - 3 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x0707,
-	  .config = STAC_D945GTP5 },	/* Intel D945PSV - 5 Stack */
-	  /* other systems  */
-	{ .pci_subvendor = 0x8384,
-	  .pci_subdevice = 0x7680,
-	  .config = STAC_MACMINI },	/* Apple Mac Mini (early 2006) */
+	[STAC_MACBOOK] = macbook_pin_configs,
+	[STAC_MACBOOK_PRO_V1] = macbook_pro_v1_pin_configs,
+	[STAC_MACBOOK_PRO_V2] = macbook_pro_v2_pin_configs,
+};
+
+static const char *stac922x_models[STAC_922X_MODELS] = {
+	[STAC_D945_REF]	= "ref",
+	[STAC_D945GTP5]	= "5stack",
+	[STAC_D945GTP3]	= "3stack",
+	[STAC_MACMINI]	= "macmini",
+	[STAC_MACBOOK]	= "macbook",
+	[STAC_MACBOOK_PRO_V1]	= "macbook-pro-v1",
+	[STAC_MACBOOK_PRO_V2]	= "macbook-pro",
+};
+
+static struct snd_pci_quirk stac922x_cfg_tbl[] = {
+	/* SigmaTel reference board */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2668,
+		      "DFI LanParty", STAC_D945_REF),
+	/* Intel 945G based systems */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0101,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0202,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0606,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0601,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0111,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x1115,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x1116,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x1117,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x1118,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x1119,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x8826,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x5049,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x5055,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x5048,
+		      "Intel D945G", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0110,
+		      "Intel D945G", STAC_D945GTP3),
+	/* Intel D945G 5-stack systems */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0404,
+		      "Intel D945G", STAC_D945GTP5),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0303,
+		      "Intel D945G", STAC_D945GTP5),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0013,
+		      "Intel D945G", STAC_D945GTP5),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0417,
+		      "Intel D945G", STAC_D945GTP5),
+	/* Intel 945P based systems */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0b0b,
+		      "Intel D945P", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0112,
+		      "Intel D945P", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0d0d,
+		      "Intel D945P", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0909,
+		      "Intel D945P", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0505,
+		      "Intel D945P", STAC_D945GTP3),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x0707,
+		      "Intel D945P", STAC_D945GTP5),
+	/* other systems  */
+	/* Apple Mac Mini (early 2006) */
+	SND_PCI_QUIRK(0x8384, 0x7680,
+		      "Mac Mini", STAC_MACMINI),
 	{} /* terminator */
 };
 
@@ -477,130 +648,111 @@
 };
 
 static unsigned int *stac927x_brd_tbl[STAC_927X_MODELS] = {
-	[STAC_REF] =	ref927x_pin_configs,
+	[STAC_D965_REF] = ref927x_pin_configs,
 	[STAC_D965_3ST] = d965_3st_pin_configs,
 	[STAC_D965_5ST] = d965_5st_pin_configs,
 };
 
-static struct hda_board_config stac927x_cfg_tbl[] = {
-	{ .modelname = "5stack", .config = STAC_D965_5ST },
-	{ .modelname = "3stack", .config = STAC_D965_3ST },
-	{ .modelname = "ref",
-	  .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2668,	/* DFI LanParty */
-	  .config = STAC_REF },		/* SigmaTel reference board */
+static const char *stac927x_models[STAC_927X_MODELS] = {
+	[STAC_D965_REF]	= "ref",
+	[STAC_D965_3ST]	= "3stack",
+	[STAC_D965_5ST] = "5stack",
+};
+
+static struct snd_pci_quirk stac927x_cfg_tbl[] = {
+	/* SigmaTel reference board */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2668,
+		      "DFI LanParty", STAC_D965_REF),
 	 /* Intel 946 based systems */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x3d01,
-	  .config = STAC_D965_3ST }, /* D946  configuration */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0xa301,
-	  .config = STAC_D965_3ST }, /* Intel D946GZT - 3 stack  */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x3d01, "Intel D946", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0xa301, "Intel D946", STAC_D965_3ST),
 	/* 965 based 3 stack systems */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2116,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2115,
-	  .config = STAC_D965_3ST }, /* Intel DQ965WC - 3 Stack  */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2114,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2113,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2112,
-	  .config = STAC_D965_3ST }, /* Intel DG965MS - 3 Stack  */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2111,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2110,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2009,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2008,
-	  .config = STAC_D965_3ST }, /* Intel DQ965GF - 3 Stack  */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2007,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2006,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2005,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2004,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2003,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2002,
-	  .config = STAC_D965_3ST }, /* Intel D965 3Stack config */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2001,
-	  .config = STAC_D965_3ST }, /* Intel DQ965GF - 3 Stack */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2116, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2115, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2114, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2113, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2112, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2111, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2110, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2009, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2008, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2007, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2006, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2005, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2004, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2003, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2002, "Intel D965", STAC_D965_3ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2001, "Intel D965", STAC_D965_3ST),
 	/* 965 based 5 stack systems */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2301,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2302,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2303,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2304,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2305,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2501,
-	  .config = STAC_D965_5ST }, /* Intel DG965MQ - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2502,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2503,
-	  .config = STAC_D965_5ST }, /* Intel DG965 - 5 Stack */
-	{ .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2504,
-	  .config = STAC_D965_5ST }, /* Intel DQ965GF - 5 Stack */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2301, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2302, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2303, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2304, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2305, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2501, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2502, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2503, "Intel D965", STAC_D965_5ST),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2504, "Intel D965", STAC_D965_5ST),
 	{} /* terminator */
 };
 
 static unsigned int ref9205_pin_configs[12] = {
 	0x40000100, 0x40000100, 0x01016011, 0x01014010,
-	0x01813122, 0x01a19021, 0x40000100, 0x40000100, 
-	0x40000100, 0x40000100, 0x01441030, 0x01c41030
+	0x01813122, 0x01a19021, 0x40000100, 0x40000100,
+	0x90a000f0, 0x90a000f0, 0x01441030, 0x01c41030
 };
 
-static unsigned int *stac9205_brd_tbl[] = {
+static unsigned int *stac9205_brd_tbl[STAC_9205_MODELS] = {
 	ref9205_pin_configs,
 };
 
-static struct hda_board_config stac9205_cfg_tbl[] = {
-	{ .modelname = "ref",
-	  .pci_subvendor = PCI_VENDOR_ID_INTEL,
-	  .pci_subdevice = 0x2668,	/* DFI LanParty */
-	  .config = STAC_REF },		/* SigmaTel reference board */
+static const char *stac9205_models[STAC_9205_MODELS] = {
+	[STAC_9205_REF] = "ref",
+};
+
+static struct snd_pci_quirk stac9205_cfg_tbl[] = {
+	/* SigmaTel reference board */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_INTEL, 0x2668,
+		      "DFI LanParty", STAC_9205_REF),
 	{} /* terminator */
 };
 
+static int stac92xx_save_bios_config_regs(struct hda_codec *codec)
+{
+	int i;
+	struct sigmatel_spec *spec = codec->spec;
+	
+	if (! spec->bios_pin_configs) {
+		spec->bios_pin_configs = kcalloc(spec->num_pins,
+		                                 sizeof(*spec->bios_pin_configs), GFP_KERNEL);
+		if (! spec->bios_pin_configs)
+			return -ENOMEM;
+	}
+	
+	for (i = 0; i < spec->num_pins; i++) {
+		hda_nid_t nid = spec->pin_nids[i];
+		unsigned int pin_cfg;
+		
+		pin_cfg = snd_hda_codec_read(codec, nid, 0, 
+			AC_VERB_GET_CONFIG_DEFAULT, 0x00);	
+		snd_printdd(KERN_INFO "hda_codec: pin nid %2.2x bios pin config %8.8x\n",
+					nid, pin_cfg);
+		spec->bios_pin_configs[i] = pin_cfg;
+	}
+	
+	return 0;
+}
+
 static void stac92xx_set_config_regs(struct hda_codec *codec)
 {
 	int i;
 	struct sigmatel_spec *spec = codec->spec;
 	unsigned int pin_cfg;
 
-	for (i=0; i < spec->num_pins; i++) {
+	if (! spec->pin_nids || ! spec->pin_configs)
+		return;
+
+	for (i = 0; i < spec->num_pins; i++) {
 		snd_hda_codec_write(codec, spec->pin_nids[i], 0,
 				    AC_VERB_SET_CONFIG_DEFAULT_BYTES_0,
 				    spec->pin_configs[i] & 0x000000ff);
@@ -974,11 +1126,29 @@
 	return 0;
 }
 
+/* create volume control/switch for the given prefx type */
+static int create_controls(struct sigmatel_spec *spec, const char *pfx, hda_nid_t nid, int chs)
+{
+	char name[32];
+	int err;
+
+	sprintf(name, "%s Playback Volume", pfx);
+	err = stac92xx_add_control(spec, STAC_CTL_WIDGET_VOL, name,
+				   HDA_COMPOSE_AMP_VAL(nid, chs, 0, HDA_OUTPUT));
+	if (err < 0)
+		return err;
+	sprintf(name, "%s Playback Switch", pfx);
+	err = stac92xx_add_control(spec, STAC_CTL_WIDGET_MUTE, name,
+				   HDA_COMPOSE_AMP_VAL(nid, chs, 0, HDA_OUTPUT));
+	if (err < 0)
+		return err;
+	return 0;
+}
+
 /* add playback controls from the parsed DAC table */
 static int stac92xx_auto_create_multi_out_ctls(struct sigmatel_spec *spec,
 					       const struct auto_pin_cfg *cfg)
 {
-	char name[32];
 	static const char *chname[4] = {
 		"Front", "Surround", NULL /*CLFE*/, "Side"
 	};
@@ -993,26 +1163,15 @@
 
 		if (i == 2) {
 			/* Center/LFE */
-			if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_VOL, "Center Playback Volume",
-					       HDA_COMPOSE_AMP_VAL(nid, 1, 0, HDA_OUTPUT))) < 0)
-				return err;
-			if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_VOL, "LFE Playback Volume",
-					       HDA_COMPOSE_AMP_VAL(nid, 2, 0, HDA_OUTPUT))) < 0)
-				return err;
-			if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_MUTE, "Center Playback Switch",
-					       HDA_COMPOSE_AMP_VAL(nid, 1, 0, HDA_OUTPUT))) < 0)
+			err = create_controls(spec, "Center", nid, 1);
+			if (err < 0)
 				return err;
-			if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_MUTE, "LFE Playback Switch",
-					       HDA_COMPOSE_AMP_VAL(nid, 2, 0, HDA_OUTPUT))) < 0)
+			err = create_controls(spec, "LFE", nid, 2);
+			if (err < 0)
 				return err;
 		} else {
-			sprintf(name, "%s Playback Volume", chname[i]);
-			if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_VOL, name,
-					       HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT))) < 0)
-				return err;
-			sprintf(name, "%s Playback Switch", chname[i]);
-			if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_MUTE, name,
-					       HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT))) < 0)
+			err = create_controls(spec, chname[i], nid, 3);
+			if (err < 0)
 				return err;
 		}
 	}
@@ -1028,39 +1187,137 @@
 	return 0;
 }
 
-/* add playback controls for HP output */
-static int stac92xx_auto_create_hp_ctls(struct hda_codec *codec, struct auto_pin_cfg *cfg)
+static int check_in_dac_nids(struct sigmatel_spec *spec, hda_nid_t nid)
 {
-	struct sigmatel_spec *spec = codec->spec;
-	hda_nid_t pin = cfg->hp_pin;
-	hda_nid_t nid;
-	int i, err;
-	unsigned int wid_caps;
+	int i;
 
-	if (! pin)
-		return 0;
+	for (i = 0; i < spec->multiout.num_dacs; i++) {
+		if (spec->multiout.dac_nids[i] == nid)
+			return 1;
+	}
+	if (spec->multiout.hp_nid == nid)
+		return 1;
+	return 0;
+}
 
-	wid_caps = get_wcaps(codec, pin);
-	if (wid_caps & AC_WCAP_UNSOL_CAP)
-		spec->hp_detect = 1;
+static int add_spec_dacs(struct sigmatel_spec *spec, hda_nid_t nid)
+{
+	if (!spec->multiout.hp_nid)
+		spec->multiout.hp_nid = nid;
+	else if (spec->multiout.num_dacs > 4) {
+		printk(KERN_WARNING "stac92xx: No space for DAC 0x%x\n", nid);
+		return 1;
+	} else {
+		spec->multiout.dac_nids[spec->multiout.num_dacs] = nid;
+		spec->multiout.num_dacs++;
+	}
+	return 0;
+}
 
-	nid = snd_hda_codec_read(codec, pin, 0, AC_VERB_GET_CONNECT_LIST, 0) & 0xff;
-	for (i = 0; i < cfg->line_outs; i++) {
-		if (! spec->multiout.dac_nids[i])
+/* add playback controls for Speaker and HP outputs */
+static int stac92xx_auto_create_hp_ctls(struct hda_codec *codec,
+					struct auto_pin_cfg *cfg)
+{
+	struct sigmatel_spec *spec = codec->spec;
+	hda_nid_t nid;
+	int i, old_num_dacs, err;
+
+	old_num_dacs = spec->multiout.num_dacs;
+	for (i = 0; i < cfg->hp_outs; i++) {
+		unsigned int wid_caps = get_wcaps(codec, cfg->hp_pins[i]);
+		if (wid_caps & AC_WCAP_UNSOL_CAP)
+			spec->hp_detect = 1;
+		nid = snd_hda_codec_read(codec, cfg->hp_pins[i], 0,
+					 AC_VERB_GET_CONNECT_LIST, 0) & 0xff;
+		if (check_in_dac_nids(spec, nid))
+			nid = 0;
+		if (! nid)
 			continue;
-		if (spec->multiout.dac_nids[i] == nid)
-			return 0;
+		add_spec_dacs(spec, nid);
+	}
+	for (i = 0; i < cfg->speaker_outs; i++) {
+		nid = snd_hda_codec_read(codec, cfg->speaker_pins[0], 0,
+					 AC_VERB_GET_CONNECT_LIST, 0) & 0xff;
+		if (check_in_dac_nids(spec, nid))
+			nid = 0;
+		if (check_in_dac_nids(spec, nid))
+			nid = 0;
+		if (! nid)
+			continue;
+		add_spec_dacs(spec, nid);
+	}
+
+	for (i = old_num_dacs; i < spec->multiout.num_dacs; i++) {
+		static const char *pfxs[] = {
+			"Speaker", "External Speaker", "Speaker2",
+		};
+		err = create_controls(spec, pfxs[i - old_num_dacs],
+				      spec->multiout.dac_nids[i], 3);
+		if (err < 0)
+			return err;
+	}
+	if (spec->multiout.hp_nid) {
+		const char *pfx;
+		if (old_num_dacs == spec->multiout.num_dacs)
+			pfx = "Master";
+		else
+			pfx = "Headphone";
+		err = create_controls(spec, pfx, spec->multiout.hp_nid, 3);
+		if (err < 0)
+			return err;
 	}
 
-	spec->multiout.hp_nid = nid;
+	return 0;
+}
 
-	/* control HP volume/switch on the output mixer amp */
-	if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_VOL, "Headphone Playback Volume",
-					HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT))) < 0)
-		return err;
-	if ((err = stac92xx_add_control(spec, STAC_CTL_WIDGET_MUTE, "Headphone Playback Switch",
-					HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT))) < 0)
-		return err;
+/* labels for dmic mux inputs */
+static const char *stac92xx_dmic_labels[5] = {
+	"Analog Inputs", "Digital Mic 1", "Digital Mic 2",
+	"Digital Mic 3", "Digital Mic 4"
+};
+
+/* create playback/capture controls for input pins on dmic capable codecs */
+static int stac92xx_auto_create_dmic_input_ctls(struct hda_codec *codec,
+						const struct auto_pin_cfg *cfg)
+{
+	struct sigmatel_spec *spec = codec->spec;
+	struct hda_input_mux *dimux = &spec->private_dimux;
+	hda_nid_t con_lst[HDA_MAX_NUM_INPUTS];
+	int i, j;
+
+	dimux->items[dimux->num_items].label = stac92xx_dmic_labels[0];
+	dimux->items[dimux->num_items].index = 0;
+	dimux->num_items++;
+
+	for (i = 0; i < spec->num_dmics; i++) {
+		int index;
+		int num_cons;
+		unsigned int def_conf;
+
+		def_conf = snd_hda_codec_read(codec,
+					      spec->dmic_nids[i],
+					      0,
+					      AC_VERB_GET_CONFIG_DEFAULT,
+					      0);
+		if (get_defcfg_connect(def_conf) == AC_JACK_PORT_NONE)
+			continue;
+
+		num_cons = snd_hda_get_connections(codec,
+				spec->dmux_nid,
+				con_lst,
+				HDA_MAX_NUM_INPUTS);
+		for (j = 0; j < num_cons; j++)
+			if (con_lst[j] == spec->dmic_nids[i]) {
+				index = j;
+				goto found;
+			}
+		continue;
+found:
+		dimux->items[dimux->num_items].label =
+			stac92xx_dmic_labels[dimux->num_items];
+		dimux->items[dimux->num_items].index = index;
+		dimux->num_items++;
+	}
 
 	return 0;
 }
@@ -1074,23 +1331,28 @@
 	int i, j, k;
 
 	for (i = 0; i < AUTO_PIN_LAST; i++) {
-		int index = -1;
-		if (cfg->input_pins[i]) {
-			imux->items[imux->num_items].label = auto_pin_cfg_labels[i];
-
-			for (j=0; j<spec->num_muxes; j++) {
-				int num_cons = snd_hda_get_connections(codec, spec->mux_nids[j], con_lst, HDA_MAX_NUM_INPUTS);
-				for (k=0; k<num_cons; k++)
-					if (con_lst[k] == cfg->input_pins[i]) {
-						index = k;
-					 	break;
-					}
-				if (index >= 0)
-					break;
-			}
-			imux->items[imux->num_items].index = index;
-			imux->num_items++;
+		int index;
+
+		if (!cfg->input_pins[i])
+			continue;
+		index = -1;
+		for (j = 0; j < spec->num_muxes; j++) {
+			int num_cons;
+			num_cons = snd_hda_get_connections(codec,
+							   spec->mux_nids[j],
+							   con_lst,
+							   HDA_MAX_NUM_INPUTS);
+			for (k = 0; k < num_cons; k++)
+				if (con_lst[k] == cfg->input_pins[i]) {
+					index = k;
+					goto found;
+				}
 		}
+		continue;
+	found:
+		imux->items[imux->num_items].label = auto_pin_cfg_labels[i];
+		imux->items[imux->num_items].index = index;
+		imux->num_items++;
 	}
 
 	if (imux->num_items == 1) {
@@ -1123,11 +1385,20 @@
 static void stac92xx_auto_init_hp_out(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec = codec->spec;
-	hda_nid_t pin;
+	int i;
 
-	pin = spec->autocfg.hp_pin;
-	if (pin) /* connect to front */
-		stac92xx_auto_set_pinctl(codec, pin, AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN);
+	for (i = 0; i < spec->autocfg.hp_outs; i++) {
+		hda_nid_t pin;
+		pin = spec->autocfg.hp_pins[i];
+		if (pin) /* connect to front */
+			stac92xx_auto_set_pinctl(codec, pin, AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN);
+	}
+	for (i = 0; i < spec->autocfg.speaker_outs; i++) {
+		hda_nid_t pin;
+		pin = spec->autocfg.speaker_pins[i];
+		if (pin) /* connect to front */
+			stac92xx_auto_set_pinctl(codec, pin, AC_PINCTL_OUT_EN);
+	}
 }
 
 static int stac92xx_parse_auto_config(struct hda_codec *codec, hda_nid_t dig_out, hda_nid_t dig_in)
@@ -1135,7 +1406,9 @@
 	struct sigmatel_spec *spec = codec->spec;
 	int err;
 
-	if ((err = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL)) < 0)
+	if ((err = snd_hda_parse_pin_def_config(codec,
+						&spec->autocfg,
+						spec->dmic_nids)) < 0)
 		return err;
 	if (! spec->autocfg.line_outs)
 		return 0; /* can't find valid pin config */
@@ -1151,6 +1424,11 @@
 	    (err = stac92xx_auto_create_analog_input_ctls(codec, &spec->autocfg)) < 0)
 		return err;
 
+	if (spec->num_dmics > 0)
+		if ((err = stac92xx_auto_create_dmic_input_ctls(codec,
+						&spec->autocfg)) < 0)
+			return err;
+
 	spec->multiout.max_channels = spec->multiout.num_dacs * 2;
 	if (spec->multiout.max_channels > 2)
 		spec->surr_switch = 1;
@@ -1164,6 +1442,7 @@
 		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
 
 	spec->input_mux = &spec->private_imux;
+	spec->dinput_mux = &spec->private_dimux;
 
 	return 1;
 }
@@ -1173,7 +1452,7 @@
 					struct auto_pin_cfg *cfg)
 {
 	struct sigmatel_spec *spec = codec->spec;
-	hda_nid_t pin = cfg->hp_pin;
+	hda_nid_t pin = cfg->hp_pins[0];
 	unsigned int wid_caps;
 
 	if (! pin)
@@ -1186,6 +1465,57 @@
 	return 0;
 }
 
+/* add playback controls for LFE output */
+static int stac9200_auto_create_lfe_ctls(struct hda_codec *codec,
+					struct auto_pin_cfg *cfg)
+{
+	struct sigmatel_spec *spec = codec->spec;
+	int err;
+	hda_nid_t lfe_pin = 0x0;
+	int i;
+
+	/*
+	 * search speaker outs and line outs for a mono speaker pin
+	 * with an amp.  If one is found, add LFE controls
+	 * for it.
+	 */
+	for (i = 0; i < spec->autocfg.speaker_outs && lfe_pin == 0x0; i++) {
+		hda_nid_t pin = spec->autocfg.speaker_pins[i];
+		unsigned long wcaps = get_wcaps(codec, pin);
+		wcaps &= (AC_WCAP_STEREO | AC_WCAP_OUT_AMP);
+		if (wcaps == AC_WCAP_OUT_AMP)
+			/* found a mono speaker with an amp, must be lfe */
+			lfe_pin = pin;
+	}
+
+	/* if speaker_outs is 0, then speakers may be in line_outs */
+	if (lfe_pin == 0 && spec->autocfg.speaker_outs == 0) {
+		for (i = 0; i < spec->autocfg.line_outs && lfe_pin == 0x0; i++) {
+			hda_nid_t pin = spec->autocfg.line_out_pins[i];
+			unsigned long cfg;
+			cfg = snd_hda_codec_read(codec, pin, 0,
+						 AC_VERB_GET_CONFIG_DEFAULT,
+						 0x00);
+			if (get_defcfg_device(cfg) == AC_JACK_SPEAKER) {
+				unsigned long wcaps = get_wcaps(codec, pin);
+				wcaps &= (AC_WCAP_STEREO | AC_WCAP_OUT_AMP);
+				if (wcaps == AC_WCAP_OUT_AMP)
+					/* found a mono speaker with an amp,
+					   must be lfe */
+					lfe_pin = pin;
+			}
+		}
+	}
+
+	if (lfe_pin) {
+		err = create_controls(spec, "LFE", lfe_pin, 1);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
 static int stac9200_parse_auto_config(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec = codec->spec;
@@ -1200,6 +1530,9 @@
 	if ((err = stac9200_auto_create_hp_ctls(codec, &spec->autocfg)) < 0)
 		return err;
 
+	if ((err = stac9200_auto_create_lfe_ctls(codec, &spec->autocfg)) < 0)
+		return err;
+
 	if (spec->autocfg.dig_out_pin)
 		spec->multiout.dig_out_nid = 0x05;
 	if (spec->autocfg.dig_in_pin)
@@ -1209,6 +1542,7 @@
 		spec->mixers[spec->num_mixers++] = spec->kctl_alloc;
 
 	spec->input_mux = &spec->private_imux;
+	spec->dinput_mux = &spec->private_dimux;
 
 	return 1;
 }
@@ -1252,6 +1586,15 @@
 			    AC_VERB_SET_GPIO_DATA, gpiostate);
 }
 
+static void enable_pin_detect(struct hda_codec *codec, hda_nid_t nid,
+			      unsigned int event)
+{
+	if (get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP)
+		snd_hda_codec_write(codec, nid, 0,
+				    AC_VERB_SET_UNSOLICITED_ENABLE,
+				    (AC_USRSP_EN | event));
+}
+
 static int stac92xx_init(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec = codec->spec;
@@ -1263,13 +1606,17 @@
 	/* set up pins */
 	if (spec->hp_detect) {
 		/* Enable unsolicited responses on the HP widget */
-		snd_hda_codec_write(codec, cfg->hp_pin, 0,
-				AC_VERB_SET_UNSOLICITED_ENABLE,
-				STAC_UNSOL_ENABLE);
+		for (i = 0; i < cfg->hp_outs; i++)
+			enable_pin_detect(codec, cfg->hp_pins[i],
+					  STAC_HP_EVENT);
+		/* force to enable the first line-out; the others are set up
+		 * in unsol_event
+		 */
+		stac92xx_auto_set_pinctl(codec, spec->autocfg.line_out_pins[0],
+					 AC_PINCTL_OUT_EN);
+		stac92xx_auto_init_hp_out(codec);
 		/* fake event to set up pins */
 		codec->patch_ops.unsol_event(codec, STAC_HP_EVENT << 26);
-		/* enable the headphones by default.  If/when unsol_event detection works, this will be ignored */
-		stac92xx_auto_init_hp_out(codec);
 	} else {
 		stac92xx_auto_init_multi_out(codec);
 		stac92xx_auto_init_hp_out(codec);
@@ -1283,6 +1630,11 @@
 			stac92xx_auto_set_pinctl(codec, nid, pinctl);
 		}
 	}
+	if (spec->num_dmics > 0)
+		for (i = 0; i < spec->num_dmics; i++)
+			stac92xx_auto_set_pinctl(codec, spec->dmic_nids[i],
+						 AC_PINCTL_IN_EN);
+
 	if (cfg->dig_out_pin)
 		stac92xx_auto_set_pinctl(codec, cfg->dig_out_pin,
 					 AC_PINCTL_OUT_EN);
@@ -1312,6 +1664,9 @@
 		kfree(spec->kctl_alloc);
 	}
 
+	if (spec->bios_pin_configs)
+		kfree(spec->bios_pin_configs);
+
 	kfree(spec);
 }
 
@@ -1320,6 +1675,8 @@
 {
 	unsigned int pin_ctl = snd_hda_codec_read(codec, nid,
 			0, AC_VERB_GET_PIN_WIDGET_CONTROL, 0x00);
+	if (flag == AC_PINCTL_OUT_EN && (pin_ctl & AC_PINCTL_IN_EN))
+		return;
 	snd_hda_codec_write(codec, nid, 0,
 			AC_VERB_SET_PIN_WIDGET_CONTROL,
 			pin_ctl | flag);
@@ -1335,33 +1692,57 @@
 			pin_ctl & ~flag);
 }
 
-static void stac92xx_unsol_event(struct hda_codec *codec, unsigned int res)
+static int get_pin_presence(struct hda_codec *codec, hda_nid_t nid)
+{
+	if (!nid)
+		return 0;
+	if (snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_PIN_SENSE, 0x00)
+	    & (1 << 31))
+		return 1;
+	return 0;
+}
+
+static void stac92xx_hp_detect(struct hda_codec *codec, unsigned int res)
 {
 	struct sigmatel_spec *spec = codec->spec;
 	struct auto_pin_cfg *cfg = &spec->autocfg;
 	int i, presence;
 
-	if ((res >> 26) != STAC_HP_EVENT)
-		return;
-
-	presence = snd_hda_codec_read(codec, cfg->hp_pin, 0,
-			AC_VERB_GET_PIN_SENSE, 0x00) >> 31;
+	presence = 0;
+	for (i = 0; i < cfg->hp_outs; i++) {
+		presence = get_pin_presence(codec, cfg->hp_pins[i]);
+		if (presence)
+			break;
+	}
 
 	if (presence) {
 		/* disable lineouts, enable hp */
 		for (i = 0; i < cfg->line_outs; i++)
 			stac92xx_reset_pinctl(codec, cfg->line_out_pins[i],
 						AC_PINCTL_OUT_EN);
-		stac92xx_set_pinctl(codec, cfg->hp_pin, AC_PINCTL_OUT_EN);
+		for (i = 0; i < cfg->speaker_outs; i++)
+			stac92xx_reset_pinctl(codec, cfg->speaker_pins[i],
+						AC_PINCTL_OUT_EN);
 	} else {
 		/* enable lineouts, disable hp */
 		for (i = 0; i < cfg->line_outs; i++)
 			stac92xx_set_pinctl(codec, cfg->line_out_pins[i],
 						AC_PINCTL_OUT_EN);
-		stac92xx_reset_pinctl(codec, cfg->hp_pin, AC_PINCTL_OUT_EN);
+		for (i = 0; i < cfg->speaker_outs; i++)
+			stac92xx_set_pinctl(codec, cfg->speaker_pins[i],
+						AC_PINCTL_OUT_EN);
 	}
 } 
 
+static void stac92xx_unsol_event(struct hda_codec *codec, unsigned int res)
+{
+	switch (res >> 26) {
+	case STAC_HP_EVENT:
+		stac92xx_hp_detect(codec, res);
+		break;
+	}
+}
+
 #ifdef CONFIG_PM
 static int stac92xx_resume(struct hda_codec *codec)
 {
@@ -1369,6 +1750,7 @@
 	int i;
 
 	stac92xx_init(codec);
+	stac92xx_set_config_regs(codec);
 	for (i = 0; i < spec->num_mixers; i++)
 		snd_hda_resume_ctls(codec, spec->mixers[i]);
 	if (spec->multiout.dig_out_nid)
@@ -1401,12 +1783,20 @@
 		return -ENOMEM;
 
 	codec->spec = spec;
-	spec->board_config = snd_hda_check_board_config(codec, stac9200_cfg_tbl);
-	if (spec->board_config < 0)
-                snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC9200, using BIOS defaults\n");
-	else {
-		spec->num_pins = 8;
-		spec->pin_nids = stac9200_pin_nids;
+	spec->num_pins = 8;
+	spec->pin_nids = stac9200_pin_nids;
+	spec->board_config = snd_hda_check_board_config(codec, STAC_9200_MODELS,
+							stac9200_models,
+							stac9200_cfg_tbl);
+	if (spec->board_config < 0) {
+		snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC9200, using BIOS defaults\n");
+		err = stac92xx_save_bios_config_regs(codec);
+		if (err < 0) {
+			stac92xx_free(codec);
+			return err;
+		}
+		spec->pin_configs = spec->bios_pin_configs;
+	} else {
 		spec->pin_configs = stac9200_brd_tbl[spec->board_config];
 		stac92xx_set_config_regs(codec);
 	}
@@ -1417,6 +1807,7 @@
 	spec->adc_nids = stac9200_adc_nids;
 	spec->mux_nids = stac9200_mux_nids;
 	spec->num_muxes = 1;
+	spec->num_dmics = 0;
 
 	spec->init = stac9200_core_init;
 	spec->mixer = stac9200_mixer;
@@ -1432,6 +1823,66 @@
 	return 0;
 }
 
+static int patch_stac925x(struct hda_codec *codec)
+{
+	struct sigmatel_spec *spec;
+	int err;
+
+	spec  = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (spec == NULL)
+		return -ENOMEM;
+
+	codec->spec = spec;
+	spec->num_pins = 8;
+	spec->pin_nids = stac925x_pin_nids;
+	spec->board_config = snd_hda_check_board_config(codec, STAC_925x_MODELS,
+							stac925x_models,
+							stac925x_cfg_tbl);
+ again:
+	if (spec->board_config < 0) {
+		snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC925x, using BIOS defaults\n");
+		err = stac92xx_save_bios_config_regs(codec);
+		if (err < 0) {
+			stac92xx_free(codec);
+			return err;
+		}
+		spec->pin_configs = spec->bios_pin_configs;
+	} else if (stac925x_brd_tbl[spec->board_config] != NULL){
+		spec->pin_configs = stac925x_brd_tbl[spec->board_config];
+		stac92xx_set_config_regs(codec);
+	}
+
+	spec->multiout.max_channels = 2;
+	spec->multiout.num_dacs = 1;
+	spec->multiout.dac_nids = stac925x_dac_nids;
+	spec->adc_nids = stac925x_adc_nids;
+	spec->mux_nids = stac925x_mux_nids;
+	spec->num_muxes = 1;
+	spec->num_dmics = 0;
+
+	spec->init = stac925x_core_init;
+	spec->mixer = stac925x_mixer;
+
+	err = stac92xx_parse_auto_config(codec, 0x8, 0x7);
+	if (!err) {
+		if (spec->board_config < 0) {
+			printk(KERN_WARNING "hda_codec: No auto-config is "
+			       "available, default to model=ref\n");
+			spec->board_config = STAC_925x_REF;
+			goto again;
+		}
+		err = -EINVAL;
+	}
+	if (err < 0) {
+		stac92xx_free(codec);
+		return err;
+	}
+
+	codec->patch_ops = stac92xx_patch_ops;
+
+	return 0;
+}
+
 static int patch_stac922x(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec;
@@ -1442,13 +1893,38 @@
 		return -ENOMEM;
 
 	codec->spec = spec;
-	spec->board_config = snd_hda_check_board_config(codec, stac922x_cfg_tbl);
-	if (spec->board_config < 0)
-                snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC922x, "
-			    "using BIOS defaults\n");
-	else if (stac922x_brd_tbl[spec->board_config] != NULL) {
-		spec->num_pins = 10;
-		spec->pin_nids = stac922x_pin_nids;
+	spec->num_pins = 10;
+	spec->pin_nids = stac922x_pin_nids;
+	spec->board_config = snd_hda_check_board_config(codec, STAC_922X_MODELS,
+							stac922x_models,
+							stac922x_cfg_tbl);
+	if (spec->board_config == STAC_MACMINI) {
+		spec->gpio_mute = 1;
+		/* Intel Macs have all same PCI SSID, so we need to check
+		 * codec SSID to distinguish the exact models
+		 */
+		printk(KERN_INFO "hda_codec: STAC922x, Apple subsys_id=%x\n", codec->subsystem_id);
+		switch (codec->subsystem_id) {
+		case 0x106b0200: /* MacBook Pro first generation */
+			spec->board_config = STAC_MACBOOK_PRO_V1;
+			break;
+		case 0x106b1e00: /* MacBook Pro second generation */
+			spec->board_config = STAC_MACBOOK_PRO_V2;
+			break;
+		}
+	}
+
+ again:
+	if (spec->board_config < 0) {
+		snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC922x, "
+			"using BIOS defaults\n");
+		err = stac92xx_save_bios_config_regs(codec);
+		if (err < 0) {
+			stac92xx_free(codec);
+			return err;
+		}
+		spec->pin_configs = spec->bios_pin_configs;
+	} else if (stac922x_brd_tbl[spec->board_config] != NULL) {
 		spec->pin_configs = stac922x_brd_tbl[spec->board_config];
 		stac92xx_set_config_regs(codec);
 	}
@@ -1456,6 +1932,7 @@
 	spec->adc_nids = stac922x_adc_nids;
 	spec->mux_nids = stac922x_mux_nids;
 	spec->num_muxes = 2;
+	spec->num_dmics = 0;
 
 	spec->init = stac922x_core_init;
 	spec->mixer = stac922x_mixer;
@@ -1463,14 +1940,20 @@
 	spec->multiout.dac_nids = spec->dac_nids;
 	
 	err = stac92xx_parse_auto_config(codec, 0x08, 0x09);
+	if (!err) {
+		if (spec->board_config < 0) {
+			printk(KERN_WARNING "hda_codec: No auto-config is "
+			       "available, default to model=ref\n");
+			spec->board_config = STAC_D945_REF;
+			goto again;
+		}
+		err = -EINVAL;
+	}
 	if (err < 0) {
 		stac92xx_free(codec);
 		return err;
 	}
 
-	if (spec->board_config == STAC_MACMINI)
-		spec->gpio_mute = 1;
-
 	codec->patch_ops = stac92xx_patch_ops;
 
 	return 0;
@@ -1486,12 +1969,21 @@
 		return -ENOMEM;
 
 	codec->spec = spec;
-	spec->board_config = snd_hda_check_board_config(codec, stac927x_cfg_tbl);
-	if (spec->board_config < 0)
+	spec->num_pins = 14;
+	spec->pin_nids = stac927x_pin_nids;
+	spec->board_config = snd_hda_check_board_config(codec, STAC_927X_MODELS,
+							stac927x_models,
+							stac927x_cfg_tbl);
+ again:
+	if (spec->board_config < 0) {
                 snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC927x, using BIOS defaults\n");
-	else if (stac927x_brd_tbl[spec->board_config] != NULL) {
-		spec->num_pins = 14;
-		spec->pin_nids = stac927x_pin_nids;
+		err = stac92xx_save_bios_config_regs(codec);
+		if (err < 0) {
+			stac92xx_free(codec);
+			return err;
+		}
+		spec->pin_configs = spec->bios_pin_configs;
+	} else if (stac927x_brd_tbl[spec->board_config] != NULL) {
 		spec->pin_configs = stac927x_brd_tbl[spec->board_config];
 		stac92xx_set_config_regs(codec);
 	}
@@ -1501,6 +1993,7 @@
 		spec->adc_nids = stac927x_adc_nids;
 		spec->mux_nids = stac927x_mux_nids;
 		spec->num_muxes = 3;
+		spec->num_dmics = 0;
 		spec->init = d965_core_init;
 		spec->mixer = stac9227_mixer;
 		break;
@@ -1508,6 +2001,7 @@
 		spec->adc_nids = stac927x_adc_nids;
 		spec->mux_nids = stac927x_mux_nids;
 		spec->num_muxes = 3;
+		spec->num_dmics = 0;
 		spec->init = d965_core_init;
 		spec->mixer = stac9227_mixer;
 		break;
@@ -1515,6 +2009,7 @@
 		spec->adc_nids = stac927x_adc_nids;
 		spec->mux_nids = stac927x_mux_nids;
 		spec->num_muxes = 3;
+		spec->num_dmics = 0;
 		spec->init = stac927x_core_init;
 		spec->mixer = stac927x_mixer;
 	}
@@ -1522,6 +2017,15 @@
 	spec->multiout.dac_nids = spec->dac_nids;
 
 	err = stac92xx_parse_auto_config(codec, 0x1e, 0x20);
+	if (!err) {
+		if (spec->board_config < 0) {
+			printk(KERN_WARNING "hda_codec: No auto-config is "
+			       "available, default to model=ref\n");
+			spec->board_config = STAC_D965_REF;
+			goto again;
+		}
+		err = -EINVAL;
+	}
 	if (err < 0) {
 		stac92xx_free(codec);
 		return err;
@@ -1542,35 +2046,59 @@
 		return -ENOMEM;
 
 	codec->spec = spec;
-	spec->board_config = snd_hda_check_board_config(codec, stac9205_cfg_tbl);
-	if (spec->board_config < 0)
-                snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC9205, using BIOS defaults\n");
-	else {
-		spec->num_pins = 14;
-		spec->pin_nids = stac9205_pin_nids;
+	spec->num_pins = 14;
+	spec->pin_nids = stac9205_pin_nids;
+	spec->board_config = snd_hda_check_board_config(codec, STAC_9205_MODELS,
+							stac9205_models,
+							stac9205_cfg_tbl);
+ again:
+	if (spec->board_config < 0) {
+		snd_printdd(KERN_INFO "hda_codec: Unknown model for STAC9205, using BIOS defaults\n");
+		err = stac92xx_save_bios_config_regs(codec);
+		if (err < 0) {
+			stac92xx_free(codec);
+			return err;
+		}
+		spec->pin_configs = spec->bios_pin_configs;
+	} else {
 		spec->pin_configs = stac9205_brd_tbl[spec->board_config];
 		stac92xx_set_config_regs(codec);
 	}
 
 	spec->adc_nids = stac9205_adc_nids;
 	spec->mux_nids = stac9205_mux_nids;
-	spec->num_muxes = 3;
+	spec->num_muxes = 2;
+	spec->dmic_nids = stac9205_dmic_nids;
+	spec->num_dmics = 2;
+	spec->dmux_nid = 0x1d;
 
 	spec->init = stac9205_core_init;
 	spec->mixer = stac9205_mixer;
 
 	spec->multiout.dac_nids = spec->dac_nids;
 
-	/* Configure GPIO0 as output */
-	snd_hda_codec_write(codec, codec->afg, 0, AC_VERB_SET_GPIO_DIRECTION, 0x00000001);
+	/* Configure GPIO0 as EAPD output */
+	snd_hda_codec_write(codec, codec->afg, 0,
+			    AC_VERB_SET_GPIO_DIRECTION, 0x00000001);
 	/* Configure GPIO0 as CMOS */
 	snd_hda_codec_write(codec, codec->afg, 0, 0x7e7, 0x00000000);
 	/* Assert GPIO0 high */
-	snd_hda_codec_write(codec, codec->afg, 0, AC_VERB_SET_GPIO_DATA, 0x00000001);
+	snd_hda_codec_write(codec, codec->afg, 0,
+			    AC_VERB_SET_GPIO_DATA, 0x00000001);
 	/* Enable GPIO0 */
-	snd_hda_codec_write(codec, codec->afg, 0, AC_VERB_SET_GPIO_MASK, 0x00000001);
+	snd_hda_codec_write(codec, codec->afg, 0,
+			    AC_VERB_SET_GPIO_MASK, 0x00000001);
 
 	err = stac92xx_parse_auto_config(codec, 0x1f, 0x20);
+	if (!err) {
+		if (spec->board_config < 0) {
+			printk(KERN_WARNING "hda_codec: No auto-config is "
+			       "available, default to model=ref\n");
+			spec->board_config = STAC_9205_REF;
+			goto again;
+		}
+		err = -EINVAL;
+	}
 	if (err < 0) {
 		stac92xx_free(codec);
 		return err;
@@ -1582,7 +2110,7 @@
 }
 
 /*
- * STAC 7661(?) and 7664 hack
+ * STAC9872 hack
  */
 
 /* static config for Sony VAIO FE550G and Sony VAIO AR */
@@ -1616,6 +2144,23 @@
 	{}
 };
 
+static struct hda_verb vaio_ar_init[] = {
+	{0x0a, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP }, /* HP <- 0x2 */
+	{0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT }, /* Speaker <- 0x5 */
+	{0x0d, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80 }, /* Mic? (<- 0x2) */
+	{0x0e, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_IN }, /* CD */
+/*	{0x11, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT },*/ /* Optical Out */
+	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80 }, /* Mic? */
+	{0x15, AC_VERB_SET_CONNECT_SEL, 0x2}, /* mic-sel: 0a,0d,14,02 */
+	{0x02, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE}, /* HP */
+	{0x05, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE}, /* Speaker */
+/*	{0x10, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},*/ /* Optical Out */
+	{0x09, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_MUTE(0)}, /* capture sw/vol -> 0x8 */
+	{0x07, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)}, /* CD-in -> 0x6 */
+	{0x15, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE}, /* Mic-in -> 0x9 */
+	{}
+};
+
 /* bind volumes of both NID 0x02 and 0x05 */
 static int vaio_master_vol_put(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
@@ -1661,9 +2206,7 @@
 		.info = snd_hda_mixer_amp_volume_info,
 		.get = snd_hda_mixer_amp_volume_get,
 		.put = vaio_master_vol_put,
-#if 0
 		.tlv = { .c = snd_hda_mixer_amp_tlv },
-#endif
 		.private_value = HDA_COMPOSE_AMP_VAL(0x02, 3, 0, HDA_OUTPUT),
 	},
 	{
@@ -1688,7 +2231,40 @@
 	{}
 };
 
-static struct hda_codec_ops stac766x_patch_ops = {
+static struct snd_kcontrol_new vaio_ar_mixer[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Volume",
+		.info = snd_hda_mixer_amp_volume_info,
+		.get = snd_hda_mixer_amp_volume_get,
+		.put = vaio_master_vol_put,
+		.private_value = HDA_COMPOSE_AMP_VAL(0x02, 3, 0, HDA_OUTPUT),
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = snd_hda_mixer_amp_switch_info,
+		.get = snd_hda_mixer_amp_switch_get,
+		.put = vaio_master_sw_put,
+		.private_value = HDA_COMPOSE_AMP_VAL(0x02, 3, 0, HDA_OUTPUT),
+	},
+	/* HDA_CODEC_VOLUME("CD Capture Volume", 0x07, 0, HDA_INPUT), */
+	HDA_CODEC_VOLUME("Capture Volume", 0x09, 0, HDA_INPUT),
+	HDA_CODEC_MUTE("Capture Switch", 0x09, 0, HDA_INPUT),
+	/*HDA_CODEC_MUTE("Optical Out Switch", 0x10, 0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Optical Out Volume", 0x10, 0, HDA_OUTPUT),*/
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.count = 1,
+		.info = stac92xx_mux_enum_info,
+		.get = stac92xx_mux_enum_get,
+		.put = stac92xx_mux_enum_put,
+	},
+	{}
+};
+
+static struct hda_codec_ops stac9872_patch_ops = {
 	.build_controls = stac92xx_build_controls,
 	.build_pcms = stac92xx_build_pcms,
 	.init = stac92xx_init,
@@ -1698,25 +2274,37 @@
 #endif
 };
 
-enum { STAC766x_VAIO };
-
-static struct hda_board_config stac766x_cfg_tbl[] = {
-	{ .modelname = "vaio", .config = STAC766x_VAIO },
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81e6,
-	  .config = STAC766x_VAIO },
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81ef,
-	  .config = STAC766x_VAIO },
-	{ .pci_subvendor = 0x104d, .pci_subdevice = 0x81fd,
-	  .config = STAC766x_VAIO },
+enum { /* FE and SZ series. id=0x83847661 and subsys=0x104D0700 or 104D1000. */
+       CXD9872RD_VAIO,
+       /* Unknown. id=0x83847662 and subsys=0x104D1200 or 104D1000. */
+       STAC9872AK_VAIO, 
+       /* Unknown. id=0x83847661 and subsys=0x104D1200. */
+       STAC9872K_VAIO,
+       /* AR Series. id=0x83847664 and subsys=104D1300 */
+       CXD9872AKD_VAIO,
+       STAC_9872_MODELS,
+};
+
+static const char *stac9872_models[STAC_9872_MODELS] = {
+	[CXD9872RD_VAIO]	= "vaio",
+	[CXD9872AKD_VAIO]	= "vaio-ar",
+};
+
+static struct snd_pci_quirk stac9872_cfg_tbl[] = {
+	SND_PCI_QUIRK(0x104d, 0x81e6, "Sony VAIO F/S", CXD9872RD_VAIO),
+	SND_PCI_QUIRK(0x104d, 0x81ef, "Sony VAIO F/S", CXD9872RD_VAIO),
+	SND_PCI_QUIRK(0x104d, 0x81fd, "Sony VAIO AR", CXD9872AKD_VAIO),
 	{}
 };
 
-static int patch_stac766x(struct hda_codec *codec)
+static int patch_stac9872(struct hda_codec *codec)
 {
 	struct sigmatel_spec *spec;
 	int board_config;
 
-	board_config = snd_hda_check_board_config(codec, stac766x_cfg_tbl);
+	board_config = snd_hda_check_board_config(codec, STAC_9872_MODELS,
+						  stac9872_models,
+						  stac9872_cfg_tbl);
 	if (board_config < 0)
 		/* unknown config, let generic-parser do its job... */
 		return snd_hda_parse_generic_codec(codec);
@@ -1727,7 +2315,9 @@
 
 	codec->spec = spec;
 	switch (board_config) {
-	case STAC766x_VAIO:
+	case CXD9872RD_VAIO:
+	case STAC9872AK_VAIO:
+	case STAC9872K_VAIO:
 		spec->mixer = vaio_mixer;
 		spec->init = vaio_init;
 		spec->multiout.max_channels = 2;
@@ -1739,9 +2329,22 @@
 		spec->input_mux = &vaio_mux;
 		spec->mux_nids = vaio_mux_nids;
 		break;
+	
+	case CXD9872AKD_VAIO:
+		spec->mixer = vaio_ar_mixer;
+		spec->init = vaio_ar_init;
+		spec->multiout.max_channels = 2;
+		spec->multiout.num_dacs = ARRAY_SIZE(vaio_dacs);
+		spec->multiout.dac_nids = vaio_dacs;
+		spec->multiout.hp_nid = VAIO_HP_DAC;
+		spec->num_adcs = ARRAY_SIZE(vaio_adcs);
+		spec->adc_nids = vaio_adcs;
+		spec->input_mux = &vaio_mux;
+		spec->mux_nids = vaio_mux_nids;
+		break;
 	}
 
-	codec->patch_ops = stac766x_patch_ops;
+	codec->patch_ops = stac9872_patch_ops;
 	return 0;
 }
 
@@ -1773,7 +2376,19 @@
  	{ .id = 0x83847627, .name = "STAC9271D", .patch = patch_stac927x },
  	{ .id = 0x83847628, .name = "STAC9274X5NH", .patch = patch_stac927x },
  	{ .id = 0x83847629, .name = "STAC9274D5NH", .patch = patch_stac927x },
- 	{ .id = 0x83847661, .name = "STAC7661", .patch = patch_stac766x },
+	{ .id = 0x83847632, .name = "STAC9202",  .patch = patch_stac925x },
+	{ .id = 0x83847633, .name = "STAC9202D", .patch = patch_stac925x },
+	{ .id = 0x83847634, .name = "STAC9250", .patch = patch_stac925x },
+	{ .id = 0x83847635, .name = "STAC9250D", .patch = patch_stac925x },
+	{ .id = 0x83847636, .name = "STAC9251", .patch = patch_stac925x },
+	{ .id = 0x83847637, .name = "STAC9250D", .patch = patch_stac925x },
+ 	/* The following does not take into account .id=0x83847661 when subsys =
+ 	 * 104D0C00 which is STAC9225s. Because of this, some SZ Notebooks are
+ 	 * currently not fully supported.
+ 	 */
+ 	{ .id = 0x83847661, .name = "CXD9872RD/K", .patch = patch_stac9872 },
+ 	{ .id = 0x83847662, .name = "STAC9872AK", .patch = patch_stac9872 },
+ 	{ .id = 0x83847664, .name = "CXD9872AKD", .patch = patch_stac9872 },
  	{ .id = 0x838476a0, .name = "STAC9205", .patch = patch_stac9205 },
  	{ .id = 0x838476a1, .name = "STAC9205D", .patch = patch_stac9205 },
  	{ .id = 0x838476a2, .name = "STAC9204", .patch = patch_stac9205 },
@@ -1782,6 +2397,5 @@
  	{ .id = 0x838476a5, .name = "STAC9255D", .patch = patch_stac9205 },
  	{ .id = 0x838476a6, .name = "STAC9254", .patch = patch_stac9205 },
  	{ .id = 0x838476a7, .name = "STAC9254D", .patch = patch_stac9205 },
- 	{ .id = 0x83847664, .name = "STAC7664", .patch = patch_stac766x },
 	{} /* terminator */
 };
--- linux-2.6.18.noarch/sound/pci/hda/hda_codec.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/hda/hda_codec.h	2007-06-05 17:46:40.000000000 -0400
@@ -479,7 +479,7 @@
 struct hda_amp_info {
 	u32 key;		/* hash key */
 	u32 amp_caps;		/* amp capabilities */
-	u16 vol[2];		/* current volume & mute*/
+	u16 vol[2];		/* current volume & mute */
 	u16 status;		/* update flag */
 	u16 next;		/* next link */
 };
--- linux-2.6.18.noarch/sound/pci/mixart/mixart.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/mixart/mixart.c	2007-06-05 17:47:17.000000000 -0400
@@ -472,7 +472,7 @@
 	struct snd_mixart *chip = snd_pcm_substream_chip(subs);
 	struct mixart_stream *stream = subs->runtime->private_data;
 
-	/* TODO de faon non bloquante, rappliquer les hw_params (rate, bits, codec) */
+	/* TODO de faon non bloquante, rappliquer les hw_params (rate, bits, codec) */
 
 	snd_printdd("snd_mixart_prepare\n");
 
@@ -1066,7 +1066,7 @@
 
 	/* release irq  */
 	if (mgr->irq >= 0)
-		free_irq(mgr->irq, (void *)mgr);
+		free_irq(mgr->irq, mgr);
 
 	/* reset board if some firmware was loaded */
 	if(mgr->dsp_loaded) {
@@ -1109,13 +1109,13 @@
 	offset = offset & ~3; /* 4 bytes aligned */
 
 	switch(orig) {
-	case 0:  /* SEEK_SET */
+	case SEEK_SET:
 		file->f_pos = offset;
 		break;
-	case 1:  /* SEEK_CUR */
+	case SEEK_CUR:
 		file->f_pos += offset;
 		break;
-	case 2:  /* SEEK_END, offset is negative */
+	case SEEK_END: /* offset is negative */
 		file->f_pos = MIXART_BA0_SIZE + offset;
 		break;
 	default:
@@ -1135,13 +1135,13 @@
 	offset = offset & ~3; /* 4 bytes aligned */
 
 	switch(orig) {
-	case 0:  /* SEEK_SET */
+	case SEEK_SET:
 		file->f_pos = offset;
 		break;
-	case 1:  /* SEEK_CUR */
+	case SEEK_CUR:
 		file->f_pos += offset;
 		break;
-	case 2: /* SEEK_END, offset is negative */
+	case SEEK_END: /* offset is negative */
 		file->f_pos = MIXART_BA1_SIZE + offset;
 		break;
 	default:
--- linux-2.6.18.noarch/sound/pci/mixart/mixart_mixer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/mixart/mixart_mixer.c	2007-06-05 17:47:17.000000000 -0400
@@ -31,6 +31,7 @@
 #include "mixart_core.h"
 #include "mixart_hwdep.h"
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include "mixart_mixer.h"
 
 static u32 mixart_analog_level[256] = {
@@ -388,12 +389,17 @@
 	return changed;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_analog, -9600, 50, 0);
+
 static struct snd_kcontrol_new mixart_control_analog_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	/* name will be filled later */
 	.info =		mixart_analog_vol_info,
 	.get =		mixart_analog_vol_get,
 	.put =		mixart_analog_vol_put,
+	.tlv = { .p = db_scale_analog },
 };
 
 /* shared */
@@ -866,14 +872,19 @@
 	return changed;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_digital, -10950, 50, 0);
+
 static struct snd_kcontrol_new snd_mixart_pcm_vol =
 {
 	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	/* name will be filled later */
 	/* count will be filled later */
 	.info =         mixart_digital_vol_info,		/* shared */
 	.get =          mixart_pcm_vol_get,
 	.put =          mixart_pcm_vol_put,
+	.tlv = { .p = db_scale_digital },
 };
 
 
@@ -984,10 +995,13 @@
 
 static struct snd_kcontrol_new mixart_control_monitor_vol = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =         "Monitoring Volume",
 	.info =		mixart_digital_vol_info,		/* shared */
 	.get =		mixart_monitor_vol_get,
 	.put =		mixart_monitor_vol_put,
+	.tlv = { .p = db_scale_digital },
 };
 
 /*
--- linux-2.6.18.noarch/sound/pci/ymfpci/ymfpci_main.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ymfpci/ymfpci_main.c	2007-06-05 17:48:14.000000000 -0400
@@ -2,12 +2,6 @@
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
  *  Routines for control of YMF724/740/744/754 chips
  *
- *  BUGS:
- *    --
- *
- *  TODO:
- *    --
- *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
  *   the Free Software Foundation; either version 2 of the License, or
@@ -26,6 +20,7 @@
 
 #include <sound/driver.h>
 #include <linux/delay.h>
+#include <linux/firmware.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
@@ -36,15 +31,13 @@
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/info.h>
+#include <sound/tlv.h>
 #include <sound/ymfpci.h>
 #include <sound/asoundef.h>
 #include <sound/mpu401.h>
 
 #include <asm/io.h>
-
-/*
- *  constants
- */
+#include <asm/byteorder.h>
 
 /*
  *  common I/O routines
@@ -178,6 +171,17 @@
 	return val[0];
 }
 
+static void snd_ymfpci_pcm_441_volume_set(struct snd_ymfpci_pcm *ypcm)
+{
+	unsigned int value;
+	struct snd_ymfpci_pcm_mixer *mixer;
+	
+	mixer = &ypcm->chip->pcm_mixer[ypcm->substream->number];
+	value = min_t(unsigned int, mixer->left, 0x7fff) >> 1;
+	value |= (min_t(unsigned int, mixer->right, 0x7fff) >> 1) << 16;
+	snd_ymfpci_writel(ypcm->chip, YDSXGR_BUF441OUTVOL, value);
+}
+
 /*
  *  Hardware start management
  */
@@ -289,6 +293,10 @@
 	snd_assert(pvoice != NULL, return -EINVAL);
 	snd_ymfpci_hw_stop(chip);
 	spin_lock_irqsave(&chip->voice_lock, flags);
+	if (pvoice->number == chip->src441_used) {
+		chip->src441_used = -1;
+		pvoice->ypcm->use_441_slot = 0;
+	}
 	pvoice->use = pvoice->pcm = pvoice->synth = pvoice->midi = 0;
 	pvoice->ypcm = NULL;
 	pvoice->interrupt = NULL;
@@ -393,7 +401,7 @@
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_RESUME:
 		chip->ctrl_playback[ypcm->voices[0]->number + 1] = cpu_to_le32(ypcm->voices[0]->bank_addr);
-		if (ypcm->voices[1] != NULL)
+		if (ypcm->voices[1] != NULL && !ypcm->use_441_slot)
 			chip->ctrl_playback[ypcm->voices[1]->number + 1] = cpu_to_le32(ypcm->voices[1]->bank_addr);
 		ypcm->running = 1;
 		break;
@@ -401,7 +409,7 @@
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		chip->ctrl_playback[ypcm->voices[0]->number + 1] = 0;
-		if (ypcm->voices[1] != NULL)
+		if (ypcm->voices[1] != NULL && !ypcm->use_441_slot)
 			chip->ctrl_playback[ypcm->voices[1]->number + 1] = 0;
 		ypcm->running = 0;
 		break;
@@ -488,6 +496,7 @@
 	unsigned int nbank;
 	u32 vol_left, vol_right;
 	u8 use_left, use_right;
+	unsigned long flags;
 
 	snd_assert(voice != NULL, return);
 	if (runtime->channels == 1) {
@@ -506,11 +515,27 @@
 		vol_left = cpu_to_le32(0x40000000);
 		vol_right = cpu_to_le32(0x40000000);
 	}
+	spin_lock_irqsave(&ypcm->chip->voice_lock, flags);
 	format = runtime->channels == 2 ? 0x00010000 : 0;
 	if (snd_pcm_format_width(runtime->format) == 8)
 		format |= 0x80000000;
+	else if (ypcm->chip->device_id == PCI_DEVICE_ID_YAMAHA_754 &&
+		 runtime->rate == 44100 && runtime->channels == 2 &&
+		 voiceidx == 0 && (ypcm->chip->src441_used == -1 ||
+				   ypcm->chip->src441_used == voice->number)) {
+		ypcm->chip->src441_used = voice->number;
+		ypcm->use_441_slot = 1;
+		format |= 0x10000000;
+		snd_ymfpci_pcm_441_volume_set(ypcm);
+	}
+	if (ypcm->chip->src441_used == voice->number &&
+	    (format & 0x10000000) == 0) {
+		ypcm->chip->src441_used = -1;
+		ypcm->use_441_slot = 0;
+	}
 	if (runtime->channels == 2 && (voiceidx & 1) != 0)
 		format |= 1;
+	spin_unlock_irqrestore(&ypcm->chip->voice_lock, flags);
 	for (nbank = 0; nbank < 2; nbank++) {
 		bank = &voice->bank[nbank];
 		memset(bank, 0, sizeof(*bank));
@@ -909,7 +934,7 @@
 	ypcm = runtime->private_data;
 	ypcm->output_front = 1;
 	ypcm->output_rear = chip->mode_dup4ch ? 1 : 0;
-	ypcm->swap_rear = chip->rear_swap;
+	ypcm->swap_rear = 0;
 	spin_lock_irq(&chip->reg_lock);
 	if (ypcm->output_rear) {
 		ymfpci_open_extension(chip);
@@ -935,6 +960,7 @@
 	ypcm = runtime->private_data;
 	ypcm->output_front = 0;
 	ypcm->output_rear = 1;
+	ypcm->swap_rear = 1;
 	spin_lock_irq(&chip->reg_lock);
 	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,
 			  snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) | 2);
@@ -962,6 +988,7 @@
 	ypcm = runtime->private_data;
 	ypcm->output_front = 0;
 	ypcm->output_rear = 1;
+	ypcm->swap_rear = 0;
 	spin_lock_irq(&chip->reg_lock);
 	ymfpci_open_extension(chip);
 	chip->rear_opened++;
@@ -1477,11 +1504,15 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_LINEAR(db_scale_native, TLV_DB_GAIN_MUTE, 0);
+
 #define YMFPCI_DOUBLE(xname, xindex, reg) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
   .info = snd_ymfpci_info_double, \
   .get = snd_ymfpci_get_double, .put = snd_ymfpci_put_double, \
-  .private_value = reg }
+  .private_value = reg, \
+  .tlv = { .p = db_scale_native } }
 
 static int snd_ymfpci_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -1715,7 +1746,10 @@
 		spin_lock_irqsave(&chip->voice_lock, flags);
 		if (substream->runtime && substream->runtime->private_data) {
 			struct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;
-			ypcm->update_pcm_vol = 2;
+			if (!ypcm->use_441_slot)
+				ypcm->update_pcm_vol = 2;
+			else
+				snd_ymfpci_pcm_441_volume_set(ypcm);
 		}
 		spin_unlock_irqrestore(&chip->voice_lock, flags);
 		return 1;
@@ -1750,7 +1784,7 @@
 	chip->ac97 = NULL;
 }
 
-int __devinit snd_ymfpci_mixer(struct snd_ymfpci *chip, int rear_switch, int rear_swap)
+int __devinit snd_ymfpci_mixer(struct snd_ymfpci *chip, int rear_switch)
 {
 	struct snd_ac97_template ac97;
 	struct snd_kcontrol *kctl;
@@ -1762,7 +1796,6 @@
 		.read = snd_ymfpci_codec_read,
 	};
 
-	chip->rear_swap = rear_swap;
 	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
 		return err;
 	chip->ac97_bus->private_free = snd_ymfpci_mixer_free_ac97_bus;
@@ -1965,13 +1998,94 @@
 	}
 }
 
+#define FIRMWARE_IN_THE_KERNEL
+
+#ifdef FIRMWARE_IN_THE_KERNEL
+
 #include "ymfpci_image.h"
 
+static struct firmware snd_ymfpci_dsp_microcode = {
+	.size = YDSXG_DSPLENGTH,
+	.data = (u8 *)DspInst,
+};
+static struct firmware snd_ymfpci_controller_microcode = {
+	.size = YDSXG_CTRLLENGTH,
+	.data = (u8 *)CntrlInst,
+};
+static struct firmware snd_ymfpci_controller_1e_microcode = {
+	.size = YDSXG_CTRLLENGTH,
+	.data = (u8 *)CntrlInst1E,
+};
+#endif
+
+#ifdef __LITTLE_ENDIAN
+static inline void snd_ymfpci_convert_from_le(const struct firmware *fw) { }
+#else
+static void snd_ymfpci_convert_from_le(const struct firmware *fw)
+{
+	int i;
+	u32 *data = (u32 *)fw->data;
+
+	for (i = 0; i < fw->size / 4; ++i)
+		le32_to_cpus(&data[i]);
+}
+#endif
+
+static int snd_ymfpci_request_firmware(struct snd_ymfpci *chip)
+{
+	int err, is_1e;
+	const char *name;
+
+	err = request_firmware(&chip->dsp_microcode, "yamaha/ds1_dsp.fw",
+			       &chip->pci->dev);
+	if (err >= 0) {
+		if (chip->dsp_microcode->size == YDSXG_DSPLENGTH)
+			snd_ymfpci_convert_from_le(chip->dsp_microcode);
+		else {
+			snd_printk(KERN_ERR "DSP microcode has wrong size\n");
+			err = -EINVAL;
+		}
+	}
+	if (err < 0) {
+#ifdef FIRMWARE_IN_THE_KERNEL
+		chip->dsp_microcode = &snd_ymfpci_dsp_microcode;
+#else
+		return err;
+#endif
+	}
+	is_1e = chip->device_id == PCI_DEVICE_ID_YAMAHA_724F ||
+		chip->device_id == PCI_DEVICE_ID_YAMAHA_740C ||
+		chip->device_id == PCI_DEVICE_ID_YAMAHA_744 ||
+		chip->device_id == PCI_DEVICE_ID_YAMAHA_754;
+	name = is_1e ? "yamaha/ds1e_ctrl.fw" : "yamaha/ds1_ctrl.fw";
+	err = request_firmware(&chip->controller_microcode, name,
+			       &chip->pci->dev);
+	if (err >= 0) {
+		if (chip->controller_microcode->size == YDSXG_CTRLLENGTH)
+			snd_ymfpci_convert_from_le(chip->controller_microcode);
+		else {
+			snd_printk(KERN_ERR "controller microcode"
+				   " has wrong size\n");
+			err = -EINVAL;
+		}
+	}
+	if (err < 0) {
+#ifdef FIRMWARE_IN_THE_KERNEL
+		chip->controller_microcode =
+			is_1e ? &snd_ymfpci_controller_1e_microcode
+			      : &snd_ymfpci_controller_microcode;
+#else
+		return err;
+#endif
+	}
+	return 0;
+}
+
 static void snd_ymfpci_download_image(struct snd_ymfpci *chip)
 {
 	int i;
 	u16 ctrl;
-	unsigned long *inst;
+	u32 *inst;
 
 	snd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0x00000000);
 	snd_ymfpci_disable_dsp(chip);
@@ -1986,21 +2100,12 @@
 	snd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);
 
 	/* setup DSP instruction code */
+	inst = (u32 *)chip->dsp_microcode->data;
 	for (i = 0; i < YDSXG_DSPLENGTH / 4; i++)
-		snd_ymfpci_writel(chip, YDSXGR_DSPINSTRAM + (i << 2), DspInst[i]);
+		snd_ymfpci_writel(chip, YDSXGR_DSPINSTRAM + (i << 2), inst[i]);
 
 	/* setup control instruction code */
-	switch (chip->device_id) {
-	case PCI_DEVICE_ID_YAMAHA_724F:
-	case PCI_DEVICE_ID_YAMAHA_740C:
-	case PCI_DEVICE_ID_YAMAHA_744:
-	case PCI_DEVICE_ID_YAMAHA_754:
-		inst = CntrlInst1E;
-		break;
-	default:
-		inst = CntrlInst;
-		break;
-	}
+	inst = (u32 *)chip->controller_microcode->data;
 	for (i = 0; i < YDSXG_CTRLLENGTH / 4; i++)
 		snd_ymfpci_writel(chip, YDSXGR_CTRLINSTRAM + (i << 2), inst[i]);
 
@@ -2020,10 +2125,10 @@
 	chip->bank_size_effect = snd_ymfpci_readl(chip, YDSXGR_EFFCTRLSIZE) << 2;
 	chip->work_size = YDSXG_DEFAULT_WORK_SIZE;
 	
-	size = ((playback_ctrl_size + 0x00ff) & ~0x00ff) +
-	       ((chip->bank_size_playback * 2 * YDSXG_PLAYBACK_VOICES + 0x00ff) & ~0x00ff) +
-	       ((chip->bank_size_capture * 2 * YDSXG_CAPTURE_VOICES + 0x00ff) & ~0x00ff) +
-	       ((chip->bank_size_effect * 2 * YDSXG_EFFECT_VOICES + 0x00ff) & ~0x00ff) +
+	size = ALIGN(playback_ctrl_size, 0x100) +
+	       ALIGN(chip->bank_size_playback * 2 * YDSXG_PLAYBACK_VOICES, 0x100) +
+	       ALIGN(chip->bank_size_capture * 2 * YDSXG_CAPTURE_VOICES, 0x100) +
+	       ALIGN(chip->bank_size_effect * 2 * YDSXG_EFFECT_VOICES, 0x100) +
 	       chip->work_size;
 	/* work_ptr must be aligned to 256 bytes, but it's already
 	   covered with the kernel page allocation mechanism */
@@ -2038,8 +2143,8 @@
 	chip->bank_base_playback_addr = ptr_addr;
 	chip->ctrl_playback = (u32 *)ptr;
 	chip->ctrl_playback[0] = cpu_to_le32(YDSXG_PLAYBACK_VOICES);
-	ptr += (playback_ctrl_size + 0x00ff) & ~0x00ff;
-	ptr_addr += (playback_ctrl_size + 0x00ff) & ~0x00ff;
+	ptr += ALIGN(playback_ctrl_size, 0x100);
+	ptr_addr += ALIGN(playback_ctrl_size, 0x100);
 	for (voice = 0; voice < YDSXG_PLAYBACK_VOICES; voice++) {
 		chip->voices[voice].number = voice;
 		chip->voices[voice].bank = (struct snd_ymfpci_playback_bank *)ptr;
@@ -2050,8 +2155,8 @@
 			ptr_addr += chip->bank_size_playback;
 		}
 	}
-	ptr = (char *)(((unsigned long)ptr + 0x00ff) & ~0x00ff);
-	ptr_addr = (ptr_addr + 0x00ff) & ~0x00ff;
+	ptr = (char *)ALIGN((unsigned long)ptr, 0x100);
+	ptr_addr = ALIGN(ptr_addr, 0x100);
 	chip->bank_base_capture = ptr;
 	chip->bank_base_capture_addr = ptr_addr;
 	for (voice = 0; voice < YDSXG_CAPTURE_VOICES; voice++)
@@ -2060,8 +2165,8 @@
 			ptr += chip->bank_size_capture;
 			ptr_addr += chip->bank_size_capture;
 		}
-	ptr = (char *)(((unsigned long)ptr + 0x00ff) & ~0x00ff);
-	ptr_addr = (ptr_addr + 0x00ff) & ~0x00ff;
+	ptr = (char *)ALIGN((unsigned long)ptr, 0x100);
+	ptr_addr = ALIGN(ptr_addr, 0x100);
 	chip->bank_base_effect = ptr;
 	chip->bank_base_effect_addr = ptr_addr;
 	for (voice = 0; voice < YDSXG_EFFECT_VOICES; voice++)
@@ -2070,8 +2175,8 @@
 			ptr += chip->bank_size_effect;
 			ptr_addr += chip->bank_size_effect;
 		}
-	ptr = (char *)(((unsigned long)ptr + 0x00ff) & ~0x00ff);
-	ptr_addr = (ptr_addr + 0x00ff) & ~0x00ff;
+	ptr = (char *)ALIGN((unsigned long)ptr, 0x100);
+	ptr_addr = ALIGN(ptr_addr, 0x100);
 	chip->work_base = ptr;
 	chip->work_base_addr = ptr_addr;
 	
@@ -2148,12 +2253,21 @@
 		snd_dma_free_pages(&chip->work_ptr);
 	
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	release_and_free_resource(chip->res_reg_area);
 
 	pci_write_config_word(chip->pci, 0x40, chip->old_legacy_ctrl);
 	
 	pci_disable_device(chip->pci);
+#ifdef FIRMWARE_IN_THE_KERNEL
+	if (chip->dsp_microcode != &snd_ymfpci_dsp_microcode)
+#endif
+		release_firmware(chip->dsp_microcode);
+#ifdef FIRMWARE_IN_THE_KERNEL
+	if (chip->controller_microcode != &snd_ymfpci_controller_microcode &&
+	    chip->controller_microcode != &snd_ymfpci_controller_1e_microcode)
+#endif
+		release_firmware(chip->controller_microcode);
 	kfree(chip);
 	return 0;
 }
@@ -2174,7 +2288,7 @@
 	YDSXGR_PRIADCLOOPVOL,
 	YDSXGR_NATIVEDACINVOL,
 	YDSXGR_NATIVEDACOUTVOL,
-	// YDSXGR_BUF441OUTVOL,
+	YDSXGR_BUF441OUTVOL,
 	YDSXGR_NATIVEADCINVOL,
 	YDSXGR_SPDIFLOOPVOL,
 	YDSXGR_SPDIFOUTVOL,
@@ -2213,6 +2327,7 @@
 	snd_ymfpci_disable_dsp(chip);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2222,8 +2337,14 @@
 	struct snd_ymfpci *chip = card->private_data;
 	unsigned int i;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "ymfpci: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 	snd_ymfpci_aclink_reset(pci);
 	snd_ymfpci_codec_ready(chip, 0);
@@ -2278,10 +2399,11 @@
 	chip->pci = pci;
 	chip->irq = -1;
 	chip->device_id = pci->device;
-	pci_read_config_byte(pci, PCI_REVISION_ID, (u8 *)&chip->rev);
+	pci_read_config_byte(pci, PCI_REVISION_ID, &chip->rev);
 	chip->reg_area_phys = pci_resource_start(pci, 0);
 	chip->reg_area_virt = ioremap_nocache(chip->reg_area_phys, 0x8000);
 	pci_set_master(pci);
+	chip->src441_used = -1;
 
 	if ((chip->res_reg_area = request_mem_region(chip->reg_area_phys, 0x8000, "YMFPCI")) == NULL) {
 		snd_printk(KERN_ERR "unable to grab memory region 0x%lx-0x%lx\n", chip->reg_area_phys, chip->reg_area_phys + 0x8000 - 1);
@@ -2301,6 +2423,12 @@
 		return -EIO;
 	}
 
+	err = snd_ymfpci_request_firmware(chip);
+	if (err < 0) {
+		snd_printk(KERN_ERR "firmware request failed: %d\n", err);
+		snd_ymfpci_free(chip);
+		return err;
+	}
 	snd_ymfpci_download_image(chip);
 
 	udelay(100); /* seems we need a delay after downloading image.. */
@@ -2310,7 +2438,6 @@
 		return -EIO;
 	}
 
-	chip->rear_swap = 1;
 	if ((err = snd_ymfpci_ac3_init(chip)) < 0) {
 		snd_ymfpci_free(chip);
 		return err;
--- linux-2.6.18.noarch/sound/pci/ymfpci/ymfpci.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ymfpci/ymfpci.c	2007-06-05 17:48:14.000000000 -0400
@@ -49,7 +49,6 @@
 static long joystick_port[SNDRV_CARDS];
 #endif
 static int rear_switch[SNDRV_CARDS];
-static int rear_swap[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 1 };
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the Yamaha DS-1 PCI soundcard.");
@@ -67,8 +66,6 @@
 #endif
 module_param_array(rear_switch, bool, NULL, 0444);
 MODULE_PARM_DESC(rear_switch, "Enable shared rear/line-in switch");
-module_param_array(rear_swap, bool, NULL, 0444);
-MODULE_PARM_DESC(rear_swap, "Swap rear channels (must be enabled for correct IEC958 (S/PDIF)) output");
 
 static struct pci_device_id snd_ymfpci_ids[] = {
         { 0x1073, 0x0004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* YMF724 */
@@ -298,7 +295,7 @@
 		snd_card_free(card);
 		return err;
 	}
-	if ((err = snd_ymfpci_mixer(chip, rear_switch[dev], rear_swap[dev])) < 0) {
+	if ((err = snd_ymfpci_mixer(chip, rear_switch[dev])) < 0) {
 		snd_card_free(card);
 		return err;
 	}
--- linux-2.6.18.noarch/sound/pci/ymfpci/ymfpci_image.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ymfpci/ymfpci_image.h	2007-06-05 17:48:14.000000000 -0400
@@ -1,7 +1,7 @@
 #ifndef _HWMCODE_
 #define _HWMCODE_
 
-static unsigned long DspInst[YDSXG_DSPLENGTH / 4] = {
+static u32 DspInst[YDSXG_DSPLENGTH / 4] = {
 	0x00000081, 0x000001a4, 0x0000000a, 0x0000002f,
 	0x00080253, 0x01800317, 0x0000407b, 0x0000843f,
 	0x0001483c, 0x0001943c, 0x0005d83c, 0x00001c3c,
@@ -12,7 +12,7 @@
 	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
 
-static unsigned long CntrlInst[YDSXG_CTRLLENGTH / 4] = {
+static u32 CntrlInst[YDSXG_CTRLLENGTH / 4] = {
 	0x000007, 0x240007, 0x0C0007, 0x1C0007,
 	0x060007, 0x700002, 0x000020, 0x030040,
 	0x007104, 0x004286, 0x030040, 0x000F0D,
@@ -791,7 +791,7 @@
 // 04/09  creat
 // 04/12  stop nise fix
 // 06/21  WorkingOff timming
-static unsigned long CntrlInst1E[YDSXG_CTRLLENGTH / 4] = {
+static u32 CntrlInst1E[YDSXG_CTRLLENGTH / 4] = {
 	0x000007, 0x240007, 0x0C0007, 0x1C0007,
 	0x060007, 0x700002, 0x000020, 0x030040,
 	0x007104, 0x004286, 0x030040, 0x000F0D,
--- linux-2.6.18.noarch/sound/pci/ice1712/revo.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/revo.h	2007-06-05 17:46:52.000000000 -0400
@@ -26,13 +26,15 @@
 
 #define REVO_DEVICE_DESC \
 		"{MidiMan M Audio,Revolution 7.1},"\
-		"{MidiMan M Audio,Revolution 5.1},"
+		"{MidiMan M Audio,Revolution 5.1},"\
+		"{MidiMan M Audio,Audiophile 192},"
 
 #define VT1724_SUBDEVICE_REVOLUTION71	0x12143036
 #define VT1724_SUBDEVICE_REVOLUTION51	0x12143136
+#define VT1724_SUBDEVICE_AUDIOPHILE192	0x12143236
 
 /* entry point */
-extern struct snd_ice1712_card_info snd_vt1724_revo_cards[];
+extern const struct snd_ice1712_card_info snd_vt1724_revo_cards[];
 
 
 /*
@@ -42,9 +44,12 @@
 #define VT1724_REVO_CCLK	0x02
 #define VT1724_REVO_CDIN	0x04	/* not used */
 #define VT1724_REVO_CDOUT	0x08
-#define VT1724_REVO_CS0		0x10	/* not used */
+#define VT1724_REVO_CS0		0x10	/* AK5365 chipselect for (revo51) */
 #define VT1724_REVO_CS1		0x20	/* front AKM4381 chipselect */
-#define VT1724_REVO_CS2		0x40	/* surround AKM4355 chipselect */
+#define VT1724_REVO_CS2		0x40	/* surround AKM4355 CS (revo71) */
+#define VT1724_REVO_I2C_DATA    0x40    /* I2C: PT 2258 SDA (on revo51) */
+#define VT1724_REVO_I2C_CLOCK   0x80    /* I2C: PT 2258 SCL (on revo51) */
+#define VT1724_REVO_CS3		0x80	/* AK4114 for AP192 */
 #define VT1724_REVO_MUTE	(1<<22)	/* 0 = all mute, 1 = normal operation */
 
 #endif /* __SOUND_REVO_H */
--- linux-2.6.18.noarch/sound/pci/ice1712/ice1712.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/ice1712.c	2007-06-05 17:46:52.000000000 -0400
@@ -62,6 +62,7 @@
 #include <sound/cs8427.h>
 #include <sound/info.h>
 #include <sound/initval.h>
+#include <sound/tlv.h>
 
 #include <sound/asoundef.h>
 
@@ -106,7 +107,7 @@
 MODULE_PARM_DESC(dxr_enable, "Enable DXR support for Terratec DMX6FIRE.");
 
 
-static struct pci_device_id snd_ice1712_ids[] = {
+static const struct pci_device_id snd_ice1712_ids[] = {
 	{ PCI_VENDOR_ID_ICE, PCI_DEVICE_ID_ICE_1712, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },   /* ICE1712 */
 	{ 0, }
 };
@@ -286,7 +287,7 @@
 	return val != nval;
 }
 
-static struct snd_kcontrol_new snd_ice1712_mixer_digmix_route_ac97 __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_mixer_digmix_route_ac97 __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Digital Mixer To AC97",
 	.info = snd_ice1712_digmix_route_ac97_info,
@@ -718,7 +719,7 @@
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static struct snd_pcm_hardware snd_ice1712_playback =
+static const struct snd_pcm_hardware snd_ice1712_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -738,7 +739,7 @@
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_ice1712_playback_ds =
+static const struct snd_pcm_hardware snd_ice1712_playback_ds =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -758,7 +759,7 @@
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_ice1712_capture =
+static const struct snd_pcm_hardware snd_ice1712_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1132,7 +1133,7 @@
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static struct snd_pcm_hardware snd_ice1712_playback_pro =
+static const struct snd_pcm_hardware snd_ice1712_playback_pro =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1152,7 +1153,7 @@
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_ice1712_capture_pro =
+static const struct snd_pcm_hardware snd_ice1712_capture_pro =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1377,8 +1378,9 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_playback, -14400, 150, 0);
 
-static struct snd_kcontrol_new snd_ice1712_multi_playback_ctrls[] __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_multi_playback_ctrls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Multi Playback Switch",
@@ -1390,16 +1392,19 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Multi Playback Volume",
 		.info = snd_ice1712_pro_mixer_volume_info,
 		.get = snd_ice1712_pro_mixer_volume_get,
 		.put = snd_ice1712_pro_mixer_volume_put,
 		.private_value = 0,
 		.count = 10,
+		.tlv = { .p = db_scale_playback }
 	},
 };
 
-static struct snd_kcontrol_new snd_ice1712_multi_capture_analog_switch __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_multi_capture_analog_switch __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "H/W Multi Capture Switch",
 	.info = snd_ice1712_pro_mixer_switch_info,
@@ -1408,7 +1413,7 @@
 	.private_value = 10,
 };
 
-static struct snd_kcontrol_new snd_ice1712_multi_capture_spdif_switch __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_multi_capture_spdif_switch __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = SNDRV_CTL_NAME_IEC958("Multi ",CAPTURE,SWITCH),
 	.info = snd_ice1712_pro_mixer_switch_info,
@@ -1418,16 +1423,19 @@
 	.count = 2,
 };
 
-static struct snd_kcontrol_new snd_ice1712_multi_capture_analog_volume __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_multi_capture_analog_volume __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name = "H/W Multi Capture Volume",
 	.info = snd_ice1712_pro_mixer_volume_info,
 	.get = snd_ice1712_pro_mixer_volume_get,
 	.put = snd_ice1712_pro_mixer_volume_put,
 	.private_value = 10,
+	.tlv = { .p = db_scale_playback }
 };
 
-static struct snd_kcontrol_new snd_ice1712_multi_capture_spdif_volume __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_multi_capture_spdif_volume __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = SNDRV_CTL_NAME_IEC958("Multi ",CAPTURE,VOLUME),
 	.info = snd_ice1712_pro_mixer_volume_info,
@@ -1619,7 +1627,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_ice1712_eeprom __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_eeprom __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
 	.name = "ICE1712 EEPROM",
 	.access = SNDRV_CTL_ELEM_ACCESS_READ,
@@ -1655,7 +1663,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_ice1712_spdif_default __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_spdif_default __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -1706,7 +1714,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_ice1712_spdif_maskc __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_spdif_maskc __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1715,7 +1723,7 @@
 	.get =		snd_ice1712_spdif_maskc_get,
 };
 
-static struct snd_kcontrol_new snd_ice1712_spdif_maskp __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_spdif_maskp __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1742,7 +1750,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_ice1712_spdif_stream __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_spdif_stream __devinitdata =
 {
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
 			 SNDRV_CTL_ELEM_ACCESS_INACTIVE),
@@ -1803,7 +1811,7 @@
 static int snd_ice1712_pro_internal_clock_info(struct snd_kcontrol *kcontrol,
 					       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {
+	static const char * const texts[] = {
 		"8000",		/* 0: 6 */
 		"9600",		/* 1: 3 */
 		"11025",	/* 2: 10 */
@@ -1832,7 +1840,7 @@
 					      struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
-	static unsigned char xlate[16] = {
+	static const unsigned char xlate[16] = {
 		9, 6, 3, 1, 7, 4, 0, 12, 8, 5, 2, 11, 255, 255, 255, 10
 	};
 	unsigned char val;
@@ -1856,8 +1864,8 @@
 					      struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
-	static unsigned int xrate[13] = {
-		8000, 9600, 11025, 12000, 1600, 22050, 24000,
+	static const unsigned int xrate[13] = {
+		8000, 9600, 11025, 12000, 16000, 22050, 24000,
 		32000, 44100, 48000, 64000, 88200, 96000
 	};
 	unsigned char oval;
@@ -1883,7 +1891,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ice1712_pro_internal_clock __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_pro_internal_clock __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Internal Clock",
 	.info = snd_ice1712_pro_internal_clock_info,
@@ -1894,7 +1902,7 @@
 static int snd_ice1712_pro_internal_clock_default_info(struct snd_kcontrol *kcontrol,
 						       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {
+	static const char * const texts[] = {
 		"8000",		/* 0: 6 */
 		"9600",		/* 1: 3 */
 		"11025",	/* 2: 10 */
@@ -1923,8 +1931,8 @@
 						      struct snd_ctl_elem_value *ucontrol)
 {
 	int val;
-	static unsigned int xrate[13] = {
-		8000, 9600, 11025, 12000, 1600, 22050, 24000,
+	static const unsigned int xrate[13] = {
+		8000, 9600, 11025, 12000, 16000, 22050, 24000,
 		32000, 44100, 48000, 64000, 88200, 96000
 	};
 
@@ -1940,8 +1948,8 @@
 static int snd_ice1712_pro_internal_clock_default_put(struct snd_kcontrol *kcontrol,
 						      struct snd_ctl_elem_value *ucontrol)
 {
-	static unsigned int xrate[13] = {
-		8000, 9600, 11025, 12000, 1600, 22050, 24000,
+	static const unsigned int xrate[13] = {
+		8000, 9600, 11025, 12000, 16000, 22050, 24000,
 		32000, 44100, 48000, 64000, 88200, 96000
 	};
 	unsigned char oval;
@@ -1954,7 +1962,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ice1712_pro_internal_clock_default __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_pro_internal_clock_default __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Internal Clock Default",
 	.info = snd_ice1712_pro_internal_clock_default_info,
@@ -1993,7 +2001,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ice1712_pro_rate_locking __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_pro_rate_locking __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Rate Locking",
 	.info = snd_ice1712_pro_rate_locking_info,
@@ -2032,7 +2040,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ice1712_pro_rate_reset __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_pro_rate_reset __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Rate Reset",
 	.info = snd_ice1712_pro_rate_reset_info,
@@ -2046,7 +2054,7 @@
 static int snd_ice1712_pro_route_info(struct snd_kcontrol *kcontrol,
 				      struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {
+	static const char * const texts[] = {
 		"PCM Out", /* 0 */
 		"H/W In 0", "H/W In 1", "H/W In 2", "H/W In 3", /* 1-4 */
 		"H/W In 4", "H/W In 5", "H/W In 6", "H/W In 7", /* 5-8 */
@@ -2199,7 +2207,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ice1712_mixer_pro_analog_route __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_mixer_pro_analog_route __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "H/W Playback Route",
 	.info = snd_ice1712_pro_route_info,
@@ -2207,7 +2215,7 @@
 	.put = snd_ice1712_pro_route_analog_put,
 };
 
-static struct snd_kcontrol_new snd_ice1712_mixer_pro_spdif_route __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_mixer_pro_spdif_route __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "Route",
 	.info = snd_ice1712_pro_route_info,
@@ -2249,7 +2257,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ice1712_mixer_pro_volume_rate __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_mixer_pro_volume_rate __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Volume Rate",
 	.info = snd_ice1712_pro_volume_rate_info,
@@ -2282,7 +2290,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_ice1712_mixer_pro_peak __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_mixer_pro_peak __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Peak",
 	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
@@ -2297,7 +2305,7 @@
 /*
  * list of available boards
  */
-static struct snd_ice1712_card_info *card_tables[] __devinitdata = {
+static const struct snd_ice1712_card_info *card_tables[] __devinitdata = {
 	snd_ice1712_hoontech_cards,
 	snd_ice1712_delta_cards,
 	snd_ice1712_ews_cards,
@@ -2321,7 +2329,7 @@
 {
 	int dev = 0xa0;		/* EEPROM device address */
 	unsigned int i, size;
-	struct snd_ice1712_card_info **tbl, *c;
+	const struct snd_ice1712_card_info **tbl, *c;
 
 	if (! modelname || ! *modelname) {
 		ice->eeprom.subvendor = 0;
@@ -2650,7 +2658,7 @@
  *
  */
 
-static struct snd_ice1712_card_info no_matched __devinitdata;
+static const struct snd_ice1712_card_info no_matched __devinitdata;
 
 static int __devinit snd_ice1712_probe(struct pci_dev *pci,
 				       const struct pci_device_id *pci_id)
@@ -2659,7 +2667,7 @@
 	struct snd_card *card;
 	struct snd_ice1712 *ice;
 	int pcm_dev = 0, err;
-	struct snd_ice1712_card_info **tbl, *c;
+	const struct snd_ice1712_card_info **tbl, *c;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
--- linux-2.6.18.noarch/sound/pci/ice1712/ice1712.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/ice1712.h	2007-06-05 17:46:52.000000000 -0400
@@ -28,6 +28,7 @@
 #include <sound/i2c.h>
 #include <sound/ak4xxx-adda.h>
 #include <sound/ak4114.h>
+#include <sound/pt2258.h>
 #include <sound/pcm.h>
 #include <sound/mpu401.h>
 
@@ -381,6 +382,11 @@
 			unsigned short master[2];
 			unsigned short vol[8];
 		} phase28;
+		/* a non-standard I2C device for revo51 */
+		struct revo51_spec {
+			struct snd_i2c_device *dev;
+			struct snd_pt2258 *pt2258;
+		} revo51;
 		/* Hoontech-specific setting */
 		struct hoontech_spec {
 			unsigned char boxbits[4];
@@ -462,6 +468,14 @@
 	snd_ice1712_gpio_write(ice, mask & bits);
 }
 
+static inline int snd_ice1712_gpio_read_bits(struct snd_ice1712 *ice,
+					      unsigned int mask)
+{
+	ice->gpio.direction &= ~mask;
+	snd_ice1712_gpio_set_dir(ice, ice->gpio.direction);
+	return  (snd_ice1712_gpio_read(ice) & mask);
+}
+
 int snd_ice1712_spdif_build_controls(struct snd_ice1712 *ice);
 
 int snd_ice1712_akm4xxx_init(struct snd_akm4xxx *ak, const struct snd_akm4xxx *template,
@@ -500,8 +514,8 @@
 	unsigned int mpu401_2_info_flags;
 	const char *mpu401_1_name;
 	const char *mpu401_2_name;
-	unsigned int eeprom_size;
-	unsigned char *eeprom_data;
+	const unsigned int eeprom_size;
+	const unsigned char *eeprom_data;
 };
 
 
--- linux-2.6.18.noarch/sound/pci/ice1712/wtm.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/wtm.h	2007-06-05 17:46:52.000000000 -0400
@@ -0,0 +1,20 @@
+#ifndef __SOUND_WTM_H
+#define __SOUND_WTM_H
+
+/* ID */
+#define WTM_DEVICE_DESC		"{EGO SYS INC,WaveTerminal 192M},"
+#define VT1724_SUBDEVICE_WTM	0x36495345	/* WT192M ver1.0 */
+
+/*
+ *chip addresses on I2C bus
+ */
+
+#define	AK4114_ADDR		0x20	/*S/PDIF receiver*/
+#define STAC9460_I2C_ADDR	0x54	/* ADC*2 | DAC*6 */	
+#define STAC9460_2_I2C_ADDR	0x56	/* ADC|DAC *2 */	
+
+
+extern struct snd_ice1712_card_info snd_vt1724_wtm_cards[];
+
+#endif /* __SOUND_WTM_H */
+
--- linux-2.6.18.noarch/sound/pci/ice1712/ews.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/ews.h	2007-06-05 17:46:52.000000000 -0400
@@ -40,7 +40,7 @@
 #define ICE1712_SUBDEVICE_PHASE88	0x3b155111
 
 /* entry point */
-extern struct snd_ice1712_card_info snd_ice1712_ews_cards[];
+extern const struct snd_ice1712_card_info snd_ice1712_ews_cards[];
 
 
 /* TerraTec EWX 24/96 configuration definitions */
--- linux-2.6.18.noarch/sound/pci/ice1712/aureon.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/aureon.c	2007-06-05 17:46:52.000000000 -0400
@@ -60,6 +60,7 @@
 #include "ice1712.h"
 #include "envy24ht.h"
 #include "aureon.h"
+#include <sound/tlv.h>
 
 /* WM8770 registers */
 #define WM_DAC_ATTEN		0x00	/* DAC1-8 analog attenuation */
@@ -293,7 +294,7 @@
 static int aureon_ac97_init (struct snd_ice1712 *ice)
 {
 	int i;
-	static unsigned short ac97_defaults[] = {
+	static const unsigned short ac97_defaults[] = {
 		0x00, 0x9640,
 		0x02, 0x8000,
 		0x04, 0x8000,
@@ -473,7 +474,8 @@
 
 	tmp = snd_ice1712_gpio_read(ice);
 
-	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT) {
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||
+	    ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) {
 		snd_ice1712_gpio_set_mask(ice, ~(PRODIGY_SPI_MOSI|PRODIGY_SPI_CLK|PRODIGY_WM_CS));
 		mosi = PRODIGY_SPI_MOSI;
 		clk = PRODIGY_SPI_CLK;
@@ -600,7 +602,9 @@
 static void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)
 {
 	aureon_spi_write(ice,
-			(ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ? PRODIGY_WM_CS : AUREON_WM_CS),
+			 ((ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||
+			   ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) ?
+			 PRODIGY_WM_CS : AUREON_WM_CS),
 			(reg << 9) | (val & 0x1ff), 16);
 }
 
@@ -660,11 +664,17 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_wm_dac, -12700, 100, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_wm_pcm, -6400, 50, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_wm_adc, -1200, 100, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_ac97_master, -4650, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_ac97_gain, -3450, 150, 0);
+
 /*
  * Logarithmic volume values for WM8770
  * Computed as 20 * Log10(255 / x)
  */
-static unsigned char wm_vol[256] = {
+static const unsigned char wm_vol[256] = {
 	127, 48, 42, 39, 36, 34, 33, 31, 30, 29, 28, 27, 27, 26, 25, 25, 24, 24, 23,
 	23, 22, 22, 21, 21, 21, 20, 20, 20, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17,
 	17, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13,
@@ -1057,14 +1067,14 @@
  */
 static int wm_adc_mux_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {
+	static const char * const texts[] = {
 		"CD",		//AIN1
 		"Aux",		//AIN2
 		"Line",		//AIN3
 		"Mic",		//AIN4
 		"AC97"		//AIN5
 	};
-	static char *universe_texts[] = {
+	static const char * const universe_texts[] = {
 		"Aux1",		//AIN1
 		"CD",		//AIN2
 		"Phono",	//AIN3
@@ -1130,11 +1140,11 @@
 static int aureon_cs8415_mux_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
-	static char *aureon_texts[] = {
+	static const char * const aureon_texts[] = {
 		"CD",		//RXP0
 		"Optical"	//RXP1
 	};
-	static char *prodigy_texts[] = {
+	static const char * const prodigy_texts[] = {
 		"CD",
 		"Coax"
 	};
@@ -1281,12 +1291,14 @@
 
 	tmp2 = tmp = snd_ice1712_gpio_read(ice);
 	if (enable)
-		if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT)
+		if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&
+		    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT)
 			tmp |= AUREON_HP_SEL;
 		else
 			tmp |= PRODIGY_HP_SEL;
 	else
-		if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT)
+		if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&
+		    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT)
 			tmp &= ~ AUREON_HP_SEL;
 		else
 			tmp &= ~ PRODIGY_HP_SEL;
@@ -1356,7 +1368,7 @@
  */
 static int aureon_oversampling_info(struct snd_kcontrol *k, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[2] = { "128x", "64x"	};
+	static const char * const texts[2] = { "128x", "64x"	};
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
@@ -1399,7 +1411,7 @@
  * mixers
  */
 
-static struct snd_kcontrol_new aureon_dac_controls[] __devinitdata = {
+static const struct snd_kcontrol_new aureon_dac_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Master Playback Switch",
@@ -1409,10 +1421,13 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Master Playback Volume",
 		.info = wm_master_vol_info,
 		.get = wm_master_vol_get,
-		.put = wm_master_vol_put
+		.put = wm_master_vol_put,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1424,11 +1439,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Front Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (2 << 8) | 0
+		.private_value = (2 << 8) | 0,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1440,11 +1458,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Rear Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (2 << 8) | 2
+		.private_value = (2 << 8) | 2,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1456,11 +1477,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Center Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (1 << 8) | 4
+		.private_value = (1 << 8) | 4,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1472,11 +1496,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "LFE Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (1 << 8) | 5
+		.private_value = (1 << 8) | 5,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1488,15 +1515,18 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Side Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (2 << 8) | 6
+		.private_value = (2 << 8) | 6,
+		.tlv = { .p = db_scale_wm_dac }
 	}
 };
 
-static struct snd_kcontrol_new wm_controls[] __devinitdata = {
+static const struct snd_kcontrol_new wm_controls[] __devinitdata = {
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "PCM Playback Switch",
@@ -1506,10 +1536,13 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "PCM Playback Volume",
 		.info = wm_pcm_vol_info,
 		.get = wm_pcm_vol_get,
-		.put = wm_pcm_vol_put
+		.put = wm_pcm_vol_put,
+		.tlv = { .p = db_scale_wm_pcm }
  	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1520,10 +1553,13 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Capture Volume",
 		.info = wm_adc_vol_info,
 		.get = wm_adc_vol_get,
-		.put = wm_adc_vol_put
+		.put = wm_adc_vol_put,
+		.tlv = { .p = db_scale_wm_adc }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1556,7 +1592,7 @@
 	}
 };
 
-static struct snd_kcontrol_new ac97_controls[] __devinitdata = {
+static const struct snd_kcontrol_new ac97_controls[] __devinitdata = {
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "AC97 Playback Switch",
@@ -1567,11 +1603,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "AC97 Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_MASTER|AUREON_AC97_STEREO
+ 		.private_value = AC97_MASTER|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_master }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1583,11 +1622,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "CD Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_CD|AUREON_AC97_STEREO
+ 		.private_value = AC97_CD|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1599,11 +1641,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Aux Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_AUX|AUREON_AC97_STEREO
+ 		.private_value = AC97_AUX|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1615,11 +1660,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Line Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_LINE|AUREON_AC97_STEREO
+ 		.private_value = AC97_LINE|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1631,11 +1679,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Mic Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_MIC
+ 		.private_value = AC97_MIC,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1646,7 +1697,7 @@
  	}
 };
 
-static struct snd_kcontrol_new universe_ac97_controls[] __devinitdata = {
+static const struct snd_kcontrol_new universe_ac97_controls[] __devinitdata = {
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "AC97 Playback Switch",
@@ -1657,11 +1708,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "AC97 Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_MASTER|AUREON_AC97_STEREO
+ 		.private_value = AC97_MASTER|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_master }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1673,11 +1727,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "CD Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_AUX|AUREON_AC97_STEREO
+ 		.private_value = AC97_AUX|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1685,15 +1742,18 @@
  		.info = aureon_ac97_mute_info,
  		.get = aureon_ac97_mute_get,
  		.put = aureon_ac97_mute_put,
- 		.private_value = AC97_CD,
+ 		.private_value = AC97_CD
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Phono Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_CD|AUREON_AC97_STEREO
+ 		.private_value = AC97_CD|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1705,11 +1765,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Line Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_LINE|AUREON_AC97_STEREO
+ 		.private_value = AC97_LINE|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1721,11 +1784,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Mic Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_MIC
+ 		.private_value = AC97_MIC,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1744,11 +1810,14 @@
  	},
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
  		.name = "Aux Playback Volume",
  		.info = aureon_ac97_vol_info,
  		.get = aureon_ac97_vol_get,
  		.put = aureon_ac97_vol_put,
- 		.private_value = AC97_VIDEO|AUREON_AC97_STEREO
+ 		.private_value = AC97_VIDEO|AUREON_AC97_STEREO,
+		.tlv = { .p = db_scale_ac97_gain }
  	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1760,8 +1829,7 @@
 
 };
 
-	
-static struct snd_kcontrol_new cs8415_controls[] __devinitdata = {
+static const struct snd_kcontrol_new cs8415_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH),
@@ -1806,7 +1874,6 @@
 	}
 };
 
- 
 static int __devinit aureon_add_controls(struct snd_ice1712 *ice)
 {
 	unsigned int i, counts;
@@ -1834,7 +1901,8 @@
 				return err;
 		}
 	}
-	else if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT) {
+	else if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&
+		 ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {
 		for (i = 0; i < ARRAY_SIZE(ac97_controls); i++) {
 			err = snd_ctl_add(ice->card, snd_ctl_new1(&ac97_controls[i], ice));
 			if (err < 0)
@@ -1842,7 +1910,8 @@
 		}
 	}
 
-	if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT) {
+	if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&
+	    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {
 		unsigned char id;
 		snd_ice1712_save_gpio_status(ice);
 		id = aureon_cs8415_get(ice, CS8415_ID);
@@ -1872,7 +1941,7 @@
  */
 static int __devinit aureon_init(struct snd_ice1712 *ice)
 {
-	static unsigned short wm_inits_aureon[] = {
+	static const unsigned short wm_inits_aureon[] = {
 		/* These come first to reduce init pop noise */
 		0x1b, 0x044,		/* ADC Mux (AC'97 source) */
 		0x1c, 0x00B,		/* Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) */
@@ -1908,7 +1977,7 @@
 		0x1a, 0x000,		/* -12dB ADC/R */
 		(unsigned short)-1
 	};
-	static unsigned short wm_inits_prodigy[] = {
+	static const unsigned short wm_inits_prodigy[] = {
 
 		/* These come first to reduce init pop noise */
 		0x1b, 0x000,		/* ADC Mux */
@@ -1950,7 +2019,7 @@
 		(unsigned short)-1
 
 	};
-	static unsigned short cs_inits[] = {
+	static const unsigned short cs_inits[] = {
 		0x0441, /* RUN */
 		0x0180, /* no mute, OMCK output on RMCK pin */
 		0x0201, /* S/PDIF source on RXP1 */
@@ -1958,7 +2027,7 @@
 		(unsigned short)-1
 	};
 	unsigned int tmp;
-	unsigned short *p;
+	const unsigned short *p;
 	int err, i;
 
 	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON51_SKY) {
@@ -1998,7 +2067,8 @@
 
 	/* initialize WM8770 codec */
 	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71 ||
-		ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT)
+		ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||
+	        ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT)
 		p = wm_inits_prodigy;
 	else
 		p = wm_inits_aureon;
@@ -2006,7 +2076,8 @@
 		wm_put(ice, p[0], p[1]);
 
 	/* initialize CS8415A codec */
-	if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT) {
+	if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&
+	    ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {
 		for (p = cs_inits; *p != (unsigned short)-1; p++)
 			aureon_spi_write(ice, AUREON_CS8415_CS, *p | 0x200000, 24);
 		ice->spec.aureon.cs8415_mux = 1;
@@ -2036,73 +2107,58 @@
  * hence the driver needs to sets up it properly.
  */
 
-static unsigned char aureon51_eeprom[] __devinitdata = {
-	0x0a,	/* SYSCONF: clock 512, spdif-in/ADC, 3DACs */
-	0x80,	/* ACLINK: I2S */
-	0xfc,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x5f,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char aureon51_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x0a,	/* clock 512, spdif-in/ADC, 3DACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xfc,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x5f,
+	[ICE_EEP2_GPIO_MASK]   = 0x00,
+	[ICE_EEP2_GPIO_MASK1]  = 0x00,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
 
-static unsigned char aureon71_eeprom[] __devinitdata = {
-	0x0b,	/* SYSCONF: clock 512, spdif-in/ADC, 4DACs */
-	0x80,	/* ACLINK: I2S */
-	0xfc,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x5f,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char aureon71_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x0b,	/* clock 512, spdif-in/ADC, 4DACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xfc,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x5f,
+	[ICE_EEP2_GPIO_MASK]   = 0x00,
+	[ICE_EEP2_GPIO_MASK1]  = 0x00,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
+#define prodigy71_eeprom aureon71_eeprom
 
-static unsigned char prodigy71_eeprom[] __devinitdata = {
-	0x0b,	/* SYSCONF: clock 512, spdif-in/ADC, 4DACs */
-	0x80,	/* ACLINK: I2S */
-	0xfc,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x5f,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char prodigy71lt_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x4b,	/* clock 384, spdif-in/ADC, 4DACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xfc,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x5f,
+	[ICE_EEP2_GPIO_MASK]   = 0x00,
+	[ICE_EEP2_GPIO_MASK1]  = 0x00,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
-
-static unsigned char prodigy71lt_eeprom[] __devinitdata = {
-	0x4b,	/* SYSCINF: clock 512, spdif-in/ADC, 4DACs */
-	0x80,	/* ACLINK: I2S */
-	0xfc,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x5f,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 */
-};
-	
+#define prodigy71xt_eeprom prodigy71lt_eeprom
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1724_aureon_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1724_aureon_cards[] __devinitdata = {
 	{
 		.subvendor = VT1724_SUBDEVICE_AUREON51_SKY,
 		.name = "Terratec Aureon 5.1-Sky",
@@ -2153,5 +2209,15 @@
 		.eeprom_data = prodigy71lt_eeprom,
 		.driver = "Prodigy71LT",
 	},
+	{
+		.subvendor = VT1724_SUBDEVICE_PRODIGY71XT,
+		.name = "Audiotrak Prodigy 7.1 XT",
+		.model = "prodigy71xt",
+		.chip_init = aureon_init,
+		.build_controls = aureon_add_controls,
+		.eeprom_size = sizeof(prodigy71xt_eeprom),
+		.eeprom_data = prodigy71xt_eeprom,
+		.driver = "Prodigy71LT",
+	},
 	{ } /* terminator */
 };
--- linux-2.6.18.noarch/sound/pci/ice1712/amp.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/amp.h	2007-06-05 17:46:52.000000000 -0400
@@ -42,7 +42,7 @@
 #define WM_DAC_CTRL	0x02
 #define WM_INT_CTRL	0x03
 
-extern struct snd_ice1712_card_info  snd_vt1724_amp_cards[];
+extern const struct snd_ice1712_card_info  snd_vt1724_amp_cards[];
 
 
 #endif /* __SOUND_AMP_H */
--- linux-2.6.18.noarch/sound/pci/ice1712/Makefile.orig	2007-06-05 16:07:58.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/Makefile	2007-06-05 17:46:52.000000000 -0400
@@ -5,7 +5,7 @@
 
 snd-ice17xx-ak4xxx-objs := ak4xxx.o
 snd-ice1712-objs := ice1712.o delta.o hoontech.o ews.o
-snd-ice1724-objs := ice1724.o amp.o revo.o aureon.o vt1720_mobo.o pontis.o prodigy192.o juli.o phase.o
+snd-ice1724-objs := ice1724.o amp.o revo.o aureon.o vt1720_mobo.o pontis.o prodigy192.o juli.o phase.o wtm.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_ICE1712) += snd-ice1712.o snd-ice17xx-ak4xxx.o
--- linux-2.6.18.noarch/sound/pci/ice1712/hoontech.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/hoontech.c	2007-06-05 17:46:52.000000000 -0400
@@ -239,7 +239,7 @@
 static int __devinit snd_ice1712_value_init(struct snd_ice1712 *ice)
 {
 	/* Hoontech STDSP24 with modified hardware */
-	static struct snd_akm4xxx akm_stdsp24_mv __devinitdata = {
+	static const struct snd_akm4xxx akm_stdsp24_mv __devinitdata = {
 		.num_adcs = 2,
 		.num_dacs = 2,
 		.type = SND_AK4524,
@@ -248,7 +248,7 @@
 		}
 	};
 
-	static struct snd_ak4xxx_private akm_stdsp24_mv_priv __devinitdata = {
+	static const struct snd_ak4xxx_private akm_stdsp24_mv_priv __devinitdata = {
 		.caddr = 2,
 		.cif = 1, /* CIF high */
 		.data_mask = ICE1712_STDSP24_SERIAL_DATA,
@@ -298,7 +298,7 @@
 
 
 /* entry point */
-struct snd_ice1712_card_info snd_ice1712_hoontech_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_ice1712_hoontech_cards[] __devinitdata = {
 	{
 		.subvendor = ICE1712_SUBDEVICE_STDSP24,
 		.name = "Hoontech SoundTrack Audio DSP24",
@@ -325,4 +325,3 @@
 	},
 	{ } /* terminator */
 };
-
--- linux-2.6.18.noarch/sound/pci/ice1712/revo.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/revo.c	2007-06-05 17:46:52.000000000 -0400
@@ -84,31 +84,151 @@
 }
 
 /*
+ * I2C access to the PT2258 volume controller on GPIO 6/7 (Revolution 5.1)
+ */
+
+static void revo_i2c_start(struct snd_i2c_bus *bus)
+{
+	struct snd_ice1712 *ice = bus->private_data;
+	snd_ice1712_save_gpio_status(ice);
+}
+
+static void revo_i2c_stop(struct snd_i2c_bus *bus)
+{
+	struct snd_ice1712 *ice = bus->private_data;
+	snd_ice1712_restore_gpio_status(ice);
+}
+
+static void revo_i2c_direction(struct snd_i2c_bus *bus, int clock, int data)
+{
+	struct snd_ice1712 *ice = bus->private_data;
+	unsigned int mask, val;
+
+	val = 0;
+	if (clock)
+		val |= VT1724_REVO_I2C_CLOCK;	/* write SCL */
+	if (data)
+		val |= VT1724_REVO_I2C_DATA;	/* write SDA */
+	mask = VT1724_REVO_I2C_CLOCK | VT1724_REVO_I2C_DATA;
+	ice->gpio.direction &= ~mask;
+	ice->gpio.direction |= val;
+	snd_ice1712_gpio_set_dir(ice, ice->gpio.direction);
+	snd_ice1712_gpio_set_mask(ice, ~mask);
+}
+
+static void revo_i2c_setlines(struct snd_i2c_bus *bus, int clk, int data)
+{
+	struct snd_ice1712 *ice = bus->private_data;
+	unsigned int val = 0;
+
+	if (clk)
+		val |= VT1724_REVO_I2C_CLOCK;
+	if (data)
+		val |= VT1724_REVO_I2C_DATA;
+	snd_ice1712_gpio_write_bits(ice,
+				    VT1724_REVO_I2C_DATA |
+				    VT1724_REVO_I2C_CLOCK, val);
+	udelay(5);
+}
+
+static int revo_i2c_getdata(struct snd_i2c_bus *bus, int ack)
+{
+	struct snd_ice1712 *ice = bus->private_data;
+	int bit;
+
+	if (ack)
+		udelay(5);
+	bit = snd_ice1712_gpio_read_bits(ice, VT1724_REVO_I2C_DATA) ? 1 : 0;
+	return bit;
+}
+
+static struct snd_i2c_bit_ops revo51_bit_ops = {
+	.start = revo_i2c_start,
+	.stop = revo_i2c_stop,
+	.direction = revo_i2c_direction,
+	.setlines = revo_i2c_setlines,
+	.getdata = revo_i2c_getdata,
+};
+
+static int revo51_i2c_init(struct snd_ice1712 *ice,
+			   struct snd_pt2258 *pt)
+{
+	int err;
+
+	/* create the I2C bus */
+	err = snd_i2c_bus_create(ice->card, "ICE1724 GPIO6", NULL, &ice->i2c);
+	if (err < 0)
+		return err;
+
+	ice->i2c->private_data = ice;
+	ice->i2c->hw_ops.bit = &revo51_bit_ops;
+
+	/* create the I2C device */
+	err = snd_i2c_device_create(ice->i2c, "PT2258", 0x40,
+				    &ice->spec.revo51.dev);
+	if (err < 0)
+		return err;
+
+	pt->card = ice->card;
+	pt->i2c_bus = ice->i2c;
+	pt->i2c_dev = ice->spec.revo51.dev;
+	ice->spec.revo51.pt2258 = pt;
+
+	snd_pt2258_reset(pt);
+
+	return 0;
+}
+
+/*
  * initialize the chips on M-Audio Revolution cards
  */
 
-static unsigned int revo71_num_stereo_front[] = {2};
-static char *revo71_channel_names_front[] = {"PCM Playback Volume"};
+#define AK_DAC(xname,xch) { .name = xname, .num_channels = xch }
 
-static unsigned int revo71_num_stereo_surround[] = {1, 1, 2, 2};
-static char *revo71_channel_names_surround[] = {"PCM Center Playback Volume", "PCM LFE Playback Volume",
-						"PCM Side Playback Volume", "PCM Rear Playback Volume"};
-
-static unsigned int revo51_num_stereo[] = {2, 1, 1, 2};
-static char *revo51_channel_names[] = {"PCM Playback Volume", "PCM Center Playback Volume",
-					"PCM LFE Playback Volume", "PCM Rear Playback Volume"};
+static const struct snd_akm4xxx_dac_channel revo71_front[] = {
+	AK_DAC("PCM Playback Volume", 2)
+};
+
+static const struct snd_akm4xxx_dac_channel revo71_surround[] = {
+	AK_DAC("PCM Center Playback Volume", 1),
+	AK_DAC("PCM LFE Playback Volume", 1),
+	AK_DAC("PCM Side Playback Volume", 2),
+	AK_DAC("PCM Rear Playback Volume", 2),
+};
 
-static struct snd_akm4xxx akm_revo_front __devinitdata = {
+static const struct snd_akm4xxx_dac_channel revo51_dac[] = {
+	AK_DAC("PCM Playback Volume", 2),
+	AK_DAC("PCM Center Playback Volume", 1),
+	AK_DAC("PCM LFE Playback Volume", 1),
+	AK_DAC("PCM Rear Playback Volume", 2),
+};
+
+static const char *revo51_adc_input_names[] = {
+	"Mic",
+	"Line",
+	"CD",
+	NULL
+};
+
+static const struct snd_akm4xxx_adc_channel revo51_adc[] = {
+	{
+		.name = "PCM Capture Volume",
+		.switch_name = "PCM Capture Switch",
+		.num_channels = 2,
+		.input_names = revo51_adc_input_names
+	},
+};
+
+static const struct snd_akm4xxx akm_revo_front __devinitdata = {
 	.type = SND_AK4381,
 	.num_dacs = 2,
 	.ops = {
 		.set_rate_val = revo_set_rate_val
 	},
-	.num_stereo = revo71_num_stereo_front,
-	.channel_names = revo71_channel_names_front
+	.dac_info = revo71_front,
 };
 
-static struct snd_ak4xxx_private akm_revo_front_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_revo_front_priv __devinitdata = {
 	.caddr = 1,
 	.cif = 0,
 	.data_mask = VT1724_REVO_CDOUT,
@@ -120,18 +240,17 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_revo_surround __devinitdata = {
+static const struct snd_akm4xxx akm_revo_surround __devinitdata = {
 	.type = SND_AK4355,
 	.idx_offset = 1,
 	.num_dacs = 6,
 	.ops = {
 		.set_rate_val = revo_set_rate_val
 	},
-	.num_stereo = revo71_num_stereo_surround,
-	.channel_names = revo71_channel_names_surround
+	.dac_info = revo71_surround,
 };
 
-static struct snd_ak4xxx_private akm_revo_surround_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_revo_surround_priv __devinitdata = {
 	.caddr = 3,
 	.cif = 0,
 	.data_mask = VT1724_REVO_CDOUT,
@@ -143,28 +262,222 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_revo51 __devinitdata = {
+static const struct snd_akm4xxx akm_revo51 __devinitdata = {
 	.type = SND_AK4358,
 	.num_dacs = 6,
 	.ops = {
 		.set_rate_val = revo_set_rate_val
 	},
-	.num_stereo = revo51_num_stereo,
-	.channel_names = revo51_channel_names
+	.dac_info = revo51_dac,
 };
 
-static struct snd_ak4xxx_private akm_revo51_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_revo51_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 0,
 	.data_mask = VT1724_REVO_CDOUT,
 	.clk_mask = VT1724_REVO_CCLK,
-	.cs_mask = VT1724_REVO_CS0 | VT1724_REVO_CS1 | VT1724_REVO_CS2,
-	.cs_addr = 0,
-	.cs_none = VT1724_REVO_CS0 | VT1724_REVO_CS1 | VT1724_REVO_CS2,
+	.cs_mask = VT1724_REVO_CS0 | VT1724_REVO_CS1,
+	.cs_addr = VT1724_REVO_CS1,
+	.cs_none = VT1724_REVO_CS0 | VT1724_REVO_CS1,
+	.add_flags = VT1724_REVO_CCLK, /* high at init */
+	.mask_flags = 0,
+};
+
+static const struct snd_akm4xxx akm_revo51_adc __devinitdata = {
+	.type = SND_AK5365,
+	.num_adcs = 2,
+	.adc_info = revo51_adc,
+};
+
+static const struct snd_ak4xxx_private akm_revo51_adc_priv __devinitdata = {
+	.caddr = 2,
+	.cif = 0,
+	.data_mask = VT1724_REVO_CDOUT,
+	.clk_mask = VT1724_REVO_CCLK,
+	.cs_mask = VT1724_REVO_CS0 | VT1724_REVO_CS1,
+	.cs_addr = VT1724_REVO_CS0,
+	.cs_none = VT1724_REVO_CS0 | VT1724_REVO_CS1,
+	.add_flags = VT1724_REVO_CCLK, /* high at init */
+	.mask_flags = 0,
+};
+
+static struct snd_pt2258 ptc_revo51_volume;
+
+/* AK4358 for AP192 DAC, AK5385A for ADC */
+static void ap192_set_rate_val(struct snd_akm4xxx *ak, unsigned int rate)
+{
+	struct snd_ice1712 *ice = ak->private_data[0];
+
+	revo_set_rate_val(ak, rate);
+
+#if 1 /* FIXME: do we need this procedure? */
+	/* reset DFS pin of AK5385A for ADC, too */
+	/* DFS0 (pin 18) -- GPIO10 pin 77 */
+	snd_ice1712_save_gpio_status(ice);
+	snd_ice1712_gpio_write_bits(ice, 1 << 10,
+				    rate > 48000 ? (1 << 10) : 0);
+	snd_ice1712_restore_gpio_status(ice);
+#endif
+}
+
+static const struct snd_akm4xxx_dac_channel ap192_dac[] = {
+	AK_DAC("PCM Playback Volume", 2)
+};
+
+static const struct snd_akm4xxx akm_ap192 __devinitdata = {
+	.type = SND_AK4358,
+	.num_dacs = 2,
+	.ops = {
+		.set_rate_val = ap192_set_rate_val
+	},
+	.dac_info = ap192_dac,
+};
+
+static const struct snd_ak4xxx_private akm_ap192_priv __devinitdata = {
+	.caddr = 2,
+	.cif = 0,
+	.data_mask = VT1724_REVO_CDOUT,
+	.clk_mask = VT1724_REVO_CCLK,
+	.cs_mask = VT1724_REVO_CS0 | VT1724_REVO_CS3,
+	.cs_addr = VT1724_REVO_CS3,
+	.cs_none = VT1724_REVO_CS0 | VT1724_REVO_CS3,
 	.add_flags = VT1724_REVO_CCLK, /* high at init */
 	.mask_flags = 0,
 };
 
+#if 0
+/* FIXME: ak4114 makes the sound much lower due to some confliction,
+ *        so let's disable it right now...
+ */
+#define BUILD_AK4114_AP192
+#endif
+
+#ifdef BUILD_AK4114_AP192
+/* AK4114 support on Audiophile 192 */
+/* CDTO (pin 32) -- GPIO2 pin 52
+ * CDTI (pin 33) -- GPIO3 pin 53 (shared with AK4358)
+ * CCLK (pin 34) -- GPIO1 pin 51 (shared with AK4358)
+ * CSN  (pin 35) -- GPIO7 pin 59
+ */
+#define AK4114_ADDR	0x00
+
+static void write_data(struct snd_ice1712 *ice, unsigned int gpio,
+		       unsigned int data, int idx)
+{
+	for (; idx >= 0; idx--) {
+		/* drop clock */
+		gpio &= ~VT1724_REVO_CCLK;
+		snd_ice1712_gpio_write(ice, gpio);
+		udelay(1);
+		/* set data */
+		if (data & (1 << idx))
+			gpio |= VT1724_REVO_CDOUT;
+		else
+			gpio &= ~VT1724_REVO_CDOUT;
+		snd_ice1712_gpio_write(ice, gpio);
+		udelay(1);
+		/* raise clock */
+		gpio |= VT1724_REVO_CCLK;
+		snd_ice1712_gpio_write(ice, gpio);
+		udelay(1);
+	}
+}
+
+static unsigned char read_data(struct snd_ice1712 *ice, unsigned int gpio,
+			       int idx)
+{
+	unsigned char data = 0;
+
+	for (; idx >= 0; idx--) {
+		/* drop clock */
+		gpio &= ~VT1724_REVO_CCLK;
+		snd_ice1712_gpio_write(ice, gpio);
+		udelay(1);
+		/* read data */
+		if (snd_ice1712_gpio_read(ice) & VT1724_REVO_CDIN)
+			data |= (1 << idx);
+		udelay(1);
+		/* raise clock */
+		gpio |= VT1724_REVO_CCLK;
+		snd_ice1712_gpio_write(ice, gpio);
+		udelay(1);
+	}
+	return data;
+}
+
+static unsigned char ap192_4wire_start(struct snd_ice1712 *ice)
+{
+	unsigned int tmp;
+
+	snd_ice1712_save_gpio_status(ice);
+	tmp = snd_ice1712_gpio_read(ice);
+	tmp |= VT1724_REVO_CCLK; /* high at init */
+	tmp |= VT1724_REVO_CS0;
+	tmp &= ~VT1724_REVO_CS3;
+	snd_ice1712_gpio_write(ice, tmp);
+	udelay(1);
+	return tmp;
+}
+
+static void ap192_4wire_finish(struct snd_ice1712 *ice, unsigned int tmp)
+{
+	tmp |= VT1724_REVO_CS3;
+	tmp |= VT1724_REVO_CS0;
+	snd_ice1712_gpio_write(ice, tmp);
+	udelay(1);
+	snd_ice1712_restore_gpio_status(ice);
+}
+
+static void ap192_ak4114_write(void *private_data, unsigned char addr,
+			       unsigned char data)
+{
+	struct snd_ice1712 *ice = private_data;
+	unsigned int tmp, addrdata;
+
+	tmp = ap192_4wire_start(ice);
+	addrdata = (AK4114_ADDR << 6) | 0x20 | (addr & 0x1f);
+	addrdata = (addrdata << 8) | data;
+	write_data(ice, tmp, addrdata, 15);
+	ap192_4wire_finish(ice, tmp);
+}
+
+static unsigned char ap192_ak4114_read(void *private_data, unsigned char addr)
+{
+	struct snd_ice1712 *ice = private_data;
+	unsigned int tmp;
+	unsigned char data;
+
+	tmp = ap192_4wire_start(ice);
+	write_data(ice, tmp, (AK4114_ADDR << 6) | (addr & 0x1f), 7);
+	data = read_data(ice, tmp, 7);
+	ap192_4wire_finish(ice, tmp);
+	return data;
+}
+
+static int ap192_ak4114_init(struct snd_ice1712 *ice)
+{
+	static const unsigned char ak4114_init_vals[] = {
+		AK4114_RST | AK4114_PWN | AK4114_OCKS0 | AK4114_OCKS1,
+		AK4114_DIF_I24I2S,
+		AK4114_TX1E,
+		AK4114_EFH_1024 | AK4114_DIT | AK4114_IPS(1),
+		0,
+		0
+	};
+	static const unsigned char ak4114_init_txcsb[] = {
+		0x41, 0x02, 0x2c, 0x00, 0x00
+	};
+	struct ak4114 *ak;
+	int err;
+
+	return snd_ak4114_create(ice->card,
+				 ap192_ak4114_read,
+				 ap192_ak4114_write,
+				 ak4114_init_vals, ak4114_init_txcsb,
+				 ice, &ak);
+}
+#endif /* BUILD_AK4114_AP192 */
+
 static int __devinit revo_init(struct snd_ice1712 *ice)
 {
 	struct snd_akm4xxx *ak;
@@ -181,6 +494,10 @@
 		ice->num_total_dacs = 6;
 		ice->num_total_adcs = 2;
 		break;
+	case VT1724_SUBDEVICE_AUDIOPHILE192:
+		ice->num_total_dacs = 2;
+		ice->num_total_adcs = 2;
+		break;
 	default:
 		snd_BUG();
 		return -EINVAL;
@@ -202,11 +519,29 @@
 		snd_ice1712_gpio_write_bits(ice, VT1724_REVO_MUTE, VT1724_REVO_MUTE);
 		break;
 	case VT1724_SUBDEVICE_REVOLUTION51:
+		ice->akm_codecs = 2;
+		err = snd_ice1712_akm4xxx_init(ak, &akm_revo51,
+					       &akm_revo51_priv, ice);
+		if (err < 0)
+			return err;
+		err = snd_ice1712_akm4xxx_init(ak+1, &akm_revo51_adc,
+					       &akm_revo51_adc_priv, ice);
+		if (err < 0)
+			return err;
+		err = revo51_i2c_init(ice, &ptc_revo51_volume);
+		if (err < 0)
+			return err;
+		/* unmute all codecs */
+		snd_ice1712_gpio_write_bits(ice, VT1724_REVO_MUTE,
+					    VT1724_REVO_MUTE);
+		break;
+	case VT1724_SUBDEVICE_AUDIOPHILE192:
 		ice->akm_codecs = 1;
-		if ((err = snd_ice1712_akm4xxx_init(ak, &akm_revo51, &akm_revo51_priv, ice)) < 0)
+		err = snd_ice1712_akm4xxx_init(ak, &akm_ap192, &akm_ap192_priv,
+					       ice);
+		if (err < 0)
 			return err;
-		/* unmute all codecs - needed! */
-		snd_ice1712_gpio_write_bits(ice, VT1724_REVO_MUTE, VT1724_REVO_MUTE);
+		
 		break;
 	}
 
@@ -220,16 +555,34 @@
 
 	switch (ice->eeprom.subvendor) {
 	case VT1724_SUBDEVICE_REVOLUTION71:
+		err = snd_ice1712_akm4xxx_build_controls(ice);
+		if (err < 0)
+			return err;
+		break;
 	case VT1724_SUBDEVICE_REVOLUTION51:
 		err = snd_ice1712_akm4xxx_build_controls(ice);
 		if (err < 0)
 			return err;
+		err = snd_pt2258_build_controls(ice->spec.revo51.pt2258);
+		if (err < 0)
+			return err;
+		break;
+	case VT1724_SUBDEVICE_AUDIOPHILE192:
+		err = snd_ice1712_akm4xxx_build_controls(ice);
+		if (err < 0)
+			return err;
+#ifdef BUILD_AK4114_AP192
+		err = ap192_ak4114_init(ice);
+		if (err < 0)
+			return err;
+#endif
+		break;
 	}
 	return 0;
 }
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1724_revo_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1724_revo_cards[] __devinitdata = {
 	{
 		.subvendor = VT1724_SUBDEVICE_REVOLUTION71,
 		.name = "M Audio Revolution-7.1",
@@ -244,5 +597,12 @@
 		.chip_init = revo_init,
 		.build_controls = revo_add_controls,
 	},
+	{
+		.subvendor = VT1724_SUBDEVICE_AUDIOPHILE192,
+		.name = "M Audio Audiophile192",
+		.model = "ap192",
+		.chip_init = revo_init,
+		.build_controls = revo_add_controls,
+	},
 	{ } /* terminator */
 };
--- linux-2.6.18.noarch/sound/pci/ice1712/prodigy192.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/prodigy192.c	2007-06-05 17:46:52.000000000 -0400
@@ -35,6 +35,7 @@
 #include "envy24ht.h"
 #include "prodigy192.h"
 #include "stac946x.h"
+#include <sound/tlv.h>
 
 static inline void stac9460_put(struct snd_ice1712 *ice, int reg, unsigned char val)
 {
@@ -356,11 +357,14 @@
 }
 #endif
 
+static const DECLARE_TLV_DB_SCALE(db_scale_dac, -19125, 75, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_adc, 0, 150, 0);
+
 /*
  * mixers
  */
 
-static struct snd_kcontrol_new stac_controls[] __devinitdata = {
+static const struct snd_kcontrol_new stac_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Master Playback Switch",
@@ -368,14 +372,18 @@
 		.get = stac9460_dac_mute_get,
 		.put = stac9460_dac_mute_put,
 		.private_value = 1,
+		.tlv = { .p = db_scale_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Master Playback Volume",
 		.info = stac9460_dac_vol_info,
 		.get = stac9460_dac_vol_get,
 		.put = stac9460_dac_vol_put,
 		.private_value = 1,
+		.tlv = { .p = db_scale_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -387,11 +395,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "DAC Volume",
 		.count = 6,
 		.info = stac9460_dac_vol_info,
 		.get = stac9460_dac_vol_get,
 		.put = stac9460_dac_vol_put,
+		.tlv = { .p = db_scale_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -404,11 +415,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "ADC Volume",
 		.count = 1,
 		.info = stac9460_adc_vol_info,
 		.get = stac9460_adc_vol_get,
 		.put = stac9460_adc_vol_put,
+		.tlv = { .p = db_scale_adc }
 	},
 #if 0
 	{
@@ -461,7 +475,7 @@
  */
 static int __devinit prodigy192_init(struct snd_ice1712 *ice)
 {
-	static unsigned short stac_inits_prodigy[] = {
+	static const unsigned short stac_inits_prodigy[] = {
 		STAC946X_RESET, 0,
 /*		STAC946X_MASTER_VOLUME, 0,
 		STAC946X_LF_VOLUME, 0,
@@ -472,7 +486,7 @@
 		STAC946X_LFE_VOLUME, 0,*/
 		(unsigned short)-1
 	};
-	unsigned short *p;
+	const unsigned short *p;
 
 	/* prodigy 192 */
 	ice->num_total_dacs = 6;
@@ -492,25 +506,25 @@
  * hence the driver needs to sets up it properly.
  */
 
-static unsigned char prodigy71_eeprom[] __devinitdata = {
-	0x2b,	/* SYSCONF: clock 512, mpu401, spdif-in/ADC, 4DACs */
-	0x80,	/* ACLINK: I2S */
-	0xf8,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0xbf,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char prodigy71_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x2b,	/* clock 512, mpu401, spdif-in/ADC, 4DACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xf8,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0xbf,
+	[ICE_EEP2_GPIO_MASK]   = 0x00,
+	[ICE_EEP2_GPIO_MASK1]  = 0x00,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
 
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1724_prodigy192_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1724_prodigy192_cards[] __devinitdata = {
 	{
 		.subvendor = VT1724_SUBDEVICE_PRODIGY192VE,
 		.name = "Audiotrak Prodigy 192",
--- linux-2.6.18.noarch/sound/pci/ice1712/aureon.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/aureon.h	2007-06-05 17:46:52.000000000 -0400
@@ -28,15 +28,17 @@
 				       "{Terratec,Aureon 7.1 Space},"\
 				       "{Terratec,Aureon 7.1 Universe}," \
 					"{AudioTrak,Prodigy 7.1}," \
-					"{AudioTrak,Prodigy 7.1 LT},"
+					"{AudioTrak,Prodigy 7.1 LT},"\
+					"{AudioTrak,Prodigy 7.1 XT},"
 
 #define VT1724_SUBDEVICE_AUREON51_SKY	0x3b154711	/* Aureon 5.1 Sky */
 #define VT1724_SUBDEVICE_AUREON71_SPACE	0x3b154511	/* Aureon 7.1 Space */
 #define VT1724_SUBDEVICE_AUREON71_UNIVERSE	0x3b155311	/* Aureon 7.1 Universe */
 #define VT1724_SUBDEVICE_PRODIGY71	0x33495345	/* PRODIGY 7.1 */
 #define VT1724_SUBDEVICE_PRODIGY71LT	0x32315441	/* PRODIGY 7.1 LT */
+#define VT1724_SUBDEVICE_PRODIGY71XT	0x36315441	/* PRODIGY 7.1 XT*/
 
-extern struct snd_ice1712_card_info  snd_vt1724_aureon_cards[];
+extern const struct snd_ice1712_card_info  snd_vt1724_aureon_cards[];
 
 /* GPIO bits */
 #define AUREON_CS8415_CS	(1 << 22)
--- linux-2.6.18.noarch/sound/pci/ice1712/hoontech.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/hoontech.h	2007-06-05 17:46:52.000000000 -0400
@@ -35,7 +35,7 @@
 #define ICE1712_SUBDEVICE_STDSP24_MEDIA7_1	0x16141217	/* Hoontech ST Audio DSP24 Media 7.1 */
 #define ICE1712_SUBDEVICE_EVENT_EZ8		0x00010001	/* A dummy id for EZ8 */
 
-extern struct snd_ice1712_card_info snd_ice1712_hoontech_cards[];
+extern const struct snd_ice1712_card_info snd_ice1712_hoontech_cards[];
 
 
 /* Hoontech SoundTrack Audio DSP 24 GPIO definitions */
--- linux-2.6.18.noarch/sound/pci/ice1712/ice1724.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/ice1724.c	2007-06-05 17:46:52.000000000 -0400
@@ -50,7 +50,7 @@
 #include "prodigy192.h"
 #include "juli.h"
 #include "phase.h"
-
+#include "wtm.h"
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("VIA ICEnsemble ICE1724/1720 (Envy24HT/PT)");
@@ -64,6 +64,7 @@
 	       PRODIGY192_DEVICE_DESC
 	       JULI_DEVICE_DESC
 	       PHASE_DEVICE_DESC
+	       WTM_DEVICE_DESC
 		"{VIA,VT1720},"
 		"{VIA,VT1724},"
 		"{ICEnsemble,Generic ICE1724},"
@@ -86,7 +87,7 @@
 
 
 /* Both VT1720 and VT1724 have the same PCI IDs */
-static struct pci_device_id snd_vt1724_ids[] = {
+static const struct pci_device_id snd_vt1724_ids[] = {
 	{ PCI_VENDOR_ID_ICE, PCI_DEVICE_ID_VT1724, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 	{ 0, }
 };
@@ -341,7 +342,7 @@
 
 	what = 0;
 	snd_pcm_group_for_each(pos, substream) {
-		struct vt1724_pcm_reg *reg;
+		const struct vt1724_pcm_reg *reg;
 		s = snd_pcm_group_substream_entry(pos);
 		reg = s->runtime->private_data;
 		what |= reg->start;
@@ -605,7 +606,7 @@
 static int snd_vt1724_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_ice1712 *ice = snd_pcm_substream_chip(substream);
-	struct vt1724_pcm_reg *reg = substream->runtime->private_data;
+	const struct vt1724_pcm_reg *reg = substream->runtime->private_data;
 
 	spin_lock_irq(&ice->reg_lock);
 	outl(substream->runtime->dma_addr, ice->profi_port + reg->addr);
@@ -620,7 +621,7 @@
 static snd_pcm_uframes_t snd_vt1724_pcm_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_ice1712 *ice = snd_pcm_substream_chip(substream);
-	struct vt1724_pcm_reg *reg = substream->runtime->private_data;
+	const struct vt1724_pcm_reg *reg = substream->runtime->private_data;
 	size_t ptr;
 
 	if (!(inl(ICEMT1724(ice, DMA_CONTROL)) & reg->start))
@@ -646,21 +647,21 @@
 #endif
 }
 
-static struct vt1724_pcm_reg vt1724_playback_pro_reg = {
+static const struct vt1724_pcm_reg vt1724_playback_pro_reg = {
 	.addr = VT1724_MT_PLAYBACK_ADDR,
 	.size = VT1724_MT_PLAYBACK_SIZE,
 	.count = VT1724_MT_PLAYBACK_COUNT,
 	.start = VT1724_PDMA0_START,
 };
 
-static struct vt1724_pcm_reg vt1724_capture_pro_reg = {
+static const struct vt1724_pcm_reg vt1724_capture_pro_reg = {
 	.addr = VT1724_MT_CAPTURE_ADDR,
 	.size = VT1724_MT_CAPTURE_SIZE,
 	.count = VT1724_MT_CAPTURE_COUNT,
 	.start = VT1724_RDMA0_START,
 };
 
-static struct snd_pcm_hardware snd_vt1724_playback_pro =
+static const struct snd_pcm_hardware snd_vt1724_playback_pro =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -679,7 +680,7 @@
 	.periods_max =		1024,
 };
 
-static struct snd_pcm_hardware snd_vt1724_spdif =
+static const struct snd_pcm_hardware snd_vt1724_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -701,7 +702,7 @@
 	.periods_max =		1024,
 };
 
-static struct snd_pcm_hardware snd_vt1724_2ch_stereo =
+static const struct snd_pcm_hardware snd_vt1724_2ch_stereo =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -773,7 +774,7 @@
 	struct snd_ice1712 *ice = snd_pcm_substream_chip(substream);
 	int chs;
 
-	runtime->private_data = &vt1724_playback_pro_reg;
+	runtime->private_data = (void *)&vt1724_playback_pro_reg;
 	ice->playback_pro_substream = substream;
 	runtime->hw = snd_vt1724_playback_pro;
 	snd_pcm_set_sync(substream);
@@ -802,7 +803,7 @@
 	struct snd_ice1712 *ice = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	runtime->private_data = &vt1724_capture_pro_reg;
+	runtime->private_data = (void *)&vt1724_capture_pro_reg;
 	ice->capture_pro_substream = substream;
 	runtime->hw = snd_vt1724_2ch_stereo;
 	snd_pcm_set_sync(substream);
@@ -888,14 +889,14 @@
  * SPDIF PCM
  */
 
-static struct vt1724_pcm_reg vt1724_playback_spdif_reg = {
+static const struct vt1724_pcm_reg vt1724_playback_spdif_reg = {
 	.addr = VT1724_MT_PDMA4_ADDR,
 	.size = VT1724_MT_PDMA4_SIZE,
 	.count = VT1724_MT_PDMA4_COUNT,
 	.start = VT1724_PDMA4_START,
 };
 
-static struct vt1724_pcm_reg vt1724_capture_spdif_reg = {
+static const struct vt1724_pcm_reg vt1724_capture_spdif_reg = {
 	.addr = VT1724_MT_RDMA1_ADDR,
 	.size = VT1724_MT_RDMA1_SIZE,
 	.count = VT1724_MT_RDMA1_COUNT,
@@ -953,7 +954,7 @@
 	struct snd_ice1712 *ice = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	runtime->private_data = &vt1724_playback_spdif_reg;
+	runtime->private_data = (void *)&vt1724_playback_spdif_reg;
 	ice->playback_con_substream = substream;
 	if (ice->force_pdma4) {
 		runtime->hw = snd_vt1724_2ch_stereo;
@@ -985,7 +986,7 @@
 	struct snd_ice1712 *ice = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	runtime->private_data = &vt1724_capture_spdif_reg;
+	runtime->private_data = (void *)&vt1724_capture_spdif_reg;
 	ice->capture_con_substream = substream;
 	if (ice->force_rdma1) {
 		runtime->hw = snd_vt1724_2ch_stereo;
@@ -1090,7 +1091,7 @@
  * independent surround PCMs
  */
 
-static struct vt1724_pcm_reg vt1724_playback_dma_regs[3] = {
+static const struct vt1724_pcm_reg vt1724_playback_dma_regs[3] = {
 	{
 		.addr = VT1724_MT_PDMA1_ADDR,
 		.size = VT1724_MT_PDMA1_SIZE,
@@ -1136,7 +1137,7 @@
 		return -EBUSY; /* FIXME: should handle blocking mode properly */
 	}
 	mutex_unlock(&ice->open_mutex);
-	runtime->private_data = &vt1724_playback_dma_regs[substream->number];
+	runtime->private_data = (void *)&vt1724_playback_dma_regs[substream->number];
 	ice->playback_con_substream_ds[substream->number] = substream;
 	runtime->hw = snd_vt1724_2ch_stereo;
 	snd_pcm_set_sync(substream);
@@ -1317,7 +1318,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_vt1724_eeprom __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_eeprom __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
 	.name = "ICE1724 EEPROM",
 	.access = SNDRV_CTL_ELEM_ACCESS_READ,
@@ -1430,7 +1431,7 @@
 	return (val != old);
 }
 
-static struct snd_kcontrol_new snd_vt1724_spdif_default __devinitdata =
+static const struct snd_kcontrol_new snd_vt1724_spdif_default __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -1462,7 +1463,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_vt1724_spdif_maskc __devinitdata =
+static const struct snd_kcontrol_new snd_vt1724_spdif_maskc __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1471,7 +1472,7 @@
 	.get =		snd_vt1724_spdif_maskc_get,
 };
 
-static struct snd_kcontrol_new snd_vt1724_spdif_maskp __devinitdata =
+static const struct snd_kcontrol_new snd_vt1724_spdif_maskp __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1516,7 +1517,7 @@
 	return old != val;
 }
 
-static struct snd_kcontrol_new snd_vt1724_spdif_switch __devinitdata =
+static const struct snd_kcontrol_new snd_vt1724_spdif_switch __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	/* FIXME: the following conflict with IEC958 Playback Route */
@@ -1584,7 +1585,7 @@
 static int snd_vt1724_pro_internal_clock_info(struct snd_kcontrol *kcontrol,
 					      struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts_1724[] = {
+	static const char * const texts_1724[] = {
 		"8000",		/* 0: 6 */
 		"9600",		/* 1: 3 */
 		"11025",	/* 2: 10 */
@@ -1602,7 +1603,7 @@
 		"192000",	/* 14: 14 */
 		"IEC958 Input",	/* 15: -- */
 	};
-	static char *texts_1720[] = {
+	static const char * const texts_1720[] = {
 		"8000",		/* 0: 6 */
 		"9600",		/* 1: 3 */
 		"11025",	/* 2: 10 */
@@ -1635,7 +1636,7 @@
 					     struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
-	static unsigned char xlate[16] = {
+	static const unsigned char xlate[16] = {
 		9, 6, 3, 1, 7, 4, 0, 12, 8, 5, 2, 11, 13, 255, 14, 10
 	};
 	unsigned char val;
@@ -1694,7 +1695,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_vt1724_pro_internal_clock __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_pro_internal_clock __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Internal Clock",
 	.info = snd_vt1724_pro_internal_clock_info,
@@ -1733,7 +1734,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_vt1724_pro_rate_locking __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_pro_rate_locking __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Rate Locking",
 	.info = snd_vt1724_pro_rate_locking_info,
@@ -1772,7 +1773,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new snd_vt1724_pro_rate_reset __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_pro_rate_reset __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Rate Reset",
 	.info = snd_vt1724_pro_rate_reset_info,
@@ -1816,7 +1817,7 @@
 {
 	unsigned long val;
 	unsigned char eitem;
-	static unsigned char xlate[8] = {
+	static const unsigned char xlate[8] = {
 		0, 255, 1, 2, 255, 255, 3, 4,
 	};
 
@@ -1835,7 +1836,7 @@
 {
 	unsigned int old_val, nval;
 	int change;
-	static unsigned char xroute[8] = {
+	static const unsigned char xroute[8] = {
 		0, /* PCM */
 		2, /* PSDIN0 Left */
 		3, /* PSDIN0 Right */
@@ -1891,7 +1892,7 @@
 			     digital_route_shift(idx));
 }
 
-static struct snd_kcontrol_new snd_vt1724_mixer_pro_analog_route __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_mixer_pro_analog_route __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "H/W Playback Route",
 	.info = snd_vt1724_pro_route_info,
@@ -1899,7 +1900,7 @@
 	.put = snd_vt1724_pro_route_analog_put,
 };
 
-static struct snd_kcontrol_new snd_vt1724_mixer_pro_spdif_route __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_mixer_pro_spdif_route __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = SNDRV_CTL_NAME_IEC958("",PLAYBACK,NONE) "Route",
 	.info = snd_vt1724_pro_route_info,
@@ -1935,7 +1936,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_vt1724_mixer_pro_peak __devinitdata = {
+static const struct snd_kcontrol_new snd_vt1724_mixer_pro_peak __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Multi Track Peak",
 	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
@@ -1947,9 +1948,9 @@
  *
  */
 
-static struct snd_ice1712_card_info no_matched __devinitdata;
+static const struct snd_ice1712_card_info no_matched __devinitdata;
 
-static struct snd_ice1712_card_info *card_tables[] __devinitdata = {
+static const struct snd_ice1712_card_info *card_tables[] __devinitdata = {
 	snd_vt1724_revo_cards,
 	snd_vt1724_amp_cards, 
 	snd_vt1724_aureon_cards,
@@ -1958,6 +1959,7 @@
 	snd_vt1724_prodigy192_cards,
 	snd_vt1724_juli_cards,
 	snd_vt1724_phase_cards,
+	snd_vt1724_wtm_cards,
 	NULL,
 };
 
@@ -2007,7 +2009,7 @@
 {
 	const int dev = 0xa0;		/* EEPROM device address */
 	unsigned int i, size;
-	struct snd_ice1712_card_info **tbl, *c;
+	const struct snd_ice1712_card_info **tbl, *c;
 
 	if (! modelname || ! *modelname) {
 		ice->eeprom.subvendor = 0;
@@ -2306,7 +2308,7 @@
 	struct snd_card *card;
 	struct snd_ice1712 *ice;
 	int pcm_dev = 0, err;
-	struct snd_ice1712_card_info **tbl, *c;
+	const struct snd_ice1712_card_info **tbl, *c;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
--- linux-2.6.18.noarch/sound/pci/ice1712/pontis.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/pontis.h	2007-06-05 17:46:52.000000000 -0400
@@ -28,6 +28,6 @@
 
 #define VT1720_SUBDEVICE_PONTIS_MS300	0x00020002	/* a dummy id for MS300 */
 
-extern struct snd_ice1712_card_info  snd_vt1720_pontis_cards[];
+extern const struct snd_ice1712_card_info  snd_vt1720_pontis_cards[];
 
 #endif /* __SOUND_PONTIS_H */
--- linux-2.6.18.noarch/sound/pci/ice1712/amp.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/amp.c	2007-06-05 17:46:52.000000000 -0400
@@ -42,7 +42,7 @@
 
 static int __devinit snd_vt1724_amp_init(struct snd_ice1712 *ice)
 {
-	static unsigned short wm_inits[] = {
+	static const unsigned short wm_inits[] = {
 		WM_ATTEN_L,	0x0000,	/* 0 db */
 		WM_ATTEN_R,	0x0000,	/* 0 db */
 		WM_DAC_CTRL,	0x0008,	/* 24bit I2S */
@@ -75,7 +75,7 @@
 
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1724_amp_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1724_amp_cards[] __devinitdata = {
 	{
 		.subvendor = VT1724_SUBDEVICE_AV710,
 		.name = "Chaintech AV-710",
--- linux-2.6.18.noarch/sound/pci/ice1712/wtm.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/wtm.c	2007-06-05 17:46:52.000000000 -0400
@@ -0,0 +1,542 @@
+/*
+ *	ALSA driver for ICEnsemble VT1724 (Envy24HT)
+ *	
+ *	Lowlevel functions for Ego Sys Waveterminal 192M
+ *
+ *		Copyright (c) 2006 Guedez Clement <klem.dev@gmail.com>
+ *		Some functions are taken from the Prodigy192 driver
+ *		source
+ *		
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *	
+ */	
+
+
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+
+#include "ice1712.h"
+#include "envy24ht.h"
+#include "wtm.h"
+#include "stac946x.h"
+
+
+/*
+ *	2*ADC 6*DAC no1 ringbuffer r/w on i2c bus 
+ */
+static inline void stac9460_put(struct snd_ice1712 *ice, int reg, 
+						unsigned char val)
+{
+	snd_vt1724_write_i2c(ice, STAC9460_I2C_ADDR, reg, val);
+}
+
+static inline unsigned char stac9460_get(struct snd_ice1712 *ice, int reg)
+{
+	return snd_vt1724_read_i2c(ice, STAC9460_I2C_ADDR, reg);
+}
+
+/*
+ *	2*ADC 2*DAC no2 ringbuffer r/w on i2c bus
+ */
+static inline void stac9460_2_put(struct snd_ice1712 *ice, int reg,
+						unsigned char val)
+{
+	snd_vt1724_write_i2c(ice, STAC9460_2_I2C_ADDR, reg, val);
+}
+
+static inline unsigned char stac9460_2_get(struct snd_ice1712 *ice, int reg)
+{
+	return snd_vt1724_read_i2c(ice, STAC9460_2_I2C_ADDR, reg);
+}
+
+
+/*
+ *	DAC mute control
+ */
+static int stac9460_dac_mute_info(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	return 0;
+}
+
+static int stac9460_dac_mute_get(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int idx, id;
+
+	if (kcontrol->private_value) {
+		idx = STAC946X_MASTER_VOLUME;
+		id = 0;
+	} else {
+		id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+		idx = id + STAC946X_LF_VOLUME;
+	}
+	if (id < 6)
+		val = stac9460_get(ice, idx);
+	else 
+		val = stac9460_2_get(ice,idx - 6);
+	ucontrol->value.integer.value[0] = (~val >> 7) & 0x1;
+	return 0;
+}
+
+static int stac9460_dac_mute_put(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char new, old;
+	int id, idx;
+	int change;
+
+	if (kcontrol->private_value) {
+		idx = STAC946X_MASTER_VOLUME;
+		old = stac9460_get(ice, idx);
+		new = (~ucontrol->value.integer.value[0]<< 7 & 0x80) |
+		       					(old & ~0x80);
+		change = (new != old);
+		if (change) {
+			stac9460_put(ice, idx, new);
+			stac9460_2_put(ice, idx, new);
+		}
+	} else {
+		id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+		idx = id + STAC946X_LF_VOLUME;
+		if (id < 6)
+			old = stac9460_get(ice, idx);
+		else 
+			old = stac9460_2_get(ice, idx - 6);
+		new = (~ucontrol->value.integer.value[0]<< 7 & 0x80) |
+							(old & ~0x80);
+		change = (new != old);
+		if (change) {
+			if (id < 6)
+			       	stac9460_put(ice, idx, new);
+			else
+			       	stac9460_2_put(ice, idx - 6, new);
+		}
+	}
+	return change;
+}
+
+/*
+ * 	DAC volume attenuation mixer control
+ */
+static int stac9460_dac_vol_info(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;			/* mute */
+	uinfo->value.integer.max = 0x7f;		/* 0dB */
+	return 0;
+}
+
+static int stac9460_dac_vol_get(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	int idx, id;
+	unsigned char vol;
+
+	if (kcontrol->private_value) {
+		idx = STAC946X_MASTER_VOLUME;
+		id = 0;
+	} else {
+		id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+		idx = id + STAC946X_LF_VOLUME;
+	}
+	if (id < 6)
+		vol = stac9460_get(ice, idx) & 0x7f;
+	else 
+		vol = stac9460_2_get(ice, idx - 6) & 0x7f;
+	ucontrol->value.integer.value[0] = 0x7f - vol;
+	return 0;
+}
+
+static int stac9460_dac_vol_put(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	int idx, id;
+	unsigned char tmp, ovol, nvol;
+	int change;
+
+	if (kcontrol->private_value) {
+		idx = STAC946X_MASTER_VOLUME;
+		nvol = ucontrol->value.integer.value[0];
+		tmp = stac9460_get(ice, idx);
+		ovol = 0x7f - (tmp & 0x7f);
+		change = (ovol != nvol);
+		if (change) {
+			 stac9460_put(ice, idx, (0x7f - nvol) | (tmp & 0x80));
+			 stac9460_2_put(ice, idx, (0x7f - nvol) | (tmp & 0x80));
+		}
+	} else {
+		id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+		idx = id + STAC946X_LF_VOLUME;
+		nvol = ucontrol->value.integer.value[0];
+		if (id < 6)
+			tmp = stac9460_get(ice, idx);
+		else 
+			tmp = stac9460_2_get(ice, idx - 6);
+		ovol = 0x7f - (tmp & 0x7f);
+		change = (ovol != nvol);
+		if (change) {
+			if (id < 6)
+				stac9460_put(ice, idx, (0x7f - nvol) |
+					       		(tmp & 0x80));
+			else 
+				stac9460_2_put(ice, idx-6, (0x7f - nvol) |
+					       			(tmp & 0x80));
+		}
+	}
+	return change;
+}
+
+/*
+ * ADC mute control
+ */
+static int stac9460_adc_mute_info(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int stac9460_adc_mute_get(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int i, id;
+	
+	id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	if (id == 0) {
+		for (i = 0; i < 2; ++i) {
+			val = stac9460_get(ice, STAC946X_MIC_L_VOLUME + i);
+			ucontrol->value.integer.value[i] = ~val>>7 & 0x1;
+		}
+	} else {
+		for (i = 0; i < 2; ++i) {
+			val = stac9460_2_get(ice, STAC946X_MIC_L_VOLUME + i);
+			ucontrol->value.integer.value[i] = ~val>>7 & 0x1;
+		}
+	}
+	return 0;
+}
+
+static int stac9460_adc_mute_put(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char new, old;
+	int i, reg, id;
+	int change;
+	
+	id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	if (id == 0) {
+		for (i = 0; i < 2; ++i) {
+			reg = STAC946X_MIC_L_VOLUME + i;
+			old = stac9460_get(ice, reg);
+			new = (~ucontrol->value.integer.value[i]<<7&0x80) |
+			       					(old&~0x80);
+			change = (new != old);
+			if (change)
+				stac9460_put(ice, reg, new);
+		}
+	} else {
+		for (i = 0; i < 2; ++i) {
+			reg = STAC946X_MIC_L_VOLUME + i;
+			old = stac9460_2_get(ice, reg);
+			new = (~ucontrol->value.integer.value[i]<<7&0x80) |
+			       					(old&~0x80);
+			change = (new != old);
+			if (change)
+				stac9460_2_put(ice, reg, new);
+		}
+	}
+	return change;
+}
+
+/*
+ *ADC gain mixer control
+ */
+static int stac9460_adc_vol_info(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;		/* 0dB */
+	uinfo->value.integer.max = 0x0f;	/* 22.5dB */
+	return 0;
+}
+
+static int stac9460_adc_vol_get(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	int i, reg, id;
+	unsigned char vol;
+	
+	id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	if (id == 0) {
+		for (i = 0; i < 2; ++i) {
+			reg = STAC946X_MIC_L_VOLUME + i;
+			vol = stac9460_get(ice, reg) & 0x0f;
+			ucontrol->value.integer.value[i] = 0x0f - vol;
+		}
+	} else {
+		for (i = 0; i < 2; ++i) {
+			reg = STAC946X_MIC_L_VOLUME + i;
+			vol = stac9460_2_get(ice, reg) & 0x0f;
+			ucontrol->value.integer.value[i] = 0x0f - vol;
+		}
+	}
+	return 0;
+}
+
+static int stac9460_adc_vol_put(struct snd_kcontrol *kcontrol,
+	       		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	int i, reg, id;
+	unsigned char ovol, nvol;
+	int change;
+	
+	id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	if (id == 0) {
+		for (i = 0; i < 2; ++i) {
+			reg = STAC946X_MIC_L_VOLUME + i;
+			nvol = ucontrol->value.integer.value[i];
+			ovol = 0x0f - stac9460_get(ice, reg);
+			change = ((ovol & 0x0f) != nvol);
+			if (change)
+				stac9460_put(ice, reg, (0x0f - nvol) |
+					       		(ovol & ~0x0f));
+		}
+	} else {
+		for (i = 0; i < 2; ++i) {
+			reg = STAC946X_MIC_L_VOLUME + i;
+			nvol = ucontrol->value.integer.value[i];
+			ovol = 0x0f - stac9460_2_get(ice, reg);
+			change = ((ovol & 0x0f) != nvol);
+			if (change)
+				stac9460_2_put(ice, reg, (0x0f - nvol) |
+					       		(ovol & ~0x0f));
+		}
+	}
+	return change;
+}
+
+/*
+ * MIC / LINE switch fonction
+ */
+
+static int stac9460_mic_sw_info(struct snd_kcontrol *kcontrol,
+	       			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int stac9460_mic_sw_get(struct snd_kcontrol *kcontrol,
+	       		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int id;
+		
+	id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	if (id == 0)
+	       	val = stac9460_get(ice, STAC946X_GENERAL_PURPOSE);
+	else
+	       	val = stac9460_2_get(ice, STAC946X_GENERAL_PURPOSE);
+	ucontrol->value.integer.value[0] = ~val>>7 & 0x1;
+	return 0;
+}
+
+static int stac9460_mic_sw_put(struct snd_kcontrol *kcontrol,
+	       		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
+	unsigned char new, old;
+	int change, id;
+
+	id = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
+	if (id == 0)
+	       	old = stac9460_get(ice, STAC946X_GENERAL_PURPOSE);
+	else
+	       	old = stac9460_2_get(ice, STAC946X_GENERAL_PURPOSE);
+	new = (~ucontrol->value.integer.value[0]<< 7 & 0x80) | (old & ~0x80);
+	change = (new != old);
+	if (change) {
+		if (id == 0)
+		       	stac9460_put(ice, STAC946X_GENERAL_PURPOSE, new);
+		else
+		       	stac9460_2_put(ice, STAC946X_GENERAL_PURPOSE, new);
+	}
+	return change;
+}
+
+/*
+ * Control tabs
+ */
+static const struct snd_kcontrol_new stac9640_controls[] __devinitdata = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Switch",
+		.info = stac9460_dac_mute_info,
+		.get = stac9460_dac_mute_get,
+		.put = stac9460_dac_mute_put,
+		.private_value = 1
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Master Playback Volume",
+		.info = stac9460_dac_vol_info,
+		.get = stac9460_dac_vol_get,
+		.put = stac9460_dac_vol_put,
+		.private_value = 1,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "MIC/Line switch",
+		.count = 2,
+		.info = stac9460_mic_sw_info,
+		.get = stac9460_mic_sw_get,
+		.put = stac9460_mic_sw_put,
+
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "DAC Switch",
+		.count = 8,
+		.info = stac9460_dac_mute_info,
+		.get = stac9460_dac_mute_get,
+		.put = stac9460_dac_mute_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "DAC Volume",
+		.count = 8,
+		.info = stac9460_dac_vol_info,
+		.get = stac9460_dac_vol_get,
+		.put = stac9460_dac_vol_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Switch",
+		.count = 2,
+		.info = stac9460_adc_mute_info,
+		.get = stac9460_adc_mute_get,
+		.put = stac9460_adc_mute_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Volume",
+		.count = 2,
+		.info = stac9460_adc_vol_info,
+		.get = stac9460_adc_vol_get,
+		.put = stac9460_adc_vol_put,
+
+	}	
+};
+
+
+
+/*INIT*/
+static int __devinit wtm_add_controls(struct snd_ice1712 *ice)
+{
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(stac9640_controls); i++) {
+		err = snd_ctl_add(ice->card,
+				snd_ctl_new1(&stac9640_controls[i], ice));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static int __devinit wtm_init(struct snd_ice1712 *ice)
+{
+	static unsigned short stac_inits_prodigy[] = {
+		STAC946X_RESET, 0,
+		(unsigned short)-1
+	};
+	unsigned short *p;
+		
+	/*WTM 192M*/
+	ice->num_total_dacs = 8;
+	ice->num_total_adcs = 4;
+	ice->force_rdma1 = 1;
+
+	/*initialize codec*/
+	p = stac_inits_prodigy;
+	for (; *p != (unsigned short)-1; p += 2) {
+		stac9460_put(ice, p[0], p[1]);
+		stac9460_2_put(ice, p[0], p[1]);
+	}
+	return 0;
+}
+
+
+static unsigned char wtm_eeprom[] __devinitdata = {
+	0x47,	/*SYSCONF: clock 192KHz, 4ADC, 8DAC */
+	0x80,	/* ACLINK : I2S */
+	0xf8,	/* I2S: vol; 96k, 24bit, 192k */
+	0xc1	/*SPDIF: out-en, spidf ext out*/,
+	0x9f,	/* GPIO_DIR */
+	0xff,	/* GPIO_DIR1 */
+	0x7f,	/* GPIO_DIR2 */
+	0x9f,	/* GPIO_MASK */
+	0xff,	/* GPIO_MASK1 */
+	0x7f,	/* GPIO_MASK2 */
+	0x16,	/* GPIO_STATE */
+	0x80,	/* GPIO_STATE1 */
+	0x00,	/* GPIO_STATE2 */
+};
+
+
+/*entry point*/
+struct snd_ice1712_card_info snd_vt1724_wtm_cards[] __devinitdata = {
+	{
+		.subvendor = VT1724_SUBDEVICE_WTM,
+		.name = "ESI Waveterminal 192M",
+		.model = "WT192M",
+		.chip_init = wtm_init,
+		.build_controls = wtm_add_controls,
+		.eeprom_size = sizeof(wtm_eeprom),
+		.eeprom_data = wtm_eeprom,
+	},
+	{} /*terminator*/
+};
--- linux-2.6.18.noarch/sound/pci/ice1712/juli.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/juli.c	2007-06-05 17:46:52.000000000 -0400
@@ -125,7 +125,7 @@
 	snd_akm4xxx_reset(ak, 0);
 }
 
-static struct snd_akm4xxx akm_juli_dac __devinitdata = {
+static const struct snd_akm4xxx akm_juli_dac __devinitdata = {
 	.type = SND_AK4358,
 	.num_dacs = 2,
 	.ops = {
@@ -146,7 +146,7 @@
  */
 static int __devinit juli_init(struct snd_ice1712 *ice)
 {
-	static unsigned char ak4114_init_vals[] = {
+	static const unsigned char ak4114_init_vals[] = {
 		/* AK4117_REG_PWRDN */	AK4114_RST | AK4114_PWN | AK4114_OCKS0 | AK4114_OCKS1,
 		/* AK4114_REQ_FORMAT */	AK4114_DIF_I24I2S,
 		/* AK4114_REG_IO0 */	AK4114_TX1E,
@@ -154,7 +154,7 @@
 		/* AK4114_REG_INT0_MASK */ 0,
 		/* AK4114_REG_INT1_MASK */ 0
 	};
-	static unsigned char ak4114_init_txcsb[] = {
+	static const unsigned char ak4114_init_txcsb[] = {
 		0x41, 0x02, 0x2c, 0x00, 0x00
 	};
 	int err;
@@ -206,24 +206,24 @@
  * hence the driver needs to sets up it properly.
  */
 
-static unsigned char juli_eeprom[] __devinitdata = {
-	0x20,	/* SYSCONF: clock 512, mpu401, 1xADC, 1xDACs */
-	0x80,	/* ACLINK: I2S */
-	0xf8,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0x9f,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x7f,	/* GPIO_DIR2 */
-	0x9f,	/* GPIO_MASK */
-	0xff,	/* GPIO_MASK1 */
-	0x7f,	/* GPIO_MASK2 */
-	0x16,	/* GPIO_STATE: internal clock, multiple 1x, 48kHz */
-	0x80,	/* GPIO_STATE1: mute */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char juli_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x20,	/* clock 512, mpu401, 1xADC, 1xDACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xf8,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0x9f,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x7f,
+	[ICE_EEP2_GPIO_MASK]   = 0x9f,
+	[ICE_EEP2_GPIO_MASK1]  = 0xff,
+	[ICE_EEP2_GPIO_MASK2]  = 0x7f,
+	[ICE_EEP2_GPIO_STATE]  = 0x16,	/* internal clock, multiple 1x, 48kHz */
+	[ICE_EEP2_GPIO_STATE1] = 0x80,	/* mute */
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1724_juli_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1724_juli_cards[] __devinitdata = {
 	{
 		.subvendor = VT1724_SUBDEVICE_JULI,
 		.name = "ESI Juli@",
--- linux-2.6.18.noarch/sound/pci/ice1712/pontis.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/pontis.c	2007-06-05 17:46:52.000000000 -0400
@@ -31,6 +31,7 @@
 
 #include <sound/core.h>
 #include <sound/info.h>
+#include <sound/tlv.h>
 
 #include "ice1712.h"
 #include "envy24ht.h"
@@ -433,7 +434,7 @@
  */
 static int cs_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {
+	static const char * const texts[] = {
 		"Coax",		/* RXP0 */
 		"Optical",	/* RXP1 */
 		"CD",		/* RXP2 */
@@ -564,24 +565,32 @@
 	return changed;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_volume, -6400, 50, 1);
+
 /*
  * mixers
  */
 
-static struct snd_kcontrol_new pontis_controls[] __devinitdata = {
+static const struct snd_kcontrol_new pontis_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "PCM Playback Volume",
 		.info = wm_dac_vol_info,
 		.get = wm_dac_vol_get,
 		.put = wm_dac_vol_put,
+		.tlv = { .p = db_scale_volume },
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Capture Volume",
 		.info = wm_adc_vol_info,
 		.get = wm_adc_vol_get,
 		.put = wm_adc_vol_put,
+		.tlv = { .p = db_scale_volume },
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -732,7 +741,7 @@
  */
 static int __devinit pontis_init(struct snd_ice1712 *ice)
 {
-	static unsigned short wm_inits[] = {
+	static const unsigned short wm_inits[] = {
 		/* These come first to reduce init pop noise */
 		WM_ADC_MUX,	0x00c0,	/* ADC mute */
 		WM_DAC_MUTE,	0x0001,	/* DAC softmute */
@@ -741,7 +750,7 @@
 		WM_POWERDOWN,	0x0008,	/* All power-up except HP */
 		WM_RESET,	0x0000,	/* reset */
 	};
-	static unsigned short wm_inits2[] = {
+	static const unsigned short wm_inits2[] = {
 		WM_MASTER_CTRL,	0x0022,	/* 256fs, slave mode */
 		WM_DAC_INT,	0x0022,	/* I2S, normal polarity, 24bit */
 		WM_ADC_INT,	0x0022,	/* I2S, normal polarity, 24bit */
@@ -767,7 +776,7 @@
 		WM_DAC_MUTE,	0x0000,	/* DAC unmute */
 		WM_ADC_MUX,	0x0003,	/* ADC unmute, both CD/Line On */
 	};
-	static unsigned char cs_inits[] = {
+	static const unsigned char cs_inits[] = {
 		0x04,	0x80,	/* RUN, RXP0 */
 		0x05,	0x05,	/* slave, 24bit */
 		0x01,	0x00,
@@ -817,24 +826,24 @@
  * hence the driver needs to sets up it properly.
  */
 
-static unsigned char pontis_eeprom[] __devinitdata = {
-	0x08,	/* SYSCONF: clock 256, mpu401, spdif-in/ADC, 1DAC */
-	0x80,	/* ACLINK: I2S */
-	0xf8,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0x07,	/* GPIO_DIR */
-	0x00,	/* GPIO_DIR1 */
-	0x00,	/* GPIO_DIR2 (ignored) */
-	0x0f,	/* GPIO_MASK (4-7 reserved for CS8416) */
-	0xff,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 (ignored) */
-	0x06,	/* GPIO_STATE (0-low, 1-high, 2-high) */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 (ignored) */
+static const unsigned char pontis_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x08,	/* clock 256, mpu401, spdif-in/ADC, 1DAC */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xf8,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0x07,
+	[ICE_EEP2_GPIO_DIR1]   = 0x00,
+	[ICE_EEP2_GPIO_DIR2]   = 0x00,	/* ignored */
+	[ICE_EEP2_GPIO_MASK]   = 0x0f,	/* 4-7 reserved for CS8416 */
+	[ICE_EEP2_GPIO_MASK1]  = 0xff,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,	/* ignored */
+	[ICE_EEP2_GPIO_STATE]  = 0x06,	/* 0-low, 1-high, 2-high */
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,	/* ignored */
 };
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1720_pontis_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1720_pontis_cards[] __devinitdata = {
 	{
 		.subvendor = VT1720_SUBDEVICE_PONTIS_MS300,
 		.name = "Pontis MS300",
--- linux-2.6.18.noarch/sound/pci/ice1712/delta.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/delta.c	2007-06-05 17:46:52.000000000 -0400
@@ -416,7 +416,7 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_ice1712_delta1010lt_wordclock_status __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_delta1010lt_wordclock_status __devinitdata =
 {
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READ),
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -429,7 +429,7 @@
  * initialize the chips on M-Audio cards
  */
 
-static struct snd_akm4xxx akm_audiophile __devinitdata = {
+static const struct snd_akm4xxx akm_audiophile __devinitdata = {
 	.type = SND_AK4528,
 	.num_adcs = 2,
 	.num_dacs = 2,
@@ -438,7 +438,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_audiophile_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_audiophile_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 0,
 	.data_mask = ICE1712_DELTA_AP_DOUT,
@@ -450,7 +450,7 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_delta410 __devinitdata = {
+static const struct snd_akm4xxx akm_delta410 __devinitdata = {
 	.type = SND_AK4529,
 	.num_adcs = 2,
 	.num_dacs = 8,
@@ -459,7 +459,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_delta410_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_delta410_priv __devinitdata = {
 	.caddr = 0,
 	.cif = 0,
 	.data_mask = ICE1712_DELTA_AP_DOUT,
@@ -471,7 +471,7 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_delta1010lt __devinitdata = {
+static const struct snd_akm4xxx akm_delta1010lt __devinitdata = {
 	.type = SND_AK4524,
 	.num_adcs = 8,
 	.num_dacs = 8,
@@ -481,7 +481,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_delta1010lt_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_delta1010lt_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 0, /* the default level of the CIF pin from AK4524 */
 	.data_mask = ICE1712_DELTA_1010LT_DOUT,
@@ -493,7 +493,7 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_delta44 __devinitdata = {
+static const struct snd_akm4xxx akm_delta44 __devinitdata = {
 	.type = SND_AK4524,
 	.num_adcs = 4,
 	.num_dacs = 4,
@@ -503,7 +503,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_delta44_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_delta44_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 0, /* the default level of the CIF pin from AK4524 */
 	.data_mask = ICE1712_DELTA_CODEC_SERIAL_DATA,
@@ -515,7 +515,7 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_vx442 __devinitdata = {
+static const struct snd_akm4xxx akm_vx442 __devinitdata = {
 	.type = SND_AK4524,
 	.num_adcs = 4,
 	.num_dacs = 4,
@@ -525,7 +525,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_vx442_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_vx442_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 0,
 	.data_mask = ICE1712_VX442_DOUT,
@@ -650,15 +650,15 @@
  * additional controls for M-Audio cards
  */
 
-static struct snd_kcontrol_new snd_ice1712_delta1010_wordclock_select __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_delta1010_wordclock_select __devinitdata =
 ICE1712_GPIO(SNDRV_CTL_ELEM_IFACE_MIXER, "Word Clock Sync", 0, ICE1712_DELTA_WORD_CLOCK_SELECT, 1, 0);
-static struct snd_kcontrol_new snd_ice1712_delta1010lt_wordclock_select __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_delta1010lt_wordclock_select __devinitdata =
 ICE1712_GPIO(SNDRV_CTL_ELEM_IFACE_MIXER, "Word Clock Sync", 0, ICE1712_DELTA_1010LT_WORDCLOCK, 0, 0);
-static struct snd_kcontrol_new snd_ice1712_delta1010_wordclock_status __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_delta1010_wordclock_status __devinitdata =
 ICE1712_GPIO(SNDRV_CTL_ELEM_IFACE_MIXER, "Word Clock Status", 0, ICE1712_DELTA_WORD_CLOCK_STATUS, 1, SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE);
-static struct snd_kcontrol_new snd_ice1712_deltadio2496_spdif_in_select __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_deltadio2496_spdif_in_select __devinitdata =
 ICE1712_GPIO(SNDRV_CTL_ELEM_IFACE_MIXER, "IEC958 Input Optical", 0, ICE1712_DELTA_SPDIF_INPUT_SELECT, 0, 0);
-static struct snd_kcontrol_new snd_ice1712_delta_spdif_in_status __devinitdata =
+static const struct snd_kcontrol_new snd_ice1712_delta_spdif_in_status __devinitdata =
 ICE1712_GPIO(SNDRV_CTL_ELEM_IFACE_MIXER, "Delta IEC958 Input Status", 0, ICE1712_DELTA_SPDIF_IN_STAT, 1, SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE);
 
 
@@ -735,7 +735,7 @@
 
 
 /* entry point */
-struct snd_ice1712_card_info snd_ice1712_delta_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_ice1712_delta_cards[] __devinitdata = {
 	{
 		.subvendor = ICE1712_SUBDEVICE_DELTA1010,
 		.name = "M Audio Delta 1010",
--- linux-2.6.18.noarch/sound/pci/ice1712/phase.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/phase.c	2007-06-05 17:46:52.000000000 -0400
@@ -46,6 +46,7 @@
 #include "ice1712.h"
 #include "envy24ht.h"
 #include "phase.h"
+#include <sound/tlv.h>
 
 /* WM8770 registers */
 #define WM_DAC_ATTEN		0x00	/* DAC1-8 analog attenuation */
@@ -70,7 +71,7 @@
  * Logarithmic volume values for WM8770
  * Computed as 20 * Log10(255 / x)
  */
-static unsigned char wm_vol[256] = {
+static const unsigned char wm_vol[256] = {
 	127, 48, 42, 39, 36, 34, 33, 31, 30, 29, 28, 27, 27, 26, 25, 25, 24, 24, 23,
 	23, 22, 22, 21, 21, 21, 20, 20, 20, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17,
 	17, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 13, 13, 13,
@@ -88,13 +89,13 @@
 #define WM_VOL_MAX	(sizeof(wm_vol) - 1)
 #define WM_VOL_MUTE	0x8000
 
-static struct snd_akm4xxx akm_phase22 __devinitdata = {
+static const struct snd_akm4xxx akm_phase22 __devinitdata = {
 	.type = SND_AK4524,
 	.num_dacs = 2,
 	.num_adcs = 2,
 };
 
-static struct snd_ak4xxx_private akm_phase22_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_phase22_priv __devinitdata = {
 	.caddr =	2,
 	.cif =		1,
 	.data_mask =	1 << 4,
@@ -151,36 +152,36 @@
 	return 0;
 }
 
-static unsigned char phase22_eeprom[] __devinitdata = {
-	0x00,	/* SYSCONF: 1xADC, 1xDACs */
-	0x80,	/* ACLINK: I2S */
-	0xf8,	/* I2S: vol, 96k, 24bit*/
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xFF,	/* GPIO_DIR */
-	0xFF,	/* GPIO_DIR1 */
-	0xFF,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE: */
-	0x00,	/* GPIO_STATE1: */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char phase22_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x00,	/* 1xADC, 1xDACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xf8,	/* vol, 96k, 24bit */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0xff,
+	[ICE_EEP2_GPIO_MASK]   = 0x00,
+	[ICE_EEP2_GPIO_MASK1]  = 0x00,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
 
-static unsigned char phase28_eeprom[] __devinitdata = {
-	0x0b,	/* SYSCONF: clock 512, spdif-in/ADC, 4DACs */
-	0x80,	/* ACLINK: I2S */
-	0xfc,	/* I2S: vol, 96k, 24bit, 192k */
-	0xc3,	/* SPDIF: out-en, out-int, spdif-in */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x5f,	/* GPIO_DIR2 */
-	0x00,	/* GPIO_MASK */
-	0x00,	/* GPIO_MASK1 */
-	0x00,	/* GPIO_MASK2 */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* GPIO_STATE2 */
+static const unsigned char phase28_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x0b,	/* clock 512, spdif-in/ADC, 4DACs */
+	[ICE_EEP2_ACLINK]      = 0x80,	/* I2S */
+	[ICE_EEP2_I2S]         = 0xfc,	/* vol, 96k, 24bit, 192k */
+	[ICE_EEP2_SPDIF]       = 0xc3,	/* out-en, out-int, spdif-in */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x5f,
+	[ICE_EEP2_GPIO_MASK]   = 0x00,
+	[ICE_EEP2_GPIO_MASK1]  = 0x00,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,
 };
 
 /*
@@ -342,7 +343,7 @@
 
 static int __devinit phase28_init(struct snd_ice1712 *ice)
 {
-	static unsigned short wm_inits_phase28[] = {
+	static const unsigned short wm_inits_phase28[] = {
 		/* These come first to reduce init pop noise */
 		0x1b, 0x044,		/* ADC Mux (AC'97 source) */
 		0x1c, 0x00B,		/* Out Mux1 (VOUT1 = DAC+AUX, VOUT2 = DAC) */
@@ -381,7 +382,7 @@
 
 	unsigned int tmp;
 	struct snd_akm4xxx *ak;
-	unsigned short *p;
+	const unsigned short *p;
 	int i;
 
 	ice->num_total_dacs = 8;
@@ -696,7 +697,10 @@
 	return 0;
 }
 
-static struct snd_kcontrol_new phase28_dac_controls[] __devinitdata = {
+static const DECLARE_TLV_DB_SCALE(db_scale_wm_dac, -12700, 100, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_wm_pcm, -6400, 50, 1);
+
+static const struct snd_kcontrol_new phase28_dac_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Master Playback Switch",
@@ -706,10 +710,13 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Master Playback Volume",
 		.info = wm_master_vol_info,
 		.get = wm_master_vol_get,
-		.put = wm_master_vol_put
+		.put = wm_master_vol_put,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -721,11 +728,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Front Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (2 << 8) | 0
+		.private_value = (2 << 8) | 0,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -737,11 +747,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Rear Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (2 << 8) | 2
+		.private_value = (2 << 8) | 2,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -753,11 +766,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Center Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (1 << 8) | 4
+		.private_value = (1 << 8) | 4,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -769,11 +785,14 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "LFE Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (1 << 8) | 5
+		.private_value = (1 << 8) | 5,
+		.tlv = { .p = db_scale_wm_dac }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -785,15 +804,18 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "Side Playback Volume",
 		.info = wm_vol_info,
 		.get = wm_vol_get,
 		.put = wm_vol_put,
-		.private_value = (2 << 8) | 6
+		.private_value = (2 << 8) | 6,
+		.tlv = { .p = db_scale_wm_dac }
 	}
 };
 
-static struct snd_kcontrol_new wm_controls[] __devinitdata = {
+static const struct snd_kcontrol_new wm_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "PCM Playback Switch",
@@ -803,10 +825,13 @@
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 		.name = "PCM Playback Volume",
 		.info = wm_pcm_vol_info,
 		.get = wm_pcm_vol_get,
-		.put = wm_pcm_vol_put
+		.put = wm_pcm_vol_put,
+		.tlv = { .p = db_scale_wm_pcm }
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -845,7 +870,7 @@
 	return 0;
 }
 
-struct snd_ice1712_card_info snd_vt1724_phase_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1724_phase_cards[] __devinitdata = {
 	{
 		.subvendor = VT1724_SUBDEVICE_PHASE22,
 		.name = "Terratec PHASE 22",
--- linux-2.6.18.noarch/sound/pci/ice1712/delta.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/delta.h	2007-06-05 17:46:52.000000000 -0400
@@ -46,7 +46,7 @@
 #define ICE1712_SUBDEVICE_MEDIASTATION	0x694c0100
 
 /* entry point */
-extern struct snd_ice1712_card_info snd_ice1712_delta_cards[];
+extern const struct snd_ice1712_card_info snd_ice1712_delta_cards[];
 
 
 /*
--- linux-2.6.18.noarch/sound/pci/ice1712/vt1720_mobo.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/vt1720_mobo.c	2007-06-05 17:46:52.000000000 -0400
@@ -30,6 +30,7 @@
 #include <sound/core.h>
 
 #include "ice1712.h"
+#include "envy24ht.h"
 #include "vt1720_mobo.h"
 
 
@@ -55,41 +56,41 @@
 
 /* EEPROM image */
 
-static unsigned char k8x800_eeprom[] __devinitdata = {
-	0x01,	/* SYSCONF: clock 256, 1ADC, 2DACs */
-	0x02,	/* ACLINK: ACLINK, packed */
-	0x00,	/* I2S: - */
-	0x00,	/* SPDIF: - */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x00,	/* - */
-	0xff,	/* GPIO_MASK */
-	0xff,	/* GPIO_MASK1 */
-	0x00,	/* - */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* - */
+static const unsigned char k8x800_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x01,	/* clock 256, 1ADC, 2DACs */
+	[ICE_EEP2_ACLINK]      = 0x02,	/* ACLINK, packed */
+	[ICE_EEP2_I2S]         = 0x00,	/* - */
+	[ICE_EEP2_SPDIF]       = 0x00,	/* - */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x00,	/* - */
+	[ICE_EEP2_GPIO_MASK]   = 0xff,
+	[ICE_EEP2_GPIO_MASK1]  = 0xff,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,	/* - */
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,	/* - */
 };
 
-static unsigned char sn25p_eeprom[] __devinitdata = {
-	0x01,	/* SYSCONF: clock 256, 1ADC, 2DACs */
-	0x02,	/* ACLINK: ACLINK, packed */
-	0x00,	/* I2S: - */
-	0x41,	/* SPDIF: - */
-	0xff,	/* GPIO_DIR */
-	0xff,	/* GPIO_DIR1 */
-	0x00,	/* - */
-	0xff,	/* GPIO_MASK */
-	0xff,	/* GPIO_MASK1 */
-	0x00,	/* - */
-	0x00,	/* GPIO_STATE */
-	0x00,	/* GPIO_STATE1 */
-	0x00,	/* - */
+static const unsigned char sn25p_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]     = 0x01,	/* clock 256, 1ADC, 2DACs */
+	[ICE_EEP2_ACLINK]      = 0x02,	/* ACLINK, packed */
+	[ICE_EEP2_I2S]         = 0x00,	/* - */
+	[ICE_EEP2_SPDIF]       = 0x41,	/* - */
+	[ICE_EEP2_GPIO_DIR]    = 0xff,
+	[ICE_EEP2_GPIO_DIR1]   = 0xff,
+	[ICE_EEP2_GPIO_DIR2]   = 0x00,	/* - */
+	[ICE_EEP2_GPIO_MASK]   = 0xff,
+	[ICE_EEP2_GPIO_MASK1]  = 0xff,
+	[ICE_EEP2_GPIO_MASK2]  = 0x00,	/* - */
+	[ICE_EEP2_GPIO_STATE]  = 0x00,
+	[ICE_EEP2_GPIO_STATE1] = 0x00,
+	[ICE_EEP2_GPIO_STATE2] = 0x00,	/* - */
 };
 
 
 /* entry point */
-struct snd_ice1712_card_info snd_vt1720_mobo_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_vt1720_mobo_cards[] __devinitdata = {
 	{
 		.subvendor = VT1720_SUBDEVICE_K8X800,
 		.name = "Albatron K8X800 Pro II",
--- linux-2.6.18.noarch/sound/pci/ice1712/phase.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/phase.h	2007-06-05 17:46:52.000000000 -0400
@@ -31,7 +31,7 @@
 #define VT1724_SUBDEVICE_PHASE28	0x3b154911
 
 /* entry point */
-extern struct snd_ice1712_card_info snd_vt1724_phase_cards[];
+extern const struct snd_ice1712_card_info snd_vt1724_phase_cards[];
 
 /* PHASE28 GPIO bits */
 #define PHASE28_SPI_MISO	(1 << 21)
--- linux-2.6.18.noarch/sound/pci/ice1712/vt1720_mobo.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/vt1720_mobo.h	2007-06-05 17:46:52.000000000 -0400
@@ -36,6 +36,6 @@
 #define VT1720_SUBDEVICE_9CJS		0x0f272327
 #define VT1720_SUBDEVICE_SN25P		0x97123650
 
-extern struct snd_ice1712_card_info  snd_vt1720_mobo_cards[];
+extern const struct snd_ice1712_card_info  snd_vt1720_mobo_cards[];
 
 #endif /* __SOUND_VT1720_MOBO_H */
--- linux-2.6.18.noarch/sound/pci/ice1712/juli.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/juli.h	2007-06-05 17:46:52.000000000 -0400
@@ -5,6 +5,6 @@
 
 #define VT1724_SUBDEVICE_JULI		0x31305345	/* Juli@ */
 
-extern struct snd_ice1712_card_info  snd_vt1724_juli_cards[];
+extern const struct snd_ice1712_card_info  snd_vt1724_juli_cards[];
 
 #endif	/* __SOUND_JULI_H */
--- linux-2.6.18.noarch/sound/pci/ice1712/ews.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/ews.c	2007-06-05 17:46:52.000000000 -0400
@@ -332,7 +332,7 @@
 
 /*
  */
-static struct snd_akm4xxx akm_ews88mt __devinitdata = {
+static const struct snd_akm4xxx akm_ews88mt __devinitdata = {
 	.num_adcs = 8,
 	.num_dacs = 8,
 	.type = SND_AK4524,
@@ -342,7 +342,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_ews88mt_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_ews88mt_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 1, /* CIF high */
 	.data_mask = ICE1712_EWS88_SERIAL_DATA,
@@ -354,7 +354,7 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_ewx2496 __devinitdata = {
+static const struct snd_akm4xxx akm_ewx2496 __devinitdata = {
 	.num_adcs = 2,
 	.num_dacs = 2,
 	.type = SND_AK4524,
@@ -363,7 +363,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_ewx2496_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_ewx2496_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 1, /* CIF high */
 	.data_mask = ICE1712_EWS88_SERIAL_DATA,
@@ -375,7 +375,7 @@
 	.mask_flags = 0,
 };
 
-static struct snd_akm4xxx akm_6fire __devinitdata = {
+static const struct snd_akm4xxx akm_6fire __devinitdata = {
 	.num_adcs = 6,
 	.num_dacs = 6,
 	.type = SND_AK4524,
@@ -384,7 +384,7 @@
 	}
 };
 
-static struct snd_ak4xxx_private akm_6fire_priv __devinitdata = {
+static const struct snd_ak4xxx_private akm_6fire_priv __devinitdata = {
 	.caddr = 2,
 	.cif = 1, /* CIF high */
 	.data_mask = ICE1712_6FIRE_SERIAL_DATA,
@@ -578,7 +578,7 @@
 	return val != nval;
 }
 
-static struct snd_kcontrol_new snd_ice1712_ewx2496_controls[] __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_ewx2496_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Input Sensitivity Switch",
@@ -678,7 +678,7 @@
 	return ndata != data;
 }
 
-static struct snd_kcontrol_new snd_ice1712_ews88mt_input_sense __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_ews88mt_input_sense __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Input Sensitivity Switch",
 	.info = snd_ice1712_ewx_io_sense_info,
@@ -687,7 +687,7 @@
 	.count = 8,
 };
 
-static struct snd_kcontrol_new snd_ice1712_ews88mt_output_sense __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_ews88mt_output_sense __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Output Sensitivity Switch",
 	.info = snd_ice1712_ewx_io_sense_info,
@@ -769,7 +769,7 @@
   .private_value = xshift | (xinvert << 8),\
 }
 
-static struct snd_kcontrol_new snd_ice1712_ews88d_controls[] __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_ews88d_controls[] __devinitdata = {
 	EWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, "IEC958 Input Optical", 0, 1, 0), /* inverted */
 	EWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, "ADAT Output Optical", 1, 0, 0),
 	EWS88D_CONTROL(SNDRV_CTL_ELEM_IFACE_MIXER, "ADAT External Master Clock", 2, 0, 0),
@@ -909,7 +909,7 @@
   .private_value = xshift | (xinvert << 8),\
 }
 
-static struct snd_kcontrol_new snd_ice1712_6fire_controls[] __devinitdata = {
+static const struct snd_kcontrol_new snd_ice1712_6fire_controls[] __devinitdata = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Analog Input Select",
@@ -989,7 +989,7 @@
 
 
 /* entry point */
-struct snd_ice1712_card_info snd_ice1712_ews_cards[] __devinitdata = {
+const struct snd_ice1712_card_info snd_ice1712_ews_cards[] __devinitdata = {
 	{
 		.subvendor = ICE1712_SUBDEVICE_EWX2496,
 		.name = "TerraTec EWX24/96",
--- linux-2.6.18.noarch/sound/pci/ice1712/prodigy192.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ice1712/prodigy192.h	2007-06-05 17:46:52.000000000 -0400
@@ -6,6 +6,6 @@
 
 #define VT1724_SUBDEVICE_PRODIGY192VE	 0x34495345	/* PRODIGY 192 VE */
 
-extern struct snd_ice1712_card_info  snd_vt1724_prodigy192_cards[];
+extern const struct snd_ice1712_card_info  snd_vt1724_prodigy192_cards[];
 
 #endif	/* __SOUND_PRODIGY192_H */
--- linux-2.6.18.noarch/sound/pci/ad1889.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ad1889.c	2007-06-05 17:47:00.000000000 -0400
@@ -860,7 +860,7 @@
 	synchronize_irq(chip->irq);
 	
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void*)chip);
+		free_irq(chip->irq, chip);
 
 skip_hw:
 	if (chip->iobase)
--- linux-2.6.18.noarch/sound/pci/azt3328.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/azt3328.c	2007-06-05 17:47:00.000000000 -0400
@@ -1513,7 +1513,7 @@
 __end_hw:
 	snd_azf3328_free_joystick(chip);
         if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 
@@ -1903,9 +1903,9 @@
 	for (reg = 0; reg < AZF_IO_SIZE_SYNTH_PM / 2; reg++)
 		chip->saved_regs_synth[reg] = inw(chip->synth_port + reg * 2);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1916,9 +1916,14 @@
 	struct snd_azf3328 *chip = card->private_data;
 	int reg;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "azt3328: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	for (reg = 0; reg < AZF_IO_SIZE_IO2_PM / 2; reg++)
--- linux-2.6.18.noarch/sound/pci/ca0106/ca0106_mixer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ca0106/ca0106_mixer.c	2007-06-05 17:45:30.000000000 -0400
@@ -70,9 +70,13 @@
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
+#include <sound/tlv.h>
 
 #include "ca0106.h"
 
+static const DECLARE_TLV_DB_SCALE(snd_ca0106_db_scale1, -5175, 25, 1);
+static const DECLARE_TLV_DB_SCALE(snd_ca0106_db_scale2, -10350, 50, 1);
+
 static int snd_ca0106_shared_spdif_info(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_info *uinfo)
 {
@@ -469,22 +473,15 @@
 #define CA_VOLUME(xname,chid,reg) \
 {								\
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |		\
+	          SNDRV_CTL_ELEM_ACCESS_TLV_READ,		\
 	.info =	 snd_ca0106_volume_info,			\
 	.get =   snd_ca0106_volume_get,				\
 	.put =   snd_ca0106_volume_put,				\
+	.tlv = { .p = snd_ca0106_db_scale1 },			\
 	.private_value = ((chid) << 8) | (reg)			\
 }
 
-#define I2C_VOLUME(xname,chid) \
-{								\
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
-	.info =  snd_ca0106_i2c_volume_info,			\
-	.get =   snd_ca0106_i2c_volume_get,			\
-	.put =   snd_ca0106_i2c_volume_put,			\
-	.private_value = chid					\
-}
-
-
 static struct snd_kcontrol_new snd_ca0106_volume_ctls[] __devinitdata = {
 	CA_VOLUME("Analog Front Playback Volume",
 		  CONTROL_FRONT_CHANNEL, PLAYBACK_VOLUME2),
@@ -507,11 +504,6 @@
         CA_VOLUME("CAPTURE feedback Playback Volume",
 		  1, CAPTURE_CONTROL),
 
-        I2C_VOLUME("Phone Capture Volume", 0),
-        I2C_VOLUME("Mic Capture Volume", 1),
-        I2C_VOLUME("Line in Capture Volume", 2),
-        I2C_VOLUME("Aux Capture Volume", 3),
-
 	{
 		.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 		.iface =        SNDRV_CTL_ELEM_IFACE_PCM,
@@ -529,14 +521,14 @@
 	},
 	{
 		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name =		"Digital Capture Source",
+		.name =		"Digital Source Capture Enum",
 		.info =		snd_ca0106_capture_source_info,
 		.get =		snd_ca0106_capture_source_get,
 		.put =		snd_ca0106_capture_source_put
 	},
 	{
 		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name =		"Capture Source",
+		.name =		"Analog Source Capture Enum",
 		.info =		snd_ca0106_i2c_capture_source_info,
 		.get =		snd_ca0106_i2c_capture_source_get,
 		.put =		snd_ca0106_i2c_capture_source_put
@@ -551,6 +543,25 @@
 	},
 };
 
+#define I2C_VOLUME(xname,chid) \
+{								\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |		\
+	          SNDRV_CTL_ELEM_ACCESS_TLV_READ,		\
+	.info =  snd_ca0106_i2c_volume_info,			\
+	.get =   snd_ca0106_i2c_volume_get,			\
+	.put =   snd_ca0106_i2c_volume_put,			\
+	.tlv = { .p = snd_ca0106_db_scale2 },			\
+	.private_value = chid					\
+}
+
+static struct snd_kcontrol_new snd_ca0106_volume_i2c_adc_ctls[] __devinitdata = {
+        I2C_VOLUME("Phone Capture Volume", 0),
+        I2C_VOLUME("Mic Capture Volume", 1),
+        I2C_VOLUME("Line in Capture Volume", 2),
+        I2C_VOLUME("Aux Capture Volume", 3),
+};
+
 static int __devinit remove_ctl(struct snd_card *card, const char *name)
 {
 	struct snd_ctl_elem_id id;
@@ -635,6 +646,11 @@
 			return err;
 	}
 	if (emu->details->i2c_adc == 1) {
+		for (i = 0; i < ARRAY_SIZE(snd_ca0106_volume_i2c_adc_ctls); i++) {
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_ca0106_volume_i2c_adc_ctls[i], emu));
+			if (err < 0)
+				return err;
+		}
 		if (emu->details->gpio_type == 1)
 			err = snd_ctl_add(card, snd_ctl_new1(&snd_ca0106_capture_mic_line_in, emu));
 		else  /* gpio_type == 2 */
--- linux-2.6.18.noarch/sound/pci/ca0106/ca0106_main.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ca0106/ca0106_main.c	2007-06-05 17:45:30.000000000 -0400
@@ -154,6 +154,7 @@
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+static uint subsystem[SNDRV_CARDS]; /* Force card subsystem model */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the CA0106 soundcard.");
@@ -161,6 +162,8 @@
 MODULE_PARM_DESC(id, "ID string for the CA0106 soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable the CA0106 soundcard.");
+module_param_array(subsystem, uint, NULL, 0444);
+MODULE_PARM_DESC(subsystem, "Force card subsystem model.");
 
 #include "ca0106.h"
 
@@ -194,6 +197,17 @@
 	   .gpio_type = 1,
 	   .i2c_adc = 1,
 	   .spi_dac = 1 } ,
+	 /* New Audigy LS. Has a different DAC. */
+	 /* SB0570:
+	  * CTRL:CA0106-DAT
+	  * ADC: WM8775EDS
+	  * DAC: WM8768GEDS
+	  */
+	 { .serial = 0x10111102,
+	   .name   = "Audigy SE OEM [SB0570a]",
+	   .gpio_type = 1,
+	   .i2c_adc = 1,
+	   .spi_dac = 1 } ,
 	 /* MSI K8N Diamond Motherboard with onboard SB Live 24bit without AC97 */
 	 /* SB0438
 	  * CTRL:CA0106-DAT
@@ -1046,7 +1060,7 @@
 
 	// release the irq
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	pci_disable_device(chip->pci);
 	kfree(chip);
 	return 0;
@@ -1224,7 +1238,7 @@
 	{ 0x15, ADC_MUX_LINEIN },  /* ADC Mixer control */
 };
 
-static int __devinit snd_ca0106_create(struct snd_card *card,
+static int __devinit snd_ca0106_create(int dev, struct snd_card *card,
 					 struct pci_dev *pci,
 					 struct snd_ca0106 **rchip)
 {
@@ -1284,21 +1298,29 @@
 
 	pci_set_master(pci);
 	/* read revision & serial */
-	pci_read_config_byte(pci, PCI_REVISION_ID, (char *)&chip->revision);
+	pci_read_config_byte(pci, PCI_REVISION_ID, &chip->revision);
 	pci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);
 	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);
 #if 1
-	printk(KERN_INFO "Model %04x Rev %08x Serial %08x\n", chip->model,
+	printk(KERN_INFO "snd-ca0106: Model %04x Rev %08x Serial %08x\n", chip->model,
 	       chip->revision, chip->serial);
 #endif
 	strcpy(card->driver, "CA0106");
 	strcpy(card->shortname, "CA0106");
 
 	for (c = ca0106_chip_details; c->serial; c++) {
-		if (c->serial == chip->serial)
+		if (subsystem[dev]) {
+			if (c->serial == subsystem[dev])
+				break;
+		} else if (c->serial == chip->serial)
 			break;
 	}
 	chip->details = c;
+	if (subsystem[dev]) {
+		printk(KERN_INFO "snd-ca0106: Sound card name=%s, subsystem=0x%x. Forced to subsystem=0x%x\n",
+                        c->name, chip->serial, subsystem[dev]);
+	}
+
 	sprintf(card->longname, "%s at 0x%lx irq %i",
 		c->name, chip->port, chip->irq);
 
@@ -1362,7 +1384,6 @@
 	snd_ca0106_ptr_write(chip, SPDIF_SELECT1, 0, 0xf);
 	snd_ca0106_ptr_write(chip, SPDIF_SELECT2, 0, 0x000f0000); /* 0x0b000000 for digital, 0x000b0000 for analog, from win2000 drivers. Use 0x000f0000 for surround71 */
 	chip->spdif_enable = 0; /* Set digital SPDIF output off */
-	chip->capture_source = 3; /* Set CAPTURE_SOURCE */
 	//snd_ca0106_ptr_write(chip, 0x45, 0, 0); /* Analogue out */
 	//snd_ca0106_ptr_write(chip, 0x45, 0, 0xf00); /* Digital out */
 
@@ -1382,8 +1403,22 @@
 		snd_ca0106_ptr_write(chip, PLAYBACK_VOLUME1, ch, 0xffffffff); /* Mute */
 		snd_ca0106_ptr_write(chip, PLAYBACK_VOLUME2, ch, 0xffffffff); /* Mute */
 	}
-        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4); /* Select MIC, Line in, TAD in, AUX in */
-	chip->capture_source = 3; /* Set CAPTURE_SOURCE */
+	if (chip->details->i2c_adc == 1) {
+	        /* Select MIC, Line in, TAD in, AUX in */
+	        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4);
+		/* Default to CAPTURE_SOURCE to i2s in */
+		chip->capture_source = 3;
+	} else if (chip->details->ac97 == 1) {
+	        /* Default to AC97 in */
+	        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x444400e4);
+		/* Default to CAPTURE_SOURCE to AC97 in */
+		chip->capture_source = 4;
+	} else {
+	        /* Select MIC, Line in, TAD in, AUX in */
+	        snd_ca0106_ptr_write(chip, CAPTURE_SOURCE, 0x0, 0x333300e4);
+		/* Default to Set CAPTURE_SOURCE to i2s in */
+		chip->capture_source = 3;
+	}
 
         if (chip->details->gpio_type == 2) { /* The SB0438 use GPIO differently. */
 		/* FIXME: Still need to find out what the other GPIO bits do. E.g. For digital spdif out. */
@@ -1541,7 +1576,7 @@
 	if (card == NULL)
 		return -ENOMEM;
 
-	if ((err = snd_ca0106_create(card, pci, &chip)) < 0) {
+	if ((err = snd_ca0106_create(dev, card, pci, &chip)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
@@ -1585,6 +1620,8 @@
 	snd_ca0106_proc_init(chip);
 #endif
 
+	snd_card_set_dev(card, &pci->dev);
+
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;
--- linux-2.6.18.noarch/sound/pci/ca0106/ca0106.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ca0106/ca0106.h	2007-06-05 17:45:30.000000000 -0400
@@ -590,7 +590,7 @@
 	struct resource *res_port;
 	int irq;
 
-	unsigned int revision;		/* chip revision */
+	unsigned char revision;		/* chip revision */
 	unsigned int serial;            /* serial number */
 	unsigned short model;		/* subsystem id */
 
--- linux-2.6.18.noarch/sound/pci/korg1212/korg1212.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/korg1212/korg1212.c	2007-06-05 17:47:08.000000000 -0400
@@ -28,6 +28,7 @@
 #include <linux/wait.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
+#include <linux/firmware.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -263,7 +264,15 @@
 #define COMMAND_ACK_DELAY   13         // number of RTC ticks to wait for an acknowledgement
                                        //    from the card after sending a command.
 
+#define FIRMWARE_IN_THE_KERNEL
+
+#ifdef FIRMWARE_IN_THE_KERNEL
 #include "korg1212-firmware.h"
+static const struct firmware static_dsp_code = {
+	.data = (u8 *)dspCode,
+	.size = sizeof dspCode
+};
+#endif
 
 enum ClockSourceIndex {
    K1212_CLKIDX_AdatAt44_1K = 0,    // selects source as ADAT at 44.1 kHz
@@ -345,8 +354,6 @@
         struct snd_dma_buffer dma_rec;
 	struct snd_dma_buffer dma_shared;
 
-        u32 dspCodeSize;
-
 	u32 DataBufsSize;
 
         struct KorgAudioBuffer  * playDataBufsPtr;
@@ -1124,9 +1131,6 @@
         u32 doorbellValue;
         struct snd_korg1212 *korg1212 = dev_id;
 
-	if(irq != korg1212->irq)
-		return IRQ_NONE;
-
         doorbellValue = readl(korg1212->inDoorbellPtr);
 
         if (!doorbellValue)
@@ -1140,7 +1144,6 @@
 
 	korg1212->inIRQ++;
 
-
         switch (doorbellValue) {
                 case K1212_DB_DSPDownloadDone:
                         K1212_DEBUG_PRINTK("K1212_DEBUG: IRQ DNLD count - %ld, %x, [%s].\n",
@@ -1227,8 +1230,6 @@
 
         snd_korg1212_setCardState(korg1212, K1212_STATE_DSP_IN_PROCESS);
 
-        memcpy(korg1212->dma_dsp.area, dspCode, korg1212->dspCodeSize);
-
         rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_StartDSPDownload,
                                      UpperWordSwap(korg1212->dma_dsp.addr),
                                      0, 0, 0);
@@ -2160,6 +2161,7 @@
         unsigned int i;
 	unsigned ioport_size, iomem_size, iomem2_size;
         struct snd_korg1212 * korg1212;
+	const struct firmware *dsp_code;
 
         static struct snd_device_ops ops = {
                 .dev_free = snd_korg1212_dev_free,
@@ -2333,8 +2335,6 @@
 
 #endif // K1212_LARGEALLOC
 
-        korg1212->dspCodeSize = sizeof (dspCode);
-
         korg1212->VolumeTablePhy = korg1212->sharedBufferPhy +
 		offsetof(struct KorgSharedBuffer, volumeData);
         korg1212->RoutingTablePhy = korg1212->sharedBufferPhy +
@@ -2342,17 +2342,40 @@
         korg1212->AdatTimeCodePhy = korg1212->sharedBufferPhy +
 		offsetof(struct KorgSharedBuffer, AdatTimeCode);
 
+	err = request_firmware(&dsp_code, "korg/k1212.dsp", &pci->dev);
+	if (err < 0) {
+		release_firmware(dsp_code);
+#ifdef FIRMWARE_IN_THE_KERNEL
+		dsp_code = &static_dsp_code;
+#else
+		snd_printk(KERN_ERR "firmware not available\n");
+		snd_korg1212_free(korg1212);
+		return err;
+#endif
+	}
+
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-				korg1212->dspCodeSize, &korg1212->dma_dsp) < 0) {
-		snd_printk(KERN_ERR "korg1212: can not allocate dsp code memory (%d bytes)\n", korg1212->dspCodeSize);
+				dsp_code->size, &korg1212->dma_dsp) < 0) {
+		snd_printk(KERN_ERR "korg1212: cannot allocate dsp code memory (%zd bytes)\n", dsp_code->size);
                 snd_korg1212_free(korg1212);
+#ifdef FIRMWARE_IN_THE_KERNEL
+		if (dsp_code != &static_dsp_code)
+#endif
+			release_firmware(dsp_code);
                 return -ENOMEM;
         }
 
         K1212_DEBUG_PRINTK("K1212_DEBUG: DSP Code area = 0x%p (0x%08x) %d bytes [%s]\n",
-		   korg1212->dma_dsp.area, korg1212->dma_dsp.addr, korg1212->dspCodeSize,
+		   korg1212->dma_dsp.area, korg1212->dma_dsp.addr, dsp_code->size,
 		   stateName[korg1212->cardState]);
 
+	memcpy(korg1212->dma_dsp.area, dsp_code->data, dsp_code->size);
+
+#ifdef FIRMWARE_IN_THE_KERNEL
+	if (dsp_code != &static_dsp_code)
+#endif
+		release_firmware(dsp_code);
+
 	rc = snd_korg1212_Send1212Command(korg1212, K1212_DB_RebootCard, 0, 0, 0, 0);
 
 	if (rc)
--- linux-2.6.18.noarch/sound/pci/cs5535audio/Makefile.orig	2007-06-05 16:07:59.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs5535audio/Makefile	2007-06-05 17:46:01.000000000 -0400
@@ -4,7 +4,7 @@
 
 snd-cs5535audio-objs := cs5535audio.o cs5535audio_pcm.o
 
-ifdef CONFIG_PM
+ifeq ($(CONFIG_PM),y)
 snd-cs5535audio-objs += cs5535audio_pm.o
 endif
 
--- linux-2.6.18.noarch/sound/pci/cs5535audio/cs5535audio_pm.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs5535audio/cs5535audio_pm.c	2007-06-05 17:46:01.000000000 -0400
@@ -73,9 +73,10 @@
 	snd_ac97_suspend(cs5535au->ac97);
 	/* save important regs, then disable aclink in hw */
 	snd_cs5535audio_stop_hardware(cs5535au);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
-
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -87,8 +88,14 @@
 	int timeout;
 	int i;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "cs5535audio: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	/* set LNK_WRM_RST to reset AC link */
--- linux-2.6.18.noarch/sound/pci/cs5535audio/cs5535audio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs5535audio/cs5535audio.c	2007-06-05 17:46:01.000000000 -0400
@@ -203,8 +203,7 @@
 	}
 }
 
-static irqreturn_t snd_cs5535audio_interrupt(int irq, void *dev_id,
-					     struct pt_regs *regs)
+static irqreturn_t snd_cs5535audio_interrupt(int irq, void *dev_id)
 {
 	u16 acc_irq_stat;
 	u8 bm_stat;
@@ -321,7 +320,7 @@
 	cs5535au->port = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_cs5535audio_interrupt,
-			IRQF_DISABLED|IRQF_SHARED, "CS5535 Audio", cs5535au)) {
+			IRQF_SHARED, "CS5535 Audio", cs5535au)) {
 		snd_printk("unable to grab IRQ %d\n", pci->irq);
 		err = -EBUSY;
 		goto sndfail;
--- linux-2.6.18.noarch/sound/pci/intel8x0m.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/intel8x0m.c	2007-06-05 17:47:00.000000000 -0400
@@ -196,12 +196,8 @@
 
 	int irq;
 
-	unsigned int mmio;
-	unsigned long addr;
-	void __iomem *remap_addr;
-	unsigned int bm_mmio;
-	unsigned long bmaddr;
-	void __iomem *remap_bmaddr;
+	void __iomem *addr;
+	void __iomem *bmaddr;
 
 	struct pci_dev *pci;
 	struct snd_card *card;
@@ -253,72 +249,48 @@
  *  Lowlevel I/O - busmaster
  */
 
-static u8 igetbyte(struct intel8x0m *chip, u32 offset)
+static inline u8 igetbyte(struct intel8x0m *chip, u32 offset)
 {
-	if (chip->bm_mmio)
-		return readb(chip->remap_bmaddr + offset);
-	else
-		return inb(chip->bmaddr + offset);
+	return ioread8(chip->bmaddr + offset);
 }
 
-static u16 igetword(struct intel8x0m *chip, u32 offset)
+static inline u16 igetword(struct intel8x0m *chip, u32 offset)
 {
-	if (chip->bm_mmio)
-		return readw(chip->remap_bmaddr + offset);
-	else
-		return inw(chip->bmaddr + offset);
+	return ioread16(chip->bmaddr + offset);
 }
 
-static u32 igetdword(struct intel8x0m *chip, u32 offset)
+static inline u32 igetdword(struct intel8x0m *chip, u32 offset)
 {
-	if (chip->bm_mmio)
-		return readl(chip->remap_bmaddr + offset);
-	else
-		return inl(chip->bmaddr + offset);
+	return ioread32(chip->bmaddr + offset);
 }
 
-static void iputbyte(struct intel8x0m *chip, u32 offset, u8 val)
+static inline void iputbyte(struct intel8x0m *chip, u32 offset, u8 val)
 {
-	if (chip->bm_mmio)
-		writeb(val, chip->remap_bmaddr + offset);
-	else
-		outb(val, chip->bmaddr + offset);
+	iowrite8(val, chip->bmaddr + offset);
 }
 
-static void iputword(struct intel8x0m *chip, u32 offset, u16 val)
+static inline void iputword(struct intel8x0m *chip, u32 offset, u16 val)
 {
-	if (chip->bm_mmio)
-		writew(val, chip->remap_bmaddr + offset);
-	else
-		outw(val, chip->bmaddr + offset);
+	iowrite16(val, chip->bmaddr + offset);
 }
 
-static void iputdword(struct intel8x0m *chip, u32 offset, u32 val)
+static inline void iputdword(struct intel8x0m *chip, u32 offset, u32 val)
 {
-	if (chip->bm_mmio)
-		writel(val, chip->remap_bmaddr + offset);
-	else
-		outl(val, chip->bmaddr + offset);
+	iowrite32(val, chip->bmaddr + offset);
 }
 
 /*
  *  Lowlevel I/O - AC'97 registers
  */
 
-static u16 iagetword(struct intel8x0m *chip, u32 offset)
+static inline u16 iagetword(struct intel8x0m *chip, u32 offset)
 {
-	if (chip->mmio)
-		return readw(chip->remap_addr + offset);
-	else
-		return inw(chip->addr + offset);
+	return ioread16(chip->addr + offset);
 }
 
-static void iaputword(struct intel8x0m *chip, u32 offset, u16 val)
+static inline void iaputword(struct intel8x0m *chip, u32 offset, u16 val)
 {
-	if (chip->mmio)
-		writew(val, chip->remap_addr + offset);
-	else
-		outw(val, chip->addr + offset);
+	iowrite16(val, chip->addr + offset);
 }
 
 /*
@@ -858,7 +830,7 @@
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
 	ac97.private_free = snd_intel8x0_mixer_free_ac97;
-	ac97.scaps = AC97_SCAP_SKIP_AUDIO;
+	ac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;
 
 	glob_sta = igetdword(chip, ICHREG(GLOB_STA));
 
@@ -1019,10 +991,10 @@
       __hw_end:
 	if (chip->bdbars.area)
 		snd_dma_free_pages(&chip->bdbars);
-	if (chip->remap_addr)
-		iounmap(chip->remap_addr);
-	if (chip->remap_bmaddr)
-		iounmap(chip->remap_bmaddr);
+	if (chip->addr)
+		pci_iounmap(chip->pci, chip->addr);
+	if (chip->bmaddr)
+		pci_iounmap(chip->pci, chip->bmaddr);
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
 	pci_release_regions(chip->pci);
@@ -1045,8 +1017,14 @@
 	for (i = 0; i < chip->pcm_devs; i++)
 		snd_pcm_suspend_all(chip->pcm[i]);
 	snd_ac97_suspend(chip->ac97);
+	if (chip->irq >= 0) {
+		synchronize_irq(chip->irq);
+		free_irq(chip->irq, chip);
+		chip->irq = -1;
+	}
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1055,9 +1033,23 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct intel8x0m *chip = card->private_data;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "intel8x0m: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
+	if (request_irq(pci->irq, snd_intel8x0_interrupt,
+			IRQF_SHARED, card->shortname, chip)) {
+		printk(KERN_ERR "intel8x0m: unable to grab IRQ %d, "
+		       "disabling device\n", pci->irq);
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	chip->irq = pci->irq;
 	snd_intel8x0_chip_init(chip, 0);
 	snd_ac97_resume(chip->ac97);
 
@@ -1153,35 +1145,27 @@
 
 	if (device_type == DEVICE_ALI) {
 		/* ALI5455 has no ac97 region */
-		chip->bmaddr = pci_resource_start(pci, 0);
+		chip->bmaddr = pci_iomap(pci, 0, 0);
 		goto port_inited;
 	}
 
-	if (pci_resource_flags(pci, 2) & IORESOURCE_MEM) {	/* ICH4 and Nforce */
-		chip->mmio = 1;
-		chip->addr = pci_resource_start(pci, 2);
-		chip->remap_addr = ioremap_nocache(chip->addr,
-						   pci_resource_len(pci, 2));
-		if (chip->remap_addr == NULL) {
-			snd_printk(KERN_ERR "AC'97 space ioremap problem\n");
-			snd_intel8x0_free(chip);
-			return -EIO;
-		}
-	} else {
-		chip->addr = pci_resource_start(pci, 0);
+	if (pci_resource_flags(pci, 2) & IORESOURCE_MEM) /* ICH4 and Nforce */
+		chip->addr = pci_iomap(pci, 2, 0);
+	else
+		chip->addr = pci_iomap(pci, 0, 0);
+	if (!chip->addr) {
+		snd_printk(KERN_ERR "AC'97 space ioremap problem\n");
+		snd_intel8x0_free(chip);
+		return -EIO;
 	}
-	if (pci_resource_flags(pci, 3) & IORESOURCE_MEM) {	/* ICH4 */
-		chip->bm_mmio = 1;
-		chip->bmaddr = pci_resource_start(pci, 3);
-		chip->remap_bmaddr = ioremap_nocache(chip->bmaddr,
-						     pci_resource_len(pci, 3));
-		if (chip->remap_bmaddr == NULL) {
-			snd_printk(KERN_ERR "Controller space ioremap problem\n");
-			snd_intel8x0_free(chip);
-			return -EIO;
-		}
-	} else {
-		chip->bmaddr = pci_resource_start(pci, 1);
+	if (pci_resource_flags(pci, 3) & IORESOURCE_MEM) /* ICH4 */
+		chip->bmaddr = pci_iomap(pci, 3, 0);
+	else
+		chip->bmaddr = pci_iomap(pci, 1, 0);
+	if (!chip->bmaddr) {
+		snd_printk(KERN_ERR "Controller space ioremap problem\n");
+		snd_intel8x0_free(chip);
+		return -EIO;
 	}
 
  port_inited:
@@ -1319,8 +1303,8 @@
 	
 	snd_intel8x0m_proc_init(chip);
 
-	sprintf(card->longname, "%s at 0x%lx, irq %i",
-		card->shortname, chip->addr, chip->irq);
+	sprintf(card->longname, "%s at irq %i",
+		card->shortname, chip->irq);
 
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
--- linux-2.6.18.noarch/sound/pci/ali5451/ali5451.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ali5451/ali5451.c	2007-06-05 17:45:15.000000000 -0400
@@ -2034,8 +2034,10 @@
 	outl(0xffffffff, ALI_REG(chip, ALI_STOP));
 
 	spin_unlock_irq(&chip->reg_lock);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2050,8 +2052,15 @@
 	if (! im)
 		return 0;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "ali5451: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	pci_set_master(pci);
 
 	spin_lock_irq(&chip->reg_lock);
 	
@@ -2088,7 +2097,7 @@
 		snd_ali_disable_address_interrupt(codec);
 	if (codec->irq >= 0) {
 		synchronize_irq(codec->irq);
-		free_irq(codec->irq, (void *)codec);
+		free_irq(codec->irq, codec);
 	}
 	if (codec->port)
 		pci_release_regions(codec->pci);
@@ -2304,6 +2313,8 @@
 		return err;
 	}
 
+	snd_card_set_dev(card, &pci->dev);
+
 	/* initialise synth voices*/
 	for (i = 0; i < ALI_CHANNELS; i++ ) {
 		codec->synth.voices[i].number = i;
--- linux-2.6.18.noarch/sound/pci/es1938.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/es1938.c	2007-06-05 17:47:00.000000000 -0400
@@ -62,6 +62,7 @@
 #include <sound/opl3.h>
 #include <sound/mpu401.h>
 #include <sound/initval.h>
+#include <sound/tlv.h>
 
 #include <asm/io.h>
 
@@ -1164,6 +1165,14 @@
 		return snd_es1938_read(chip, reg);
 }
 
+#define ES1938_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv)    \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\
+  .name = xname, .index = xindex, \
+  .info = snd_es1938_info_single, \
+  .get = snd_es1938_get_single, .put = snd_es1938_put_single, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24), \
+  .tlv = { .p = xtlv } }
 #define ES1938_SINGLE(xname, xindex, reg, shift, mask, invert) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_es1938_info_single, \
@@ -1217,6 +1226,14 @@
 	return snd_es1938_reg_bits(chip, reg, mask, val) != val;
 }
 
+#define ES1938_DOUBLE_TLV(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,\
+  .name = xname, .index = xindex, \
+  .info = snd_es1938_info_double, \
+  .get = snd_es1938_get_double, .put = snd_es1938_put_double, \
+  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22), \
+  .tlv = { .p = xtlv } }
 #define ES1938_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_es1938_info_double, \
@@ -1297,8 +1314,41 @@
 	return change;
 }
 
+static unsigned int db_scale_master[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 54, TLV_DB_SCALE_ITEM(-3600, 50, 1),
+	54, 63, TLV_DB_SCALE_ITEM(-900, 100, 0),
+};
+
+static unsigned int db_scale_audio1[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 8, TLV_DB_SCALE_ITEM(-3300, 300, 1),
+	8, 15, TLV_DB_SCALE_ITEM(-900, 150, 0),
+};
+
+static unsigned int db_scale_audio2[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 8, TLV_DB_SCALE_ITEM(-3450, 300, 1),
+	8, 15, TLV_DB_SCALE_ITEM(-1050, 150, 0),
+};
+
+static unsigned int db_scale_mic[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 8, TLV_DB_SCALE_ITEM(-2400, 300, 1),
+	8, 15, TLV_DB_SCALE_ITEM(0, 150, 0),
+};
+
+static unsigned int db_scale_line[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 8, TLV_DB_SCALE_ITEM(-3150, 300, 1),
+	8, 15, TLV_DB_SCALE_ITEM(-750, 150, 0),
+};
+
+static const DECLARE_TLV_DB_SCALE(db_scale_capture, 0, 150, 0);
+
 static struct snd_kcontrol_new snd_es1938_controls[] = {
-ES1938_DOUBLE("Master Playback Volume", 0, 0x60, 0x62, 0, 0, 63, 0),
+ES1938_DOUBLE_TLV("Master Playback Volume", 0, 0x60, 0x62, 0, 0, 63, 0,
+		  db_scale_master),
 ES1938_DOUBLE("Master Playback Switch", 0, 0x60, 0x62, 6, 6, 1, 1),
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1309,19 +1359,27 @@
 },
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READ |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name = "Hardware Master Playback Switch",
-	.access = SNDRV_CTL_ELEM_ACCESS_READ,
 	.info = snd_es1938_info_hw_switch,
 	.get = snd_es1938_get_hw_switch,
+	.tlv = { .p = db_scale_master },
 },
 ES1938_SINGLE("Hardware Volume Split", 0, 0x64, 7, 1, 0),
-ES1938_DOUBLE("Line Playback Volume", 0, 0x3e, 0x3e, 4, 0, 15, 0),
+ES1938_DOUBLE_TLV("Line Playback Volume", 0, 0x3e, 0x3e, 4, 0, 15, 0,
+		  db_scale_line),
 ES1938_DOUBLE("CD Playback Volume", 0, 0x38, 0x38, 4, 0, 15, 0),
-ES1938_DOUBLE("FM Playback Volume", 0, 0x36, 0x36, 4, 0, 15, 0),
-ES1938_DOUBLE("Mono Playback Volume", 0, 0x6d, 0x6d, 4, 0, 15, 0),
-ES1938_DOUBLE("Mic Playback Volume", 0, 0x1a, 0x1a, 4, 0, 15, 0),
-ES1938_DOUBLE("Aux Playback Volume", 0, 0x3a, 0x3a, 4, 0, 15, 0),
-ES1938_DOUBLE("Capture Volume", 0, 0xb4, 0xb4, 4, 0, 15, 0),
+ES1938_DOUBLE_TLV("FM Playback Volume", 0, 0x36, 0x36, 4, 0, 15, 0,
+		  db_scale_mic),
+ES1938_DOUBLE_TLV("Mono Playback Volume", 0, 0x6d, 0x6d, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("Mic Playback Volume", 0, 0x1a, 0x1a, 4, 0, 15, 0,
+		  db_scale_mic),
+ES1938_DOUBLE_TLV("Aux Playback Volume", 0, 0x3a, 0x3a, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("Capture Volume", 0, 0xb4, 0xb4, 4, 0, 15, 0,
+		  db_scale_capture),
 ES1938_SINGLE("PC Speaker Volume", 0, 0x3c, 0, 7, 0),
 ES1938_SINGLE("Record Monitor", 0, 0xa8, 3, 1, 0),
 ES1938_SINGLE("Capture Switch", 0, 0x1c, 4, 1, 1),
@@ -1332,16 +1390,26 @@
 	.get = snd_es1938_get_mux,
 	.put = snd_es1938_put_mux,
 },
-ES1938_DOUBLE("Mono Input Playback Volume", 0, 0x6d, 0x6d, 4, 0, 15, 0),
-ES1938_DOUBLE("PCM Capture Volume", 0, 0x69, 0x69, 4, 0, 15, 0),
-ES1938_DOUBLE("Mic Capture Volume", 0, 0x68, 0x68, 4, 0, 15, 0),
-ES1938_DOUBLE("Line Capture Volume", 0, 0x6e, 0x6e, 4, 0, 15, 0),
-ES1938_DOUBLE("FM Capture Volume", 0, 0x6b, 0x6b, 4, 0, 15, 0),
-ES1938_DOUBLE("Mono Capture Volume", 0, 0x6f, 0x6f, 4, 0, 15, 0),
-ES1938_DOUBLE("CD Capture Volume", 0, 0x6a, 0x6a, 4, 0, 15, 0),
-ES1938_DOUBLE("Aux Capture Volume", 0, 0x6c, 0x6c, 4, 0, 15, 0),
-ES1938_DOUBLE("PCM Playback Volume", 0, 0x7c, 0x7c, 4, 0, 15, 0),
-ES1938_DOUBLE("PCM Playback Volume", 1, 0x14, 0x14, 4, 0, 15, 0),
+ES1938_DOUBLE_TLV("Mono Input Playback Volume", 0, 0x6d, 0x6d, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("PCM Capture Volume", 0, 0x69, 0x69, 4, 0, 15, 0,
+		  db_scale_audio2),
+ES1938_DOUBLE_TLV("Mic Capture Volume", 0, 0x68, 0x68, 4, 0, 15, 0,
+		  db_scale_mic),
+ES1938_DOUBLE_TLV("Line Capture Volume", 0, 0x6e, 0x6e, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("FM Capture Volume", 0, 0x6b, 0x6b, 4, 0, 15, 0,
+		  db_scale_mic),
+ES1938_DOUBLE_TLV("Mono Capture Volume", 0, 0x6f, 0x6f, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("CD Capture Volume", 0, 0x6a, 0x6a, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("Aux Capture Volume", 0, 0x6c, 0x6c, 4, 0, 15, 0,
+		  db_scale_line),
+ES1938_DOUBLE_TLV("PCM Playback Volume", 0, 0x7c, 0x7c, 4, 0, 15, 0,
+		  db_scale_audio2),
+ES1938_DOUBLE_TLV("PCM Playback Volume", 1, 0x14, 0x14, 4, 0, 15, 0,
+		  db_scale_audio1),
 ES1938_SINGLE("3D Control - Level", 0, 0x52, 0, 63, 0),
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1413,10 +1481,14 @@
 		*d = snd_es1938_reg_read(chip, *s);
 
 	outb(0x00, SLIO_REG(chip, IRQCONTROL)); /* disable irqs */
-	if (chip->irq >= 0)
+	if (chip->irq >= 0) {
+		synchronize_irq(chip->irq);
 		free_irq(chip->irq, chip);
+		chip->irq = -1;
+	}
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1426,6 +1498,7 @@
 	struct es1938 *chip = card->private_data;
 	unsigned char *s, *d;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	pci_enable_device(pci);
 	request_irq(pci->irq, snd_es1938_interrupt,
@@ -1488,8 +1561,10 @@
 
 	snd_es1938_free_gameport(chip);
 
-	if (chip->irq >= 0)
+	if (chip->irq >= 0) {
+		synchronize_irq(chip->irq);
 		free_irq(chip->irq, chip);
+	}
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 	kfree(chip);
@@ -1534,6 +1609,7 @@
 	spin_lock_init(&chip->mixer_lock);
 	chip->card = card;
 	chip->pci = pci;
+	chip->irq = -1;
 	if ((err = pci_request_regions(pci, "ESS Solo-1")) < 0) {
 		kfree(chip);
 		pci_disable_device(pci);
--- linux-2.6.18.noarch/sound/pci/echoaudio/mona.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/mona.c	2007-06-05 17:46:10.000000000 -0400
@@ -55,6 +55,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/layla24.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/layla24.c	2007-06-05 17:46:10.000000000 -0400
@@ -58,6 +58,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/darla24.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/darla24.c	2007-06-05 17:46:10.000000000 -0400
@@ -51,6 +51,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/indigo.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/indigo.c	2007-06-05 17:46:10.000000000 -0400
@@ -49,6 +49,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/indigoio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/indigoio.c	2007-06-05 17:46:10.000000000 -0400
@@ -50,6 +50,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/gina20.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/gina20.c	2007-06-05 17:46:10.000000000 -0400
@@ -51,6 +51,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/echo3g_dsp.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/echo3g_dsp.c	2007-06-05 17:46:10.000000000 -0400
@@ -39,7 +39,7 @@
 static int write_control_reg(struct echoaudio *chip, u32 ctl, u32 frq,
 			     char force);
 
-#include <linux/irq.h>
+#include <linux/interrupt.h>
 
 static int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)
 {
--- linux-2.6.18.noarch/sound/pci/echoaudio/echoaudio.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/echoaudio.c	2007-06-05 17:46:10.000000000 -0400
@@ -34,6 +34,7 @@
 MODULE_PARM_DESC(enable, "Enable " ECHOCARD_NAME " soundcard.");
 
 static unsigned int channels_list[10] = {1, 2, 4, 6, 8, 10, 12, 14, 16, 999999};
+static const DECLARE_TLV_DB_SCALE(db_scale_output_gain, -12800, 100, 1);
 
 static int get_firmware(const struct firmware **fw_entry,
 			const struct firmware *frm, struct echoaudio *chip)
@@ -1011,17 +1012,21 @@
 static struct snd_kcontrol_new snd_echo_line_output_gain __devinitdata = {
 	.name = "Line Playback Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,
 	.info = snd_echo_output_gain_info,
 	.get = snd_echo_output_gain_get,
 	.put = snd_echo_output_gain_put,
+	.tlv = {.p = db_scale_output_gain},
 };
 #else
 static struct snd_kcontrol_new snd_echo_pcm_output_gain __devinitdata = {
 	.name = "PCM Playback Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,
 	.info = snd_echo_output_gain_info,
 	.get = snd_echo_output_gain_get,
 	.put = snd_echo_output_gain_put,
+	.tlv = {.p = db_scale_output_gain},
 };
 #endif
 
@@ -1080,12 +1085,16 @@
 	return changed;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_input_gain, -2500, 50, 0);
+
 static struct snd_kcontrol_new snd_echo_line_input_gain __devinitdata = {
 	.name = "Line Capture Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,
 	.info = snd_echo_input_gain_info,
 	.get = snd_echo_input_gain_get,
 	.put = snd_echo_input_gain_put,
+	.tlv = {.p = db_scale_input_gain},
 };
 
 #endif /* ECHOCARD_HAS_INPUT_GAIN */
@@ -1277,9 +1286,11 @@
 static struct snd_kcontrol_new snd_echo_monitor_mixer __devinitdata = {
 	.name = "Monitor Mixer Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,
 	.info = snd_echo_mixer_info,
 	.get = snd_echo_mixer_get,
 	.put = snd_echo_mixer_put,
+	.tlv = {.p = db_scale_output_gain},
 };
 
 #endif /* ECHOCARD_HAS_MONITOR */
@@ -1343,9 +1354,11 @@
 static struct snd_kcontrol_new snd_echo_vmixer __devinitdata = {
 	.name = "VMixer Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ,
 	.info = snd_echo_vmixer_info,
 	.get = snd_echo_vmixer_get,
 	.put = snd_echo_vmixer_put,
+	.tlv = {.p = db_scale_output_gain},
 };
 
 #endif /* ECHOCARD_HAS_VMIXER */
@@ -1753,9 +1766,12 @@
 static struct snd_kcontrol_new snd_echo_vumeters __devinitdata = {
 	.name = "VU-meters",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |
+		  SNDRV_CTL_ELEM_ACCESS_VOLATILE |
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
 	.info = snd_echo_vumeters_info,
 	.get = snd_echo_vumeters_get,
+	.tlv = {.p = db_scale_output_gain},
 };
 
 
@@ -1873,7 +1889,7 @@
 	DE_INIT(("Stopped.\n"));
 
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 
 	if (chip->dsp_registers)
 		iounmap(chip->dsp_registers);
@@ -2018,6 +2034,8 @@
 	if (card == NULL)
 		return -ENOMEM;
 
+	snd_card_set_dev(card, &pci->dev);
+
 	if ((err = snd_echo_create(card, pci, &chip)) < 0) {
 		snd_card_free(card);
 		return err;
--- linux-2.6.18.noarch/sound/pci/echoaudio/mia.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/mia.c	2007-06-05 17:46:10.000000000 -0400
@@ -56,6 +56,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/layla20.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/layla20.c	2007-06-05 17:46:10.000000000 -0400
@@ -56,6 +56,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/midi.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/midi.c	2007-06-05 17:46:10.000000000 -0400
@@ -213,7 +213,7 @@
 	sent = bytes = 0;
 	spin_lock_irqsave(&chip->lock, flags);
 	chip->midi_full = 0;
-	if (chip->midi_out && !snd_rawmidi_transmit_empty(chip->midi_out)) {
+	if (!snd_rawmidi_transmit_empty(chip->midi_out)) {
 		bytes = snd_rawmidi_transmit_peek(chip->midi_out, buf,
 						  MIDI_OUT_BUFFER_SIZE - 1);
 		DE_MID(("Try to send %d bytes...\n", bytes));
@@ -264,9 +264,11 @@
 		}
 	} else {
 		if (chip->tinuse) {
-			del_timer(&chip->timer);
 			chip->tinuse = 0;
+			spin_unlock_irq(&chip->lock);
+			del_timer_sync(&chip->timer);
 			DE_MID(("Timer removed\n"));
+			return;
 		}
 	}
 	spin_unlock_irq(&chip->lock);
--- linux-2.6.18.noarch/sound/pci/echoaudio/indigodj.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/indigodj.c	2007-06-05 17:46:10.000000000 -0400
@@ -49,6 +49,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/darla20.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/darla20.c	2007-06-05 17:46:10.000000000 -0400
@@ -47,6 +47,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/gina24.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/gina24.c	2007-06-05 17:46:10.000000000 -0400
@@ -57,6 +57,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/echoaudio/echo3g.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/echoaudio/echo3g.c	2007-06-05 17:46:10.000000000 -0400
@@ -58,6 +58,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
--- linux-2.6.18.noarch/sound/pci/cs4281.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cs4281.c	2007-06-05 17:47:00.000000000 -0400
@@ -33,6 +33,7 @@
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/ac97_codec.h>
+#include <sound/tlv.h>
 #include <sound/opl3.h>
 #include <sound/initval.h>
 
@@ -1054,6 +1055,8 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -4650, 150, 0);
+
 static struct snd_kcontrol_new snd_cs4281_fm_vol = 
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1062,6 +1065,7 @@
 	.get = snd_cs4281_get_volume,
 	.put = snd_cs4281_put_volume, 
 	.private_value = ((BA0_FMLVC << 16) | BA0_FMRVC),
+	.tlv = { .p = db_scale_dsp },
 };
 
 static struct snd_kcontrol_new snd_cs4281_pcm_vol = 
@@ -1072,6 +1076,7 @@
 	.get = snd_cs4281_get_volume,
 	.put = snd_cs4281_put_volume, 
 	.private_value = ((BA0_PPLVC << 16) | BA0_PPRVC),
+	.tlv = { .p = db_scale_dsp },
 };
 
 static void snd_cs4281_mixer_free_ac97_bus(struct snd_ac97_bus *bus)
@@ -2045,6 +2050,7 @@
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2055,8 +2061,14 @@
 	unsigned int i;
 	u32 ulCLK;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "cs4281: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
--- linux-2.6.18.noarch/sound/pci/ac97/ac97_patch.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ac97_patch.c	2007-06-05 17:45:08.000000000 -0400
@@ -32,6 +32,7 @@
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/ac97_codec.h>
 #include "ac97_patch.h"
 #include "ac97_id.h"
@@ -51,6 +52,20 @@
 	return 0;
 }
 
+/* replace with a new TLV */
+static void reset_tlv(struct snd_ac97 *ac97, const char *name,
+		      const unsigned int *tlv)
+{
+	struct snd_ctl_elem_id sid;
+	struct snd_kcontrol *kctl;
+	memset(&sid, 0, sizeof(sid));
+	strcpy(sid.name, name);
+	sid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	kctl = snd_ctl_find_id(ac97->bus->card, &sid);
+	if (kctl && kctl->tlv.p)
+		kctl->tlv.p = tlv;
+}
+
 /* set to the page, update bits and restore the page */
 static int ac97_update_bits_page(struct snd_ac97 *ac97, unsigned short reg, unsigned short mask, unsigned short value, unsigned short page)
 {
@@ -175,14 +190,28 @@
 	return ac97->channel_mode >= 2;
 }
 
+/* system has shared jacks with surround out enabled */
+static inline int is_shared_surrout(struct snd_ac97 *ac97)
+{
+	return !ac97->indep_surround && is_surround_on(ac97);
+}
+
+/* system has shared jacks with center/lfe out enabled */
+static inline int is_shared_clfeout(struct snd_ac97 *ac97)
+{
+	return !ac97->indep_surround && is_clfe_on(ac97);
+}
+
+/* system has shared jacks with line in enabled */
 static inline int is_shared_linein(struct snd_ac97 *ac97)
 {
-	return ! ac97->indep_surround && is_surround_on(ac97);
+	return !ac97->indep_surround && !is_surround_on(ac97);
 }
 
+/* system has shared jacks with mic in enabled */
 static inline int is_shared_micin(struct snd_ac97 *ac97)
 {
-	return ! ac97->indep_surround && is_clfe_on(ac97);
+	return !ac97->indep_surround && !is_clfe_on(ac97);
 }
 
 
@@ -466,7 +495,7 @@
 	ac97->build_ops = &patch_wolfson_wm9705_ops;
 #ifdef CONFIG_TOUCHSCREEN_WM9705
 	/* WM9705 touchscreen uses AUX and VIDEO for touch */
-	ac97->flags |=3D AC97_HAS_NO_VIDEO | AC97_HAS_NO_AUX;
+	ac97->flags |= AC97_HAS_NO_VIDEO | AC97_HAS_NO_AUX;
 #endif
 	return 0;
 }
@@ -515,7 +544,7 @@
 AC97_SINGLE("ALC Headphone Volume", AC97_VIDEO, 7, 7, 1),
 
 AC97_SINGLE("Out3 Switch", AC97_AUX, 15, 1, 1),
-AC97_SINGLE("Out3 ZC Switch", AC97_AUX, 7, 1, 1),
+AC97_SINGLE("Out3 ZC Switch", AC97_AUX, 7, 1, 0),
 AC97_ENUM("Out3 Mux", wm9711_enum[2]),
 AC97_ENUM("Out3 LR Mux", wm9711_enum[3]),
 AC97_SINGLE("Out3 Volume", AC97_AUX, 0, 31, 1),
@@ -560,13 +589,14 @@
 
 AC97_SINGLE("ADC Switch", AC97_REC_GAIN, 15, 1, 1),
 AC97_ENUM("Capture Volume Steps", wm9711_enum[6]),
-AC97_DOUBLE("Capture Volume", AC97_REC_GAIN, 8, 0, 15, 1),
+AC97_DOUBLE("Capture Volume", AC97_REC_GAIN, 8, 0, 63, 1),
 AC97_SINGLE("Capture ZC Switch", AC97_REC_GAIN, 7, 1, 0),
 
 AC97_SINGLE("Mic 1 to Phone Switch", AC97_MIC, 14, 1, 1),
 AC97_SINGLE("Mic 2 to Phone Switch", AC97_MIC, 13, 1, 1),
 AC97_ENUM("Mic Select Source", wm9711_enum[7]),
-AC97_SINGLE("Mic 1 Volume", AC97_MIC, 8, 32, 1),
+AC97_SINGLE("Mic 1 Volume", AC97_MIC, 8, 31, 1),
+AC97_SINGLE("Mic 2 Volume", AC97_MIC, 0, 31, 1),
 AC97_SINGLE("Mic 20dB Boost Switch", AC97_MIC, 7, 1, 0),
 
 AC97_SINGLE("Master ZC Switch", AC97_MASTER, 7, 1, 0),
@@ -925,6 +955,9 @@
 {
 	int err;
 
+	/* the register bit is writable, but the function is not implemented: */
+	snd_ac97_remove_ctl(ac97, "PCM Out Path & Mute", NULL);
+
 	snd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Sigmatel Surround Playback");
 	if ((err = patch_build_controls(ac97, &snd_ac97_stac9708_bias_control, 1)) < 0)
 		return err;
@@ -1305,6 +1338,12 @@
 	return 0;
 }
 
+int patch_cx20551(struct snd_ac97 *ac97)
+{
+	snd_ac97_update_bits(ac97, 0x5c, 0x01, 0x01);
+	return 0;
+}
+
 /*
  * Analog Device AD18xx, AD19xx codecs
  */
@@ -1380,6 +1419,17 @@
 
 #endif
 
+static const struct snd_ac97_res_table ad1819_restbl[] = {
+	{ AC97_PHONE, 0x9f1f },
+	{ AC97_MIC, 0x9f1f },
+	{ AC97_LINE, 0x9f1f },
+	{ AC97_CD, 0x9f1f },
+	{ AC97_VIDEO, 0x9f1f },
+	{ AC97_AUX, 0x9f1f },
+	{ AC97_PCM, 0x9f1f },
+	{ } /* terminator */
+};
+
 int patch_ad1819(struct snd_ac97 * ac97)
 {
 	unsigned short scfg;
@@ -1387,6 +1437,7 @@
 	// patch for Analog Devices
 	scfg = snd_ac97_read(ac97, AC97_AD_SERIAL_CFG);
 	snd_ac97_write_cache(ac97, AC97_AD_SERIAL_CFG, scfg | 0x7000); /* select all codecs */
+	ac97->res_table = ad1819_restbl;
 	return 0;
 }
 
@@ -1439,7 +1490,9 @@
 	snd_ac97_write_cache(ac97, AC97_AD_CODEC_CFG, 0x0002);		// ID1C
 	ac97->spec.ad18xx.codec_cfg[unchained_idx] = 0x0002;
 	if (cidx1 >= 0) {
-		if (patch_ad1881_chained1(ac97, cidx1, 0x0006))		// SDIE | ID1C
+		if (cidx2 < 0)
+			patch_ad1881_chained1(ac97, cidx1, 0);
+		else if (patch_ad1881_chained1(ac97, cidx1, 0x0006))	// SDIE | ID1C
 			patch_ad1881_chained1(ac97, cidx2, 0);
 		else if (patch_ad1881_chained1(ac97, cidx2, 0x0006))	// SDIE | ID1C
 			patch_ad1881_chained1(ac97, cidx1, 0);
@@ -1522,12 +1575,16 @@
 	AC97_SINGLE("Line Jack Sense", AC97_AD_JACK_SPDIF, 8, 1, 1), /* inverted */
 };
 
+static const DECLARE_TLV_DB_SCALE(db_scale_6bit_6db_max, -8850, 150, 0);
+
 static int patch_ad1885_specific(struct snd_ac97 * ac97)
 {
 	int err;
 
 	if ((err = patch_build_controls(ac97, snd_ac97_controls_ad1885, ARRAY_SIZE(snd_ac97_controls_ad1885))) < 0)
 		return err;
+	reset_tlv(ac97, "Headphone Playback Volume",
+		  db_scale_6bit_6db_max);
 	return 0;
 }
 
@@ -1551,28 +1608,46 @@
 	return 0;
 }
 
+static int patch_ad1886_specific(struct snd_ac97 * ac97)
+{
+	reset_tlv(ac97, "Headphone Playback Volume",
+		  db_scale_6bit_6db_max);
+	return 0;
+}
+
+static struct snd_ac97_build_ops patch_ad1886_build_ops = {
+	.build_specific = &patch_ad1886_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume
+#endif
+};
+
 int patch_ad1886(struct snd_ac97 * ac97)
 {
 	patch_ad1881(ac97);
 	/* Presario700 workaround */
 	/* for Jack Sense/SPDIF Register misetting causing */
 	snd_ac97_write_cache(ac97, AC97_AD_JACK_SPDIF, 0x0010);
+	ac97->build_ops = &patch_ad1886_build_ops;
 	return 0;
 }
 
-/* MISC bits */
+/* MISC bits (AD1888/AD1980/AD1985 register 0x76) */
 #define AC97_AD198X_MBC		0x0003	/* mic boost */
 #define AC97_AD198X_MBC_20	0x0000	/* +20dB */
 #define AC97_AD198X_MBC_10	0x0001	/* +10dB */
 #define AC97_AD198X_MBC_30	0x0002	/* +30dB */
 #define AC97_AD198X_VREFD	0x0004	/* VREF high-Z */
-#define AC97_AD198X_VREFH	0x0008	/* 2.25V, 3.7V */
-#define AC97_AD198X_VREF_0	0x000c	/* 0V */
+#define AC97_AD198X_VREFH	0x0008	/* 0=2.25V, 1=3.7V */
+#define AC97_AD198X_VREF_0	0x000c	/* 0V (AD1985 only) */
+#define AC97_AD198X_VREF_MASK	(AC97_AD198X_VREFH | AC97_AD198X_VREFD)
+#define AC97_AD198X_VREF_SHIFT	2
 #define AC97_AD198X_SRU		0x0010	/* sample rate unlock */
 #define AC97_AD198X_LOSEL	0x0020	/* LINE_OUT amplifiers input select */
 #define AC97_AD198X_2MIC	0x0040	/* 2-channel mic select */
 #define AC97_AD198X_SPRD	0x0080	/* SPREAD enable */
-#define AC97_AD198X_DMIX0	0x0100	/* downmix mode: 0 = 6-to-4, 1 = 6-to-2 downmix */
+#define AC97_AD198X_DMIX0	0x0100	/* downmix mode: */
+					/*  0 = 6-to-4, 1 = 6-to-2 downmix */
 #define AC97_AD198X_DMIX1	0x0200	/* downmix mode: 1 = enabled */
 #define AC97_AD198X_HPSEL	0x0400	/* headphone amplifier input select */
 #define AC97_AD198X_CLDIS	0x0800	/* center/lfe disable */
@@ -1581,6 +1656,83 @@
 #define AC97_AD198X_AC97NC	0x4000	/* AC97 no compatible mode */
 #define AC97_AD198X_DACZ	0x8000	/* DAC zero-fill mode */
 
+/* MISC 1 bits (AD1986 register 0x76) */
+#define AC97_AD1986_MBC		0x0003	/* mic boost */
+#define AC97_AD1986_MBC_20	0x0000	/* +20dB */
+#define AC97_AD1986_MBC_10	0x0001	/* +10dB */
+#define AC97_AD1986_MBC_30	0x0002	/* +30dB */
+#define AC97_AD1986_LISEL0	0x0004	/* LINE_IN select bit 0 */
+#define AC97_AD1986_LISEL1	0x0008	/* LINE_IN select bit 1 */
+#define AC97_AD1986_LISEL_MASK	(AC97_AD1986_LISEL1 | AC97_AD1986_LISEL0)
+#define AC97_AD1986_LISEL_LI	0x0000  /* LINE_IN pins as LINE_IN source */
+#define AC97_AD1986_LISEL_SURR	0x0004  /* SURROUND pins as LINE_IN source */
+#define AC97_AD1986_LISEL_MIC	0x0008  /* MIC_1/2 pins as LINE_IN source */
+#define AC97_AD1986_SRU		0x0010	/* sample rate unlock */
+#define AC97_AD1986_SOSEL	0x0020	/* SURROUND_OUT amplifiers input sel */
+#define AC97_AD1986_2MIC	0x0040	/* 2-channel mic select */
+#define AC97_AD1986_SPRD	0x0080	/* SPREAD enable */
+#define AC97_AD1986_DMIX0	0x0100	/* downmix mode: */
+					/*  0 = 6-to-4, 1 = 6-to-2 downmix */
+#define AC97_AD1986_DMIX1	0x0200	/* downmix mode: 1 = enabled */
+#define AC97_AD1986_CLDIS	0x0800	/* center/lfe disable */
+#define AC97_AD1986_SODIS	0x1000	/* SURROUND_OUT disable */
+#define AC97_AD1986_MSPLT	0x2000	/* mute split (read only 1) */
+#define AC97_AD1986_AC97NC	0x4000	/* AC97 no compatible mode (r/o 1) */
+#define AC97_AD1986_DACZ	0x8000	/* DAC zero-fill mode */
+
+/* MISC 2 bits (AD1986 register 0x70) */
+#define AC97_AD_MISC2		0x70	/* Misc Control Bits 2 (AD1986) */
+
+#define AC97_AD1986_CVREF0	0x0004	/* C/LFE VREF_OUT 2.25V */
+#define AC97_AD1986_CVREF1	0x0008	/* C/LFE VREF_OUT 0V */
+#define AC97_AD1986_CVREF2	0x0010	/* C/LFE VREF_OUT 3.7V */
+#define AC97_AD1986_CVREF_MASK \
+	(AC97_AD1986_CVREF2 | AC97_AD1986_CVREF1 | AC97_AD1986_CVREF0)
+#define AC97_AD1986_JSMAP	0x0020	/* Jack Sense Mapping 1 = alternate */
+#define AC97_AD1986_MMDIS	0x0080	/* Mono Mute Disable */
+#define AC97_AD1986_MVREF0	0x0400	/* MIC VREF_OUT 2.25V */
+#define AC97_AD1986_MVREF1	0x0800	/* MIC VREF_OUT 0V */
+#define AC97_AD1986_MVREF2	0x1000	/* MIC VREF_OUT 3.7V */
+#define AC97_AD1986_MVREF_MASK \
+	(AC97_AD1986_MVREF2 | AC97_AD1986_MVREF1 | AC97_AD1986_MVREF0)
+
+/* MISC 3 bits (AD1986 register 0x7a) */
+#define AC97_AD_MISC3		0x7a	/* Misc Control Bits 3 (AD1986) */
+
+#define AC97_AD1986_MMIX	0x0004	/* Mic Mix, left/right */
+#define AC97_AD1986_GPO		0x0008	/* General Purpose Out */
+#define AC97_AD1986_LOHPEN	0x0010	/* LINE_OUT headphone drive */
+#define AC97_AD1986_LVREF0	0x0100	/* LINE_OUT VREF_OUT 2.25V */
+#define AC97_AD1986_LVREF1	0x0200	/* LINE_OUT VREF_OUT 0V */
+#define AC97_AD1986_LVREF2	0x0400	/* LINE_OUT VREF_OUT 3.7V */
+#define AC97_AD1986_LVREF_MASK \
+	(AC97_AD1986_LVREF2 | AC97_AD1986_LVREF1 | AC97_AD1986_LVREF0)
+#define AC97_AD1986_JSINVA	0x0800	/* Jack Sense Invert SENSE_A */
+#define AC97_AD1986_LOSEL	0x1000	/* LINE_OUT amplifiers input select */
+#define AC97_AD1986_HPSEL0	0x2000	/* Headphone amplifiers */
+					/*   input select Surround DACs */
+#define AC97_AD1986_HPSEL1	0x4000	/* Headphone amplifiers input */
+					/*   select C/LFE DACs */
+#define AC97_AD1986_JSINVB	0x8000	/* Jack Sense Invert SENSE_B */
+
+/* Serial Config bits (AD1986 register 0x74) (incomplete) */
+#define AC97_AD1986_OMS0	0x0100	/* Optional Mic Selector bit 0 */
+#define AC97_AD1986_OMS1	0x0200	/* Optional Mic Selector bit 1 */
+#define AC97_AD1986_OMS2	0x0400	/* Optional Mic Selector bit 2 */
+#define AC97_AD1986_OMS_MASK \
+	(AC97_AD1986_OMS2 | AC97_AD1986_OMS1 | AC97_AD1986_OMS0)
+#define AC97_AD1986_OMS_M	0x0000  /* MIC_1/2 pins are MIC sources */
+#define AC97_AD1986_OMS_L	0x0100  /* LINE_IN pins are MIC sources */
+#define AC97_AD1986_OMS_C	0x0200  /* Center/LFE pins are MCI sources */
+#define AC97_AD1986_OMS_MC	0x0400  /* Mix of MIC and C/LFE pins */
+					/*   are MIC sources */
+#define AC97_AD1986_OMS_ML	0x0500  /* MIX of MIC and LINE_IN pins */
+					/*   are MIC sources */
+#define AC97_AD1986_OMS_LC	0x0600  /* MIX of LINE_IN and C/LFE pins */
+					/*   are MIC sources */
+#define AC97_AD1986_OMS_MLC	0x0700  /* MIX of MIC, LINE_IN, C/LFE pins */
+					/*   are MIC sources */
+
 
 static int snd_ac97_ad198x_spdif_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -1638,6 +1790,8 @@
  * (SS vendor << 16 | device)
  */
 static unsigned int ad1981_jacks_blacklist[] = {
+	0x10140523, /* Thinkpad R40 */
+	0x10140534, /* Thinkpad X31 */
 	0x10140537, /* Thinkpad T41p */
 	0x10140554, /* Thinkpad T42p/R50p */
 	0 /* end */
@@ -1808,9 +1962,11 @@
 static void ad1888_update_jacks(struct snd_ac97 *ac97)
 {
 	unsigned short val = 0;
-	if (! is_shared_linein(ac97))
+	/* clear LODIS if shared jack is to be used for Surround out */
+	if (is_shared_linein(ac97))
 		val |= (1 << 12);
-	if (! is_shared_micin(ac97))
+	/* clear CLDIS if shared jack is to be used for C/LFE out */
+	if (is_shared_micin(ac97))
 		val |= (1 << 11);
 	/* shared Line-In */
 	snd_ac97_update_bits(ac97, AC97_AD_MISC, (1 << 11) | (1 << 12), val);
@@ -1903,24 +2059,104 @@
 	return 0;
 }
 
+static int snd_ac97_ad1985_vrefout_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[4] = {"High-Z", "3.7 V", "2.25 V", "0 V"};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 4;
+	if (uinfo->value.enumerated.item > 3)
+		uinfo->value.enumerated.item = 3;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_ac97_ad1985_vrefout_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	static const int reg2ctrl[4] = {2, 0, 1, 3};
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned short val;
+	val = (ac97->regs[AC97_AD_MISC] & AC97_AD198X_VREF_MASK)
+	      >> AC97_AD198X_VREF_SHIFT;
+	ucontrol->value.enumerated.item[0] = reg2ctrl[val];
+	return 0;
+}
+
+static int snd_ac97_ad1985_vrefout_put(struct snd_kcontrol *kcontrol, 
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	static const int ctrl2reg[4] = {1, 2, 0, 3};
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned short val;
+
+	if (ucontrol->value.enumerated.item[0] > 3
+	    || ucontrol->value.enumerated.item[0] < 0)
+		return -EINVAL;
+	val = ctrl2reg[ucontrol->value.enumerated.item[0]]
+	      << AC97_AD198X_VREF_SHIFT;
+	return snd_ac97_update_bits(ac97, AC97_AD_MISC,
+				    AC97_AD198X_VREF_MASK, val);
+}
+
 static const struct snd_kcontrol_new snd_ac97_ad1985_controls[] = {
-	AC97_SINGLE("Exchange Center/LFE", AC97_AD_SERIAL_CFG, 3, 1, 0)
+	AC97_SINGLE("Exchange Center/LFE", AC97_AD_SERIAL_CFG, 3, 1, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Exchange Front/Surround",
+		.info = snd_ac97_ad1888_lohpsel_info,
+		.get = snd_ac97_ad1888_lohpsel_get,
+		.put = snd_ac97_ad1888_lohpsel_put
+	},
+	AC97_SINGLE("High Pass Filter Enable", AC97_AD_TEST2, 12, 1, 1),
+	AC97_SINGLE("Spread Front to Surround and Center/LFE",
+		    AC97_AD_MISC, 7, 1, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Downmix",
+		.info = snd_ac97_ad1888_downmix_info,
+		.get = snd_ac97_ad1888_downmix_get,
+		.put = snd_ac97_ad1888_downmix_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "V_REFOUT",
+		.info = snd_ac97_ad1985_vrefout_info,
+		.get = snd_ac97_ad1985_vrefout_get,
+		.put = snd_ac97_ad1985_vrefout_put
+	},
+	AC97_SURROUND_JACK_MODE_CTL,
+	AC97_CHANNEL_MODE_CTL,
+
+	AC97_SINGLE("Headphone Jack Sense", AC97_AD_JACK_SPDIF, 10, 1, 0),
+	AC97_SINGLE("Line Jack Sense", AC97_AD_JACK_SPDIF, 12, 1, 0),
 };
 
 static void ad1985_update_jacks(struct snd_ac97 *ac97)
 {
 	ad1888_update_jacks(ac97);
+	/* clear OMS if shared jack is to be used for C/LFE out */
 	snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG, 1 << 9,
-			     is_shared_micin(ac97) ? 0 : 1 << 9);
+			     is_shared_micin(ac97) ? 1 << 9 : 0);
 }
 
 static int patch_ad1985_specific(struct snd_ac97 *ac97)
 {
 	int err;
 
-	if ((err = patch_ad1980_specific(ac97)) < 0)
+	/* rename 0x04 as "Master" and 0x02 as "Master Surround" */
+	snd_ac97_rename_vol_ctl(ac97, "Master Playback",
+				"Master Surround Playback");
+	snd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");
+
+	if ((err = patch_build_controls(ac97, &snd_ac97_ad198x_2cmic, 1)) < 0)
 		return err;
-	return patch_build_controls(ac97, snd_ac97_ad1985_controls, ARRAY_SIZE(snd_ac97_ad1985_controls));
+
+	return patch_build_controls(ac97, snd_ac97_ad1985_controls,
+				    ARRAY_SIZE(snd_ac97_ad1985_controls));
 }
 
 static struct snd_ac97_build_ops patch_ad1985_build_ops = {
@@ -1940,24 +2176,311 @@
 	ac97->build_ops = &patch_ad1985_build_ops;
 	misc = snd_ac97_read(ac97, AC97_AD_MISC);
 	/* switch front/surround line-out/hp-out */
-	/* center/LFE, mic in 3.75V mode */
 	/* AD-compatible mode */
 	/* Stereo mutes enabled */
-	/* in accordance with ADI driver: misc | 0x5c28 */
 	snd_ac97_write_cache(ac97, AC97_AD_MISC, misc |
-			     AC97_AD198X_VREFH |
 			     AC97_AD198X_LOSEL |
 			     AC97_AD198X_HPSEL |
-			     AC97_AD198X_CLDIS |
-			     AC97_AD198X_LODIS |
 			     AC97_AD198X_MSPLT |
 			     AC97_AD198X_AC97NC);
 	ac97->flags |= AC97_STEREO_MUTES;
+
+	/* update current jack configuration */
+	ad1985_update_jacks(ac97);
+
 	/* on AD1985 rev. 3, AC'97 revision bits are zero */
 	ac97->ext_id = (ac97->ext_id & ~AC97_EI_REV_MASK) | AC97_EI_REV_23;
 	return 0;
 }
 
+static int snd_ac97_ad1986_bool_info(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_ac97_ad1986_lososel_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned short val;
+
+	val = ac97->regs[AC97_AD_MISC3];
+	ucontrol->value.integer.value[0] = (val & AC97_AD1986_LOSEL) != 0;
+	return 0;
+}
+
+static int snd_ac97_ad1986_lososel_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	int ret0;
+	int ret1;
+	int sprd = (ac97->regs[AC97_AD_MISC] & AC97_AD1986_SPRD) != 0;
+
+	ret0 = snd_ac97_update_bits(ac97, AC97_AD_MISC3, AC97_AD1986_LOSEL,
+					ucontrol->value.integer.value[0] != 0
+				    ? AC97_AD1986_LOSEL : 0);
+	if (ret0 < 0)
+		return ret0;
+
+	/* SOSEL is set to values of "Spread" or "Exchange F/S" controls */
+	ret1 = snd_ac97_update_bits(ac97, AC97_AD_MISC, AC97_AD1986_SOSEL,
+				    (ucontrol->value.integer.value[0] != 0
+				     || sprd)
+				    ? AC97_AD1986_SOSEL : 0);
+	if (ret1 < 0)
+		return ret1;
+
+	return (ret0 > 0 || ret1 > 0) ? 1 : 0;
+}
+
+static int snd_ac97_ad1986_spread_get(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned short val;
+
+	val = ac97->regs[AC97_AD_MISC];
+	ucontrol->value.integer.value[0] = (val & AC97_AD1986_SPRD) != 0;
+	return 0;
+}
+
+static int snd_ac97_ad1986_spread_put(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	int ret0;
+	int ret1;
+	int sprd = (ac97->regs[AC97_AD_MISC3] & AC97_AD1986_LOSEL) != 0;
+
+	ret0 = snd_ac97_update_bits(ac97, AC97_AD_MISC, AC97_AD1986_SPRD,
+					ucontrol->value.integer.value[0] != 0
+				    ? AC97_AD1986_SPRD : 0);
+	if (ret0 < 0)
+		return ret0;
+
+	/* SOSEL is set to values of "Spread" or "Exchange F/S" controls */
+	ret1 = snd_ac97_update_bits(ac97, AC97_AD_MISC, AC97_AD1986_SOSEL,
+				    (ucontrol->value.integer.value[0] != 0
+				     || sprd)
+				    ? AC97_AD1986_SOSEL : 0);
+	if (ret1 < 0)
+		return ret1;
+
+	return (ret0 > 0 || ret1 > 0) ? 1 : 0;
+}
+
+static int snd_ac97_ad1986_miclisel_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = ac97->spec.ad18xx.swap_mic_linein;
+	return 0;
+}
+
+static int snd_ac97_ad1986_miclisel_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned char swap = ucontrol->value.integer.value[0] != 0;
+
+	if (swap != ac97->spec.ad18xx.swap_mic_linein) {
+		ac97->spec.ad18xx.swap_mic_linein = swap;
+		if (ac97->build_ops->update_jacks)
+			ac97->build_ops->update_jacks(ac97);
+		return 1;
+	}
+	return 0;
+}
+
+static int snd_ac97_ad1986_vrefout_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	/* Use MIC_1/2 V_REFOUT as the "get" value */
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned short val;
+	unsigned short reg = ac97->regs[AC97_AD_MISC2];
+	if ((reg & AC97_AD1986_MVREF0) != 0)
+		val = 2;
+	else if ((reg & AC97_AD1986_MVREF1) != 0)
+		val = 3;
+	else if ((reg & AC97_AD1986_MVREF2) != 0)
+		val = 1;
+	else
+		val = 0;
+	ucontrol->value.enumerated.item[0] = val;
+	return 0;
+}
+
+static int snd_ac97_ad1986_vrefout_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);
+	unsigned short cval;
+	unsigned short lval;
+	unsigned short mval;
+	int cret;
+	int lret;
+	int mret;
+
+	switch (ucontrol->value.enumerated.item[0])
+	{
+	case 0: /* High-Z */
+		cval = 0;
+		lval = 0;
+		mval = 0;
+		break;
+	case 1: /* 3.7 V */
+		cval = AC97_AD1986_CVREF2;
+		lval = AC97_AD1986_LVREF2;
+		mval = AC97_AD1986_MVREF2;
+		break;
+	case 2: /* 2.25 V */
+		cval = AC97_AD1986_CVREF0;
+		lval = AC97_AD1986_LVREF0;
+		mval = AC97_AD1986_MVREF0;
+		break;
+	case 3: /* 0 V */
+		cval = AC97_AD1986_CVREF1;
+		lval = AC97_AD1986_LVREF1;
+		mval = AC97_AD1986_MVREF1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	cret = snd_ac97_update_bits(ac97, AC97_AD_MISC2,
+				    AC97_AD1986_CVREF_MASK, cval);
+	if (cret < 0)
+		return cret;
+	lret = snd_ac97_update_bits(ac97, AC97_AD_MISC3,
+				    AC97_AD1986_LVREF_MASK, lval);
+	if (lret < 0)
+		return lret;
+	mret = snd_ac97_update_bits(ac97, AC97_AD_MISC2,
+				    AC97_AD1986_MVREF_MASK, mval);
+	if (mret < 0)
+		return mret;
+
+	return (cret > 0 || lret > 0 || mret > 0) ? 1 : 0;
+}
+
+static const struct snd_kcontrol_new snd_ac97_ad1986_controls[] = {
+	AC97_SINGLE("Exchange Center/LFE", AC97_AD_SERIAL_CFG, 3, 1, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Exchange Front/Surround",
+		.info = snd_ac97_ad1986_bool_info,
+		.get = snd_ac97_ad1986_lososel_get,
+		.put = snd_ac97_ad1986_lososel_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Exchange Mic/Line In",
+		.info = snd_ac97_ad1986_bool_info,
+		.get = snd_ac97_ad1986_miclisel_get,
+		.put = snd_ac97_ad1986_miclisel_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Spread Front to Surround and Center/LFE",
+		.info = snd_ac97_ad1986_bool_info,
+		.get = snd_ac97_ad1986_spread_get,
+		.put = snd_ac97_ad1986_spread_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Downmix",
+		.info = snd_ac97_ad1888_downmix_info,
+		.get = snd_ac97_ad1888_downmix_get,
+		.put = snd_ac97_ad1888_downmix_put
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "V_REFOUT",
+		.info = snd_ac97_ad1985_vrefout_info,
+		.get = snd_ac97_ad1986_vrefout_get,
+		.put = snd_ac97_ad1986_vrefout_put
+	},
+	AC97_SURROUND_JACK_MODE_CTL,
+	AC97_CHANNEL_MODE_CTL,
+
+	AC97_SINGLE("Headphone Jack Sense", AC97_AD_JACK_SPDIF, 10, 1, 0),
+	AC97_SINGLE("Line Jack Sense", AC97_AD_JACK_SPDIF, 12, 1, 0)
+};
+
+static void ad1986_update_jacks(struct snd_ac97 *ac97)
+{
+	unsigned short misc_val = 0;
+	unsigned short ser_val;
+
+	/* disable SURROUND and CENTER/LFE if not surround mode */
+	if (!is_surround_on(ac97))
+		misc_val |= AC97_AD1986_SODIS;
+	if (!is_clfe_on(ac97))
+		misc_val |= AC97_AD1986_CLDIS;
+
+	/* select line input (default=LINE_IN, SURROUND or MIC_1/2) */
+	if (is_shared_linein(ac97))
+		misc_val |= AC97_AD1986_LISEL_SURR;
+	else if (ac97->spec.ad18xx.swap_mic_linein != 0)
+		misc_val |= AC97_AD1986_LISEL_MIC;
+	snd_ac97_update_bits(ac97, AC97_AD_MISC,
+			     AC97_AD1986_SODIS | AC97_AD1986_CLDIS |
+			     AC97_AD1986_LISEL_MASK,
+			     misc_val);
+
+	/* select microphone input (MIC_1/2, Center/LFE or LINE_IN) */
+	if (is_shared_micin(ac97))
+		ser_val = AC97_AD1986_OMS_C;
+	else if (ac97->spec.ad18xx.swap_mic_linein != 0)
+		ser_val = AC97_AD1986_OMS_L;
+	else
+		ser_val = AC97_AD1986_OMS_M;
+	snd_ac97_update_bits(ac97, AC97_AD_SERIAL_CFG,
+			     AC97_AD1986_OMS_MASK,
+			     ser_val);
+}
+
+static int patch_ad1986_specific(struct snd_ac97 *ac97)
+{
+	int err;
+
+	if ((err = patch_build_controls(ac97, &snd_ac97_ad198x_2cmic, 1)) < 0)
+		return err;
+
+	return patch_build_controls(ac97, snd_ac97_ad1986_controls,
+				    ARRAY_SIZE(snd_ac97_ad1985_controls));
+}
+
+static struct snd_ac97_build_ops patch_ad1986_build_ops = {
+	.build_post_spdif = patch_ad198x_post_spdif,
+	.build_specific = patch_ad1986_specific,
+#ifdef CONFIG_PM
+	.resume = ad18xx_resume,
+#endif
+	.update_jacks = ad1986_update_jacks,
+};
+
+int patch_ad1986(struct snd_ac97 * ac97)
+{
+	patch_ad1881(ac97);
+	ac97->build_ops = &patch_ad1986_build_ops;
+	ac97->flags |= AC97_STEREO_MUTES;
+
+	/* update current jack configuration */
+	ad1986_update_jacks(ac97);
+
+	return 0;
+}
+
+
 /*
  * realtek ALC65x/850 codecs
  */
@@ -1965,12 +2488,12 @@
 {
 	int shared;
 	
-	/* shared Line-In */
-	shared = is_shared_linein(ac97);
+	/* shared Line-In / Surround Out */
+	shared = is_shared_surrout(ac97);
 	snd_ac97_update_bits(ac97, AC97_ALC650_MULTICH, 1 << 9,
 			     shared ? (1 << 9) : 0);
-	/* update shared Mic */
-	shared = is_shared_micin(ac97);
+	/* update shared Mic In / Center/LFE Out */
+	shared = is_shared_clfeout(ac97);
 	/* disable/enable vref */
 	snd_ac97_update_bits(ac97, AC97_ALC650_CLOCK, 1 << 12,
 			     shared ? (1 << 12) : 0);
@@ -2015,6 +2538,8 @@
 	/* AC97_SINGLE("IEC958 Input Monitor", AC97_ALC650_MULTICH, 13, 1, 0), */
 };
 
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit_3db_max, -4350, 150, 0);
+
 static int patch_alc650_specific(struct snd_ac97 * ac97)
 {
 	int err;
@@ -2025,6 +2550,9 @@
 		if ((err = patch_build_controls(ac97, snd_ac97_spdif_controls_alc650, ARRAY_SIZE(snd_ac97_spdif_controls_alc650))) < 0)
 			return err;
 	}
+	if (ac97->id != AC97_ID_ALC650F)
+		reset_tlv(ac97, "Master Playback Volume",
+			  db_scale_5bit_3db_max);
 	return 0;
 }
 
@@ -2095,12 +2623,12 @@
 {
 	int shared;
 	
-	/* shared Line-In */
-	shared = is_shared_linein(ac97);
+	/* shared Line-In / Surround Out */
+	shared = is_shared_surrout(ac97);
 	ac97_update_bits_page(ac97, AC97_ALC650_MULTICH, 1 << 9,
 			      shared ? (1 << 9) : 0, 0);
-	/* update shared mic */
-	shared = is_shared_micin(ac97);
+	/* update shared Mic In / Center/LFE Out */
+	shared = is_shared_clfeout(ac97);
 	/* misc control; vrefout disable */
 	snd_ac97_update_bits(ac97, AC97_ALC650_CLOCK, 1 << 12,
 			     shared ? (1 << 12) : 0);
@@ -2208,7 +2736,10 @@
 		val &= ~(1 << 1); /* Pin 47 is spdif input pin */
 	else { /* ALC655 */
 		if (ac97->subsystem_vendor == 0x1462 &&
-		    ac97->subsystem_device == 0x0131) /* MSI S270 laptop */
+		    (ac97->subsystem_device == 0x0131 || /* MSI S270 laptop */
+		     ac97->subsystem_device == 0x0161 || /* LG K1 Express */
+		     ac97->subsystem_device == 0x0351 || /* MSI L725 laptop */
+		     ac97->subsystem_device == 0x0061))  /* MSI S250 laptop */
 			val &= ~(1 << 1); /* Pin 47 is EAPD (for internal speaker) */
 		else
 			val |= (1 << 1); /* Pin 47 is spdif input pin */
@@ -2241,16 +2772,16 @@
 {
 	int shared;
 	
-	/* shared Line-In */
-	shared = is_shared_linein(ac97);
+	/* shared Line-In / Surround Out */
+	shared = is_shared_surrout(ac97);
 	/* SURR 1kOhm (bit4), Amp (bit5) */
 	snd_ac97_update_bits(ac97, AC97_ALC850_MISC1, (1<<4)|(1<<5),
 			     shared ? (1<<5) : (1<<4));
 	/* LINE-IN = 0, SURROUND = 2 */
 	snd_ac97_update_bits(ac97, AC97_ALC850_JACK_SELECT, 7 << 12,
 			     shared ? (2<<12) : (0<<12));
-	/* update shared mic */
-	shared = is_shared_micin(ac97);
+	/* update shared Mic In / Center/LFE Out */
+	shared = is_shared_clfeout(ac97);
 	/* Vref disable (bit12), 1kOhm (bit13) */
 	snd_ac97_update_bits(ac97, AC97_ALC850_MISC1, (1<<12)|(1<<13),
 			     shared ? (1<<12) : (1<<13));
@@ -2323,9 +2854,9 @@
  */
 static void cm9738_update_jacks(struct snd_ac97 *ac97)
 {
-	/* shared Line-In */
+	/* shared Line-In / Surround Out */
 	snd_ac97_update_bits(ac97, AC97_CM9738_VENDOR_CTRL, 1 << 10,
-			     is_shared_linein(ac97) ? (1 << 10) : 0);
+			     is_shared_surrout(ac97) ? (1 << 10) : 0);
 }
 
 static const struct snd_kcontrol_new snd_ac97_cm9738_controls[] = {
@@ -2407,12 +2938,12 @@
 
 static void cm9739_update_jacks(struct snd_ac97 *ac97)
 {
-	/* shared Line-In */
+	/* shared Line-In / Surround Out */
 	snd_ac97_update_bits(ac97, AC97_CM9739_MULTI_CHAN, 1 << 10,
-			     is_shared_linein(ac97) ? (1 << 10) : 0);
-	/* shared Mic */
+			     is_shared_surrout(ac97) ? (1 << 10) : 0);
+	/* shared Mic In / Center/LFE Out **/
 	snd_ac97_update_bits(ac97, AC97_CM9739_MULTI_CHAN, 0x3000,
-			     is_shared_micin(ac97) ? 0x1000 : 0x2000);
+			     is_shared_clfeout(ac97) ? 0x1000 : 0x2000);
 }
 
 static const struct snd_kcontrol_new snd_ac97_cm9739_controls[] = {
@@ -2524,8 +3055,8 @@
 
 	val |= surr_on[ac97->spec.dev_flags][is_surround_on(ac97)];
 	val |= clfe_on[ac97->spec.dev_flags][is_clfe_on(ac97)];
-	val |= surr_shared[ac97->spec.dev_flags][is_shared_linein(ac97)];
-	val |= clfe_shared[ac97->spec.dev_flags][is_shared_micin(ac97)];
+	val |= surr_shared[ac97->spec.dev_flags][is_shared_surrout(ac97)];
+	val |= clfe_shared[ac97->spec.dev_flags][is_shared_clfeout(ac97)];
 
 	snd_ac97_update_bits(ac97, AC97_CM9761_MULTI_CHAN, 0x3c88, val);
 }
@@ -2759,8 +3290,13 @@
  */
 int patch_vt1617a(struct snd_ac97 * ac97)
 {
+	/* bring analog power consumption to normal, like WinXP driver
+	 * for EPIA SP
+	 */
+	snd_ac97_write_cache(ac97, 0x5c, 0x20);
 	ac97->ext_id |= AC97_EI_SPDIF;	/* force the detection of spdif */
 	ac97->rates[AC97_RATES_SPDIF] = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000;
+	ac97->build_ops = &patch_vt1616_ops;
 	return 0;
 }
 
@@ -2768,12 +3304,12 @@
  */
 static void it2646_update_jacks(struct snd_ac97 *ac97)
 {
-	/* shared Line-In */
+	/* shared Line-In / Surround Out */
 	snd_ac97_update_bits(ac97, 0x76, 1 << 9,
-			     is_shared_linein(ac97) ? (1<<9) : 0);
-	/* shared Mic */
+			     is_shared_surrout(ac97) ? (1<<9) : 0);
+	/* shared Mic / Center/LFE Out */
 	snd_ac97_update_bits(ac97, 0x76, 1 << 10,
-			     is_shared_micin(ac97) ? (1<<10) : 0);
+			     is_shared_clfeout(ac97) ? (1<<10) : 0);
 }
 
 static const struct snd_kcontrol_new snd_ac97_controls_it2646[] = {
@@ -2872,3 +3408,41 @@
 	ac97->res_table = lm4550_restbl;
 	return 0;
 }
+
+/* 
+ *  UCB1400 codec (http://www.semiconductors.philips.com/acrobat_download/datasheets/UCB1400-02.pdf)
+ */
+static const struct snd_kcontrol_new snd_ac97_controls_ucb1400[] = {
+/* enable/disable headphone driver which allows direct connection to
+   stereo headphone without the use of external DC blocking
+   capacitors */
+AC97_SINGLE("Headphone Driver", 0x6a, 6, 1, 0),
+/* Filter used to compensate the DC offset is added in the ADC to remove idle
+   tones from the audio band. */
+AC97_SINGLE("DC Filter", 0x6a, 4, 1, 0),
+/* Control smart-low-power mode feature. Allows automatic power down
+   of unused blocks in the ADC analog front end and the PLL. */
+AC97_SINGLE("Smart Low Power Mode", 0x6c, 4, 3, 0),
+};
+
+static int patch_ucb1400_specific(struct snd_ac97 * ac97)
+{
+	int idx, err;
+	for (idx = 0; idx < ARRAY_SIZE(snd_ac97_controls_ucb1400); idx++)
+		if ((err = snd_ctl_add(ac97->bus->card, snd_ctl_new1(&snd_ac97_controls_ucb1400[idx], ac97))) < 0)
+			return err;
+	return 0;
+}
+
+static struct snd_ac97_build_ops patch_ucb1400_ops = {
+	.build_specific	= patch_ucb1400_specific,
+};
+
+int patch_ucb1400(struct snd_ac97 * ac97)
+{
+	ac97->build_ops = &patch_ucb1400_ops;
+	/* enable headphone driver and smart low power mode by default */
+	snd_ac97_write(ac97, 0x6a, 0x0050);
+	snd_ac97_write(ac97, 0x6c, 0x0030);
+	return 0;
+}
--- linux-2.6.18.noarch/sound/pci/ac97/Makefile.orig	2007-06-05 16:08:01.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/Makefile	2007-06-05 17:45:08.000000000 -0400
@@ -10,11 +10,9 @@
 endif
 
 snd-ak4531-codec-objs := ak4531_codec.o
-snd-ac97-bus-objs := ac97_bus.o
 
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_AC97_CODEC) += snd-ac97-codec.o
 obj-$(CONFIG_SND_ENS1370) += snd-ak4531-codec.o
-obj-$(CONFIG_SND_AC97_BUS) += snd-ac97-bus.o
 
 obj-m := $(sort $(obj-m))
--- linux-2.6.18.noarch/sound/pci/ac97/ac97_patch.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ac97_patch.h	2007-06-05 17:45:08.000000000 -0400
@@ -39,6 +39,7 @@
 int patch_cirrus_cs4299(struct snd_ac97 * ac97);
 int patch_cirrus_spdif(struct snd_ac97 * ac97);
 int patch_conexant(struct snd_ac97 * ac97);
+int patch_cx20551(struct snd_ac97 * ac97);
 int patch_ad1819(struct snd_ac97 * ac97);
 int patch_ad1881(struct snd_ac97 * ac97);
 int patch_ad1885(struct snd_ac97 * ac97);
@@ -48,6 +49,7 @@
 int patch_ad1981a(struct snd_ac97 * ac97);
 int patch_ad1981b(struct snd_ac97 * ac97);
 int patch_ad1985(struct snd_ac97 * ac97);
+int patch_ad1986(struct snd_ac97 * ac97);
 int patch_alc650(struct snd_ac97 * ac97);
 int patch_alc655(struct snd_ac97 * ac97);
 int patch_alc850(struct snd_ac97 * ac97);
@@ -58,5 +60,6 @@
 int patch_vt1616(struct snd_ac97 * ac97);
 int patch_vt1617a(struct snd_ac97 * ac97);
 int patch_it2646(struct snd_ac97 * ac97);
+int patch_ucb1400(struct snd_ac97 * ac97);
 int mpatch_si3036(struct snd_ac97 * ac97);
 int patch_lm4550(struct snd_ac97 * ac97);
--- linux-2.6.18.noarch/sound/pci/ac97/ac97_codec.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ac97_codec.c	2007-06-05 17:45:08.000000000 -0400
@@ -31,6 +31,7 @@
 #include <linux/mutex.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
+#include <sound/tlv.h>
 #include <sound/ac97_codec.h>
 #include <sound/asoundef.h>
 #include <sound/initval.h>
@@ -47,6 +48,11 @@
 module_param(enable_loopback, bool, 0444);
 MODULE_PARM_DESC(enable_loopback, "Enable AC97 ADC/DAC Loopback Control");
 
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+static int power_save;
+module_param(power_save, bool, 0644);
+MODULE_PARM_DESC(power_save, "Enable AC97 power-saving control");
+#endif
 /*
 
  */
@@ -105,7 +111,7 @@
 { 0x41445372, 0xffffffff, "AD1981A",		patch_ad1981a,	NULL },
 { 0x41445374, 0xffffffff, "AD1981B",		patch_ad1981b,	NULL },
 { 0x41445375, 0xffffffff, "AD1985",		patch_ad1985,	NULL },
-{ 0x41445378, 0xffffffff, "AD1986",		patch_ad1985,	NULL },
+{ 0x41445378, 0xffffffff, "AD1986",		patch_ad1986,	NULL },
 { 0x414c4300, 0xffffff00, "ALC100,100P", 	NULL,		NULL },
 { 0x414c4710, 0xfffffff0, "ALC200,200P",	NULL,		NULL },
 { 0x414c4721, 0xffffffff, "ALC650D",		NULL,	NULL }, /* already patched */
@@ -123,9 +129,9 @@
 { 0x434d4941, 0xffffffff, "CMI9738",		patch_cm9738,	NULL },
 { 0x434d4961, 0xffffffff, "CMI9739",		patch_cm9739,	NULL },
 { 0x434d4969, 0xffffffff, "CMI9780",		patch_cm9780,	NULL },
-{ 0x434d4978, 0xffffffff, "CMI9761",		patch_cm9761,	NULL },
-{ 0x434d4982, 0xffffffff, "CMI9761",		patch_cm9761,	NULL },
-{ 0x434d4983, 0xffffffff, "CMI9761",		patch_cm9761,	NULL },
+{ 0x434d4978, 0xffffffff, "CMI9761A",		patch_cm9761,	NULL },
+{ 0x434d4982, 0xffffffff, "CMI9761B",		patch_cm9761,	NULL },
+{ 0x434d4983, 0xffffffff, "CMI9761A+",		patch_cm9761,	NULL },
 { 0x43525900, 0xfffffff8, "CS4297",		NULL,		NULL },
 { 0x43525910, 0xfffffff8, "CS4297A",		patch_cirrus_spdif,	NULL },
 { 0x43525920, 0xfffffff8, "CS4298",		patch_cirrus_spdif,		NULL },
@@ -137,6 +143,7 @@
 { 0x43525970, 0xfffffff8, "CS4202",		NULL,		NULL },
 { 0x43585421, 0xffffffff, "HSD11246",		NULL,		NULL },	// SmartMC II
 { 0x43585428, 0xfffffff8, "Cx20468",		patch_conexant,	NULL }, // SmartAMC fixme: the mask might be different
+{ 0x43585431, 0xffffffff, "Cx20551",           patch_cx20551,  NULL },
 { 0x44543031, 0xfffffff0, "DT0398",		NULL,		NULL },
 { 0x454d4328, 0xffffffff, "EM28028",		NULL,		NULL },  // same as TR28028?
 { 0x45838308, 0xffffffff, "ESS1988",		NULL,		NULL },
@@ -151,7 +158,7 @@
 { 0x4e534300, 0xffffffff, "LM4540,43,45,46,48",	NULL,		NULL }, // only guess --jk
 { 0x4e534331, 0xffffffff, "LM4549",		NULL,		NULL },
 { 0x4e534350, 0xffffffff, "LM4550",		patch_lm4550,  	NULL }, // volume wrap fix 
-{ 0x50534304, 0xffffffff, "UCB1400",		NULL,		NULL },
+{ 0x50534304, 0xffffffff, "UCB1400",		patch_ucb1400,	NULL },
 { 0x53494c20, 0xffffffe0, "Si3036,8",		mpatch_si3036,	mpatch_si3036, AC97_MODEM_PATCH },
 { 0x54524102, 0xffffffff, "TR28022",		NULL,		NULL },
 { 0x54524106, 0xffffffff, "TR28026",		NULL,		NULL },
@@ -187,6 +194,15 @@
 };
 
 
+static void update_power_regs(struct snd_ac97 *ac97);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+#define ac97_is_power_save_mode(ac97) \
+	((ac97->scaps & AC97_SCAP_POWER_SAVE) && power_save)
+#else
+#define ac97_is_power_save_mode(ac97) 0
+#endif
+
+
 /*
  *  I/O routines
  */
@@ -374,7 +390,7 @@
 	unsigned short old, new;
 
 	old = snd_ac97_read_cache(ac97, reg);
-	new = (old & ~mask) | value;
+	new = (old & ~mask) | (value & mask);
 	change = old != new;
 	if (change) {
 		ac97->regs[reg] = new;
@@ -391,7 +407,7 @@
 
 	mutex_lock(&ac97->page_mutex);
 	old = ac97->spec.ad18xx.pcmreg[codec];
-	new = (old & ~mask) | value;
+	new = (old & ~mask) | (value & mask);
 	change = old != new;
 	if (change) {
 		mutex_lock(&ac97->reg_mutex);
@@ -554,6 +570,17 @@
 	}
 	err = snd_ac97_update_bits(ac97, reg, val_mask, val);
 	snd_ac97_page_restore(ac97, page_save);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	/* check analog mixer power-down */
+	if ((val_mask & 0x8000) &&
+	    (kcontrol->private_value & (1<<30))) {
+		if (val & 0x8000)
+			ac97->power_up &= ~(1 << (reg>>1));
+		else
+			ac97->power_up |= 1 << (reg>>1);
+		update_power_regs(ac97);
+	}
+#endif
 	return err;
 }
 
@@ -962,6 +989,10 @@
 static int snd_ac97_free(struct snd_ac97 *ac97)
 {
 	if (ac97) {
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+		cancel_delayed_work(&ac97->power_work);
+		flush_scheduled_work();
+#endif
 		snd_ac97_proc_done(ac97);
 		if (ac97->bus)
 			ac97->bus->codec[ac97->num] = NULL;
@@ -1117,7 +1148,9 @@
 /*
  * create mute switch(es) for normal stereo controls
  */
-static int snd_ac97_cmute_new_stereo(struct snd_card *card, char *name, int reg, int check_stereo, struct snd_ac97 *ac97)
+static int snd_ac97_cmute_new_stereo(struct snd_card *card, char *name, int reg,
+				     int check_stereo, int check_amix,
+				     struct snd_ac97 *ac97)
 {
 	struct snd_kcontrol *kctl;
 	int err;
@@ -1137,10 +1170,14 @@
 	}
 	if (mute_mask == 0x8080) {
 		struct snd_kcontrol_new tmp = AC97_DOUBLE(name, reg, 15, 7, 1, 1);
+		if (check_amix)
+			tmp.private_value |= (1 << 30);
 		tmp.index = ac97->num;
 		kctl = snd_ctl_new1(&tmp, ac97);
 	} else {
 		struct snd_kcontrol_new tmp = AC97_SINGLE(name, reg, 15, 1, 1);
+		if (check_amix)
+			tmp.private_value |= (1 << 30);
 		tmp.index = ac97->num;
 		kctl = snd_ctl_new1(&tmp, ac97);
 	}
@@ -1153,6 +1190,32 @@
 }
 
 /*
+ * set dB information
+ */
+static const DECLARE_TLV_DB_SCALE(db_scale_4bit, -4500, 300, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit_12db_max, -3450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_rec_gain, 0, 150, 0);
+
+static const unsigned int *find_db_scale(unsigned int maxval)
+{
+	switch (maxval) {
+	case 0x0f: return db_scale_4bit;
+	case 0x1f: return db_scale_5bit;
+	case 0x3f: return db_scale_6bit;
+	}
+	return NULL;
+}
+
+static void set_tlv_db_scale(struct snd_kcontrol *kctl, const unsigned int *tlv)
+{
+	kctl->tlv.p = tlv;
+	if (tlv)
+		kctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;
+}
+
+/*
  * create a volume for normal stereo/mono controls
  */
 static int snd_ac97_cvol_new(struct snd_card *card, char *name, int reg, unsigned int lo_max,
@@ -1174,6 +1237,10 @@
 		tmp.index = ac97->num;
 		kctl = snd_ctl_new1(&tmp, ac97);
 	}
+	if (reg >= AC97_PHONE && reg <= AC97_PCM)
+		set_tlv_db_scale(kctl, db_scale_5bit_12db_max);
+	else
+		set_tlv_db_scale(kctl, find_db_scale(lo_max));
 	err = snd_ctl_add(card, kctl);
 	if (err < 0)
 		return err;
@@ -1186,7 +1253,9 @@
 /*
  * create a mute-switch and a volume for normal stereo/mono controls
  */
-static int snd_ac97_cmix_new_stereo(struct snd_card *card, const char *pfx, int reg, int check_stereo, struct snd_ac97 *ac97)
+static int snd_ac97_cmix_new_stereo(struct snd_card *card, const char *pfx,
+				    int reg, int check_stereo, int check_amix,
+				    struct snd_ac97 *ac97)
 {
 	int err;
 	char name[44];
@@ -1197,7 +1266,9 @@
 
 	if (snd_ac97_try_bit(ac97, reg, 15)) {
 		sprintf(name, "%s Switch", pfx);
-		if ((err = snd_ac97_cmute_new_stereo(card, name, reg, check_stereo, ac97)) < 0)
+		if ((err = snd_ac97_cmute_new_stereo(card, name, reg,
+						     check_stereo, check_amix,
+						     ac97)) < 0)
 			return err;
 	}
 	check_volume_resolution(ac97, reg, &lo_max, &hi_max);
@@ -1209,8 +1280,10 @@
 	return 0;
 }
 
-#define snd_ac97_cmix_new(card, pfx, reg, ac97)	snd_ac97_cmix_new_stereo(card, pfx, reg, 0, ac97)
-#define snd_ac97_cmute_new(card, name, reg, ac97)	snd_ac97_cmute_new_stereo(card, name, reg, 0, ac97)
+#define snd_ac97_cmix_new(card, pfx, reg, acheck, ac97) \
+	snd_ac97_cmix_new_stereo(card, pfx, reg, 0, acheck, ac97)
+#define snd_ac97_cmute_new(card, name, reg, acheck, ac97) \
+	snd_ac97_cmute_new_stereo(card, name, reg, 0, acheck, ac97)
 
 static unsigned int snd_ac97_determine_spdif_rates(struct snd_ac97 *ac97);
 
@@ -1226,9 +1299,11 @@
 	/* AD claims to remove this control from AD1887, although spec v2.2 does not allow this */
 	if (snd_ac97_try_volume_mix(ac97, AC97_MASTER)) {
 		if (ac97->flags & AC97_HAS_NO_MASTER_VOL)
-			err = snd_ac97_cmute_new(card, "Master Playback Switch", AC97_MASTER, ac97);
+			err = snd_ac97_cmute_new(card, "Master Playback Switch",
+						 AC97_MASTER, 0, ac97);
 		else
-			err = snd_ac97_cmix_new(card, "Master Playback", AC97_MASTER, ac97);
+			err = snd_ac97_cmix_new(card, "Master Playback",
+						AC97_MASTER, 0, ac97);
 		if (err < 0)
 			return err;
 	}
@@ -1245,6 +1320,7 @@
 		snd_ac97_change_volume_params2(ac97, AC97_CENTER_LFE_MASTER, 0, &max);
 		kctl->private_value &= ~(0xff << 16);
 		kctl->private_value |= (int)max << 16;
+		set_tlv_db_scale(kctl, find_db_scale(max));
 		snd_ac97_write_cache(ac97, AC97_CENTER_LFE_MASTER, ac97->regs[AC97_CENTER_LFE_MASTER] | max);
 	}
 
@@ -1258,6 +1334,7 @@
 		snd_ac97_change_volume_params2(ac97, AC97_CENTER_LFE_MASTER, 8, &max);
 		kctl->private_value &= ~(0xff << 16);
 		kctl->private_value |= (int)max << 16;
+		set_tlv_db_scale(kctl, find_db_scale(max));
 		snd_ac97_write_cache(ac97, AC97_CENTER_LFE_MASTER, ac97->regs[AC97_CENTER_LFE_MASTER] | max << 8);
 	}
 
@@ -1265,19 +1342,23 @@
 	if ((snd_ac97_try_volume_mix(ac97, AC97_SURROUND_MASTER)) 
 		&& !(ac97->flags & AC97_AD_MULTI)) {
 		/* Surround Master (0x38) is with stereo mutes */
-		if ((err = snd_ac97_cmix_new_stereo(card, "Surround Playback", AC97_SURROUND_MASTER, 1, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new_stereo(card, "Surround Playback",
+						    AC97_SURROUND_MASTER, 1, 0,
+						    ac97)) < 0)
 			return err;
 	}
 
 	/* build headphone controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_HEADPHONE)) {
-		if ((err = snd_ac97_cmix_new(card, "Headphone Playback", AC97_HEADPHONE, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Headphone Playback",
+					     AC97_HEADPHONE, 0, ac97)) < 0)
 			return err;
 	}
 	
 	/* build master mono controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_MASTER_MONO)) {
-		if ((err = snd_ac97_cmix_new(card, "Master Mono Playback", AC97_MASTER_MONO, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Master Mono Playback",
+					     AC97_MASTER_MONO, 0, ac97)) < 0)
 			return err;
 	}
 	
@@ -1301,8 +1382,9 @@
 		((ac97->flags & AC97_HAS_PC_BEEP) ||
 	    snd_ac97_try_volume_mix(ac97, AC97_PC_BEEP))) {
 		for (idx = 0; idx < 2; idx++)
-			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_pc_beep[idx], ac97))) < 0)
+			if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_pc_beep[idx], ac97))) < 0)
 				return err;
+		set_tlv_db_scale(kctl, db_scale_4bit);
 		snd_ac97_write_cache(ac97, AC97_PC_BEEP,
 				     snd_ac97_read(ac97, AC97_PC_BEEP) | 0x801e);
 	}
@@ -1310,7 +1392,8 @@
 	/* build Phone controls */
 	if (!(ac97->flags & AC97_HAS_NO_PHONE)) {
 		if (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {
-			if ((err = snd_ac97_cmix_new(card, "Phone Playback", AC97_PHONE, ac97)) < 0)
+			if ((err = snd_ac97_cmix_new(card, "Phone Playback",
+						     AC97_PHONE, 1, ac97)) < 0)
 				return err;
 		}
 	}
@@ -1318,7 +1401,8 @@
 	/* build MIC controls */
 	if (!(ac97->flags & AC97_HAS_NO_MIC)) {
 		if (snd_ac97_try_volume_mix(ac97, AC97_MIC)) {
-			if ((err = snd_ac97_cmix_new(card, "Mic Playback", AC97_MIC, ac97)) < 0)
+			if ((err = snd_ac97_cmix_new(card, "Mic Playback",
+						     AC97_MIC, 1, ac97)) < 0)
 				return err;
 			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic_boost, ac97))) < 0)
 				return err;
@@ -1327,14 +1411,16 @@
 
 	/* build Line controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_LINE)) {
-		if ((err = snd_ac97_cmix_new(card, "Line Playback", AC97_LINE, ac97)) < 0)
+		if ((err = snd_ac97_cmix_new(card, "Line Playback",
+					     AC97_LINE, 1, ac97)) < 0)
 			return err;
 	}
 	
 	/* build CD controls */
 	if (!(ac97->flags & AC97_HAS_NO_CD)) {
 		if (snd_ac97_try_volume_mix(ac97, AC97_CD)) {
-			if ((err = snd_ac97_cmix_new(card, "CD Playback", AC97_CD, ac97)) < 0)
+			if ((err = snd_ac97_cmix_new(card, "CD Playback",
+						     AC97_CD, 1, ac97)) < 0)
 				return err;
 		}
 	}
@@ -1342,7 +1428,8 @@
 	/* build Video controls */
 	if (!(ac97->flags & AC97_HAS_NO_VIDEO)) {
 		if (snd_ac97_try_volume_mix(ac97, AC97_VIDEO)) {
-			if ((err = snd_ac97_cmix_new(card, "Video Playback", AC97_VIDEO, ac97)) < 0)
+			if ((err = snd_ac97_cmix_new(card, "Video Playback",
+						     AC97_VIDEO, 1, ac97)) < 0)
 				return err;
 		}
 	}
@@ -1350,7 +1437,8 @@
 	/* build Aux controls */
 	if (!(ac97->flags & AC97_HAS_NO_AUX)) {
 		if (snd_ac97_try_volume_mix(ac97, AC97_AUX)) {
-			if ((err = snd_ac97_cmix_new(card, "Aux Playback", AC97_AUX, ac97)) < 0)
+			if ((err = snd_ac97_cmix_new(card, "Aux Playback",
+						     AC97_AUX, 1, ac97)) < 0)
 				return err;
 		}
 	}
@@ -1363,31 +1451,38 @@
 		else
 			init_val = 0x9f1f;
 		for (idx = 0; idx < 2; idx++)
-			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_ad18xx_pcm[idx], ac97))) < 0)
+			if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_pcm[idx], ac97))) < 0)
 				return err;
+		set_tlv_db_scale(kctl, db_scale_5bit);
 		ac97->spec.ad18xx.pcmreg[0] = init_val;
 		if (ac97->scaps & AC97_SCAP_SURROUND_DAC) {
 			for (idx = 0; idx < 2; idx++)
-				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_ad18xx_surround[idx], ac97))) < 0)
+				if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_surround[idx], ac97))) < 0)
 					return err;
+			set_tlv_db_scale(kctl, db_scale_5bit);
 			ac97->spec.ad18xx.pcmreg[1] = init_val;
 		}
 		if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC) {
 			for (idx = 0; idx < 2; idx++)
-				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_ad18xx_center[idx], ac97))) < 0)
+				if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_center[idx], ac97))) < 0)
 					return err;
+			set_tlv_db_scale(kctl, db_scale_5bit);
 			for (idx = 0; idx < 2; idx++)
-				if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_ad18xx_lfe[idx], ac97))) < 0)
+				if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_lfe[idx], ac97))) < 0)
 					return err;
+			set_tlv_db_scale(kctl, db_scale_5bit);
 			ac97->spec.ad18xx.pcmreg[2] = init_val;
 		}
 		snd_ac97_write_cache(ac97, AC97_PCM, init_val);
 	} else {
 		if (!(ac97->flags & AC97_HAS_NO_STD_PCM)) {
 			if (ac97->flags & AC97_HAS_NO_PCM_VOL)
-				err = snd_ac97_cmute_new(card, "PCM Playback Switch", AC97_PCM, ac97);
+				err = snd_ac97_cmute_new(card,
+							 "PCM Playback Switch",
+							 AC97_PCM, 0, ac97);
 			else
-				err = snd_ac97_cmix_new(card, "PCM Playback", AC97_PCM, ac97);
+				err = snd_ac97_cmix_new(card, "PCM Playback",
+							AC97_PCM, 0, ac97);
 			if (err < 0)
 				return err;
 		}
@@ -1398,19 +1493,23 @@
 		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_src, ac97))) < 0)
 			return err;
 		if (snd_ac97_try_bit(ac97, AC97_REC_GAIN, 15)) {
-			if ((err = snd_ac97_cmute_new(card, "Capture Switch", AC97_REC_GAIN, ac97)) < 0)
+			err = snd_ac97_cmute_new(card, "Capture Switch",
+						 AC97_REC_GAIN, 0, ac97);
+			if (err < 0)
 				return err;
 		}
-		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_vol, ac97))) < 0)
+		if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_control_capture_vol, ac97))) < 0)
 			return err;
+		set_tlv_db_scale(kctl, db_scale_rec_gain);
 		snd_ac97_write_cache(ac97, AC97_REC_SEL, 0x0000);
 		snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x0000);
 	}
 	/* build MIC Capture controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_REC_GAIN_MIC)) {
 		for (idx = 0; idx < 2; idx++)
-			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic_capture[idx], ac97))) < 0)
+			if ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_mic_capture[idx], ac97))) < 0)
 				return err;
+		set_tlv_db_scale(kctl, db_scale_rec_gain);
 		snd_ac97_write_cache(ac97, AC97_REC_GAIN_MIC, 0x0000);
 	}
 
@@ -1481,6 +1580,12 @@
 	}
 
 	/* build S/PDIF controls */
+
+	/* Hack for ASUS P5P800-VM, which does not indicate S/PDIF capability */
+	if (ac97->subsystem_vendor == 0x1043 &&
+	    ac97->subsystem_device == 0x810f)
+		ac97->ext_id |= AC97_EI_SPDIF;
+
 	if ((ac97->ext_id & AC97_EI_SPDIF) && !(ac97->scaps & AC97_SCAP_NO_SPDIF)) {
 		if (ac97->build_ops->build_spdif) {
 			if ((err = ac97->build_ops->build_spdif(ac97)) < 0)
@@ -1817,18 +1922,26 @@
 	return 0;
 }
 
-/* unregister ac97 codec */
-static int snd_ac97_dev_unregister(struct snd_device *device)
+/* disconnect ac97 codec */
+static int snd_ac97_dev_disconnect(struct snd_device *device)
 {
 	struct snd_ac97 *ac97 = device->device_data;
 	if (ac97->dev.bus)
 		device_unregister(&ac97->dev);
-	return snd_ac97_free(ac97);
+	return 0;
 }
 
 /* build_ops to do nothing */
 static struct snd_ac97_build_ops null_build_ops;
 
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+static void do_update_power(struct work_struct *work)
+{
+	update_power_regs(
+		container_of(work, struct snd_ac97, power_work.work));
+}
+#endif
+
 /**
  * snd_ac97_mixer - create an Codec97 component
  * @bus: the AC97 bus which codec is attached to
@@ -1860,7 +1973,7 @@
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_ac97_dev_free,
 		.dev_register =	snd_ac97_dev_register,
-		.dev_unregister =	snd_ac97_dev_unregister,
+		.dev_disconnect =	snd_ac97_dev_disconnect,
 	};
 
 	snd_assert(rac97 != NULL, return -EINVAL);
@@ -1883,6 +1996,9 @@
 	bus->codec[ac97->num] = ac97;
 	mutex_init(&ac97->reg_mutex);
 	mutex_init(&ac97->page_mutex);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	INIT_DELAYED_WORK(&ac97->power_work, do_update_power);
+#endif
 
 #ifdef CONFIG_PCI
 	if (ac97->pci) {
@@ -2117,15 +2233,8 @@
 			return -ENOMEM;
 		}
 	}
-	/* make sure the proper powerdown bits are cleared */
-	if (ac97->scaps && ac97_is_audio(ac97)) {
-		reg = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);
-		if (ac97->scaps & AC97_SCAP_SURROUND_DAC) 
-			reg &= ~AC97_EA_PRJ;
-		if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC) 
-			reg &= ~(AC97_EA_PRI | AC97_EA_PRK);
-		snd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, reg);
-	}
+	if (ac97_is_audio(ac97))
+		update_power_regs(ac97);
 	snd_ac97_proc_init(ac97);
 	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, ac97, &ops)) < 0) {
 		snd_ac97_free(ac97);
@@ -2153,19 +2262,145 @@
 		snd_ac97_write(ac97, AC97_HEADPHONE, 0x9f9f);
 	}
 
-	power = ac97->regs[AC97_POWERDOWN] | 0x8000;	/* EAPD */
-	power |= 0x4000;	/* Headphone amplifier powerdown */
-	power |= 0x0300;	/* ADC & DAC powerdown */
+	/* surround, CLFE, mic powerdown */
+	power = ac97->regs[AC97_EXTENDED_STATUS];
+	if (ac97->scaps & AC97_SCAP_SURROUND_DAC)
+		power |= AC97_EA_PRJ;
+	if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)
+		power |= AC97_EA_PRI | AC97_EA_PRK;
+	power |= AC97_EA_PRL;
+	snd_ac97_write(ac97, AC97_EXTENDED_STATUS, power);
+
+	/* powerdown external amplifier */
+	if (ac97->scaps & AC97_SCAP_INV_EAPD)
+		power = ac97->regs[AC97_POWERDOWN] & ~AC97_PD_EAPD;
+	else if (! (ac97->scaps & AC97_SCAP_EAPD_LED))
+		power = ac97->regs[AC97_POWERDOWN] | AC97_PD_EAPD;
+	power |= AC97_PD_PR6;	/* Headphone amplifier powerdown */
+	power |= AC97_PD_PR0 | AC97_PD_PR1;	/* ADC & DAC powerdown */
 	snd_ac97_write(ac97, AC97_POWERDOWN, power);
 	udelay(100);
-	power |= 0x0400;	/* Analog Mixer powerdown (Vref on) */
-	snd_ac97_write(ac97, AC97_POWERDOWN, power);
-	udelay(100);
-#if 0
-	/* FIXME: this causes click noises on some boards at resume */
-	power |= 0x3800;	/* AC-link powerdown, internal Clk disable */
+	power |= AC97_PD_PR2 | AC97_PD_PR3;	/* Analog Mixer powerdown */
 	snd_ac97_write(ac97, AC97_POWERDOWN, power);
+	if (ac97_is_power_save_mode(ac97)) {
+		udelay(100);
+		/* AC-link powerdown, internal Clk disable */
+		/* FIXME: this may cause click noises on some boards */
+		power |= AC97_PD_PR4 | AC97_PD_PR5;
+		snd_ac97_write(ac97, AC97_POWERDOWN, power);
+	}
+}
+
+
+struct ac97_power_reg {
+	unsigned short reg;
+	unsigned short power_reg;
+	unsigned short mask;
+};
+
+enum { PWIDX_ADC, PWIDX_FRONT, PWIDX_CLFE, PWIDX_SURR, PWIDX_MIC, PWIDX_SIZE };
+
+static struct ac97_power_reg power_regs[PWIDX_SIZE] = {
+	[PWIDX_ADC] = { AC97_PCM_LR_ADC_RATE, AC97_POWERDOWN, AC97_PD_PR0},
+	[PWIDX_FRONT] = { AC97_PCM_FRONT_DAC_RATE, AC97_POWERDOWN, AC97_PD_PR1},
+	[PWIDX_CLFE] = { AC97_PCM_LFE_DAC_RATE, AC97_EXTENDED_STATUS,
+			 AC97_EA_PRI | AC97_EA_PRK},
+	[PWIDX_SURR] = { AC97_PCM_SURR_DAC_RATE, AC97_EXTENDED_STATUS,
+			 AC97_EA_PRJ},
+	[PWIDX_MIC] = { AC97_PCM_MIC_ADC_RATE, AC97_EXTENDED_STATUS,
+			AC97_EA_PRL},
+};
+
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+/**
+ * snd_ac97_update_power - update the powerdown register
+ * @ac97: the codec instance
+ * @reg: the rate register, e.g. AC97_PCM_FRONT_DAC_RATE
+ * @powerup: non-zero when power up the part
+ *
+ * Update the AC97 powerdown register bits of the given part.
+ */
+int snd_ac97_update_power(struct snd_ac97 *ac97, int reg, int powerup)
+{
+	int i;
+
+	if (! ac97)
+		return 0;
+
+	if (reg) {
+		/* SPDIF requires DAC power, too */
+		if (reg == AC97_SPDIF)
+			reg = AC97_PCM_FRONT_DAC_RATE;
+		for (i = 0; i < PWIDX_SIZE; i++) {
+			if (power_regs[i].reg == reg) {
+				if (powerup)
+					ac97->power_up |= (1 << i);
+				else
+					ac97->power_up &= ~(1 << i);
+				break;
+			}
+		}
+	}
+
+	if (ac97_is_power_save_mode(ac97) && !powerup)
+		/* adjust power-down bits after two seconds delay
+		 * (for avoiding loud click noises for many (OSS) apps
+		 *  that open/close frequently)
+		 */
+		schedule_delayed_work(&ac97->power_work, HZ*2);
+	else {
+		cancel_delayed_work(&ac97->power_work);
+		update_power_regs(ac97);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_ac97_update_power);
+#endif /* CONFIG_SND_AC97_POWER_SAVE */
+
+static void update_power_regs(struct snd_ac97 *ac97)
+{
+	unsigned int power_up, bits;
+	int i;
+
+	power_up = (1 << PWIDX_FRONT) | (1 << PWIDX_ADC);
+	power_up |= (1 << PWIDX_MIC);
+	if (ac97->scaps & AC97_SCAP_SURROUND_DAC)
+		power_up |= (1 << PWIDX_SURR);
+	if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)
+		power_up |= (1 << PWIDX_CLFE);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	if (ac97_is_power_save_mode(ac97))
+		power_up = ac97->power_up;
 #endif
+	if (power_up) {
+		if (ac97->regs[AC97_POWERDOWN] & AC97_PD_PR2) {
+			/* needs power-up analog mix and vref */
+			snd_ac97_update_bits(ac97, AC97_POWERDOWN,
+					     AC97_PD_PR3, 0);
+			msleep(1);
+			snd_ac97_update_bits(ac97, AC97_POWERDOWN,
+					     AC97_PD_PR2, 0);
+		}
+	}
+	for (i = 0; i < PWIDX_SIZE; i++) {
+		if (power_up & (1 << i))
+			bits = 0;
+		else
+			bits = power_regs[i].mask;
+		snd_ac97_update_bits(ac97, power_regs[i].power_reg,
+				     power_regs[i].mask, bits);
+	}
+	if (! power_up) {
+		if (! (ac97->regs[AC97_POWERDOWN] & AC97_PD_PR2)) {
+			/* power down analog mix and vref */
+			snd_ac97_update_bits(ac97, AC97_POWERDOWN,
+					     AC97_PD_PR2, AC97_PD_PR2);
+			snd_ac97_update_bits(ac97, AC97_POWERDOWN,
+					     AC97_PD_PR3, AC97_PD_PR3);
+		}
+	}
 }
 
 
@@ -2182,6 +2417,10 @@
 		return;
 	if (ac97->build_ops->suspend)
 		ac97->build_ops->suspend(ac97);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	cancel_delayed_work(&ac97->power_work);
+	flush_scheduled_work();
+#endif
 	snd_ac97_powerdown(ac97);
 }
 
@@ -2484,6 +2723,7 @@
 	msw->put = master_mute_sw_put;
 	snd_ac97_remove_ctl(ac97, "External Amplifier", NULL);
 	snd_ac97_update_bits(ac97, AC97_POWERDOWN, 0x8000, 0x8000); /* mute LED on */
+	ac97->scaps |= AC97_SCAP_EAPD_LED;
 	return 0;
 }
 
--- linux-2.6.18.noarch/sound/pci/ac97/ac97_pcm.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ac97_pcm.c	2007-06-05 17:45:08.000000000 -0400
@@ -269,6 +269,7 @@
 			return -EINVAL;
 	}
 
+	snd_ac97_update_power(ac97, reg, 1);
 	switch (reg) {
 	case AC97_PCM_MIC_ADC_RATE:
 		if ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRM) == 0)	/* MIC VRA */
@@ -606,6 +607,7 @@
 			goto error;
 		}
 	}
+	pcm->cur_dbl = r;
 	spin_unlock_irq(&pcm->bus->bus_lock);
 	for (i = 3; i < 12; i++) {
 		if (!(slots & (1 << i)))
@@ -651,6 +653,21 @@
 	unsigned short slots = pcm->aslots;
 	int i, cidx;
 
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	int r = pcm->cur_dbl;
+	for (i = 3; i < 12; i++) {
+		if (!(slots & (1 << i)))
+			continue;
+		for (cidx = 0; cidx < 4; cidx++) {
+			if (pcm->r[r].rslots[cidx] & (1 << i)) {
+				int reg = get_slot_reg(pcm, cidx, i, r);
+				snd_ac97_update_power(pcm->r[r].codec[cidx],
+						      reg, 0);
+			}
+		}
+	}
+#endif
+
 	bus = pcm->bus;
 	spin_lock_irq(&pcm->bus->bus_lock);
 	for (i = 3; i < 12; i++) {
@@ -660,6 +677,7 @@
 			bus->used_slots[pcm->stream][cidx] &= ~(1 << i);
 	}
 	pcm->aslots = 0;
+	pcm->cur_dbl = 0;
 	spin_unlock_irq(&pcm->bus->bus_lock);
 	return 0;
 }
--- linux-2.6.18.noarch/sound/pci/ac97/ak4531_codec.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ak4531_codec.c	2007-06-05 17:45:08.000000000 -0400
@@ -27,6 +27,7 @@
 
 #include <sound/core.h>
 #include <sound/ak4531_codec.h>
+#include <sound/tlv.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Universal routines for AK4531 codec");
@@ -63,6 +64,14 @@
   .info = snd_ak4531_info_single, \
   .get = snd_ak4531_get_single, .put = snd_ak4531_put_single, \
   .private_value = reg | (shift << 16) | (mask << 24) | (invert << 22) }
+#define AK4531_SINGLE_TLV(xname, xindex, reg, shift, mask, invert, xtlv)    \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .index = xindex, \
+  .info = snd_ak4531_info_single, \
+  .get = snd_ak4531_get_single, .put = snd_ak4531_put_single, \
+  .private_value = reg | (shift << 16) | (mask << 24) | (invert << 22), \
+  .tlv = { .p = (xtlv) } }
 
 static int snd_ak4531_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -122,6 +131,14 @@
   .info = snd_ak4531_info_double, \
   .get = snd_ak4531_get_double, .put = snd_ak4531_put_double, \
   .private_value = left_reg | (right_reg << 8) | (left_shift << 16) | (right_shift << 19) | (mask << 24) | (invert << 22) }
+#define AK4531_DOUBLE_TLV(xname, xindex, left_reg, right_reg, left_shift, right_shift, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .index = xindex, \
+  .info = snd_ak4531_info_double, \
+  .get = snd_ak4531_get_double, .put = snd_ak4531_put_double, \
+  .private_value = left_reg | (right_reg << 8) | (left_shift << 16) | (right_shift << 19) | (mask << 24) | (invert << 22), \
+  .tlv = { .p = (xtlv) } }
 
 static int snd_ak4531_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -250,50 +267,62 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_master, -6200, 200, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_mono, -2800, 400, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_input, -5000, 200, 0);
+
 static struct snd_kcontrol_new snd_ak4531_controls[] = {
 
-AK4531_DOUBLE("Master Playback Switch", 0, AK4531_LMASTER, AK4531_RMASTER, 7, 7, 1, 1),
+AK4531_DOUBLE_TLV("Master Playback Switch", 0,
+		  AK4531_LMASTER, AK4531_RMASTER, 7, 7, 1, 1,
+		  db_scale_master),
 AK4531_DOUBLE("Master Playback Volume", 0, AK4531_LMASTER, AK4531_RMASTER, 0, 0, 0x1f, 1),
 
-AK4531_SINGLE("Master Mono Playback Switch", 0, AK4531_MONO_OUT, 7, 1, 1),
+AK4531_SINGLE_TLV("Master Mono Playback Switch", 0, AK4531_MONO_OUT, 7, 1, 1,
+		  db_scale_mono),
 AK4531_SINGLE("Master Mono Playback Volume", 0, AK4531_MONO_OUT, 0, 0x07, 1),
 
 AK4531_DOUBLE("PCM Switch", 0, AK4531_LVOICE, AK4531_RVOICE, 7, 7, 1, 1),
-AK4531_DOUBLE("PCM Volume", 0, AK4531_LVOICE, AK4531_RVOICE, 0, 0, 0x1f, 1),
+AK4531_DOUBLE_TLV("PCM Volume", 0, AK4531_LVOICE, AK4531_RVOICE, 0, 0, 0x1f, 1,
+		  db_scale_input),
 AK4531_DOUBLE("PCM Playback Switch", 0, AK4531_OUT_SW2, AK4531_OUT_SW2, 3, 2, 1, 0),
 AK4531_DOUBLE("PCM Capture Switch", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 2, 2, 1, 0),
 
 AK4531_DOUBLE("PCM Switch", 1, AK4531_LFM, AK4531_RFM, 7, 7, 1, 1),
-AK4531_DOUBLE("PCM Volume", 1, AK4531_LFM, AK4531_RFM, 0, 0, 0x1f, 1),
+AK4531_DOUBLE_TLV("PCM Volume", 1, AK4531_LFM, AK4531_RFM, 0, 0, 0x1f, 1,
+		  db_scale_input),
 AK4531_DOUBLE("PCM Playback Switch", 1, AK4531_OUT_SW1, AK4531_OUT_SW1, 6, 5, 1, 0),
 AK4531_INPUT_SW("PCM Capture Route", 1, AK4531_LIN_SW1, AK4531_RIN_SW1, 6, 5),
 
 AK4531_DOUBLE("CD Switch", 0, AK4531_LCD, AK4531_RCD, 7, 7, 1, 1),
-AK4531_DOUBLE("CD Volume", 0, AK4531_LCD, AK4531_RCD, 0, 0, 0x1f, 1),
+AK4531_DOUBLE_TLV("CD Volume", 0, AK4531_LCD, AK4531_RCD, 0, 0, 0x1f, 1,
+		  db_scale_input),
 AK4531_DOUBLE("CD Playback Switch", 0, AK4531_OUT_SW1, AK4531_OUT_SW1, 2, 1, 1, 0),
 AK4531_INPUT_SW("CD Capture Route", 0, AK4531_LIN_SW1, AK4531_RIN_SW1, 2, 1),
 
 AK4531_DOUBLE("Line Switch", 0, AK4531_LLINE, AK4531_RLINE, 7, 7, 1, 1),
-AK4531_DOUBLE("Line Volume", 0, AK4531_LLINE, AK4531_RLINE, 0, 0, 0x1f, 1),
+AK4531_DOUBLE_TLV("Line Volume", 0, AK4531_LLINE, AK4531_RLINE, 0, 0, 0x1f, 1,
+		  db_scale_input),
 AK4531_DOUBLE("Line Playback Switch", 0, AK4531_OUT_SW1, AK4531_OUT_SW1, 4, 3, 1, 0),
 AK4531_INPUT_SW("Line Capture Route", 0, AK4531_LIN_SW1, AK4531_RIN_SW1, 4, 3),
 
 AK4531_DOUBLE("Aux Switch", 0, AK4531_LAUXA, AK4531_RAUXA, 7, 7, 1, 1),
-AK4531_DOUBLE("Aux Volume", 0, AK4531_LAUXA, AK4531_RAUXA, 0, 0, 0x1f, 1),
+AK4531_DOUBLE_TLV("Aux Volume", 0, AK4531_LAUXA, AK4531_RAUXA, 0, 0, 0x1f, 1,
+		  db_scale_input),
 AK4531_DOUBLE("Aux Playback Switch", 0, AK4531_OUT_SW2, AK4531_OUT_SW2, 5, 4, 1, 0),
 AK4531_INPUT_SW("Aux Capture Route", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 4, 3),
 
 AK4531_SINGLE("Mono Switch", 0, AK4531_MONO1, 7, 1, 1),
-AK4531_SINGLE("Mono Volume", 0, AK4531_MONO1, 0, 0x1f, 1),
+AK4531_SINGLE_TLV("Mono Volume", 0, AK4531_MONO1, 0, 0x1f, 1, db_scale_input),
 AK4531_SINGLE("Mono Playback Switch", 0, AK4531_OUT_SW2, 0, 1, 0),
 AK4531_DOUBLE("Mono Capture Switch", 0, AK4531_LIN_SW2, AK4531_RIN_SW2, 0, 0, 1, 0),
 
 AK4531_SINGLE("Mono Switch", 1, AK4531_MONO2, 7, 1, 1),
-AK4531_SINGLE("Mono Volume", 1, AK4531_MONO2, 0, 0x1f, 1),
+AK4531_SINGLE_TLV("Mono Volume", 1, AK4531_MONO2, 0, 0x1f, 1, db_scale_input),
 AK4531_SINGLE("Mono Playback Switch", 1, AK4531_OUT_SW2, 1, 1, 0),
 AK4531_DOUBLE("Mono Capture Switch", 1, AK4531_LIN_SW2, AK4531_RIN_SW2, 1, 1, 1, 0),
 
-AK4531_SINGLE("Mic Volume", 0, AK4531_MIC, 0, 0x1f, 1),
+AK4531_SINGLE_TLV("Mic Volume", 0, AK4531_MIC, 0, 0x1f, 1, db_scale_input),
 AK4531_SINGLE("Mic Switch", 0, AK4531_MIC, 7, 1, 1),
 AK4531_SINGLE("Mic Playback Switch", 0, AK4531_OUT_SW1, 0, 1, 0),
 AK4531_DOUBLE("Mic Capture Switch", 0, AK4531_LIN_SW1, AK4531_RIN_SW1, 0, 0, 1, 0),
--- linux-2.6.18.noarch/sound/pci/ac97/ac97_proc.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ac97_proc.c	2007-06-05 17:45:08.000000000 -0400
@@ -457,14 +457,10 @@
 
 void snd_ac97_proc_done(struct snd_ac97 * ac97)
 {
-	if (ac97->proc_regs) {
-		snd_info_unregister(ac97->proc_regs);
-		ac97->proc_regs = NULL;
-	}
-	if (ac97->proc) {
-		snd_info_unregister(ac97->proc);
-		ac97->proc = NULL;
-	}
+	snd_info_free_entry(ac97->proc_regs);
+	ac97->proc_regs = NULL;
+	snd_info_free_entry(ac97->proc);
+	ac97->proc = NULL;
 }
 
 void snd_ac97_bus_proc_init(struct snd_ac97_bus * bus)
@@ -485,8 +481,6 @@
 
 void snd_ac97_bus_proc_done(struct snd_ac97_bus * bus)
 {
-	if (bus->proc) {
-		snd_info_unregister(bus->proc);
-		bus->proc = NULL;
-	}
+	snd_info_free_entry(bus->proc);
+	bus->proc = NULL;
 }
--- linux-2.6.18.noarch/sound/pci/ac97/ac97_bus.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ac97/ac97_bus.c	2007-06-05 17:45:08.000000000 -0400
@@ -1,72 +0,0 @@
-/*
- * Linux driver model AC97 bus interface
- *
- * Author:	Nicolas Pitre
- * Created:	Jan 14, 2005
- * Copyright:	(C) MontaVista Software Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/string.h>
-
-/*
- * Let drivers decide whether they want to support given codec from their
- * probe method.  Drivers have direct access to the struct snd_ac97 structure and may
- * decide based on the id field amongst other things.
- */
-static int ac97_bus_match(struct device *dev, struct device_driver *drv)
-{
-	return 1;
-}
-
-static int ac97_bus_suspend(struct device *dev, pm_message_t state)
-{
-	int ret = 0;
-
-	if (dev->driver && dev->driver->suspend)
-		ret = dev->driver->suspend(dev, state);
-
-	return ret;
-}
-
-static int ac97_bus_resume(struct device *dev)
-{
-	int ret = 0;
-
-	if (dev->driver && dev->driver->resume)
-		ret = dev->driver->resume(dev);
-
-	return ret;
-}
-
-struct bus_type ac97_bus_type = {
-	.name		= "ac97",
-	.match		= ac97_bus_match,
-	.suspend	= ac97_bus_suspend,
-	.resume		= ac97_bus_resume,
-};
-
-static int __init ac97_bus_init(void)
-{
-	return bus_register(&ac97_bus_type);
-}
-
-subsys_initcall(ac97_bus_init);
-
-static void __exit ac97_bus_exit(void)
-{
-	bus_unregister(&ac97_bus_type);
-}
-
-module_exit(ac97_bus_exit);
-
-EXPORT_SYMBOL(ac97_bus_type);
-
-MODULE_LICENSE("GPL");
--- linux-2.6.18.noarch/sound/pci/intel8x0.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/intel8x0.c	2007-06-05 17:47:00.000000000 -0400
@@ -71,6 +71,7 @@
 static int buggy_semaphore;
 static int buggy_irq = -1; /* auto-check */
 static int xbox;
+static int spdif_aclink = -1;
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for Intel i8x0 soundcard.");
@@ -86,6 +87,8 @@
 MODULE_PARM_DESC(buggy_irq, "Enable workaround for buggy interrupts on some motherboards.");
 module_param(xbox, bool, 0444);
 MODULE_PARM_DESC(xbox, "Set to 1 for Xbox, if you have problems with the AC'97 codec detection.");
+module_param(spdif_aclink, int, 0444);
+MODULE_PARM_DESC(spdif_aclink, "S/PDIF over AC-link.");
 
 /* just for backward compatibility */
 static int enable;
@@ -368,12 +371,8 @@
 
 	int irq;
 
-	unsigned int mmio;
-	unsigned long addr;
-	void __iomem *remap_addr;
-	unsigned int bm_mmio;
-	unsigned long bmaddr;
-	void __iomem *remap_bmaddr;
+	void __iomem *addr;
+	void __iomem *bmaddr;
 
 	struct pci_dev *pci;
 	struct snd_card *card;
@@ -446,72 +445,48 @@
  *  Lowlevel I/O - busmaster
  */
 
-static u8 igetbyte(struct intel8x0 *chip, u32 offset)
+static inline u8 igetbyte(struct intel8x0 *chip, u32 offset)
 {
-	if (chip->bm_mmio)
-		return readb(chip->remap_bmaddr + offset);
-	else
-		return inb(chip->bmaddr + offset);
+	return ioread8(chip->bmaddr + offset);
 }
 
-static u16 igetword(struct intel8x0 *chip, u32 offset)
+static inline u16 igetword(struct intel8x0 *chip, u32 offset)
 {
-	if (chip->bm_mmio)
-		return readw(chip->remap_bmaddr + offset);
-	else
-		return inw(chip->bmaddr + offset);
+	return ioread16(chip->bmaddr + offset);
 }
 
-static u32 igetdword(struct intel8x0 *chip, u32 offset)
+static inline u32 igetdword(struct intel8x0 *chip, u32 offset)
 {
-	if (chip->bm_mmio)
-		return readl(chip->remap_bmaddr + offset);
-	else
-		return inl(chip->bmaddr + offset);
+	return ioread32(chip->bmaddr + offset);
 }
 
-static void iputbyte(struct intel8x0 *chip, u32 offset, u8 val)
+static inline void iputbyte(struct intel8x0 *chip, u32 offset, u8 val)
 {
-	if (chip->bm_mmio)
-		writeb(val, chip->remap_bmaddr + offset);
-	else
-		outb(val, chip->bmaddr + offset);
+	iowrite8(val, chip->bmaddr + offset);
 }
 
-static void iputword(struct intel8x0 *chip, u32 offset, u16 val)
+static inline void iputword(struct intel8x0 *chip, u32 offset, u16 val)
 {
-	if (chip->bm_mmio)
-		writew(val, chip->remap_bmaddr + offset);
-	else
-		outw(val, chip->bmaddr + offset);
+	iowrite16(val, chip->bmaddr + offset);
 }
 
-static void iputdword(struct intel8x0 *chip, u32 offset, u32 val)
+static inline void iputdword(struct intel8x0 *chip, u32 offset, u32 val)
 {
-	if (chip->bm_mmio)
-		writel(val, chip->remap_bmaddr + offset);
-	else
-		outl(val, chip->bmaddr + offset);
+	iowrite32(val, chip->bmaddr + offset);
 }
 
 /*
  *  Lowlevel I/O - AC'97 registers
  */
 
-static u16 iagetword(struct intel8x0 *chip, u32 offset)
+static inline u16 iagetword(struct intel8x0 *chip, u32 offset)
 {
-	if (chip->mmio)
-		return readw(chip->remap_addr + offset);
-	else
-		return inw(chip->addr + offset);
+	return ioread16(chip->addr + offset);
 }
 
-static void iaputword(struct intel8x0 *chip, u32 offset, u16 val)
+static inline void iaputword(struct intel8x0 *chip, u32 offset, u16 val)
 {
-	if (chip->mmio)
-		writew(val, chip->remap_addr + offset);
-	else
-		outw(val, chip->addr + offset);
+	iowrite16(val, chip->addr + offset);
 }
 
 /*
@@ -750,10 +725,11 @@
 static inline void snd_intel8x0_update(struct intel8x0 *chip, struct ichdev *ichdev)
 {
 	unsigned long port = ichdev->reg_offset;
+	unsigned long flags;
 	int status, civ, i, step;
 	int ack = 0;
 
-	spin_lock(&chip->reg_lock);
+	spin_lock_irqsave(&chip->reg_lock, flags);
 	status = igetbyte(chip, port + ichdev->roff_sr);
 	civ = igetbyte(chip, port + ICH_REG_OFF_CIV);
 	if (!(status & ICH_BCIS)) {
@@ -793,7 +769,7 @@
 			ack = 1;
 		}
 	}
-	spin_unlock(&chip->reg_lock);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	if (ack && ichdev->substream) {
 		snd_pcm_period_elapsed(ichdev->substream);
 	}
@@ -1606,10 +1582,14 @@
 	case DEVICE_INTEL_ICH4:
 		tbl = intel_pcms;
 		tblsize = ARRAY_SIZE(intel_pcms);
+		if (spdif_aclink)
+			tblsize--;
 		break;
 	case DEVICE_NFORCE:
 		tbl = nforce_pcms;
 		tblsize = ARRAY_SIZE(nforce_pcms);
+		if (spdif_aclink)
+			tblsize--;
 		break;
 	case DEVICE_ALI:
 		tbl = ali_pcms;
@@ -1962,6 +1942,12 @@
 		.type = AC97_TUNE_HP_ONLY
 	},
 	{
+		.subvendor = 0x10f7,
+		.subdevice = 0x834c,
+		.name = "Panasonic CF-R4",
+		.type = AC97_TUNE_HP_ONLY,
+	},
+	{
 		.subvendor = 0x110a,
 		.subdevice = 0x0056,
 		.name = "Fujitsu-Siemens Scenic",	/* AD1981? */
@@ -2062,24 +2048,26 @@
 	};
 
 	chip->spdif_idx = -1; /* use PCMOUT (or disabled) */
-	switch (chip->device_type) {
-	case DEVICE_NFORCE:
-		chip->spdif_idx = NVD_SPBAR;
-		break;
-	case DEVICE_ALI:
-		chip->spdif_idx = ALID_AC97SPDIFOUT;
-		break;
-	case DEVICE_INTEL_ICH4:
-		chip->spdif_idx = ICHD_SPBAR;
-		break;
-	};
+	if (!spdif_aclink) {
+		switch (chip->device_type) {
+		case DEVICE_NFORCE:
+			chip->spdif_idx = NVD_SPBAR;
+			break;
+		case DEVICE_ALI:
+			chip->spdif_idx = ALID_AC97SPDIFOUT;
+			break;
+		case DEVICE_INTEL_ICH4:
+			chip->spdif_idx = ICHD_SPBAR;
+			break;
+		};
+	}
 
 	chip->in_ac97_init = 1;
 	
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
 	ac97.private_free = snd_intel8x0_mixer_free_ac97;
-	ac97.scaps = AC97_SCAP_SKIP_MODEM;
+	ac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;
 	if (chip->xbox)
 		ac97.scaps |= AC97_SCAP_DETECT_BY_VENDOR;
 	if (chip->device_type != DEVICE_ALI) {
@@ -2195,11 +2183,11 @@
 		if ((igetdword(chip, ICHREG(GLOB_STA)) & ICH_SAMPLE_CAP) == ICH_SAMPLE_16_20)
 			chip->smp20bit = 1;
 	}
-	if (chip->device_type == DEVICE_NFORCE) {
+	if (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {
 		/* 48kHz only */
 		chip->ichd[chip->spdif_idx].pcm->rates = SNDRV_PCM_RATE_48000;
 	}
-	if (chip->device_type == DEVICE_INTEL_ICH4) {
+	if (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {
 		/* use slot 10/11 for SPDIF */
 		u32 val;
 		val = igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_PCM_SPDIF_MASK;
@@ -2251,6 +2239,16 @@
 	/* ACLink on, 2 channels */
 	cnt = igetdword(chip, ICHREG(GLOB_CNT));
 	cnt &= ~(ICH_ACLINK | ICH_PCM_246_MASK);
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	/* do cold reset - the full ac97 powerdown may leave the controller
+	 * in a warm state but actually it cannot communicate with the codec.
+	 */
+	iputdword(chip, ICHREG(GLOB_CNT), cnt & ~ICH_AC97COLD);
+	cnt = igetdword(chip, ICHREG(GLOB_CNT));
+	udelay(10);
+	iputdword(chip, ICHREG(GLOB_CNT), cnt | ICH_AC97COLD);
+	msleep(1);
+#else
 	/* finish cold or do warm reset */
 	cnt |= (cnt & ICH_AC97COLD) == 0 ? ICH_AC97COLD : ICH_AC97WARM;
 	iputdword(chip, ICHREG(GLOB_CNT), cnt);
@@ -2265,6 +2263,7 @@
 	return -EIO;
 
       __ok:
+#endif
 	if (probing) {
 		/* wait for any codec ready status.
 		 * Once it becomes ready it should remain ready
@@ -2316,7 +2315,7 @@
 		/* unmute the output on SIS7012 */
 		iputword(chip, 0x4c, igetword(chip, 0x4c) | 1);
 	}
-	if (chip->device_type == DEVICE_NFORCE) {
+	if (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {
 		/* enable SPDIF interrupt */
 		unsigned int val;
 		pci_read_config_dword(chip->pci, 0x4c, &val);
@@ -2409,7 +2408,7 @@
 	/* reset channels */
 	for (i = 0; i < chip->bdbars_count; i++)
 		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);
-	if (chip->device_type == DEVICE_NFORCE) {
+	if (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {
 		/* stop the spdif interrupt */
 		unsigned int val;
 		pci_read_config_dword(chip->pci, 0x4c, &val);
@@ -2426,10 +2425,10 @@
 			fill_nocache(chip->bdbars.area, chip->bdbars.bytes, 0);
 		snd_dma_free_pages(&chip->bdbars);
 	}
-	if (chip->remap_addr)
-		iounmap(chip->remap_addr);
-	if (chip->remap_bmaddr)
-		iounmap(chip->remap_bmaddr);
+	if (chip->addr)
+		pci_iounmap(chip->pci, chip->addr);
+	if (chip->bmaddr)
+		pci_iounmap(chip->pci, chip->bmaddr);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 	kfree(chip);
@@ -2465,10 +2464,17 @@
 	if (chip->device_type == DEVICE_INTEL_ICH4)
 		chip->sdm_saved = igetbyte(chip, ICHREG(SDM));
 
-	if (chip->irq >= 0)
+	if (chip->irq >= 0) {
+		synchronize_irq(chip->irq);
 		free_irq(chip->irq, chip);
+		chip->irq = -1;
+	}
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	/* The call below may disable built-in speaker on some laptops
+	 * after S2RAM.  So, don't touch it.
+	 */
+	/* pci_set_power_state(pci, pci_choose_state(pci, state)); */
 	return 0;
 }
 
@@ -2478,17 +2484,23 @@
 	struct intel8x0 *chip = card->private_data;
 	int i;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "intel8x0: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 	request_irq(pci->irq, snd_intel8x0_interrupt, IRQF_DISABLED|IRQF_SHARED,
 		    card->shortname, chip);
 	chip->irq = pci->irq;
 	synchronize_irq(chip->irq);
-	snd_intel8x0_chip_init(chip, 1);
+	snd_intel8x0_chip_init(chip, 0);
 
 	/* re-initialize mixer stuff */
-	if (chip->device_type == DEVICE_INTEL_ICH4) {
+	if (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {
 		/* enable separate SDINs for ICH4 */
 		iputbyte(chip, ICHREG(SDM), chip->sdm_saved);
 		/* use slot 10/11 for SPDIF */
@@ -2615,6 +2627,7 @@
 		/* not 48000Hz, tuning the clock.. */
 		chip->ac97_bus->clock = (chip->ac97_bus->clock * 48000) / pos;
 	printk(KERN_INFO "intel8x0: clocking to %d\n", chip->ac97_bus->clock);
+	snd_ac97_update_power(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 0);
 }
 
 #ifdef CONFIG_PROC_FS
@@ -2760,35 +2773,27 @@
 
 	if (device_type == DEVICE_ALI) {
 		/* ALI5455 has no ac97 region */
-		chip->bmaddr = pci_resource_start(pci, 0);
+		chip->bmaddr = pci_iomap(pci, 0, 0);
 		goto port_inited;
 	}
 
-	if (pci_resource_flags(pci, 2) & IORESOURCE_MEM) {	/* ICH4 and Nforce */
-		chip->mmio = 1;
-		chip->addr = pci_resource_start(pci, 2);
-		chip->remap_addr = ioremap_nocache(chip->addr,
-						   pci_resource_len(pci, 2));
-		if (chip->remap_addr == NULL) {
-			snd_printk(KERN_ERR "AC'97 space ioremap problem\n");
-			snd_intel8x0_free(chip);
-			return -EIO;
-		}
-	} else {
-		chip->addr = pci_resource_start(pci, 0);
+	if (pci_resource_flags(pci, 2) & IORESOURCE_MEM) /* ICH4 and Nforce */
+		chip->addr = pci_iomap(pci, 2, 0);
+	else
+		chip->addr = pci_iomap(pci, 0, 0);
+	if (!chip->addr) {
+		snd_printk(KERN_ERR "AC'97 space ioremap problem\n");
+		snd_intel8x0_free(chip);
+		return -EIO;
 	}
-	if (pci_resource_flags(pci, 3) & IORESOURCE_MEM) {	/* ICH4 */
-		chip->bm_mmio = 1;
-		chip->bmaddr = pci_resource_start(pci, 3);
-		chip->remap_bmaddr = ioremap_nocache(chip->bmaddr,
-						     pci_resource_len(pci, 3));
-		if (chip->remap_bmaddr == NULL) {
-			snd_printk(KERN_ERR "Controller space ioremap problem\n");
-			snd_intel8x0_free(chip);
-			return -EIO;
-		}
-	} else {
-		chip->bmaddr = pci_resource_start(pci, 1);
+	if (pci_resource_flags(pci, 3) & IORESOURCE_MEM) /* ICH4 */
+		chip->bmaddr = pci_iomap(pci, 3, 0);
+	else
+		chip->bmaddr = pci_iomap(pci, 1, 0);
+	if (!chip->bmaddr) {
+		snd_printk(KERN_ERR "Controller space ioremap problem\n");
+		snd_intel8x0_free(chip);
+		return -EIO;
 	}
 
  port_inited:
@@ -2931,6 +2936,29 @@
 	{ 0, NULL },
 };
 
+static struct snd_pci_quirk spdif_aclink_defaults[] __devinitdata = {
+	SND_PCI_QUIRK(0x147b, 0x1c1a, "ASUS KN8", 1),
+	{ } /* end */
+};
+
+/* look up white/black list for SPDIF over ac-link */
+static int __devinit check_default_spdif_aclink(struct pci_dev *pci)
+{
+	const struct snd_pci_quirk *w;
+
+	w = snd_pci_quirk_lookup(pci, spdif_aclink_defaults);
+	if (w) {
+		if (w->value)
+			snd_printdd(KERN_INFO "intel8x0: Using SPDIF over "
+				    "AC-Link for %s\n", w->name);
+		else
+			snd_printdd(KERN_INFO "intel8x0: Using integrated "
+				    "SPDIF DMA for %s\n", w->name);
+		return w->value;
+	}
+	return 0;
+}
+
 static int __devinit snd_intel8x0_probe(struct pci_dev *pci,
 					const struct pci_device_id *pci_id)
 {
@@ -2943,16 +2971,18 @@
 	if (card == NULL)
 		return -ENOMEM;
 
-	switch (pci_id->driver_data) {
-	case DEVICE_NFORCE:
-		strcpy(card->driver, "NFORCE");
-		break;
-	case DEVICE_INTEL_ICH4:
-		strcpy(card->driver, "ICH4");
-		break;
-	default:
-		strcpy(card->driver, "ICH");
-		break;
+	if (spdif_aclink < 0)
+		spdif_aclink = check_default_spdif_aclink(pci);
+
+	strcpy(card->driver, "ICH");
+	if (!spdif_aclink) {
+		switch (pci_id->driver_data) {
+		case DEVICE_NFORCE:
+			strcpy(card->driver, "NFORCE");
+			break;
+		case DEVICE_INTEL_ICH4:
+			strcpy(card->driver, "ICH4");
+		}
 	}
 
 	strcpy(card->shortname, "Intel ICH");
@@ -2992,8 +3022,8 @@
 	snd_intel8x0_proc_init(chip);
 
 	snprintf(card->longname, sizeof(card->longname),
-		 "%s with %s at %#lx, irq %i", card->shortname,
-		 snd_ac97_get_short_name(chip->ac97[0]), chip->addr, chip->irq);
+		 "%s with %s at irq %i", card->shortname,
+		 snd_ac97_get_short_name(chip->ac97[0]), chip->irq);
 
 	if (! ac97_clock)
 		intel8x0_measure_ac97_clock(chip);
--- linux-2.6.18.noarch/sound/pci/als300.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/als300.c	2007-06-05 17:47:00.000000000 -0400
@@ -190,7 +190,7 @@
 	snd_als300_dbgcallenter();
 	snd_als300_set_irq_flag(chip, IRQ_DISABLE);
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 	kfree(chip);
@@ -204,8 +204,7 @@
 	return snd_als300_free(chip);
 }
 
-static irqreturn_t snd_als300_interrupt(int irq, void *dev_id,
-						struct pt_regs *regs)
+static irqreturn_t snd_als300_interrupt(int irq, void *dev_id)
 {
 	u8 status;
 	struct snd_als300 *chip = dev_id;
@@ -236,8 +235,7 @@
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id,
-						struct pt_regs *regs)
+static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id)
 {
 	u8 general, mpu, dram;
 	struct snd_als300 *chip = dev_id;
@@ -446,7 +444,7 @@
 }
 
 static int snd_als300_pcm_hw_params(struct snd_pcm_substream *substream,
-					snd_pcm_hw_params_t * hw_params)
+				    struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream,
 					params_buffer_bytes(hw_params));
@@ -675,7 +673,7 @@
 	snd_als300_dbgcallleave();
 }
 
-static int __devinit snd_als300_create(snd_card_t *card,
+static int __devinit snd_als300_create(struct snd_card *card,
 				       struct pci_dev *pci, int chip_type,
 				       struct snd_als300 **rchip)
 {
@@ -683,7 +681,7 @@
 	void *irq_handler;
 	int err;
 
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_als300_dev_free,
 	};
 	*rchip = NULL;
@@ -724,8 +722,8 @@
 	else
 		irq_handler = snd_als300_interrupt;
 
-	if (request_irq(pci->irq, irq_handler, IRQF_DISABLED|IRQF_SHARED,
-					card->shortname, (void *)chip)) {
+	if (request_irq(pci->irq, irq_handler, IRQF_SHARED,
+			card->shortname, chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_als300_free(chip);
 		return -EBUSY;
@@ -770,9 +768,9 @@
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -781,9 +779,14 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_als300 *chip = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "als300: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_als300_init(chip);
--- linux-2.6.18.noarch/sound/pci/als4000.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/als4000.c	2007-06-05 17:47:00.000000000 -0400
@@ -804,9 +804,9 @@
 	snd_pcm_suspend_all(chip->pcm);
 	snd_sbmixer_suspend(chip);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -816,9 +816,14 @@
 	struct snd_card_als4000 *acard = card->private_data;
 	struct snd_sb *chip = acard->chip;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "als4000: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_als4000_configure(chip);
--- linux-2.6.18.noarch/sound/pci/bt87x.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/bt87x.c	2007-06-05 17:47:00.000000000 -0400
@@ -699,7 +699,7 @@
 						     SNDRV_DMA_TYPE_DEV_SG,
 						     snd_dma_pci_data(chip->pci),
 							128 * 1024,
-							(255 * 4092 + 1023) & ~1023);
+							ALIGN(255 * 4092, 1024));
 }
 
 static int __devinit snd_bt87x_create(struct snd_card *card,
@@ -804,6 +804,7 @@
 	{0x1822, 0x0001}, /* Twinhan VisionPlus DVB-T */
 	{0x18ac, 0xd500}, /* DVICO FusionHDTV 5 Lite */
 	{0x18ac, 0xdb10}, /* DVICO FusionHDTV DVB-T Lite */
+	{0x18ac, 0xdb11}, /* Ultraview DVB-T Lite */
 	{0x270f, 0xfc00}, /* Chaintech Digitop DST-1000 DVB-S */
 	{0x7063, 0x2000}, /* pcHDTV HD-2000 TV */
 };
--- linux-2.6.18.noarch/sound/pci/atiixp_modem.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/atiixp_modem.c	2007-06-05 17:47:00.000000000 -0400
@@ -1090,7 +1090,7 @@
 		ac97.private_data = chip;
 		ac97.pci = chip->pci;
 		ac97.num = i;
-		ac97.scaps = AC97_SCAP_SKIP_AUDIO;
+		ac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;
 		if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i])) < 0) {
 			chip->ac97[i] = NULL; /* to be sure */
 			snd_printdd("atiixp-modem: codec %d not available for modem\n", i);
@@ -1128,9 +1128,9 @@
 	snd_atiixp_aclink_down(chip);
 	snd_atiixp_chip_stop(chip);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1140,9 +1140,14 @@
 	struct atiixp_modem *chip = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "atiixp-modem: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_atiixp_aclink_reset(chip);
--- linux-2.6.18.noarch/sound/pci/via82xx_modem.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/via82xx_modem.c	2007-06-05 17:47:00.000000000 -0400
@@ -900,7 +900,7 @@
 	ac97.private_data = chip;
 	ac97.private_free = snd_via82xx_mixer_free_ac97;
 	ac97.pci = chip->pci;
-	ac97.scaps = AC97_SCAP_SKIP_AUDIO;
+	ac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;
 	ac97.num = chip->ac97_secondary;
 
 	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
@@ -1032,9 +1032,10 @@
 		snd_via82xx_channel_reset(chip, &chip->devs[i]);
 	synchronize_irq(chip->irq);
 	snd_ac97_suspend(chip->ac97);
-	pci_set_power_state(pci, PCI_D3hot);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1044,9 +1045,14 @@
 	struct via82xx_modem *chip = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "via82xx-modem: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_via82xx_chip_init(chip);
--- linux-2.6.18.noarch/sound/pci/nm256/nm256.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/nm256/nm256.c	2007-06-05 17:47:30.000000000 -0400
@@ -1390,6 +1390,7 @@
 	chip->coeffs_current = 0;
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1401,8 +1402,17 @@
 
 	/* Perform a full reset on the hardware */
 	chip->in_resume = 1;
+
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "nm256: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	pci_set_master(pci);
+
 	snd_nm256_init_chip(chip);
 
 	/* restore ac97 */
@@ -1618,23 +1628,15 @@
 }
 
 
-struct nm256_quirk {
-	unsigned short vendor;
-	unsigned short device;
-	int type;
-};
-
 enum { NM_BLACKLISTED, NM_RESET_WORKAROUND, NM_RESET_WORKAROUND_2 };
 
-static struct nm256_quirk nm256_quirks[] __devinitdata = {
+static struct snd_pci_quirk nm256_quirks[] __devinitdata = {
 	/* HP omnibook 4150 has cs4232 codec internally */
-	{ .vendor = 0x103c, .device = 0x0007, .type = NM_BLACKLISTED },
-	/* Sony PCG-F305 */
-	{ .vendor = 0x104d, .device = 0x8041, .type = NM_RESET_WORKAROUND },
-	/* Dell Latitude LS */
-	{ .vendor = 0x1028, .device = 0x0080, .type = NM_RESET_WORKAROUND },
-	/* Dell Latitude CSx */
-	{ .vendor = 0x1028, .device = 0x0091, .type = NM_RESET_WORKAROUND_2 },
+	SND_PCI_QUIRK(0x103c, 0x0007, "HP omnibook 4150", NM_BLACKLISTED),
+	/* Reset workarounds to avoid lock-ups */
+	SND_PCI_QUIRK(0x104d, 0x8041, "Sony PCG-F305", NM_RESET_WORKAROUND),
+	SND_PCI_QUIRK(0x1028, 0x0080, "Dell Latitude LS", NM_RESET_WORKAROUND),
+	SND_PCI_QUIRK(0x1028, 0x0091, "Dell Latitude CSx", NM_RESET_WORKAROUND_2),
 	{ } /* terminator */
 };
 
@@ -1645,26 +1647,22 @@
 	struct snd_card *card;
 	struct nm256 *chip;
 	int err;
-	struct nm256_quirk *q;
-	u16 subsystem_vendor, subsystem_device;
-
-	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
-	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
+	const struct snd_pci_quirk *q;
 
-	for (q = nm256_quirks; q->vendor; q++) {
-		if (q->vendor == subsystem_vendor && q->device == subsystem_device) {
-			switch (q->type) {
-			case NM_BLACKLISTED:
-				printk(KERN_INFO "nm256: The device is blacklisted. "
-				       "Loading stopped\n");
-				return -ENODEV;
-			case NM_RESET_WORKAROUND_2:
-				reset_workaround_2 = 1;
-				/* Fall-through */
-			case NM_RESET_WORKAROUND:
-				reset_workaround = 1;
-				break;
-			}
+	q = snd_pci_quirk_lookup(pci, nm256_quirks);
+	if (q) {
+		snd_printdd(KERN_INFO "nm256: Enabled quirk for %s.\n", q->name);
+		switch (q->value) {
+		case NM_BLACKLISTED:
+			printk(KERN_INFO "nm256: The device is blacklisted. "
+			       "Loading stopped\n");
+			return -ENODEV;
+		case NM_RESET_WORKAROUND_2:
+			reset_workaround_2 = 1;
+			/* Fall-through */
+		case NM_RESET_WORKAROUND:
+			reset_workaround = 1;
+			break;
 		}
 	}
 
--- linux-2.6.18.noarch/sound/pci/cmipci.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/cmipci.c	2007-06-05 17:47:00.000000000 -0400
@@ -57,7 +57,7 @@
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 static long mpu_port[SNDRV_CARDS];
-static long fm_port[SNDRV_CARDS];
+static long fm_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 static int soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS];
@@ -2198,7 +2198,8 @@
 		val = inb(cm->iobase + args->reg);
 	else
 		val = snd_cmipci_read(cm, args->reg);
-	change = (val & args->mask) != (ucontrol->value.integer.value[0] ? args->mask : 0);
+	change = (val & args->mask) != (ucontrol->value.integer.value[0] ? 
+			args->mask_on : (args->mask & ~args->mask_on));
 	if (change) {
 		val &= ~args->mask;
 		if (ucontrol->value.integer.value[0])
@@ -2778,6 +2779,9 @@
 	struct snd_opl3 *opl3;
 	int err;
 
+	if (!fm_port)
+		goto disable_fm;
+
 	/* first try FM regs in PCI port range */
 	iosynth = cm->iobase + CM_REG_FM_PCI;
 	err = snd_opl3_create(cm->card, iosynth, iosynth + 2,
@@ -2792,7 +2796,7 @@
 		case 0x3C8: val |= CM_FMSEL_3C8; break;
 		case 0x388: val |= CM_FMSEL_388; break;
 		default:
-			    return 0;
+			goto disable_fm;
 		}
 		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
 		/* enable FM */
@@ -2802,11 +2806,7 @@
 				    OPL3_HW_OPL3, 0, &opl3) < 0) {
 			printk(KERN_ERR "cmipci: no OPL device at %#lx, "
 			       "skipping...\n", iosynth);
-			/* disable FM */
-			snd_cmipci_write(cm, CM_REG_LEGACY_CTRL,
-					 val & ~CM_FMSEL_MASK);
-			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
-			return 0;
+			goto disable_fm;
 		}
 	}
 	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
@@ -2814,6 +2814,11 @@
 		return err;
 	}
 	return 0;
+
+ disable_fm:
+	snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_FMSEL_MASK);
+	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+	return 0;
 }
 
 static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
@@ -2862,7 +2867,7 @@
 	cm->iobase = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt,
-			IRQF_DISABLED|IRQF_SHARED, card->driver, cm)) {
+			IRQF_SHARED, card->driver, cm)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;
@@ -3122,9 +3127,9 @@
 	/* disable ints */
 	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -3134,9 +3139,14 @@
 	struct cmipci *cm = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "cmipci: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	/* reset / initialize to a sane state */
--- linux-2.6.18.noarch/sound/pci/Kconfig.orig	2007-06-05 16:07:58.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/Kconfig	2007-06-05 17:47:00.000000000 -0400
@@ -236,7 +236,7 @@
 config SND_DARLA20
 	tristate "(Echoaudio) Darla20"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Darla.
@@ -247,7 +247,7 @@
 config SND_GINA20
 	tristate "(Echoaudio) Gina20"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Gina.
@@ -258,7 +258,7 @@
 config SND_LAYLA20
 	tristate "(Echoaudio) Layla20"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_RAWMIDI
 	select SND_PCM
 	help
@@ -270,7 +270,7 @@
 config SND_DARLA24
 	tristate "(Echoaudio) Darla24"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Darla24.
@@ -281,7 +281,7 @@
 config SND_GINA24
 	tristate "(Echoaudio) Gina24"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Gina24.
@@ -292,7 +292,7 @@
 config SND_LAYLA24
 	tristate "(Echoaudio) Layla24"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_RAWMIDI
 	select SND_PCM
 	help
@@ -304,7 +304,7 @@
 config SND_MONA
 	tristate "(Echoaudio) Mona"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_RAWMIDI
 	select SND_PCM
 	help
@@ -316,7 +316,7 @@
 config SND_MIA
 	tristate "(Echoaudio) Mia"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_RAWMIDI
 	select SND_PCM
 	help
@@ -328,7 +328,7 @@
 config SND_ECHO3G
 	tristate "(Echoaudio) 3G cards"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_RAWMIDI
 	select SND_PCM
 	help
@@ -340,7 +340,7 @@
 config SND_INDIGO
 	tristate "(Echoaudio) Indigo"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Indigo.
@@ -351,7 +351,7 @@
 config SND_INDIGOIO
 	tristate "(Echoaudio) Indigo IO"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Indigo IO.
@@ -362,7 +362,7 @@
 config SND_INDIGODJ
 	tristate "(Echoaudio) Indigo DJ"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Echoaudio Indigo DJ.
@@ -373,6 +373,7 @@
 config SND_EMU10K1
 	tristate "Emu10k1 (SB Live!, Audigy, E-mu APS)"
 	depends on SND
+	select FW_LOADER
 	select SND_HWDEP
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
@@ -475,6 +476,7 @@
 	depends on SND_FM801_TEA575X_BOOL
 	default SND_FM801
 	select VIDEO_V4L1
+	select VIDEO_DEV
 
 config SND_HDA_INTEL
 	tristate "Intel HD Audio"
@@ -574,6 +576,7 @@
 config SND_KORG1212
 	tristate "Korg 1212 IO"
 	depends on SND
+	select FW_LOADER
 	select SND_PCM
 	help
 	  Say Y here to include support for Korg 1212IO soundcards.
@@ -584,6 +587,7 @@
 config SND_MAESTRO3
 	tristate "ESS Allegro/Maestro3"
 	depends on SND
+	select FW_LOADER
 	select SND_AC97_CODEC
 	help
 	  Say Y here to include support for soundcards based on ESS Maestro 3
@@ -628,7 +632,7 @@
 config SND_RIPTIDE
 	tristate "Conexant Riptide"
 	depends on SND
-	depends on FW_LOADER
+	select FW_LOADER
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
@@ -733,6 +737,7 @@
 config SND_YMFPCI
 	tristate "Yamaha YMF724/740/744/754"
 	depends on SND
+	select FW_LOADER
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
@@ -743,4 +748,17 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-ymfpci.
 
+config SND_AC97_POWER_SAVE
+	bool "AC97 Power-Saving Mode"
+	depends on SND_AC97_CODEC && EXPERIMENTAL
+	default n
+	help
+	  Say Y here to enable the aggressive power-saving support of
+	  AC97 codecs.  In this mode, the power-mode is dynamically
+	  controlled at each open/close.
+
+	  The mode is activated by passing power_save=1 option to
+	  snd-ac97-codec driver.  You can toggle it dynamically over
+	  sysfs, too.
+
 endmenu
--- linux-2.6.18.noarch/sound/pci/rme9652/hdspm.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/rme9652/hdspm.c	2007-06-05 17:47:52.000000000 -0400
@@ -6,6 +6,8 @@
  *      code based on hdsp.c   Paul Davis
  *                             Marcus Andersson
  *                             Thomas Charbonnel
+ *      Modified 2006-06-01 for AES32 support by Remy Bruno
+ *                                               <remy.bruno@trinnov.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -77,7 +79,8 @@
 
 MODULE_AUTHOR
       ("Winfried Ritsch <ritsch_AT_iem.at>, Paul Davis <paul@linuxaudiosystems.com>, "
-       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>");
+       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>, "
+       "Remy Bruno <remy.bruno@trinnov.com>");
 MODULE_DESCRIPTION("RME HDSPM");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
@@ -107,7 +110,12 @@
 /* --- Read registers. ---
    These are defined as byte-offsets from the iobase value */
 #define HDSPM_statusRegister    0
-#define HDSPM_statusRegister2  96
+/*#define HDSPM_statusRegister2  96 */
+/* after RME Windows driver sources, status2 is 4-byte word # 48 = word at
+ * offset 192, for AES32 *and* MADI
+ * => need to check that offset 192 is working on MADI */
+#define HDSPM_statusRegister2  192
+#define HDSPM_timecodeRegister 128
 
 #define HDSPM_midiDataIn0     360
 #define HDSPM_midiDataIn1     364
@@ -140,37 +148,50 @@
 #define HDSPM_Frequency0  (1<<6)  /* 0=44.1kHz/88.2kHz 1=48kHz/96kHz */
 #define HDSPM_Frequency1  (1<<7)  /* 0=32kHz/64kHz */
 #define HDSPM_DoubleSpeed (1<<8)  /* 0=normal speed, 1=double speed */
-#define HDSPM_QuadSpeed   (1<<31) /* quad speed bit, not implemented now */
+#define HDSPM_QuadSpeed   (1<<31) /* quad speed bit */
 
+#define HDSPM_Professional (1<<9) /* Professional */ /* AES32 ONLY */
 #define HDSPM_TX_64ch     (1<<10) /* Output 64channel MODE=1,
-				     56channelMODE=0 */
+				     56channelMODE=0 */ /* MADI ONLY*/
+#define HDSPM_Emphasis    (1<<10) /* Emphasis */ /* AES32 ONLY */
 
 #define HDSPM_AutoInp     (1<<11) /* Auto Input (takeover) == Safe Mode, 
-                                     0=off, 1=on  */
+                                     0=off, 1=on  */ /* MADI ONLY */
+#define HDSPM_Dolby       (1<<11) /* Dolby = "NonAudio" ?? */ /* AES32 ONLY */
 
-#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */
+#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */ /* MADI ONLY*/
 #define HDSPM_InputSelect1 (1<<15) /* should be 0 */
 
 #define HDSPM_SyncRef0     (1<<16) /* 0=WOrd, 1=MADI */
-#define HDSPM_SyncRef1     (1<<17) /* should be 0 */
+#define HDSPM_SyncRef1     (1<<17) /* for AES32: SyncRefN codes the AES # */
+#define HDSPM_SyncRef2     (1<<13)
+#define HDSPM_SyncRef3     (1<<25)
 
+#define HDSPM_SMUX         (1<<18) /* Frame ??? */ /* MADI ONY */
 #define HDSPM_clr_tms      (1<<19) /* clear track marker, do not use 
                                       AES additional bits in
 				      lower 5 Audiodatabits ??? */
+#define HDSPM_taxi_reset   (1<<20) /* ??? */ /* MADI ONLY ? */
+#define HDSPM_WCK48        (1<<20) /* Frame ??? = HDSPM_SMUX */ /* AES32 ONLY */
 
 #define HDSPM_Midi0InterruptEnable (1<<22)
 #define HDSPM_Midi1InterruptEnable (1<<23)
 
 #define HDSPM_LineOut (1<<24) /* Analog Out on channel 63/64 on=1, mute=0 */
 
+#define HDSPM_DS_DoubleWire (1<<26) /* AES32 ONLY */
+#define HDSPM_QS_DoubleWire (1<<27) /* AES32 ONLY */
+#define HDSPM_QS_QuadWire   (1<<28) /* AES32 ONLY */
+
+#define HDSPM_wclk_sel (1<<30)
 
 /* --- bit helper defines */
 #define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)
-#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1)
+#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1|HDSPM_DoubleSpeed|HDSPM_QuadSpeed)
 #define HDSPM_InputMask      (HDSPM_InputSelect0|HDSPM_InputSelect1)
 #define HDSPM_InputOptical   0
 #define HDSPM_InputCoaxial   (HDSPM_InputSelect0)
-#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1)
+#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1|HDSPM_SyncRef2|HDSPM_SyncRef3)
 #define HDSPM_SyncRef_Word   0
 #define HDSPM_SyncRef_MADI   (HDSPM_SyncRef0)
 
@@ -183,6 +204,9 @@
 #define HDSPM_Frequency64KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency0)
 #define HDSPM_Frequency88_2KHz (HDSPM_DoubleSpeed|HDSPM_Frequency1)
 #define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
+#define HDSPM_Frequency128KHz   (HDSPM_QuadSpeed|HDSPM_Frequency0)
+#define HDSPM_Frequency176_4KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1)
+#define HDSPM_Frequency192KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
 
 /* --- for internal discrimination */
 #define HDSPM_CLOCK_SOURCE_AUTOSYNC          0	/* Sample Clock Sources */
@@ -229,7 +253,8 @@
 #define HDSPM_BIGENDIAN_MODE  (1<<9)
 #define HDSPM_RD_MULTIPLE     (1<<10)
 
-/* --- Status Register bits --- */
+/* --- Status Register bits --- */ /* MADI ONLY */ /* Bits defined here and
+     that do not conflict with specific bits for AES32 seem to be valid also for the AES32 */
 #define HDSPM_audioIRQPending    (1<<0)	/* IRQ is high and pending */
 #define HDSPM_RX_64ch            (1<<1)	/* Input 64chan. MODE=1, 56chn. MODE=0 */
 #define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1 (like inp0) */
@@ -263,7 +288,7 @@
 #define HDSPM_madiFreq176_4 (HDSPM_madiFreq3)
 #define HDSPM_madiFreq192   (HDSPM_madiFreq3|HDSPM_madiFreq0)
 
-/* Status2 Register bits */
+/* Status2 Register bits */ /* MADI ONLY */
 
 #define HDSPM_version0 (1<<0)	/* not realy defined but I guess */
 #define HDSPM_version1 (1<<1)	/* in former cards it was ??? */
@@ -297,6 +322,56 @@
 #define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)
 #define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
 
+/*
+   For AES32, bits for status, status2 and timecode are different
+*/
+/* status */
+#define HDSPM_AES32_wcLock	0x0200000
+#define HDSPM_AES32_wcFreq_bit  22
+/* (status >> HDSPM_AES32_wcFreq_bit) & 0xF gives WC frequency (cf function 
+  HDSPM_bit2freq */
+#define HDSPM_AES32_syncref_bit  16
+/* (status >> HDSPM_AES32_syncref_bit) & 0xF gives sync source */
+
+#define HDSPM_AES32_AUTOSYNC_FROM_WORD 0
+#define HDSPM_AES32_AUTOSYNC_FROM_AES1 1
+#define HDSPM_AES32_AUTOSYNC_FROM_AES2 2
+#define HDSPM_AES32_AUTOSYNC_FROM_AES3 3
+#define HDSPM_AES32_AUTOSYNC_FROM_AES4 4
+#define HDSPM_AES32_AUTOSYNC_FROM_AES5 5
+#define HDSPM_AES32_AUTOSYNC_FROM_AES6 6
+#define HDSPM_AES32_AUTOSYNC_FROM_AES7 7
+#define HDSPM_AES32_AUTOSYNC_FROM_AES8 8
+#define HDSPM_AES32_AUTOSYNC_FROM_NONE -1
+
+/*  status2 */
+/* HDSPM_LockAES_bit is given by HDSPM_LockAES >> (AES# - 1) */
+#define HDSPM_LockAES   0x80
+#define HDSPM_LockAES1  0x80
+#define HDSPM_LockAES2  0x40
+#define HDSPM_LockAES3  0x20
+#define HDSPM_LockAES4  0x10
+#define HDSPM_LockAES5  0x8
+#define HDSPM_LockAES6  0x4
+#define HDSPM_LockAES7  0x2
+#define HDSPM_LockAES8  0x1
+/*
+   Timecode
+   After windows driver sources, bits 4*i to 4*i+3 give the input frequency on
+   AES i+1
+ bits 3210
+      0001  32kHz
+      0010  44.1kHz
+      0011  48kHz
+      0100  64kHz
+      0101  88.2kHz
+      0110  96kHz
+      0111  128kHz
+      1000  176.4kHz
+      1001  192kHz
+  NB: Timecode register doesn't seem to work on AES32 card revision 230
+*/
+
 /* Mixer Values */
 #define UNITY_GAIN          32768	/* = 65536/2 */
 #define MINUS_INFINITY_GAIN 0
@@ -314,10 +389,14 @@
    size is the same regardless of the number of channels, and
    also the latency to use. 
    for one direction !!!
+   => need to mupltiply by 2!!
 */
-#define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
+#define HDSPM_DMA_AREA_BYTES (2 * HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
+/* revisions >= 230 indicate AES32 card */
+#define HDSPM_AESREVISION 230
+
 struct hdspm_midi {
 	struct hdspm *hdspm;
 	int id;
@@ -336,7 +415,9 @@
         struct snd_pcm_substream *playback_substream; /* and/or capture stream */
 
 	char *card_name;	     /* for procinfo */
-	unsigned short firmware_rev; /* dont know if relevant */
+	unsigned short firmware_rev; /* dont know if relevant (yes if AES32)*/
+
+	unsigned char is_aes32;    /* indicates if card is AES32 */
 
 	int precise_ptr;	/* use precise pointers, to be tested */
 	int monitor_outs;	/* set up monitoring outs init flag */
@@ -453,6 +534,15 @@
 static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
 			     unsigned int reg, int channels);
 
+static inline int HDSPM_bit2freq(int n)
+{
+	static int bit2freq_tab[] = { 0, 32000, 44100, 48000, 64000, 88200,
+		96000, 128000, 176400, 192000 };
+	if (n < 1 || n > 9)
+		return 0;
+	return bit2freq_tab[n];
+}
+
 /* Write/read to/from HDSPM with Adresses in Bytes
    not words but only 32Bit writes are allowed */
 
@@ -544,86 +634,105 @@
 /* check for external sample rate */
 static inline int hdspm_external_sample_rate(struct hdspm * hdspm)
 {
-	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-	unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-	unsigned int rate_bits;
-	int rate = 0;
-
-	/* if wordclock has synced freq and wordclock is valid */
-	if ((status2 & HDSPM_wcLock) != 0 &&
-	    (status & HDSPM_SelSyncRef0) == 0) {
-
-		rate_bits = status2 & HDSPM_wcFreqMask;
-
-		switch (rate_bits) {
-		case HDSPM_wcFreq32:
-			rate = 32000;
-			break;
-		case HDSPM_wcFreq44_1:
-			rate = 44100;
-			break;
-		case HDSPM_wcFreq48:
-			rate = 48000;
-			break;
-		case HDSPM_wcFreq64:
-			rate = 64000;
-			break;
-		case HDSPM_wcFreq88_2:
-			rate = 88200;
-			break;
-		case HDSPM_wcFreq96:
-			rate = 96000;
-			break;
-			/* Quadspeed Bit missing ???? */
-		default:
-			rate = 0;
-			break;
+	if (hdspm->is_aes32) {
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		unsigned int timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
+
+		int syncref = hdspm_autosync_ref(hdspm);
+
+		if (syncref == HDSPM_AES32_AUTOSYNC_FROM_WORD &&
+				status & HDSPM_AES32_wcLock)
+			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF);
+		if (syncref >= HDSPM_AES32_AUTOSYNC_FROM_AES1 &&
+			syncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&
+			status2 & (HDSPM_LockAES >>
+			          (syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1)))
+			return HDSPM_bit2freq((timecode >>
+			  (4*(syncref-HDSPM_AES32_AUTOSYNC_FROM_AES1))) & 0xF);
+		return 0;
+	} else {
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		unsigned int rate_bits;
+		int rate = 0;
+
+		/* if wordclock has synced freq and wordclock is valid */
+		if ((status2 & HDSPM_wcLock) != 0 &&
+				(status & HDSPM_SelSyncRef0) == 0) {
+
+			rate_bits = status2 & HDSPM_wcFreqMask;
+
+			switch (rate_bits) {
+			case HDSPM_wcFreq32:
+				rate = 32000;
+				break;
+			case HDSPM_wcFreq44_1:
+				rate = 44100;
+				break;
+			case HDSPM_wcFreq48:
+				rate = 48000;
+				break;
+			case HDSPM_wcFreq64:
+				rate = 64000;
+				break;
+			case HDSPM_wcFreq88_2:
+				rate = 88200;
+				break;
+			case HDSPM_wcFreq96:
+				rate = 96000;
+				break;
+				/* Quadspeed Bit missing ???? */
+			default:
+				rate = 0;
+				break;
+			}
 		}
-	}
 
-	/* if rate detected and Syncref is Word than have it, word has priority to MADI */
-	if (rate != 0
-	    && (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
-		return rate;
-
-	/* maby a madi input (which is taken if sel sync is madi) */
-	if (status & HDSPM_madiLock) {
-		rate_bits = status & HDSPM_madiFreqMask;
-
-		switch (rate_bits) {
-		case HDSPM_madiFreq32:
-			rate = 32000;
-			break;
-		case HDSPM_madiFreq44_1:
-			rate = 44100;
-			break;
-		case HDSPM_madiFreq48:
-			rate = 48000;
-			break;
-		case HDSPM_madiFreq64:
-			rate = 64000;
-			break;
-		case HDSPM_madiFreq88_2:
-			rate = 88200;
-			break;
-		case HDSPM_madiFreq96:
-			rate = 96000;
-			break;
-		case HDSPM_madiFreq128:
-			rate = 128000;
-			break;
-		case HDSPM_madiFreq176_4:
-			rate = 176400;
-			break;
-		case HDSPM_madiFreq192:
-			rate = 192000;
-			break;
-		default:
-			rate = 0;
-			break;
+		/* if rate detected and Syncref is Word than have it, word has priority to MADI */
+		if (rate != 0 &&
+	            (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
+			return rate;
+
+		/* maby a madi input (which is taken if sel sync is madi) */
+		if (status & HDSPM_madiLock) {
+			rate_bits = status & HDSPM_madiFreqMask;
+
+			switch (rate_bits) {
+			case HDSPM_madiFreq32:
+				rate = 32000;
+				break;
+			case HDSPM_madiFreq44_1:
+				rate = 44100;
+				break;
+			case HDSPM_madiFreq48:
+				rate = 48000;
+				break;
+			case HDSPM_madiFreq64:
+				rate = 64000;
+				break;
+			case HDSPM_madiFreq88_2:
+				rate = 88200;
+				break;
+			case HDSPM_madiFreq96:
+				rate = 96000;
+				break;
+			case HDSPM_madiFreq128:
+				rate = 128000;
+				break;
+			case HDSPM_madiFreq176_4:
+				rate = 176400;
+				break;
+			case HDSPM_madiFreq192:
+				rate = 192000;
+				break;
+			default:
+				rate = 0;
+				break;
+			}
 		}
+		return rate;
 	}
-	return rate;
 }
 
 /* Latency function */
@@ -676,7 +785,8 @@
 	int n = hdspm->period_bytes;
 	void *buf = hdspm->playback_buffer;
 
-	snd_assert(buf != NULL, return);
+	if (buf == NULL)
+		return;
 
 	for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
 		memset(buf, 0, n);
@@ -716,6 +826,7 @@
 	int current_rate;
 	int rate_bits;
 	int not_set = 0;
+	int is_single, is_double, is_quad;
 
 	/* ASSUMPTION: hdspm->lock is either set, or there is no need for
 	   it (e.g. during module initialization).
@@ -766,43 +877,56 @@
 	   changes in the read/write routines.  
 	 */
 
+	is_single = (current_rate <= 48000);
+	is_double = (current_rate > 48000 && current_rate <= 96000);
+	is_quad = (current_rate > 96000);
+
 	switch (rate) {
 	case 32000:
-		if (current_rate > 48000) {
+		if (!is_single)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency32KHz;
 		break;
 	case 44100:
-		if (current_rate > 48000) {
+		if (!is_single)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency44_1KHz;
 		break;
 	case 48000:
-		if (current_rate > 48000) {
+		if (!is_single)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency48KHz;
 		break;
 	case 64000:
-		if (current_rate <= 48000) {
+		if (!is_double)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency64KHz;
 		break;
 	case 88200:
-		if (current_rate <= 48000) {
+		if (!is_double)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency88_2KHz;
 		break;
 	case 96000:
-		if (current_rate <= 48000) {
+		if (!is_double)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency96KHz;
 		break;
+	case 128000:
+		if (!is_quad)
+			reject_if_open = 1;
+		rate_bits = HDSPM_Frequency128KHz;
+		break;
+	case 176400:
+		if (!is_quad)
+			reject_if_open = 1;
+		rate_bits = HDSPM_Frequency176_4KHz;
+		break;
+	case 192000:
+		if (!is_quad)
+			reject_if_open = 1;
+		rate_bits = HDSPM_Frequency192KHz;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -819,7 +943,7 @@
 	hdspm->control_register |= rate_bits;
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
-	if (rate > 64000)
+	if (rate > 96000 /* 64000*/)
 		hdspm->channel_map = channel_map_madi_qs;
 	else if (rate > 48000)
 		hdspm->channel_map = channel_map_madi_ds;
@@ -1455,11 +1579,27 @@
 	/* Notice that this looks at the requested sync source,
 	   not the one actually in use.
 	 */
-	switch (hdspm->control_register & HDSPM_SyncRefMask) {
-	case HDSPM_SyncRef_Word:
-		return HDSPM_SYNC_FROM_WORD;
-	case HDSPM_SyncRef_MADI:
-		return HDSPM_SYNC_FROM_MADI;
+	if (hdspm->is_aes32) {
+		switch (hdspm->control_register & HDSPM_SyncRefMask) {
+		/* number gives AES index, except for 0 which
+		   corresponds to WordClock */
+		case 0: return 0;
+		case HDSPM_SyncRef0: return 1;
+		case HDSPM_SyncRef1: return 2;
+		case HDSPM_SyncRef1+HDSPM_SyncRef0: return 3;
+		case HDSPM_SyncRef2: return 4;
+		case HDSPM_SyncRef2+HDSPM_SyncRef0: return 5;
+		case HDSPM_SyncRef2+HDSPM_SyncRef1: return 6;
+		case HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0: return 7;
+		case HDSPM_SyncRef3: return 8;
+		}
+	} else {
+		switch (hdspm->control_register & HDSPM_SyncRefMask) {
+		case HDSPM_SyncRef_Word:
+			return HDSPM_SYNC_FROM_WORD;
+		case HDSPM_SyncRef_MADI:
+			return HDSPM_SYNC_FROM_MADI;
+		}
 	}
 
 	return HDSPM_SYNC_FROM_WORD;
@@ -1469,15 +1609,49 @@
 {
 	hdspm->control_register &= ~HDSPM_SyncRefMask;
 
-	switch (pref) {
-	case HDSPM_SYNC_FROM_MADI:
-		hdspm->control_register |= HDSPM_SyncRef_MADI;
-		break;
-	case HDSPM_SYNC_FROM_WORD:
-		hdspm->control_register |= HDSPM_SyncRef_Word;
-		break;
-	default:
-		return -1;
+	if (hdspm->is_aes32) {
+		switch (pref) {
+		case 0:
+		       hdspm->control_register |= 0;
+		       break;
+		case 1:
+		       hdspm->control_register |= HDSPM_SyncRef0;
+		       break;
+		case 2:
+		       hdspm->control_register |= HDSPM_SyncRef1;
+		       break;
+		case 3:
+		       hdspm->control_register |= HDSPM_SyncRef1+HDSPM_SyncRef0;
+		       break;
+		case 4:
+		       hdspm->control_register |= HDSPM_SyncRef2;
+		       break;
+		case 5:
+		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef0;
+		       break;
+		case 6:
+		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1;
+		       break;
+		case 7:
+		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;
+		       break;
+		case 8:
+		       hdspm->control_register |= HDSPM_SyncRef3;
+		       break;
+		default:
+		       return -1;
+		}
+	} else {
+		switch (pref) {
+		case HDSPM_SYNC_FROM_MADI:
+			hdspm->control_register |= HDSPM_SyncRef_MADI;
+			break;
+		case HDSPM_SYNC_FROM_WORD:
+			hdspm->control_register |= HDSPM_SyncRef_Word;
+			break;
+		default:
+			return -1;
+		}
 	}
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 	return 0;
@@ -1486,18 +1660,36 @@
 static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Word", "MADI" };
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
+	if (hdspm->is_aes32) {
+		static char *texts[] = { "Word", "AES1", "AES2", "AES3",
+			"AES4", "AES5",	"AES6", "AES7", "AES8" };
+
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
+
+		uinfo->value.enumerated.items = 9;
+
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	} else {
+		static char *texts[] = { "Word", "MADI" };
 
-	uinfo->value.enumerated.items = 2;
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
 
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+		uinfo->value.enumerated.items = 2;
+
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	}
 	return 0;
 }
 
@@ -1517,7 +1709,7 @@
 	int change, max;
 	unsigned int val;
 
-	max = 2;
+	max = hdspm->is_aes32 ? 9 : 2;
 
 	if (!snd_hdspm_use_is_exclusive(hdspm))
 		return -EBUSY;
@@ -1542,40 +1734,64 @@
 
 static int hdspm_autosync_ref(struct hdspm * hdspm)
 {
-	/* This looks at the autosync selected sync reference */
-	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-
-	switch (status2 & HDSPM_SelSyncRefMask) {
-
-	case HDSPM_SelSyncRef_WORD:
-		return HDSPM_AUTOSYNC_FROM_WORD;
-
-	case HDSPM_SelSyncRef_MADI:
-		return HDSPM_AUTOSYNC_FROM_MADI;
+	if (hdspm->is_aes32) {
+		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		unsigned int syncref = (status >> HDSPM_AES32_syncref_bit) & 0xF;
+		if (syncref == 0)
+			return HDSPM_AES32_AUTOSYNC_FROM_WORD;
+		if (syncref <= 8)
+			return syncref;
+		return HDSPM_AES32_AUTOSYNC_FROM_NONE;
+	} else {
+		/* This looks at the autosync selected sync reference */
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 
-	case HDSPM_SelSyncRef_NVALID:
-		return HDSPM_AUTOSYNC_FROM_NONE;
+		switch (status2 & HDSPM_SelSyncRefMask) {
+		case HDSPM_SelSyncRef_WORD:
+			return HDSPM_AUTOSYNC_FROM_WORD;
+		case HDSPM_SelSyncRef_MADI:
+			return HDSPM_AUTOSYNC_FROM_MADI;
+		case HDSPM_SelSyncRef_NVALID:
+			return HDSPM_AUTOSYNC_FROM_NONE;
+		default:
+			return 0;
+		}
 
-	default:
 		return 0;
 	}
-
-	return 0;
 }
 
 static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "WordClock", "MADI", "None" };
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+	if (hdspm->is_aes32) {
+		static char *texts[] = { "WordClock", "AES1", "AES2", "AES3",
+			"AES4",	"AES5", "AES6", "AES7", "AES8", "None"};
+
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
+		uinfo->value.enumerated.items = 10;
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	}
+	else
+	{
+		static char *texts[] = { "WordClock", "MADI", "None" };
+
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
+		uinfo->value.enumerated.items = 3;
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	}
 	return 0;
 }
 
@@ -1787,45 +2003,376 @@
   .put = snd_hdspm_put_safe_mode \
 }
 
-static int hdspm_safe_mode(struct hdspm * hdspm)
+static int hdspm_safe_mode(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
+}
+
+static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_AutoInp;
+	else
+		hdspm->control_register &= ~HDSPM_AutoInp;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_safe_mode(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_safe_mode(hdspm);
+	hdspm_set_safe_mode(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_EMPHASIS(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_emphasis, \
+  .get = snd_hdspm_get_emphasis, \
+  .put = snd_hdspm_put_emphasis \
+}
+
+static int hdspm_emphasis(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_Emphasis) ? 1 : 0;
+}
+
+static int hdspm_set_emphasis(struct hdspm * hdspm, int emp)
+{
+	if (emp)
+		hdspm->control_register |= HDSPM_Emphasis;
+	else
+		hdspm->control_register &= ~HDSPM_Emphasis;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_emphasis(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_emphasis(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_emphasis(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_emphasis(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_emphasis(hdspm);
+	hdspm_set_emphasis(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_DOLBY(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_dolby, \
+  .get = snd_hdspm_get_dolby, \
+  .put = snd_hdspm_put_dolby \
+}
+
+static int hdspm_dolby(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_Dolby) ? 1 : 0;
+}
+
+static int hdspm_set_dolby(struct hdspm * hdspm, int dol)
+{
+	if (dol)
+		hdspm->control_register |= HDSPM_Dolby;
+	else
+		hdspm->control_register &= ~HDSPM_Dolby;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_dolby(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_dolby(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_dolby(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_dolby(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_dolby(hdspm);
+	hdspm_set_dolby(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_PROFESSIONAL(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_professional, \
+  .get = snd_hdspm_get_professional, \
+  .put = snd_hdspm_put_professional \
+}
+
+static int hdspm_professional(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_Professional) ? 1 : 0;
+}
+
+static int hdspm_set_professional(struct hdspm * hdspm, int dol)
+{
+	if (dol)
+		hdspm->control_register |= HDSPM_Professional;
+	else
+		hdspm->control_register &= ~HDSPM_Professional;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_professional(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_professional(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_professional(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_professional(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_professional(hdspm);
+	hdspm_set_professional(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_INPUT_SELECT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_input_select, \
+  .get = snd_hdspm_get_input_select, \
+  .put = snd_hdspm_put_input_select \
+}
+
+static int hdspm_input_select(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
+}
+
+static int hdspm_set_input_select(struct hdspm * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_InputSelect0;
+	else
+		hdspm->control_register &= ~HDSPM_InputSelect0;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "optical", "coaxial" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_input_select(hdspm);
+	hdspm_set_input_select(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_DS_WIRE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_ds_wire, \
+  .get = snd_hdspm_get_ds_wire, \
+  .put = snd_hdspm_put_ds_wire \
+}
+
+static int hdspm_ds_wire(struct hdspm * hdspm)
 {
-	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
+	return (hdspm->control_register & HDSPM_DS_DoubleWire) ? 1 : 0;
 }
 
-static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
+static int hdspm_set_ds_wire(struct hdspm * hdspm, int ds)
 {
-	if (out)
-		hdspm->control_register |= HDSPM_AutoInp;
+	if (ds)
+		hdspm->control_register |= HDSPM_DS_DoubleWire;
 	else
-		hdspm->control_register &= ~HDSPM_AutoInp;
+		hdspm->control_register &= ~HDSPM_DS_DoubleWire;
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
 	return 0;
 }
 
-static int snd_hdspm_info_safe_mode(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_info *uinfo)
+static int snd_hdspm_info_ds_wire(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	static char *texts[] = { "Single", "Double" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
 	return 0;
 }
 
-static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
+static int snd_hdspm_get_ds_wire(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
+	ucontrol->value.enumerated.item[0] = hdspm_ds_wire(hdspm);
 	spin_unlock_irq(&hdspm->lock);
 	return 0;
 }
 
-static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
+static int snd_hdspm_put_ds_wire(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
@@ -1835,45 +2382,56 @@
 		return -EBUSY;
 	val = ucontrol->value.integer.value[0] & 1;
 	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_safe_mode(hdspm);
-	hdspm_set_safe_mode(hdspm, val);
+	change = (int) val != hdspm_ds_wire(hdspm);
+	hdspm_set_ds_wire(hdspm, val);
 	spin_unlock_irq(&hdspm->lock);
 	return change;
 }
 
-#define HDSPM_INPUT_SELECT(xname, xindex) \
+#define HDSPM_QS_WIRE(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
-  .info = snd_hdspm_info_input_select, \
-  .get = snd_hdspm_get_input_select, \
-  .put = snd_hdspm_put_input_select \
+  .info = snd_hdspm_info_qs_wire, \
+  .get = snd_hdspm_get_qs_wire, \
+  .put = snd_hdspm_put_qs_wire \
 }
 
-static int hdspm_input_select(struct hdspm * hdspm)
+static int hdspm_qs_wire(struct hdspm * hdspm)
 {
-	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
+	if (hdspm->control_register & HDSPM_QS_DoubleWire)
+		return 1;
+	if (hdspm->control_register & HDSPM_QS_QuadWire)
+		return 2;
+	return 0;
 }
 
-static int hdspm_set_input_select(struct hdspm * hdspm, int out)
+static int hdspm_set_qs_wire(struct hdspm * hdspm, int mode)
 {
-	if (out)
-		hdspm->control_register |= HDSPM_InputSelect0;
-	else
-		hdspm->control_register &= ~HDSPM_InputSelect0;
+	hdspm->control_register &= ~(HDSPM_QS_DoubleWire | HDSPM_QS_QuadWire);
+	switch (mode) {
+	case 0:
+		break;
+	case 1:
+		hdspm->control_register |= HDSPM_QS_DoubleWire;
+		break;
+	case 2:
+		hdspm->control_register |= HDSPM_QS_QuadWire;
+		break;
+	}
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
 	return 0;
 }
 
-static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
+static int snd_hdspm_info_qs_wire(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "optical", "coaxial" };
+	static char *texts[] = { "Single", "Double", "Quad" };
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
+	uinfo->value.enumerated.items = 3;
 
 	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
 		uinfo->value.enumerated.item =
@@ -1884,30 +2442,34 @@
 	return 0;
 }
 
-static int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,
+static int snd_hdspm_get_qs_wire(struct snd_kcontrol *kcontrol,
 				      struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
+	ucontrol->value.enumerated.item[0] = hdspm_qs_wire(hdspm);
 	spin_unlock_irq(&hdspm->lock);
 	return 0;
 }
 
-static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
+static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
 				      struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
-	unsigned int val;
+	int val;
 
 	if (!snd_hdspm_use_is_exclusive(hdspm))
 		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
+	val = ucontrol->value.integer.value[0];
+	if (val < 0)
+		val = 0;
+	if (val > 2)
+		val = 2;
 	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_input_select(hdspm);
-	hdspm_set_input_select(hdspm, val);
+	change = (int) val != hdspm_qs_wire(hdspm);
+	hdspm_set_qs_wire(hdspm, val);
 	spin_unlock_irq(&hdspm->lock);
 	return change;
 }
@@ -2135,14 +2697,24 @@
 
 static int hdspm_wc_sync_check(struct hdspm * hdspm)
 {
-	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-	if (status2 & HDSPM_wcLock) {
-		if (status2 & HDSPM_wcSync)
+	if (hdspm->is_aes32) {
+		int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		if (status & HDSPM_AES32_wcLock) {
+			/* I don't know how to differenciate sync from lock.
+			   Doing as if sync for now */
 			return 2;
-		else
-			return 1;
+		}
+		return 0;
+	} else {
+		int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		if (status2 & HDSPM_wcLock) {
+			if (status2 & HDSPM_wcSync)
+				return 2;
+			else
+				return 1;
+		}
+		return 0;
 	}
-	return 0;
 }
 
 static int snd_hdspm_get_wc_sync_check(struct snd_kcontrol *kcontrol,
@@ -2188,9 +2760,43 @@
 }
 
 
+#define HDSPM_AES_SYNC_CHECK(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_sync_check, \
+  .get = snd_hdspm_get_aes_sync_check \
+}
+
+static int hdspm_aes_sync_check(struct hdspm * hdspm, int idx)
+{
+	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	if (status2 & (HDSPM_LockAES >> idx)) {
+		/* I don't know how to differenciate sync from lock.
+		   Doing as if sync for now */
+		return 2;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_aes_sync_check(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	int offset;
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	offset = ucontrol->id.index - 1;
+	if (offset < 0 || offset >= 8)
+		return -EINVAL;
+
+	ucontrol->value.enumerated.item[0] =
+		hdspm_aes_sync_check(hdspm, offset);
+	return 0;
+}
 
 
-static struct snd_kcontrol_new snd_hdspm_controls[] = {
+static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 
 	HDSPM_MIXER("Mixer", 0),
 /* 'Sample Clock Source' complies with the alsa control naming scheme */
@@ -2211,6 +2817,29 @@
 	HDSPM_INPUT_SELECT("Input Select", 0),
 };
 
+static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
+
+	HDSPM_MIXER("Mixer", 0),
+/* 'Sample Clock Source' complies with the alsa control naming scheme */
+	HDSPM_CLOCK_SOURCE("Sample Clock Source", 0),
+
+	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
+	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
+	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+/* 'External Rate' complies with the alsa control naming scheme */
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_WC_SYNC_CHECK("Word Clock Lock Status", 0),
+/*	HDSPM_AES_SYNC_CHECK("AES Lock Status", 0),*/ /* created in snd_hdspm_create_controls() */
+	HDSPM_LINE_OUT("Line Out", 0),
+	HDSPM_EMPHASIS("Emphasis", 0),
+	HDSPM_DOLBY("Non Audio", 0),
+	HDSPM_PROFESSIONAL("Professional", 0),
+	HDSPM_C_TMS("Clear Track Marker", 0),
+	HDSPM_DS_WIRE("Double Speed Wire Mode", 0),
+	HDSPM_QS_WIRE("Quad Speed Wire Mode", 0),
+};
+
 static struct snd_kcontrol_new snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
 
 
@@ -2245,20 +2874,40 @@
 	struct snd_kcontrol *kctl;
 
 	/* add control list first */
-
-	for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls); idx++) {
-		if ((err =
-		     snd_ctl_add(card, kctl =
-				 snd_ctl_new1(&snd_hdspm_controls[idx],
-					      hdspm))) < 0) {
-			return err;
+	if (hdspm->is_aes32) {
+		struct snd_kcontrol_new aes_sync_ctl =
+			HDSPM_AES_SYNC_CHECK("AES Lock Status", 0);
+
+		for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls_aes32);
+		     idx++) {
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&snd_hdspm_controls_aes32[idx],
+						       hdspm));
+			if (err < 0)
+				return err;
+		}
+		for (idx = 1; idx <= 8; idx++) {
+			aes_sync_ctl.index = idx;
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&aes_sync_ctl, hdspm));
+			if (err < 0)
+				return err;
+		}
+	} else {
+		for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls_madi);
+		     idx++) {
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&snd_hdspm_controls_madi[idx],
+						       hdspm));
+			if (err < 0)
+				return err;
 		}
 	}
 
 	/* Channel playback mixer as default control 
-	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats too big for any alsamixer
-	   they are accesible via special IOCTL on hwdep
-	   and the mixer 2dimensional mixer control */
+Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats too big for any alsamixer
+they are accesible via special IOCTL on hwdep
+and the mixer 2dimensional mixer control */
 
 	snd_hdspm_playback_mixer.name = "Chn";
 	limit = HDSPM_MAX_CHANNELS;
@@ -2289,7 +2938,8 @@
  ------------------------------------------------------------*/
 
 static void
-snd_hdspm_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffer)
+snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
+			 struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
 	unsigned int status;
@@ -2420,11 +3070,10 @@
 		clock_source = "Error";
 	}
 	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
-	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster))
 		system_clock_mode = "Slave";
-	} else {
+	else
 		system_clock_mode = "Master";
-	}
 	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
 
 	switch (hdspm_pref_sync_ref(hdspm)) {
@@ -2484,13 +3133,213 @@
 	snd_iprintf(buffer, "\n");
 }
 
+static void
+snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
+			  struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
+	unsigned int status;
+	unsigned int status2;
+	unsigned int timecode;
+	int pref_syncref;
+	char *autosync_ref;
+	char *system_clock_mode;
+	char *clock_source;
+	int x;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
+
+	snd_iprintf(buffer, "%s (Card #%d) Rev.%x\n",
+		    hdspm->card_name, hdspm->card->number + 1,
+		    hdspm->firmware_rev);
+
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+		    hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
+
+	snd_iprintf(buffer, "--- System ---\n");
+
+	snd_iprintf(buffer,
+		    "IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
+		    status & HDSPM_audioIRQPending,
+		    (status & HDSPM_midi0IRQPending) ? 1 : 0,
+		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
+		    hdspm->irq_count);
+	snd_iprintf(buffer,
+		    "HW pointer: id = %d, rawptr = %d (%d->%d) estimated= %ld (bytes)\n",
+		    ((status & HDSPM_BufferID) ? 1 : 0),
+		    (status & HDSPM_BufferPositionMask),
+		    (status & HDSPM_BufferPositionMask) % (2 *
+							   (int)hdspm->
+							   period_bytes),
+		    ((status & HDSPM_BufferPositionMask) -
+		     64) % (2 * (int)hdspm->period_bytes),
+		    (long) hdspm_hw_pointer(hdspm) * 4);
+
+	snd_iprintf(buffer,
+		    "MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
+		    hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
+	snd_iprintf(buffer,
+		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, status2=0x%x, timecode=0x%x\n",
+		    hdspm->control_register, hdspm->control2_register,
+		    status, status2, timecode);
+
+	snd_iprintf(buffer, "--- Settings ---\n");
+
+	x = 1 << (6 +
+		  hdspm_decode_latency(hdspm->
+				       control_register &
+				       HDSPM_LatencyMask));
+
+	snd_iprintf(buffer,
+		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
+		    x, (unsigned long) hdspm->period_bytes);
+
+	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
+		    (hdspm->
+		     control_register & HDSPM_LineOut) ? "on " : "off",
+		    (hdspm->precise_ptr) ? "on" : "off");
+
+	snd_iprintf(buffer,
+		    "ClearTrackMarker %s, Emphasis %s, Dolby %s\n",
+		    (hdspm->
+		     control_register & HDSPM_clr_tms) ? "on" : "off",
+		    (hdspm->
+		     control_register & HDSPM_Emphasis) ? "on" : "off",
+		    (hdspm->
+		     control_register & HDSPM_Dolby) ? "on" : "off");
+
+	switch (hdspm_clock_source(hdspm)) {
+	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
+		clock_source = "AutoSync";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
+		clock_source = "Internal 32 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
+		clock_source = "Internal 44.1 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
+		clock_source = "Internal 48 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
+		clock_source = "Internal 64 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
+		clock_source = "Internal 88.2 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
+		clock_source = "Internal 96 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ:
+		clock_source = "Internal 128 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ:
+		clock_source = "Internal 176.4 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ:
+		clock_source = "Internal 192 kHz";
+		break;
+	default:
+		clock_source = "Error";
+	}
+	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster))
+		system_clock_mode = "Slave";
+	else
+		system_clock_mode = "Master";
+	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
+
+	pref_syncref = hdspm_pref_sync_ref(hdspm);
+	if (pref_syncref == 0)
+		snd_iprintf(buffer, "Preferred Sync Reference: Word Clock\n");
+	else
+		snd_iprintf(buffer, "Preferred Sync Reference: AES%d\n",
+				pref_syncref);
+
+	snd_iprintf(buffer, "System Clock Frequency: %d\n",
+		    hdspm->system_sample_rate);
+
+	snd_iprintf(buffer, "Double speed: %s\n",
+			hdspm->control_register & HDSPM_DS_DoubleWire?
+			"Double wire" : "Single wire");
+	snd_iprintf(buffer, "Quad speed: %s\n",
+			hdspm->control_register & HDSPM_QS_DoubleWire?
+			"Double wire" :
+			hdspm->control_register & HDSPM_QS_QuadWire?
+			"Quad wire" : "Single wire");
+
+	snd_iprintf(buffer, "--- Status:\n");
+
+	snd_iprintf(buffer, "Word: %s  Frequency: %d\n",
+			(status & HDSPM_AES32_wcLock)? "Sync   " : "No Lock",
+			HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));
+
+	for (x = 0; x < 8; x++) {
+		snd_iprintf(buffer, "AES%d: %s  Frequency: %d\n",
+				x+1,
+				(status2 & (HDSPM_LockAES >> x))? "Sync   ": "No Lock",
+				HDSPM_bit2freq((timecode >> (4*x)) & 0xF));
+	}
+
+	switch (hdspm_autosync_ref(hdspm)) {
+	case HDSPM_AES32_AUTOSYNC_FROM_NONE: autosync_ref="None"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_WORD: autosync_ref="Word Clock"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES1: autosync_ref="AES1"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES2: autosync_ref="AES2"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES3: autosync_ref="AES3"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES4: autosync_ref="AES4"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES5: autosync_ref="AES5"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES6: autosync_ref="AES6"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES7: autosync_ref="AES7"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES8: autosync_ref="AES8"; break;
+	default: autosync_ref = "---"; break;
+	}
+	snd_iprintf(buffer, "AutoSync ref = %s\n", autosync_ref);
+
+	snd_iprintf(buffer, "\n");
+}
+
+#ifdef CONFIG_SND_DEBUG
+static void
+snd_hdspm_proc_read_debug(struct snd_info_entry * entry,
+			  struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = (struct hdspm *)entry->private_data;
+
+	int j,i;
+
+	for (i = 0; i < 256 /* 1024*64 */; i += j)
+	{
+		snd_iprintf(buffer, "0x%08X: ", i);
+		for (j = 0; j < 16; j += 4)
+			snd_iprintf(buffer, "%08X ", hdspm_read(hdspm, i + j));
+		snd_iprintf(buffer, "\n");
+	}
+}
+#endif
+
+
+
 static void __devinit snd_hdspm_proc_init(struct hdspm * hdspm)
 {
 	struct snd_info_entry *entry;
 
 	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
 		snd_info_set_text_ops(entry, hdspm,
-				      snd_hdspm_proc_read);
+				      hdspm->is_aes32 ?
+				      snd_hdspm_proc_read_aes32 :
+				      snd_hdspm_proc_read_madi);
+#ifdef CONFIG_SND_DEBUG
+	/* debug file to read all hdspm registers */
+	if (!snd_card_proc_new(hdspm->card, "debug", &entry))
+		snd_info_set_text_ops(entry, hdspm,
+				snd_hdspm_proc_read_debug);
+#endif
 }
 
 /*------------------------------------------------------------
@@ -2507,13 +3356,20 @@
 
 	/* set defaults:       */
 
-	hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
-	    hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
-	    HDSPM_InputCoaxial |	/* Input Coax not Optical */
-	    HDSPM_SyncRef_MADI |	/* Madi is syncclock */
-	    HDSPM_LineOut |	/* Analog output in */
-	    HDSPM_TX_64ch |	/* transmit in 64ch mode */
-	    HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
+	if (hdspm->is_aes32)
+		hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+			HDSPM_SyncRef0 |	/* AES1 is syncclock */
+			HDSPM_LineOut |	/* Analog output in */
+			HDSPM_Professional;  /* Professional mode */
+	else
+		hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+			HDSPM_InputCoaxial |	/* Input Coax not Optical */
+			HDSPM_SyncRef_MADI |	/* Madi is syncclock */
+			HDSPM_LineOut |	/* Analog output in */
+			HDSPM_TX_64ch |	/* transmit in 64ch mode */
+			HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
 
 	/* ! HDSPM_Frequency0|HDSPM_Frequency1 = 44.1khz */
 	/* !  HDSPM_DoubleSpeed HDSPM_QuadSpeed = normal speed */
@@ -2823,6 +3679,8 @@
 
 		hdspm->playback_buffer =
 		    (unsigned char *) substream->runtime->dma_area;
+		snd_printdd("Allocated sample buffer for playback at %p\n",
+				hdspm->playback_buffer);
 	} else {
 		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferIn,
 				params_channels(params));
@@ -2832,7 +3690,15 @@
 
 		hdspm->capture_buffer =
 		    (unsigned char *) substream->runtime->dma_area;
+		snd_printdd("Allocated sample buffer for capture at %p\n",
+				hdspm->capture_buffer);
 	}
+	/*
+	   snd_printdd("Allocated sample buffer for %s at 0x%08X\n",
+	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+	   "playback" : "capture",
+	   snd_pcm_sgbuf_get_addr(sgbuf, 0));
+	 */
 	return 0;
 }
 
@@ -2983,9 +3849,10 @@
 		  SNDRV_PCM_RATE_44100 |
 		  SNDRV_PCM_RATE_48000 |
 		  SNDRV_PCM_RATE_64000 |
-		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+		  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000 ),
 	.rate_min = 32000,
-	.rate_max = 96000,
+	.rate_max = 192000,
 	.channels_min = 1,
 	.channels_max = HDSPM_MAX_CHANNELS,
 	.buffer_bytes_max =
@@ -3007,9 +3874,10 @@
 		  SNDRV_PCM_RATE_44100 |
 		  SNDRV_PCM_RATE_48000 |
 		  SNDRV_PCM_RATE_64000 |
-		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+		  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000),
 	.rate_min = 32000,
-	.rate_max = 96000,
+	.rate_max = 192000,
 	.channels_min = 1,
 	.channels_max = HDSPM_MAX_CHANNELS,
 	.buffer_bytes_max =
@@ -3316,7 +4184,8 @@
 
 	pcm = hdspm->pcm;
 
-	wanted = HDSPM_DMA_AREA_BYTES + 4096;	/* dont know why, but it works */
+/*	wanted = HDSPM_DMA_AREA_BYTES + 4096;*/	/* dont know why, but it works */
+	wanted = HDSPM_DMA_AREA_BYTES;
 
 	if ((err =
 	     snd_pcm_lib_preallocate_pages_for_all(pcm,
@@ -3468,9 +4337,16 @@
 	pci_read_config_word(hdspm->pci,
 			     PCI_CLASS_REVISION, &hdspm->firmware_rev);
 
-	strcpy(card->driver, "HDSPM");
+	hdspm->is_aes32 = (hdspm->firmware_rev >= HDSPM_AESREVISION);
+
 	strcpy(card->mixername, "Xilinx FPGA");
-	hdspm->card_name = "RME HDSPM MADI";
+	if (hdspm->is_aes32) {
+		strcpy(card->driver, "HDSPAES32");
+		hdspm->card_name = "RME HDSPM AES32";
+	} else {
+		strcpy(card->driver, "HDSPM");
+		hdspm->card_name = "RME HDSPM MADI";
+	}
 
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
@@ -3594,6 +4470,8 @@
 	hdspm->dev = dev;
 	hdspm->pci = pci;
 
+	snd_card_set_dev(card, &pci->dev);
+
 	if ((err =
 	     snd_hdspm_create(card, hdspm, precise_ptr[dev],
 			      enable_monitor[dev])) < 0) {
--- linux-2.6.18.noarch/sound/pci/rme9652/rme9652.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/rme9652/rme9652.c	2007-06-05 17:47:52.000000000 -0400
@@ -1827,8 +1827,8 @@
 
 	/* Align to bus-space 64K boundary */
 
-	cb_bus = (rme9652->capture_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
-	pb_bus = (rme9652->playback_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
+	cb_bus = ALIGN(rme9652->capture_dma_buf.addr, 0x10000ul);
+	pb_bus = ALIGN(rme9652->playback_dma_buf.addr, 0x10000ul);
 
 	/* Tell the card where it is */
 
--- linux-2.6.18.noarch/sound/pci/rme9652/hdsp.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/rme9652/hdsp.c	2007-06-05 17:47:52.000000000 -0400
@@ -80,6 +80,7 @@
 /* Write registers. These are defined as byte-offsets from the iobase value.
  */
 #define HDSP_resetPointer               0
+#define HDSP_freqReg			0
 #define HDSP_outputBufferAddress	32
 #define HDSP_inputBufferAddress		36
 #define HDSP_controlRegister		64
@@ -469,6 +470,7 @@
 	struct pci_dev       *pci;
 	struct snd_kcontrol *spdif_ctl;
         unsigned short        mixer_matrix[HDSP_MATRIX_MIXER_SIZE];
+	unsigned int          dds_value; /* last value written to freq register */
 };
 
 /* These tables map the ALSA channels 1..N to the channels that we
@@ -598,6 +600,7 @@
 		return (64 * out) + (32 + (in));
 	case 0x96:
 	case 0x97:
+	case 0x98:
 		return (32 * out) + (16 + (in));
 	default:
 		return (52 * out) + (26 + (in));
@@ -611,6 +614,7 @@
 		return (64 * out) + in;
 	case 0x96:
 	case 0x97:
+	case 0x98:
 		return (32 * out) + in;
 	default:
 		return (52 * out) + in;
@@ -726,22 +730,36 @@
 }
 
 
-static int hdsp_check_for_firmware (struct hdsp *hdsp, int show_err)
+#ifdef HDSP_FW_LOADER
+static int __devinit hdsp_request_fw_loader(struct hdsp *hdsp);
+#endif
+
+static int hdsp_check_for_firmware (struct hdsp *hdsp, int load_on_demand)
 {
-	if (hdsp->io_type == H9652 || hdsp->io_type == H9632) return 0;
+	if (hdsp->io_type == H9652 || hdsp->io_type == H9632)
+		return 0;
 	if ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {
-		snd_printk(KERN_ERR "Hammerfall-DSP: firmware not present.\n");
 		hdsp->state &= ~HDSP_FirmwareLoaded;
-		if (! show_err)
+		if (! load_on_demand)
 			return -EIO;
+		snd_printk(KERN_ERR "Hammerfall-DSP: firmware not present.\n");
 		/* try to load firmware */
-		if (hdsp->state & HDSP_FirmwareCached) {
-			if (snd_hdsp_load_firmware_from_cache(hdsp) != 0)
-				snd_printk(KERN_ERR "Hammerfall-DSP: Firmware loading from cache failed, please upload manually.\n");
-		} else {
-			snd_printk(KERN_ERR "Hammerfall-DSP: No firmware loaded nor cached, please upload firmware.\n");
+		if (! (hdsp->state & HDSP_FirmwareCached)) {
+#ifdef HDSP_FW_LOADER
+			if (! hdsp_request_fw_loader(hdsp))
+				return 0;
+#endif
+			snd_printk(KERN_ERR
+				   "Hammerfall-DSP: No firmware loaded nor "
+				   "cached, please upload firmware.\n");
+			return -EIO;
+		}
+		if (snd_hdsp_load_firmware_from_cache(hdsp) != 0) {
+			snd_printk(KERN_ERR
+				   "Hammerfall-DSP: Firmware loading from "
+				   "cache failed, please upload manually.\n");
+			return -EIO;
 		}
-		return -EIO;
 	}
 	return 0;
 }
@@ -924,6 +942,11 @@
 static void hdsp_reset_hw_pointer(struct hdsp *hdsp)
 {
 	hdsp_write (hdsp, HDSP_resetPointer, 0);
+	if (hdsp->io_type == H9632 && hdsp->firmware_rev >= 152)
+		/* HDSP_resetPointer = HDSP_freqReg, which is strange and
+		 * requires (?) to write again DDS value after a reset pointer
+		 * (at least, it works like this) */
+		hdsp_write (hdsp, HDSP_freqReg, hdsp->dds_value);
 }
 
 static void hdsp_start_audio(struct hdsp *s)
@@ -968,6 +991,30 @@
 	return 0;
 }
 
+static void hdsp_set_dds_value(struct hdsp *hdsp, int rate)
+{
+	u64 n;
+	u32 r;
+	
+	if (rate >= 112000)
+		rate /= 4;
+	else if (rate >= 56000)
+		rate /= 2;
+
+	/* RME says n = 104857600000000, but in the windows MADI driver, I see:
+//	return 104857600000000 / rate; // 100 MHz
+	return 110100480000000 / rate; // 105 MHz
+        */	   
+	n = 104857600000000ULL;  /*  =  2^20 * 10^8 */
+	div64_32(&n, rate, &r);
+	/* n should be less than 2^32 for being written to FREQ register */
+	snd_assert((n >> 32) == 0);
+	/* HDSP_freqReg and HDSP_resetPointer are the same, so keep the DDS
+	   value to write it after a reset */
+	hdsp->dds_value = n;
+	hdsp_write(hdsp, HDSP_freqReg, hdsp->dds_value);
+}
+
 static int hdsp_set_rate(struct hdsp *hdsp, int rate, int called_internally)
 {
 	int reject_if_open = 0;
@@ -1076,6 +1123,10 @@
 	hdsp->control_register |= rate_bits;
 	hdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);
 
+	/* For HDSP9632 rev 152, need to set DDS value in FREQ register */
+	if (hdsp->io_type == H9632 && hdsp->firmware_rev >= 152)
+		hdsp_set_dds_value(hdsp, rate);
+
 	if (rate >= 128000) {
 		hdsp->channel_map = channel_map_H9632_qs;
 	} else if (rate > 48000) {
@@ -3181,8 +3232,16 @@
 				return;
 			}
 		} else {
-			snd_iprintf(buffer, "No firmware loaded nor cached, please upload firmware.\n");
-			return;
+			int err = -EINVAL;
+#ifdef HDSP_FW_LOADER
+			err = hdsp_request_fw_loader(hdsp);
+#endif
+			if (err < 0) {
+				snd_iprintf(buffer,
+					    "No firmware loaded nor cached, "
+					    "please upload firmware.\n");
+				return;
+			}
 		}
 	}
 	
@@ -3494,8 +3553,8 @@
 
 	/* Align to bus-space 64K boundary */
 
-	cb_bus = (hdsp->capture_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
-	pb_bus = (hdsp->playback_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
+	cb_bus = ALIGN(hdsp->capture_dma_buf.addr, 0x10000ul);
+	pb_bus = ALIGN(hdsp->playback_dma_buf.addr, 0x10000ul);
 
 	/* Tell the card where it is */
 
@@ -3851,7 +3910,7 @@
 	if (hdsp_check_for_iobox (hdsp))
 		return -EIO;
 
-	if (hdsp_check_for_firmware(hdsp, 1))
+	if (hdsp_check_for_firmware(hdsp, 0)) /* no auto-loading in trigger */
 		return -EIO;
 
 	spin_lock(&hdsp->lock);
@@ -4918,8 +4977,9 @@
 	}
 
 	hdsp->irq = pci->irq;
-	hdsp->precise_ptr = 1;
+	hdsp->precise_ptr = 0;
 	hdsp->use_midi_tasklet = 1;
+	hdsp->dds_value = 0;
 
 	if ((err = snd_hdsp_initialize_memory(hdsp)) < 0)
 		return err;
--- linux-2.6.18.noarch/sound/pci/atiixp.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/atiixp.c	2007-06-05 17:47:00.000000000 -0400
@@ -45,6 +45,7 @@
 static int ac97_clock = 48000;
 static char *ac97_quirk;
 static int spdif_aclink = 1;
+static int ac97_codec = -1;
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for ATI IXP controller.");
@@ -54,6 +55,8 @@
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (default 48000Hz).");
 module_param(ac97_quirk, charp, 0444);
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
+module_param(ac97_codec, int, 0444);
+MODULE_PARM_DESC(ac97_codec, "Specify codec instead of probing.");
 module_param(spdif_aclink, bool, 0444);
 MODULE_PARM_DESC(spdif_aclink, "S/PDIF over AC-link.");
 
@@ -293,6 +296,10 @@
 
 MODULE_DEVICE_TABLE(pci, snd_atiixp_ids);
 
+static struct snd_pci_quirk atiixp_quirks[] __devinitdata = {
+	SND_PCI_QUIRK(0x15bd, 0x3100, "DFI RS482", 0),
+	{ } /* terminator */
+};
 
 /*
  * lowlevel functions
@@ -553,11 +560,33 @@
 	     ATI_REG_ISR_CODEC2_NOT_READY)
 #define CODEC_CHECK_BITS (ALL_CODEC_NOT_READY|ATI_REG_ISR_NEW_FRAME)
 
+static int ac97_probing_bugs(struct pci_dev *pci)
+{
+	const struct snd_pci_quirk *q;
+
+	q = snd_pci_quirk_lookup(pci, atiixp_quirks);
+	if (q) {
+		snd_printdd(KERN_INFO "Atiixp quirk for %s.  "
+			    "Forcing codec %d\n", q->name, q->value);
+		return q->value;
+	}
+	/* this hardware doesn't need workarounds.  Probe for codec */
+	return -1;
+}
+
 static int snd_atiixp_codec_detect(struct atiixp *chip)
 {
 	int timeout;
 
 	chip->codec_not_ready_bits = 0;
+	if (ac97_codec == -1)
+		ac97_codec = ac97_probing_bugs(chip->pci);
+	if (ac97_codec >= 0) {
+		chip->codec_not_ready_bits |= 
+			CODEC_CHECK_BITS ^ (1 << (ac97_codec + 10));
+		return 0;
+	}
+
 	atiixp_write(chip, IER, CODEC_CHECK_BITS);
 	/* wait for the interrupts */
 	timeout = 50;
@@ -1396,7 +1425,7 @@
 		ac97.private_data = chip;
 		ac97.pci = chip->pci;
 		ac97.num = i;
-		ac97.scaps = AC97_SCAP_SKIP_MODEM;
+		ac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;
 		if (! chip->spdif_over_aclink)
 			ac97.scaps |= AC97_SCAP_NO_SPDIF;
 		if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i])) < 0) {
@@ -1442,9 +1471,9 @@
 	snd_atiixp_aclink_down(chip);
 	snd_atiixp_chip_stop(chip);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1454,9 +1483,14 @@
 	struct atiixp *chip = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "atiixp: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_atiixp_aclink_reset(chip);
--- linux-2.6.18.noarch/sound/pci/vx222/vx222.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/vx222/vx222.c	2007-06-05 17:48:07.000000000 -0400
@@ -26,6 +26,7 @@
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/initval.h>
+#include <sound/tlv.h>
 #include "vx222.h"
 
 #define CARD_NAME "VX222"
@@ -72,6 +73,9 @@
 /*
  */
 
+static const DECLARE_TLV_DB_SCALE(db_scale_old_vol, -11350, 50, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_akm, -7350, 50, 0);
+
 static struct snd_vx_hardware vx222_old_hw = {
 
 	.name = "VX222/Old",
@@ -81,6 +85,7 @@
 	.num_ins = 1,
 	.num_outs = 1,
 	.output_level_max = VX_ANALOG_OUT_LEVEL_MAX,
+	.output_level_db_scale = db_scale_old_vol,
 };
 
 static struct snd_vx_hardware vx222_v2_hw = {
@@ -92,6 +97,7 @@
 	.num_ins = 1,
 	.num_outs = 1,
 	.output_level_max = VX2_AKM_LEVEL_MAX,
+	.output_level_db_scale = db_scale_akm,
 };
 
 static struct snd_vx_hardware vx222_mic_hw = {
@@ -103,6 +109,7 @@
 	.num_ins = 1,
 	.num_outs = 1,
 	.output_level_max = VX2_AKM_LEVEL_MAX,
+	.output_level_db_scale = db_scale_akm,
 };
 
 
@@ -259,9 +266,9 @@
 	int err;
 
 	err = snd_vx_suspend(&vx->core, state);
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return err;
 }
 
@@ -270,9 +277,14 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_vx222 *vx = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "vx222: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 	return snd_vx_resume(&vx->core);
 }
--- linux-2.6.18.noarch/sound/pci/vx222/vx222_ops.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/vx222/vx222_ops.c	2007-06-05 17:48:07.000000000 -0400
@@ -28,6 +28,7 @@
 
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <asm/io.h>
 #include "vx222.h"
 
@@ -845,6 +846,8 @@
 
 #define MIC_LEVEL_MAX	0xff
 
+static const DECLARE_TLV_DB_SCALE(db_scale_mic, -6450, 50, 0);
+
 /*
  * controls API for input levels
  */
@@ -922,18 +925,24 @@
 
 static struct snd_kcontrol_new vx_control_input_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Capture Volume",
 	.info =		vx_input_level_info,
 	.get =		vx_input_level_get,
 	.put =		vx_input_level_put,
+	.tlv = { .p = db_scale_mic },
 };
 
 static struct snd_kcontrol_new vx_control_mic_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Mic Capture Volume",
 	.info =		vx_mic_level_info,
 	.get =		vx_mic_level_get,
 	.put =		vx_mic_level_put,
+	.tlv = { .p = db_scale_mic },
 };
 
 /*
--- linux-2.6.18.noarch/sound/pci/es1968.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/es1968.c	2007-06-05 17:47:00.000000000 -0400
@@ -432,46 +432,6 @@
 #define ESM_MODE_PLAY		0
 #define ESM_MODE_CAPTURE	1
 
-/* acpi states */
-enum {
-	ACPI_D0=0,
-	ACPI_D1,
-	ACPI_D2,
-	ACPI_D3
-};
-
-/* bits in the acpi masks */
-#define ACPI_12MHZ	( 1 << 15)
-#define ACPI_24MHZ	( 1 << 14)
-#define ACPI_978	( 1 << 13)
-#define ACPI_SPDIF	( 1 << 12)
-#define ACPI_GLUE	( 1 << 11)
-#define ACPI__10	( 1 << 10) /* reserved */
-#define ACPI_PCIINT	( 1 << 9)
-#define ACPI_HV		( 1 << 8) /* hardware volume */
-#define ACPI_GPIO	( 1 << 7)
-#define ACPI_ASSP	( 1 << 6)
-#define ACPI_SB		( 1 << 5) /* sb emul */
-#define ACPI_FM		( 1 << 4) /* fm emul */
-#define ACPI_RB		( 1 << 3) /* ringbus / aclink */
-#define ACPI_MIDI	( 1 << 2) 
-#define ACPI_GP		( 1 << 1) /* game port */
-#define ACPI_WP		( 1 << 0) /* wave processor */
-
-#define ACPI_ALL	(0xffff)
-#define ACPI_SLEEP	(~(ACPI_SPDIF|ACPI_ASSP|ACPI_SB|ACPI_FM| \
-			ACPI_MIDI|ACPI_GP|ACPI_WP))
-#define ACPI_NONE	(ACPI__10)
-
-/* these masks indicate which units we care about at
-	which states */
-static u16 acpi_state_mask[] = {
-	[ACPI_D0] = ACPI_ALL,
-	[ACPI_D1] = ACPI_SLEEP,
-	[ACPI_D2] = ACPI_SLEEP,
-	[ACPI_D3] = ACPI_NONE
-};
-
 
 /* APU use in the driver */
 enum snd_enum_apu_type {
@@ -1377,7 +1337,7 @@
 	struct esm_memory *buf;
 	struct list_head *p;
 	
-	size = ((size + ESM_MEM_ALIGN - 1) / ESM_MEM_ALIGN) * ESM_MEM_ALIGN;
+	size = ALIGN(size, ESM_MEM_ALIGN);
 	mutex_lock(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
 		buf = list_entry(p, struct esm_memory, list);
@@ -1905,7 +1865,7 @@
 	/* Figure out which volume control button was pushed,
 	   based on differences from the default register
 	   values. */
-	x = inb(chip->io_port + 0x1c);
+	x = inb(chip->io_port + 0x1c) & 0xee;
 	/* Reset the volume control registers. */
 	outb(0x88, chip->io_port + 0x1c);
 	outb(0x88, chip->io_port + 0x1d);
@@ -1921,7 +1881,8 @@
 	/* FIXME: we can't call snd_ac97_* functions since here is in tasklet. */
 	spin_lock_irqsave(&chip->ac97_lock, flags);
 	val = chip->ac97->regs[AC97_MASTER];
-	if (x & 1) {
+	switch (x) {
+	case 0x88:
 		/* mute */
 		val ^= 0x8000;
 		chip->ac97->regs[AC97_MASTER] = val;
@@ -1929,26 +1890,31 @@
 		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_switch->id);
-	} else {
-		val &= 0x7fff;
-		if (((x>>1) & 7) > 4) {
-			/* volume up */
-			if ((val & 0xff) > 0)
-				val--;
-			if ((val & 0xff00) > 0)
-				val -= 0x0100;
-		} else {
-			/* volume down */
-			if ((val & 0xff) < 0x1f)
-				val++;
-			if ((val & 0xff00) < 0x1f00)
-				val += 0x0100;
-		}
+		break;
+	case 0xaa:
+		/* volume up */
+		if ((val & 0x7f) > 0)
+			val--;
+		if ((val & 0x7f00) > 0)
+			val -= 0x0100;
+		chip->ac97->regs[AC97_MASTER] = val;
+		outw(val, chip->io_port + ESM_AC97_DATA);
+		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
+		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &chip->master_volume->id);
+		break;
+	case 0x66:
+		/* volume down */
+		if ((val & 0x7f) < 0x1f)
+			val++;
+		if ((val & 0x7f00) < 0x1f00)
+			val += 0x0100;
 		chip->ac97->regs[AC97_MASTER] = val;
 		outw(val, chip->io_port + ESM_AC97_DATA);
 		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_volume->id);
+		break;
 	}
 	spin_unlock_irqrestore(&chip->ac97_lock, flags);
 }
@@ -2154,21 +2120,6 @@
 }
 
 /*
- * power management
- */
-static void snd_es1968_set_acpi(struct es1968 *chip, int state)
-{
-	u16 active_mask = acpi_state_mask[state];
-
-	pci_set_power_state(chip->pci, state);
-	/* make sure the units we care about are on 
-		XXX we might want to do this before state flipping? */
-	pci_write_config_word(chip->pci, 0x54, ~ active_mask);
-	pci_write_config_word(chip->pci, 0x56, ~ active_mask);
-}
-
-
-/*
  * initialize maestro chip
  */
 static void snd_es1968_chip_init(struct es1968 *chip)
@@ -2190,9 +2141,6 @@
 	 * IRQs.
 	 */
 	
-	/* do config work at full power */
-	snd_es1968_set_acpi(chip, ACPI_D0);
-
 	/* Config Reg A */
 	pci_read_config_word(pci, ESM_CONFIG_A, &w);
 
@@ -2391,9 +2339,10 @@
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	snd_es1968_bob_stop(chip);
-	snd_es1968_set_acpi(chip, ACPI_D3);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2407,9 +2356,16 @@
 		return 0;
 
 	/* restore all our config */
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "es1968: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
+
 	snd_es1968_chip_init(chip);
 
 	/* need to restore the base pointers.. */ 
@@ -2506,9 +2462,8 @@
 	}
 
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	snd_es1968_free_gameport(chip);
-	snd_es1968_set_acpi(chip, ACPI_D3);
 	chip->master_switch = NULL;
 	chip->master_volume = NULL;
 	pci_release_regions(chip->pci);
--- linux-2.6.18.noarch/sound/pci/ens1370.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/ens1370.c	2007-06-05 17:47:00.000000000 -0400
@@ -413,8 +413,6 @@
 	} u;
 
 	struct pci_dev *pci;
-	unsigned short subsystem_vendor_id;
-	unsigned short subsystem_device_id;
 	struct snd_card *card;
 	struct snd_pcm *pcm1;	/* DAC1/ADC PCM */
 	struct snd_pcm *pcm2;	/* DAC2 PCM */
@@ -1607,11 +1605,26 @@
 	ensoniq->u.es1371.ac97 = NULL;
 }
 
-static struct {
+struct es1371_quirk {
 	unsigned short vid;		/* vendor ID */
 	unsigned short did;		/* device ID */
 	unsigned char rev;		/* revision */
-} es1371_spdif_present[] __devinitdata = {
+};
+
+static int __devinit es1371_quirk_lookup(struct ensoniq *ensoniq,
+					 struct es1371_quirk *list)
+{
+	while (list->vid != (unsigned short)PCI_ANY_ID) {
+		if (ensoniq->pci->vendor == list->vid &&
+		    ensoniq->pci->device == list->did &&
+		    ensoniq->rev == list->rev)
+			return 1;
+		list++;
+	}
+	return 0;
+}
+
+static struct es1371_quirk es1371_spdif_present[] __devinitdata = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
@@ -1620,12 +1633,19 @@
 	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
 };
 
-static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq, int has_spdif, int has_line)
+static struct snd_pci_quirk ens1373_line_quirk[] __devinitdata = {
+	SND_PCI_QUIRK_ID(0x1274, 0x2000), /* GA-7DXR */
+	SND_PCI_QUIRK_ID(0x1458, 0xa000), /* GA-8IEXP */
+	{ } /* end */
+};
+
+static int __devinit snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
+					    int has_spdif, int has_line)
 {
 	struct snd_card *card = ensoniq->card;
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
-	int err, idx;
+	int err;
 	static struct snd_ac97_bus_ops ops = {
 		.write = snd_es1371_codec_write,
 		.read = snd_es1371_codec_read,
@@ -1641,33 +1661,28 @@
 	ac97.scaps = AC97_SCAP_AUDIO;
 	if ((err = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97)) < 0)
 		return err;
-	for (idx = 0; es1371_spdif_present[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if ((ensoniq->pci->vendor == es1371_spdif_present[idx].vid &&
-		     ensoniq->pci->device == es1371_spdif_present[idx].did &&
-		     ensoniq->rev == es1371_spdif_present[idx].rev) || has_spdif > 0) {
-		    	struct snd_kcontrol *kctl;
-			int i, index = 0; 
-
-                        if (has_spdif < 0)
-                                break;
-
-			ensoniq->spdif_default = ensoniq->spdif_stream =
-				SNDRV_PCM_DEFAULT_CON_SPDIF;
-			outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
-
-		    	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
-			    	index++;
-
-			for (i = 0; i < (int)ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {
-				kctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);
-				if (! kctl)
-					return -ENOMEM;
-				kctl->id.index = index;
-				if ((err = snd_ctl_add(card, kctl)) < 0)
-					return err;
-			}
-			break;
+	if (has_spdif > 0 ||
+	    (!has_spdif && es1371_quirk_lookup(ensoniq, es1371_spdif_present))) {
+		struct snd_kcontrol *kctl;
+		int i, index = 0;
+
+		ensoniq->spdif_default = ensoniq->spdif_stream =
+			SNDRV_PCM_DEFAULT_CON_SPDIF;
+		outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
+
+		if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
+			index++;
+
+		for (i = 0; i < ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {
+			kctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);
+			if (!kctl)
+				return -ENOMEM;
+			kctl->id.index = index;
+			err = snd_ctl_add(card, kctl);
+			if (err < 0)
+				return err;
 		}
+	}
 	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SDAC) {
 		/* mirror rear to front speakers */
 		ensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);
@@ -1676,12 +1691,10 @@
 		if (err < 0)
 			return err;
 	}
-	if (((ensoniq->subsystem_vendor_id == 0x1274) &&
-	    (ensoniq->subsystem_device_id == 0x2000)) || /* GA-7DXR */
-	    ((ensoniq->subsystem_vendor_id == 0x1458) &&
-	    (ensoniq->subsystem_device_id == 0xa000)) || /* GA-8IEXP */
-	    has_line > 0) {
-		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line, ensoniq));
+	if (has_line > 0 ||
+	    snd_pci_quirk_lookup(ensoniq->pci, ens1373_line_quirk)) {
+		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line,
+						      ensoniq));
 		 if (err < 0)
 			 return err;
 	}
@@ -1956,21 +1969,15 @@
 }
 
 #ifdef CHIP1371
-static struct {
-	unsigned short svid;		/* subsystem vendor ID */
-	unsigned short sdid;		/* subsystem device ID */
-} es1371_amplifier_hack[] = {
-	{ .svid = 0x107b, .sdid = 0x2150 },	/* Gateway Solo 2150 */
-	{ .svid = 0x13bd, .sdid = 0x100c },	/* EV1938 on Mebius PC-MJ100V */
-	{ .svid = 0x1102, .sdid = 0x5938 },	/* Targa Xtender300 */
-	{ .svid = 0x1102, .sdid = 0x8938 },	/* IPC Topnote G notebook */
-	{ .svid = PCI_ANY_ID, .sdid = PCI_ANY_ID }
+static struct snd_pci_quirk es1371_amplifier_hack[] __devinitdata = {
+	SND_PCI_QUIRK_ID(0x107b, 0x2150),	/* Gateway Solo 2150 */
+	SND_PCI_QUIRK_ID(0x13bd, 0x100c),	/* EV1938 on Mebius PC-MJ100V */
+	SND_PCI_QUIRK_ID(0x1102, 0x5938),	/* Targa Xtender300 */
+	SND_PCI_QUIRK_ID(0x1102, 0x8938),	/* IPC Topnote G notebook */
+	{ } /* end */
 };
-static struct {
-	unsigned short vid;		/* vendor ID */
-	unsigned short did;		/* device ID */
-	unsigned char rev;		/* revision */
-} es1371_ac97_reset_hack[] = {
+
+static struct es1371_quirk es1371_ac97_reset_hack[] = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
@@ -1984,7 +1991,6 @@
 {
 #ifdef CHIP1371
 	int idx;
-	struct pci_dev *pci = ensoniq->pci;
 #endif
 	/* this code was part of snd_ensoniq_create before intruduction
 	  * of suspend/resume
@@ -1999,16 +2005,12 @@
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
 	outl(0, ES_REG(ensoniq, 1371_LEGACY));
-	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
-		    pci->device == es1371_ac97_reset_hack[idx].did &&
-		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
-			outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
-			/* need to delay around 20ms(bleech) to give
-			some CODECs enough time to wakeup */
-			msleep(20);
-			break;
-		}
+	if (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack)) {
+	    outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+	    /* need to delay around 20ms(bleech) to give
+	       some CODECs enough time to wakeup */
+	    msleep(20);
+	}
 	/* AC'97 warm reset to start the bitclk */
 	outl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));
 	inl(ES_REG(ensoniq, CONTROL));
@@ -2072,9 +2074,10 @@
 	udelay(100);
 	snd_ak4531_suspend(ensoniq->u.es1370.ak4531);
 #endif	
-	pci_set_power_state(pci, PCI_D3hot);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2083,9 +2086,14 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct ensoniq *ensoniq = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR DRIVER_NAME ": pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_ensoniq_chip_init(ensoniq);
@@ -2106,11 +2114,7 @@
 				     struct ensoniq ** rensoniq)
 {
 	struct ensoniq *ensoniq;
-	unsigned short cmdw;
 	unsigned char cmdb;
-#ifdef CHIP1371
-	int idx;
-#endif
 	int err;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_ensoniq_dev_free,
@@ -2153,10 +2157,6 @@
 	pci_set_master(pci);
 	pci_read_config_byte(pci, PCI_REVISION_ID, &cmdb);
 	ensoniq->rev = cmdb;
-	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &cmdw);
-	ensoniq->subsystem_vendor_id = cmdw;
-	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &cmdw);
-	ensoniq->subsystem_device_id = cmdw;
 #ifdef CHIP1370
 #if 0
 	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE |
@@ -2169,19 +2169,11 @@
 	ensoniq->ctrl = 0;
 	ensoniq->sctrl = 0;
 	ensoniq->cssr = 0;
-	for (idx = 0; es1371_amplifier_hack[idx].svid != (unsigned short)PCI_ANY_ID; idx++)
-		if (ensoniq->subsystem_vendor_id == es1371_amplifier_hack[idx].svid &&
-		    ensoniq->subsystem_device_id == es1371_amplifier_hack[idx].sdid) {
-			ensoniq->ctrl |= ES_1371_GPIO_OUT(1);	/* turn amplifier on */
-			break;
-		}
-	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
-		    pci->device == es1371_ac97_reset_hack[idx].did &&
-		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
-			ensoniq->cssr |= ES_1371_ST_AC97_RST;
-			break;
-		}
+	if (snd_pci_quirk_lookup(pci, es1371_amplifier_hack))
+		ensoniq->ctrl |= ES_1371_GPIO_OUT(1);	/* turn amplifier on */
+
+	if (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack))
+		ensoniq->cssr |= ES_1371_ST_AC97_RST;
 #endif
 
 	snd_ensoniq_chip_init(ensoniq);
--- linux-2.6.18.noarch/sound/pci/fm801.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/fm801.c	2007-06-05 17:47:00.000000000 -0400
@@ -2,6 +2,7 @@
  *  The driver for the ForteMedia FM801 based soundcards
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
  *
+ *  Support FM only card by Andy Shevchenko <andy@smile.org.ua>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -28,6 +29,7 @@
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
+#include <sound/tlv.h>
 #include <sound/ac97_codec.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
@@ -54,6 +56,7 @@
  *    1 = MediaForte 256-PCS
  *    2 = MediaForte 256-PCPR
  *    3 = MediaForte 64-PCR
+ *   16 = setup tuner only (this is additional bit), i.e. SF-64-PCR FM card
  *  High 16-bits are video (radio) device number + 1
  */
 static int tea575x_tuner[SNDRV_CARDS];
@@ -158,6 +161,7 @@
 	unsigned int multichannel: 1,	/* multichannel support */
 		     secondary: 1;	/* secondary codec */
 	unsigned char secondary_addr;	/* address of the secondary codec */
+	unsigned int tea575x_tuner;	/* tuner flags */
 
 	unsigned short ply_ctrl; /* playback control */
 	unsigned short cap_ctrl; /* capture control */
@@ -318,10 +322,8 @@
   2, 4, 6
 };
 
-#define CHANNELS sizeof(channels) / sizeof(channels[0])
-
 static struct snd_pcm_hw_constraint_list hw_constraints_channels = {
-	.count = CHANNELS,
+	.count = ARRAY_SIZE(channels),
 	.list = channels,
 	.mask = 0,
 };
@@ -1052,6 +1054,13 @@
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_fm801_info_double, \
   .get = snd_fm801_get_double, .put = snd_fm801_put_double, \
   .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24) }
+#define FM801_DOUBLE_TLV(xname, reg, shift_left, shift_right, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .info = snd_fm801_info_double, \
+  .get = snd_fm801_get_double, .put = snd_fm801_put_double, \
+  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24), \
+  .tlv = { .p = (xtlv) } }
 
 static int snd_fm801_info_double(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_info *uinfo)
@@ -1148,14 +1157,19 @@
 	return snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);
+
 #define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)
 
 static struct snd_kcontrol_new snd_fm801_controls[] __devinitdata = {
-FM801_DOUBLE("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1),
+FM801_DOUBLE_TLV("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1,
+		 db_scale_dsp),
 FM801_SINGLE("Wave Playback Switch", FM801_PCM_VOL, 15, 1, 1),
-FM801_DOUBLE("I2S Playback Volume", FM801_I2S_VOL, 0, 8, 31, 1),
+FM801_DOUBLE_TLV("I2S Playback Volume", FM801_I2S_VOL, 0, 8, 31, 1,
+		 db_scale_dsp),
 FM801_SINGLE("I2S Playback Switch", FM801_I2S_VOL, 15, 1, 1),
-FM801_DOUBLE("FM Playback Volume", FM801_FM_VOL, 0, 8, 31, 1),
+FM801_DOUBLE_TLV("FM Playback Volume", FM801_FM_VOL, 0, 8, 31, 1,
+		 db_scale_dsp),
 FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1253,6 +1267,9 @@
 	int id;
 	unsigned short cmdw;
 
+	if (chip->tea575x_tuner & 0x0010)
+		goto __ac97_ok;
+
 	/* codec cold reset + AC'97 warm reset */
 	outw((1<<5) | (1<<6), FM801_REG(chip, CODEC_CTRL));
 	inw(FM801_REG(chip, CODEC_CTRL)); /* flush posting data */
@@ -1290,6 +1307,8 @@
 		wait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));
 	}
 
+      __ac97_ok:
+
 	/* init volume */
 	outw(0x0808, FM801_REG(chip, PCM_VOL));
 	outw(0x9f1f, FM801_REG(chip, FM_VOL));
@@ -1298,9 +1317,12 @@
 	/* I2S control - I2S mode */
 	outw(0x0003, FM801_REG(chip, I2S_MODE));
 
-	/* interrupt setup - unmask MPU, PLAYBACK & CAPTURE */
+	/* interrupt setup */
 	cmdw = inw(FM801_REG(chip, IRQ_MASK));
-	cmdw &= ~0x0083;
+	if (chip->irq < 0)
+		cmdw |= 0x00c3;		/* mask everything, no PCM nor MPU */
+	else
+		cmdw &= ~0x0083;	/* unmask MPU, PLAYBACK & CAPTURE */
 	outw(cmdw, FM801_REG(chip, IRQ_MASK));
 
 	/* interrupt clear */
@@ -1365,6 +1387,7 @@
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;
+	chip->tea575x_tuner = tea575x_tuner;
 	if ((err = pci_request_regions(pci, "FM801")) < 0) {
 		kfree(chip);
 		pci_disable_device(pci);
@@ -1377,8 +1400,6 @@
 		snd_fm801_free(chip);
 		return -EBUSY;
 	}
-	chip->irq = pci->irq;
-	pci_set_master(pci);
 
 	pci_read_config_byte(pci, PCI_REVISION_ID, &rev);
 	if (rev >= 0xb1)	/* FM801-AU */
@@ -1394,12 +1415,12 @@
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef TEA575X_RADIO
-	if (tea575x_tuner > 0 && (tea575x_tuner & 0xffff) < 4) {
+	if (tea575x_tuner > 0 && (tea575x_tuner & 0x000f) < 4) {
 		chip->tea.dev_nr = tea575x_tuner >> 16;
 		chip->tea.card = card;
 		chip->tea.freq_fixup = 10700;
 		chip->tea.private_data = chip;
-		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0xffff) - 1];
+		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0x000f) - 1];
 		snd_tea575x_init(&chip->tea);
 	}
 #endif
@@ -1439,6 +1460,9 @@
 	sprintf(card->longname, "%s at 0x%lx, irq %i",
 		card->shortname, chip->port, chip->irq);
 
+	if (tea575x_tuner[dev] & 0x0010)
+		goto __fm801_tuner_only;
+
 	if ((err = snd_fm801_pcm(chip, 0, NULL)) < 0) {
 		snd_card_free(card);
 		return err;
@@ -1465,6 +1489,7 @@
 		return err;
 	}
 
+      __fm801_tuner_only:
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;
@@ -1502,9 +1527,9 @@
 		chip->saved_regs[i] = inw(chip->port + saved_regs[i]);
 	/* FIXME: tea575x suspend */
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1514,9 +1539,14 @@
 	struct fm801 *chip = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "fm801: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_fm801_chip_init(chip, 1);
--- linux-2.6.18.noarch/sound/pci/via82xx.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/via82xx.c	2007-06-05 17:47:00.000000000 -0400
@@ -59,6 +59,7 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/info.h>
+#include <sound/tlv.h>
 #include <sound/ac97_codec.h>
 #include <sound/mpu401.h>
 #include <sound/initval.h>
@@ -1277,7 +1278,18 @@
 	if (! ratep->used)
 		ratep->rate = 0;
 	spin_unlock_irq(&ratep->lock);
-
+	if (! ratep->rate) {
+		if (! viadev->direction) {
+			snd_ac97_update_power(chip->ac97,
+					      AC97_PCM_FRONT_DAC_RATE, 0);
+			snd_ac97_update_power(chip->ac97,
+					      AC97_PCM_SURR_DAC_RATE, 0);
+			snd_ac97_update_power(chip->ac97,
+					      AC97_PCM_LFE_DAC_RATE, 0);
+		} else
+			snd_ac97_update_power(chip->ac97,
+					      AC97_PCM_LR_ADC_RATE, 0);
+	}
 	viadev->substream = NULL;
 	return 0;
 }
@@ -1687,21 +1699,29 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_dxs, -9450, 150, 1);
+
 static struct snd_kcontrol_new snd_via8233_pcmdxs_volume_control __devinitdata = {
 	.name = "PCM Playback Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.info = snd_via8233_dxs_volume_info,
 	.get = snd_via8233_pcmdxs_volume_get,
 	.put = snd_via8233_pcmdxs_volume_put,
+	.tlv = { .p = db_scale_dxs }
 };
 
 static struct snd_kcontrol_new snd_via8233_dxs_volume_control __devinitdata = {
 	.name = "VIA DXS Playback Volume",
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		   SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.count = 4,
 	.info = snd_via8233_dxs_volume_info,
 	.get = snd_via8233_dxs_volume_get,
 	.put = snd_via8233_dxs_volume_put,
+	.tlv = { .p = db_scale_dxs }
 };
 
 /*
@@ -1803,7 +1823,7 @@
 	ac97.private_data = chip;
 	ac97.private_free = snd_via82xx_mixer_free_ac97;
 	ac97.pci = chip->pci;
-	ac97.scaps = AC97_SCAP_SKIP_MODEM;
+	ac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;
 	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
 		return err;
 
@@ -2165,9 +2185,9 @@
 		chip->capture_src_saved[1] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);
 	}
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2177,9 +2197,15 @@
 	struct via82xx *chip = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "via82xx: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	pci_set_master(pci);
 
 	snd_via82xx_chip_init(chip);
 
@@ -2331,92 +2357,59 @@
 /*
  * auto detection of DXS channel supports.
  */
-struct dxs_whitelist {
-	unsigned short subvendor;
-	unsigned short subdevice; 
-	unsigned short mask; 
-	short action;	/* new dxs_support value */
+
+static struct snd_pci_quirk dxs_whitelist[] __devinitdata = {
+	SND_PCI_QUIRK(0x1005, 0x4710, "Avance Logic Mobo", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1019, 0x0996, "ESC Mobo", VIA_DXS_48K),
+	SND_PCI_QUIRK(0x1019, 0x0a81, "ECS K7VTA3 v8.0", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x1019, 0x0a85, "ECS L7VMM2", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x1019, 0, "ESC K8", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1019, 0xaa01, "ESC K8T890-A", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1025, 0x0033, "Acer Inspire 1353LM", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x1025, 0x0046, "Acer Aspire 1524 WLMi", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1043, 0, "ASUS A7/A8", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x1071, 0, "Diverse Notebook", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x10cf, 0x118e, "FSC Laptop", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1106, 0, "ASRock", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1297, 0xa232, "Shuttle", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1297, 0xc160, "Shuttle Sk41G", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1458, 0xa002, "Gigabyte GA-7VAXP", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1462, 0x3800, "MSI KT266", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1462, 0x7120, "MSI KT4V", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1462, 0x7142, "MSI K8MM-V", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1462, 0, "MSI Mobo", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x147b, 0x1401, "ABIT KD7(-RAID)", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x147b, 0x1411, "ABIT VA-20", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x147b, 0x1413, "ABIT KV8 Pro", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x147b, 0x1415, "ABIT AV8", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x14ff, 0x0403, "Twinhead mobo", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x14ff, 0x0408, "Twinhead laptop", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1558, 0x4701, "Clevo D470", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1584, 0x8120, "Diverse Laptop", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1584, 0x8123, "Targa/Uniwill", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x161f, 0x202b, "Amira Notebook", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x161f, 0x2032, "m680x machines", VIA_DXS_48K),
+	SND_PCI_QUIRK(0x1631, 0xe004, "PB EasyNote 3174", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1695, 0x3005, "EPoX EP-8K9A", VIA_DXS_ENABLE),
+	SND_PCI_QUIRK(0x1695, 0, "EPoX mobo", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x16f3, 0, "Jetway K8", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1734, 0, "FSC Laptop", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1849, 0x3059, "ASRock K7VM2", VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x1849, 0, "ASRock mobo", VIA_DXS_SRC),
+	SND_PCI_QUIRK(0x1919, 0x200a, "Soltek SL-K8",  VIA_DXS_NO_VRA),
+	SND_PCI_QUIRK(0x4005, 0x4710, "MSI K7T266", VIA_DXS_SRC),
+	{ } /* terminator */
 };
 
 static int __devinit check_dxs_list(struct pci_dev *pci, int revision)
 {
-	static struct dxs_whitelist whitelist[] = {
-		{ .subvendor = 0x1005, .subdevice = 0x4710, .action = VIA_DXS_ENABLE }, /* Avance Logic Mobo */
-		{ .subvendor = 0x1019, .subdevice = 0x0996, .action = VIA_DXS_48K },
-		{ .subvendor = 0x1019, .subdevice = 0x0a81, .action = VIA_DXS_NO_VRA }, /* ECS K7VTA3 v8.0 */
-		{ .subvendor = 0x1019, .subdevice = 0x0a85, .action = VIA_DXS_NO_VRA }, /* ECS L7VMM2 */
-		{ .subvendor = 0x1019, .subdevice = 0xa101, .action = VIA_DXS_SRC },
-		{ .subvendor = 0x1019, .subdevice = 0xaa01, .action = VIA_DXS_SRC }, /* ECS K8T890-A */
-		{ .subvendor = 0x1025, .subdevice = 0x0033, .action = VIA_DXS_NO_VRA }, /* Acer Inspire 1353LM */
-		{ .subvendor = 0x1025, .subdevice = 0x0046, .action = VIA_DXS_SRC }, /* Acer Aspire 1524 WLMi */
-		{ .subvendor = 0x1043, .subdevice = 0x8095, .action = VIA_DXS_NO_VRA }, /* ASUS A7V8X (FIXME: possibly VIA_DXS_ENABLE?)*/
-		{ .subvendor = 0x1043, .subdevice = 0x80a1, .action = VIA_DXS_NO_VRA }, /* ASUS A7V8-X */
-		{ .subvendor = 0x1043, .subdevice = 0x80b0, .action = VIA_DXS_NO_VRA }, /* ASUS A7V600 & K8V*/ 
-		{ .subvendor = 0x1043, .subdevice = 0x810d, .action = VIA_DXS_SRC }, /* ASUS */
-		{ .subvendor = 0x1043, .subdevice = 0x812a, .action = VIA_DXS_SRC    }, /* ASUS A8V Deluxe */ 
-		{ .subvendor = 0x1043, .subdevice = 0x8174, .action = VIA_DXS_SRC    }, /* ASUS */
-		{ .subvendor = 0x1043, .subdevice = 0x81b9, .action = VIA_DXS_SRC    }, /* ASUS A8V-MX */
-		{ .subvendor = 0x1071, .subdevice = 0x8375, .action = VIA_DXS_NO_VRA }, /* Vobis/Yakumo/Mitac notebook */
-		{ .subvendor = 0x1071, .subdevice = 0x8399, .action = VIA_DXS_NO_VRA }, /* Umax AB 595T (VIA K8N800A - VT8237) */
-		{ .subvendor = 0x10cf, .subdevice = 0x118e, .action = VIA_DXS_ENABLE }, /* FSC laptop */
-		{ .subvendor = 0x1106, .subdevice = 0x4161, .action = VIA_DXS_NO_VRA }, /* ASRock K7VT2 */
-		{ .subvendor = 0x1106, .subdevice = 0x4552, .action = VIA_DXS_NO_VRA }, /* QDI Kudoz 7X/600-6AL */
-		{ .subvendor = 0x1106, .subdevice = 0xaa01, .action = VIA_DXS_NO_VRA }, /* EPIA MII */
-		{ .subvendor = 0x1106, .subdevice = 0xc001, .action = VIA_DXS_SRC }, /* Insight P4-ITX */
-		{ .subvendor = 0x1297, .subdevice = 0xa232, .action = VIA_DXS_ENABLE }, /* Shuttle ?? */
-		{ .subvendor = 0x1297, .subdevice = 0xc160, .action = VIA_DXS_ENABLE }, /* Shuttle SK41G */
-		{ .subvendor = 0x1458, .subdevice = 0xa002, .action = VIA_DXS_ENABLE }, /* Gigabyte GA-7VAXP */
-		{ .subvendor = 0x1462, .subdevice = 0x0080, .action = VIA_DXS_SRC }, /* MSI K8T Neo-FIS2R */
-		{ .subvendor = 0x1462, .subdevice = 0x0430, .action = VIA_DXS_SRC }, /* MSI 7142 (K8MM-V) */
-		{ .subvendor = 0x1462, .subdevice = 0x0470, .action = VIA_DXS_SRC }, /* MSI KT880 Delta-FSR */
-		{ .subvendor = 0x1462, .subdevice = 0x3800, .action = VIA_DXS_ENABLE }, /* MSI KT266 */
-		{ .subvendor = 0x1462, .subdevice = 0x5901, .action = VIA_DXS_NO_VRA }, /* MSI KT6 Delta-SR */
-		{ .subvendor = 0x1462, .subdevice = 0x7023, .action = VIA_DXS_SRC }, /* MSI K8T Neo2-FI */
-		{ .subvendor = 0x1462, .subdevice = 0x7120, .action = VIA_DXS_ENABLE }, /* MSI KT4V */
-		{ .subvendor = 0x1462, .subdevice = 0x7142, .action = VIA_DXS_ENABLE }, /* MSI K8MM-V */
-		{ .subvendor = 0x1462, .subdevice = 0xb012, .action = VIA_DXS_SRC }, /* P4M800/VIA8237R */
-		{ .subvendor = 0x147b, .subdevice = 0x1401, .action = VIA_DXS_ENABLE }, /* ABIT KD7(-RAID) */
-		{ .subvendor = 0x147b, .subdevice = 0x1411, .action = VIA_DXS_ENABLE }, /* ABIT VA-20 */
-		{ .subvendor = 0x147b, .subdevice = 0x1413, .action = VIA_DXS_ENABLE }, /* ABIT KV8 Pro */
-		{ .subvendor = 0x147b, .subdevice = 0x1415, .action = VIA_DXS_NO_VRA }, /* Abit AV8 */
-		{ .subvendor = 0x14ff, .subdevice = 0x0403, .action = VIA_DXS_ENABLE }, /* Twinhead mobo */
-		{ .subvendor = 0x14ff, .subdevice = 0x0408, .action = VIA_DXS_SRC }, /* Twinhead laptop */
-		{ .subvendor = 0x1558, .subdevice = 0x4701, .action = VIA_DXS_SRC }, /* Clevo D470 */
-		{ .subvendor = 0x1584, .subdevice = 0x8120, .action = VIA_DXS_ENABLE }, /* Gericom/Targa/Vobis/Uniwill laptop */
-		{ .subvendor = 0x1584, .subdevice = 0x8123, .action = VIA_DXS_NO_VRA }, /* Uniwill (Targa Visionary XP-210) */
-		{ .subvendor = 0x161f, .subdevice = 0x202b, .action = VIA_DXS_NO_VRA }, /* Amira Note book */
-		{ .subvendor = 0x161f, .subdevice = 0x2032, .action = VIA_DXS_48K }, /* m680x machines */
-		{ .subvendor = 0x1631, .subdevice = 0xe004, .action = VIA_DXS_ENABLE }, /* Easy Note 3174, Packard Bell */
-		{ .subvendor = 0x1695, .subdevice = 0x3005, .action = VIA_DXS_ENABLE }, /* EPoX EP-8K9A */
-		{ .subvendor = 0x1695, .subdevice = 0x300c, .action = VIA_DXS_SRC }, /* EPoX EP-8KRAI */
-		{ .subvendor = 0x1695, .subdevice = 0x300e, .action = VIA_DXS_SRC }, /* EPoX 9HEAI */
-		{ .subvendor = 0x16f3, .subdevice = 0x6405, .action = VIA_DXS_SRC }, /* Jetway K8M8MS */
-		{ .subvendor = 0x1734, .subdevice = 0x1078, .action = VIA_DXS_SRC }, /* FSC Amilo L7300 */
-		{ .subvendor = 0x1734, .subdevice = 0x1093, .action = VIA_DXS_SRC }, /* FSC */
-		{ .subvendor = 0x1849, .subdevice = 0x3059, .action = VIA_DXS_NO_VRA }, /* ASRock K7VM2 */
-		{ .subvendor = 0x1849, .subdevice = 0x9739, .action = VIA_DXS_SRC }, /* ASRock mobo(?) */
-		{ .subvendor = 0x1849, .subdevice = 0x9761, .action = VIA_DXS_SRC }, /* ASRock mobo(?) */
-		{ .subvendor = 0x1919, .subdevice = 0x200a, .action = VIA_DXS_NO_VRA }, /* Soltek SL-K8Tpro-939 */
-		{ .subvendor = 0x4005, .subdevice = 0x4710, .action = VIA_DXS_SRC },	/* MSI K7T266 Pro2 (MS-6380 V2.0) BIOS 3.7 */
-		{ } /* terminator */
-	};
-	struct dxs_whitelist *w;
-	unsigned short subsystem_vendor;
-	unsigned short subsystem_device;
-
-	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
-	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
+	const struct snd_pci_quirk *w;
 
-	for (w = whitelist; w->subvendor; w++) {
-		if (w->subvendor != subsystem_vendor)
-			continue;
-		if (w->mask) {
-			if ((w->mask & subsystem_device) == w->subdevice)
-				return w->action;
-		} else {
-			if (subsystem_device == w->subdevice)
-				return w->action;
-		}
+	w = snd_pci_quirk_lookup(pci, dxs_whitelist);
+	if (w) {
+		snd_printdd(KERN_INFO "via82xx: DXS white list for %s found\n",
+			    w->name);
+		return w->value;
 	}
 
 	/* for newer revision, default to DXS_SRC */
--- linux-2.6.18.noarch/sound/pci/riptide/riptide.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/riptide/riptide.c	2007-06-05 17:47:45.000000000 -0400
@@ -673,9 +673,13 @@
 #define FIRMWARE_VERSIONS 1
 static union firmware_version firmware_versions[] = {
 	{
-	 .firmware.ASIC = 3,.firmware.CODEC = 2,
-	 .firmware.AUXDSP = 3,.firmware.PROG = 773,
-	 },
+		.firmware = {
+			.ASIC = 3,
+			.CODEC = 2,
+			.AUXDSP = 3,
+			.PROG = 773,
+		},
+	},
 };
 
 static u32 atoh(unsigned char *in, unsigned int len)
@@ -1174,9 +1178,9 @@
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1185,9 +1189,14 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_riptide *chip = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "riptide: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 	snd_riptide_initialize(chip);
 	snd_ac97_resume(chip->ac97);
@@ -1912,6 +1921,8 @@
 		return err;
 	}
 
+	snd_card_set_dev(card, &pci->dev);
+
 	*rchip = chip;
 	return 0;
 }
--- linux-2.6.18.noarch/sound/pci/maestro3.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/maestro3.c	2007-06-05 17:47:00.000000000 -0400
@@ -41,6 +41,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/moduleparam.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
@@ -48,6 +49,7 @@
 #include <sound/mpu401.h>
 #include <sound/ac97_codec.h>
 #include <sound/initval.h>
+#include <asm/byteorder.h>
 
 MODULE_AUTHOR("Zach Brown <zab@zabbo.net>, Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("ESS Maestro3 PCI");
@@ -768,21 +770,6 @@
 /*
  */
 
-/* quirk lists */
-struct m3_quirk {
-	const char *name;	/* device name */
-	u16 vendor, device;	/* subsystem ids */
-	int amp_gpio;		/* gpio pin #  for external amp, -1 = default */
-	int irda_workaround;	/* non-zero if avoid to touch 0x10 on GPIO_DIRECTION
-				   (e.g. for IrDA on Dell Inspirons) */
-};
-
-struct m3_hv_quirk {
-	u16 vendor, device, subsystem_vendor, subsystem_device;
-	u32 config;		/* ALLEGRO_CONFIG hardware volume bits */
-	int is_omnibook;	/* Do HP OmniBook GPIO magic? */
-};
-
 struct m3_list {
 	int curlen;
 	int mem_addr;
@@ -830,8 +817,6 @@
 	struct snd_pcm *pcm;
 
 	struct pci_dev *pci;
-	const struct m3_quirk *quirk;
-	const struct m3_hv_quirk *hv_quirk;
 
 	int dacs_active;
 	int timer_users;
@@ -845,7 +830,11 @@
 	u8 reset_state;
 
 	int external_amp;
-	int amp_gpio;
+	int amp_gpio;	/* gpio pin #  for external amp, -1 = default */
+	unsigned int hv_config;		/* hardware-volume config bits */
+	unsigned irda_workaround :1;	/* avoid to touch 0x10 on GPIO_DIRECTION
+					   (e.g. for IrDA on Dell Inspirons) */
+	unsigned is_omnibook :1;	/* Do HP OmniBook GPIO magic? */
 
 	/* midi */
 	struct snd_rawmidi *rmidi;
@@ -864,6 +853,9 @@
 #ifdef CONFIG_PM
 	u16 *suspend_mem;
 #endif
+
+	const struct firmware *assp_kernel_image;
+	const struct firmware *assp_minisrc_image;
 };
 
 /*
@@ -891,127 +883,104 @@
 
 MODULE_DEVICE_TABLE(pci, snd_m3_ids);
 
-static const struct m3_quirk m3_quirk_list[] = {
-	/* panasonic CF-28 "toughbook" */
-	{
-		.name = "Panasonic CF-28",
-		.vendor = 0x10f7,
-		.device = 0x833e,
-		.amp_gpio = 0x0d,
-	},
-	/* panasonic CF-72 "toughbook" */
-	{
-		.name = "Panasonic CF-72",
-		.vendor = 0x10f7,
-		.device = 0x833d,
-		.amp_gpio = 0x0d,
-	},
-	/* Dell Inspiron 4000 */
-	{
-		.name = "Dell Inspiron 4000",
-		.vendor = 0x1028,
-		.device = 0x00b0,
-		.amp_gpio = -1,
-		.irda_workaround = 1,
-	},
-	/* Dell Inspiron 8000 */
-	{
-		.name = "Dell Inspiron 8000",
-		.vendor = 0x1028,
-		.device = 0x00a4,
-		.amp_gpio = -1,
-		.irda_workaround = 1,
-	},
-	/* Dell Inspiron 8100 */
-	{
-		.name = "Dell Inspiron 8100",
-		.vendor = 0x1028,
-		.device = 0x00e6,
-		.amp_gpio = -1,
-		.irda_workaround = 1,
-	},
-	/* NEC LM800J/7 */
-	{
-		.name = "NEC LM800J/7",
-		.vendor = 0x1033,
-		.device = 0x80f1,
-		.amp_gpio = 0x03,
-	},
-	/* LEGEND ZhaoYang 3100CF */
-	{
-		.name = "LEGEND ZhaoYang 3100CF",
-		.vendor = 0x1509,
-		.device = 0x1740,
-		.amp_gpio = 0x03,
-	},
-	/* END */
-	{ NULL }
+static struct snd_pci_quirk m3_amp_quirk_list[] __devinitdata = {
+	SND_PCI_QUIRK(0x10f7, 0x833e, "Panasonic CF-28", 0x0d),
+	SND_PCI_QUIRK(0x10f7, 0x833d, "Panasonic CF-72", 0x0d),
+	SND_PCI_QUIRK(0x1033, 0x80f1, "NEC LM800J/7", 0x03),
+	SND_PCI_QUIRK(0x1509, 0x1740, "LEGEND ZhaoYang 3100CF", 0x03),
+	{ } /* END */
+};
+
+static struct snd_pci_quirk m3_irda_quirk_list[] __devinitdata = {
+	SND_PCI_QUIRK(0x1028, 0x00b0, "Dell Inspiron 4000", 1),
+	SND_PCI_QUIRK(0x1028, 0x00a4, "Dell Inspiron 8000", 1),
+	SND_PCI_QUIRK(0x1028, 0x00e6, "Dell Inspiron 8100", 1),
+	{ } /* END */
 };
 
-/* These values came from the Windows driver. */
-static const struct m3_hv_quirk m3_hv_quirk_list[] = {
+/* hardware volume quirks */
+static struct snd_pci_quirk m3_hv_quirk_list[] __devinitdata = {
 	/* Allegro chips */
-	{ 0x125D, 0x1988, 0x0E11, 0x002E, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x0E11, 0x0094, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x0E11, 0xB112, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x0E11, 0xB114, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x103C, 0x0012, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x103C, 0x0018, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x103C, 0x001C, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x103C, 0x001D, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x103C, 0x001E, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x107B, 0x3350, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x10F7, 0x8338, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x10F7, 0x833C, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x10F7, 0x833D, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x10F7, 0x833E, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x10F7, 0x833F, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x13BD, 0x1018, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x13BD, 0x1019, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x13BD, 0x101A, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x14FF, 0x0F03, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x14FF, 0x0F04, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x14FF, 0x0F05, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x156D, 0xB400, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x156D, 0xB795, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x156D, 0xB797, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x156D, 0xC700, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD, 0 },
-	{ 0x125D, 0x1988, 0x1033, 0x80F1, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x103C, 0x001A, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 }, /* HP OmniBook 6100 */
-	{ 0x125D, 0x1988, 0x107B, 0x340A, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x107B, 0x3450, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x109F, 0x3134, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x109F, 0x3161, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x144D, 0x3280, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x144D, 0x3281, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x144D, 0xC002, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x144D, 0xC003, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x1509, 0x1740, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x1610, 0x0010, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x1988, 0x1042, 0x1042, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1988, 0x107B, 0x9500, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1988, 0x14FF, 0x0F06, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1988, 0x1558, 0x8586, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1988, 0x161F, 0x2011, HV_CTRL_ENABLE, 0 },
+	SND_PCI_QUIRK(0x0E11, 0x002E, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x0E11, 0x0094, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x0E11, 0xB112, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x0E11, 0xB114, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x103C, 0x0012, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x103C, 0x0018, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x103C, 0x001C, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x103C, 0x001D, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x103C, 0x001E, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x107B, 0x3350, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x10F7, 0x8338, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x10F7, 0x833C, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x10F7, 0x833D, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x10F7, 0x833E, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x10F7, 0x833F, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x13BD, 0x1018, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x13BD, 0x1019, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x13BD, 0x101A, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x14FF, 0x0F03, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x14FF, 0x0F04, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x14FF, 0x0F05, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x156D, 0xB400, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x156D, 0xB795, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x156D, 0xB797, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x156D, 0xC700, NULL, HV_CTRL_ENABLE | HV_BUTTON_FROM_GD),
+	SND_PCI_QUIRK(0x1033, 0x80F1, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x103C, 0x001A, NULL, /* HP OmniBook 6100 */
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x107B, 0x340A, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x107B, 0x3450, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x109F, 0x3134, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x109F, 0x3161, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0x3280, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0x3281, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0xC002, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0xC003, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x1509, 0x1740, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x1610, 0x0010, NULL,
+		      HV_CTRL_ENABLE | HV_BUTTON_FROM_GD | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x1042, 0x1042, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x107B, 0x9500, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x14FF, 0x0F06, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x1558, 0x8586, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x161F, 0x2011, NULL, HV_CTRL_ENABLE),
 	/* Maestro3 chips */
-	{ 0x125D, 0x1998, 0x103C, 0x000E, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x103C, 0x0010, HV_CTRL_ENABLE, 1 }, /* HP OmniBook 6000 */
-	{ 0x125D, 0x1998, 0x103C, 0x0011, HV_CTRL_ENABLE, 1 }, /* HP OmniBook 500 */
-	{ 0x125D, 0x1998, 0x103C, 0x001B, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x104D, 0x80A6, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x104D, 0x80AA, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x107B, 0x5300, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x110A, 0x1998, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x13BD, 0x1015, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x13BD, 0x101C, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x13BD, 0x1802, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x1599, 0x0715, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x1998, 0x5643, 0x5643, HV_CTRL_ENABLE, 0 },
-	{ 0x125D, 0x199A, 0x144D, 0x3260, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x199A, 0x144D, 0x3261, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x199A, 0x144D, 0xC000, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
-	{ 0x125D, 0x199A, 0x144D, 0xC001, HV_CTRL_ENABLE | REDUCED_DEBOUNCE, 0 },
-	{ 0 }
+	SND_PCI_QUIRK(0x103C, 0x000E, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x103C, 0x0010, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x103C, 0x0011, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x103C, 0x001B, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x104D, 0x80A6, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x104D, 0x80AA, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x107B, 0x5300, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x110A, 0x1998, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x13BD, 0x1015, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x13BD, 0x101C, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x13BD, 0x1802, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x1599, 0x0715, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x5643, 0x5643, NULL, HV_CTRL_ENABLE),
+	SND_PCI_QUIRK(0x144D, 0x3260, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0x3261, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0xC000, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),
+	SND_PCI_QUIRK(0x144D, 0xC001, NULL, HV_CTRL_ENABLE | REDUCED_DEBOUNCE),
+	{ } /* END */
+};
+
+/* HP Omnibook quirks */
+static struct snd_pci_quirk m3_omnibook_quirk_list[] __devinitdata = {
+	SND_PCI_QUIRK_ID(0x103c, 0x0010), /* HP OmniBook 6000 */
+	SND_PCI_QUIRK_ID(0x103c, 0x0011), /* HP OmniBook 500 */
+	{ } /* END */
 };
 
 /*
@@ -2051,7 +2020,7 @@
 
 	for (i = 0; i < 5; i++) {
 		dir = inw(io + GPIO_DIRECTION);
-		if (! chip->quirk || ! chip->quirk->irda_workaround)
+		if (!chip->irda_workaround)
 			dir |= 0x10; /* assuming pci bus master? */
 
 		snd_m3_remote_codec_config(io, 0);
@@ -2133,6 +2102,10 @@
 }
 
 
+#define FIRMWARE_IN_THE_KERNEL
+
+#ifdef FIRMWARE_IN_THE_KERNEL
+
 /*
  * DSP Code images
  */
@@ -2261,6 +2234,30 @@
     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
 };
 
+static const struct firmware assp_kernel = {
+	.data = (u8 *)assp_kernel_image,
+	.size = sizeof assp_kernel_image
+};
+static const struct firmware assp_minisrc = {
+	.data = (u8 *)assp_minisrc_image,
+	.size = sizeof assp_minisrc_image
+};
+
+#endif /* FIRMWARE_IN_THE_KERNEL */
+
+#ifdef __LITTLE_ENDIAN
+static inline void snd_m3_convert_from_le(const struct firmware *fw) { }
+#else
+static void snd_m3_convert_from_le(const struct firmware *fw)
+{
+	int i;
+	u16 *data = (u16 *)fw->data;
+
+	for (i = 0; i < fw->size / 2; ++i)
+		le16_to_cpus(&data[i]);
+}
+#endif
+
 
 /*
  * initialize ASSP
@@ -2275,6 +2272,7 @@
 static void snd_m3_assp_init(struct snd_m3 *chip)
 {
 	unsigned int i;
+	u16 *data;
 
 	/* zero kernel data */
 	for (i = 0; i < (REV_B_DATA_MEMORY_UNIT_LENGTH * NUM_UNITS_KERNEL_DATA) / 2; i++)
@@ -2292,10 +2290,10 @@
 			  KDATA_DMA_XFER0);
 
 	/* write kernel into code memory.. */
-	for (i = 0 ; i < ARRAY_SIZE(assp_kernel_image); i++) {
+	data = (u16 *)chip->assp_kernel_image->data;
+	for (i = 0 ; i * 2 < chip->assp_kernel_image->size; i++) {
 		snd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE, 
-				  REV_B_CODE_MEMORY_BEGIN + i, 
-				  assp_kernel_image[i]);
+				  REV_B_CODE_MEMORY_BEGIN + i, data[i]);
 	}
 
 	/*
@@ -2304,10 +2302,10 @@
 	 * drop it there.  It seems that the minisrc doesn't
 	 * need vectors, so we won't bother with them..
 	 */
-	for (i = 0; i < ARRAY_SIZE(assp_minisrc_image); i++) {
+	data = (u16 *)chip->assp_minisrc_image->data;
+	for (i = 0; i * 2 < chip->assp_minisrc_image->size; i++) {
 		snd_m3_assp_write(chip, MEMTYPE_INTERNAL_CODE, 
-				  0x400 + i, 
-				  assp_minisrc_image[i]);
+				  0x400 + i, data[i]);
 	}
 
 	/*
@@ -2378,7 +2376,7 @@
 	 * shifted list address is aligned.
 	 * list address = (mem address >> 1) >> 7;
 	 */
-	data_bytes = (data_bytes + 255) & ~255;
+	data_bytes = ALIGN(data_bytes, 256);
 	address = 0x1100 + ((data_bytes/2) * index);
 
 	if ((address + (data_bytes/2)) >= 0x1c00) {
@@ -2445,7 +2443,7 @@
 	       DISABLE_LEGACY);
 	pci_write_config_word(pcidev, PCI_LEGACY_AUDIO_CTRL, w);
 
-	if (chip->hv_quirk && chip->hv_quirk->is_omnibook) {
+	if (chip->is_omnibook) {
 		/*
 		 * Volume buttons on some HP OmniBook laptops don't work
 		 * correctly. This makes them work for the most part.
@@ -2462,8 +2460,7 @@
 	}
 	pci_read_config_dword(pcidev, PCI_ALLEGRO_CONFIG, &n);
 	n &= ~(HV_CTRL_ENABLE | REDUCED_DEBOUNCE | HV_BUTTON_FROM_GD);
-	if (chip->hv_quirk)
-		n |= chip->hv_quirk->config;
+	n |= chip->hv_config;
 	/* For some reason we must always use reduced debounce. */
 	n |= REDUCED_DEBOUNCE;
 	n |= PM_CTRL_ENABLE | CLK_DIV_BY_49 | USE_PCI_TIMING;
@@ -2511,7 +2508,7 @@
 
 	/* TODO: MPU401 not supported yet */
 	val = ASSP_INT_ENABLE /*| MPU401_INT_ENABLE*/;
-	if (chip->hv_quirk && (chip->hv_quirk->config & HV_CTRL_ENABLE))
+	if (chip->hv_config & HV_CTRL_ENABLE)
 		val |= HV_INT_ENABLE;
 	outw(val, io + HOST_INT_CTRL);
 	outb(inb(io + ASSP_CONTROL_C) | ASSP_HOST_INT_ENABLE,
@@ -2554,6 +2551,15 @@
 	if (chip->iobase)
 		pci_release_regions(chip->pci);
 
+#ifdef FIRMWARE_IN_THE_KERNEL
+	if (chip->assp_kernel_image != &assp_kernel)
+#endif
+		release_firmware(chip->assp_kernel_image);
+#ifdef FIRMWARE_IN_THE_KERNEL
+	if (chip->assp_minisrc_image != &assp_minisrc)
+#endif
+		release_firmware(chip->assp_minisrc_image);
+
 	pci_disable_device(chip->pci);
 	kfree(chip);
 	return 0;
@@ -2590,12 +2596,9 @@
 		chip->suspend_mem[index++] = 
 			snd_m3_assp_read(chip, MEMTYPE_INTERNAL_DATA, i);
 
-	/* power down apci registers */
-	snd_m3_outw(chip, 0xffff, 0x54);
-	snd_m3_outw(chip, 0xffff, 0x56);
-
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2608,8 +2611,14 @@
 	if (chip->suspend_mem == NULL)
 		return 0;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "maestor3: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	/* first lets just bring everything back. .*/
@@ -2663,8 +2672,7 @@
 {
 	struct snd_m3 *chip;
 	int i, err;
-	const struct m3_quirk *quirk;
-	const struct m3_hv_quirk *hv_quirk;
+	const struct snd_pci_quirk *quirk;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_m3_dev_free,
 	};
@@ -2704,34 +2712,32 @@
 	chip->pci = pci;
 	chip->irq = -1;
 
-	for (quirk = m3_quirk_list; quirk->vendor; quirk++) {
-		if (pci->subsystem_vendor == quirk->vendor &&
-		    pci->subsystem_device == quirk->device) {
-			printk(KERN_INFO "maestro3: enabled hack for '%s'\n", quirk->name);
-			chip->quirk = quirk;
-			break;
-		}
-	}
-
-	for (hv_quirk = m3_hv_quirk_list; hv_quirk->vendor; hv_quirk++) {
-		if (pci->vendor == hv_quirk->vendor &&
-		    pci->device == hv_quirk->device &&
-		    pci->subsystem_vendor == hv_quirk->subsystem_vendor &&
-		    pci->subsystem_device == hv_quirk->subsystem_device) {
-			chip->hv_quirk = hv_quirk;
-			break;
-		}
-	}
-
 	chip->external_amp = enable_amp;
 	if (amp_gpio >= 0 && amp_gpio <= 0x0f)
 		chip->amp_gpio = amp_gpio;
-	else if (chip->quirk && chip->quirk->amp_gpio >= 0)
-		chip->amp_gpio = chip->quirk->amp_gpio;
-	else if (chip->allegro_flag)
-		chip->amp_gpio = GPO_EXT_AMP_ALLEGRO;
-	else /* presumably this is for all 'maestro3's.. */
-		chip->amp_gpio = GPO_EXT_AMP_M3;
+	else {
+		quirk = snd_pci_quirk_lookup(pci, m3_amp_quirk_list);
+		if (quirk) {
+			snd_printdd(KERN_INFO "maestro3: set amp-gpio "
+				    "for '%s'\n", quirk->name);
+			chip->amp_gpio = quirk->value;
+		} else if (chip->allegro_flag)
+			chip->amp_gpio = GPO_EXT_AMP_ALLEGRO;
+		else /* presumably this is for all 'maestro3's.. */
+			chip->amp_gpio = GPO_EXT_AMP_M3;
+	}
+
+	quirk = snd_pci_quirk_lookup(pci, m3_irda_quirk_list);
+	if (quirk) {
+		snd_printdd(KERN_INFO "maestro3: enabled irda workaround "
+			    "for '%s'\n", quirk->name);
+		chip->irda_workaround = 1;
+	}
+	quirk = snd_pci_quirk_lookup(pci, m3_hv_quirk_list);
+	if (quirk)
+		chip->hv_config = quirk->value;
+	if (snd_pci_quirk_lookup(pci, m3_omnibook_quirk_list))
+		chip->is_omnibook = 1;
 
 	chip->num_substreams = NR_DSPS;
 	chip->substreams = kcalloc(chip->num_substreams, sizeof(struct m3_dma),
@@ -2742,6 +2748,30 @@
 		return -ENOMEM;
 	}
 
+	err = request_firmware(&chip->assp_kernel_image,
+			       "ess/maestro3_assp_kernel.fw", &pci->dev);
+	if (err < 0) {
+#ifdef FIRMWARE_IN_THE_KERNEL
+		chip->assp_kernel_image = &assp_kernel;
+#else
+		snd_m3_free(chip);
+		return err;
+#endif
+	} else
+		snd_m3_convert_from_le(chip->assp_kernel_image);
+
+	err = request_firmware(&chip->assp_minisrc_image,
+			       "ess/maestro3_assp_minisrc.fw", &pci->dev);
+	if (err < 0) {
+#ifdef FIRMWARE_IN_THE_KERNEL
+		chip->assp_minisrc_image = &assp_minisrc;
+#else
+		snd_m3_free(chip);
+		return err;
+#endif
+	} else
+		snd_m3_convert_from_le(chip->assp_minisrc_image);
+
 	if ((err = pci_request_regions(pci, card->driver)) < 0) {
 		snd_m3_free(chip);
 		return err;
--- linux-2.6.18.noarch/sound/pci/sonicvibes.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/sonicvibes.c	2007-06-05 17:47:00.000000000 -0400
@@ -1195,7 +1195,7 @@
 	pci_write_config_dword(sonic->pci, 0x40, sonic->dmaa_port);
 	pci_write_config_dword(sonic->pci, 0x48, sonic->dmac_port);
 	if (sonic->irq >= 0)
-		free_irq(sonic->irq, (void *)sonic);
+		free_irq(sonic->irq, sonic);
 	release_and_free_resource(sonic->res_dmaa);
 	release_and_free_resource(sonic->res_dmac);
 	pci_release_regions(sonic->pci);
--- linux-2.6.18.noarch/sound/pci/emu10k1/voice.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/voice.c	2007-06-05 17:46:26.000000000 -0400
@@ -83,7 +83,7 @@
 	if (first_voice == last_voice)
 		return -ENOMEM;
 	
-	for (i=0; i < number; i++) {
+	for (i = 0; i < number; i++) {
 		voice = &emu->voices[(first_voice + i) % NUM_G];
 		// printk("voice alloc - %i, %i of %i\n", voice->number, idx-first_voice+1, number);
 		voice->use = 1;
--- linux-2.6.18.noarch/sound/pci/emu10k1/p17v.h.orig	2007-06-05 16:46:41.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/p17v.h	2007-06-05 17:46:26.000000000 -0400
@@ -43,6 +43,53 @@
 #define P17V_I2C_ADDR		0x3d	/* I2C Address */
 #define P17V_I2C_0		0x3e	/* I2C Data */
 #define P17V_I2C_1		0x3f	/* I2C Data */
+/* I2C values */
+#define I2C_A_ADC_ADD_MASK	0x000000fe	/*The address is a 7 bit address */
+#define I2C_A_ADC_RW_MASK	0x00000001	/*bit mask for R/W */
+#define I2C_A_ADC_TRANS_MASK	0x00000010  	/*Bit mask for I2c address DAC value  */
+#define I2C_A_ADC_ABORT_MASK	0x00000020	/*Bit mask for I2C transaction abort flag */
+#define I2C_A_ADC_LAST_MASK	0x00000040	/*Bit mask for Last word transaction */
+#define I2C_A_ADC_BYTE_MASK	0x00000080	/*Bit mask for Byte Mode */
+
+#define I2C_A_ADC_ADD		0x00000034	/*This is the Device address for ADC  */
+#define I2C_A_ADC_READ		0x00000001	/*To perform a read operation */
+#define I2C_A_ADC_START		0x00000100	/*Start I2C transaction */
+#define I2C_A_ADC_ABORT		0x00000200	/*I2C transaction abort */
+#define I2C_A_ADC_LAST		0x00000400	/*I2C last transaction */
+#define I2C_A_ADC_BYTE		0x00000800	/*I2C one byte mode */
+
+#define I2C_D_ADC_REG_MASK	0xfe000000  	/*ADC address register */ 
+#define I2C_D_ADC_DAT_MASK	0x01ff0000  	/*ADC data register */
+
+#define ADC_TIMEOUT		0x00000007	/*ADC Timeout Clock Disable */
+#define ADC_IFC_CTRL		0x0000000b	/*ADC Interface Control */
+#define ADC_MASTER		0x0000000c	/*ADC Master Mode Control */
+#define ADC_POWER		0x0000000d	/*ADC PowerDown Control */
+#define ADC_ATTEN_ADCL		0x0000000e	/*ADC Attenuation ADCL */
+#define ADC_ATTEN_ADCR		0x0000000f	/*ADC Attenuation ADCR */
+#define ADC_ALC_CTRL1		0x00000010	/*ADC ALC Control 1 */
+#define ADC_ALC_CTRL2		0x00000011	/*ADC ALC Control 2 */
+#define ADC_ALC_CTRL3		0x00000012	/*ADC ALC Control 3 */
+#define ADC_NOISE_CTRL		0x00000013	/*ADC Noise Gate Control */
+#define ADC_LIMIT_CTRL		0x00000014	/*ADC Limiter Control */
+#define ADC_MUX			0x00000015  	/*ADC Mux offset */
+#if 0
+/* FIXME: Not tested yet. */
+#define ADC_GAIN_MASK		0x000000ff	//Mask for ADC Gain
+#define ADC_ZERODB		0x000000cf	//Value to set ADC to 0dB
+#define ADC_MUTE_MASK		0x000000c0	//Mask for ADC mute
+#define ADC_MUTE		0x000000c0	//Value to mute ADC
+#define ADC_OSR			0x00000008	//Mask for ADC oversample rate select
+#define ADC_TIMEOUT_DISABLE	0x00000008	//Value and mask to disable Timeout clock
+#define ADC_HPF_DISABLE		0x00000100	//Value and mask to disable High pass filter
+#define ADC_TRANWIN_MASK	0x00000070	//Mask for Length of Transient Window
+#endif
+
+#define ADC_MUX_MASK		0x0000000f	//Mask for ADC Mux
+#define ADC_MUX_0		0x00000001	//Value to select Unknown at ADC Mux (Not used)
+#define ADC_MUX_1		0x00000002	//Value to select Unknown at ADC Mux (Not used)
+#define ADC_MUX_2		0x00000004	//Value to select Mic at ADC Mux
+#define ADC_MUX_3		0x00000008	//Value to select Line-In at ADC Mux
 
 #define P17V_START_AUDIO	0x40	/* Start Audio bit */
 /* 41 - 47: Reserved */
--- linux-2.6.18.noarch/sound/pci/emu10k1/emu10k1.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emu10k1.c	2007-06-05 17:46:25.000000000 -0400
@@ -226,22 +226,27 @@
 
 	snd_emu10k1_done(emu);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
-int snd_emu10k1_resume(struct pci_dev *pci)
+static int snd_emu10k1_resume(struct pci_dev *pci)
 {
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_emu10k1 *emu = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "emu10k1: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
-	
+
 	snd_emu10k1_resume_init(emu);
 	snd_emu10k1_efx_resume(emu);
 	snd_ac97_resume(emu->ac97);
--- linux-2.6.18.noarch/sound/pci/emu10k1/emu10k1x.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emu10k1x.c	2007-06-05 17:46:25.000000000 -0400
@@ -235,7 +235,7 @@
 	struct resource *res_port;
 	int irq;
 
-	unsigned int revision;		/* chip revision */
+	unsigned char revision;		/* chip revision */
 	unsigned int serial;            /* serial number */
 	unsigned short model;		/* subsystem id */
 
@@ -460,7 +460,7 @@
 	u32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);
 	int i;
 	
-	for(i=0; i < runtime->periods; i++) {
+	for(i = 0; i < runtime->periods; i++) {
 		*table_base++=runtime->dma_addr+(i*period_size_bytes);
 		*table_base++=period_size_bytes<<16;
 	}
@@ -760,7 +760,7 @@
 
 	// release the irq
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 
 	// release the DMA
 	if (chip->dma_buffer.area) {
@@ -944,7 +944,7 @@
 
 	pci_set_master(pci);
 	/* read revision & serial */
-	pci_read_config_byte(pci, PCI_REVISION_ID, (char *)&chip->revision);
+	pci_read_config_byte(pci, PCI_REVISION_ID, &chip->revision);
 	pci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);
 	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);
 	snd_printk(KERN_INFO "Model %04x Rev %08x Serial %08x\n", chip->model,
@@ -1044,8 +1044,8 @@
 		if (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)
 			continue;
 
-		if ((reg < 0x49) && (reg >=0) && (val <= 0xffffffff) 
-		    && (channel_id >=0) && (channel_id <= 2) )
+		if ((reg < 0x49) && (reg >= 0) && (val <= 0xffffffff) 
+		    && (channel_id >= 0) && (channel_id <= 2) )
 			snd_emu10k1x_ptr_write(emu, reg, channel_id, val);
 	}
 }
@@ -1626,12 +1626,7 @@
 // initialization of the module
 static int __init alsa_card_emu10k1x_init(void)
 {
-	int err;
-
-	if ((err = pci_register_driver(&driver)) > 0)
-		return err;
-
-	return 0;
+	return pci_register_driver(&driver);
 }
 
 // clean up the module
--- linux-2.6.18.noarch/sound/pci/emu10k1/emufx.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emufx.c	2007-06-05 17:46:26.000000000 -0400
@@ -3,6 +3,9 @@
  *                   Creative Labs, Inc.
  *  Routines for effect processor FX8010
  *
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
+ *  	Added EMU 1010 support.
+ *
  *  BUGS:
  *    --
  *
@@ -35,6 +38,7 @@
 #include <linux/mutex.h>
 
 #include <sound/core.h>
+#include <sound/tlv.h>
 #include <sound/emu10k1.h>
 
 #if 0		/* for testing purposes - digital out -> capture */
@@ -266,6 +270,7 @@
 	{ 0x37c4448b, 0xa45ef51d, 0x262f3267, 0x081e36dc, 0xfd8f5d14 }
 };
 
+/* dB gain = (float) 20 * log10( float(db_table_value) / 0x8000000 ) */
 static const u32 db_table[101] = {
 	0x00000000, 0x01571f82, 0x01674b41, 0x01783a1b, 0x0189f540,
 	0x019c8651, 0x01aff763, 0x01c45306, 0x01d9a446, 0x01eff6b8,
@@ -290,6 +295,9 @@
 	0x7fffffff,
 };
 
+/* EMU10k1/EMU10k2 DSP control db gain */
+static const DECLARE_TLV_DB_SCALE(snd_emu10k1_db_scale1, -4000, 40, 1);
+
 static const u32 onoff_table[2] = {
 	0x00000000, 0x00000001
 };
@@ -647,13 +655,66 @@
 	return NULL;
 }
 
+#define MAX_TLV_SIZE	256
+
+static unsigned int *copy_tlv(const unsigned int __user *_tlv)
+{
+	unsigned int data[2];
+	unsigned int *tlv;
+
+	if (!_tlv)
+		return NULL;
+	if (copy_from_user(data, _tlv, sizeof(data)))
+		return NULL;
+	if (data[1] >= MAX_TLV_SIZE)
+		return NULL;
+	tlv = kmalloc(data[1] * 4 + sizeof(data), GFP_KERNEL);
+	if (!tlv)
+		return NULL;
+	memcpy(tlv, data, sizeof(data));
+	if (copy_from_user(tlv + 2, _tlv + 2, data[1])) {
+		kfree(tlv);
+		return NULL;
+	}
+	return tlv;
+}
+
+static int copy_gctl(struct snd_emu10k1 *emu,
+		     struct snd_emu10k1_fx8010_control_gpr *gctl,
+		     struct snd_emu10k1_fx8010_control_gpr __user *_gctl,
+		     int idx)
+{
+	struct snd_emu10k1_fx8010_control_old_gpr __user *octl;
+
+	if (emu->support_tlv)
+		return copy_from_user(gctl, &_gctl[idx], sizeof(*gctl));
+	octl = (struct snd_emu10k1_fx8010_control_old_gpr __user *)_gctl;
+	if (copy_from_user(gctl, &octl[idx], sizeof(*octl)))
+		return -EFAULT;
+	gctl->tlv = NULL;
+	return 0;
+}
+
+static int copy_gctl_to_user(struct snd_emu10k1 *emu,
+		     struct snd_emu10k1_fx8010_control_gpr __user *_gctl,
+		     struct snd_emu10k1_fx8010_control_gpr *gctl,
+		     int idx)
+{
+	struct snd_emu10k1_fx8010_control_old_gpr __user *octl;
+
+	if (emu->support_tlv)
+		return copy_to_user(&_gctl[idx], gctl, sizeof(*gctl));
+	
+	octl = (struct snd_emu10k1_fx8010_control_old_gpr __user *)_gctl;
+	return copy_to_user(&octl[idx], gctl, sizeof(*octl));
+}
+
 static int snd_emu10k1_verify_controls(struct snd_emu10k1 *emu,
 				       struct snd_emu10k1_fx8010_code *icode)
 {
 	unsigned int i;
 	struct snd_ctl_elem_id __user *_id;
 	struct snd_ctl_elem_id id;
-	struct snd_emu10k1_fx8010_control_gpr __user *_gctl;
 	struct snd_emu10k1_fx8010_control_gpr *gctl;
 	int err;
 	
@@ -668,9 +729,8 @@
 	if (! gctl)
 		return -ENOMEM;
 	err = 0;
-	for (i = 0, _gctl = icode->gpr_add_controls;
-	     i < icode->gpr_add_control_count; i++, _gctl++) {
-		if (copy_from_user(gctl, _gctl, sizeof(*gctl))) {
+	for (i = 0; i < icode->gpr_add_control_count; i++) {
+		if (copy_gctl(emu, gctl, icode->gpr_add_controls, i)) {
 			err = -EFAULT;
 			goto __error;
 		}
@@ -689,10 +749,9 @@
 			goto __error;
 		}
 	}
-	for (i = 0, _gctl = icode->gpr_list_controls;
-	     i < icode->gpr_list_control_count; i++, _gctl++) {
+	for (i = 0; i < icode->gpr_list_control_count; i++) {
 	     	/* FIXME: we need to check the WRITE access */
-		if (copy_from_user(gctl, _gctl, sizeof(*gctl))) {
+		if (copy_gctl(emu, gctl, icode->gpr_list_controls, i)) {
 			err = -EFAULT;
 			goto __error;
 		}
@@ -710,13 +769,14 @@
 	kctl->private_value = 0;
 	list_del(&ctl->list);
 	kfree(ctl);
+	if (kctl->tlv.p)
+		kfree(kctl->tlv.p);
 }
 
 static int snd_emu10k1_add_controls(struct snd_emu10k1 *emu,
 				    struct snd_emu10k1_fx8010_code *icode)
 {
 	unsigned int i, j;
-	struct snd_emu10k1_fx8010_control_gpr __user *_gctl;
 	struct snd_emu10k1_fx8010_control_gpr *gctl;
 	struct snd_emu10k1_fx8010_ctl *ctl, *nctl;
 	struct snd_kcontrol_new knew;
@@ -732,9 +792,8 @@
 		goto __error;
 	}
 
-	for (i = 0, _gctl = icode->gpr_add_controls;
-	     i < icode->gpr_add_control_count; i++, _gctl++) {
-		if (copy_from_user(gctl, _gctl, sizeof(*gctl))) {
+	for (i = 0; i < icode->gpr_add_control_count; i++) {
+		if (copy_gctl(emu, gctl, icode->gpr_add_controls, i)) {
 			err = -EFAULT;
 			goto __error;
 		}
@@ -755,6 +814,10 @@
 		knew.device = gctl->id.device;
 		knew.subdevice = gctl->id.subdevice;
 		knew.info = snd_emu10k1_gpr_ctl_info;
+		knew.tlv.p = copy_tlv(gctl->tlv);
+		if (knew.tlv.p)
+			knew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+				SNDRV_CTL_ELEM_ACCESS_TLV_READ;
 		knew.get = snd_emu10k1_gpr_ctl_get;
 		knew.put = snd_emu10k1_gpr_ctl_put;
 		memset(nctl, 0, sizeof(*nctl));
@@ -772,12 +835,14 @@
 			ctl = kmalloc(sizeof(*ctl), GFP_KERNEL);
 			if (ctl == NULL) {
 				err = -ENOMEM;
+				kfree(knew.tlv.p);
 				goto __error;
 			}
 			knew.private_value = (unsigned long)ctl;
 			*ctl = *nctl;
 			if ((err = snd_ctl_add(emu->card, kctl = snd_ctl_new1(&knew, emu))) < 0) {
 				kfree(ctl);
+				kfree(knew.tlv.p);
 				goto __error;
 			}
 			kctl->private_free = snd_emu10k1_ctl_private_free;
@@ -828,7 +893,6 @@
 	unsigned int i = 0, j;
 	unsigned int total = 0;
 	struct snd_emu10k1_fx8010_control_gpr *gctl;
-	struct snd_emu10k1_fx8010_control_gpr __user *_gctl;
 	struct snd_emu10k1_fx8010_ctl *ctl;
 	struct snd_ctl_elem_id *id;
 	struct list_head *list;
@@ -837,11 +901,11 @@
 	if (! gctl)
 		return -ENOMEM;
 
-	_gctl = icode->gpr_list_controls;	
 	list_for_each(list, &emu->fx8010.gpr_ctl) {
 		ctl = emu10k1_gpr_ctl(list);
 		total++;
-		if (_gctl && i < icode->gpr_list_control_count) {
+		if (icode->gpr_list_controls &&
+		    i < icode->gpr_list_control_count) {
 			memset(gctl, 0, sizeof(*gctl));
 			id = &ctl->kcontrol->id;
 			gctl->id.iface = id->iface;
@@ -858,11 +922,11 @@
 			gctl->min = ctl->min;
 			gctl->max = ctl->max;
 			gctl->translation = ctl->translation;
-			if (copy_to_user(_gctl, gctl, sizeof(*gctl))) {
+			if (copy_gctl_to_user(emu, icode->gpr_list_controls,
+					      gctl, i)) {
 				kfree(gctl);
 				return -EFAULT;
 			}
-			_gctl++;
 			i++;
 		}
 	}
@@ -1013,6 +1077,7 @@
 	ctl->gpr[0] = gpr + 0; ctl->value[0] = defval;
 	ctl->min = 0;
 	ctl->max = 100;
+	ctl->tlv = snd_emu10k1_db_scale1;
 	ctl->translation = EMU10K1_GPR_TRANSLATION_TABLE100;	
 }
 
@@ -1027,6 +1092,7 @@
 	ctl->gpr[1] = gpr + 1; ctl->value[1] = defval;
 	ctl->min = 0;
 	ctl->max = 100;
+	ctl->tlv = snd_emu10k1_db_scale1;
 	ctl->translation = EMU10K1_GPR_TRANSLATION_TABLE100;
 }
 
@@ -1057,6 +1123,21 @@
 	ctl->translation = EMU10K1_GPR_TRANSLATION_ONOFF;
 }
 
+static int snd_emu10k1_audigy_dsp_convert_32_to_2x16(
+				struct snd_emu10k1_fx8010_code *icode,
+				u32 *ptr, int tmp, int bit_shifter16,
+				int reg_in, int reg_out)
+{
+	A_OP(icode, ptr, iACC3, A_GPR(tmp + 1), reg_in, A_C_00000000, A_C_00000000);
+	A_OP(icode, ptr, iANDXOR, A_GPR(tmp), A_GPR(tmp + 1), A_GPR(bit_shifter16 - 1), A_C_00000000);
+	A_OP(icode, ptr, iTSTNEG, A_GPR(tmp + 2), A_GPR(tmp), A_C_80000000, A_GPR(bit_shifter16 - 2));
+	A_OP(icode, ptr, iANDXOR, A_GPR(tmp + 2), A_GPR(tmp + 2), A_C_80000000, A_C_00000000);
+	A_OP(icode, ptr, iANDXOR, A_GPR(tmp), A_GPR(tmp), A_GPR(bit_shifter16 - 3), A_C_00000000);
+	A_OP(icode, ptr, iMACINT0, A_GPR(tmp), A_C_00000000, A_GPR(tmp), A_C_00010000);
+	A_OP(icode, ptr, iANDXOR, reg_out, A_GPR(tmp), A_C_ffffffff, A_GPR(tmp + 2));
+	A_OP(icode, ptr, iACC3, reg_out + 1, A_GPR(tmp + 1), A_C_00000000, A_C_00000000);
+	return 1;
+}
 
 /*
  * initial DSP configuration for Audigy
@@ -1065,6 +1146,7 @@
 static int __devinit _snd_emu10k1_audigy_init_efx(struct snd_emu10k1 *emu)
 {
 	int err, i, z, gpr, nctl;
+	int bit_shifter16;
 	const int playback = 10;
 	const int capture = playback + (SND_EMU10K1_PLAYBACK_CHANNELS * 2); /* we reserve 10 voices */
 	const int stereo_mix = capture + 2;
@@ -1102,17 +1184,14 @@
 	ptr = 0;
 	nctl = 0;
 	gpr = stereo_mix + 10;
+	gpr_map[gpr++] = 0x00007fff;
+	gpr_map[gpr++] = 0x00008000;
+	gpr_map[gpr++] = 0x0000ffff;
+	bit_shifter16 = gpr;
 
 	/* stop FX processor */
 	snd_emu10k1_ptr_write(emu, A_DBG, 0, (emu->fx8010.dbg = 0) | A_DBG_SINGLE_STEP);
 
-#if 0
-	/* FIX: jcd test */
-	for (z = 0; z < 80; z=z+2) {
-		A_OP(icode, &ptr, iACC3, A_EXTOUT(z), A_FXBUS(FXBUS_PCM_LEFT_FRONT), A_C_00000000, A_C_00000000); /* left */
-		A_OP(icode, &ptr, iACC3, A_EXTOUT(z+1), A_FXBUS(FXBUS_PCM_RIGHT_FRONT), A_C_00000000, A_C_00000000); /* right */
-	}
-#endif /* jcd test */
 #if 1
 	/* PCM front Playback Volume (independent from stereo mix) */
 	A_OP(icode, &ptr, iMAC0, A_GPR(playback), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_FRONT));
@@ -1170,13 +1249,20 @@
 	A_OP(icode, &ptr, iMAC0, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+1), A_FXBUS(FXBUS_MIDI_RIGHT));
 	snd_emu10k1_init_stereo_control(&controls[nctl++], "Synth Capture Volume", gpr, 0);
 	gpr += 2;
-
+      
 	/*
 	 * inputs
 	 */
 #define A_ADD_VOLUME_IN(var,vol,input) \
 A_OP(icode, &ptr, iMAC0, A_GPR(var), A_GPR(var), A_GPR(vol), A_EXTIN(input))
 
+	/* emu1212 DSP 0 and DSP 1 Capture */
+	if (emu->card_capabilities->emu1010) {
+		A_OP(icode, &ptr, iMAC0, A_GPR(capture+0), A_GPR(capture+0), A_GPR(gpr), A_P16VIN(0x0));
+		A_OP(icode, &ptr, iMAC0, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+1), A_P16VIN(0x1));
+		snd_emu10k1_init_stereo_control(&controls[nctl++], "EMU Capture Volume", gpr, 0);
+		gpr += 2;
+	}
 	/* AC'97 Playback Volume - used only for mic (renamed later) */
 	A_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_AC97_L);
 	A_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_AC97_R);
@@ -1417,6 +1503,13 @@
 
 	/* digital outputs */
 	/* A_PUT_STEREO_OUTPUT(A_EXTOUT_FRONT_L, A_EXTOUT_FRONT_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS); */
+	if (emu->card_capabilities->emu1010) {
+		/* EMU1010 Outputs from PCM Front, Rear, Center, LFE, Side */
+		snd_printk("EMU outputs on\n");
+		for (z = 0; z < 8; z++) {
+			A_OP(icode, &ptr, iACC3, A_EMU32OUTL(z), A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + z), A_C_00000000, A_C_00000000);
+		}
+	}
 
 	/* IEC958 Optical Raw Playback Switch */ 
 	gpr_map[gpr++] = 0;
@@ -1454,9 +1547,57 @@
 	A_PUT_OUTPUT(A_EXTOUT_ADC_CAP_R, capture+1);
 #endif
 
-	/* EFX capture - capture the 16 EXTINs */
-	for (z = 0; z < 16; z++) {
-		A_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_EXTIN(z));
+	if (emu->card_capabilities->emu1010) {
+		snd_printk("EMU inputs on\n");
+		/* Capture 8 channels of S32_LE sound */
+		
+		/* printk("emufx.c: gpr=0x%x, tmp=0x%x\n",gpr, tmp); */
+		/* For the EMU1010: How to get 32bit values from the DSP. High 16bits into L, low 16bits into R. */
+		/* A_P16VIN(0) is delayed by one sample,
+		 * so all other A_P16VIN channels will need to also be delayed
+		 */
+		/* Left ADC in. 1 of 2 */
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_P16VIN(0x0), A_FXBUS2(0) );
+		/* Right ADC in 1 of 2 */
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(2) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x1), A_C_00000000, A_C_00000000);
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(4) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x2), A_C_00000000, A_C_00000000);
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(6) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x3), A_C_00000000, A_C_00000000);
+		/* For 96kHz mode */
+		/* Left ADC in. 2 of 2 */
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0x8) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x4), A_C_00000000, A_C_00000000);
+		/* Right ADC in 2 of 2 */
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0xa) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x5), A_C_00000000, A_C_00000000);
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0xc) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x6), A_C_00000000, A_C_00000000);
+		gpr_map[gpr++] = 0x00000000;
+		snd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0xe) );
+		A_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x7), A_C_00000000, A_C_00000000);
+
+#if 0
+		for (z = 4; z < 8; z++) {
+			A_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_C_00000000);
+		}
+		for (z = 0xc; z < 0x10; z++) {
+			A_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_C_00000000);
+		}
+#endif
+	} else {
+		/* EFX capture - capture the 16 EXTINs */
+		/* Capture 16 channels of S16_LE sound */
+		for (z = 0; z < 16; z++) {
+			A_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_EXTIN(z));
+		}
 	}
 	
 #endif /* JCD test */
@@ -1476,7 +1617,9 @@
 	seg = snd_enter_user();
 	icode->gpr_add_control_count = nctl;
 	icode->gpr_add_controls = (struct snd_emu10k1_fx8010_control_gpr __user *)controls;
+	emu->support_tlv = 1; /* support TLV */
 	err = snd_emu10k1_icode_poke(emu, icode);
+	emu->support_tlv = 0; /* clear again */
 	snd_leave_user(seg);
 
  __err:
@@ -2093,7 +2236,9 @@
 	seg = snd_enter_user();
 	icode->gpr_add_control_count = i;
 	icode->gpr_add_controls = (struct snd_emu10k1_fx8010_control_gpr __user *)controls;
+	emu->support_tlv = 1; /* support TLV */
 	err = snd_emu10k1_icode_poke(emu, icode);
+	emu->support_tlv = 0; /* clear again */
 	snd_leave_user(seg);
 	if (err >= 0)
 		err = snd_emu10k1_ipcm_poke(emu, ipcm);
@@ -2126,7 +2271,7 @@
 		snd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg = EMU10K1_DBG_SINGLE_STEP);
 }
 
-#if 0 // FIXME: who use them?
+#if 0 /* FIXME: who use them? */
 int snd_emu10k1_fx8010_tone_control_activate(struct snd_emu10k1 *emu, int output)
 {
 	if (output < 0 || output >= 6)
@@ -2237,6 +2382,9 @@
 	int res;
 	
 	switch (cmd) {
+	case SNDRV_EMU10K1_IOCTL_PVERSION:
+		emu->support_tlv = 1;
+		return put_user(SNDRV_EMU10K1_VERSION, (int __user *)argp);
 	case SNDRV_EMU10K1_IOCTL_INFO:
 		info = kmalloc(sizeof(*info), GFP_KERNEL);
 		if (!info)
--- linux-2.6.18.noarch/sound/pci/emu10k1/p16v.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/p16v.c	2007-06-05 17:46:26.000000000 -0400
@@ -100,6 +100,7 @@
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
+#include <sound/tlv.h>
 #include <sound/emu10k1.h>
 #include "p16v.h"
 
@@ -252,7 +253,7 @@
 	struct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);
 	//struct snd_pcm_runtime *runtime = substream->runtime;
 	//struct snd_emu10k1_pcm *epcm = runtime->private_data;
-	emu->p16v_voices[substream->pcm->device - emu->p16v_device_offset].use=0;
+	emu->p16v_voices[substream->pcm->device - emu->p16v_device_offset].use = 0;
 	/* FIXME: maybe zero others */
 	return 0;
 }
@@ -263,7 +264,7 @@
 	struct snd_emu10k1 *emu = snd_pcm_substream_chip(substream);
 	//struct snd_pcm_runtime *runtime = substream->runtime;
 	//struct snd_emu10k1_pcm *epcm = runtime->private_data;
-	emu->p16v_capture_voice.use=0;
+	emu->p16v_capture_voice.use = 0;
 	/* FIXME: maybe zero others */
 	return 0;
 }
@@ -348,7 +349,7 @@
 	  break;
 	}
 	/* FIXME: Check emu->buffer.size before actually writing to it. */
-	for(i=0; i < runtime->periods; i++) {
+	for(i = 0; i < runtime->periods; i++) {
 		table_base[i*2]=runtime->dma_addr+(i*period_size_bytes);
 		table_base[(i*2)+1]=period_size_bytes<<16;
 	}
@@ -393,7 +394,7 @@
 	/* FIXME: Check emu->buffer.size before actually writing to it. */
 	snd_emu10k1_ptr20_write(emu, 0x13, channel, 0);
 	snd_emu10k1_ptr20_write(emu, CAPTURE_DMA_ADDR, channel, runtime->dma_addr);
-	snd_emu10k1_ptr20_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size)<<16); // buffer size in bytes
+	snd_emu10k1_ptr20_write(emu, CAPTURE_BUFFER_SIZE, channel, frames_to_bytes(runtime, runtime->buffer_size) << 16); // buffer size in bytes
 	snd_emu10k1_ptr20_write(emu, CAPTURE_POINTER, channel, 0);
 	//snd_emu10k1_ptr20_write(emu, CAPTURE_SOURCE, 0x0, 0x333300e4); /* Select MIC or Line in */
 	//snd_emu10k1_ptr20_write(emu, EXTENDED_INT_MASK, 0, snd_emu10k1_ptr20_read(emu, EXTENDED_INT_MASK, 0) | (0x110000<<channel));
@@ -436,7 +437,7 @@
         struct snd_pcm_substream *s;
 	u32 basic = 0;
 	u32 inte = 0;
-	int running=0;
+	int running = 0;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -444,7 +445,7 @@
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	default:
-		running=0;
+		running = 0;
 		break;
 	}
         snd_pcm_group_for_each(pos, substream) {
@@ -784,12 +785,16 @@
 	}
         return change;
 }
+static const DECLARE_TLV_DB_SCALE(snd_p16v_db_scale1, -5175, 25, 1);
 
 #define P16V_VOL(xname,xreg,xhl) { \
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |             \
+                  SNDRV_CTL_ELEM_ACCESS_TLV_READ,               \
 	.info = snd_p16v_volume_info, \
 	.get = snd_p16v_volume_get, \
 	.put = snd_p16v_volume_put, \
+	.tlv = { .p = snd_p16v_db_scale1 },	\
 	.private_value = ((xreg) | ((xhl) << 8)) \
 }
 
--- linux-2.6.18.noarch/sound/pci/emu10k1/emuproc.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emuproc.c	2007-06-05 17:46:26.000000000 -0400
@@ -3,6 +3,9 @@
  *                   Creative Labs, Inc.
  *  Routines for control of EMU10K1 chips / proc interface routines
  *
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
+ *  	Added EMU 1010 support.
+ *
  *  BUGS:
  *    --
  *
@@ -255,7 +258,7 @@
 	unsigned int val, tmp, n;
 	val = snd_emu10k1_ptr20_read(emu, CAPTURE_RATE_STATUS, 0);
 	tmp = (val >> 16) & 0x8;
-	for (n=0;n<4;n++) {
+	for (n = 0; n < 4; n++) {
 		tmp = val >> (16 + (n*4));
 		if (tmp & 0x8) snd_iprintf(buffer, "Channel %d: Rate=%d\n", n, samplerate[tmp & 0x7]);
 		else snd_iprintf(buffer, "Channel %d: No input\n", n);
@@ -372,6 +375,27 @@
 }
 
 #ifdef CONFIG_SND_DEBUG
+static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,
+				     struct snd_info_buffer *buffer)
+{
+	struct snd_emu10k1 *emu = entry->private_data;
+	unsigned long value;
+	unsigned long flags;
+	unsigned long regs;
+	int i;
+	snd_iprintf(buffer, "EMU1010 Registers:\n\n");
+
+	for(i = 0; i < 0x30; i+=1) {
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		regs=i+0x40; /* 0x40 upwards are registers. */
+		outl(regs, emu->port + A_IOCFG);
+		outl(regs | 0x80, emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
+		value = inl(emu->port + A_IOCFG);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+		snd_iprintf(buffer, "%02X: %08lX, %02lX\n", i, value, (value >> 8) & 0x7f);
+	}
+}
+
 static void snd_emu_proc_io_reg_read(struct snd_info_entry *entry,
 				     struct snd_info_buffer *buffer)
 {
@@ -398,7 +422,7 @@
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
 		if (sscanf(line, "%x %x", &reg, &val) != 2)
 			continue;
-		if ((reg < 0x40) && (reg >=0) && (val <= 0xffffffff) ) {
+		if ((reg < 0x40) && (reg >= 0) && (val <= 0xffffffff) ) {
 			spin_lock_irqsave(&emu->emu_lock, flags);
 			outl(val, emu->port + (reg & 0xfffffffc));
 			spin_unlock_irqrestore(&emu->emu_lock, flags);
@@ -474,7 +498,7 @@
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
 		if (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)
 			continue;
-		if ((reg < 0xa0) && (reg >=0) && (val <= 0xffffffff) && (channel_id >=0) && (channel_id <= 3) )
+		if ((reg < 0xa0) && (reg >= 0) && (val <= 0xffffffff) && (channel_id >= 0) && (channel_id <= 3) )
 			snd_ptr_write(emu, iobase, reg, channel_id, val);
 	}
 }
@@ -531,6 +555,10 @@
 {
 	struct snd_info_entry *entry;
 #ifdef CONFIG_SND_DEBUG
+	if ((emu->card_capabilities->emu1010) &&
+	     snd_card_proc_new(emu->card, "emu1010_regs", &entry)) {
+		snd_info_set_text_ops(entry, emu, snd_emu_proc_emu1010_reg_read);
+	}
 	if (! snd_card_proc_new(emu->card, "io_regs", &entry)) {
 		snd_info_set_text_ops(entry, emu, snd_emu_proc_io_reg_read);
 		entry->c.text.write = snd_emu_proc_io_reg_write;
--- linux-2.6.18.noarch/sound/pci/emu10k1/emupcm.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emupcm.c	2007-06-05 17:46:26.000000000 -0400
@@ -147,7 +147,7 @@
 					      1,
 					      &epcm->extra);
 		if (err < 0) {
-			// printk("pcm_channel_alloc: failed extra: voices=%d, frame=%d\n", voices, frame);
+			/* printk("pcm_channel_alloc: failed extra: voices=%d, frame=%d\n", voices, frame); */
 			for (i = 0; i < voices; i++) {
 				snd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);
 				epcm->voices[i] = NULL;
@@ -339,7 +339,7 @@
 		}
 	}
 
-	// setup routing
+	/* setup routing */
 	if (emu->audigy) {
 		snd_emu10k1_ptr_write(emu, A_FXRT1, voice,
 				      snd_emu10k1_compose_audigy_fxrt1(send_routing));
@@ -353,12 +353,15 @@
 	} else
 		snd_emu10k1_ptr_write(emu, FXRT, voice,
 				      snd_emu10k1_compose_send_routing(send_routing));
-	// Stop CA
-	// Assumption that PT is already 0 so no harm overwriting
+	/* Stop CA */
+	/* Assumption that PT is already 0 so no harm overwriting */
 	snd_emu10k1_ptr_write(emu, PTRX, voice, (send_amount[0] << 8) | send_amount[1]);
 	snd_emu10k1_ptr_write(emu, DSL, voice, end_addr | (send_amount[3] << 24));
 	snd_emu10k1_ptr_write(emu, PSST, voice, start_addr | (send_amount[2] << 24));
-	pitch_target = emu10k1_calc_pitch_target(runtime->rate);
+	if (emu->card_capabilities->emu1010)
+		pitch_target = PITCH_48000; /* Disable interpolators on emu1010 card */
+	else 
+		pitch_target = emu10k1_calc_pitch_target(runtime->rate);
 	if (extra)
 		snd_emu10k1_ptr_write(emu, CCCA, voice, start_addr |
 			      emu10k1_select_interprom(pitch_target) |
@@ -367,14 +370,14 @@
 		snd_emu10k1_ptr_write(emu, CCCA, voice, (start_addr + ccis) |
 			      emu10k1_select_interprom(pitch_target) |
 			      (w_16 ? 0 : CCCA_8BITSELECT));
-	// Clear filter delay memory
+	/* Clear filter delay memory */
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
-	// invalidate maps
+	/* invalidate maps */
 	silent_page = ((unsigned int)emu->silent_page.addr << 1) | MAP_PTI_MASK;
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
-	// modulation envelope
+	/* modulation envelope */
 	snd_emu10k1_ptr_write(emu, CVCF, voice, 0xffff);
 	snd_emu10k1_ptr_write(emu, VTFT, voice, 0xffff);
 	snd_emu10k1_ptr_write(emu, ATKHLDM, voice, 0);
@@ -385,12 +388,12 @@
 	snd_emu10k1_ptr_write(emu, TREMFRQ, voice, 0);
 	snd_emu10k1_ptr_write(emu, FM2FRQ2, voice, 0);
 	snd_emu10k1_ptr_write(emu, ENVVAL, voice, 0x8000);
-	// volume envelope
+	/* volume envelope */
 	snd_emu10k1_ptr_write(emu, ATKHLDV, voice, 0x7f7f);
 	snd_emu10k1_ptr_write(emu, ENVVOL, voice, 0x0000);
-	// filter envelope
+	/* filter envelope */
 	snd_emu10k1_ptr_write(emu, PEFE_FILTERAMOUNT, voice, 0x7f);
-	// pitch envelope
+	/* pitch envelope */
 	snd_emu10k1_ptr_write(emu, PEFE_PITCHAMOUNT, voice, 0);
 
 	spin_unlock_irqrestore(&emu->reg_lock, flags);
@@ -468,7 +471,7 @@
 		snd_emu10k1_voice_free(epcm->emu, epcm->extra);
 		epcm->extra = NULL;
 	}
-	for (i=0; i < NUM_EFX_PLAYBACK; i++) {
+	for (i = 0; i < NUM_EFX_PLAYBACK; i++) {
 		if (epcm->voices[i]) {
 			snd_emu10k1_voice_free(epcm->emu, epcm->voices[i]);
 			epcm->voices[i] = NULL;
@@ -637,7 +640,7 @@
 	stereo = (!extra && runtime->channels == 2);
 	sample = snd_pcm_format_width(runtime->format) == 16 ? 0 : 0x80808080;
 	ccis = emu10k1_ccis(stereo, sample == 0);
-	// set cs to 2 * number of cache registers beside the invalidated
+	/* set cs to 2 * number of cache registers beside the invalidated */
 	cs = (sample == 0) ? (32-ccis) : (64-ccis+1) >> 1;
 	if (cs > 16) cs = 16;
 	for (i = 0; i < cs; i++) {
@@ -646,14 +649,14 @@
 			snd_emu10k1_ptr_write(emu, CD0 + i, voice + 1, sample);
 		}
 	}
-	// reset cache
+	/* reset cache */
 	snd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice, 0);
 	snd_emu10k1_ptr_write(emu, CCR_READADDRESS, voice, cra);
 	if (stereo) {
 		snd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice + 1, 0);
 		snd_emu10k1_ptr_write(emu, CCR_READADDRESS, voice + 1, cra);
 	}
-	// fill cache
+	/* fill cache */
 	snd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice, ccis);
 	if (stereo) {
 		snd_emu10k1_ptr_write(emu, CCR_CACHEINVALIDSIZE, voice+1, ccis);
@@ -698,7 +701,10 @@
 	voice = evoice->number;
 
 	pitch = snd_emu10k1_rate_to_pitch(runtime->rate) >> 8;
-	pitch_target = emu10k1_calc_pitch_target(runtime->rate);
+	if (emu->card_capabilities->emu1010)
+		pitch_target = PITCH_48000; /* Disable interpolators on emu1010 card */
+	else 
+		pitch_target = emu10k1_calc_pitch_target(runtime->rate);
 	snd_emu10k1_ptr_write(emu, PTRX_PITCHTARGET, voice, pitch_target);
 	if (master || evoice->epcm->type == PLAYBACK_EFX)
 		snd_emu10k1_ptr_write(emu, CPF_CURRENTPITCH, voice, pitch_target);
@@ -732,7 +738,7 @@
 	struct snd_emu10k1_pcm_mixer *mix;
 	int result = 0;
 
-	// printk("trigger - emu10k1 = 0x%x, cmd = %i, pointer = %i\n", (int)emu, cmd, substream->ops->pointer(substream));
+	/* printk("trigger - emu10k1 = 0x%x, cmd = %i, pointer = %i\n", (int)emu, cmd, substream->ops->pointer(substream)); */
 	spin_lock(&emu->reg_lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -778,10 +784,10 @@
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		// hmm this should cause full and half full interrupt to be raised?  
+		/* hmm this should cause full and half full interrupt to be raised? */
 		outl(epcm->capture_ipr, emu->port + IPR);
 		snd_emu10k1_intr_enable(emu, epcm->capture_inte);
-		// printk("adccr = 0x%x, adcbs = 0x%x\n", epcm->adccr, epcm->adcbs);
+		/* printk("adccr = 0x%x, adcbs = 0x%x\n", epcm->adccr, epcm->adcbs); */
 		switch (epcm->type) {
 		case CAPTURE_AC97ADC:
 			snd_emu10k1_ptr_write(emu, ADCCR, 0, epcm->capture_cr_val);
@@ -790,6 +796,7 @@
 			if (emu->audigy) {
 				snd_emu10k1_ptr_write(emu, A_FXWC1, 0, epcm->capture_cr_val);
 				snd_emu10k1_ptr_write(emu, A_FXWC2, 0, epcm->capture_cr_val2);
+				snd_printdd("cr_val=0x%x, cr_val2=0x%x\n", epcm->capture_cr_val, epcm->capture_cr_val2);
 			} else
 				snd_emu10k1_ptr_write(emu, FXWC, 0, epcm->capture_cr_val);
 			break;
@@ -851,7 +858,7 @@
 			ptr -= runtime->buffer_size;
 	}
 #endif
-	// printk("ptr = 0x%x, buffer_size = 0x%x, period_size = 0x%x\n", ptr, runtime->buffer_size, runtime->period_size);
+	/* printk("ptr = 0x%x, buffer_size = 0x%x, period_size = 0x%x\n", ptr, runtime->buffer_size, runtime->period_size); */
 	return ptr;
 }
 
@@ -868,7 +875,7 @@
 	spin_lock(&emu->reg_lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		// prepare voices
+		/* prepare voices */
 		for (i = 0; i < NUM_EFX_PLAYBACK; i++) {	
 			snd_emu10k1_playback_invalidate_cache(emu, 0, epcm->voices[i]);
 		}
@@ -917,7 +924,7 @@
 	if (!epcm->running)
 		return 0;
 	if (epcm->first_ptr) {
-		udelay(50);	// hack, it takes awhile until capture is started
+		udelay(50);	/* hack, it takes awhile until capture is started */
 		epcm->first_ptr = 0;
 	}
 	ptr = snd_emu10k1_ptr_read(emu, epcm->capture_idx_reg, 0) & 0x0000ffff;
@@ -972,6 +979,28 @@
 	.fifo_size =		0,
 };
 
+static struct snd_pcm_hardware snd_emu10k1_capture_efx =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_RESUME |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | 
+				 SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | 
+				 SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+	.rate_min =		44100,
+	.rate_max =		192000,
+	.channels_min =		8,
+	.channels_max =		8,
+	.buffer_bytes_max =	(64*1024),
+	.period_bytes_min =	384,
+	.period_bytes_max =	(64*1024),
+	.periods_min =		2,
+	.periods_max =		2,
+	.fifo_size =		0,
+};
+
 /*
  *
  */
@@ -1016,7 +1045,7 @@
 	struct snd_emu10k1_pcm_mixer *mix;
 	int i;
 
-	for (i=0; i < NUM_EFX_PLAYBACK; i++) {
+	for (i = 0; i < NUM_EFX_PLAYBACK; i++) {
 		mix = &emu->efx_pcm_mixer[i];
 		mix->epcm = NULL;
 		snd_emu10k1_pcm_efx_mixer_notify(emu, i, 0);
@@ -1045,7 +1074,7 @@
 	runtime->private_free = snd_emu10k1_pcm_free_substream;
 	runtime->hw = snd_emu10k1_efx_playback;
 	
-	for (i=0; i < NUM_EFX_PLAYBACK; i++) {
+	for (i = 0; i < NUM_EFX_PLAYBACK; i++) {
 		mix = &emu->efx_pcm_mixer[i];
 		mix->send_routing[0][0] = i;
 		memset(&mix->send_volume, 0, sizeof(mix->send_volume));
@@ -1199,15 +1228,69 @@
 	epcm->capture_idx_reg = FXIDX;
 	substream->runtime->private_data = epcm;
 	substream->runtime->private_free = snd_emu10k1_pcm_free_substream;
-	runtime->hw = snd_emu10k1_capture;
+	runtime->hw = snd_emu10k1_capture_efx;
 	runtime->hw.rates = SNDRV_PCM_RATE_48000;
 	runtime->hw.rate_min = runtime->hw.rate_max = 48000;
 	spin_lock_irq(&emu->reg_lock);
-	runtime->hw.channels_min = runtime->hw.channels_max = 0;
-	for (idx = 0; idx < nefx; idx++) {
-		if (emu->efx_voices_mask[idx/32] & (1 << (idx%32))) {
-			runtime->hw.channels_min++;
-			runtime->hw.channels_max++;
+	if (emu->card_capabilities->emu1010) {
+		/* TODO 
+		 * SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE
+		 * SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
+		 * SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+		 * SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
+		 * rate_min = 44100,
+		 * rate_max = 192000,
+		 * channels_min = 8,
+		 * channels_max = 8,
+		 * Need to add mixer control to fix sample rate
+		 *                 
+		 * There are 16 mono channels of 16bits each.
+		 * 24bit Audio uses 2x channels over 16bit
+		 * 96kHz uses 2x channels over 48kHz
+		 * 192kHz uses 4x channels over 48kHz
+		 * So, for 48kHz 24bit, one has 8 channels
+		 * for 96kHz 24bit, one has 4 channels
+		 * for 192kHz 24bit, one has 2 channels
+		 */
+#if 1
+		switch (emu->emu1010.internal_clock) {
+		case 0:
+			/* For 44.1kHz */
+			runtime->hw.rates = SNDRV_PCM_RATE_44100;
+			runtime->hw.rate_min = runtime->hw.rate_max = 44100;
+			runtime->hw.channels_min = runtime->hw.channels_max = 8;
+			break;
+		case 1:
+			/* For 48kHz */
+			runtime->hw.rates = SNDRV_PCM_RATE_48000;
+			runtime->hw.rate_min = runtime->hw.rate_max = 48000;
+			runtime->hw.channels_min = runtime->hw.channels_max = 8;
+			break;
+		};
+#endif
+#if 0
+		/* For 96kHz */
+		runtime->hw.rates = SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_min = runtime->hw.rate_max = 96000;
+		runtime->hw.channels_min = runtime->hw.channels_max = 4;
+#endif
+#if 0
+		/* For 192kHz */
+		runtime->hw.rates = SNDRV_PCM_RATE_192000;
+		runtime->hw.rate_min = runtime->hw.rate_max = 192000;
+		runtime->hw.channels_min = runtime->hw.channels_max = 2;
+#endif
+		runtime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;
+		/* efx_voices_mask[0] is expected to be zero
+ 		 * efx_voices_mask[1] is expected to have 16bits set
+		 */
+	} else {
+		runtime->hw.channels_min = runtime->hw.channels_max = 0;
+		for (idx = 0; idx < nefx; idx++) {
+			if (emu->efx_voices_mask[idx/32] & (1 << (idx%32))) {
+				runtime->hw.channels_min++;
+				runtime->hw.channels_max++;
+			}
 		}
 	}
 	epcm->capture_cr_val = emu->efx_voices_mask[0];
@@ -1460,7 +1543,7 @@
 						   unsigned int count,
 						   unsigned int tram_shift)
 {
-	// printk("tram_poke1: dst_left = 0x%p, dst_right = 0x%p, src = 0x%p, count = 0x%x\n", dst_left, dst_right, src, count);
+	/* printk("tram_poke1: dst_left = 0x%p, dst_right = 0x%p, src = 0x%p, count = 0x%x\n", dst_left, dst_right, src, count); */
 	if ((tram_shift & 1) == 0) {
 		while (count--) {
 			*dst_left-- = *src++;
@@ -1537,7 +1620,7 @@
 	struct snd_emu10k1_fx8010_pcm *pcm = &emu->fx8010.pcm[substream->number];
 	unsigned int i;
 	
-	// printk("prepare: etram_pages = 0x%p, dma_area = 0x%x, buffer_size = 0x%x (0x%x)\n", emu->fx8010.etram_pages, runtime->dma_area, runtime->buffer_size, runtime->buffer_size << 2);
+	/* printk("prepare: etram_pages = 0x%p, dma_area = 0x%x, buffer_size = 0x%x (0x%x)\n", emu->fx8010.etram_pages, runtime->dma_area, runtime->buffer_size, runtime->buffer_size << 2); */
 	memset(&pcm->pcm_rec, 0, sizeof(pcm->pcm_rec));
 	pcm->pcm_rec.hw_buffer_size = pcm->buffer_size * 2; /* byte size */
 	pcm->pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
--- linux-2.6.18.noarch/sound/pci/emu10k1/emumixer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emumixer.c	2007-06-05 17:46:26.000000000 -0400
@@ -5,6 +5,9 @@
  *  Routines for control of EMU10K1 chips / mixer routines
  *  Multichannel PCM support Copyright (c) Lee Revell <rlrevell@joe-job.com>
  *
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
+ *  	Added EMU 1010 support.
+ *
  *  BUGS:
  *    --
  *
@@ -32,9 +35,15 @@
 #include <linux/init.h>
 #include <sound/core.h>
 #include <sound/emu10k1.h>
+#include <linux/delay.h>
+#include <sound/tlv.h>
+
+#include "p17v.h"
 
 #define AC97_ID_STAC9758	0x83847658
 
+static const DECLARE_TLV_DB_SCALE(snd_audigy_db_scale2, -10350, 50, 1); /* WM8775 gain scale */
+
 static int snd_emu10k1_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
@@ -68,6 +77,669 @@
 	return 0;
 }
 
+static char *emu1010_src_texts[] = { 
+	"Silence",
+	"Dock Mic A",
+	"Dock Mic B",
+	"Dock ADC1 Left",
+	"Dock ADC1 Right",
+	"Dock ADC2 Left",
+	"Dock ADC2 Right",
+	"Dock ADC3 Left",
+	"Dock ADC3 Right",
+	"0202 ADC Left",
+	"0202 ADC Right",
+	"0202 SPDIF Left",
+	"0202 SPDIF Right",
+	"ADAT 0",
+	"ADAT 1",
+	"ADAT 2",
+	"ADAT 3",
+	"ADAT 4",
+	"ADAT 5",
+	"ADAT 6",
+	"ADAT 7",
+	"DSP 0",
+	"DSP 1",
+	"DSP 2",
+	"DSP 3",
+	"DSP 4",
+	"DSP 5",
+	"DSP 6",
+	"DSP 7",
+	"DSP 8",
+	"DSP 9",
+	"DSP 10",
+	"DSP 11",
+	"DSP 12",
+	"DSP 13",
+	"DSP 14",
+	"DSP 15",
+	"DSP 16",
+	"DSP 17",
+	"DSP 18",
+	"DSP 19",
+	"DSP 20",
+	"DSP 21",
+	"DSP 22",
+	"DSP 23",
+	"DSP 24",
+	"DSP 25",
+	"DSP 26",
+	"DSP 27",
+	"DSP 28",
+	"DSP 29",
+	"DSP 30",
+	"DSP 31",
+};
+
+static unsigned int emu1010_src_regs[] = {
+	EMU_SRC_SILENCE,/* 0 */
+	EMU_SRC_DOCK_MIC_A1, /* 1 */
+	EMU_SRC_DOCK_MIC_B1, /* 2 */
+	EMU_SRC_DOCK_ADC1_LEFT1, /* 3 */
+	EMU_SRC_DOCK_ADC1_RIGHT1, /* 4 */
+	EMU_SRC_DOCK_ADC2_LEFT1, /* 5 */
+	EMU_SRC_DOCK_ADC2_RIGHT1, /* 6 */
+	EMU_SRC_DOCK_ADC3_LEFT1, /* 7 */
+	EMU_SRC_DOCK_ADC3_RIGHT1, /* 8 */
+	EMU_SRC_HAMOA_ADC_LEFT1, /* 9 */
+	EMU_SRC_HAMOA_ADC_RIGHT1, /* 10 */
+	EMU_SRC_HANA_SPDIF_LEFT1, /* 11 */
+	EMU_SRC_HANA_SPDIF_RIGHT1, /* 12 */
+	EMU_SRC_HANA_ADAT, /* 13 */
+	EMU_SRC_HANA_ADAT+1, /* 14 */
+	EMU_SRC_HANA_ADAT+2, /* 15 */
+	EMU_SRC_HANA_ADAT+3, /* 16 */
+	EMU_SRC_HANA_ADAT+4, /* 17 */
+	EMU_SRC_HANA_ADAT+5, /* 18 */
+	EMU_SRC_HANA_ADAT+6, /* 19 */
+	EMU_SRC_HANA_ADAT+7, /* 20 */
+	EMU_SRC_ALICE_EMU32A, /* 21 */
+	EMU_SRC_ALICE_EMU32A+1, /* 22 */
+	EMU_SRC_ALICE_EMU32A+2, /* 23 */
+	EMU_SRC_ALICE_EMU32A+3, /* 24 */
+	EMU_SRC_ALICE_EMU32A+4, /* 25 */
+	EMU_SRC_ALICE_EMU32A+5, /* 26 */
+	EMU_SRC_ALICE_EMU32A+6, /* 27 */
+	EMU_SRC_ALICE_EMU32A+7, /* 28 */
+	EMU_SRC_ALICE_EMU32A+8, /* 29 */
+	EMU_SRC_ALICE_EMU32A+9, /* 30 */
+	EMU_SRC_ALICE_EMU32A+0xa, /* 31 */
+	EMU_SRC_ALICE_EMU32A+0xb, /* 32 */
+	EMU_SRC_ALICE_EMU32A+0xc, /* 33 */
+	EMU_SRC_ALICE_EMU32A+0xd, /* 34 */
+	EMU_SRC_ALICE_EMU32A+0xe, /* 35 */
+	EMU_SRC_ALICE_EMU32A+0xf, /* 36 */
+	EMU_SRC_ALICE_EMU32B, /* 37 */
+	EMU_SRC_ALICE_EMU32B+1, /* 38 */
+	EMU_SRC_ALICE_EMU32B+2, /* 39 */
+	EMU_SRC_ALICE_EMU32B+3, /* 40 */
+	EMU_SRC_ALICE_EMU32B+4, /* 41 */
+	EMU_SRC_ALICE_EMU32B+5, /* 42 */
+	EMU_SRC_ALICE_EMU32B+6, /* 43 */
+	EMU_SRC_ALICE_EMU32B+7, /* 44 */
+	EMU_SRC_ALICE_EMU32B+8, /* 45 */
+	EMU_SRC_ALICE_EMU32B+9, /* 46 */
+	EMU_SRC_ALICE_EMU32B+0xa, /* 47 */
+	EMU_SRC_ALICE_EMU32B+0xb, /* 48 */
+	EMU_SRC_ALICE_EMU32B+0xc, /* 49 */
+	EMU_SRC_ALICE_EMU32B+0xd, /* 50 */
+	EMU_SRC_ALICE_EMU32B+0xe, /* 51 */
+	EMU_SRC_ALICE_EMU32B+0xf, /* 52 */
+};
+
+static unsigned int emu1010_output_dst[] = {
+	EMU_DST_DOCK_DAC1_LEFT1, /* 0 */
+	EMU_DST_DOCK_DAC1_RIGHT1, /* 1 */
+	EMU_DST_DOCK_DAC2_LEFT1, /* 2 */
+	EMU_DST_DOCK_DAC2_RIGHT1, /* 3 */
+	EMU_DST_DOCK_DAC3_LEFT1, /* 4 */
+	EMU_DST_DOCK_DAC3_RIGHT1, /* 5 */
+	EMU_DST_DOCK_DAC4_LEFT1, /* 6 */
+	EMU_DST_DOCK_DAC4_RIGHT1, /* 7 */
+	EMU_DST_DOCK_PHONES_LEFT1, /* 8 */
+	EMU_DST_DOCK_PHONES_RIGHT1, /* 9 */
+	EMU_DST_DOCK_SPDIF_LEFT1, /* 10 */
+	EMU_DST_DOCK_SPDIF_RIGHT1, /* 11 */
+	EMU_DST_HANA_SPDIF_LEFT1, /* 12 */
+	EMU_DST_HANA_SPDIF_RIGHT1, /* 13 */
+	EMU_DST_HAMOA_DAC_LEFT1, /* 14 */
+	EMU_DST_HAMOA_DAC_RIGHT1, /* 15 */
+	EMU_DST_HANA_ADAT, /* 16 */
+	EMU_DST_HANA_ADAT+1, /* 17 */
+	EMU_DST_HANA_ADAT+2, /* 18 */
+	EMU_DST_HANA_ADAT+3, /* 19 */
+	EMU_DST_HANA_ADAT+4, /* 20 */
+	EMU_DST_HANA_ADAT+5, /* 21 */
+	EMU_DST_HANA_ADAT+6, /* 22 */
+	EMU_DST_HANA_ADAT+7, /* 23 */
+};
+
+static unsigned int emu1010_input_dst[] = {
+	EMU_DST_ALICE2_EMU32_0,
+	EMU_DST_ALICE2_EMU32_1,
+	EMU_DST_ALICE2_EMU32_2,
+	EMU_DST_ALICE2_EMU32_3,
+	EMU_DST_ALICE2_EMU32_4,
+	EMU_DST_ALICE2_EMU32_5,
+	EMU_DST_ALICE2_EMU32_6,
+	EMU_DST_ALICE2_EMU32_7,
+	EMU_DST_ALICE2_EMU32_8,
+	EMU_DST_ALICE2_EMU32_9,
+	EMU_DST_ALICE2_EMU32_A,
+	EMU_DST_ALICE2_EMU32_B,
+	EMU_DST_ALICE2_EMU32_C,
+	EMU_DST_ALICE2_EMU32_D,
+	EMU_DST_ALICE2_EMU32_E,
+	EMU_DST_ALICE2_EMU32_F,
+	EMU_DST_ALICE_I2S0_LEFT,
+	EMU_DST_ALICE_I2S0_RIGHT,
+	EMU_DST_ALICE_I2S1_LEFT,
+	EMU_DST_ALICE_I2S1_RIGHT,
+	EMU_DST_ALICE_I2S2_LEFT,
+	EMU_DST_ALICE_I2S2_RIGHT,
+};
+
+static int snd_emu1010_input_output_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 53;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, emu1010_src_texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_emu1010_output_source_get(struct snd_kcontrol *kcontrol,
+                                 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	int channel;
+
+	channel = (kcontrol->private_value) & 0xff;
+	ucontrol->value.enumerated.item[0] = emu->emu1010.output_source[channel];
+	return 0;
+}
+
+static int snd_emu1010_output_source_put(struct snd_kcontrol *kcontrol,
+                                 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	int change = 0;
+	unsigned int val;
+	int channel;
+
+	channel = (kcontrol->private_value) & 0xff;
+	if (emu->emu1010.output_source[channel] != ucontrol->value.enumerated.item[0]) {
+		val = emu->emu1010.output_source[channel] = ucontrol->value.enumerated.item[0];
+		change = 1;
+		snd_emu1010_fpga_link_dst_src_write(emu,
+			emu1010_output_dst[channel], emu1010_src_regs[val]);
+	}
+	return change;
+}
+
+static int snd_emu1010_input_source_get(struct snd_kcontrol *kcontrol,
+                                 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	int channel;
+
+	channel = (kcontrol->private_value) & 0xff;
+	ucontrol->value.enumerated.item[0] = emu->emu1010.input_source[channel];
+	return 0;
+}
+
+static int snd_emu1010_input_source_put(struct snd_kcontrol *kcontrol,
+                                 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	int change = 0;
+	unsigned int val;
+	int channel;
+
+	channel = (kcontrol->private_value) & 0xff;
+	if (emu->emu1010.input_source[channel] != ucontrol->value.enumerated.item[0]) {
+		val = emu->emu1010.input_source[channel] = ucontrol->value.enumerated.item[0];
+		change = 1;
+		snd_emu1010_fpga_link_dst_src_write(emu,
+			emu1010_input_dst[channel], emu1010_src_regs[val]);
+	}
+	return change;
+}
+
+#define EMU1010_SOURCE_OUTPUT(xname,chid) \
+{								\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,		\
+	.info =  snd_emu1010_input_output_source_info,		\
+	.get =   snd_emu1010_output_source_get,			\
+	.put =   snd_emu1010_output_source_put,			\
+	.private_value = chid					\
+}
+
+static struct snd_kcontrol_new snd_emu1010_output_enum_ctls[] __devinitdata = {
+	EMU1010_SOURCE_OUTPUT("Dock DAC1 Left Playback Enum", 0),
+	EMU1010_SOURCE_OUTPUT("Dock DAC1 Right Playback Enum", 1),
+	EMU1010_SOURCE_OUTPUT("Dock DAC2 Left Playback Enum", 2),
+	EMU1010_SOURCE_OUTPUT("Dock DAC2 Right Playback Enum", 3),
+	EMU1010_SOURCE_OUTPUT("Dock DAC3 Left Playback Enum", 4),
+	EMU1010_SOURCE_OUTPUT("Dock DAC3 Right Playback Enum", 5),
+	EMU1010_SOURCE_OUTPUT("Dock DAC4 Left Playback Enum", 6),
+	EMU1010_SOURCE_OUTPUT("Dock DAC4 Right Playback Enum", 7),
+	EMU1010_SOURCE_OUTPUT("Dock Phones Left Playback Enum", 8),
+	EMU1010_SOURCE_OUTPUT("Dock Phones Right Playback Enum", 9),
+	EMU1010_SOURCE_OUTPUT("Dock SPDIF Left Playback Enum", 0xa),
+	EMU1010_SOURCE_OUTPUT("Dock SPDIF Right Playback Enum", 0xb),
+	EMU1010_SOURCE_OUTPUT("1010 SPDIF Left Playback Enum", 0xc),
+	EMU1010_SOURCE_OUTPUT("1010 SPDIF Right Playback Enum", 0xd),
+	EMU1010_SOURCE_OUTPUT("0202 DAC Left Playback Enum", 0xe),
+	EMU1010_SOURCE_OUTPUT("0202 DAC Right Playback Enum", 0xf),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 0 Playback Enum", 0x10),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 1 Playback Enum", 0x11),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 2 Playback Enum", 0x12),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 3 Playback Enum", 0x13),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 4 Playback Enum", 0x14),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 5 Playback Enum", 0x15),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 6 Playback Enum", 0x16),
+	EMU1010_SOURCE_OUTPUT("1010 ADAT 7 Playback Enum", 0x17),
+};
+
+#define EMU1010_SOURCE_INPUT(xname,chid) \
+{								\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,		\
+	.info =  snd_emu1010_input_output_source_info,		\
+	.get =   snd_emu1010_input_source_get,			\
+	.put =   snd_emu1010_input_source_put,			\
+	.private_value = chid					\
+}
+
+static struct snd_kcontrol_new snd_emu1010_input_enum_ctls[] __devinitdata = {
+	EMU1010_SOURCE_INPUT("DSP 0 Capture Enum", 0),
+	EMU1010_SOURCE_INPUT("DSP 1 Capture Enum", 1),
+	EMU1010_SOURCE_INPUT("DSP 2 Capture Enum", 2),
+	EMU1010_SOURCE_INPUT("DSP 3 Capture Enum", 3),
+	EMU1010_SOURCE_INPUT("DSP 4 Capture Enum", 4),
+	EMU1010_SOURCE_INPUT("DSP 5 Capture Enum", 5),
+	EMU1010_SOURCE_INPUT("DSP 6 Capture Enum", 6),
+	EMU1010_SOURCE_INPUT("DSP 7 Capture Enum", 7),
+	EMU1010_SOURCE_INPUT("DSP 8 Capture Enum", 8),
+	EMU1010_SOURCE_INPUT("DSP 9 Capture Enum", 9),
+	EMU1010_SOURCE_INPUT("DSP A Capture Enum", 0xa),
+	EMU1010_SOURCE_INPUT("DSP B Capture Enum", 0xb),
+	EMU1010_SOURCE_INPUT("DSP C Capture Enum", 0xc),
+	EMU1010_SOURCE_INPUT("DSP D Capture Enum", 0xd),
+	EMU1010_SOURCE_INPUT("DSP E Capture Enum", 0xe),
+	EMU1010_SOURCE_INPUT("DSP F Capture Enum", 0xf),
+	EMU1010_SOURCE_INPUT("DSP 10 Capture Enum", 0x10),
+	EMU1010_SOURCE_INPUT("DSP 11 Capture Enum", 0x11),
+	EMU1010_SOURCE_INPUT("DSP 12 Capture Enum", 0x12),
+	EMU1010_SOURCE_INPUT("DSP 13 Capture Enum", 0x13),
+	EMU1010_SOURCE_INPUT("DSP 14 Capture Enum", 0x14),
+	EMU1010_SOURCE_INPUT("DSP 15 Capture Enum", 0x15),
+};
+
+
+
+
+static int snd_emu1010_adc_pads_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_emu1010_adc_pads_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int mask = kcontrol->private_value & 0xff;
+	ucontrol->value.integer.value[0] = (emu->emu1010.adc_pads & mask) ? 1 : 0;
+	return 0;
+}
+
+static int snd_emu1010_adc_pads_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int mask = kcontrol->private_value & 0xff;
+	unsigned int val, cache;
+	val = ucontrol->value.integer.value[0];
+	cache = emu->emu1010.adc_pads;
+	if (val == 1) 
+		cache = cache | mask;
+	else
+		cache = cache & ~mask;
+	if (cache != emu->emu1010.adc_pads) {
+		snd_emu1010_fpga_write(emu, EMU_HANA_ADC_PADS, cache );
+	        emu->emu1010.adc_pads = cache;
+	}
+
+	return 0;
+}
+
+
+
+#define EMU1010_ADC_PADS(xname,chid) \
+{								\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,		\
+	.info =  snd_emu1010_adc_pads_info,			\
+	.get =   snd_emu1010_adc_pads_get,			\
+	.put =   snd_emu1010_adc_pads_put,			\
+	.private_value = chid					\
+}
+
+static struct snd_kcontrol_new snd_emu1010_adc_pads[] __devinitdata = {
+	EMU1010_ADC_PADS("ADC1 14dB PAD Audio Dock Capture Switch", EMU_HANA_DOCK_ADC_PAD1),
+	EMU1010_ADC_PADS("ADC2 14dB PAD Audio Dock Capture Switch", EMU_HANA_DOCK_ADC_PAD2),
+	EMU1010_ADC_PADS("ADC3 14dB PAD Audio Dock Capture Switch", EMU_HANA_DOCK_ADC_PAD3),
+	EMU1010_ADC_PADS("ADC1 14dB PAD 0202 Capture Switch", EMU_HANA_0202_ADC_PAD1),
+};
+
+static int snd_emu1010_dac_pads_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_emu1010_dac_pads_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int mask = kcontrol->private_value & 0xff;
+	ucontrol->value.integer.value[0] = (emu->emu1010.dac_pads & mask) ? 1 : 0;
+	return 0;
+}
+
+static int snd_emu1010_dac_pads_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int mask = kcontrol->private_value & 0xff;
+	unsigned int val, cache;
+	val = ucontrol->value.integer.value[0];
+	cache = emu->emu1010.dac_pads;
+	if (val == 1) 
+		cache = cache | mask;
+	else
+		cache = cache & ~mask;
+	if (cache != emu->emu1010.dac_pads) {
+		snd_emu1010_fpga_write(emu, EMU_HANA_DAC_PADS, cache );
+	        emu->emu1010.dac_pads = cache;
+	}
+
+	return 0;
+}
+
+
+
+#define EMU1010_DAC_PADS(xname,chid) \
+{								\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,		\
+	.info =  snd_emu1010_dac_pads_info,			\
+	.get =   snd_emu1010_dac_pads_get,			\
+	.put =   snd_emu1010_dac_pads_put,			\
+	.private_value = chid					\
+}
+
+static struct snd_kcontrol_new snd_emu1010_dac_pads[] __devinitdata = {
+	EMU1010_DAC_PADS("DAC1 Audio Dock 14dB PAD Playback Switch", EMU_HANA_DOCK_DAC_PAD1),
+	EMU1010_DAC_PADS("DAC2 Audio Dock 14dB PAD Playback Switch", EMU_HANA_DOCK_DAC_PAD2),
+	EMU1010_DAC_PADS("DAC3 Audio Dock 14dB PAD Playback Switch", EMU_HANA_DOCK_DAC_PAD3),
+	EMU1010_DAC_PADS("DAC4 Audio Dock 14dB PAD Playback Switch", EMU_HANA_DOCK_DAC_PAD4),
+	EMU1010_DAC_PADS("DAC1 0202 14dB PAD Playback Switch", EMU_HANA_0202_DAC_PAD1),
+};
+
+
+static int snd_emu1010_internal_clock_info(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[2] = {
+		"44100", "48000"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item > 1)
+                uinfo->value.enumerated.item = 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_emu1010_internal_clock_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = emu->emu1010.internal_clock;
+	return 0;
+}
+
+static int snd_emu1010_internal_clock_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change = 0;
+
+	val = ucontrol->value.enumerated.item[0] ;
+	change = (emu->emu1010.internal_clock != val);
+	if (change) {
+		emu->emu1010.internal_clock = val;
+		switch (val) {
+		case 0:
+			/* 44100 */
+			/* Mute all */
+			snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE );
+			/* Default fallback clock 48kHz */
+			snd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_44_1K );
+			/* Word Clock source, Internal 44.1kHz x1 */
+			snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK,
+			EMU_HANA_WCLOCK_INT_44_1K | EMU_HANA_WCLOCK_1X );
+			/* Set LEDs on Audio Dock */
+			snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2,
+				EMU_HANA_DOCK_LEDS_2_44K | EMU_HANA_DOCK_LEDS_2_LOCK );
+			/* Allow DLL to settle */
+			msleep(10);
+			/* Unmute all */
+			snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE );
+			break;
+		case 1:
+			/* 48000 */
+			/* Mute all */
+			snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_MUTE );
+			/* Default fallback clock 48kHz */
+			snd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, EMU_HANA_DEFCLOCK_48K );
+			/* Word Clock source, Internal 48kHz x1 */
+			snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK,
+				EMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_1X );
+			/* Set LEDs on Audio Dock */
+			snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2,
+				EMU_HANA_DOCK_LEDS_2_48K | EMU_HANA_DOCK_LEDS_2_LOCK );
+			/* Allow DLL to settle */
+			msleep(10);
+			/* Unmute all */
+			snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, EMU_UNMUTE );
+			break;
+		}
+	}
+        return change;
+}
+
+static struct snd_kcontrol_new snd_emu1010_internal_clock =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Clock Internal Rate",
+	.count =	1,
+	.info =         snd_emu1010_internal_clock_info,
+	.get =          snd_emu1010_internal_clock_get,
+	.put =          snd_emu1010_internal_clock_put
+};
+
+static int snd_audigy_i2c_capture_source_info(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
+{
+#if 0
+	static char *texts[4] = {
+		"Unknown1", "Unknown2", "Mic", "Line"
+	};
+#endif
+	static char *texts[2] = {
+		"Mic", "Line"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item > 1)
+                uinfo->value.enumerated.item = 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_audigy_i2c_capture_source_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = emu->i2c_capture_source;
+	return 0;
+}
+
+static int snd_audigy_i2c_capture_source_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int source_id;
+	unsigned int ngain, ogain;
+	u32 gpio;
+	int change = 0;
+	unsigned long flags;
+	u32 source;
+	/* If the capture source has changed,
+	 * update the capture volume from the cached value
+	 * for the particular source.
+	 */
+	source_id = ucontrol->value.enumerated.item[0]; /* Use 2 and 3 */
+	change = (emu->i2c_capture_source != source_id);
+	if (change) {
+		snd_emu10k1_i2c_write(emu, ADC_MUX, 0); /* Mute input */
+		spin_lock_irqsave(&emu->emu_lock, flags);
+		gpio = inl(emu->port + A_IOCFG);
+		if (source_id==0)
+			outl(gpio | 0x4, emu->port + A_IOCFG);
+		else
+			outl(gpio & ~0x4, emu->port + A_IOCFG);
+		spin_unlock_irqrestore(&emu->emu_lock, flags);
+
+		ngain = emu->i2c_capture_volume[source_id][0]; /* Left */
+		ogain = emu->i2c_capture_volume[emu->i2c_capture_source][0]; /* Left */
+		if (ngain != ogain)
+			snd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCL, ((ngain) & 0xff));
+		ngain = emu->i2c_capture_volume[source_id][1]; /* Right */
+		ogain = emu->i2c_capture_volume[emu->i2c_capture_source][1]; /* Right */
+		if (ngain != ogain)
+			snd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCR, ((ngain) & 0xff));
+
+		source = 1 << (source_id + 2);
+		snd_emu10k1_i2c_write(emu, ADC_MUX, source); /* Set source */
+		emu->i2c_capture_source = source_id;
+	}
+        return change;
+}
+
+static struct snd_kcontrol_new snd_audigy_i2c_capture_source =
+{
+		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =		"Capture Source",
+		.info =		snd_audigy_i2c_capture_source_info,
+		.get =		snd_audigy_i2c_capture_source_get,
+		.put =		snd_audigy_i2c_capture_source_put
+};
+
+static int snd_audigy_i2c_volume_info(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 255;
+	return 0;
+}
+
+static int snd_audigy_i2c_volume_get(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	int source_id;
+
+	source_id = kcontrol->private_value;
+
+	ucontrol->value.integer.value[0] = emu->i2c_capture_volume[source_id][0];
+	ucontrol->value.integer.value[1] = emu->i2c_capture_volume[source_id][1];
+	return 0;
+}
+
+static int snd_audigy_i2c_volume_put(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);
+	unsigned int ogain;
+	unsigned int ngain;
+	int source_id;
+	int change = 0;
+
+	source_id = kcontrol->private_value;
+	ogain = emu->i2c_capture_volume[source_id][0]; /* Left */
+	ngain = ucontrol->value.integer.value[0];
+	if (ngain > 0xff)
+		return 0;
+	if (ogain != ngain) {
+		if (emu->i2c_capture_source == source_id)
+			snd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCL, ((ngain) & 0xff) );
+		emu->i2c_capture_volume[source_id][0] = ucontrol->value.integer.value[0];
+		change = 1;
+	}
+	ogain = emu->i2c_capture_volume[source_id][1]; /* Right */
+	ngain = ucontrol->value.integer.value[1];
+	if (ngain > 0xff)
+		return 0;
+	if (ogain != ngain) {
+		if (emu->i2c_capture_source == source_id)
+			snd_emu10k1_i2c_write(emu, ADC_ATTEN_ADCR, ((ngain) & 0xff));
+		emu->i2c_capture_volume[source_id][1] = ucontrol->value.integer.value[1];
+		change = 1;
+	}
+
+	return change;
+}
+
+#define I2C_VOLUME(xname,chid) \
+{								\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,	\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |		\
+	          SNDRV_CTL_ELEM_ACCESS_TLV_READ,		\
+	.info =  snd_audigy_i2c_volume_info,			\
+	.get =   snd_audigy_i2c_volume_get,			\
+	.put =   snd_audigy_i2c_volume_put,			\
+	.tlv = { .p = snd_audigy_db_scale2 },			\
+	.private_value = chid					\
+}
+
+
+static struct snd_kcontrol_new snd_audigy_i2c_volume_ctls[] __devinitdata = {
+	I2C_VOLUME("Mic Capture Volume", 0),
+	I2C_VOLUME("Line Capture Volume", 0)
+};
+
 #if 0
 static int snd_audigy_spdif_output_rate_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
@@ -668,7 +1340,9 @@
 	int change = 0;
 
 	spin_lock_irqsave(&emu->reg_lock, flags);
-	if (emu->audigy) {
+	if ( emu->card_capabilities->i2c_adc) {
+		/* Do nothing for Audigy 2 ZS Notebook */
+	} else if (emu->audigy) {
 		reg = inl(emu->port + A_IOCFG);
 		val = ucontrol->value.integer.value[0] ? A_IOCFG_GPOUT0 : 0;
 		change = (reg & A_IOCFG_GPOUT0) != val;
@@ -806,6 +1480,24 @@
 		"AMic Playback Volume", "Mic Playback Volume",
 		NULL
 	};
+	static char *audigy_rename_ctls_i2c_adc[] = {
+		//"Analog Mix Capture Volume","OLD Analog Mix Capture Volume",
+		"Line Capture Volume", "Analog Mix Capture Volume",
+		"Wave Playback Volume", "OLD PCM Playback Volume",
+		"Wave Master Playback Volume", "Master Playback Volume",
+		"AMic Playback Volume", "Old Mic Playback Volume",
+		"CD Capture Volume", "IEC958 Optical Capture Volume",
+		NULL
+	};
+	static char *audigy_remove_ctls_i2c_adc[] = {
+		/* On the Audigy2 ZS Notebook
+		 * Capture via WM8775  */
+		"Mic Capture Volume",
+		"Analog Mix Capture Volume",
+		"Aux Capture Volume",
+		"IEC958 Optical Capture Volume",
+		NULL
+	};
 	static char *audigy_remove_ctls_1361t_adc[] = {
 		/* On the Audigy2 the AC97 playback is piped into
 		 * the Philips ADC for 24bit capture */
@@ -890,6 +1582,7 @@
 			if (emu->ac97->id == AC97_ID_STAC9758) {
 				emu->rear_ac97 = 1;
 				snd_emu10k1_ptr_write(emu, AC97SLOT, 0, AC97SLOT_CNTR|AC97SLOT_LFE|AC97SLOT_REAR_LEFT|AC97SLOT_REAR_RIGHT);
+				snd_ac97_write_cache(emu->ac97, AC97_HEADPHONE, 0x0202);
 			}
 			/* remove unused AC97 controls */
 			snd_ac97_write_cache(emu->ac97, AC97_SURROUND_MASTER, 0x0202);
@@ -898,6 +1591,10 @@
 		}
 		for (; *c; c++)
 			remove_ctl(card, *c);
+	} else if (emu->card_capabilities->i2c_adc) {
+		c = audigy_remove_ctls_i2c_adc;
+		for (; *c; c++)
+			remove_ctl(card, *c);
 	} else {
 	no_ac97:
 		if (emu->card_capabilities->ecard)
@@ -911,6 +1608,8 @@
 	if (emu->audigy)
 		if (emu->card_capabilities->adc_1361t)
 			c = audigy_rename_ctls_1361t_adc;
+		else if (emu->card_capabilities->i2c_adc)
+			c = audigy_rename_ctls_i2c_adc;
 		else
 			c = audigy_rename_ctls;
 	else
@@ -1021,7 +1720,7 @@
 			return err;
 	}
 
-	if ( emu->card_capabilities->emu1212m) {
+	if ( emu->card_capabilities->emu1010) {
 		;  /* Disable the snd_audigy_spdif_shared_spdif */
 	} else if (emu->audigy) {
 		if ((kctl = snd_ctl_new1(&snd_audigy_shared_spdif, emu)) == NULL)
@@ -1045,6 +1744,48 @@
 		if ((err = snd_p16v_mixer(emu)))
 			return err;
 	}
+
+	if ( emu->card_capabilities->emu1010) {
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(snd_emu1010_output_enum_ctls); i++) {
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_emu1010_output_enum_ctls[i], emu));
+			if (err < 0)
+				return err;
+		}
+		for (i = 0; i < ARRAY_SIZE(snd_emu1010_input_enum_ctls); i++) {
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_emu1010_input_enum_ctls[i], emu));
+			if (err < 0)
+				return err;
+		}
+		for (i = 0; i < ARRAY_SIZE(snd_emu1010_adc_pads); i++) {
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_emu1010_adc_pads[i], emu));
+			if (err < 0)
+				return err;
+		}
+		for (i = 0; i < ARRAY_SIZE(snd_emu1010_dac_pads); i++) {
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_emu1010_dac_pads[i], emu));
+			if (err < 0)
+				return err;
+		}
+		err = snd_ctl_add(card, snd_ctl_new1(&snd_emu1010_internal_clock, emu));
+		if (err < 0)
+			return err;
+	}
+
+	if ( emu->card_capabilities->i2c_adc) {
+		int i;
+
+		err = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_i2c_capture_source, emu));
+		if (err < 0)
+			return err;
+
+		for (i = 0; i < ARRAY_SIZE(snd_audigy_i2c_volume_ctls); i++) {
+			err = snd_ctl_add(card, snd_ctl_new1(&snd_audigy_i2c_volume_ctls[i], emu));
+			if (err < 0)
+				return err;
+		}
+	}
 		
 	return 0;
 }
--- linux-2.6.18.noarch/sound/pci/emu10k1/emu10k1_main.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/emu10k1_main.c	2007-06-05 17:46:25.000000000 -0400
@@ -3,8 +3,10 @@
  *                   Creative Labs, Inc.
  *  Routines for control of EMU10K1 chips
  *
- *  Copyright (c) by James Courtier-Dutton <James@superbug.demon.co.uk>
+ *  Copyright (c) by James Courtier-Dutton <James@superbug.co.uk>
  *      Added support for Audigy 2 Value.
+ *  	Added EMU 1010 support.
+ *  	General bug fixes and enhancements.
  *
  *
  *  BUGS:
@@ -41,8 +43,10 @@
 
 #include <sound/core.h>
 #include <sound/emu10k1.h>
+#include <linux/firmware.h>
 #include "p16v.h"
 #include "tina2.h"
+#include "p17v.h"
 
 
 /*************************************************************************
@@ -117,11 +121,28 @@
 		0x0622,
 		0x1400,
 };
+
+static unsigned int i2c_adc_init[][2] = {
+	{ 0x17, 0x00 }, /* Reset */
+	{ 0x07, 0x00 }, /* Timeout */
+	{ 0x0b, 0x22 },  /* Interface control */
+	{ 0x0c, 0x22 },  /* Master mode control */
+	{ 0x0d, 0x08 },  /* Powerdown control */
+	{ 0x0e, 0xcf },  /* Attenuation Left  0x01 = -103dB, 0xff = 24dB */
+	{ 0x0f, 0xcf },  /* Attenuation Right 0.5dB steps */
+	{ 0x10, 0x7b },  /* ALC Control 1 */
+	{ 0x11, 0x00 },  /* ALC Control 2 */
+	{ 0x12, 0x32 },  /* ALC Control 3 */
+	{ 0x13, 0x00 },  /* Noise gate control */
+	{ 0x14, 0xa6 },  /* Limiter control */
+	{ 0x15, ADC_MUX_2 },  /* ADC Mixer control. Mic for Audigy 2 ZS Notebook */
+};
 	
 static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)
 {
 	unsigned int silent_page;
 	int ch;
+	u32 tmp;
 
 	/* disable audio and lock cache */
 	outl(HCFG_LOCKSOUNDCACHE | HCFG_LOCKTANKCACHE_MASK | HCFG_MUTEBUTTONENABLE,
@@ -160,8 +181,6 @@
 
 	if (emu->card_capabilities->ca0151_chip) { /* audigy2 */
 		/* Hacks for Alice3 to work independent of haP16V driver */
-		u32 tmp;
-
 		//Setup SRCMulti_I2S SamplingRate
 		tmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, 0);
 		tmp &= 0xfffff1ff;
@@ -181,8 +200,6 @@
 	}
 	if (emu->card_capabilities->ca0108_chip) { /* audigy2 Value */
 		/* Hacks for Alice3 to work independent of haP16V driver */
-		u32 tmp;
-
 		snd_printk(KERN_INFO "Audigy2 value: Special config.\n");
 		//Setup SRCMulti_I2S SamplingRate
 		tmp = snd_emu10k1_ptr_read(emu, A_SPDIF_SAMPLERATE, 0);
@@ -211,7 +228,7 @@
 		int size, n;
 
 		size = ARRAY_SIZE(spi_dac_init);
-		for (n=0; n < size; n++)
+		for (n = 0; n < size; n++)
 			snd_emu10k1_spi_write(emu, spi_dac_init[n]);
 
 		snd_emu10k1_ptr20_write(emu, 0x60, 0, 0x10);
@@ -228,6 +245,23 @@
 		outl(0x76, emu->port + A_IOCFG); /* Windows uses 0x3f76 */
 
 	}
+	if (emu->card_capabilities->i2c_adc) { /* Audigy 2 ZS Notebook with ADC Wolfson WM8775 */
+		int size, n;
+
+		snd_emu10k1_ptr20_write(emu, P17V_I2S_SRC_SEL, 0, 0x2020205f);
+		tmp = inl(emu->port + A_IOCFG);
+		outl(tmp | 0x4, emu->port + A_IOCFG);  /* Set bit 2 for mic input */
+		tmp = inl(emu->port + A_IOCFG);
+		size = ARRAY_SIZE(i2c_adc_init);
+		for (n = 0; n < size; n++)
+			snd_emu10k1_i2c_write(emu, i2c_adc_init[n][0], i2c_adc_init[n][1]);
+		for (n=0; n < 4; n++) {
+			emu->i2c_capture_volume[n][0]= 0xcf;
+			emu->i2c_capture_volume[n][1]= 0xcf;
+		}
+
+	}
+
 	
 	snd_emu10k1_ptr_write(emu, PTB, 0, emu->ptb_pages.addr);
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
@@ -239,6 +273,10 @@
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
 	}
 
+	if (emu->card_capabilities->emu1010) {
+		outl(HCFG_AUTOMUTE_ASYNC |
+			HCFG_EMU32_SLAVE |
+			HCFG_AUDIOENABLE, emu->port + HCFG);
 	/*
 	 *  Hokay, setup HCFG
 	 *   Mute Disable Audio = 0
@@ -246,7 +284,7 @@
 	 *   Lock Sound Memory = 0
 	 *   Auto Mute = 1
 	 */
-	if (emu->audigy) {
+	} else if (emu->audigy) {
 		if (emu->revision == 4) /* audigy2 */
 			outl(HCFG_AUDIOENABLE |
 			     HCFG_AC3ENABLE_CDSPDIF |
@@ -265,8 +303,10 @@
 		outl(HCFG_LOCKTANKCACHE_MASK | HCFG_AUTOMUTE | HCFG_JOYENABLE, emu->port + HCFG);
 
 	if (enable_ir) {	/* enable IR for SB Live */
-		if ( emu->card_capabilities->emu1212m) {
-			;  /* Disable all access to A_IOCFG for the emu1212m */
+		if (emu->card_capabilities->emu1010) {
+			;  /* Disable all access to A_IOCFG for the emu1010 */
+		} else if (emu->card_capabilities->i2c_adc) {
+			;  /* Disable A_IOCFG for Audigy 2 ZS Notebook */
 		} else if (emu->audigy) {
 			unsigned int reg = inl(emu->port + A_IOCFG);
 			outl(reg | A_IOCFG_GPOUT2, emu->port + A_IOCFG);
@@ -284,8 +324,10 @@
  		}
 	}
 	
-	if ( emu->card_capabilities->emu1212m) {
-		;  /* Disable all access to A_IOCFG for the emu1212m */
+	if (emu->card_capabilities->emu1010) {
+		;  /* Disable all access to A_IOCFG for the emu1010 */
+	} else if (emu->card_capabilities->i2c_adc) {
+		;  /* Disable A_IOCFG for Audigy 2 ZS Notebook */
 	} else if (emu->audigy) {	/* enable analog output */
 		unsigned int reg = inl(emu->port + A_IOCFG);
 		outl(reg | A_IOCFG_GPOUT0, emu->port + A_IOCFG);
@@ -302,8 +344,10 @@
 	outl(inl(emu->port + HCFG) | HCFG_AUDIOENABLE, emu->port + HCFG);
 
 	/* Enable analog/digital outs on audigy */
-	if ( emu->card_capabilities->emu1212m) {
-		;  /* Disable all access to A_IOCFG for the emu1212m */
+	if (emu->card_capabilities->emu1010) {
+		;  /* Disable all access to A_IOCFG for the emu1010 */
+	} else if (emu->card_capabilities->i2c_adc) {
+		;  /* Disable A_IOCFG for Audigy 2 ZS Notebook */
 	} else if (emu->audigy) {
 		outl(inl(emu->port + A_IOCFG) & ~0x44, emu->port + A_IOCFG);
  
@@ -596,133 +640,423 @@
 	return 0;
 }
 
-static int snd_emu1212m_fpga_write(struct snd_emu10k1 * emu, int reg, int value)
-{
-	if (reg<0 || reg>0x3f)
-		return 1;
-	reg+=0x40; /* 0x40 upwards are registers. */
-	if (value<0 || value>0x3f) /* 0 to 0x3f are values */
-		return 1;
-	outl(reg, emu->port + A_IOCFG);
-	outl(reg | 0x80, emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
-	outl(value, emu->port + A_IOCFG);
-	outl(value | 0x80 , emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
-
-	return 0;
-}
-
-static int snd_emu1212m_fpga_read(struct snd_emu10k1 * emu, int reg, int *value)
+static int snd_emu1010_load_firmware(struct snd_emu10k1 * emu, const char * filename)
 {
-	if (reg<0 || reg>0x3f)
-		return 1;
-	reg+=0x40; /* 0x40 upwards are registers. */
-	outl(reg, emu->port + A_IOCFG);
-	outl(reg | 0x80, emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
-	*value = inl(emu->port + A_IOCFG);
+	int err;
+	int n, i;
+	int reg;
+	int value;
+	const struct firmware *fw_entry;
 
-	return 0;
-}
+	if ((err = request_firmware(&fw_entry, filename, &emu->pci->dev)) != 0) {
+		snd_printk(KERN_ERR "firmware: %s not found. Err=%d\n",filename, err);
+		return err;
+	}
+	snd_printk(KERN_INFO "firmware size=0x%zx\n", fw_entry->size);
+	if (fw_entry->size != 0x133a4) {
+		snd_printk(KERN_ERR "firmware: %s wrong size.\n",filename);
+		return -EINVAL;
+	}
 
-static int snd_emu1212m_fpga_netlist_write(struct snd_emu10k1 * emu, int reg, int value)
-{
-	snd_emu1212m_fpga_write(emu, 0x00, ((reg >> 8) & 0x3f) );
-	snd_emu1212m_fpga_write(emu, 0x01, (reg & 0x3f) );
-	snd_emu1212m_fpga_write(emu, 0x02, ((value >> 8) & 0x3f) );
-	snd_emu1212m_fpga_write(emu, 0x03, (value & 0x3f) );
+	/* The FPGA is a Xilinx Spartan IIE XC2S50E */
+	/* GPIO7 -> FPGA PGMN
+	 * GPIO6 -> FPGA CCLK
+	 * GPIO5 -> FPGA DIN
+	 * FPGA CONFIG OFF -> FPGA PGMN
+	 */
+	outl(0x00, emu->port + A_IOCFG); /* Set PGMN low for 1uS. */
+	udelay(1);
+	outl(0x80, emu->port + A_IOCFG); /* Leave bit 7 set during netlist setup. */
+	udelay(100); /* Allow FPGA memory to clean */
+	for(n = 0; n < fw_entry->size; n++) {
+		value=fw_entry->data[n];	
+		for(i = 0; i < 8; i++) {
+			reg = 0x80;
+			if (value & 0x1)
+				reg = reg | 0x20;
+			value = value >> 1;   
+			outl(reg, emu->port + A_IOCFG);
+			outl(reg | 0x40, emu->port + A_IOCFG);
+		}
+	}
+	/* After programming, set GPIO bit 4 high again. */
+	outl(0x10, emu->port + A_IOCFG);
+	
 
+        release_firmware(fw_entry);
 	return 0;
 }
 
-static int snd_emu10k1_emu1212m_init(struct snd_emu10k1 * emu)
+static int snd_emu10k1_emu1010_init(struct snd_emu10k1 * emu)
 {
 	unsigned int i;
-	int tmp;
-
-	snd_printk(KERN_ERR "emu1212m: Special config.\n");
+	int tmp,tmp2;
+	int reg;
+	int err;
+	const char *hana_filename = "emu/hana.fw";
+	const char *dock_filename = "emu/audio_dock.fw";
+
+	snd_printk(KERN_INFO "emu1010: Special config.\n");
+	/* AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
+	 * Lock Sound Memory Cache, Lock Tank Memory Cache,
+	 * Mute all codecs.
+	 */
 	outl(0x0005a00c, emu->port + HCFG);
-	outl(0x0005a004, emu->port + HCFG);
+	/* AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
+	 * Lock Tank Memory Cache,
+	 * Mute all codecs.
+	 */
+	outl(0x0005a004, emu->port + HCFG); 
+	/* AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
+	 * Mute all codecs.
+	 */
 	outl(0x0005a000, emu->port + HCFG);
+	/* AC97 2.1, Any 16Meg of 4Gig address, Auto-Mute, EMU32 Slave,
+	 * Mute all codecs.
+	 */
 	outl(0x0005a000, emu->port + HCFG);
 
-	snd_emu1212m_fpga_read(emu, 0x22, &tmp );
-	snd_emu1212m_fpga_read(emu, 0x23, &tmp );
-	snd_emu1212m_fpga_read(emu, 0x24, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x04, 0x01 );
-	snd_emu1212m_fpga_read(emu, 0x0b, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x0b, 0x01 );
-	snd_emu1212m_fpga_read(emu, 0x10, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x10, 0x00 );
-	snd_emu1212m_fpga_read(emu, 0x11, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x11, 0x30 );
-	snd_emu1212m_fpga_read(emu, 0x13, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x13, 0x0f );
-	snd_emu1212m_fpga_read(emu, 0x11, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x11, 0x30 );
-	snd_emu1212m_fpga_read(emu, 0x0a, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x0a, 0x10 );
-	snd_emu1212m_fpga_write(emu, 0x0c, 0x19 );
-	snd_emu1212m_fpga_write(emu, 0x12, 0x0c );
-	snd_emu1212m_fpga_write(emu, 0x09, 0x0f );
-	snd_emu1212m_fpga_write(emu, 0x06, 0x00 );
-	snd_emu1212m_fpga_write(emu, 0x05, 0x00 );
-	snd_emu1212m_fpga_write(emu, 0x0e, 0x12 );
-	snd_emu1212m_fpga_netlist_write(emu, 0x0000, 0x0200);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0001, 0x0201);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0002, 0x0500);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0003, 0x0501);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0004, 0x0400);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0005, 0x0401);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0006, 0x0402);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0007, 0x0403);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0008, 0x0404);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0009, 0x0405);
-	snd_emu1212m_fpga_netlist_write(emu, 0x000a, 0x0406);
-	snd_emu1212m_fpga_netlist_write(emu, 0x000b, 0x0407);
-	snd_emu1212m_fpga_netlist_write(emu, 0x000c, 0x0100);
-	snd_emu1212m_fpga_netlist_write(emu, 0x000d, 0x0104);
-	snd_emu1212m_fpga_netlist_write(emu, 0x000e, 0x0200);
-	snd_emu1212m_fpga_netlist_write(emu, 0x000f, 0x0201);
-	for (i=0;i < 0x20;i++) {
-		snd_emu1212m_fpga_netlist_write(emu, 0x0100+i, 0x0000);
-	}
-	for (i=0;i < 4;i++) {
-		snd_emu1212m_fpga_netlist_write(emu, 0x0200+i, 0x0000);
-	}
-	for (i=0;i < 7;i++) {
-		snd_emu1212m_fpga_netlist_write(emu, 0x0300+i, 0x0000);
-	}
-	for (i=0;i < 7;i++) {
-		snd_emu1212m_fpga_netlist_write(emu, 0x0400+i, 0x0000);
-	}
-	snd_emu1212m_fpga_netlist_write(emu, 0x0500, 0x0108);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0501, 0x010c);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0600, 0x0110);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0601, 0x0114);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0700, 0x0118);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0701, 0x011c);
-	snd_emu1212m_fpga_write(emu, 0x07, 0x01 );
+	/* Disable 48Volt power to Audio Dock */
+	snd_emu1010_fpga_write(emu,  EMU_HANA_DOCK_PWR,  0 );
+
+	/* ID, should read & 0x7f = 0x55. (Bit 7 is the IRQ bit) */
+	snd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg );
+	snd_printdd("reg1=0x%x\n",reg);
+	if (reg == 0x55) {
+		/* FPGA netlist already present so clear it */
+		/* Return to programming mode */
+
+		snd_emu1010_fpga_write(emu,  EMU_HANA_FPGA_CONFIG, 0x02 );
+	}
+	snd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg );
+	snd_printdd("reg2=0x%x\n",reg);
+	if (reg == 0x55) {
+		/* FPGA failed to return to programming mode */
+		return -ENODEV;
+	}
+	snd_printk(KERN_INFO "emu1010: EMU_HANA_ID=0x%x\n",reg);
+	if ((err = snd_emu1010_load_firmware(emu, hana_filename)) != 0) {
+		snd_printk(KERN_INFO "emu1010: Loading Hana Firmware file %s failed\n", hana_filename);
+		return err;
+	}
+
+	/* ID, should read & 0x7f = 0x55 when FPGA programmed. */
+	snd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg );
+	if (reg != 0x55) {
+		/* FPGA failed to be programmed */
+		snd_printk(KERN_INFO "emu1010: Loading Hana Firmware file failed, reg=0x%x\n", reg);
+		return -ENODEV;
+	}
+
+	snd_printk(KERN_INFO "emu1010: Hana Firmware loaded\n");
+	snd_emu1010_fpga_read(emu, EMU_HANA_MAJOR_REV, &tmp );
+	snd_emu1010_fpga_read(emu, EMU_HANA_MINOR_REV, &tmp2 );
+	snd_printk("Hana ver:%d.%d\n",tmp ,tmp2);
+	/* Enable 48Volt power to Audio Dock */
+	snd_emu1010_fpga_write(emu,  EMU_HANA_DOCK_PWR,  EMU_HANA_DOCK_PWR_ON );
+
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &reg );
+	snd_printk(KERN_INFO "emu1010: Card options=0x%x\n",reg);
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &reg );
+	snd_printk(KERN_INFO "emu1010: Card options=0x%x\n",reg);
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTICAL_TYPE, &tmp ); 
+	/* ADAT input. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_OPTICAL_TYPE, 0x01 );
+	snd_emu1010_fpga_read(emu, EMU_HANA_ADC_PADS, &tmp );
+	/* Set no attenuation on Audio Dock pads. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_ADC_PADS, 0x00 );
+	emu->emu1010.adc_pads = 0x00;
+	snd_emu1010_fpga_read(emu, EMU_HANA_DOCK_MISC, &tmp );
+	/* Unmute Audio dock DACs, Headphone source DAC-4. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_MISC, 0x30 );
+	snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2, 0x12 );
+	snd_emu1010_fpga_read(emu, EMU_HANA_DAC_PADS, &tmp );
+	/* DAC PADs. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_DAC_PADS, 0x0f );
+	emu->emu1010.dac_pads = 0x0f;
+	snd_emu1010_fpga_read(emu, EMU_HANA_DOCK_MISC, &tmp );
+	snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_MISC, 0x30 );
+	snd_emu1010_fpga_read(emu, EMU_HANA_SPDIF_MODE, &tmp );
+	/* SPDIF Format. Set Consumer mode, 24bit, copy enable */
+	snd_emu1010_fpga_write(emu, EMU_HANA_SPDIF_MODE, 0x10 );
+	/* MIDI routing */
+	snd_emu1010_fpga_write(emu, EMU_HANA_MIDI_IN, 0x19 );
+	/* Unknown. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_MIDI_OUT, 0x0c );
+	/* snd_emu1010_fpga_write(emu, 0x09, 0x0f ); // IRQ Enable: All on */
+	/* IRQ Enable: All off */
+	snd_emu1010_fpga_write(emu, EMU_HANA_IRQ_ENABLE, 0x00 );
+
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &reg );
+	snd_printk(KERN_INFO "emu1010: Card options3=0x%x\n",reg);
+	/* Default WCLK set to 48kHz. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, 0x00 );
+	/* Word Clock source, Internal 48kHz x1 */
+	snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K );
+	//snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_4X );
+	/* Audio Dock LEDs. */
+	snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2, 0x12 );
 
-	snd_emu1212m_fpga_read(emu, 0x21, &tmp );
+#if 0
+	/* For 96kHz */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_0, EMU_SRC_HAMOA_ADC_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_1, EMU_SRC_HAMOA_ADC_RIGHT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_4, EMU_SRC_HAMOA_ADC_LEFT2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_5, EMU_SRC_HAMOA_ADC_RIGHT2);
+#endif
+#if 0
+	/* For 192kHz */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_0, EMU_SRC_HAMOA_ADC_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_1, EMU_SRC_HAMOA_ADC_RIGHT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_2, EMU_SRC_HAMOA_ADC_LEFT2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_3, EMU_SRC_HAMOA_ADC_RIGHT2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_4, EMU_SRC_HAMOA_ADC_LEFT3);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_5, EMU_SRC_HAMOA_ADC_RIGHT3);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_6, EMU_SRC_HAMOA_ADC_LEFT4);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_7, EMU_SRC_HAMOA_ADC_RIGHT4);
+#endif
+#if 1
+	/* For 48kHz */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_0, EMU_SRC_DOCK_MIC_A1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_1, EMU_SRC_DOCK_MIC_B1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_2, EMU_SRC_HAMOA_ADC_LEFT2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_3, EMU_SRC_HAMOA_ADC_LEFT2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_4, EMU_SRC_DOCK_ADC1_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_5, EMU_SRC_DOCK_ADC1_RIGHT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_6, EMU_SRC_DOCK_ADC2_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_7, EMU_SRC_DOCK_ADC2_RIGHT1);
+#endif
+#if 0
+	/* Original */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_4, EMU_SRC_HANA_ADAT);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_5, EMU_SRC_HANA_ADAT + 1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_6, EMU_SRC_HANA_ADAT + 2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_7, EMU_SRC_HANA_ADAT + 3);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_8, EMU_SRC_HANA_ADAT + 4);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_9, EMU_SRC_HANA_ADAT + 5);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_A, EMU_SRC_HANA_ADAT + 6);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_B, EMU_SRC_HANA_ADAT + 7);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_C, EMU_SRC_DOCK_MIC_A1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_D, EMU_SRC_DOCK_MIC_B1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_E, EMU_SRC_HAMOA_ADC_LEFT2);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE2_EMU32_F, EMU_SRC_HAMOA_ADC_LEFT2);
+#endif
+	for (i = 0;i < 0x20; i++ ) {
+		/* AudioDock Elink <-  Silence */
+		snd_emu1010_fpga_link_dst_src_write(emu, 0x0100+i, EMU_SRC_SILENCE);
+	}
+	for (i = 0;i < 4; i++) {
+		/* Hana SPDIF Out <- Silence */
+		snd_emu1010_fpga_link_dst_src_write(emu, 0x0200+i, EMU_SRC_SILENCE);
+	}
+	for (i = 0;i < 7; i++) {
+		/* Hamoa DAC <- Silence */
+		snd_emu1010_fpga_link_dst_src_write(emu, 0x0300+i, EMU_SRC_SILENCE);
+	}
+	for (i = 0;i < 7; i++) {
+		/* Hana ADAT Out <- Silence */
+		snd_emu1010_fpga_link_dst_src_write(emu, EMU_DST_HANA_ADAT + i, EMU_SRC_SILENCE);
+	}
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE_I2S0_LEFT, EMU_SRC_DOCK_ADC1_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE_I2S0_RIGHT, EMU_SRC_DOCK_ADC1_RIGHT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE_I2S1_LEFT, EMU_SRC_DOCK_ADC2_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE_I2S1_RIGHT, EMU_SRC_DOCK_ADC2_RIGHT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE_I2S2_LEFT, EMU_SRC_DOCK_ADC3_LEFT1);
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_ALICE_I2S2_RIGHT, EMU_SRC_DOCK_ADC3_RIGHT1);
+	snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, 0x01 ); // Unmute all
 
-	outl(0x0000a000, emu->port + HCFG);
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &tmp );
+	
+	/* AC97 1.03, Any 32Meg of 2Gig address, Auto-Mute, EMU32 Slave,
+	 * Lock Sound Memory Cache, Lock Tank Memory Cache,
+	 * Mute all codecs.
+	 */
+	outl(0x0000a000, emu->port + HCFG); 
+	/* AC97 1.03, Any 32Meg of 2Gig address, Auto-Mute, EMU32 Slave,
+	 * Lock Sound Memory Cache, Lock Tank Memory Cache,
+	 * Un-Mute all codecs.
+	 */
 	outl(0x0000a001, emu->port + HCFG);
+ 
 	/* Initial boot complete. Now patches */
 
-	snd_emu1212m_fpga_read(emu, 0x21, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x0c, 0x19 );
-	snd_emu1212m_fpga_write(emu, 0x12, 0x0c );
-	snd_emu1212m_fpga_write(emu, 0x0c, 0x19 );
-	snd_emu1212m_fpga_write(emu, 0x12, 0x0c );
-	snd_emu1212m_fpga_read(emu, 0x0a, &tmp );
-	snd_emu1212m_fpga_write(emu, 0x0a, 0x10 );
-
-	snd_emu1212m_fpga_read(emu, 0x20, &tmp );
-	snd_emu1212m_fpga_read(emu, 0x21, &tmp );
-
-	snd_emu1212m_fpga_netlist_write(emu, 0x0300, 0x0312);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0301, 0x0313);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0200, 0x0302);
-	snd_emu1212m_fpga_netlist_write(emu, 0x0201, 0x0303);
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &tmp );
+	snd_emu1010_fpga_write(emu, EMU_HANA_MIDI_IN, 0x19 ); /* MIDI Route */
+	snd_emu1010_fpga_write(emu, EMU_HANA_MIDI_OUT, 0x0c ); /* Unknown */
+	snd_emu1010_fpga_write(emu, EMU_HANA_MIDI_IN, 0x19 ); /* MIDI Route */
+	snd_emu1010_fpga_write(emu, EMU_HANA_MIDI_OUT, 0x0c ); /* Unknown */
+	snd_emu1010_fpga_read(emu, EMU_HANA_SPDIF_MODE, &tmp ); 
+	snd_emu1010_fpga_write(emu, EMU_HANA_SPDIF_MODE, 0x10 ); /* SPDIF Format spdif  (or 0x11 for aes/ebu) */
+
+	/* Delay to allow Audio Dock to settle */
+	msleep(100);
+	snd_emu1010_fpga_read(emu, EMU_HANA_IRQ_STATUS, &tmp ); /* IRQ Status */
+	snd_emu1010_fpga_read(emu, EMU_HANA_OPTION_CARDS, &reg ); /* OPTIONS: Which cards are attached to the EMU */
+	/* FIXME: The loading of this should be able to happen any time,
+	 * as the user can plug/unplug it at any time
+	 */
+	if (reg & (EMU_HANA_OPTION_DOCK_ONLINE | EMU_HANA_OPTION_DOCK_OFFLINE) ) {
+		/* Audio Dock attached */
+		/* Return to Audio Dock programming mode */
+		snd_printk(KERN_INFO "emu1010: Loading Audio Dock Firmware\n");
+		snd_emu1010_fpga_write(emu,  EMU_HANA_FPGA_CONFIG, EMU_HANA_FPGA_CONFIG_AUDIODOCK );
+		if ((err = snd_emu1010_load_firmware(emu, dock_filename)) != 0) {
+			return err;
+		}
+		snd_emu1010_fpga_write(emu,  EMU_HANA_FPGA_CONFIG, 0 );
+		snd_emu1010_fpga_read(emu, EMU_HANA_IRQ_STATUS, &reg );
+		snd_printk(KERN_INFO "emu1010: EMU_HANA+DOCK_IRQ_STATUS=0x%x\n",reg);
+		/* ID, should read & 0x7f = 0x55 when FPGA programmed. */
+		snd_emu1010_fpga_read(emu, EMU_HANA_ID, &reg );
+		snd_printk(KERN_INFO "emu1010: EMU_HANA+DOCK_ID=0x%x\n",reg);
+		if (reg != 0x55) {
+			/* FPGA failed to be programmed */
+			snd_printk(KERN_INFO "emu1010: Loading Audio Dock Firmware file failed, reg=0x%x\n", reg);
+			return 0;
+			return -ENODEV;
+		}
+		snd_printk(KERN_INFO "emu1010: Audio Dock Firmware loaded\n");
+		snd_emu1010_fpga_read(emu, EMU_DOCK_MAJOR_REV, &tmp );
+		snd_emu1010_fpga_read(emu, EMU_DOCK_MINOR_REV, &tmp2 );
+		snd_printk("Audio Dock ver:%d.%d\n",tmp ,tmp2);
+	}
+#if 0
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HAMOA_DAC_LEFT1, EMU_SRC_ALICE_EMU32B + 2); /* ALICE2 bus 0xa2 */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HAMOA_DAC_RIGHT1, EMU_SRC_ALICE_EMU32B + 3); /* ALICE2 bus 0xa3 */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_SPDIF_LEFT1, EMU_SRC_ALICE_EMU32A + 2); /* ALICE2 bus 0xb2 */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_SPDIF_RIGHT1, EMU_SRC_ALICE_EMU32A + 3); /* ALICE2 bus 0xb3 */
+#endif
+	/* Default outputs */
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC1_LEFT1, EMU_SRC_ALICE_EMU32A + 0); /* ALICE2 bus 0xa0 */
+	emu->emu1010.output_source[0] = 21;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC1_RIGHT1, EMU_SRC_ALICE_EMU32A + 1);
+	emu->emu1010.output_source[1] = 22;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC2_LEFT1, EMU_SRC_ALICE_EMU32A + 2);
+	emu->emu1010.output_source[2] = 23;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC2_RIGHT1, EMU_SRC_ALICE_EMU32A + 3);
+	emu->emu1010.output_source[3] = 24;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC3_LEFT1, EMU_SRC_ALICE_EMU32A + 4);
+	emu->emu1010.output_source[4] = 25;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC3_RIGHT1, EMU_SRC_ALICE_EMU32A + 5);
+	emu->emu1010.output_source[5] = 26;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC4_LEFT1, EMU_SRC_ALICE_EMU32A + 6);
+	emu->emu1010.output_source[6] = 27;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_DAC4_RIGHT1, EMU_SRC_ALICE_EMU32A + 7);
+	emu->emu1010.output_source[7] = 28;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_PHONES_LEFT1, EMU_SRC_ALICE_EMU32A + 0); /* ALICE2 bus 0xa0 */
+	emu->emu1010.output_source[8] = 21;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_PHONES_RIGHT1, EMU_SRC_ALICE_EMU32A + 1);
+	emu->emu1010.output_source[9] = 22;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_SPDIF_LEFT1, EMU_SRC_ALICE_EMU32A + 0); /* ALICE2 bus 0xa0 */
+	emu->emu1010.output_source[10] = 21;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_DOCK_SPDIF_RIGHT1, EMU_SRC_ALICE_EMU32A + 1);
+	emu->emu1010.output_source[11] = 22;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_SPDIF_LEFT1, EMU_SRC_ALICE_EMU32A + 0); /* ALICE2 bus 0xa0 */
+	emu->emu1010.output_source[12] = 21;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_SPDIF_RIGHT1, EMU_SRC_ALICE_EMU32A + 1);
+	emu->emu1010.output_source[13] = 22;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HAMOA_DAC_LEFT1, EMU_SRC_ALICE_EMU32A + 0); /* ALICE2 bus 0xa0 */
+	emu->emu1010.output_source[14] = 21;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HAMOA_DAC_RIGHT1, EMU_SRC_ALICE_EMU32A + 1);
+	emu->emu1010.output_source[15] = 22;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT, EMU_SRC_ALICE_EMU32A + 0); /* ALICE2 bus 0xa0 */
+	emu->emu1010.output_source[16] = 21;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 1, EMU_SRC_ALICE_EMU32A + 1);
+	emu->emu1010.output_source[17] = 22;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 2, EMU_SRC_ALICE_EMU32A + 2);
+	emu->emu1010.output_source[18] = 23;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 3, EMU_SRC_ALICE_EMU32A + 3);
+	emu->emu1010.output_source[19] = 24;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 4, EMU_SRC_ALICE_EMU32A + 4);
+	emu->emu1010.output_source[20] = 25;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 5, EMU_SRC_ALICE_EMU32A + 5);
+	emu->emu1010.output_source[21] = 26;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 6, EMU_SRC_ALICE_EMU32A + 6);
+	emu->emu1010.output_source[22] = 27;
+	snd_emu1010_fpga_link_dst_src_write(emu,
+		EMU_DST_HANA_ADAT + 7, EMU_SRC_ALICE_EMU32A + 7);
+	emu->emu1010.output_source[23] = 28;
+
+	/* TEMP: Select SPDIF in/out */
+	snd_emu1010_fpga_write(emu, EMU_HANA_OPTICAL_TYPE, 0x0); /* Output spdif */
+
+	/* TEMP: Select 48kHz SPDIF out */
+	snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, 0x0); /* Mute all */
+	snd_emu1010_fpga_write(emu, EMU_HANA_DEFCLOCK, 0x0); /* Default fallback clock 48kHz */
+	/* Word Clock source, Internal 48kHz x1 */
+	snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K );
+	//snd_emu1010_fpga_write(emu, EMU_HANA_WCLOCK, EMU_HANA_WCLOCK_INT_48K | EMU_HANA_WCLOCK_4X );
+	emu->emu1010.internal_clock = 1; /* 48000 */
+	snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_LEDS_2, 0x12);/* Set LEDs on Audio Dock */
+	snd_emu1010_fpga_write(emu, EMU_HANA_UNMUTE, 0x1); /* Unmute all */
+	//snd_emu1010_fpga_write(emu, 0x7, 0x0); /* Mute all */
+	//snd_emu1010_fpga_write(emu, 0x7, 0x1); /* Unmute all */
+	//snd_emu1010_fpga_write(emu, 0xe, 0x12); /* Set LEDs on Audio Dock */
 
 	return 0;
 }
@@ -747,6 +1081,10 @@
 		}
 		snd_emu10k1_free_efx(emu);
        	}
+	if (emu->card_capabilities->emu1010) {
+		/* Disable 48Volt power to Audio Dock */
+		snd_emu1010_fpga_write(emu,  EMU_HANA_DOCK_PWR,  0 );
+	}
 	if (emu->memhdr)
 		snd_util_memhdr_free(emu->memhdr);
 	if (emu->silent_page.area)
@@ -759,7 +1097,7 @@
 	free_pm_buffer(emu);
 #endif
 	if (emu->irq >= 0)
-		free_irq(emu->irq, (void *)emu);
+		free_irq(emu->irq, emu);
 	if (emu->port)
 		pci_release_regions(emu->pci);
 	if (emu->card_capabilities->ca0151_chip) /* P16V */	
@@ -838,10 +1176,11 @@
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	/* Audigy 2 ZS Notebook Cardbus card.*/
-	/* Tested by James@superbug.co.uk 22th December 2005 */
+	/* Tested by James@superbug.co.uk 6th November 2006 */
 	/* Audio output 7.1/Headphones working.
 	 * Digital output working. (AC3 not checked, only PCM)
-	 * Audio inputs not tested.
+	 * Audio Mic/Line inputs working.
+	 * Digital input not tested.
 	 */ 
 	/* DSP: Tina2
 	 * DAC: Wolfson WM8768/WM8568
@@ -849,6 +1188,25 @@
 	 * AC97: None
 	 * CA0151: None
 	 */
+	/* Tested by James@superbug.co.uk 4th April 2006 */
+	/* A_IOCFG bits
+	 * Output
+	 * 0: Not Used
+	 * 1: 0 = Mute all the 7.1 channel out. 1 = unmute.
+	 * 2: Analog input 0 = line in, 1 = mic in
+	 * 3: Not Used
+	 * 4: Digital output 0 = off, 1 = on.
+	 * 5: Not Used
+	 * 6: Not Used
+	 * 7: Not Used
+	 * Input
+	 *      All bits 1 (0x3fxx) means nothing plugged in.
+	 * 8-9: 0 = Line in/Mic, 2 = Optical in, 3 = Nothing.
+	 * A-B: 0 = Headphones, 2 = Optical out, 3 = Nothing.
+	 * C-D: 2 = Front/Rear/etc, 3 = nothing.
+	 * E-F: Always 0
+	 *
+	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
 	 .driver = "Audigy2", .name = "Audigy 2 ZS Notebook [SB0530]", 
 	 .id = "Audigy2",
@@ -856,6 +1214,7 @@
 	 .ca0108_chip = 1,
 	 .ca_cardbus_chip = 1,
 	 .spi_dac = 1,
+	 .i2c_adc = 1,
 	 .spk71 = 1} ,
 	{.vendor = 0x1102, .device = 0x0008, 
 	 .driver = "Audigy2", .name = "Audigy 2 Value [Unknown]", 
@@ -865,11 +1224,12 @@
 	 .ac97_chip = 1} ,
 	/* Tested by James@superbug.co.uk 8th July 2005. No sound available yet. */
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x40011102,
-	 .driver = "Audigy2", .name = "E-mu 1212m [4001]", 
-	 .id = "EMU1212m",
+	 .driver = "Audigy2", .name = "E-mu 1010 [4001]", 
+	 .id = "EMU1010",
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
-	 .emu1212m = 1} ,
+	 .spk71 = 1,
+	 .emu1010 = 1} ,
 	/* Tested by James@superbug.co.uk 3rd July 2005 */
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x20071102,
 	 .driver = "Audigy2", .name = "Audigy 4 PRO [SB0380]", 
@@ -927,6 +1287,7 @@
 	 .ca0151_chip = 1,
 	 .spk71 = 1,
 	 .spdif_bug = 1,
+	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
 	 .driver = "Audigy2", .name = "Audigy 2 EX [1005]", 
@@ -955,6 +1316,7 @@
 	 .ca0151_chip = 1,
 	 .spk71 = 1,
 	 .spdif_bug = 1,
+	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit. Fixes ALSA bug#324 */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .revision = 0x04,
 	 .driver = "Audigy2", .name = "Audigy 2 [Unknown]",
@@ -1294,8 +1656,8 @@
 	} else if (emu->card_capabilities->ca_cardbus_chip) {
 		if ((err = snd_emu10k1_cardbus_init(emu)) < 0)
 			goto error;
- 	} else if (emu->card_capabilities->emu1212m) {
- 		if ((err = snd_emu10k1_emu1212m_init(emu)) < 0) {
+ 	} else if (emu->card_capabilities->emu1010) {
+ 		if ((err = snd_emu10k1_emu1010_init(emu)) < 0) {
  			snd_emu10k1_free(emu);
  			return err;
  		}
@@ -1443,8 +1805,8 @@
 		snd_emu10k1_ecard_init(emu);
 	else if (emu->card_capabilities->ca_cardbus_chip)
 		snd_emu10k1_cardbus_init(emu);
-	else if (emu->card_capabilities->emu1212m)
- 		snd_emu10k1_emu1212m_init(emu);
+	else if (emu->card_capabilities->emu1010)
+ 		snd_emu10k1_emu1010_init(emu);
 	else
 		snd_emu10k1_ptr_write(emu, AC97SLOT, 0, AC97SLOT_CNTR|AC97SLOT_LFE);
 	snd_emu10k1_init(emu, emu->enable_ir, 1);
--- linux-2.6.18.noarch/sound/pci/emu10k1/io.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/emu10k1/io.c	2007-06-05 17:46:26.000000000 -0400
@@ -30,6 +30,7 @@
 #include <sound/core.h>
 #include <sound/emu10k1.h>
 #include <linux/delay.h>
+#include "p17v.h"
 
 unsigned int snd_emu10k1_ptr_read(struct snd_emu10k1 * emu, unsigned int reg, unsigned int chn)
 {
@@ -167,6 +168,109 @@
 	return 0;
 }
 
+/* The ADC does not support i2c read, so only write is implemented */
+int snd_emu10k1_i2c_write(struct snd_emu10k1 *emu,
+				u32 reg,
+				u32 value)
+{
+	u32 tmp;
+	int timeout = 0;
+	int status;
+	int retry;
+	if ((reg > 0x7f) || (value > 0x1ff)) {
+		snd_printk(KERN_ERR "i2c_write: invalid values.\n");
+		return -EINVAL;
+	}
+
+	tmp = reg << 25 | value << 16;
+	// snd_printk("I2C-write:reg=0x%x, value=0x%x\n", reg, value);
+	/* Not sure what this I2C channel controls. */
+	/* snd_emu10k1_ptr_write(emu, P17V_I2C_0, 0, tmp); */
+
+	/* This controls the I2C connected to the WM8775 ADC Codec */
+	snd_emu10k1_ptr20_write(emu, P17V_I2C_1, 0, tmp);
+	tmp = snd_emu10k1_ptr20_read(emu, P17V_I2C_1, 0); /* write post */
+
+	for (retry = 0; retry < 10; retry++) {
+		/* Send the data to i2c */
+		//tmp = snd_emu10k1_ptr_read(emu, P17V_I2C_ADDR, 0);
+		//tmp = tmp & ~(I2C_A_ADC_READ|I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD_MASK);
+		tmp = 0;
+		tmp = tmp | (I2C_A_ADC_LAST|I2C_A_ADC_START|I2C_A_ADC_ADD);
+		snd_emu10k1_ptr20_write(emu, P17V_I2C_ADDR, 0, tmp);
+
+		/* Wait till the transaction ends */
+		while (1) {
+			udelay(10);
+			status = snd_emu10k1_ptr20_read(emu, P17V_I2C_ADDR, 0);
+                	// snd_printk("I2C:status=0x%x\n", status);
+			timeout++;
+			if ((status & I2C_A_ADC_START) == 0)
+				break;
+
+			if (timeout > 1000) {
+                		snd_printk("emu10k1:I2C:timeout status=0x%x\n", status);
+				break;
+			}
+		}
+		//Read back and see if the transaction is successful
+		if ((status & I2C_A_ADC_ABORT) == 0)
+			break;
+	}
+
+	if (retry == 10) {
+		snd_printk(KERN_ERR "Writing to ADC failed!\n");
+		return -EINVAL;
+	}
+    
+    	return 0;
+}
+
+int snd_emu1010_fpga_write(struct snd_emu10k1 * emu, int reg, int value)
+{
+	if (reg < 0 || reg > 0x3f)
+		return 1;
+	reg += 0x40; /* 0x40 upwards are registers. */
+	if (value < 0 || value > 0x3f) /* 0 to 0x3f are values */
+		return 1;
+	outl(reg, emu->port + A_IOCFG);
+	udelay(10);
+	outl(reg | 0x80, emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
+	udelay(10);
+	outl(value, emu->port + A_IOCFG);
+	udelay(10);
+	outl(value | 0x80 , emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
+
+	return 0;
+}
+
+int snd_emu1010_fpga_read(struct snd_emu10k1 * emu, int reg, int *value)
+{
+	if (reg < 0 || reg > 0x3f)
+		return 1;
+	reg += 0x40; /* 0x40 upwards are registers. */
+	outl(reg, emu->port + A_IOCFG);
+	udelay(10);
+	outl(reg | 0x80, emu->port + A_IOCFG);  /* High bit clocks the value into the fpga. */
+	udelay(10);
+	*value = ((inl(emu->port + A_IOCFG) >> 8) & 0x7f);
+
+	return 0;
+}
+
+/* Each Destination has one and only one Source,
+ * but one Source can feed any number of Destinations simultaneously.
+ */
+int snd_emu1010_fpga_link_dst_src_write(struct snd_emu10k1 * emu, int dst, int src)
+{
+	snd_emu1010_fpga_write(emu, 0x00, ((dst >> 8) & 0x3f) );
+	snd_emu1010_fpga_write(emu, 0x01, (dst & 0x3f) );
+	snd_emu1010_fpga_write(emu, 0x02, ((src >> 8) & 0x3f) );
+	snd_emu1010_fpga_write(emu, 0x03, (src & 0x3f) );
+
+	return 0;
+}
+
 void snd_emu10k1_intr_enable(struct snd_emu10k1 *emu, unsigned int intrenb)
 {
 	unsigned long flags;
--- linux-2.6.18.noarch/sound/pci/trident/trident_main.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/trident/trident_main.c	2007-06-05 17:47:58.000000000 -0400
@@ -40,6 +40,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/trident.h>
 #include <sound/asoundef.h>
 
@@ -2627,6 +2628,8 @@
 	return 0;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_gvol, -6375, 25, 0);
+
 static int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
 {
@@ -2653,6 +2656,7 @@
 	.get =		snd_trident_vol_control_get,
 	.put =		snd_trident_vol_control_put,
 	.private_value = 16,
+	.tlv = { .p = db_scale_gvol },
 };
 
 static struct snd_kcontrol_new snd_trident_vol_wave_control __devinitdata =
@@ -2663,6 +2667,7 @@
 	.get =		snd_trident_vol_control_get,
 	.put =		snd_trident_vol_control_put,
 	.private_value = 0,
+	.tlv = { .p = db_scale_gvol },
 };
 
 /*---------------------------------------------------------------------------
@@ -2730,6 +2735,7 @@
 	.info =		snd_trident_pcm_vol_control_info,
 	.get =		snd_trident_pcm_vol_control_get,
 	.put =		snd_trident_pcm_vol_control_put,
+	/* FIXME: no tlv yet */
 };
 
 /*---------------------------------------------------------------------------
@@ -2839,6 +2845,8 @@
 	return change;
 }
 
+static const DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);
+
 static struct snd_kcontrol_new snd_trident_pcm_rvol_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -2848,6 +2856,7 @@
 	.info =		snd_trident_pcm_rvol_control_info,
 	.get =		snd_trident_pcm_rvol_control_get,
 	.put =		snd_trident_pcm_rvol_control_put,
+	.tlv = { .p = db_scale_crvol },
 };
 
 /*---------------------------------------------------------------------------
@@ -2903,6 +2912,7 @@
 	.info =		snd_trident_pcm_cvol_control_info,
 	.get =		snd_trident_pcm_cvol_control_get,
 	.put =		snd_trident_pcm_cvol_control_put,
+	.tlv = { .p = db_scale_crvol },
 };
 
 static void snd_trident_notify_pcm_change1(struct snd_card *card,
@@ -3371,8 +3381,8 @@
 		snd_printk(KERN_ERR "trident: unable to allocate TLB buffer\n");
 		return -ENOMEM;
 	}
-	trident->tlb.entries = (unsigned int*)(((unsigned long)trident->tlb.buffer.area + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1));
-	trident->tlb.entries_dmaaddr = (trident->tlb.buffer.addr + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1);
+	trident->tlb.entries = (unsigned int*)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);
+	trident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer.addr, SNDRV_TRIDENT_MAX_PAGES * 4);
 	/* allocate shadow TLB page table (virtual addresses) */
 	trident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
 	if (trident->tlb.shadow_entries == NULL) {
@@ -3957,15 +3967,9 @@
 	snd_ac97_suspend(trident->ac97);
 	snd_ac97_suspend(trident->ac97_sec);
 
-	switch (trident->device) {
-	case TRIDENT_DEVICE_ID_DX:
-	case TRIDENT_DEVICE_ID_NX:
-		break;			/* TODO */
-	case TRIDENT_DEVICE_ID_SI7018:
-		break;
-	}
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -3974,9 +3978,15 @@
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_trident *trident = card->private_data;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
-	pci_set_master(pci); /* to be sure */
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "trident: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	pci_set_master(pci);
 
 	switch (trident->device) {
 	case TRIDENT_DEVICE_ID_DX:
--- linux-2.6.18.noarch/sound/pci/pcxhr/pcxhr_mixer.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/pci/pcxhr/pcxhr_mixer.c	2007-06-05 17:47:38.000000000 -0400
@@ -31,6 +31,7 @@
 #include "pcxhr_hwdep.h"
 #include "pcxhr_core.h"
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/asoundef.h>
 #include "pcxhr_mixer.h"
 
@@ -43,6 +44,9 @@
 #define PCXHR_ANALOG_PLAYBACK_LEVEL_MAX  128	/*    0.0 dB */
 #define PCXHR_ANALOG_PLAYBACK_ZERO_LEVEL 104	/*  -24.0 dB ( 0.0 dB - fix level +24.0 dB ) */
 
+static const DECLARE_TLV_DB_SCALE(db_scale_analog_capture, -9600, 50, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_analog_playback, -12800, 100, 0);
+
 static int pcxhr_update_analog_audio_level(struct snd_pcxhr *chip, int is_capture, int channel)
 {
 	int err, vol;
@@ -130,10 +134,13 @@
 
 static struct snd_kcontrol_new pcxhr_control_analog_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	/* name will be filled later */
 	.info =		pcxhr_analog_vol_info,
 	.get =		pcxhr_analog_vol_get,
 	.put =		pcxhr_analog_vol_put,
+	/* tlv will be filled later */
 };
 
 /* shared */
@@ -188,6 +195,7 @@
 #define PCXHR_DIGITAL_LEVEL_MAX		0x1ff	/* +18 dB */
 #define PCXHR_DIGITAL_ZERO_LEVEL	0x1b7	/*  0 dB */
 
+static const DECLARE_TLV_DB_SCALE(db_scale_digital, -10950, 50, 0);
 
 #define MORE_THAN_ONE_STREAM_LEVEL	0x000001
 #define VALID_STREAM_PAN_LEVEL_MASK	0x800000
@@ -343,11 +351,14 @@
 static struct snd_kcontrol_new snd_pcxhr_pcm_vol =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	/* name will be filled later */
 	/* count will be filled later */
 	.info =		pcxhr_digital_vol_info,		/* shared */
 	.get =		pcxhr_pcm_vol_get,
 	.put =		pcxhr_pcm_vol_put,
+	.tlv = { .p = db_scale_digital },
 };
 
 
@@ -433,10 +444,13 @@
 
 static struct snd_kcontrol_new pcxhr_control_monitor_vol = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =         "Monitoring Volume",
 	.info =		pcxhr_digital_vol_info,		/* shared */
 	.get =		pcxhr_monitor_vol_get,
 	.put =		pcxhr_monitor_vol_put,
+	.tlv = { .p = db_scale_digital },
 };
 
 /*
@@ -928,6 +942,7 @@
 			temp = pcxhr_control_analog_level;
 			temp.name = "Master Playback Volume";
 			temp.private_value = 0; /* playback */
+			temp.tlv.p = db_scale_analog_playback;
 			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
 				return err;
 			/* output mute controls */
@@ -963,6 +978,7 @@
 			temp = pcxhr_control_analog_level;
 			temp.name = "Master Capture Volume";
 			temp.private_value = 1; /* capture */
+			temp.tlv.p = db_scale_analog_capture;
 			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
 				return err;
 
--- linux-2.6.18.noarch/sound/sparc/dbri.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/sparc/dbri.c	2007-06-05 17:49:06.000000000 -0400
@@ -2,6 +2,8 @@
  * Driver for DBRI sound chip found on Sparcs.
  * Copyright (C) 2004, 2005 Martin Habets (mhabets@users.sourceforge.net)
  *
+ * Converted to ring buffered version by Krzysztof Helt (krzysztof.h1@wp.pl)
+ *
  * Based entirely upon drivers/sbus/audio/dbri.c which is:
  * Copyright (C) 1997 Rudolf Koenig (rfkoenig@immd4.informatik.uni-erlangen.de)
  * Copyright (C) 1998, 1999 Brent Baccala (baccala@freesoft.org)
@@ -34,7 +36,7 @@
  * (the second one is a monitor/tee pipe, valid only for serial input).
  *
  * The mmcodec is connected via the CHI bus and needs the data & some
- * parameters (volume, balance, output selection) timemultiplexed in 8 byte
+ * parameters (volume, output selection) timemultiplexed in 8 byte
  * chunks. It also has a control mode, which serves for audio format setting.
  *
  * Looking at the CS4215 data sheet it is easy to set up 2 or 4 codecs on
@@ -83,7 +85,7 @@
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable Sun DBRI soundcard.");
 
-#define DBRI_DEBUG
+#undef DBRI_DEBUG
 
 #define D_INT	(1<<0)
 #define D_GEN	(1<<1)
@@ -104,17 +106,15 @@
 
 #define dprintk(a, x...) if(dbri_debug & a) printk(KERN_DEBUG x)
 
-#define DBRI_CMD(cmd, intr, value) ((cmd << 28) |			\
-				    (1 << 27) | \
-				    value)
 #else
-#define dprintk(a, x...)
+#define dprintk(a, x...) do { } while (0)
 
-#define DBRI_CMD(cmd, intr, value) ((cmd << 28) |			\
-				    (intr << 27) | \
-				    value)
 #endif				/* DBRI_DEBUG */
 
+#define DBRI_CMD(cmd, intr, value) ((cmd << 28) |	\
+				    (intr << 27) |	\
+				    value)
+
 /***************************************************************************
 	CS4215 specific definitions and structures
 ****************************************************************************/
@@ -160,7 +160,7 @@
      /* {    NA, (1 << 4), (5 << 3) }, */
 	{ 48000, (1 << 4), (6 << 3) },
 	{  9600, (1 << 4), (7 << 3) },
-	{  5513, (2 << 4), (0 << 3) },	/* Actually 5512.5 */
+	{  5512, (2 << 4), (0 << 3) },	/* Actually 5512.5 */
 	{ 11025, (2 << 4), (1 << 3) },
 	{ 18900, (2 << 4), (2 << 3) },
 	{ 22050, (2 << 4), (3 << 3) },
@@ -240,28 +240,21 @@
 #define REG9	0x24UL		/* Interrupt Queue Pointer */
 
 #define DBRI_NO_CMDS	64
-#define DBRI_NO_INTS	1	/* Note: the value of this define was
-				 * originally 2.  The ringbuffer to store
-				 * interrupts in dma is currently broken.
-				 * This is a temporary fix until the ringbuffer
-				 * is fixed.
-				 */
 #define DBRI_INT_BLK	64
 #define DBRI_NO_DESCS	64
 #define DBRI_NO_PIPES	32
-
-#define DBRI_MM_ONB	1
-#define DBRI_MM_SB	2
+#define DBRI_MAX_PIPE	(DBRI_NO_PIPES - 1)
 
 #define DBRI_REC	0
 #define DBRI_PLAY	1
 #define DBRI_NO_STREAMS	2
 
 /* One transmit/receive descriptor */
+/* When ba != 0 descriptor is used */
 struct dbri_mem {
 	volatile __u32 word1;
-	volatile __u32 ba;	/* Transmit/Receive Buffer Address */
-	volatile __u32 nda;	/* Next Descriptor Address */
+	__u32 ba;	/* Transmit/Receive Buffer Address */
+	__u32 nda;	/* Next Descriptor Address */
 	volatile __u32 word4;
 };
 
@@ -269,8 +262,8 @@
  * the CPU and the DBRI
  */
 struct dbri_dma {
-	volatile s32 cmd[DBRI_NO_CMDS];	/* Place for commands       */
-	volatile s32 intr[DBRI_NO_INTS * DBRI_INT_BLK];	/* Interrupt field  */
+	s32 cmd[DBRI_NO_CMDS];			/* Place for commands */
+	volatile s32 intr[DBRI_INT_BLK];	/* Interrupt field  */
 	struct dbri_mem desc[DBRI_NO_DESCS];	/* Xmit/receive descriptors */
 };
 
@@ -282,58 +275,43 @@
 
 struct dbri_pipe {
 	u32 sdp;		/* SDP command word */
-	enum in_or_out direction;
 	int nextpipe;		/* Next pipe in linked list */
-	int prevpipe;
-	int cycle;		/* Offset of timeslot (bits) */
 	int length;		/* Length of timeslot (bits) */
 	int first_desc;		/* Index of first descriptor */
 	int desc;		/* Index of active descriptor */
 	volatile __u32 *recv_fixed_ptr;	/* Ptr to receive fixed data */
 };
 
-struct dbri_desc {
-	int inuse;		/* Boolean flag */
-	int next;		/* Index of next desc, or -1 */
-	unsigned int len;
-};
-
 /* Per stream (playback or record) information */
 struct dbri_streaminfo {
 	struct snd_pcm_substream *substream;
 	u32 dvma_buffer;	/* Device view of Alsa DMA buffer */
-	int left;		/* # of bytes left in DMA buffer  */
 	int size;		/* Size of DMA buffer             */
 	size_t offset;		/* offset in user buffer          */
 	int pipe;		/* Data pipe used                 */
 	int left_gain;		/* mixer elements                 */
 	int right_gain;
-	int balance;
 };
 
 /* This structure holds the information for both chips (DBRI & CS4215) */
 struct snd_dbri {
 	struct snd_card *card;	/* ALSA card */
-	struct snd_pcm *pcm;
 
 	int regs_size, irq;	/* Needed for unload */
 	struct sbus_dev *sdev;	/* SBUS device info */
 	spinlock_t lock;
 
-	volatile struct dbri_dma *dma;	/* Pointer to our DMA block */
+	struct dbri_dma *dma;	/* Pointer to our DMA block */
 	u32 dma_dvma;		/* DBRI visible DMA address */
 
 	void __iomem *regs;	/* dbri HW regs */
-	int dbri_version;	/* 'e' and up is OK */
 	int dbri_irqp;		/* intr queue pointer */
-	int wait_send;		/* sequence of command buffers send */
-	int wait_ackd;		/* sequence of command buffers acknowledged */
 
 	struct dbri_pipe pipes[DBRI_NO_PIPES];	/* DBRI's 32 data pipes */
-	struct dbri_desc descs[DBRI_NO_DESCS];
+	int next_desc[DBRI_NO_DESCS];		/* Index of next desc, or -1 */
+	spinlock_t cmdlock;	/* Protects cmd queue accesses */
+	s32 *cmdptr;		/* Pointer to the last queued cmd */
 
-	int chi_in_pipe;
-	int chi_out_pipe;
 	int chi_bpf;
 
 	struct cs4215 mm;	/* mmcodec special info */
@@ -345,8 +323,6 @@
 
 #define DBRI_MAX_VOLUME		63	/* Output volume */
 #define DBRI_MAX_GAIN		15	/* Input gain */
-#define DBRI_RIGHT_BALANCE	255
-#define DBRI_MID_BALANCE	(DBRI_RIGHT_BALANCE >> 1)
 
 /* DBRI Reg0 - Status Control Register - defines. (Page 17) */
 #define D_P		(1<<15)	/* Program command & queue pointer valid */
@@ -569,7 +545,7 @@
 #define DBRI_TD_TBC	(1<<0)	/* Transmit buffer Complete */
 #define DBRI_TD_STATUS(v)       ((v)&0xff)	/* Transmit status */
 			/* Maximum buffer size per TD: almost 8Kb */
-#define DBRI_TD_MAXCNT	((1 << 13) - 1)
+#define DBRI_TD_MAXCNT	((1 << 13) - 4)
 
 /* Receive descriptor defines */
 #define DBRI_RD_F	(1<<31)	/* End of Frame */
@@ -633,93 +609,124 @@
 CPU interrupt to signal completion.
 
 Since the DBRI can run in parallel with the CPU, several means of
-synchronization present themselves.  The method implemented here is close
-to the original scheme (Rudolf's), and uses 2 counters (wait_send and
-wait_ackd) to synchronize the command buffer between the CPU and the DBRI.
-
-A more sophisticated scheme might involve a circular command buffer
-or an array of command buffers.  A routine could fill one with
-commands and link it onto a list.  When a interrupt signaled
-completion of the current command buffer, look on the list for
-the next one.
+synchronization present themselves. The method implemented here is only
+use of the dbri_cmdwait() to wait for execution of batch of sent commands.
+
+A circular command buffer is used here. A new command is being added 
+while another can be executed. The scheme works by adding two WAIT commands
+after each sent batch of commands. When the next batch is prepared it is
+added after the WAIT commands then the WAITs are replaced with single JUMP
+command to the new batch. The the DBRI is forced to reread the last WAIT 
+command (replaced by the JUMP by then). If the DBRI is still executing 
+previous commands the request to reread the WAIT command is ignored.
 
 Every time a routine wants to write commands to the DBRI, it must
-first call dbri_cmdlock() and get an initial pointer into dbri->dma->cmd
-in return. dbri_cmdlock() will block if the previous commands have not
-been completed yet. After this the commands can be written to the buffer,
-and dbri_cmdsend() is called with the final pointer value to send them
-to the DBRI.
+first call dbri_cmdlock() and get pointer to a free space in 
+dbri->dma->cmd buffer. After this, the commands can be written to 
+the buffer, and dbri_cmdsend() is called with the final pointer value 
+to send them to the DBRI.
 
 */
 
-static void dbri_process_interrupt_buffer(struct snd_dbri * dbri);
-
-enum dbri_lock { NoGetLock, GetLock };
-#define MAXLOOPS 10
-
-static volatile s32 *dbri_cmdlock(struct snd_dbri * dbri, enum dbri_lock get)
+#define MAXLOOPS 20
+/*
+ * Wait for the current command string to execute
+ */
+static void dbri_cmdwait(struct snd_dbri *dbri)
 {
 	int maxloops = MAXLOOPS;
-
-#ifndef SMP
-	if ((get == GetLock) && spin_is_locked(&dbri->lock)) {
-		printk(KERN_ERR "DBRI: cmdlock called while in spinlock.");
-	}
-#endif
+	unsigned long flags;
 
 	/* Delay if previous commands are still being processed */
-	while ((--maxloops) > 0 && (dbri->wait_send != dbri->wait_ackd)) {
+	spin_lock_irqsave(&dbri->lock, flags);
+	while ((--maxloops) > 0 && (sbus_readl(dbri->regs + REG0) & D_P)) {
+		spin_unlock_irqrestore(&dbri->lock, flags);
 		msleep_interruptible(1);
-		/* If dbri_cmdlock() got called from inside the
-		 * interrupt handler, this will do the processing.
-		 */
-		dbri_process_interrupt_buffer(dbri);
+		spin_lock_irqsave(&dbri->lock, flags);
 	}
+	spin_unlock_irqrestore(&dbri->lock, flags);
+
 	if (maxloops == 0) {
-		printk(KERN_ERR "DBRI: Chip never completed command buffer %d\n",
-			dbri->wait_send);
+		printk(KERN_ERR "DBRI: Chip never completed command buffer\n");
 	} else {
 		dprintk(D_CMD, "Chip completed command buffer (%d)\n",
 			MAXLOOPS - maxloops - 1);
 	}
+}
+/*
+ * Lock the command queue and returns pointer to a space for len cmd words
+ * It locks the cmdlock spinlock.
+ */
+static s32 *dbri_cmdlock(struct snd_dbri * dbri, int len)
+{
+	/* Space for 2 WAIT cmds (replaced later by 1 JUMP cmd) */
+	len += 2;
+	spin_lock(&dbri->cmdlock);
+	if (dbri->cmdptr - dbri->dma->cmd + len < DBRI_NO_CMDS - 2)
+		return dbri->cmdptr + 2;
+	else if (len < sbus_readl(dbri->regs + REG8) - dbri->dma_dvma)
+		return dbri->dma->cmd;
+	else
+		printk(KERN_ERR "DBRI: no space for commands.");
 
-	/*if (get == GetLock) spin_lock(&dbri->lock); */
-	return &dbri->dma->cmd[0];
+	return NULL;
 }
 
-static void dbri_cmdsend(struct snd_dbri * dbri, volatile s32 * cmd)
+/*
+ * Send prepared cmd string. It works by writting a JUMP cmd into
+ * the last WAIT cmd and force DBRI to reread the cmd.
+ * The JUMP cmd points to the new cmd string.
+ * It also releases the cmdlock spinlock.
+ *
+ * Lock must be held before calling this.
+ */
+static void dbri_cmdsend(struct snd_dbri * dbri, s32 * cmd,int len)
 {
-	volatile s32 *ptr;
-	u32	reg;
+	s32 tmp, addr;
+	static int wait_id = 0;
 
-	for (ptr = &dbri->dma->cmd[0]; ptr < cmd; ptr++) {
-		dprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);
-	}
+	wait_id++;
+	wait_id &= 0xffff;	/* restrict it to a 16 bit counter. */
+	*(cmd) = DBRI_CMD(D_WAIT, 1, wait_id);
+	*(cmd+1) = DBRI_CMD(D_WAIT, 1, wait_id);
+
+	/* Replace the last command with JUMP */
+	addr = dbri->dma_dvma + (cmd - len - dbri->dma->cmd) * sizeof(s32);
+	*(dbri->cmdptr+1) = addr;
+	*(dbri->cmdptr) = DBRI_CMD(D_JUMP, 0, 0);
 
-	if ((cmd - &dbri->dma->cmd[0]) >= DBRI_NO_CMDS - 1) {
-		printk(KERN_ERR "DBRI: Command buffer overflow! (bug in driver)\n");
-		/* Ignore the last part. */
-		cmd = &dbri->dma->cmd[DBRI_NO_CMDS - 3];
-	}
+#ifdef DBRI_DEBUG
+	if (cmd > dbri->cmdptr) {
+		s32 *ptr;
 
-	dbri->wait_send++;
-	dbri->wait_send &= 0xffff;	/* restrict it to a 16 bit counter. */
-	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
-	*(cmd++) = DBRI_CMD(D_WAIT, 1, dbri->wait_send);
+		for (ptr = dbri->cmdptr; ptr < cmd+2; ptr++)
+			dprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);
+	} else {
+		s32 *ptr = dbri->cmdptr;
 
-	/* Set command pointer and signal it is valid. */
-	sbus_writel(dbri->dma_dvma, dbri->regs + REG8);
-	reg = sbus_readl(dbri->regs + REG0);
-	reg |= D_P;
-	sbus_writel(reg, dbri->regs + REG0);
+		dprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);
+		ptr++;
+		dprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);
+		for (ptr = dbri->dma->cmd; ptr < cmd+2; ptr++) {
+			dprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);
+		}
+	}
+#endif
 
-	/*spin_unlock(&dbri->lock); */
+	/* Reread the last command */
+	tmp = sbus_readl(dbri->regs + REG0);
+	tmp |= D_P;
+	sbus_writel(tmp, dbri->regs + REG0);
+
+	dbri->cmdptr = cmd;
+	spin_unlock(&dbri->cmdlock);
 }
 
 /* Lock must be held when calling this */
 static void dbri_reset(struct snd_dbri * dbri)
 {
 	int i;
+	u32 tmp;
 
 	dprintk(D_GEN, "reset 0:%x 2:%x 8:%x 9:%x\n",
 		sbus_readl(dbri->regs + REG0),
@@ -729,13 +736,20 @@
 	sbus_writel(D_R, dbri->regs + REG0);	/* Soft Reset */
 	for (i = 0; (sbus_readl(dbri->regs + REG0) & D_R) && i < 64; i++)
 		udelay(10);
+
+	/* A brute approach - DBRI falls back to working burst size by itself
+	 * On SS20 D_S does not work, so do not try so high. */
+	tmp = sbus_readl(dbri->regs + REG0);
+	tmp |= D_G | D_E;
+	tmp &= ~D_S;
+	sbus_writel(tmp, dbri->regs + REG0);
 }
 
 /* Lock must not be held before calling this */
 static void dbri_initialize(struct snd_dbri * dbri)
 {
-	volatile s32 *cmd;
-	u32 dma_addr, tmp;
+	s32 *cmd;
+	u32 dma_addr;
 	unsigned long flags;
 	int n;
 
@@ -743,42 +757,34 @@
 
 	dbri_reset(dbri);
 
-	cmd = dbri_cmdlock(dbri, NoGetLock);
-	dprintk(D_GEN, "init: cmd: %p, int: %p\n",
-		&dbri->dma->cmd[0], &dbri->dma->intr[0]);
+	/* Initialize pipes */
+	for (n = 0; n < DBRI_NO_PIPES; n++)
+		dbri->pipes[n].desc = dbri->pipes[n].first_desc = -1;
 
+	spin_lock_init(&dbri->cmdlock);
 	/*
 	 * Initialize the interrupt ringbuffer.
 	 */
-	for (n = 0; n < DBRI_NO_INTS - 1; n++) {
-		dma_addr = dbri->dma_dvma;
-		dma_addr += dbri_dma_off(intr, ((n + 1) & DBRI_INT_BLK));
-		dbri->dma->intr[n * DBRI_INT_BLK] = dma_addr;
-	}
 	dma_addr = dbri->dma_dvma + dbri_dma_off(intr, 0);
-	dbri->dma->intr[n * DBRI_INT_BLK] = dma_addr;
+	dbri->dma->intr[0] = dma_addr;
 	dbri->dbri_irqp = 1;
-
-	/* Initialize pipes */
-	for (n = 0; n < DBRI_NO_PIPES; n++)
-		dbri->pipes[n].desc = dbri->pipes[n].first_desc = -1;
-
-	/* A brute approach - DBRI falls back to working burst size by itself
-	 * On SS20 D_S does not work, so do not try so high. */
-	tmp = sbus_readl(dbri->regs + REG0);
-	tmp |= D_G | D_E;
-	tmp &= ~D_S;
-	sbus_writel(tmp, dbri->regs + REG0);
-
 	/*
 	 * Set up the interrupt queue
 	 */
-	dma_addr = dbri->dma_dvma + dbri_dma_off(intr, 0);
+	spin_lock(&dbri->cmdlock);
+	cmd = dbri->cmdptr = dbri->dma->cmd;
 	*(cmd++) = DBRI_CMD(D_IIQ, 0, 0);
 	*(cmd++) = dma_addr;
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
+	dbri->cmdptr = cmd;
+	*(cmd++) = DBRI_CMD(D_WAIT, 1, 0);
+	*(cmd++) = DBRI_CMD(D_WAIT, 1, 0);
+	dma_addr = dbri->dma_dvma + dbri_dma_off(cmd, 0);
+	sbus_writel(dma_addr, dbri->regs + REG8);
+	spin_unlock(&dbri->cmdlock);
 
-	dbri_cmdsend(dbri, cmd);
 	spin_unlock_irqrestore(&dbri->lock, flags);
+	dbri_cmdwait(dbri);
 }
 
 /*
@@ -809,9 +815,9 @@
 {
 	int sdp;
 	int desc;
-	volatile int *cmd;
+	s32 *cmd;
 
-	if (pipe < 0 || pipe > 31) {
+	if (pipe < 0 || pipe > DBRI_MAX_PIPE) {
 		printk(KERN_ERR "DBRI: reset_pipe called with illegal pipe number\n");
 		return;
 	}
@@ -822,25 +828,29 @@
 		return;
 	}
 
-	cmd = dbri_cmdlock(dbri, NoGetLock);
+	cmd = dbri_cmdlock(dbri, 3);
 	*(cmd++) = DBRI_CMD(D_SDP, 0, sdp | D_SDP_C | D_SDP_P);
 	*(cmd++) = 0;
-	dbri_cmdsend(dbri, cmd);
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
+	dbri_cmdsend(dbri, cmd, 3);
 
 	desc = dbri->pipes[pipe].first_desc;
-	while (desc != -1) {
-		dbri->descs[desc].inuse = 0;
-		desc = dbri->descs[desc].next;
-	}
+	if ( desc >= 0)
+		do {
+			dbri->dma->desc[desc].nda = dbri->dma->desc[desc].ba = 0;
+			desc = dbri->next_desc[desc];
+		} while (desc != -1 && desc != dbri->pipes[pipe].first_desc);
 
 	dbri->pipes[pipe].desc = -1;
 	dbri->pipes[pipe].first_desc = -1;
 }
 
-/* FIXME: direction as an argument? */
+/*
+ * Lock must be held before calling this.
+ */
 static void setup_pipe(struct snd_dbri * dbri, int pipe, int sdp)
 {
-	if (pipe < 0 || pipe > 31) {
+	if (pipe < 0 || pipe > DBRI_MAX_PIPE) {
 		printk(KERN_ERR "DBRI: setup_pipe called with illegal pipe number\n");
 		return;
 	}
@@ -860,119 +870,87 @@
 	dbri->pipes[pipe].sdp = sdp;
 	dbri->pipes[pipe].desc = -1;
 	dbri->pipes[pipe].first_desc = -1;
-	if (sdp & D_SDP_TO_SER)
-		dbri->pipes[pipe].direction = PIPEoutput;
-	else
-		dbri->pipes[pipe].direction = PIPEinput;
 
 	reset_pipe(dbri, pipe);
 }
 
-/* FIXME: direction not needed */
+/*
+ * Lock must be held before calling this.
+ */
 static void link_time_slot(struct snd_dbri * dbri, int pipe,
-			   enum in_or_out direction, int basepipe,
+			   int prevpipe, int nextpipe,
 			   int length, int cycle)
 {
-	volatile s32 *cmd;
+	s32 *cmd;
 	int val;
-	int prevpipe;
-	int nextpipe;
 
-	if (pipe < 0 || pipe > 31 || basepipe < 0 || basepipe > 31) {
+	if (pipe < 0 || pipe > DBRI_MAX_PIPE 
+			|| prevpipe < 0 || prevpipe > DBRI_MAX_PIPE
+			|| nextpipe < 0 || nextpipe > DBRI_MAX_PIPE) {
 		printk(KERN_ERR 
 		    "DBRI: link_time_slot called with illegal pipe number\n");
 		return;
 	}
 
-	if (dbri->pipes[pipe].sdp == 0 || dbri->pipes[basepipe].sdp == 0) {
+	if (dbri->pipes[pipe].sdp == 0 
+			|| dbri->pipes[prevpipe].sdp == 0
+			|| dbri->pipes[nextpipe].sdp == 0) {
 		printk(KERN_ERR "DBRI: link_time_slot called on uninitialized pipe\n");
 		return;
 	}
 
-	/* Deal with CHI special case:
-	 * "If transmission on edges 0 or 1 is desired, then cycle n
-	 *  (where n = # of bit times per frame...) must be used."
-	 *                  - DBRI data sheet, page 11
-	 */
-	if (basepipe == 16 && direction == PIPEoutput && cycle == 0)
-		cycle = dbri->chi_bpf;
-
-	if (basepipe == pipe) {
-		prevpipe = pipe;
-		nextpipe = pipe;
-	} else {
-		/* We're not initializing a new linked list (basepipe != pipe),
-		 * so run through the linked list and find where this pipe
-		 * should be sloted in, based on its cycle.  CHI confuses
-		 * things a bit, since it has a single anchor for both its
-		 * transmit and receive lists.
-		 */
-		if (basepipe == 16) {
-			if (direction == PIPEinput) {
-				prevpipe = dbri->chi_in_pipe;
-			} else {
-				prevpipe = dbri->chi_out_pipe;
-			}
-		} else {
-			prevpipe = basepipe;
-		}
-
-		nextpipe = dbri->pipes[prevpipe].nextpipe;
-
-		while (dbri->pipes[nextpipe].cycle < cycle
-		       && dbri->pipes[nextpipe].nextpipe != basepipe) {
-			prevpipe = nextpipe;
-			nextpipe = dbri->pipes[nextpipe].nextpipe;
-		}
-	}
-
-	if (prevpipe == 16) {
-		if (direction == PIPEinput) {
-			dbri->chi_in_pipe = pipe;
-		} else {
-			dbri->chi_out_pipe = pipe;
-		}
-	} else {
-		dbri->pipes[prevpipe].nextpipe = pipe;
-	}
-
+	dbri->pipes[prevpipe].nextpipe = pipe;
 	dbri->pipes[pipe].nextpipe = nextpipe;
-	dbri->pipes[pipe].cycle = cycle;
 	dbri->pipes[pipe].length = length;
 
-	cmd = dbri_cmdlock(dbri, NoGetLock);
+	cmd = dbri_cmdlock(dbri, 4);
 
-	if (direction == PIPEinput) {
-		val = D_DTS_VI | D_DTS_INS | D_DTS_PRVIN(prevpipe) | pipe;
+	if (dbri->pipes[pipe].sdp & D_SDP_TO_SER) {
+		/* Deal with CHI special case:
+		 * "If transmission on edges 0 or 1 is desired, then cycle n
+		 *  (where n = # of bit times per frame...) must be used."
+		 *                  - DBRI data sheet, page 11
+		 */
+		if (prevpipe == 16 && cycle == 0)
+			cycle = dbri->chi_bpf;
+
+		val = D_DTS_VO | D_DTS_INS | D_DTS_PRVOUT(prevpipe) | pipe;
 		*(cmd++) = DBRI_CMD(D_DTS, 0, val);
+		*(cmd++) = 0;
 		*(cmd++) =
 		    D_TS_LEN(length) | D_TS_CYCLE(cycle) | D_TS_NEXT(nextpipe);
-		*(cmd++) = 0;
 	} else {
-		val = D_DTS_VO | D_DTS_INS | D_DTS_PRVOUT(prevpipe) | pipe;
+		val = D_DTS_VI | D_DTS_INS | D_DTS_PRVIN(prevpipe) | pipe;
 		*(cmd++) = DBRI_CMD(D_DTS, 0, val);
-		*(cmd++) = 0;
 		*(cmd++) =
 		    D_TS_LEN(length) | D_TS_CYCLE(cycle) | D_TS_NEXT(nextpipe);
+		*(cmd++) = 0;
 	}
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
 
-	dbri_cmdsend(dbri, cmd);
+	dbri_cmdsend(dbri, cmd, 4);
 }
 
+#if 0
+/*
+ * Lock must be held before calling this.
+ */
 static void unlink_time_slot(struct snd_dbri * dbri, int pipe,
 			     enum in_or_out direction, int prevpipe,
 			     int nextpipe)
 {
-	volatile s32 *cmd;
+	s32 *cmd;
 	int val;
 
-	if (pipe < 0 || pipe > 31 || prevpipe < 0 || prevpipe > 31) {
+	if (pipe < 0 || pipe > DBRI_MAX_PIPE 
+			|| prevpipe < 0 || prevpipe > DBRI_MAX_PIPE
+			|| nextpipe < 0 || nextpipe > DBRI_MAX_PIPE) {
 		printk(KERN_ERR 
 		    "DBRI: unlink_time_slot called with illegal pipe number\n");
 		return;
 	}
 
-	cmd = dbri_cmdlock(dbri, NoGetLock);
+	cmd = dbri_cmdlock(dbri, 4);
 
 	if (direction == PIPEinput) {
 		val = D_DTS_VI | D_DTS_DEL | D_DTS_PRVIN(prevpipe) | pipe;
@@ -985,9 +963,11 @@
 		*(cmd++) = 0;
 		*(cmd++) = D_TS_NEXT(nextpipe);
 	}
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
 
-	dbri_cmdsend(dbri, cmd);
+	dbri_cmdsend(dbri, cmd, 4);
 }
+#endif
 
 /* xmit_fixed() / recv_fixed()
  *
@@ -1001,13 +981,16 @@
  * the actual time slot is.  The interrupt handler takes care of bit
  * ordering and alignment.  An 8-bit time slot will always end up
  * in the low-order 8 bits, filled either MSB-first or LSB-first,
- * depending on the settings passed to setup_pipe()
+ * depending on the settings passed to setup_pipe().
+ *
+ * Lock must not be held before calling it.
  */
 static void xmit_fixed(struct snd_dbri * dbri, int pipe, unsigned int data)
 {
-	volatile s32 *cmd;
+	s32 *cmd;
+	unsigned long flags;
 
-	if (pipe < 16 || pipe > 31) {
+	if (pipe < 16 || pipe > DBRI_MAX_PIPE) {
 		printk(KERN_ERR "DBRI: xmit_fixed: Illegal pipe number\n");
 		return;
 	}
@@ -1032,17 +1015,22 @@
 	if (dbri->pipes[pipe].sdp & D_SDP_MSB)
 		data = reverse_bytes(data, dbri->pipes[pipe].length);
 
-	cmd = dbri_cmdlock(dbri, GetLock);
+	cmd = dbri_cmdlock(dbri, 3);
 
 	*(cmd++) = DBRI_CMD(D_SSP, 0, pipe);
 	*(cmd++) = data;
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
+
+	spin_lock_irqsave(&dbri->lock, flags);
+	dbri_cmdsend(dbri, cmd, 3);
+	spin_unlock_irqrestore(&dbri->lock, flags);
+	dbri_cmdwait(dbri);
 
-	dbri_cmdsend(dbri, cmd);
 }
 
 static void recv_fixed(struct snd_dbri * dbri, int pipe, volatile __u32 * ptr)
 {
-	if (pipe < 16 || pipe > 31) {
+	if (pipe < 16 || pipe > DBRI_MAX_PIPE) {
 		printk(KERN_ERR "DBRI: recv_fixed called with illegal pipe number\n");
 		return;
 	}
@@ -1071,12 +1059,16 @@
  * and work by building chains of descriptors which identify the
  * data buffers.  Buffers too large for a single descriptor will
  * be spread across multiple descriptors.
+ *
+ * All descriptors create a ring buffer.
+ *
+ * Lock must be held before calling this.
  */
 static int setup_descs(struct snd_dbri * dbri, int streamno, unsigned int period)
 {
 	struct dbri_streaminfo *info = &dbri->stream_info[streamno];
 	__u32 dvma_buffer;
-	int desc = 0;
+	int desc;
 	int len;
 	int first_desc = -1;
 	int last_desc = -1;
@@ -1119,11 +1111,23 @@
 		len &= ~3;
 	}
 
+	/* Free descriptors if pipe has any */
+	desc = dbri->pipes[info->pipe].first_desc;
+	if ( desc >= 0)
+		do {
+			dbri->dma->desc[desc].nda = dbri->dma->desc[desc].ba = 0;
+			desc = dbri->next_desc[desc];
+		} while (desc != -1 && desc != dbri->pipes[info->pipe].first_desc);
+
+	dbri->pipes[info->pipe].desc = -1;
+	dbri->pipes[info->pipe].first_desc = -1;
+
+	desc = 0;
 	while (len > 0) {
 		int mylen;
 
 		for (; desc < DBRI_NO_DESCS; desc++) {
-			if (!dbri->descs[desc].inuse)
+			if (!dbri->dma->desc[desc].ba)
 				break;
 		}
 		if (desc == DBRI_NO_DESCS) {
@@ -1131,37 +1135,33 @@
 			return -1;
 		}
 
-		if (len > DBRI_TD_MAXCNT) {
-			mylen = DBRI_TD_MAXCNT;	/* 8KB - 1 */
-		} else {
+		if (len > DBRI_TD_MAXCNT)
+			mylen = DBRI_TD_MAXCNT;	/* 8KB - 4 */
+		else
 			mylen = len;
-		}
-		if (mylen > period) {
+
+		if (mylen > period)
 			mylen = period;
-		}
 
-		dbri->descs[desc].inuse = 1;
-		dbri->descs[desc].next = -1;
+		dbri->next_desc[desc] = -1;
 		dbri->dma->desc[desc].ba = dvma_buffer;
 		dbri->dma->desc[desc].nda = 0;
 
 		if (streamno == DBRI_PLAY) {
-			dbri->descs[desc].len = mylen;
 			dbri->dma->desc[desc].word1 = DBRI_TD_CNT(mylen);
 			dbri->dma->desc[desc].word4 = 0;
-			if (first_desc != -1)
-				dbri->dma->desc[desc].word1 |= DBRI_TD_M;
+			dbri->dma->desc[desc].word1 |= 
+			    DBRI_TD_F | DBRI_TD_B;
 		} else {
-			dbri->descs[desc].len = 0;
 			dbri->dma->desc[desc].word1 = 0;
 			dbri->dma->desc[desc].word4 =
 			    DBRI_RD_B | DBRI_RD_BCNT(mylen);
 		}
 
-		if (first_desc == -1) {
+		if (first_desc == -1)
 			first_desc = desc;
-		} else {
-			dbri->descs[last_desc].next = desc;
+		else {
+			dbri->next_desc[last_desc] = desc;
 			dbri->dma->desc[last_desc].nda =
 			    dbri->dma_dvma + dbri_dma_off(desc, desc);
 		}
@@ -1176,21 +1176,24 @@
 		return -1;
 	}
 
-	dbri->dma->desc[last_desc].word1 &= ~DBRI_TD_M;
-	if (streamno == DBRI_PLAY) {
-		dbri->dma->desc[last_desc].word1 |=
-		    DBRI_TD_I | DBRI_TD_F | DBRI_TD_B;
-	}
+	dbri->dma->desc[last_desc].nda =
+	    dbri->dma_dvma + dbri_dma_off(desc, first_desc);
+	dbri->next_desc[last_desc] = first_desc;
 	dbri->pipes[info->pipe].first_desc = first_desc;
 	dbri->pipes[info->pipe].desc = first_desc;
 
-	for (desc = first_desc; desc != -1; desc = dbri->descs[desc].next) {
+#ifdef DBRI_DEBUG
+	for (desc = first_desc; desc != -1; ) {
 		dprintk(D_DESC, "DESC %d: %08x %08x %08x %08x\n",
 			desc,
 			dbri->dma->desc[desc].word1,
 			dbri->dma->desc[desc].ba,
 			dbri->dma->desc[desc].nda, dbri->dma->desc[desc].word4);
+			desc = dbri->next_desc[desc];
+			if ( desc == first_desc )
+				break;
 	}
+#endif
 	return 0;
 }
 
@@ -1207,56 +1210,30 @@
 
 enum master_or_slave { CHImaster, CHIslave };
 
+/*
+ * Lock must not be held before calling it.
+ */
 static void reset_chi(struct snd_dbri * dbri, enum master_or_slave master_or_slave,
 		      int bits_per_frame)
 {
-	volatile s32 *cmd;
+	s32 *cmd;
 	int val;
-	static int chi_initialized = 0;	/* FIXME: mutex? */
-
-	if (!chi_initialized) {
 
-		cmd = dbri_cmdlock(dbri, GetLock);
+	/* Set CHI Anchor: Pipe 16 */
 
-		/* Set CHI Anchor: Pipe 16 */
-
-		val = D_DTS_VI | D_DTS_INS | D_DTS_PRVIN(16) | D_PIPE(16);
-		*(cmd++) = DBRI_CMD(D_DTS, 0, val);
-		*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);
-		*(cmd++) = 0;
-
-		val = D_DTS_VO | D_DTS_INS | D_DTS_PRVOUT(16) | D_PIPE(16);
-		*(cmd++) = DBRI_CMD(D_DTS, 0, val);
-		*(cmd++) = 0;
-		*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);
-
-		dbri->pipes[16].sdp = 1;
-		dbri->pipes[16].nextpipe = 16;
-		dbri->chi_in_pipe = 16;
-		dbri->chi_out_pipe = 16;
-
-#if 0
-		chi_initialized++;
-#endif
-	} else {
-		int pipe;
-
-		for (pipe = dbri->chi_in_pipe;
-		     pipe != 16; pipe = dbri->pipes[pipe].nextpipe) {
-			unlink_time_slot(dbri, pipe, PIPEinput,
-					 16, dbri->pipes[pipe].nextpipe);
-		}
-		for (pipe = dbri->chi_out_pipe;
-		     pipe != 16; pipe = dbri->pipes[pipe].nextpipe) {
-			unlink_time_slot(dbri, pipe, PIPEoutput,
-					 16, dbri->pipes[pipe].nextpipe);
-		}
+	cmd = dbri_cmdlock(dbri, 4);
+	val = D_DTS_VO | D_DTS_VI | D_DTS_INS 
+		| D_DTS_PRVIN(16) | D_PIPE(16) | D_DTS_PRVOUT(16);
+	*(cmd++) = DBRI_CMD(D_DTS, 0, val);
+	*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);
+	*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
+	dbri_cmdsend(dbri, cmd, 4);
 
-		dbri->chi_in_pipe = 16;
-		dbri->chi_out_pipe = 16;
+	dbri->pipes[16].sdp = 1;
+	dbri->pipes[16].nextpipe = 16;
 
-		cmd = dbri_cmdlock(dbri, GetLock);
-	}
+	cmd = dbri_cmdlock(dbri, 4);
 
 	if (master_or_slave == CHIslave) {
 		/* Setup DBRI for CHI Slave - receive clock, frame sync (FS)
@@ -1295,8 +1272,9 @@
 
 	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
 	*(cmd++) = DBRI_CMD(D_CDM, 0, D_CDM_XCE | D_CDM_XEN | D_CDM_REN);
+	*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);
 
-	dbri_cmdsend(dbri, cmd);
+	dbri_cmdsend(dbri, cmd, 4);
 }
 
 /*
@@ -1307,9 +1285,14 @@
 In the standard SPARC audio configuration, the CS4215 codec is attached
 to the DBRI via the CHI interface and few of the DBRI's PIO pins.
 
+ * Lock must not be held before calling it.
+
 */
 static void cs4215_setup_pipes(struct snd_dbri * dbri)
 {
+	unsigned long flags;
+
+	spin_lock_irqsave(&dbri->lock, flags);
 	/*
 	 * Data mode:
 	 * Pipe  4: Send timeslots 1-4 (audio data)
@@ -1333,6 +1316,9 @@
 	setup_pipe(dbri, 17, D_SDP_FIXED | D_SDP_TO_SER | D_SDP_MSB);
 	setup_pipe(dbri, 18, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);
 	setup_pipe(dbri, 19, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);
+	spin_unlock_irqrestore(&dbri->lock, flags);
+
+	dbri_cmdwait(dbri);
 }
 
 static int cs4215_init_data(struct cs4215 *mm)
@@ -1364,7 +1350,7 @@
 	mm->status = 0;
 	mm->version = 0xff;
 	mm->precision = 8;	/* For ULAW */
-	mm->channels = 2;
+	mm->channels = 1;
 
 	return 0;
 }
@@ -1379,16 +1365,8 @@
 	} else {
 		/* Start by setting the playback attenuation. */
 		struct dbri_streaminfo *info = &dbri->stream_info[DBRI_PLAY];
-		int left_gain = info->left_gain % 64;
-		int right_gain = info->right_gain % 64;
-
-		if (info->balance < DBRI_MID_BALANCE) {
-			right_gain *= info->balance;
-			right_gain /= DBRI_MID_BALANCE;
-		} else {
-			left_gain *= DBRI_RIGHT_BALANCE - info->balance;
-			left_gain /= DBRI_MID_BALANCE;
-		}
+		int left_gain = info->left_gain & 0x3f;
+		int right_gain = info->right_gain & 0x3f;
 
 		dbri->mm.data[0] &= ~0x3f;	/* Reset the volume bits */
 		dbri->mm.data[1] &= ~0x3f;
@@ -1397,8 +1375,8 @@
 
 		/* Now set the recording gain. */
 		info = &dbri->stream_info[DBRI_REC];
-		left_gain = info->left_gain % 16;
-		right_gain = info->right_gain % 16;
+		left_gain = info->left_gain & 0xf;
+		right_gain = info->right_gain & 0xf;
 		dbri->mm.data[2] |= CS4215_LG(left_gain);
 		dbri->mm.data[3] |= CS4215_RG(right_gain);
 	}
@@ -1413,6 +1391,7 @@
 {
 	int data_width;
 	u32 tmp;
+	unsigned long flags;
 
 	dprintk(D_MM, "cs4215_open: %d channels, %d bits\n",
 		dbri->mm.channels, dbri->mm.precision);
@@ -1437,6 +1416,7 @@
 	 * bits.  The CS4215, it seems, observes TSIN (the delayed signal)
 	 * even if it's the CHI master.  Don't ask me...
 	 */
+	spin_lock_irqsave(&dbri->lock, flags);
 	tmp = sbus_readl(dbri->regs + REG0);
 	tmp &= ~(D_C);		/* Disable CHI */
 	sbus_writel(tmp, dbri->regs + REG0);
@@ -1455,15 +1435,16 @@
 	 */
 	data_width = dbri->mm.channels * dbri->mm.precision;
 
-	link_time_slot(dbri, 20, PIPEoutput, 16, 32, dbri->mm.offset + 32);
-	link_time_slot(dbri, 4, PIPEoutput, 16, data_width, dbri->mm.offset);
-	link_time_slot(dbri, 6, PIPEinput, 16, data_width, dbri->mm.offset);
-	link_time_slot(dbri, 21, PIPEinput, 16, 16, dbri->mm.offset + 40);
+	link_time_slot(dbri, 4, 16, 16, data_width, dbri->mm.offset);
+	link_time_slot(dbri, 20, 4, 16, 32, dbri->mm.offset + 32);
+	link_time_slot(dbri, 6, 16, 16, data_width, dbri->mm.offset);
+	link_time_slot(dbri, 21, 6, 16, 16, dbri->mm.offset + 40);
 
 	/* FIXME: enable CHI after _setdata? */
 	tmp = sbus_readl(dbri->regs + REG0);
 	tmp |= D_C;		/* Enable CHI */
 	sbus_writel(tmp, dbri->regs + REG0);
+	spin_unlock_irqrestore(&dbri->lock, flags);
 
 	cs4215_setdata(dbri, 0);
 }
@@ -1475,6 +1456,7 @@
 {
 	int i, val;
 	u32 tmp;
+	unsigned long flags;
 
 	/* FIXME - let the CPU do something useful during these delays */
 
@@ -1511,6 +1493,7 @@
 	 * done in hardware by a TI 248 that delays the DBRI->4215
 	 * frame sync signal by eight clock cycles.  Anybody know why?
 	 */
+	spin_lock_irqsave(&dbri->lock, flags);
 	tmp = sbus_readl(dbri->regs + REG0);
 	tmp &= ~D_C;		/* Disable CHI */
 	sbus_writel(tmp, dbri->regs + REG0);
@@ -1524,17 +1507,20 @@
 	 * Pipe 19: Receive timeslot 7 (version). 
 	 */
 
-	link_time_slot(dbri, 17, PIPEoutput, 16, 32, dbri->mm.offset);
-	link_time_slot(dbri, 18, PIPEinput, 16, 8, dbri->mm.offset);
-	link_time_slot(dbri, 19, PIPEinput, 16, 8, dbri->mm.offset + 48);
+	link_time_slot(dbri, 17, 16, 16, 32, dbri->mm.offset);
+	link_time_slot(dbri, 18, 16, 16, 8, dbri->mm.offset);
+	link_time_slot(dbri, 19, 18, 16, 8, dbri->mm.offset + 48);
+	spin_unlock_irqrestore(&dbri->lock, flags);
 
 	/* Wait for the chip to echo back CLB (Control Latch Bit) as zero */
 	dbri->mm.ctrl[0] &= ~CS4215_CLB;
 	xmit_fixed(dbri, 17, *(int *)dbri->mm.ctrl);
 
+	spin_lock_irqsave(&dbri->lock, flags);
 	tmp = sbus_readl(dbri->regs + REG0);
 	tmp |= D_C;		/* Enable CHI */
 	sbus_writel(tmp, dbri->regs + REG0);
+	spin_unlock_irqrestore(&dbri->lock, flags);
 
 	for (i = 10; ((dbri->mm.status & 0xe4) != 0x20); --i) {
 		msleep_interruptible(1);
@@ -1614,8 +1600,7 @@
 	    CS4215_BSEL_128 | CS4215_FREQ[freq_idx].xtal;
 
 	dbri->mm.channels = channels;
-	/* Stereo bit: 8 bit stereo not working yet. */
-	if ((channels > 1) && (dbri->mm.precision == 16))
+	if (channels == 2)
 		dbri->mm.ctrl[1] |= CS4215_DFR_STEREO;
 
 	ret = cs4215_setctrl(dbri);
@@ -1655,7 +1640,6 @@
 	}
 
 	cs4215_setup_pipes(dbri);
-
 	cs4215_init_data(&dbri->mm);
 
 	/* Enable capture of the status & version timeslots. */
@@ -1684,88 +1668,71 @@
 Complicated interrupts are handled by dedicated functions (which
 appear first in this file).  Any pending interrupts can be serviced by
 calling dbri_process_interrupt_buffer(), which works even if the CPU's
-interrupts are disabled.  This function is used by dbri_cmdlock()
-to make sure we're synced up with the chip before each command sequence,
-even if we're running cli'ed.
+interrupts are disabled.
 
 */
 
 /* xmit_descs()
  *
- * Transmit the current TD's for recording/playing, if needed.
+ * Starts transmiting the current TD's for recording/playing.
  * For playback, ALSA has filled the DMA memory with new data (we hope).
  */
-static void xmit_descs(unsigned long data)
+static void xmit_descs(struct snd_dbri *dbri)
 {
-	struct snd_dbri *dbri = (struct snd_dbri *) data;
 	struct dbri_streaminfo *info;
-	volatile s32 *cmd;
+	s32 *cmd;
 	unsigned long flags;
 	int first_td;
 
 	if (dbri == NULL)
 		return;		/* Disabled */
 
-	/* First check the recording stream for buffer overflow */
 	info = &dbri->stream_info[DBRI_REC];
 	spin_lock_irqsave(&dbri->lock, flags);
 
-	if ((info->left >= info->size) && (info->pipe >= 0)) {
+	if (info->pipe >= 0) {
 		first_td = dbri->pipes[info->pipe].first_desc;
 
 		dprintk(D_DESC, "xmit_descs rec @ TD %d\n", first_td);
 
 		/* Stream could be closed by the time we run. */
-		if (first_td < 0) {
-			goto play;
-		}
+		if (first_td >= 0) {
+			cmd = dbri_cmdlock(dbri, 2);
+			*(cmd++) = DBRI_CMD(D_SDP, 0,
+					    dbri->pipes[info->pipe].sdp
+					    | D_SDP_P | D_SDP_EVERY | D_SDP_C);
+			*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, first_td);
+			dbri_cmdsend(dbri, cmd, 2);
 
-		cmd = dbri_cmdlock(dbri, NoGetLock);
-		*(cmd++) = DBRI_CMD(D_SDP, 0,
-				    dbri->pipes[info->pipe].sdp
-				    | D_SDP_P | D_SDP_EVERY | D_SDP_C);
-		*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, first_td);
-		dbri_cmdsend(dbri, cmd);
-
-		/* Reset our admin of the pipe & bytes read. */
-		dbri->pipes[info->pipe].desc = first_td;
-		info->left = 0;
+			/* Reset our admin of the pipe. */
+			dbri->pipes[info->pipe].desc = first_td;
+		}
 	}
 
-play:
-	spin_unlock_irqrestore(&dbri->lock, flags);
-
-	/* Now check the playback stream for buffer underflow */
 	info = &dbri->stream_info[DBRI_PLAY];
-	spin_lock_irqsave(&dbri->lock, flags);
 
-	if ((info->left <= 0) && (info->pipe >= 0)) {
+	if (info->pipe >= 0) {
 		first_td = dbri->pipes[info->pipe].first_desc;
 
 		dprintk(D_DESC, "xmit_descs play @ TD %d\n", first_td);
 
 		/* Stream could be closed by the time we run. */
-		if (first_td < 0) {
-			spin_unlock_irqrestore(&dbri->lock, flags);
-			return;
-		}
+		if (first_td >= 0) {
+			cmd = dbri_cmdlock(dbri, 2);
+			*(cmd++) = DBRI_CMD(D_SDP, 0,
+					    dbri->pipes[info->pipe].sdp
+					    | D_SDP_P | D_SDP_EVERY | D_SDP_C);
+			*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, first_td);
+			dbri_cmdsend(dbri, cmd, 2);
 
-		cmd = dbri_cmdlock(dbri, NoGetLock);
-		*(cmd++) = DBRI_CMD(D_SDP, 0,
-				    dbri->pipes[info->pipe].sdp
-				    | D_SDP_P | D_SDP_EVERY | D_SDP_C);
-		*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, first_td);
-		dbri_cmdsend(dbri, cmd);
-
-		/* Reset our admin of the pipe & bytes written. */
-		dbri->pipes[info->pipe].desc = first_td;
-		info->left = info->size;
+			/* Reset our admin of the pipe. */
+			dbri->pipes[info->pipe].desc = first_td;
+		}
 	}
+
 	spin_unlock_irqrestore(&dbri->lock, flags);
 }
 
-static DECLARE_TASKLET(xmit_descs_task, xmit_descs, 0);
-
 /* transmission_complete_intr()
  *
  * Called by main interrupt handler when DBRI signals transmission complete
@@ -1775,9 +1742,9 @@
  * them as available. Stops when the first descriptor is found without
  * TBC (Transmit Buffer Complete) set, or we've run through them all.
  *
- * The DMA buffers are not released, but re-used. Since the transmit buffer
- * descriptors are not clobbered, they can be re-submitted as is. This is
- * done by the xmit_descs() tasklet above since that could take longer.
+ * The DMA buffers are not released. They form a ring buffer and
+ * they are filled by ALSA while others are transmitted by DMA.
+ *
  */
 
 static void transmission_complete_intr(struct snd_dbri * dbri, int pipe)
@@ -1803,21 +1770,9 @@
 		dprintk(D_INT, "TD %d, status 0x%02x\n", td, status);
 
 		dbri->dma->desc[td].word4 = 0;	/* Reset it for next time. */
-		info->offset += dbri->descs[td].len;
-		info->left -= dbri->descs[td].len;
-
-		/* On the last TD, transmit them all again. */
-		if (dbri->descs[td].next == -1) {
-			if (info->left > 0) {
-				printk(KERN_WARNING
-				       "%d bytes left after last transfer.\n",
-				       info->left);
-				info->left = 0;
-			}
-			tasklet_schedule(&xmit_descs_task);
-		}
+		info->offset += DBRI_RD_CNT(dbri->dma->desc[td].word1);
 
-		td = dbri->descs[td].next;
+		td = dbri->next_desc[td];
 		dbri->pipes[pipe].desc = td;
 	}
 
@@ -1841,30 +1796,18 @@
 		return;
 	}
 
-	dbri->descs[rd].inuse = 0;
-	dbri->pipes[pipe].desc = dbri->descs[rd].next;
+	dbri->pipes[pipe].desc = dbri->next_desc[rd];
 	status = dbri->dma->desc[rd].word1;
 	dbri->dma->desc[rd].word1 = 0;	/* Reset it for next time. */
 
 	info = &dbri->stream_info[DBRI_REC];
 	info->offset += DBRI_RD_CNT(status);
-	info->left += DBRI_RD_CNT(status);
 
 	/* FIXME: Check status */
 
 	dprintk(D_INT, "Recv RD %d, status 0x%02x, len %d\n",
 		rd, DBRI_RD_STATUS(status), DBRI_RD_CNT(status));
 
-	/* On the last TD, transmit them all again. */
-	if (dbri->descs[rd].next == -1) {
-		if (info->left > info->size) {
-			printk(KERN_WARNING
-			       "%d bytes recorded in %d size buffer.\n",
-			       info->left, info->size);
-		}
-		tasklet_schedule(&xmit_descs_task);
-	}
-
 	/* Notify ALSA */
 	if (spin_is_locked(&dbri->lock)) {
 		spin_unlock(&dbri->lock);
@@ -1892,16 +1835,11 @@
 			channel, code, rval);
 	}
 
-	if (channel == D_INTR_CMD && command == D_WAIT) {
-		dbri->wait_ackd = val;
-		if (dbri->wait_send != val) {
-			printk(KERN_ERR "Processing wait command %d when %d was send.\n",
-			       val, dbri->wait_send);
-		}
-		return;
-	}
-
 	switch (code) {
+	case D_INTR_CMDI:
+		if (command != D_WAIT)
+			printk(KERN_ERR "DBRI: Command read interrupt\n");
+		break;
 	case D_INTR_BRDY:
 		reception_complete_intr(dbri, channel);
 		break;
@@ -1914,8 +1852,10 @@
 		 * resend SDP command with clear pipe bit (C) set
 		 */
 		{
-			volatile s32 *cmd;
-
+	/* FIXME: do something useful in case of underrun */
+			printk(KERN_ERR "DBRI: Underrun error\n");
+#if 0
+			s32 *cmd;
 			int pipe = channel;
 			int td = dbri->pipes[pipe].desc;
 
@@ -1926,6 +1866,7 @@
 					    | D_SDP_P | D_SDP_C | D_SDP_2SAME);
 			*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, td);
 			dbri_cmdsend(dbri, cmd);
+#endif
 		}
 		break;
 	case D_INTR_FXDT:
@@ -1946,9 +1887,7 @@
 /* dbri_process_interrupt_buffer advances through the DBRI's interrupt
  * buffer until it finds a zero word (indicating nothing more to do
  * right now).  Non-zero words require processing and are handed off
- * to dbri_process_one_interrupt AFTER advancing the pointer.  This
- * order is important since we might recurse back into this function
- * and need to make sure the pointer has been advanced first.
+ * to dbri_process_one_interrupt AFTER advancing the pointer.
  */
 static void dbri_process_interrupt_buffer(struct snd_dbri * dbri)
 {
@@ -1957,17 +1896,14 @@
 	while ((x = dbri->dma->intr[dbri->dbri_irqp]) != 0) {
 		dbri->dma->intr[dbri->dbri_irqp] = 0;
 		dbri->dbri_irqp++;
-		if (dbri->dbri_irqp == (DBRI_NO_INTS * DBRI_INT_BLK))
+		if (dbri->dbri_irqp == DBRI_INT_BLK)
 			dbri->dbri_irqp = 1;
-		else if ((dbri->dbri_irqp & (DBRI_INT_BLK - 1)) == 0)
-			dbri->dbri_irqp++;
 
 		dbri_process_one_interrupt(dbri, x);
 	}
 }
 
-static irqreturn_t snd_dbri_interrupt(int irq, void *dev_id,
-				      struct pt_regs *regs)
+static irqreturn_t snd_dbri_interrupt(int irq, void *dev_id)
 {
 	struct snd_dbri *dbri = dev_id;
 	static int errcnt = 0;
@@ -2020,8 +1956,6 @@
 
 	dbri_process_interrupt_buffer(dbri);
 
-	/* FIXME: Write 0 into regs to ACK interrupt */
-
 	spin_unlock(&dbri->lock);
 
 	return IRQ_HANDLED;
@@ -2039,8 +1973,8 @@
 				  SNDRV_PCM_FMTBIT_A_LAW |
 				  SNDRV_PCM_FMTBIT_U8 |
 				  SNDRV_PCM_FMTBIT_S16_BE,
-	.rates			= SNDRV_PCM_RATE_8000_48000,
-	.rate_min		= 8000,
+	.rates			= SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_5512,
+	.rate_min		= 5512,
 	.rate_max		= 48000,
 	.channels_min		= 1,
 	.channels_max		= 2,
@@ -2051,6 +1985,39 @@
 	.periods_max		= 1024,
 };
 
+static int snd_hw_rule_format(struct snd_pcm_hw_params *params,
+			      struct snd_pcm_hw_rule *rule)
+{
+	struct snd_interval *c = hw_param_interval(params,
+				SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
+	struct snd_mask fmt;
+
+	snd_mask_any(&fmt);
+	if (c->min > 1) {
+		fmt.bits[0] &= SNDRV_PCM_FMTBIT_S16_BE;
+		return snd_mask_refine(f, &fmt);
+	}
+	return 0;
+}
+
+static int snd_hw_rule_channels(struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_rule *rule)
+{
+	struct snd_interval *c = hw_param_interval(params,
+				SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
+	struct snd_interval ch;
+
+	snd_interval_any(&ch);
+	if (!(f->bits[0] & SNDRV_PCM_FMTBIT_S16_BE)) {
+		ch.min = ch.max = 1;
+		ch.integer = 1;
+		return snd_interval_refine(c, &ch);
+	}
+	return 0;
+}
+
 static int snd_dbri_open(struct snd_pcm_substream *substream)
 {
 	struct snd_dbri *dbri = snd_pcm_substream_chip(substream);
@@ -2063,12 +2030,19 @@
 
 	spin_lock_irqsave(&dbri->lock, flags);
 	info->substream = substream;
-	info->left = 0;
 	info->offset = 0;
 	info->dvma_buffer = 0;
 	info->pipe = -1;
 	spin_unlock_irqrestore(&dbri->lock, flags);
 
+	snd_pcm_hw_rule_add(runtime,0,SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_hw_rule_format, NULL, SNDRV_PCM_HW_PARAM_FORMAT,
+			    -1);
+	snd_pcm_hw_rule_add(runtime,0,SNDRV_PCM_HW_PARAM_FORMAT,
+			    snd_hw_rule_channels, NULL, 
+			    SNDRV_PCM_HW_PARAM_CHANNELS,
+			    -1);
+				
 	cs4215_open(dbri);
 
 	return 0;
@@ -2081,7 +2055,6 @@
 
 	dprintk(D_USR, "close audio output.\n");
 	info->substream = NULL;
-	info->left = 0;
 	info->offset = 0;
 
 	return 0;
@@ -2134,6 +2107,7 @@
 	struct snd_dbri *dbri = snd_pcm_substream_chip(substream);
 	struct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);
 	int direction;
+
 	dprintk(D_USR, "hw_free.\n");
 
 	/* hw_free can get called multiple times. Only unmap the DMA once.
@@ -2148,7 +2122,10 @@
 				  substream->runtime->buffer_size, direction);
 		info->dvma_buffer = 0;
 	}
-	info->pipe = -1;
+	if (info->pipe != -1) {
+		reset_pipe(dbri, info->pipe);
+		info->pipe = -1;
+	}
 
 	return snd_pcm_lib_free_pages(substream);
 }
@@ -2157,18 +2134,16 @@
 {
 	struct snd_dbri *dbri = snd_pcm_substream_chip(substream);
 	struct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
 	info->size = snd_pcm_lib_buffer_bytes(substream);
 	if (DBRI_STREAMNO(substream) == DBRI_PLAY)
 		info->pipe = 4;	/* Send pipe */
-	else {
+	else
 		info->pipe = 6;	/* Receive pipe */
-		info->left = info->size;	/* To trigger submittal */
-	}
 
 	spin_lock_irq(&dbri->lock);
+	info->offset = 0;
 
 	/* Setup the all the transmit/receive desciptors to cover the
 	 * whole DMA buffer.
@@ -2176,8 +2151,6 @@
 	ret = setup_descs(dbri, DBRI_STREAMNO(substream),
 			  snd_pcm_lib_period_bytes(substream));
 
-	runtime->stop_threshold = DBRI_TD_MAXCNT / runtime->channels;
-
 	spin_unlock_irq(&dbri->lock);
 
 	dprintk(D_USR, "prepare audio output. %d bytes\n", info->size);
@@ -2194,14 +2167,11 @@
 	case SNDRV_PCM_TRIGGER_START:
 		dprintk(D_USR, "start audio, period is %d bytes\n",
 			(int)snd_pcm_lib_period_bytes(substream));
-		/* Enable & schedule the tasklet that re-submits the TDs. */
-		xmit_descs_task.data = (unsigned long)dbri;
-		tasklet_schedule(&xmit_descs_task);
+		/* Re-submit the TDs. */
+		xmit_descs(dbri);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		dprintk(D_USR, "stop audio.\n");
-		/* Make the tasklet bail out immediately. */
-		xmit_descs_task.data = 0;
 		reset_pipe(dbri, info->pipe);
 		break;
 	default:
@@ -2219,8 +2189,8 @@
 
 	ret = bytes_to_frames(substream->runtime, info->offset)
 		% substream->runtime->buffer_size;
-	dprintk(D_USR, "I/O pointer: %ld frames, %d bytes left.\n",
-		ret, info->left);
+	dprintk(D_USR, "I/O pointer: %ld frames of %ld.\n",
+		ret, substream->runtime->buffer_size);
 	return ret;
 }
 
@@ -2254,7 +2224,6 @@
 	pcm->private_data = dbri;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, dbri->card->shortname);
-	dbri->pcm = pcm;
 
 	if ((err = snd_pcm_lib_preallocate_pages_for_all(pcm,
 			SNDRV_DMA_TYPE_CONTINUOUS,
@@ -2303,7 +2272,6 @@
 {
 	struct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);
 	struct dbri_streaminfo *info = &dbri->stream_info[kcontrol->private_value];
-	unsigned long flags;
 	int changed = 0;
 
 	if (info->left_gain != ucontrol->value.integer.value[0]) {
@@ -2318,13 +2286,9 @@
 		/* First mute outputs, and wait 1/8000 sec (125 us)
 		 * to make sure this takes.  This avoids clicking noises.
 		 */
-		spin_lock_irqsave(&dbri->lock, flags);
-
 		cs4215_setdata(dbri, 1);
 		udelay(125);
 		cs4215_setdata(dbri, 0);
-
-		spin_unlock_irqrestore(&dbri->lock, flags);
 	}
 	return changed;
 }
@@ -2371,7 +2335,6 @@
 				 struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int elem = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
@@ -2404,13 +2367,9 @@
 		/* First mute outputs, and wait 1/8000 sec (125 us)
 		 * to make sure this takes.  This avoids clicking noises.
 		 */
-		spin_lock_irqsave(&dbri->lock, flags);
-
 		cs4215_setdata(dbri, 1);
 		udelay(125);
 		cs4215_setdata(dbri, 0);
-
-		spin_unlock_irqrestore(&dbri->lock, flags);
 	}
 	return changed;
 }
@@ -2452,8 +2411,6 @@
 	CS4215_SINGLE("Mic boost", 4, 4, 1, 1)
 };
 
-#define NUM_CS4215_CONTROLS (sizeof(dbri_controls)/sizeof(struct snd_kcontrol_new))
-
 static int __init snd_dbri_mixer(struct snd_dbri * dbri)
 {
 	struct snd_card *card;
@@ -2464,7 +2421,7 @@
 	card = dbri->card;
 	strcpy(card->mixername, card->shortname);
 
-	for (idx = 0; idx < NUM_CS4215_CONTROLS; idx++) {
+	for (idx = 0; idx < ARRAY_SIZE(dbri_controls); idx++) {
 		if ((err = snd_ctl_add(card,
 				snd_ctl_new1(&dbri_controls[idx], dbri))) < 0)
 			return err;
@@ -2473,7 +2430,6 @@
 	for (idx = DBRI_REC; idx < DBRI_NO_STREAMS; idx++) {
 		dbri->stream_info[idx].left_gain = 0;
 		dbri->stream_info[idx].right_gain = 0;
-		dbri->stream_info[idx].balance = DBRI_MID_BALANCE;
 	}
 
 	return 0;
@@ -2505,12 +2461,11 @@
 			struct dbri_pipe *pptr = &dbri->pipes[pipe];
 			snd_iprintf(buffer,
 				    "Pipe %d: %s SDP=0x%x desc=%d, "
-				    "len=%d @ %d prev: %d next %d\n",
+				    "len=%d next %d\n",
 				    pipe,
-				    (pptr->direction ==
-				     PIPEinput ? "input" : "output"), pptr->sdp,
-				    pptr->desc, pptr->length, pptr->cycle,
-				    pptr->prevpipe, pptr->nextpipe);
+				   ((pptr->sdp & D_SDP_TO_SER) ? "output" : "input"),
+				    pptr->sdp, pptr->desc,
+				    pptr->length, pptr->nextpipe);
 		}
 	}
 }
@@ -2549,7 +2504,6 @@
 	dbri->card = card;
 	dbri->sdev = sdev;
 	dbri->irq = irq->pri;
-	dbri->dbri_version = sdev->prom_name[9];
 
 	dbri->dma = sbus_alloc_consistent(sdev, sizeof(struct dbri_dma),
 					  &dbri->dma_dvma);
@@ -2669,7 +2623,7 @@
 
 	printk(KERN_INFO "audio%d at %p (irq %d) is DBRI(%c)+CS4215(%d)\n",
 	       dev, dbri->regs,
-	       dbri->irq, dbri->dbri_version, dbri->mm.version);
+	       dbri->irq, sdev->prom_name[9], dbri->mm.version);
 	dev++;
 
 	return 0;
--- linux-2.6.18.noarch/sound/sparc/cs4231.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/sparc/cs4231.c	2007-06-05 17:49:06.000000000 -0400
@@ -1268,7 +1268,7 @@
 	.channels_min		= 1,
 	.channels_max		= 2,
 	.buffer_bytes_max	= (32*1024),
-	.period_bytes_min	= 4096,
+	.period_bytes_min	= 64,
 	.period_bytes_max	= (32*1024),
 	.periods_min		= 1,
 	.periods_max		= 1024,
@@ -1288,7 +1288,7 @@
 	.channels_min		= 1,
 	.channels_max		= 2,
 	.buffer_bytes_max	= (32*1024),
-	.period_bytes_min	= 4096,
+	.period_bytes_min	= 64,
 	.period_bytes_max	= (32*1024),
 	.periods_min		= 1,
 	.periods_max		= 1024,
@@ -1753,7 +1753,7 @@
 
 #ifdef SBUS_SUPPORT
 
-static irqreturn_t snd_cs4231_sbus_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_cs4231_sbus_interrupt(int irq, void *dev_id)
 {
 	unsigned long flags;
 	unsigned char status;
@@ -1796,7 +1796,7 @@
 	snd_cs4231_outm(chip, CS4231_IRQ_STATUS, ~CS4231_ALL_IRQS | ~status, 0);
 	spin_unlock_irqrestore(&chip->lock, flags);
 
-	return 0;
+	return IRQ_HANDLED;
 }
 
 /*
@@ -1821,7 +1821,6 @@
 	if (!(csr & test))
 		goto out;
 	err = -EBUSY;
-	csr = sbus_readl(base->regs + APCCSR);
 	test = APC_XINT_CNVA;
 	if ( base->dir == APC_PLAY )
 		test = APC_XINT_PNVA;
@@ -1862,17 +1861,16 @@
 
 	spin_lock_irqsave(&base->lock, flags);
 	if (!on) {
-		if (base->dir == APC_PLAY) { 
-			sbus_writel(0, base->regs + base->dir + APCNVA); 
-			sbus_writel(1, base->regs + base->dir + APCC); 
-		}
-		else
-		{
-			sbus_writel(0, base->regs + base->dir + APCNC); 
-			sbus_writel(0, base->regs + base->dir + APCVA); 
-		} 
+		sbus_writel(0, base->regs + base->dir + APCNC);
+		sbus_writel(0, base->regs + base->dir + APCNVA);
+		sbus_writel(0, base->regs + base->dir + APCC);
+		sbus_writel(0, base->regs + base->dir + APCVA);
+
+		/* ACK any APC interrupts. */
+		csr = sbus_readl(base->regs + APCCSR);
+		sbus_writel(csr, base->regs + APCCSR);
 	} 
-	udelay(600); 
+	udelay(1000);
 	csr = sbus_readl(base->regs + APCCSR);
 	shift = 0;
 	if ( base->dir == APC_PLAY )
--- linux-2.6.18.noarch/sound/sparc/amd7930.c.orig	2007-06-05 16:46:40.000000000 -0400
+++ linux-2.6.18.noarch/sound/sparc/amd7930.c	2007-06-05 17:49:06.000000000 -0400
@@ -491,7 +491,7 @@
 	__amd7930_write_map(amd);
 }
 
-static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id)
 {
 	struct snd_amd7930 *amd = dev_id;
 	unsigned int elapsed;
@@ -755,7 +755,7 @@
 	.pointer	=	snd_amd7930_capture_pointer,
 };
 
-static int __init snd_amd7930_pcm(struct snd_amd7930 *amd)
+static int __devinit snd_amd7930_pcm(struct snd_amd7930 *amd)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -870,7 +870,7 @@
 	return change;
 }
 
-static struct snd_kcontrol_new amd7930_controls[] __initdata = {
+static struct snd_kcontrol_new amd7930_controls[] __devinitdata = {
 	{
 		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		=	"Monitor Volume",
@@ -900,7 +900,7 @@
 	},
 };
 
-static int __init snd_amd7930_mixer(struct snd_amd7930 *amd)
+static int __devinit snd_amd7930_mixer(struct snd_amd7930 *amd)
 {
 	struct snd_card *card;
 	int idx, err;
@@ -945,11 +945,11 @@
 	.dev_free	=	snd_amd7930_dev_free,
 };
 
-static int __init snd_amd7930_create(struct snd_card *card,
-				     struct resource *rp,
-				     unsigned int reg_size,
-				     int irq, int dev,
-				     struct snd_amd7930 **ramd)
+static int __devinit snd_amd7930_create(struct snd_card *card,
+					struct resource *rp,
+					unsigned int reg_size,
+					int irq, int dev,
+					struct snd_amd7930 **ramd)
 {
 	unsigned long flags;
 	struct snd_amd7930 *amd;
@@ -1013,7 +1013,7 @@
 	return 0;
 }
 
-static int __init amd7930_attach_common(struct resource *rp, int irq)
+static int __devinit amd7930_attach_common(struct resource *rp, int irq)
 {
 	static int dev_num;
 	struct snd_card *card;
@@ -1065,7 +1065,7 @@
 	return err;
 }
 
-static int __init amd7930_obio_attach(struct device_node *dp)
+static int __devinit amd7930_obio_attach(struct device_node *dp)
 {
 	struct linux_prom_registers *regs;
 	struct linux_prom_irqs *irqp;

--- linux-2.6.18.noarch/sound/aoa/aoa-gpio.h	2007-06-05 17:39:10.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/aoa-gpio.h.new	2007-06-23 01:00:39.000000000 -0400
@@ -59,10 +59,10 @@ struct gpio_methods {
 };
 
 struct gpio_notification {
-	struct delayed_work work;
 	notify_func_t notify;
 	void *data;
 	void *gpio_private;
+	struct work_struct work;
 	struct mutex mutex;
 };
 
--- linux-2.6.18.noarch/sound/ppc/tumbler.c	2007-06-05 17:48:54.000000000 -0400
+++ linux-2.6.18.noarch/sound/ppc/tumbler.c.new	2007-06-23 01:39:35.000000000 -0400
@@ -944,7 +944,7 @@ static void check_mute(struct snd_pmac *
 static struct work_struct device_change;
 static struct snd_pmac *device_change_chip;
 
-static void device_change_handler(struct work_struct *work)
+static void device_change_handler(void *self)
 {
 	struct snd_pmac *chip = device_change_chip;
 	struct pmac_tumbler *mix;
@@ -1018,7 +1018,7 @@ static void tumbler_update_automute(stru
 
 
 /* interrupt - headphone plug changed */
-static irqreturn_t headphone_intr(int irq, void *devid)
+static irqreturn_t headphone_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	struct snd_pmac *chip = devid;
 	if (chip->update_automute && chip->initialized) {
@@ -1418,8 +1418,7 @@ int __init snd_pmac_tumbler_init(struct 
 	chip->resume = tumbler_resume;
 #endif
 
-	INIT_WORK(&device_change, device_change_handler);
-	device_change_chip = chip;
+	INIT_WORK(&device_change, device_change_handler, (void *)chip);
 
 #ifdef PMAC_SUPPORT_AUTOMUTE
 	if ((mix->headphone_irq >=0 || mix->lineout_irq >= 0)
--- linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-pcm.c	2007-06-05 17:39:43.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-pcm.c.new	2007-06-23 01:18:40.000000000 -0400
@@ -702,13 +702,13 @@ static inline void handle_interrupt(stru
 	spin_unlock(&i2sdev->low_lock);
 }
 
-irqreturn_t i2sbus_tx_intr(int irq, void *devid)
+irqreturn_t i2sbus_tx_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	handle_interrupt((struct i2sbus_dev *)devid, 0);
 	return IRQ_HANDLED;
 }
 
-irqreturn_t i2sbus_rx_intr(int irq, void *devid)
+irqreturn_t i2sbus_rx_intr(int irq, void *devid, struct pt_regs * regs)
 {
 	handle_interrupt((struct i2sbus_dev *)devid, 1);
 	return IRQ_HANDLED;
--- linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-core.c	2007-06-05 17:39:43.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus-core.c.new	2007-06-23 01:45:42.000000000 -0400
@@ -93,7 +93,7 @@ static void i2sbus_release_dev(struct de
 	kfree(i2sdev);
 }
 
-static irqreturn_t i2sbus_bus_intr(int irq, void *devid)
+static irqreturn_t i2sbus_bus_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	struct i2sbus_dev *dev = devid;
 	u32 intreg;
@@ -165,7 +165,8 @@ static int i2sbus_add_dev(struct macio_d
 	static const char *rnames[] = { "i2sbus: %s (control)",
 					"i2sbus: %s (tx)",
 					"i2sbus: %s (rx)" };
-	static irq_handler_t ints[] = {
+	static irqreturn_t (*ints[])(int irq, void *devid,
+				     struct pt_regs *regs) = {
 		i2sbus_bus_intr,
 		i2sbus_tx_intr,
 		i2sbus_rx_intr
--- linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus.h	2007-06-05 17:39:43.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/soundbus/i2sbus/i2sbus.h.new	2007-06-23 01:22:08.000000000 -0400
@@ -100,9 +100,9 @@ i2sbus_attach_codec(struct soundbus_dev 
 extern void
 i2sbus_detach_codec(struct soundbus_dev *dev, void *data);
 extern irqreturn_t
-i2sbus_tx_intr(int irq, void *devid);
+i2sbus_tx_intr(int irq, void *devid, struct pt_regs *regs);
 extern irqreturn_t
-i2sbus_rx_intr(int irq, void *devid);
+i2sbus_rx_intr(int irq, void *devid, struct pt_regs *regs);
 
 extern void i2sbus_wait_for_stop_both(struct i2sbus_dev *i2sdev);
 extern void i2sbus_pcm_prepare_both(struct i2sbus_dev *i2sdev);
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-pmf.c	2007-06-05 17:39:27.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-pmf.c.new	2007-06-23 01:02:09.000000000 -0400
@@ -69,10 +69,9 @@ static void pmf_gpio_all_amps_restore(st
 	pmf_gpio_set_lineout(rt, (s>>2)&1);
 }
 
-static void pmf_handle_notify(struct work_struct *work)
+static void pmf_handle_notify(void *data)
 {
-	struct gpio_notification *notif =
-		container_of(work, struct gpio_notification, work.work);
+	struct gpio_notification *notif = data;
 
 	mutex_lock(&notif->mutex);
 	if (notif->notify)
@@ -84,9 +83,12 @@ static void pmf_gpio_init(struct gpio_ru
 {
 	pmf_gpio_all_amps_off(rt);
 	rt->implementation_private = 0;
-	INIT_DELAYED_WORK(&rt->headphone_notify.work, pmf_handle_notify);
-	INIT_DELAYED_WORK(&rt->line_in_notify.work, pmf_handle_notify);
-	INIT_DELAYED_WORK(&rt->line_out_notify.work, pmf_handle_notify);
+	INIT_WORK(&rt->headphone_notify.work, pmf_handle_notify,
+		  &rt->headphone_notify);
+	INIT_WORK(&rt->line_in_notify.work, pmf_handle_notify,
+		  &rt->line_in_notify);
+	INIT_WORK(&rt->line_out_notify.work, pmf_handle_notify,
+		  &rt->line_out_notify);
 	mutex_init(&rt->headphone_notify.mutex);
 	mutex_init(&rt->line_in_notify.mutex);
 	mutex_init(&rt->line_out_notify.mutex);
@@ -127,7 +129,7 @@ static void pmf_handle_notify_irq(void *
 {
 	struct gpio_notification *notif = data;
 
-	schedule_delayed_work(&notif->work, 0);
+	schedule_work(&notif->work);
 }
 
 static int pmf_set_notify(struct gpio_runtime *rt,
--- linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-feature.c	2007-06-05 17:39:27.000000000 -0400
+++ linux-2.6.18.noarch/sound/aoa/core/snd-aoa-gpio-feature.c.new	2007-06-23 01:06:11.000000000 -0400
@@ -195,10 +195,9 @@ static void ftr_gpio_all_amps_restore(st
 	ftr_gpio_set_lineout(rt, (s>>2)&1);
 }
 
-static void ftr_handle_notify(struct work_struct *work)
+static void ftr_handle_notify(void *data)
 {
-	struct gpio_notification *notif =
-		container_of(work, struct gpio_notification, work.work);
+	struct gpio_notification *notif = data;
 
 	mutex_lock(&notif->mutex);
 	if (notif->notify)
@@ -254,9 +253,12 @@ static void ftr_gpio_init(struct gpio_ru
 
 	ftr_gpio_all_amps_off(rt);
 	rt->implementation_private = 0;
-	INIT_DELAYED_WORK(&rt->headphone_notify.work, ftr_handle_notify);
-	INIT_DELAYED_WORK(&rt->line_in_notify.work, ftr_handle_notify);
-	INIT_DELAYED_WORK(&rt->line_out_notify.work, ftr_handle_notify);
+	INIT_WORK(&rt->headphone_notify.work, ftr_handle_notify,
+		  &rt->headphone_notify);
+	INIT_WORK(&rt->line_in_notify.work, ftr_handle_notify,
+		  &rt->line_in_notify);
+	INIT_WORK(&rt->line_out_notify.work, ftr_handle_notify,
+		  &rt->line_out_notify);
 	mutex_init(&rt->headphone_notify.mutex);
 	mutex_init(&rt->line_in_notify.mutex);
 	mutex_init(&rt->line_out_notify.mutex);
@@ -281,11 +283,13 @@ static void ftr_gpio_exit(struct gpio_ru
 	mutex_destroy(&rt->line_out_notify.mutex);
 }
 
-static irqreturn_t ftr_handle_notify_irq(int xx, void *data)
+static irqreturn_t ftr_handle_notify_irq(int xx,
+					 void *data,
+					 struct pt_regs *regs)
 {
 	struct gpio_notification *notif = data;
 
-	schedule_delayed_work(&notif->work, 0);
+	schedule_work(&notif->work);
 
 	return IRQ_HANDLED;
 }
--- linux-2.6.18.noarch/sound/ppc/pmac.c	2007-06-05 17:48:54.000000000 -0400
+++ linux-2.6.18.noarch/sound/ppc/pmac.c.new	2007-06-23 02:03:15.000000000 -0400
@@ -713,7 +713,7 @@ void snd_pmac_beep_dma_stop(struct snd_p
  * interrupt handlers
  */
 static irqreturn_t
-snd_pmac_tx_intr(int irq, void *devid)
+snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->playback);
@@ -722,7 +722,7 @@ snd_pmac_tx_intr(int irq, void *devid)
 
 
 static irqreturn_t
-snd_pmac_rx_intr(int irq, void *devid)
+snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->capture);
@@ -731,7 +731,7 @@ snd_pmac_rx_intr(int irq, void *devid)
 
 
 static irqreturn_t
-snd_pmac_ctrl_intr(int irq, void *devid)
+snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	struct snd_pmac *chip = devid;
 	int ctrl = in_le32(&chip->awacs->control);

