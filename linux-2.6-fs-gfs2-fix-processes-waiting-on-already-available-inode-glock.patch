From: Phillip Lougher <plougher@redhat.com>
Date: Wed, 01 Jun 2011 15:59:27 -0000
Subject: [fs] gfs2: fix processes waiting on already-available inode glock
Message-id: <20110601155927.7CFCD44AC5@plougher.csb>
Patchwork-id: 36340
O-Subject: [RHEL5.6.z PATCH] GFS2: Processes waiting on inode glock that no
	processes are holding - bz 709767
Bugzilla: 709767
RH-Acked-by: Steven Whitehouse <swhiteho@redhat.com>
RH-Acked-by: Robert S Peterson <rpeterso@redhat.com>

BZ #709767

Y-stream patch for BZ #694669 fails to apply to 5.6.z
due to the following commit in 5.7

http://git.engineering.redhat.com/?p=users/jwilson/rhel5/kernel;a=commit;h=8348dca02b46d0c81aa881bdb3ac960a9b526243

This is a fix-up of the patch to allow it to be applied to 5.6.z

Phillip

>From dc19b0a4c74c6d9ce20dc8df9b4fba2a731f92ad Mon Sep 17 00:00:00 2001
From: Robert S Peterson <rpeterso@redhat.com>
Date: Tue, 24 May 2011 20:24:48 -0400
Subject: [PATCH] gfs2: fix processes waiting on already-available inode glock

Hi,

This is for bugzilla bug #694669.

This patch fixes a race in the GFS2 glock state machine that may
result in lockups.  The symptom is that all nodes but one will
hang, waiting for a particular glock.  All the holder records
will have the "W" (Waiting) bit set.  The other node will
typically have the glock stuck in Exclusive mode (EX) with no
holder records, but the dinode will be cached.  In other words,
an entry with "I:" will appear in the glock dump for that glock,
but nothing else.

The race has to do with the glock "Pending Demote" bit, which
can be set, then immediately reset by another process, thus
losing the fact that another node needs the glock.  The sequence
of events is:

1. Something schedules the glock workqueue (e.g. glock request from fs)
2. The glock workqueue gets to the point between the test of the reply pending
bit and the spin lock:

        if (test_and_clear_bit(GLF_REPLY_PENDING, &gl->gl_flags)) {
                finish_xmote(gl, gl->gl_reply);
                drop_ref = 1;
        }
        down_read(&gfs2_umount_flush_sem);         <---- i.e. here
        spin_lock(&gl->gl_spin);

3. In comes (a) the reply to our EX lock request setting GLF_REPLY_PENDING and
            (b) the demote request which sets GLF_PENDING_DEMOTE

4. The following test is executed:

        if (test_and_clear_bit(GLF_PENDING_DEMOTE, &gl->gl_flags) &&
            gl->gl_state != LM_ST_UNLOCKED &&
            gl->gl_demote_state != LM_ST_EXCLUSIVE) {

This resets the pending demote flag, and gl->gl_demote_state is not equal to
exclusive, however because the reply from the dlm arrived after we checked for
the GLF_REPLY_PENDING flag, gl->gl_state is still equal to unlocked, so
although we reset the GLF_PENDING_DEMOTE flag, we didn't then set the
GLF_DEMOTE flag or reinstate the GLF_PENDING_DEMOTE_FLAG.

The patch closes the timing window by only transitioning the
"Pending demote" bit to the "demote" flag once we know the
other conditions (not unlocked and not exclusive) are met.

The patch was tested by the customer who could recreate
the problem with their app within 2 hours.  I also tested
it on my gfs-a16c-0{1,2,3,4} cluster using a variety of
parameters to the customer's script, as they suggested.

Regards,

Bob Peterson
Red Hat File Systems

Signed-off-by: Bob Peterson <rpeterso@redhat.com>
--

Signed-off-by: Jarod Wilson <jarod@redhat.com>
---
 fs/gfs2/glock.c |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 83eaecf..683c2b6 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -766,14 +766,19 @@ static void glock_work_func(void *data)
 	}
 	down_read(&gfs2_umount_flush_sem);
 	spin_lock(&gl->gl_spin);
-	if (test_and_clear_bit(GLF_PENDING_DEMOTE, &gl->gl_flags) &&
+	if (test_bit(GLF_PENDING_DEMOTE, &gl->gl_flags) &&
 	    gl->gl_state != LM_ST_UNLOCKED &&
 	    gl->gl_demote_state != LM_ST_EXCLUSIVE) {
 		unsigned long holdtime, now = jiffies;
+
 		holdtime = gl->gl_tchange + gl->gl_ops->go_min_hold_time;
 		if (time_before(now, holdtime))
 			delay = holdtime - now;
-		set_bit(delay ? GLF_PENDING_DEMOTE : GLF_DEMOTE, &gl->gl_flags);
+
+		if (!delay) {
+			clear_bit(GLF_PENDING_DEMOTE, &gl->gl_flags);
+			set_bit(GLF_DEMOTE, &gl->gl_flags);
+		}
 	}
 	run_queue(gl, 0);
 	spin_unlock(&gl->gl_spin);
