From: Konrad Rzeszutek <konradr@redhat.com>
Date: Wed, 11 Jul 2007 11:49:30 -0400
Subject: [net] NetXen: MSI: failed interrupt after fw enabled
Message-id: 20070711154930.GB31367@mars.boston.redhat.com
O-Subject: [RHEL5 U1 PATCH] RHBZ #246019: LTC35465-NetXen driver failed with MSI interrupt after system firmware enable MSI
Bugzilla: 246019

RHBZ#:
------
https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=246019

Description:
------------
NetXen driver uses PCI function 0 to provide the functionality of MSI.
The patch makes driver check the bus master bit for function 0 and
enable it after the card initialization.

RHEL Version Found:
------------------
RHEL5 U1 (2.6.18-32.el5)

Upstream Status:
----------------
http://marc.info/?l=linux-netdev&m=118331665420592&w=2

Test Status:
------------
Tested in-house on System P and System X. We ran stress tests over a 24hr period using
both System P and System X machines and the tests completed successfully.

Proposed Patch:
---------------
This patch is based on 2.6.18-33.el5.

Acked-by: Pete Zaitcev <zaitcev@redhat.com>
---
 drivers/net/netxen/netxen_nic_main.c |   21 ++++++---------------
 1 files changed, 6 insertions(+), 15 deletions(-)

diff --git a/drivers/net/netxen/netxen_nic_main.c b/drivers/net/netxen/netxen_nic_main.c
index 2bf5892..6c0bc75 100644
--- a/drivers/net/netxen/netxen_nic_main.c
+++ b/drivers/net/netxen/netxen_nic_main.c
@@ -45,10 +45,6 @@ MODULE_DESCRIPTION("NetXen Multi port (1/10) Gigabit Network Driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(NETXEN_NIC_LINUX_VERSIONID);
 
-#ifdef CONFIG_PPC
-static int nx_ppc_msi_enable = 0;      /* by default donot enable msi */
-#endif
-
 char netxen_nic_driver_name[] = "netxen-nic";
 static char netxen_nic_driver_string[] = "NetXen Network Driver version "
     NETXEN_NIC_LINUX_VERSIONID;
@@ -197,11 +193,7 @@ netxen_nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	printk(KERN_INFO "%s \n", netxen_nic_driver_string);
 
-#ifdef CONFIG_PPC
-	if (nx_ppc_msi_enable && (pdev->class != 0x020000)) {
-#else /* !CONFIG_PPC */
 	if (pdev->class != 0x020000) {
-#endif /* CONFIG_PPC */
 		printk(KERN_ERR"NetXen function %d, class %x will not"
 				"be enabled.\n",pci_func_id, pdev->class);
 		return -ENODEV;
@@ -365,13 +357,6 @@ netxen_nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* initialize the adapter */
 	netxen_initialize_adapter_hw(adapter);
 
-#ifdef CONFIG_PPC
-	if ((adapter->ahw.boardcfg.board_type ==
-		NETXEN_BRDTYPE_P2_SB31_10G_IMEZ) &&
-			(pci_func_id == 2))
-		    goto err_out_free_adapter;
-#endif /* CONFIG_PPC */
-
 	/*
 	 *  Adapter in our case is quad port so initialize it before
 	 *  initializing the ports
@@ -518,6 +503,12 @@ netxen_nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 					NETXEN_CAM_RAM(0x1fc)));
 		if (val == 0x55555555) {
 		    /* This is the first boot after power up */
+		    netxen_nic_read_w0(adapter, NETXEN_PCIE_REG(0x4), &val);
+                    if (!(val & 0x4)) {
+                        val |= 0x4;
+                        netxen_nic_write_w0(adapter, NETXEN_PCIE_REG(0x4), val);
+                        mdelay(100);
+                    }
 		    val = readl(NETXEN_CRB_NORMALIZE(adapter,
 					NETXEN_ROMUSB_GLB_SW_RESET));
 		    printk(KERN_INFO"NetXen: read 0x%08x for reset reg.\n",val);
-- 
1.5.3.5.645.gbb47

