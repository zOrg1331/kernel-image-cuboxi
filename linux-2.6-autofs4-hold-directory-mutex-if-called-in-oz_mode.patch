From: Ian Kent <ikent@redhat.com>
Date: Tue, 12 Aug 2008 12:26:25 +0800
Subject: [autofs4] hold directory mutex if called in oz_mode
Message-id: 20080812042623.15842.51673.stgit@web.messagingengine.com
O-Subject: [RHEL 5.3 PATCH 07/20] autofs4 - don't release directory mutex if called in oz_mode [bz458749]
Bugzilla: 458749

This patch is for bug 458749.

Since we now delay hashing of dentrys until the ->mkdir() call,
droping and re-taking the directory mutex within the ->lookup()
function when we are being called by user space is not needed.
This can lead to a race when other processes are attempting to
access the same directory during mount point directory creation.

In this case we need to hang onto the mutex to ensure we don't
get user processes trying to create a mount request for a newly
created dentry after the mount point entry has already been
created. This ensures that when we need to check a dentry passed
to autofs4_wait(), if it is hashed, it is always the mount point
dentry and not a new dentry created by another lookup during
directory creation.

diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c
index 7b01926..22cb746 100644
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -685,12 +685,11 @@ static struct dentry *autofs4_lookup(struct inode *dir, struct dentry *dentry, s
 		spin_lock(&dentry->d_lock);
 		dentry->d_flags |= DCACHE_AUTOFS_PENDING;
 		spin_unlock(&dentry->d_lock);
-	}
-
-	if (dentry->d_op && dentry->d_op->d_revalidate) {
-		mutex_unlock(&dir->i_mutex);
-		(dentry->d_op->d_revalidate)(dentry, nd);
-		mutex_lock(&dir->i_mutex);
+		if (dentry->d_op && dentry->d_op->d_revalidate) {
+			mutex_unlock(&dir->i_mutex);
+			(dentry->d_op->d_revalidate)(dentry, nd);
+			mutex_lock(&dir->i_mutex);
+		}
 	}
 
 	/*
