From: Herbert Xu <herbert.xu@redhat.com>
Subject: [RHEL5 PATCH] [LINUX] xen: Use swiotlb mask for coherent mappings too
Date: Fri, 22 Dec 2006 16:14:55 +1100
Bugzilla: 216472
Message-Id: <20061222051455.GA15815@gondor.apana.org.au>
Changelog: xen: Use swiotlb mask for coherent mappings too


Hi:

RHEL5 blocker 216472

This patch is a backport of Xen upstream changeset 13099.  This differs
from the upstream version because they have introduced a boot argument
prior to this changeset which we don't have in RHEL5.

This change is needed for the b44 chipset to work under Xen as it
only knows how to address 1G of RAM.

Original changelog (note the io_tlb_dma_bits variable does not exist
in RHEL5 where we use the IO_TLB_DMA_BITS macro instead):

[LINUX] dma: Use swiotlb mask for coherent mappings too

The recent change to use a default DMA bit width of 30 bits (required
by chips like the b44) only converted the streaming DMA primitives.
The coherent mappings are still hard-coded to 31 bits.  This means
that b44 still doesn't work under Xen.

This patch makes the io_tlb_dma_bits variable global and uses it for
coherent memory mappings.

Thanks to Calvin Webster for providing a machine with a b44 and 2G
of memory I've been able to verify that this finally makes the b44
work under Xen.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

Cheers,
-- 
Visit Openswan at http://www.openswan.org/
Email: Herbert Xu 许志壬 <herbert@gondor.apana.org.au>
Home Page: http://gondor.apana.org.au/herbert/
PGP Key: http://gondor.apana.org.au/herbert/pubkey.txt
--
diff --git a/arch/i386/kernel/pci-dma-xen.c b/arch/i386/kernel/pci-dma-xen.c
index 29fddf6..8f7ef3e 100644
--- a/arch/i386/kernel/pci-dma-xen.c
+++ b/arch/i386/kernel/pci-dma-xen.c
@@ -15,6 +15,7 @@ #include <linux/module.h>
 #include <linux/version.h>
 #include <asm/io.h>
 #include <xen/balloon.h>
+#include <asm/swiotlb.h>
 #include <asm/tlbflush.h>
 #include <asm-i386/mach-xen/asm/swiotlb.h>
 #include <asm/bug.h>
@@ -218,8 +219,8 @@ void *dma_alloc_coherent(struct device *
 	ret = (void *)vstart;
 
 	if (ret != NULL) {
-		/* NB. Hardcode 31 address bits for now: aacraid limitation. */
-		if (xen_create_contiguous_region(vstart, order, 31) != 0) {
+		if (xen_create_contiguous_region(vstart, order,
+						 IO_TLB_DMA_BITS) != 0) {
 			free_pages(vstart, order);
 			return NULL;
 		}
diff --git a/arch/i386/kernel/swiotlb.c b/arch/i386/kernel/swiotlb.c
index 93a4d6c..907be50 100644
--- a/arch/i386/kernel/swiotlb.c
+++ b/arch/i386/kernel/swiotlb.c
@@ -47,9 +47,6 @@ #define IO_TLB_SEGSIZE	128
  */
 #define IO_TLB_SHIFT 11
 
-/* Width of DMA addresses in the IO TLB. 30 bits is a b44 limitation. */
-#define IO_TLB_DMA_BITS 30
-
 int swiotlb_force;
 static char *iotlb_virt_start;
 static unsigned long iotlb_nslabs;
diff --git a/include/asm-i386/mach-xen/asm/swiotlb.h b/include/asm-i386/mach-xen/asm/swiotlb.h
index c9afcbb..cf4ba38 100644
--- a/include/asm-i386/mach-xen/asm/swiotlb.h
+++ b/include/asm-i386/mach-xen/asm/swiotlb.h
@@ -32,6 +32,9 @@ extern void swiotlb_unmap_page(struct de
 extern int swiotlb_dma_supported(struct device *hwdev, u64 mask);
 extern void swiotlb_init(void);
 
+/* Width of DMA addresses in the IO TLB. 30 bits is a b44 limitation. */
+#define IO_TLB_DMA_BITS 30
+
 #ifdef CONFIG_SWIOTLB
 extern int swiotlb;
 #else

--- /dev/null	2005-03-25 14:01:30.000000000 +1100
+++ b/include/asm-ia64/swiotlb.h	2006-12-23 08:37:15.000000000 +1100
@@ -0,0 +1,44 @@
+#ifndef _ASM_SWIOTLB_H
+#define _ASM_SWIOTLB_H 1
+
+/* SWIOTLB interface */
+
+extern dma_addr_t swiotlb_map_single(struct device *hwdev, void *ptr, size_t size,
+				      int dir);
+extern void swiotlb_unmap_single(struct device *hwdev, dma_addr_t dev_addr,
+				  size_t size, int dir);
+extern void swiotlb_sync_single_for_cpu(struct device *hwdev,
+					 dma_addr_t dev_addr,
+					 size_t size, int dir);
+extern void swiotlb_sync_single_for_device(struct device *hwdev,
+					    dma_addr_t dev_addr,
+					    size_t size, int dir);
+extern void swiotlb_sync_sg_for_cpu(struct device *hwdev,
+				     struct scatterlist *sg, int nelems,
+				     int dir);
+extern void swiotlb_sync_sg_for_device(struct device *hwdev,
+					struct scatterlist *sg, int nelems,
+					int dir);
+extern int swiotlb_map_sg(struct device *hwdev, struct scatterlist *sg,
+		      int nents, int direction);
+extern void swiotlb_unmap_sg(struct device *hwdev, struct scatterlist *sg,
+			 int nents, int direction);
+extern int swiotlb_dma_mapping_error(dma_addr_t dma_addr);
+extern dma_addr_t swiotlb_map_page(struct device *hwdev, struct page *page,
+                                   unsigned long offset, size_t size,
+                                   enum dma_data_direction direction);
+extern void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dma_address,
+                               size_t size, enum dma_data_direction direction);
+extern int swiotlb_dma_supported(struct device *hwdev, u64 mask);
+extern void swiotlb_init(void);
+
+/* Width of DMA addresses in the IO TLB. 30 bits is a b44 limitation. */
+#define IO_TLB_DMA_BITS 30
+
+#ifdef CONFIG_SWIOTLB
+extern int swiotlb;
+#else
+#define swiotlb 0
+#endif
+
+#endif

Index: latest/arch/i386/kernel/swiotlb.c
===================================================================
--- latest.orig/arch/i386/kernel/swiotlb.c
+++ latest/arch/i386/kernel/swiotlb.c
@@ -26,6 +26,7 @@
 #include <asm/dma.h>
 #include <asm/uaccess.h>
 #include <xen/interface/memory.h>
+#include <asm-i386/mach-xen/asm/swiotlb.h>
 
 int swiotlb;
 EXPORT_SYMBOL(swiotlb);
