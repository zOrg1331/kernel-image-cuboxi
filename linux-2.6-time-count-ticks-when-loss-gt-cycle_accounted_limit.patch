From: Glauber Costa <glommer@redhat.com>
Date: Thu, 1 Jul 2010 19:45:34 -0400
Subject: [time] count ticks when loss gt cycle_accounted_limit
Message-id: <1278013535-12710-2-git-send-email-glommer@redhat.com>
Patchwork-id: 26667
O-Subject: [RHEL5.6 PATCH 1/2] account ticks even if we lost more than
	cycle_accounted_limit
Bugzilla: 584679
RH-Acked-by: Rik van Riel <riel@redhat.com>
RH-Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>
RH-Acked-by: Marcelo Tosatti <mtosatti@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

RH-Author: Glauber Costa <glommer@redhat.com>
RH-Bugzilla: 584679
RH-Upstream-status: N/A.

The algorithm we are using for lost tick compensation works well when
the VM is de-scheduled and don't run for a period of time. But when
we stop the VM, it is pretty common to leave it not running for large
periods of time.

Testing this, I found that a VM stopped for more than a day can recover
all its losts ticks in just a couple of seconds, which sounds like okay,
specially considering it is hard to do better that with current RHEL5 timer
infrastructure.

Signed-off-by: Glauber Costa <glommer@redhat.com>

diff --git a/arch/x86_64/kernel/time.c b/arch/x86_64/kernel/time.c
index cb6c8f3..dfe9ec6 100644
--- a/arch/x86_64/kernel/time.c
+++ b/arch/x86_64/kernel/time.c
@@ -512,12 +512,6 @@ static void do_timer_tsc_timekeeping(struct pt_regs *regs)
 
 	tsc_not_accounted = tsc - tsc_accounted;
 
-	if (tsc_not_accounted > cycles_accounted_limit) {
-		/* Be extra safe and limit the loop below. */
-		tsc_accounted += tsc_not_accounted - cycles_accounted_limit;
-		tsc_not_accounted = cycles_accounted_limit;
-	}
-
 	while (tsc_not_accounted >= cycles_per_tick) {
 		for (i = 0; i < tick_divider; i++)
 			do_timer_jiffy(regs);
