From: David Milburn <dmilburn@redhat.com>
Date: Wed, 22 Apr 2009 16:30:09 -0500
Subject: [scsi] stex: support promise 6Gb sas raid controller
Message-id: 20090422213009.GA5121@dhcp-210.hsv.redhat.com
O-Subject: [RHEL5.4 PATCH] stex: support promise 6Gb sas raid controller
Bugzilla: 492022
RH-Acked-by: Mike Christie <mchristi@redhat.com>

This patch updates the stex driver to 4.6.0102.3 primarily
to provide support Promise 6Gb SAS RAID controller (105a:8760).
Backport was by Ed Lin at Promise, he has verified the driver
update on the 6Gb controller and I have regression tested
a system with SuperTRAK EX8350/16350 and a st_vsc system.

Upstream commits:
commit 05b4460bd4f2450021ee2887c801283a95393f03
commit 0f3f6ee68f771b61dc6bc5ae7c2e355cfc5884d1
commit 591a3a5f604c2bee0ba6a614469575918238f4f9
commit 99946f8141f65a8bd5034ac5b1a53237aec8743e
commit f14981616205eedb6fe8b24a09ec103ed976e122
commit bd5cd9cdc5379088b7e4e9a1757a1d101223a005
commit 7cfe99a526b92e30df19673b3533f827bbe93821
commit e8a091b36cd50faa1276e6934edcc3e8b8e83b5a
commit dd48ebf7ca4a6e60e6787e443f5316724309865b

This resolves BZ 492022, I am still working with Promise
on the fix to allow xen kernel to boot on st_vsc
platform due to failure of dma_alloc_coherent (BZ 486466).

Please review and ACK.

Thanks,
David

diff --git a/drivers/scsi/stex.c b/drivers/scsi/stex.c
index cf253d0..aaaaa39 100644
--- a/drivers/scsi/stex.c
+++ b/drivers/scsi/stex.c
@@ -1,7 +1,7 @@
 /*
  * SuperTrak EX Series Storage Controller driver for Linux
  *
- *	Copyright (C) 2005, 2006 Promise Technology Inc.
+ *	Copyright (C) 2005-2009 Promise Technology Inc.
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -35,11 +35,11 @@
 #include <scsi/scsi_dbg.h>
 
 #define DRV_NAME "stex"
-#define ST_DRIVER_VERSION "3.6.0102.2"
-#define ST_VER_MAJOR 		3
-#define ST_VER_MINOR 		6
-#define ST_OEM 			0102
-#define ST_BUILD_VER 		2
+#define ST_DRIVER_VERSION "4.6.0102.3"
+#define ST_VER_MAJOR		4
+#define ST_VER_MINOR		6
+#define ST_OEM			102
+#define ST_BUILD_VER		3
 
 enum {
 	/* MU register offset */
@@ -54,6 +54,13 @@ enum {
 	OIS	= 0x30,	/* MU_OUTBOUND_INTERRUPT_STATUS */
 	OIM	= 0x3c,	/* MU_OUTBOUND_INTERRUPT_MASK */
 
+	YH2I_INT				= 0x20,
+	YINT_EN					= 0x34,
+	YI2H_INT				= 0x9c,
+	YI2H_INT_C				= 0xa0,
+	YH2I_REQ				= 0xc0,
+	YH2I_REQ_HI				= 0xc4,
+
 	/* MU register value */
 	MU_INBOUND_DOORBELL_HANDSHAKE		= 1,
 	MU_INBOUND_DOORBELL_REQHEADCHANGED	= 2,
@@ -94,35 +101,32 @@ enum {
 	TASK_ATTRIBUTE_ORDERED			= 0x2,
 	TASK_ATTRIBUTE_ACA			= 0x4,
 
-	/* request count, etc. */
-	MU_MAX_REQUEST				= 32,
-	TAG_BITMAP_LENGTH			= MU_MAX_REQUEST,
+	SS_STS_NORMAL				= 0x80000000,
+	SS_STS_DONE				= 0x40000000,
+	SS_STS_HANDSHAKE			= 0x20000000,
 
-	/* one message wasted, use MU_MAX_REQUEST+1
-		to handle MU_MAX_REQUEST messages */
-	MU_REQ_COUNT				= (MU_MAX_REQUEST + 1),
-	MU_STATUS_COUNT				= (MU_MAX_REQUEST + 1),
+	SS_HEAD_HANDSHAKE			= 0x80,
 
-	STEX_CDB_LENGTH				= MAX_COMMAND_SIZE,
-	REQ_VARIABLE_LEN			= 1024,
+	STEX_CDB_LENGTH				= 16,
 	STATUS_VAR_LEN				= 128,
-	ST_CAN_QUEUE				= MU_MAX_REQUEST,
-	ST_CMD_PER_LUN				= MU_MAX_REQUEST,
-	ST_MAX_SG				= 32,
 
 	/* sg flags */
 	SG_CF_EOT				= 0x80,	/* end of table */
 	SG_CF_64B				= 0x40,	/* 64 bit item */
 	SG_CF_HOST				= 0x20,	/* sg in host memory */
+	MSG_DATA_DIR_ND				= 0,
+	MSG_DATA_DIR_IN				= 1,
+	MSG_DATA_DIR_OUT			= 2,
 
 	st_shasta				= 0,
 	st_vsc					= 1,
-	st_vsc1					= 2,
-	st_yosemite				= 3,
+	st_yosemite				= 2,
+	st_seq					= 3,
+	st_yel					= 4,
 
 	PASSTHRU_REQ_TYPE			= 0x00000001,
 	PASSTHRU_REQ_NO_WAKEUP			= 0x00000100,
-	ST_INTERNAL_TIMEOUT			= 30,
+	ST_INTERNAL_TIMEOUT			= 180,
 
 	ST_TO_CMD				= 0,
 	ST_FROM_CMD				= 1,
@@ -152,59 +156,40 @@ enum {
 	ST_ADDITIONAL_MEM			= 0x200000,
 };
 
-/* SCSI inquiry data */
-typedef struct st_inq {
-	u8 DeviceType			:5;
-	u8 DeviceTypeQualifier		:3;
-	u8 DeviceTypeModifier		:7;
-	u8 RemovableMedia		:1;
-	u8 Versions;
-	u8 ResponseDataFormat		:4;
-	u8 HiSupport			:1;
-	u8 NormACA			:1;
-	u8 ReservedBit			:1;
-	u8 AERC				:1;
-	u8 AdditionalLength;
-	u8 Reserved[2];
-	u8 SoftReset			:1;
-	u8 CommandQueue			:1;
-	u8 Reserved2			:1;
-	u8 LinkedCommands		:1;
-	u8 Synchronous			:1;
-	u8 Wide16Bit			:1;
-	u8 Wide32Bit			:1;
-	u8 RelativeAddressing		:1;
-	u8 VendorId[8];
-	u8 ProductId[16];
-	u8 ProductRevisionLevel[4];
-	u8 VendorSpecific[20];
-	u8 Reserved3[40];
-} ST_INQ;
-
 struct st_sgitem {
 	u8 ctrl;	/* SG_CF_xxx */
 	u8 reserved[3];
 	__le32 count;
+	__le64 addr;
+};
+
+struct st_ss_sgitem {
 	__le32 addr;
 	__le32 addr_hi;
+	__le32 count;
 };
 
 struct st_sgtable {
 	__le16 sg_count;
 	__le16 max_sg_count;
 	__le32 sz_in_byte;
-	struct st_sgitem table[ST_MAX_SG];
+};
+
+struct st_msg_header {
+	__le64 handle;
+	u8 flag;
+	u8 channel;
+	__le16 timeout;
+	u32 reserved;
 };
 
 struct handshake_frame {
-	__le32 rb_phy;		/* request payload queue physical address */
-	__le32 rb_phy_hi;
+	__le64 rb_phy;		/* request payload queue physical address */
 	__le16 req_sz;		/* size of each request payload */
 	__le16 req_cnt;		/* count of reqs the buffer can hold */
 	__le16 status_sz;	/* size of each status payload */
 	__le16 status_cnt;	/* count of status the buffer can hold */
-	__le32 hosttime;	/* seconds from Jan 1, 1970 (GMT) */
-	__le32 hosttime_hi;
+	__le64 hosttime;	/* seconds from Jan 1, 1970 (GMT) */
 	u8 partner_type;	/* who sends this frame */
 	u8 reserved0[7];
 	__le32 partner_ver_major;
@@ -213,7 +198,8 @@ struct handshake_frame {
 	__le32 partner_ver_build;
 	__le32 extra_offset;	/* NEW */
 	__le32 extra_size;	/* NEW */
-	u32 reserved1[2];
+	__le32 scratch_size;
+	u32 reserved1;
 };
 
 struct req_msg {
@@ -222,10 +208,10 @@ struct req_msg {
 	u8 target;
 	u8 task_attr;
 	u8 task_manage;
-	u8 prd_entry;
+	u8 data_dir;
 	u8 payload_sz;		/* payload size in 4-byte, not used */
 	u8 cdb[STEX_CDB_LENGTH];
-	u8 variable[REQ_VARIABLE_LEN];
+	u32 variable[0];
 };
 
 struct status_msg {
@@ -281,12 +267,6 @@ struct st_drvver {
 	u32 reserved[3];
 };
 
-#define MU_REQ_BUFFER_SIZE	(MU_REQ_COUNT * sizeof(struct req_msg))
-#define MU_STATUS_BUFFER_SIZE	(MU_STATUS_COUNT * sizeof(struct status_msg))
-#define MU_BUFFER_SIZE		(MU_REQ_BUFFER_SIZE + MU_STATUS_BUFFER_SIZE)
-#define STEX_EXTRA_SIZE		max(sizeof(struct st_frame), sizeof(ST_INQ))
-#define STEX_BUFFER_SIZE	(MU_BUFFER_SIZE + STEX_EXTRA_SIZE)
-
 struct st_ccb {
 	struct req_msg *req;
 	struct scsi_cmnd *cmd;
@@ -298,6 +278,7 @@ struct st_ccb {
 	u32 req_type;
 	u8 srb_status;
 	u8 scsi_status;
+	u8 reserved[2];
 };
 
 struct st_hba {
@@ -309,7 +290,11 @@ struct st_hba {
 	struct Scsi_Host *host;
 	struct pci_dev *pdev;
 
-	u32 tag;
+	struct req_msg * (*alloc_rq) (struct st_hba *);
+	int (*map_sg) (struct st_hba *, struct req_msg *, struct st_ccb *);
+	void (*send) (struct st_hba *, struct req_msg *, u16);
+
+	unsigned long *tag;
 	u32 req_head;
 	u32 req_tail;
 	u32 status_head;
@@ -317,16 +302,36 @@ struct st_hba {
 
 	struct status_msg *status_buffer;
 	void *copy_buffer; /* temp buffer for driver-handled commands */
-	struct st_ccb ccb[MU_MAX_REQUEST];
+	struct st_ccb *ccb;
 	struct st_ccb *wait_ccb;
-	wait_queue_head_t waitq;
+	__le32 *scratch;
 
 	unsigned int mu_status;
+	unsigned int cardtype;
+	int msi_enabled;
 	int out_req_cnt;
+	u32 extra_offset;
+	u16 rq_count;
+	u16 rq_size;
+	u16 sts_count;
+};
 
-	unsigned int cardtype;
+struct st_card_info {
+	struct req_msg * (*alloc_rq) (struct st_hba *);
+	int (*map_sg) (struct st_hba *, struct req_msg *, struct st_ccb *);
+	void (*send) (struct st_hba *, struct req_msg *, u16);
+	unsigned int max_id;
+	unsigned int max_lun;
+	unsigned int max_channel;
+	u16 rq_count;
+	u16 rq_size;
+	u16 sts_count;
 };
 
+static int msi;
+module_param(msi, int, 0);
+MODULE_PARM_DESC(msi, "Enable Message Signaled Interrupts(0=off, 1=on)");
+
 static const char console_inq_page[] =
 {
 	0x03,0x00,0x03,0x03,0xFA,0x00,0x00,0x30,
@@ -344,19 +349,19 @@ MODULE_DESCRIPTION("Promise Technology SuperTrak EX Controllers");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(ST_DRIVER_VERSION);
 
-static void stex_gettime(__le32 *time)
+static void stex_gettime(__le64 *time)
 {
 	struct timeval tv;
-	do_gettimeofday(&tv);
 
-	*time = cpu_to_le32(tv.tv_sec & 0xffffffff);
-	*(time + 1) = cpu_to_le32((tv.tv_sec >> 16) >> 16);
+	do_gettimeofday(&tv);
+	*time = cpu_to_le64(tv.tv_sec);
 }
 
-static u16 stex_alloc_tag(unsigned long *bitmap) {
+static u16 stex_alloc_tag(unsigned long *bitmap, int depth)
+{
 	int i;
-	i = find_first_zero_bit(bitmap, TAG_BITMAP_LENGTH);
-	if (i < TAG_BITMAP_LENGTH)
+	i = find_first_zero_bit(bitmap, depth);
+	if (i < depth)
 		__set_bit(i, bitmap);
 	return (u16)i;
 }
@@ -367,11 +372,10 @@ static void stex_free_tag(unsigned long *bitmap, u16 tag) {
 
 static struct status_msg *stex_get_status(struct st_hba *hba)
 {
-	struct status_msg *status =
-		hba->status_buffer + hba->status_tail;
+	struct status_msg *status = hba->status_buffer + hba->status_tail;
 
 	++hba->status_tail;
-	hba->status_tail %= MU_STATUS_COUNT;
+	hba->status_tail %= hba->sts_count+1;
 
 	return status;
 }
@@ -390,22 +394,27 @@ static void stex_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq)
 static void stex_invalid_field(struct scsi_cmnd *cmd,
 			       void (*done)(struct scsi_cmnd *))
 {
-	/* "Invalid field in cbd" */
+	/* "Invalid field in cdb" */
 	stex_set_sense(cmd, ILLEGAL_REQUEST, 0x24, 0x0);
 	done(cmd);
 }
 
 static struct req_msg *stex_alloc_req(struct st_hba *hba)
 {
-	struct req_msg *req = ((struct req_msg *)hba->dma_mem) +
-		hba->req_head;
+	struct req_msg *req = hba->dma_mem + hba->req_head * hba->rq_size;
 
 	++hba->req_head;
-	hba->req_head %= MU_REQ_COUNT;
+	hba->req_head %= hba->rq_count+1;
 
 	return req;
 }
 
+static struct req_msg *stex_ss_alloc_req(struct st_hba *hba)
+{
+	return (struct req_msg *)(hba->dma_mem +
+		hba->req_head * hba->rq_size + sizeof(struct st_msg_header));
+}
+
 static int stex_map_sg(struct st_hba *hba,
 	struct req_msg *req, struct st_ccb *ccb)
 {
@@ -414,12 +423,14 @@ static int stex_map_sg(struct st_hba *hba,
 	dma_addr_t dma_handle;
 	struct scatterlist *src;
 	struct st_sgtable *dst;
+	struct st_sgitem *table;
 	int i;
 
 	cmd = ccb->cmd;
 	dst = (struct st_sgtable *)req->variable;
-	dst->max_sg_count = cpu_to_le16(ST_MAX_SG);
+	dst->max_sg_count = cpu_to_le16(hba->host->sg_tablesize);
 	dst->sz_in_byte = cpu_to_le32(cmd->request_bufflen);
+	table = (struct st_sgitem *)(dst + 1);
 
 	if (cmd->use_sg) {
 		int n_elem;
@@ -428,21 +439,70 @@ static int stex_map_sg(struct st_hba *hba,
 		n_elem = pci_map_sg(pdev, src,
 			cmd->use_sg, cmd->sc_data_direction);
 		if (n_elem <= 0)
-			return -EIO;
+			return 0;
 
 		ccb->sg_count = n_elem;
 		dst->sg_count = cpu_to_le16((u16)n_elem);
 
 		for (i = 0; i < n_elem; i++, src++) {
-			dst->table[i].count = cpu_to_le32((u32)sg_dma_len(src));
-			dst->table[i].addr =
+			table[i].count = cpu_to_le32((u32)sg_dma_len(src));
+			table[i].addr = cpu_to_le64(sg_dma_address(src));
+			table[i].ctrl = SG_CF_64B | SG_CF_HOST;
+		}
+		table[--i].ctrl |= SG_CF_EOT;
+		return n_elem;
+	}
+
+	dma_handle = pci_map_single(pdev, cmd->request_buffer,
+		cmd->request_bufflen, cmd->sc_data_direction);
+	cmd->SCp.dma_handle = dma_handle;
+
+	ccb->sg_count = 1;
+	dst->sg_count = cpu_to_le16(1);
+	table[0].count = cpu_to_le32((u32)cmd->request_bufflen);
+	table[0].addr = cpu_to_le64(dma_handle);
+	table[0].ctrl = SG_CF_EOT | SG_CF_64B | SG_CF_HOST;
+
+	return 1;
+}
+
+static int stex_ss_map_sg(struct st_hba *hba,
+	struct req_msg *req, struct st_ccb *ccb)
+{
+	struct pci_dev *pdev = hba->pdev;
+	struct scsi_cmnd *cmd;
+	dma_addr_t dma_handle;
+	struct scatterlist *src;
+	struct st_sgtable *dst;
+	struct st_ss_sgitem *table;
+	int i;
+
+	cmd = ccb->cmd;
+	dst = (struct st_sgtable *)req->variable;
+	dst->max_sg_count = cpu_to_le16(hba->host->sg_tablesize);
+	dst->sz_in_byte = cpu_to_le32(cmd->request_bufflen);
+	table = (struct st_ss_sgitem *)(dst + 1);
+
+	if (cmd->use_sg) {
+		int n_elem;
+
+		src = (struct scatterlist *) cmd->request_buffer;
+		n_elem = pci_map_sg(pdev, src,
+			cmd->use_sg, cmd->sc_data_direction);
+		if (n_elem <= 0)
+			return 0;
+
+		ccb->sg_count = n_elem;
+		dst->sg_count = cpu_to_le16((u16)n_elem);
+
+		for (i = 0; i < n_elem; i++, src++) {
+			table[i].count = cpu_to_le32((u32)sg_dma_len(src));
+			table[i].addr =
 				cpu_to_le32(sg_dma_address(src) & 0xffffffff);
-			dst->table[i].addr_hi =
+			table[i].addr_hi =
 				cpu_to_le32((sg_dma_address(src) >> 16) >> 16);
-			dst->table[i].ctrl = SG_CF_64B | SG_CF_HOST;
 		}
-		dst->table[--i].ctrl |= SG_CF_EOT;
-		return 0;
+		return n_elem;
 	}
 
 	dma_handle = pci_map_single(pdev, cmd->request_buffer,
@@ -451,12 +511,11 @@ static int stex_map_sg(struct st_hba *hba,
 
 	ccb->sg_count = 1;
 	dst->sg_count = cpu_to_le16(1);
-	dst->table[0].addr = cpu_to_le32(dma_handle & 0xffffffff);
-	dst->table[0].addr_hi = cpu_to_le32((dma_handle >> 16) >> 16);
-	dst->table[0].count = cpu_to_le32((u32)cmd->request_bufflen);
-	dst->table[0].ctrl = SG_CF_EOT | SG_CF_64B | SG_CF_HOST;
+	table[0].count = cpu_to_le32((u32)cmd->request_bufflen);
+	table[0].addr = cpu_to_le32(dma_handle & 0xffffffff);
+	table[0].addr_hi = cpu_to_le32((dma_handle >> 16) >> 16);
 
-	return 0;
+	return 1;
 }
 
 static void stex_internal_copy(struct scsi_cmnd *cmd,
@@ -548,8 +607,6 @@ static void
 stex_send_cmd(struct st_hba *hba, struct req_msg *req, u16 tag)
 {
 	req->tag = cpu_to_le16(tag);
-	req->task_attr = TASK_ATTRIBUTE_SIMPLE;
-	req->task_manage = 0; /* not supported yet */
 
 	hba->ccb[tag].req = req;
 	hba->out_req_cnt++;
@@ -559,15 +616,35 @@ stex_send_cmd(struct st_hba *hba, struct req_msg *req, u16 tag)
 	readl(hba->mmio_base + IDBL); /* flush */
 }
 
-static int
-stex_slave_alloc(struct scsi_device *sdev)
+static void
+stex_ss_send_cmd(struct st_hba *hba, struct req_msg *req, u16 tag)
 {
-	/* Cheat: usually extracted from Inquiry data */
-	sdev->tagged_supported = 1;
+	struct scsi_cmnd *cmd;
+	struct st_msg_header *msg_h;
+	dma_addr_t addr;
 
-	scsi_activate_tcq(sdev, sdev->host->can_queue);
+	req->tag = cpu_to_le16(tag);
 
-	return 0;
+	hba->ccb[tag].req = req;
+	hba->out_req_cnt++;
+
+	cmd = hba->ccb[tag].cmd;
+	msg_h = (struct st_msg_header *)req - 1;
+	if (likely(cmd)) {
+		msg_h->channel = (u8)cmd->device->channel;
+		msg_h->timeout = cpu_to_le16(cmd->timeout_per_command/HZ);
+	}
+	addr = hba->dma_handle + hba->req_head * hba->rq_size;
+	addr += (hba->ccb[tag].sg_count+4)/11;
+	msg_h->handle = cpu_to_le64(addr);
+
+	++hba->req_head;
+	hba->req_head %= hba->rq_count+1;
+
+	writel((addr >> 16) >> 16, hba->mmio_base + YH2I_REQ_HI);
+	readl(hba->mmio_base + YH2I_REQ_HI); /* flush */
+	writel(addr, hba->mmio_base + YH2I_REQ);
+	readl(hba->mmio_base + YH2I_REQ); /* flush */
 }
 
 static int
@@ -576,25 +653,19 @@ stex_slave_config(struct scsi_device *sdev)
 	sdev->use_10_for_rw = 1;
 	sdev->use_10_for_ms = 1;
 	sdev->timeout = 60 * HZ;
-	sdev->tagged_supported = 1;
 
 	return 0;
 }
 
-static void
-stex_slave_destroy(struct scsi_device *sdev)
-{
-	scsi_deactivate_tcq(sdev, 1);
-}
-
 static int
 stex_queuecommand(struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
 {
 	struct st_hba *hba;
 	struct Scsi_Host *host;
-	unsigned int id,lun;
+	unsigned int id, lun;
 	struct req_msg *req;
 	u16 tag;
+
 	host = cmd->device->host;
 	id = cmd->device->id;
 	lun = cmd->device->lun;
@@ -606,6 +677,7 @@ stex_queuecommand(struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
 		static char ms10_caching_page[12] =
 			{ 0, 0x12, 0, 0, 0, 0, 0, 0, 0x8, 0xa, 0x4, 0 };
 		unsigned char page;
+
 		page = cmd->cmnd[2] & 0x3f;
 		if (page == 0x8 || page == 0x3f) {
 			stex_direct_copy(cmd, ms10_caching_page,
@@ -637,7 +709,8 @@ stex_queuecommand(struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
 	case INQUIRY:
 		if (id != host->max_id - 1)
 			break;
-		if (lun == 0 && (cmd->cmnd[1] & INQUIRY_EVPD) == 0) {
+		if (!lun && !cmd->device->channel &&
+			(cmd->cmnd[1] & INQUIRY_EVPD) == 0) {
 			stex_direct_copy(cmd, console_inq_page,
 				sizeof(console_inq_page));
 			cmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8;
@@ -667,11 +740,12 @@ stex_queuecommand(struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
 
 	cmd->scsi_done = done;
 
-	if (unlikely((tag = stex_alloc_tag((unsigned long *)&hba->tag))
-		>= host->can_queue))
+	tag = stex_alloc_tag(hba->tag, host->can_queue);
+
+	if (unlikely(tag >= host->can_queue))
 		return SCSI_MLQUEUE_HOST_BUSY;
 
-	req = stex_alloc_req(hba);
+	req = hba->alloc_rq(hba);
 
 	req->lun = lun;
 	req->target = id;
@@ -679,15 +753,24 @@ stex_queuecommand(struct scsi_cmnd *cmd, void (* done)(struct scsi_cmnd *))
 	/* cdb */
 	memcpy(req->cdb, cmd->cmnd, STEX_CDB_LENGTH);
 
+	if (cmd->sc_data_direction == DMA_FROM_DEVICE)
+		req->data_dir = MSG_DATA_DIR_IN;
+	else if (cmd->sc_data_direction == DMA_TO_DEVICE)
+		req->data_dir = MSG_DATA_DIR_OUT;
+	else
+		req->data_dir = MSG_DATA_DIR_ND;
+
 	hba->ccb[tag].cmd = cmd;
 	hba->ccb[tag].sense_bufflen = SCSI_SENSE_BUFFERSIZE;
 	hba->ccb[tag].sense_buffer = cmd->sense_buffer;
-	hba->ccb[tag].req_type = 0;
 
-	if (cmd->sc_data_direction != DMA_NONE)
-		stex_map_sg(hba, req, &hba->ccb[tag]);
+	if (cmd->sc_data_direction == DMA_NONE ||
+		!hba->map_sg(hba, req, &hba->ccb[tag])) {
+		hba->ccb[tag].sg_count = 0;
+		memset(&req->variable[0], 0, 8);
+	}
 
-	stex_send_cmd(hba, req, tag);
+	hba->send(hba, req, tag);
 	return 0;
 }
 
@@ -708,7 +791,7 @@ static void stex_scsi_done(struct st_ccb *ccb)
 	struct scsi_cmnd *cmd = ccb->cmd;
 	int result;
 
-	if (ccb->srb_status == SRB_STATUS_SUCCESS ||  ccb->srb_status == 0) {
+	if (ccb->srb_status == SRB_STATUS_SUCCESS || ccb->srb_status == 0) {
 		result = ccb->scsi_status;
 		switch (ccb->scsi_status) {
 		case SAM_STAT_GOOD:
@@ -749,6 +832,7 @@ static void stex_copy_data(struct st_ccb *ccb,
 	struct status_msg *resp, unsigned int variable)
 {
 	size_t count = variable;
+
 	if (resp->scsi_status != SAM_STAT_GOOD) {
 		if (ccb->sense_buffer != NULL)
 			memcpy(ccb->sense_buffer, resp->variable,
@@ -762,35 +846,13 @@ static void stex_copy_data(struct st_ccb *ccb,
 		resp->variable, &count, ccb->sg_count, ST_TO_CMD);
 }
 
-static void stex_ys_commands(struct st_hba *hba,
+static void stex_check_cmd(struct st_hba *hba,
 	struct st_ccb *ccb, struct status_msg *resp)
 {
-	size_t count;
-
 	if (ccb->cmd->cmnd[0] == MGT_CMD &&
-		resp->scsi_status != SAM_STAT_CHECK_CONDITION) {
+		resp->scsi_status != SAM_STAT_CHECK_CONDITION)
 		ccb->cmd->resid = ccb->cmd->request_bufflen -
 			le32_to_cpu(*(__le32 *)&resp->variable[0]);
-		return;
-	}
-
-	if (resp->srb_status != 0)
-		return;
-
-	/* determine inquiry command status by DeviceTypeQualifier */
-	if (ccb->cmd->cmnd[0] == INQUIRY &&
-		resp->scsi_status == SAM_STAT_GOOD) {
-		ST_INQ *inq_data;
-
-		count = STEX_EXTRA_SIZE;
-		stex_internal_copy(ccb->cmd, hba->copy_buffer,
-			&count, ccb->sg_count, ST_FROM_CMD);
-		inq_data = (ST_INQ *)hba->copy_buffer;
-		if (inq_data->DeviceTypeQualifier != 0)
-			ccb->srb_status = SRB_STATUS_SELECTION_TIMEOUT;
-		else
-			ccb->srb_status = SRB_STATUS_SUCCESS;
-	}
 }
 
 static void stex_mu_intr(struct st_hba *hba, u32 doorbell)
@@ -801,12 +863,12 @@ static void stex_mu_intr(struct st_hba *hba, u32 doorbell)
 	unsigned int size;
 	u16 tag;
 
-	if (!(doorbell & MU_OUTBOUND_DOORBELL_STATUSHEADCHANGED))
+	if (unlikely(!(doorbell & MU_OUTBOUND_DOORBELL_STATUSHEADCHANGED)))
 		return;
 
 	/* status payloads */
 	hba->status_head = readl(base + OMR1);
-	if (unlikely(hba->status_head >= MU_STATUS_COUNT)) {
+	if (unlikely(hba->status_head > hba->sts_count)) {
 		printk(KERN_WARNING DRV_NAME "(%s): invalid status head\n",
 			pci_name(hba->pdev));
 		return;
@@ -836,14 +898,14 @@ static void stex_mu_intr(struct st_hba *hba, u32 doorbell)
 			continue;
 		}
 
+		hba->out_req_cnt--;
 		ccb = &hba->ccb[tag];
-		if (hba->wait_ccb == ccb)
+		if (unlikely(hba->wait_ccb == ccb))
 			hba->wait_ccb = NULL;
 		if (unlikely(ccb->req == NULL)) {
 			printk(KERN_WARNING DRV_NAME
 				"(%s): lagging req\n", pci_name(hba->pdev));
-			stex_free_tag((unsigned long *)&hba->tag, tag);
-			hba->out_req_cnt--;
+			stex_free_tag(hba->tag, tag);
 			continue;
 		}
 
@@ -858,30 +920,22 @@ static void stex_mu_intr(struct st_hba *hba, u32 doorbell)
 				stex_copy_data(ccb, resp, size);
 		}
 
+		ccb->req = NULL;
 		ccb->srb_status = resp->srb_status;
 		ccb->scsi_status = resp->scsi_status;
 
 		if (likely(ccb->cmd != NULL)) {
 			if (hba->cardtype == st_yosemite)
-				stex_ys_commands(hba, ccb, resp);
+				stex_check_cmd(hba, ccb, resp);
 
 			if (unlikely(ccb->cmd->cmnd[0] == PASSTHRU_CMD &&
 				ccb->cmd->cmnd[1] == PASSTHRU_GET_ADAPTER))
 				stex_controller_info(hba, ccb);
-			stex_free_tag((unsigned long *)&hba->tag, tag);
+			stex_free_tag(hba->tag, tag);
 			stex_unmap_sg(hba, ccb->cmd);
 			stex_scsi_done(ccb);
-			hba->out_req_cnt--;
-		} else if (ccb->req_type & PASSTHRU_REQ_TYPE) {
-			hba->out_req_cnt--;
-			if (ccb->req_type & PASSTHRU_REQ_NO_WAKEUP) {
-				ccb->req_type = 0;
-				continue;
-			}
+		} else
 			ccb->req_type = 0;
-			if (waitqueue_active(&hba->waitq))
-				wake_up(&hba->waitq);
-		}
 	}
 
 update_status:
@@ -914,7 +968,105 @@ static irqreturn_t stex_intr(int irq, void *__hba, struct pt_regs *regs)
 	return IRQ_RETVAL(handled);
 }
 
-static int stex_handshake(struct st_hba *hba)
+static void stex_ss_mu_intr(struct st_hba *hba)
+{
+	struct status_msg *resp;
+	struct st_ccb *ccb;
+	__le32 *scratch;
+	unsigned int size;
+	int count = 0;
+	u32 value;
+	u16 tag;
+
+	if (unlikely(hba->out_req_cnt <= 0 ||
+			hba->mu_status == MU_STATE_RESETTING))
+		return;
+
+	while (count < hba->sts_count) {
+		scratch = hba->scratch + hba->status_tail;
+		value = le32_to_cpu(*scratch);
+		if (unlikely(!(value & SS_STS_NORMAL)))
+			return;
+
+		resp = hba->status_buffer + hba->status_tail;
+		*scratch = 0;
+		++count;
+		++hba->status_tail;
+		hba->status_tail %= hba->sts_count+1;
+
+		tag = (u16)value;
+		if (unlikely(tag >= hba->host->can_queue)) {
+			printk(KERN_WARNING DRV_NAME
+				"(%s): invalid tag\n", pci_name(hba->pdev));
+			continue;
+		}
+
+		hba->out_req_cnt--;
+		ccb = &hba->ccb[tag];
+		if (unlikely(hba->wait_ccb == ccb))
+			hba->wait_ccb = NULL;
+		if (unlikely(ccb->req == NULL)) {
+			printk(KERN_WARNING DRV_NAME
+				"(%s): lagging req\n", pci_name(hba->pdev));
+			stex_free_tag(hba->tag, tag);
+			continue;
+		}
+
+		ccb->req = NULL;
+		if (likely(value & SS_STS_DONE)) { /* normal case */
+			ccb->srb_status = SRB_STATUS_SUCCESS;
+			ccb->scsi_status = SAM_STAT_GOOD;
+		} else {
+			ccb->srb_status = resp->srb_status;
+			ccb->scsi_status = resp->scsi_status;
+			size = resp->payload_sz * sizeof(u32);
+			if (unlikely(size < sizeof(*resp) - STATUS_VAR_LEN ||
+				size > sizeof(*resp))) {
+				printk(KERN_WARNING DRV_NAME
+					"(%s): bad status size\n",
+					pci_name(hba->pdev));
+			} else {
+				size -= sizeof(*resp) - STATUS_VAR_LEN;
+				if (size)
+					stex_copy_data(ccb, resp, size);
+			}
+			if (likely(ccb->cmd != NULL))
+				stex_check_cmd(hba, ccb, resp);
+		}
+
+		if (likely(ccb->cmd != NULL)) {
+			stex_free_tag(hba->tag, tag);
+			stex_unmap_sg(hba, ccb->cmd);
+			stex_scsi_done(ccb);
+		} else
+			ccb->req_type = 0;
+	}
+}
+
+static irqreturn_t stex_ss_intr(int irq, void *__hba, struct pt_regs *regs)
+{
+	struct st_hba *hba = __hba;
+	void __iomem *base = hba->mmio_base;
+	u32 data;
+	unsigned long flags;
+	int handled = 0;
+
+	spin_lock_irqsave(hba->host->host_lock, flags);
+
+	data = readl(base + YI2H_INT);
+	if (data && data != 0xffffffff) {
+		/* clear the interrupt */
+		writel(data, base + YI2H_INT_C);
+		stex_ss_mu_intr(hba);
+		handled = 1;
+	}
+
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+static int stex_common_handshake(struct st_hba *hba)
 {
 	void __iomem *base = hba->mmio_base;
 	struct handshake_frame *h;
@@ -943,26 +1095,27 @@ static int stex_handshake(struct st_hba *hba)
 	data = readl(base + OMR1);
 	if ((data & 0xffff0000) == MU_HANDSHAKE_SIGNATURE_HALF) {
 		data &= 0x0000ffff;
-		if (hba->host->can_queue > data)
+		if (hba->host->can_queue > data) {
 			hba->host->can_queue = data;
+			hba->host->cmd_per_lun = data;
+		}
 	}
 
-	h = (struct handshake_frame *)(hba->dma_mem + MU_REQ_BUFFER_SIZE);
-	h->rb_phy = cpu_to_le32(hba->dma_handle);
-	h->rb_phy_hi = cpu_to_le32((hba->dma_handle >> 16) >> 16);
-	h->req_sz = cpu_to_le16(sizeof(struct req_msg));
-	h->req_cnt = cpu_to_le16(MU_REQ_COUNT);
+	h = (struct handshake_frame *)hba->status_buffer;
+	h->rb_phy = cpu_to_le64(hba->dma_handle);
+	h->req_sz = cpu_to_le16(hba->rq_size);
+	h->req_cnt = cpu_to_le16(hba->rq_count+1);
 	h->status_sz = cpu_to_le16(sizeof(struct status_msg));
-	h->status_cnt = cpu_to_le16(MU_STATUS_COUNT);
+	h->status_cnt = cpu_to_le16(hba->sts_count+1);
 	stex_gettime(&h->hosttime);
 	h->partner_type = HMU_PARTNER_TYPE;
-	if (hba->dma_size > STEX_BUFFER_SIZE) {
-		h->extra_offset = cpu_to_le32(STEX_BUFFER_SIZE);
+	if (hba->extra_offset) {
+		h->extra_offset = cpu_to_le32(hba->extra_offset);
 		h->extra_size = cpu_to_le32(ST_ADDITIONAL_MEM);
 	} else
 		h->extra_offset = h->extra_size = 0;
 
-	status_phys = hba->dma_handle + MU_REQ_BUFFER_SIZE;
+	status_phys = hba->dma_handle + (hba->rq_count+1) * hba->rq_size;
 	writel(status_phys, base + IMR0);
 	readl(base + IMR0);
 	writel((status_phys >> 16) >> 16, base + IMR1);
@@ -994,15 +1147,87 @@ static int stex_handshake(struct st_hba *hba)
 	readl(base + IMR1);
 	writel(0, base + OMR1);
 	readl(base + OMR1); /* flush */
-	hba->mu_status = MU_STATE_STARTED;
 	return 0;
 }
 
+static int stex_ss_handshake(struct st_hba *hba)
+{
+	void __iomem *base = hba->mmio_base;
+	struct st_msg_header *msg_h;
+	struct handshake_frame *h;
+	__le32 *scratch;
+	u32 data;
+	unsigned long before;
+	int ret = 0;
+
+	h = (struct handshake_frame *)(hba->alloc_rq(hba));
+	msg_h = (struct st_msg_header *)h - 1;
+	msg_h->handle = cpu_to_le64(hba->dma_handle);
+	msg_h->flag = SS_HEAD_HANDSHAKE;
+
+	h->rb_phy = cpu_to_le64(hba->dma_handle);
+	h->req_sz = cpu_to_le16(hba->rq_size);
+	h->req_cnt = cpu_to_le16(hba->rq_count+1);
+	h->status_sz = cpu_to_le16(sizeof(struct status_msg));
+	h->status_cnt = cpu_to_le16(hba->sts_count+1);
+	stex_gettime(&h->hosttime);
+	h->partner_type = HMU_PARTNER_TYPE;
+	h->extra_offset = h->extra_size = 0;
+	h->scratch_size = cpu_to_le32((hba->sts_count+1)*sizeof(u32));
+
+	data = readl(base + YINT_EN);
+	data &= ~4;
+	writel(data, base + YINT_EN);
+	writel((hba->dma_handle >> 16) >> 16, base + YH2I_REQ_HI);
+	writel(hba->dma_handle, base + YH2I_REQ);
+
+	scratch = hba->scratch;
+	before = jiffies;
+	while (!(le32_to_cpu(*scratch) & SS_STS_HANDSHAKE)) {
+		if (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {
+			printk(KERN_ERR DRV_NAME
+				"(%s): no signature after handshake frame\n",
+				pci_name(hba->pdev));
+			ret = -1;
+			break;
+		}
+		rmb();
+		msleep(1);
+	}
+
+	*scratch = 0;
+	msg_h->flag = 0;
+	return ret;
+}
+
+static int stex_handshake(struct st_hba *hba)
+{
+	int err, size;
+	unsigned long flags;
+
+	err = (hba->cardtype == st_yel) ?
+		stex_ss_handshake(hba) : stex_common_handshake(hba);
+	if (err == 0) {
+		size = ALIGN(hba->host->can_queue, BITS_PER_LONG)/BITS_PER_LONG;
+		size *= sizeof(unsigned long);
+		spin_lock_irqsave(hba->host->host_lock, flags);
+		hba->req_head = 0;
+		hba->req_tail = 0;
+		hba->status_head = 0;
+		hba->status_tail = 0;
+		hba->out_req_cnt = 0;
+		memset(hba->tag, 0, size);
+		hba->mu_status = MU_STATE_STARTED;
+		spin_unlock_irqrestore(hba->host->host_lock, flags);
+	}
+	return err;
+}
+
 static int stex_abort(struct scsi_cmnd *cmd)
 {
 	struct Scsi_Host *host = cmd->device->host;
 	struct st_hba *hba = (struct st_hba *)host->hostdata;
-	u16 tag = cmd->request->tag;
+	u16 tag;
 	void __iomem *base;
 	u32 data;
 	int result = SUCCESS;
@@ -1014,27 +1239,31 @@ static int stex_abort(struct scsi_cmnd *cmd)
 
 	base = hba->mmio_base;
 	spin_lock_irqsave(host->host_lock, flags);
-	if (tag < host->can_queue && hba->ccb[tag].cmd == cmd)
-		hba->wait_ccb = &hba->ccb[tag];
-	else {
-		for (tag = 0; tag < host->can_queue; tag++)
-			if (hba->ccb[tag].cmd == cmd) {
-				hba->wait_ccb = &hba->ccb[tag];
-				break;
-			}
-		if (tag >= host->can_queue)
-			goto out;
-	}
+	for (tag = 0; tag < host->can_queue; tag++)
+		if (hba->ccb[tag].cmd == cmd) {
+			hba->wait_ccb = &hba->ccb[tag];
+			break;
+		}
+	if (tag >= host->can_queue)
+		goto out;
 
-	data = readl(base + ODBL);
-	if (data == 0 || data == 0xffffffff)
-		goto fail_out;
+	if (hba->cardtype == st_yel) {
+		data = readl(base + YI2H_INT);
+		if (data == 0 || data == 0xffffffff)
+			goto fail_out;
 
-	writel(data, base + ODBL);
-	readl(base + ODBL); /* flush */
+		writel(data, base + YI2H_INT_C);
+		stex_ss_mu_intr(hba);
+	} else {
+		data = readl(base + ODBL);
+		if (data == 0 || data == 0xffffffff)
+			goto fail_out;
 
-	stex_mu_intr(hba, data);
+		writel(data, base + ODBL);
+		readl(base + ODBL); /* flush */
 
+		stex_mu_intr(hba, data);
+	}
 	if (hba->wait_ccb == NULL) {
 		printk(KERN_WARNING DRV_NAME
 			"(%s): lost interrupt\n", pci_name(hba->pdev));
@@ -1093,8 +1322,10 @@ static void stex_hard_reset(struct st_hba *hba)
 static int stex_reset(struct scsi_cmnd *cmd)
 {
 	struct st_hba *hba;
-	unsigned long flags;
-	unsigned long before;
+	void __iomem *base;
+	unsigned long flags, before;
+	int size;
+
 	hba = (struct st_hba *) &cmd->device->host->hostdata[0];
 
 	printk(KERN_INFO DRV_NAME
@@ -1113,13 +1344,6 @@ static int stex_reset(struct scsi_cmnd *cmd)
 				pci_name(hba->pdev));
 			return FAILED;
 		}
-		spin_lock_irqsave(hba->host->host_lock, flags);
-		hba->req_head = 0;
-		hba->req_tail = 0;
-		hba->status_head = 0;
-		hba->status_tail = 0;
-		hba->out_req_cnt = 0;
-		spin_unlock_irqrestore(hba->host->host_lock, flags);
 		return SUCCESS;
 	}
 
@@ -1136,7 +1360,26 @@ static int stex_reset(struct scsi_cmnd *cmd)
 		msleep(1);
 	}
 
+	base = hba->mmio_base;
+	writel(0, base + IMR0);
+	readl(base + IMR0);
+	writel(0, base + OMR0);
+	readl(base + OMR0);
+	writel(0, base + IMR1);
+	readl(base + IMR1);
+	writel(0, base + OMR1);
+	readl(base + OMR1); /* flush */
+	size = ALIGN(hba->host->can_queue, BITS_PER_LONG)/BITS_PER_LONG;
+	size *= sizeof(unsigned long);
+	spin_lock_irqsave(hba->host->host_lock, flags);
+	hba->req_head = 0;
+	hba->req_tail = 0;
+	hba->status_head = 0;
+	hba->status_tail = 0;
+	hba->out_req_cnt = 0;
+	memset(hba->tag, 0, size);
 	hba->mu_status = MU_STATE_STARTED;
+	spin_unlock_irqrestore(hba->host->host_lock, flags);
 	return SUCCESS;
 }
 
@@ -1165,20 +1408,109 @@ static struct scsi_host_template driver_template = {
 	.proc_name			= DRV_NAME,
 	.bios_param			= stex_biosparam,
 	.queuecommand			= stex_queuecommand,
-	.slave_alloc			= stex_slave_alloc,
 	.slave_configure		= stex_slave_config,
-	.slave_destroy			= stex_slave_destroy,
 	.eh_abort_handler		= stex_abort,
 	.eh_host_reset_handler		= stex_reset,
-	.can_queue			= ST_CAN_QUEUE,
 	.this_id			= -1,
-	.sg_tablesize			= ST_MAX_SG,
-	.cmd_per_lun			= ST_CMD_PER_LUN,
+};
+
+static struct pci_device_id stex_pci_tbl[] = {
+	/* st_shasta */
+	{ 0x105a, 0x8350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		st_shasta }, /* SuperTrak EX8350/8300/16350/16300 */
+	{ 0x105a, 0xc350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		st_shasta }, /* SuperTrak EX12350 */
+	{ 0x105a, 0x4302, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		st_shasta }, /* SuperTrak EX4350 */
+	{ 0x105a, 0xe350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		st_shasta }, /* SuperTrak EX24350 */
+
+	/* st_vsc */
+	{ 0x105a, 0x7250, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_vsc },
+
+	/* st_yosemite */
+	{ 0x105a, 0x8650, 0x105a, PCI_ANY_ID, 0, 0, st_yosemite },
+
+	/* st_seq */
+	{ 0x105a, 0x3360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_seq },
+
+	/* st_yel */
+	{ 0x105a, 0x8650, 0x1033, PCI_ANY_ID, 0, 0, st_yel },
+	{ 0x105a, 0x8760, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_yel },
+	{ }	/* terminate list */
+};
+
+static struct st_card_info stex_card_info[] = {
+	/* st_shasta */
+	{
+		.max_id		= 17,
+		.max_lun	= 8,
+		.max_channel	= 0,
+		.rq_count	= 32,
+		.rq_size	= 1048,
+		.sts_count	= 32,
+		.alloc_rq	= stex_alloc_req,
+		.map_sg		= stex_map_sg,
+		.send		= stex_send_cmd,
+	},
+
+	/* st_vsc */
+	{
+		.max_id		= 129,
+		.max_lun	= 1,
+		.max_channel	= 0,
+		.rq_count	= 32,
+		.rq_size	= 1048,
+		.sts_count	= 32,
+		.alloc_rq	= stex_alloc_req,
+		.map_sg		= stex_map_sg,
+		.send		= stex_send_cmd,
+	},
+
+	/* st_yosemite */
+	{
+		.max_id		= 2,
+		.max_lun	= 256,
+		.max_channel	= 0,
+		.rq_count	= 256,
+		.rq_size	= 1048,
+		.sts_count	= 256,
+		.alloc_rq	= stex_alloc_req,
+		.map_sg		= stex_map_sg,
+		.send		= stex_send_cmd,
+	},
+
+	/* st_seq */
+	{
+		.max_id		= 129,
+		.max_lun	= 1,
+		.max_channel	= 0,
+		.rq_count	= 32,
+		.rq_size	= 1048,
+		.sts_count	= 32,
+		.alloc_rq	= stex_alloc_req,
+		.map_sg		= stex_map_sg,
+		.send		= stex_send_cmd,
+	},
+
+	/* st_yel */
+	{
+		.max_id		= 129,
+		.max_lun	= 256,
+		.max_channel	= 3,
+		.rq_count	= 801,
+		.rq_size	= 512,
+		.sts_count	= 801,
+		.alloc_rq	= stex_ss_alloc_req,
+		.map_sg		= stex_ss_map_sg,
+		.send		= stex_ss_send_cmd,
+	},
 };
 
 static int stex_set_dma_mask(struct pci_dev * pdev)
 {
 	int ret;
+
 	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK)
 		&& !pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK))
 		return 0;
@@ -1188,11 +1520,48 @@ static int stex_set_dma_mask(struct pci_dev * pdev)
 	return ret;
 }
 
+static int stex_request_irq(struct st_hba *hba)
+{
+	struct pci_dev *pdev = hba->pdev;
+	int status;
+
+	if (msi) {
+		status = pci_enable_msi(pdev);
+		if (status != 0)
+			printk(KERN_ERR DRV_NAME
+				"(%s): error %d setting up MSI\n",
+				pci_name(pdev), status);
+		else
+			hba->msi_enabled = 1;
+	} else
+		hba->msi_enabled = 0;
+
+	status = request_irq(pdev->irq, hba->cardtype == st_yel ?
+		stex_ss_intr : stex_intr, IRQF_SHARED, DRV_NAME, hba);
+
+	if (status != 0) {
+		if (hba->msi_enabled)
+			pci_disable_msi(pdev);
+	}
+	return status;
+}
+
+static void stex_free_irq(struct st_hba *hba)
+{
+	struct pci_dev *pdev = hba->pdev;
+
+	free_irq(pdev->irq, hba);
+	if (hba->msi_enabled)
+		pci_disable_msi(pdev);
+}
+
 static int __devinit
 stex_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct st_hba *hba;
 	struct Scsi_Host *host;
+	const struct st_card_info *ci = NULL;
+	u32 sts_offset, cp_offset, scratch_offset, tag_offset;
 	int err;
 
 	err = pci_enable_device(pdev);
@@ -1237,10 +1606,19 @@ stex_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	hba->cardtype = (unsigned int) id->driver_data;
-	if (hba->cardtype == st_vsc && (pdev->subsystem_device & 0xf) == 0x1)
-		hba->cardtype = st_vsc1;
-	hba->dma_size = (hba->cardtype == st_vsc1) ?
-		(STEX_BUFFER_SIZE + ST_ADDITIONAL_MEM) : (STEX_BUFFER_SIZE);
+	ci = &stex_card_info[hba->cardtype];
+	sts_offset = scratch_offset = (ci->rq_count+1) * ci->rq_size;
+	if (hba->cardtype == st_yel)
+		sts_offset += (ci->sts_count+1) * sizeof(u32);
+	cp_offset = sts_offset + (ci->sts_count+1) * sizeof(struct status_msg);
+	tag_offset = cp_offset + sizeof(struct st_frame);
+	tag_offset = ALIGN(tag_offset, 8);
+	hba->dma_size = tag_offset + ALIGN(ci->rq_count, 64)/8;
+	if (hba->cardtype == st_seq ||
+		(hba->cardtype == st_vsc && (pdev->subsystem_device & 1))) {
+		hba->extra_offset = hba->dma_size;
+		hba->dma_size += ST_ADDITIONAL_MEM;
+	}
 	hba->dma_mem = dma_alloc_coherent(&pdev->dev,
 		hba->dma_size, &hba->dma_handle, GFP_KERNEL);
 	if (!hba->dma_mem) {
@@ -1250,35 +1628,47 @@ stex_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto out_iounmap;
 	}
 
-	hba->status_buffer =
-		(struct status_msg *)(hba->dma_mem + MU_REQ_BUFFER_SIZE);
-	hba->copy_buffer = hba->dma_mem + MU_BUFFER_SIZE;
+	hba->ccb = kcalloc(ci->rq_count, sizeof(struct st_ccb), GFP_KERNEL);
+	if (!hba->ccb) {
+		err = -ENOMEM;
+		printk(KERN_ERR DRV_NAME "(%s): ccb alloc failed\n",
+			pci_name(pdev));
+		goto out_pci_free;
+	}
+
+	if (hba->cardtype == st_yel)
+		hba->scratch = (__le32 *)(hba->dma_mem + scratch_offset);
+	hba->status_buffer = (struct status_msg *)(hba->dma_mem + sts_offset);
+	hba->copy_buffer = hba->dma_mem + cp_offset;
+	hba->tag = (unsigned long *)(hba->dma_mem + tag_offset);
+	hba->rq_count = ci->rq_count;
+	hba->rq_size = ci->rq_size;
+	hba->sts_count = ci->sts_count;
+	hba->alloc_rq = ci->alloc_rq;
+	hba->map_sg = ci->map_sg;
+	hba->send = ci->send;
 	hba->mu_status = MU_STATE_STARTING;
 
-	if (hba->cardtype == st_shasta) {
-		host->max_lun = 8;
-		host->max_id = 16 + 1;
-	} else if (hba->cardtype == st_yosemite) {
-		host->max_lun = 128;
-		host->max_id = 1 + 1;
-	} else {
-		/* st_vsc and st_vsc1 */
-		host->max_lun = 1;
-		host->max_id = 128 + 1;
-	}
-	host->max_channel = 0;
+	if (hba->cardtype == st_yel)
+		host->sg_tablesize = 38;
+	else
+		host->sg_tablesize = 32;
+	host->can_queue = ci->rq_count;
+	host->cmd_per_lun = ci->rq_count;
+	host->max_id = ci->max_id;
+	host->max_lun = ci->max_lun;
+	host->max_channel = ci->max_channel;
 	host->unique_id = host->host_no;
 	host->max_cmd_len = STEX_CDB_LENGTH;
 
 	hba->host = host;
 	hba->pdev = pdev;
-	init_waitqueue_head(&hba->waitq);
 
-	err = request_irq(pdev->irq, stex_intr, IRQF_SHARED, DRV_NAME, hba);
+	err = stex_request_irq(hba);
 	if (err) {
 		printk(KERN_ERR DRV_NAME "(%s): request irq failed\n",
 			pci_name(pdev));
-		goto out_pci_free;
+		goto out_ccb_free;
 	}
 
 	err = stex_handshake(hba);
@@ -1299,7 +1689,9 @@ stex_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	return 0;
 
 out_free_irq:
-	free_irq(pdev->irq, hba);
+	stex_free_irq(hba);
+out_ccb_free:
+	kfree(hba->ccb);
 out_pci_free:
 	dma_free_coherent(&pdev->dev, hba->dma_size,
 			  hba->dma_mem, hba->dma_handle);
@@ -1318,22 +1710,27 @@ out_disable:
 static void stex_hba_stop(struct st_hba *hba)
 {
 	struct req_msg *req;
+	struct st_msg_header *msg_h;
 	unsigned long flags;
 	unsigned long before;
 	u16 tag;
 
 	spin_lock_irqsave(hba->host->host_lock, flags);
-	if ((tag = stex_alloc_tag((unsigned long *)&hba->tag))
-		>= hba->host->can_queue) {
+	tag = stex_alloc_tag(hba->tag, hba->host->can_queue);
+	if (tag >= hba->host->can_queue) {
 		spin_unlock_irqrestore(hba->host->host_lock, flags);
 		printk(KERN_ERR DRV_NAME "(%s): unable to alloc tag\n",
 			pci_name(hba->pdev));
 		return;
 	}
-	req = stex_alloc_req(hba);
-	memset(req->cdb, 0, STEX_CDB_LENGTH);
+	req = hba->alloc_rq(hba);
+	if (hba->cardtype == st_yel) {
+		msg_h = (struct st_msg_header *)req - 1;
+		memset(msg_h, 0, hba->rq_size);
+	} else
+		memset(req, 0, hba->rq_size);
 
-	if (hba->cardtype == st_yosemite) {
+	if (hba->cardtype == st_yosemite || hba->cardtype == st_yel) {
 		req->cdb[0] = MGT_CMD;
 		req->cdb[1] = MGT_CMD_SIGNATURE;
 		req->cdb[2] = CTLR_CONFIG_CMD;
@@ -1348,31 +1745,35 @@ static void stex_hba_stop(struct st_hba *hba)
 	hba->ccb[tag].sg_count = 0;
 	hba->ccb[tag].sense_bufflen = 0;
 	hba->ccb[tag].sense_buffer = NULL;
-	hba->ccb[tag].req_type |= PASSTHRU_REQ_TYPE;
+	hba->ccb[tag].req_type = PASSTHRU_REQ_TYPE;
 
-	stex_send_cmd(hba, req, tag);
+	hba->send(hba, req, tag);
 	spin_unlock_irqrestore(hba->host->host_lock, flags);
 
 	before = jiffies;
 	while (hba->ccb[tag].req_type & PASSTHRU_REQ_TYPE) {
-		if (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ))
+		if (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ)) {
+			hba->ccb[tag].req_type = 0;
 			return;
-		msleep(10);
+		}
+		msleep(1);
 	}
 
 	spin_lock_irqsave(hba->host->host_lock, flags);
-	stex_free_tag((unsigned long *)&hba->tag, tag);
+	stex_free_tag(hba->tag, tag);
 	spin_unlock_irqrestore(hba->host->host_lock, flags);
 }
 
 static void stex_hba_free(struct st_hba *hba)
 {
-	free_irq(hba->pdev->irq, hba);
+	stex_free_irq(hba);
 
 	iounmap(hba->mmio_base);
 
 	pci_release_regions(hba->pdev);
 
+	kfree(hba->ccb);
+
 	dma_free_coherent(&hba->pdev->dev, hba->dma_size,
 			  hba->dma_mem, hba->dma_handle);
 }
@@ -1401,35 +1802,6 @@ static void stex_shutdown(struct pci_dev *pdev)
 	stex_hba_stop(hba);
 }
 
-static struct pci_device_id stex_pci_tbl[] = {
-	/* st_shasta */
-	{ 0x105a, 0x8350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		st_shasta }, /* SuperTrak EX8350/8300/16350/16300 */
-	{ 0x105a, 0xc350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		st_shasta }, /* SuperTrak EX12350 */
-	{ 0x105a, 0x4302, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		st_shasta }, /* SuperTrak EX4350 */
-	{ 0x105a, 0xe350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		st_shasta }, /* SuperTrak EX24350 */
-
-	/* st_vsc */
-	{ 0x105a, 0x7250, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_vsc },
-
-	/* st_yosemite */
-	{ 0x105a, 0x8650, PCI_ANY_ID, 0x4600, 0, 0,
-		st_yosemite }, /* SuperTrak EX4650 */
-	{ 0x105a, 0x8650, PCI_ANY_ID, 0x4610, 0, 0,
-		st_yosemite }, /* SuperTrak EX4650o */
-	{ 0x105a, 0x8650, PCI_ANY_ID, 0x8600, 0, 0,
-		st_yosemite }, /* SuperTrak EX8650EL */
-	{ 0x105a, 0x8650, PCI_ANY_ID, 0x8601, 0, 0,
-		st_yosemite }, /* SuperTrak EX8650 */
-	{ 0x105a, 0x8650, PCI_ANY_ID, 0x8602, 0, 0,
-		st_yosemite }, /* SuperTrak EX8654 */
-	{ 0x105a, 0x8650, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		st_yosemite }, /* generic st_yosemite */
-	{ }	/* terminate list */
-};
 MODULE_DEVICE_TABLE(pci, stex_pci_tbl);
 
 static struct pci_driver stex_pci_driver = {
