From: Paolo Bonzini <pbonzini@redhat.com>
Date: Fri, 6 Aug 2010 15:10:34 -0400
Subject: [virt] xen: don't give up ballooning under mem pressure
Message-id: <1281107435-18569-1-git-send-email-pbonzini@redhat.com>
Patchwork-id: 27453
O-Subject: [RHEL5.5 PATCH 1/2] xen: do not give up when ballooning under memory
	pressure
Bugzilla: 507846
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=507846

Upstream status: http://xenbits.xensource.com/linux-2.6.18-xen.hg?rev/897

Brew build: https://brewweb.devel.redhat.com/taskinfo?taskID=2657991

The balloon driver for RHEL5 will give up too easily on ballooning if
it encounters memory pressure. When this occurs ballooning will stop
until the target is reset, regardless of how much memory subsequently
becomes available.  This is the so called "hard limit"---but there's
nothing in the hypervisor that supports such a draconian strategy.

This patch changes the algorithm to what is used upstream and in RHEL6.
Similar to what is done when ballooning down, if the memory cannot be
obtained from the hypervisor increase_reservation will return 1 so
that the guest will try again in one second.

This patch leaves around some dead code for easier reviewability.  This
is fixed in the next one.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/drivers/xen/balloon/balloon.c b/drivers/xen/balloon/balloon.c
index e8ce44f..720009a 100644
--- a/drivers/xen/balloon/balloon.c
+++ b/drivers/xen/balloon/balloon.c
@@ -196,7 +196,7 @@ static void balloon_alarm(unsigned long unused)
 
 static unsigned long current_target(void)
 {
-	unsigned long target = min(target_pages, hard_limit);
+	unsigned long target = target_pages;
 	if (target > (current_pages + balloon_low + balloon_high))
 		target = current_pages + balloon_low + balloon_high;
 	return target;
@@ -230,21 +230,13 @@ static int increase_reservation(unsigned long nr_pages)
 	rc = HYPERVISOR_memory_op(
 		XENMEM_populate_physmap, &reservation);
 	if (rc < nr_pages) {
-		if (rc > 0) {
-			int ret;
-
-			/* We hit the Xen hard limit: reprobe. */
-			reservation.nr_extents = rc;
-			ret = HYPERVISOR_memory_op(XENMEM_decrease_reservation,
-					&reservation);
-			BUG_ON(ret != rc);
-		}
 		if (rc >= 0)
 			hard_limit = current_pages + rc - driver_pages;
-		goto out;
+		else
+			goto out;
 	}
 
-	for (i = 0; i < nr_pages; i++) {
+	for (i = 0; i < rc; i++) {
 		page = balloon_retrieve();
 		BUG_ON(page == NULL);
 
@@ -274,13 +266,13 @@ static int increase_reservation(unsigned long nr_pages)
 		__free_page(page);
 	}
 
-	current_pages += nr_pages;
+	current_pages += rc;
 	totalram_pages = current_pages;
 
  out:
 	balloon_unlock(flags);
 
-	return 0;
+	return rc < 0 ? rc : rc != nr_pages;
 }
 
 static int decrease_reservation(unsigned long nr_pages)
