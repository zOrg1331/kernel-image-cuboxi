From: AMEET M. PARANJAPE <aparanja@redhat.com>
Date: Wed, 12 Nov 2008 10:17:29 -0600
Subject: [ppc64] spufs: clean up page fault error checking
Message-id: 491B0199.8010303@REDHAT.COM
O-Subject: Re: [PATCH RHEL5.3 BZ470301] Fix page fault error checking in Cell spufs
Bugzilla: 470301
RH-Acked-by: Tomas Henzl <thenzl@redhat.com>

Upstream Status:
============

GIT Commit ID: 2e3b2ad84d70dc7b6ee9e6ff43f3fc0c391164d8

Description:
=========
At present, we keep a 'ret' variable for error conditions in
spu_handle_mm_fault, but never use this value in the error path.

This change makes spu_handle_mm_fault return the value of the ret
variable, allowing us to consolidate the output path of this
function.

Test status:
========
With this new patch the testcase (given in the BZ) still passes.  The
brewbuild
for this patch is https://brewweb.devel.redhat.com/taskinfo?taskID=1567107.

--
Ameet M. Paranjape
aparanja@redhat.com
IBM/Red Hat POWER Liason
IRC name: aparanja

diff --git a/arch/powerpc/platforms/cell/spu_fault.c b/arch/powerpc/platforms/cell/spu_fault.c
index 54ee12c..9b718eb 100644
--- a/arch/powerpc/platforms/cell/spu_fault.c
+++ b/arch/powerpc/platforms/cell/spu_fault.c
@@ -52,37 +52,39 @@ int spu_handle_mm_fault(struct mm_struct *mm, unsigned long ea,
 	}
 
 	down_read(&mm->mmap_sem);
+	ret = -EFAULT;
 	vma = find_vma(mm, ea);
 	if (!vma)
-		goto bad_area;
-	if (vma->vm_start <= ea)
-		goto good_area;
-	if (!(vma->vm_flags & VM_GROWSDOWN))
-		goto bad_area;
-	if (expand_stack(vma, ea))
-		goto bad_area;
-good_area:
+		goto out_unlock;
+
+	if (ea < vma->vm_start) {
+		if (!(vma->vm_flags & VM_GROWSDOWN))
+			goto out_unlock;
+		if (expand_stack(vma, ea))
+			goto out_unlock;
+	}
+
 	is_write = dsisr & MFC_DSISR_ACCESS_PUT;
 	if (is_write) {
 		if (!(vma->vm_flags & VM_WRITE))
-			goto bad_area;
+			goto out_unlock;
 	} else {
 		if (dsisr & MFC_DSISR_ACCESS_DENIED)
-			goto bad_area;
+			goto out_unlock;
 		if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
-			goto bad_area;
+			goto out_unlock;
 	}
 	ret = 0;
 	*flt = handle_mm_fault(mm, vma, ea, is_write);
 
 	if (unlikely(*flt == VM_FAULT_OOM)) {
 		ret = -ENOMEM;
-		goto bad_area;
+		goto out_unlock;
 	}
 
 	if (unlikely(*flt == VM_FAULT_SIGBUS)) {
 		ret = -EFAULT;
-		goto bad_area;
+		goto out_unlock;
 	}
 
 	if (*flt == VM_FAULT_MAJOR)
@@ -90,11 +92,8 @@ good_area:
 	else
 		current->min_flt++;
 
+out_unlock:
 	up_read(&mm->mmap_sem);
 	return ret;
-
-bad_area:
-	up_read(&mm->mmap_sem);
-	return -EFAULT;
 }
 EXPORT_SYMBOL_GPL(spu_handle_mm_fault);
