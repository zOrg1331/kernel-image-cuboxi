From: Dave Anderson <anderson@redhat.com>
Date: Tue, 7 Dec 2010 19:23:48 -0500
Subject: [misc] kernel: fix address limit override in OOPS path
Message-id: <1268365354.240911291749828681.JavaMail.root@zmail05.collab.prod.int.phx2.redhat.com>
Patchwork-id: 4524
O-Subject: [kernel team] [RHEL5.6 PATCH] CVE-2010-4258: failure to revert
 address limit override in OOPS error path
Bugzilla: 659571
CVE: CVE-2010-4258
RH-Acked-by: Bob Picco <bpicco@redhat.com>
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>

BZ #659571 - CVE-2010-4258 kernel: failure to revert address limit override
             in OOPS error path [rhel-5.6]
https://bugzilla.redhat.com/show_bug.cgi?id=659571

Backport of upstream commit 33dd94ae1ccbfb7bf0fb6c692bc3d1c4269e6177,
where the issue would apply if a customer changes the default setting
of /proc/sys/kernel/panic_on_oops from 1 to 0:

  commit 33dd94ae1ccbfb7bf0fb6c692bc3d1c4269e6177
  Author: Nelson Elhage <nelhage@ksplice.com>
  Date:   Thu Dec 2 14:31:21 2010 -0800

    do_exit(): make sure that we run with get_fs() == USER_DS

    If a user manages to trigger an oops with fs set to KERNEL_DS, fs is not
    otherwise reset before do_exit().  do_exit may later (via mm_release in
    fork.c) do a put_user to a user-controlled address, potentially allowing
    a user to leverage an oops into a controlled write into kernel memory.

    This is only triggerable in the presence of another bug, but this
    potentially turns a lot of DoS bugs into privilege escalations, so it's
    worth fixing.  I have proof-of-concept code which uses this bug along
    with CVE-2010-3849 to write a zero to an arbitrary kernel address, so
    I've tested that this is not theoretical.

    A more logical place to put this fix might be when we know an oops has
    occurred, before we call do_exit(), but that would involve changing
    every architecture, in multiple places.

    Let's just stick it in do_exit instead.

    [akpm@linux-foundation.org: update code comment]
    Signed-off-by: Nelson Elhage <nelhage@ksplice.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Brew build: http://brewweb.devel.redhat.com/brew/taskinfo?taskID=2948209

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/kernel/exit.c b/kernel/exit.c
index b45d02a..49908fb 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -844,6 +844,15 @@ fastcall NORET_TYPE void do_exit(long code)
 	if (unlikely(tsk == child_reaper))
 		panic("Attempted to kill init!");
 
+	/*
+	 * If do_exit is called because this processes oopsed, it's possible
+	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
+	 * continuing. Amongst other possible reasons, this is to prevent
+	 * mm_release()->clear_child_tid() from writing to a user-controlled
+	 * kernel address.
+	 */
+	set_fs(USER_DS);
+
 	tracehook_report_exit(&code);
 
 	/*
