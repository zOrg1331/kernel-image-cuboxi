From: Doug Chapman <dchapman@redhat.com>
Date: Fri, 2 Nov 2007 12:22:51 -0400
Subject: [ia64] add driver for ACPI methods to call native fw
Message-id: 1194020571.25889.11.camel@dchapman.boston.redhat.com
O-Subject: [RHEL5.2 PATCH 1/2] add driver for ACPI methods to call native firmware
Bugzilla: 262281

patch 1/2 for BZ 262281

    [IA64] abstract SAL_CALL wrapper to allow other firmware entry points

    SAL_CALL() always calls through the ia64_sal function pointer.  I am adding
    new functionality that needs the same conventions as SAL_CALL (FP regs
    saved/restored, sal_lock acquired, etc), but doesn't use the ia64_sal
    function pointer.

    This patch pulls the body of SAL_CALL out into a new "IA64_FW_CALL" that
    takes care of these calling conventions, but allows the caller to specify
    either ia64_sal or some other firmware entry point.

-----------------------------------------------
---
 include/asm-ia64/sal.h |   15 +++++++++------
 1 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/include/asm-ia64/sal.h b/include/asm-ia64/sal.h
index f9cf65d..0c47c75 100644
--- a/include/asm-ia64/sal.h
+++ b/include/asm-ia64/sal.h
@@ -49,25 +49,28 @@
 extern spinlock_t sal_lock;
 
 /* SAL spec _requires_ eight args for each call. */
-#define __SAL_CALL(result,a0,a1,a2,a3,a4,a5,a6,a7)	\
-	result = (*ia64_sal)(a0,a1,a2,a3,a4,a5,a6,a7)
+#define __IA64_FW_CALL(entry,result,a0,a1,a2,a3,a4,a5,a6,a7)	\
+	result = (*entry)(a0,a1,a2,a3,a4,a5,a6,a7)
 
-# define SAL_CALL(result,args...) do {				\
+# define IA64_FW_CALL(entry,result,args...) do {		\
 	unsigned long __ia64_sc_flags;				\
 	struct ia64_fpreg __ia64_sc_fr[6];			\
 	ia64_save_scratch_fpregs(__ia64_sc_fr);			\
 	spin_lock_irqsave(&sal_lock, __ia64_sc_flags);		\
-	__SAL_CALL(result, args);				\
+	__IA64_FW_CALL(entry, result, args);			\
 	spin_unlock_irqrestore(&sal_lock, __ia64_sc_flags);	\
 	ia64_load_scratch_fpregs(__ia64_sc_fr);			\
 } while (0)
 
+# define SAL_CALL(result,args...)			\
+	IA64_FW_CALL(ia64_sal, result, args);
+
 # define SAL_CALL_NOLOCK(result,args...) do {		\
 	unsigned long __ia64_scn_flags;			\
 	struct ia64_fpreg __ia64_scn_fr[6];		\
 	ia64_save_scratch_fpregs(__ia64_scn_fr);	\
 	local_irq_save(__ia64_scn_flags);		\
-	__SAL_CALL(result, args);			\
+	__IA64_FW_CALL(ia64_sal, result, args);		\
 	local_irq_restore(__ia64_scn_flags);		\
 	ia64_load_scratch_fpregs(__ia64_scn_fr);	\
 } while (0)
@@ -76,7 +79,7 @@ extern spinlock_t sal_lock;
 	struct ia64_fpreg __ia64_scs_fr[6];		\
 	ia64_save_scratch_fpregs(__ia64_scs_fr);	\
 	preempt_disable();				\
-	__SAL_CALL(result, args);			\
+	__IA64_FW_CALL(ia64_sal, result, args);		\
 	preempt_enable();				\
 	ia64_load_scratch_fpregs(__ia64_scs_fr);	\
 } while (0)
-- 
1.5.3.5.645.gbb47

