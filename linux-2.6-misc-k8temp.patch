From: Florian La Roche <laroche@redhat.com>
Subject: [RHEL5.1] k8temp
Date: Thu, 8 Feb 2007 14:45:46 +0100
Bugzilla: 236205
Message-Id: <20070208134546.GA15868@dudweiler.stuttgart.redhat.com>
Changelog: [misc] k8temp


Hello all,

the following patches add a new kernel module k8temp to
the RHEL5 kernel that allows lm_sensors to see the CPU
temperature on AMD K8 CPUs. Patch directly and unchanged
from the upstream kernel sources.
CONFIG_SENSORS_K8TEMP=m should also be added to the
configuration files.

regards,

Florian La Roche




X-Git-Tag: v2.6.19^0~1801^2~25
X-Git-Url: http://www.jur-linux.org/git/?p=linux-2.6.git;a=commitdiff_plain;h=29fa06c1292f473ae51a84f55c8fe22179bc1080

hwmon: New driver k8temp

Add support for the temperature sensor(s) found in AMD K8 CPUs.

Signed-off-by: Rudolf Marek <r.marek@sh.cvut.cz>
Signed-off-by: Jean Delvare <khali@linux-fr.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 78c237f..d9f86e9 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -94,6 +94,16 @@ config SENSORS_ADM9240
 	  This driver can also be built as a module.  If so, the module
 	  will be called adm9240.
 
+config SENSORS_K8TEMP
+	tristate "AMD K8 processor sensor"
+	depends on HWMON && X86 && PCI && EXPERIMENTAL
+	help
+	  If you say yes here you get support for the temperature
+	  sensor(s) inside your AMD K8 CPU.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called k8temp.
+
 config SENSORS_ASB100
 	tristate "Asus ASB100 Bach"
 	depends on HWMON && I2C && EXPERIMENTAL
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 3141584..aab4c10 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_SENSORS_GL518SM)	+= gl518sm.o
 obj-$(CONFIG_SENSORS_GL520SM)	+= gl520sm.o
 obj-$(CONFIG_SENSORS_HDAPS)	+= hdaps.o
 obj-$(CONFIG_SENSORS_IT87)	+= it87.o
+obj-$(CONFIG_SENSORS_K8TEMP)	+= k8temp.o
 obj-$(CONFIG_SENSORS_LM63)	+= lm63.o
 obj-$(CONFIG_SENSORS_LM70)	+= lm70.o
 obj-$(CONFIG_SENSORS_LM75)	+= lm75.o
diff --git a/drivers/hwmon/k8temp.c b/drivers/hwmon/k8temp.c
new file mode 100644
index 0000000..50162ff
--- /dev/null
+++ b/drivers/hwmon/k8temp.c
@@ -0,0 +1,292 @@
+/*
+ * k8temp.c - Linux kernel module for hardware monitoring
+ *
+ * Copyright (C) 2006 Rudolf Marek <r.marek@sh.cvut.cz>
+ *
+ * Inspired from the w83785 and amd756 drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/pci.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+
+#define TEMP_FROM_REG(val)	(((((val) >> 16) & 0xff) - 49) * 1000)
+#define REG_TEMP	0xe4
+#define SEL_PLACE	0x40
+#define SEL_CORE	0x04
+
+struct k8temp_data {
+	struct class_device *class_dev;
+	struct mutex update_lock;
+	const char *name;
+	char valid;		/* zero until following fields are valid */
+	unsigned long last_updated;	/* in jiffies */
+
+	/* registers values */
+	u8 sensorsp;		/* sensor presence bits - SEL_CORE & SEL_PLACE */
+	u32 temp[2][2];		/* core, place */
+};
+
+static struct k8temp_data *k8temp_update_device(struct device *dev)
+{
+	struct k8temp_data *data = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	u8 tmp;
+
+	mutex_lock(&data->update_lock);
+
+	if (!data->valid
+	    || time_after(jiffies, data->last_updated + HZ)) {
+		pci_read_config_byte(pdev, REG_TEMP, &tmp);
+		tmp &= ~(SEL_PLACE | SEL_CORE);		/* Select sensor 0, core0 */
+		pci_write_config_byte(pdev, REG_TEMP, tmp);
+		pci_read_config_dword(pdev, REG_TEMP, &data->temp[0][0]);
+
+		if (data->sensorsp & SEL_PLACE) {
+			tmp |= SEL_PLACE;	/* Select sensor 1, core0 */
+			pci_write_config_byte(pdev, REG_TEMP, tmp);
+			pci_read_config_dword(pdev, REG_TEMP,
+					      &data->temp[0][1]);
+		}
+
+		if (data->sensorsp & SEL_CORE) {
+			tmp &= ~SEL_PLACE;	/* Select sensor 0, core1 */
+			tmp |= SEL_CORE;
+			pci_write_config_byte(pdev, REG_TEMP, tmp);
+			pci_read_config_dword(pdev, REG_TEMP,
+					      &data->temp[1][0]);
+
+			if (data->sensorsp & SEL_PLACE) {
+				tmp |= SEL_PLACE;	/* Select sensor 1, core1 */
+				pci_write_config_byte(pdev, REG_TEMP, tmp);
+				pci_read_config_dword(pdev, REG_TEMP,
+						      &data->temp[1][1]);
+			}
+		}
+
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+/*
+ * Sysfs stuff
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			 *devattr, char *buf)
+{
+	struct k8temp_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%s\n", data->name);
+}
+
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf)
+{
+	struct sensor_device_attribute_2 *attr =
+	    to_sensor_dev_attr_2(devattr);
+	int core = attr->nr;
+	int place = attr->index;
+	struct k8temp_data *data = k8temp_update_device(dev);
+
+	return sprintf(buf, "%d\n",
+		       TEMP_FROM_REG(data->temp[core][place]));
+}
+
+/* core, place */
+
+static SENSOR_DEVICE_ATTR_2(temp1_input, S_IRUGO, show_temp, NULL, 0, 0);
+static SENSOR_DEVICE_ATTR_2(temp2_input, S_IRUGO, show_temp, NULL, 0, 1);
+static SENSOR_DEVICE_ATTR_2(temp3_input, S_IRUGO, show_temp, NULL, 1, 0);
+static SENSOR_DEVICE_ATTR_2(temp4_input, S_IRUGO, show_temp, NULL, 1, 1);
+static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);
+
+static struct pci_device_id k8temp_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },
+	{ 0 },
+};
+
+static int __devinit k8temp_probe(struct pci_dev *pdev,
+				  const struct pci_device_id *id)
+{
+	int err;
+	u8 scfg;
+	u32 temp;
+	struct k8temp_data *data;
+	u32 cpuid = cpuid_eax(1);
+
+	/* this feature should be available since SH-C0 core */
+	if ((cpuid == 0xf40) || (cpuid == 0xf50) || (cpuid == 0xf51)) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	if (!(data = kzalloc(sizeof(struct k8temp_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	pci_read_config_byte(pdev, REG_TEMP, &scfg);
+	scfg &= ~(SEL_PLACE | SEL_CORE);		/* Select sensor 0, core0 */
+	pci_write_config_byte(pdev, REG_TEMP, scfg);
+	pci_read_config_byte(pdev, REG_TEMP, &scfg);
+
+	if (scfg & (SEL_PLACE | SEL_CORE)) {
+		dev_err(&pdev->dev, "Configuration bit(s) stuck at 1!\n");
+		err = -ENODEV;
+		goto exit_free;
+	}
+
+	scfg |= (SEL_PLACE | SEL_CORE);
+	pci_write_config_byte(pdev, REG_TEMP, scfg);
+
+	/* now we know if we can change core and/or sensor */
+	pci_read_config_byte(pdev, REG_TEMP, &data->sensorsp);
+
+	if (data->sensorsp & SEL_PLACE) {
+		scfg &= ~SEL_CORE;	/* Select sensor 1, core0 */
+		pci_write_config_byte(pdev, REG_TEMP, scfg);
+		pci_read_config_dword(pdev, REG_TEMP, &temp);
+		scfg |= SEL_CORE;	/* prepare for next selection */
+		if (!((temp >> 16) & 0xff))	/* if temp is 0 -49C is not likely */
+			data->sensorsp &= ~SEL_PLACE;
+	}
+
+	if (data->sensorsp & SEL_CORE) {
+		scfg &= ~SEL_PLACE;	/* Select sensor 0, core1 */
+		pci_write_config_byte(pdev, REG_TEMP, scfg);
+		pci_read_config_dword(pdev, REG_TEMP, &temp);
+		if (!((temp >> 16) & 0xff))	/* if temp is 0 -49C is not likely */
+			data->sensorsp &= ~SEL_CORE;
+	}
+
+	data->name = "k8temp";
+	mutex_init(&data->update_lock);
+	dev_set_drvdata(&pdev->dev, data);
+
+	/* Register sysfs hooks */
+	err = device_create_file(&pdev->dev,
+			   &sensor_dev_attr_temp1_input.dev_attr);
+	if (err)
+		goto exit_remove;
+
+	/* sensor can be changed and reports something */
+	if (data->sensorsp & SEL_PLACE) {
+		err = device_create_file(&pdev->dev,
+				   &sensor_dev_attr_temp2_input.dev_attr);
+		if (err)
+			goto exit_remove;
+	}
+
+	/* core can be changed and reports something */
+	if (data->sensorsp & SEL_CORE) {
+		err = device_create_file(&pdev->dev,
+				   &sensor_dev_attr_temp3_input.dev_attr);
+		if (err)
+			goto exit_remove;
+		if (data->sensorsp & SEL_PLACE)
+			err = device_create_file(&pdev->dev,
+					   &sensor_dev_attr_temp4_input.
+					   dev_attr);
+			if (err)
+				goto exit_remove;
+	}
+
+	err = device_create_file(&pdev->dev, &dev_attr_name);
+	if (err)
+		goto exit_remove;
+
+	data->class_dev = hwmon_device_register(&pdev->dev);
+
+	if (IS_ERR(data->class_dev)) {
+		err = PTR_ERR(data->class_dev);
+		goto exit_remove;
+	}
+
+	return 0;
+
+exit_remove:
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp1_input.dev_attr);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp2_input.dev_attr);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp3_input.dev_attr);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp4_input.dev_attr);
+	device_remove_file(&pdev->dev, &dev_attr_name);
+exit_free:
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(data);
+exit:
+	return err;
+}
+
+static void __devexit k8temp_remove(struct pci_dev *pdev)
+{
+	struct k8temp_data *data = dev_get_drvdata(&pdev->dev);
+
+	hwmon_device_unregister(data->class_dev);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp1_input.dev_attr);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp2_input.dev_attr);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp3_input.dev_attr);
+	device_remove_file(&pdev->dev,
+			   &sensor_dev_attr_temp4_input.dev_attr);
+	device_remove_file(&pdev->dev, &dev_attr_name);
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(data);
+}
+
+static struct pci_driver k8temp_driver = {
+	.name = "k8temp",
+	.id_table = k8temp_ids,
+	.probe = k8temp_probe,
+	.remove = __devexit_p(k8temp_remove),
+};
+
+static int __init k8temp_init(void)
+{
+	return pci_register_driver(&k8temp_driver);
+}
+
+static void __exit k8temp_exit(void)
+{
+	pci_unregister_driver(&k8temp_driver);
+}
+
+MODULE_AUTHOR("Rudolf Marek <r.marek@sh.cvut.cz>");
+MODULE_DESCRIPTION("AMD K8 core temperature monitor");
+MODULE_LICENSE("GPL");
+
+module_init(k8temp_init)
+module_exit(k8temp_exit)
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index ab032ce..61db190 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -479,6 +479,7 @@
 
 #define PCI_VENDOR_ID_AMD		0x1022
 #define PCI_DEVICE_ID_AMD_K8_NB		0x1100
+#define PCI_DEVICE_ID_AMD_K8_NB_MISC	0x1103
 #define PCI_DEVICE_ID_AMD_LANCE		0x2000
 #define PCI_DEVICE_ID_AMD_LANCE_HOME	0x2001
 #define PCI_DEVICE_ID_AMD_SCSI		0x2020



X-Git-Tag: v2.6.19^0~1801^2~24
X-Git-Url: http://www.jur-linux.org/git/?p=linux-2.6.git;a=commitdiff_plain;h=b17ebc9402040959690b5a2c4e1cfb1e6d4fb206

k8temp: Enable automatic loading

Let the k8temp driver load automatically.

Signed-off-by: Jean Delvare <khali@linux-fr.org>
Cc: Rudolf Marek <r.marek@sh.cvut.cz>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

diff --git a/drivers/hwmon/k8temp.c b/drivers/hwmon/k8temp.c
index 50162ff..f58b64e 100644
--- a/drivers/hwmon/k8temp.c
+++ b/drivers/hwmon/k8temp.c
@@ -133,6 +133,8 @@ static struct pci_device_id k8temp_ids[] = {
 	{ 0 },
 };
 
+MODULE_DEVICE_TABLE(pci, k8temp_ids);
+
 static int __devinit k8temp_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {

