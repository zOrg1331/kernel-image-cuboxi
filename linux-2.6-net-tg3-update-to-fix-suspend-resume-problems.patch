From: Andy Gospodarek <gospo@redhat.com>
Subject: [RHEL5.1 PATCH] tg3: update to fix suspend/resume problems
Date: Fri, 24 Aug 2007 14:01:24 -0400
Bugzilla: 253988
Message-Id: <20070824180123.GM29579@gospo.rdu.redhat.com>
Changelog: [net] tg3: update to fix suspend/resume problems



This patch was recently committed upstream and it has been reported that
it helps out with suspend/resume on tg3 cards.  

commit 3e0c95fd648c0d3175b9ff2232597d0b02eb7d46
Author: Michael Chan <mchan@broadcom.com>

    [TG3]: Fix suspend/resume problem.

    Joachim Deguara <joachim.deguara@amd.com> reported that tg3 devices
    would not resume properly if the device was shutdown before the system
    was suspended.  In such scenario where the netif_running state is 0,
    tg3_suspend() would not save the PCI state and so the memory enable bit
    and bus master enable bit would be lost.

    We fix this by always saving and restoring the PCI state in
    tg3_suspend() and tg3_resume() regardless of netif_running() state.

    Signed-off-by: Michael Chan <mchan@broadcom.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>


Specifically when not using the tg3 when you suspend, but trying to use
it when you resume.  Adding this allows T43's to suspend/resume
correctly on 5.1, so this would be nice.

This resolves BZ 253988.

---

 tg3.c |   17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

--- linux-2.6.18.i386/drivers/net/tg3.c.orig
+++ linux-2.6.18.i386/drivers/net/tg3.c
@@ -63,8 +63,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.79"
-#define DRV_MODULE_RELDATE	"July 18, 2007"
+#define DRV_MODULE_VERSION	"3.80"
+#define DRV_MODULE_RELDATE	"August 2, 2007"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -12199,6 +12199,12 @@ static int tg3_suspend(struct pci_dev *p
 	struct tg3 *tp = netdev_priv(dev);
 	int err;
 
+	/* PCI register 4 needs to be saved whether netif_running() or not.
+	 * MSI address and data need to be saved if using MSI and
+	 * netif_running().
+	 */
+	pci_save_state(pdev);
+
 	if (!netif_running(dev))
 		return 0;
 
@@ -12218,9 +12224,6 @@ static int tg3_suspend(struct pci_dev *p
 	tp->tg3_flags &= ~TG3_FLAG_INIT_COMPLETE;
 	tg3_full_unlock(tp);
 
-	/* Save MSI address and data for resume.  */
-	pci_save_state(pdev);
-
 	err = tg3_set_power_state(tp, pci_choose_state(pdev, state));
 	if (err) {
 		tg3_full_lock(tp, 0);
@@ -12248,11 +12251,11 @@ static int tg3_resume(struct pci_dev *pd
 	struct tg3 *tp = netdev_priv(dev);
 	int err;
 
+	pci_restore_state(tp->pdev);
+
 	if (!netif_running(dev))
 		return 0;
 
-	pci_restore_state(tp->pdev);
-
 	err = tg3_set_power_state(tp, PCI_D0);
 	if (err)
 		return err;

