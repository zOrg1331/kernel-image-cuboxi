From: Luming Yu <luyu@redhat.com>
Date: Sat, 13 Sep 2008 00:48:34 +0800
Subject: [ia64] param for max num of concurrent global TLB purges
Message-id: 48CA9D62.8070400@redhat.com
O-Subject: Re: [RHEL 5.3 PATCH 2/2] bz 451593: Kernel parameter for max number of concurrent global TLB purges
Bugzilla: 451593
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

bz 451593

Description of problem:
The patch defines kernel parameter "nptcg=". The parameter overrides max
number
of concurrent global TLB purges which is reported from either
PAL_VM_SUMMARY or
Upstream status:
a6c75b86ce9f01db4ea9912877b526c2dc4d2f0a

Testing status:
Boot fine on tiger4 and Cold fusion, and nothing unusual found.
I don't have box with PALO table to support this feature to test this
feature right now.

Update the patch series against -105 kernel. And add one more patch to
set max_purges=1 by default regardless what PAL returns to make sure no
regressions.
Please revew and ACKs.
NOTE: to apply, please keep it in this order:
1. [RHEL 5.3 PATCH 1/2] bz 451593: Multiple    outstanding    ptc.g
instruction support
2. [RHEL 5.3 PATCH 2/2]  bz 451593: Kernel parameter for max number
of concurrent global TLB purges
3. [RHEL 5.3 PATCH 1/1] bz 451593: set max_purges=1 by default
regardless what PAL returns

Thanks,
Luming

diff --git a/arch/ia64/kernel/efi.c b/arch/ia64/kernel/efi.c
index 35b3d22..c4f7237 100644
--- a/arch/ia64/kernel/efi.c
+++ b/arch/ia64/kernel/efi.c
@@ -418,7 +418,7 @@ static void __init handle_palo(unsigned long palo_phys)
 		return;
 	}
 
-	setup_ptcg_sem(palo->max_tlb_purges, 1);
+	setup_ptcg_sem(palo->max_tlb_purges, NPTCG_FROM_PALO);
 }
 
 void
diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c
index 5e8704a..3e8b5f8 100644
--- a/arch/ia64/kernel/setup.c
+++ b/arch/ia64/kernel/setup.c
@@ -1069,7 +1069,7 @@ cpu_init (void)
 	/* set ia64_ctx.max_rid to the maximum RID that is supported by all CPUs: */
 	if (ia64_pal_vm_summary(NULL, &vmi) == 0) {
 		max_ctx = (1U << (vmi.pal_vm_info_2_s.rid_size - 3)) - 1;
-		setup_ptcg_sem(vmi.pal_vm_info_2_s.max_purges, 0);
+		setup_ptcg_sem(vmi.pal_vm_info_2_s.max_purges, NPTCG_FROM_PAL);
 	} else {
 		printk(KERN_WARNING "cpu_init: PAL VM summary failed, assuming 18 RID bits\n");
 		max_ctx = (1U << 15) - 1;	/* use architected minimum */
diff --git a/arch/ia64/mm/tlb.c b/arch/ia64/mm/tlb.c
index c3b3994..f854597 100644
--- a/arch/ia64/mm/tlb.c
+++ b/arch/ia64/mm/tlb.c
@@ -120,19 +120,45 @@ static int need_ptcg_sem = 1;
 static int toolatetochangeptcgsem = 0;
 
 /*
+ * Kernel parameter "nptcg=" overrides max number of concurrent global TLB
+ * purges which is reported from either PAL or SAL PALO.
+ *
+ * We don't have sanity checking for nptcg value. It's the user's responsibility
+ * for valid nptcg value on the platform. Otherwise, kernel may hang in some
+ * cases.
+ */
+static int __init
+set_nptcg(char *str)
+{
+	int value = 0;
+
+	get_option(&str, &value);
+	setup_ptcg_sem(value, NPTCG_FROM_KERNEL_PARAMETER);
+
+	return 1;
+}
+
+__setup("nptcg=", set_nptcg);
+
+/*
  * Maximum number of simultaneous ptc.g purges in the system can
  * be defined by PAL_VM_SUMMARY (in which case we should take
  * the smallest value for any cpu in the system) or by the PAL
  * override table (in which case we should ignore the value from
  * PAL_VM_SUMMARY).
  *
+ * Kernel parameter "nptcg=" overrides maximum number of simultanesous ptc.g
+ * purges defined in either PAL_VM_SUMMARY or PAL override table. In this case,
+ * we should ignore the value from either PAL_VM_SUMMARY or PAL override table.
+ *
  * Complicating the logic here is the fact that num_possible_cpus()
  * isn't fully setup until we start bringing cpus online.
  */
 void
-setup_ptcg_sem(int max_purges, int from_palo)
+setup_ptcg_sem(int max_purges, int nptcg_from)
 {
-	static int have_palo;
+	static int kp_override;
+	static int palo_override;
 	static int firstcpu = 1;
  
 	if (toolatetochangeptcgsem) {
@@ -140,8 +166,18 @@ setup_ptcg_sem(int max_purges, int from_palo)
 		return;
 	}
 
-	if (from_palo) {
-		have_palo = 1;
+	if (nptcg_from == NPTCG_FROM_KERNEL_PARAMETER) {
+		kp_override = 1;
+		nptcg = max_purges;
+		goto resetsema;
+	}
+	if (kp_override) {
+		need_ptcg_sem = num_possible_cpus() > nptcg;
+		return;
+	}
+
+	if (nptcg_from == NPTCG_FROM_PALO) {
+		palo_override = 1;
 
 		/* In PALO max_purges == 0 really means it! */
 		if (max_purges == 0)
@@ -153,7 +189,7 @@ setup_ptcg_sem(int max_purges, int from_palo)
 		}
 		goto resetsema;
 	}
-	if (have_palo) {
+	if (palo_override) {
 		if (nptcg != PALO_MAX_TLB_PURGES)
 			need_ptcg_sem = (num_possible_cpus() > nptcg);
 		return;
diff --git a/include/asm-ia64/sal.h b/include/asm-ia64/sal.h
index 50eb9d3..863ca56 100644
--- a/include/asm-ia64/sal.h
+++ b/include/asm-ia64/sal.h
@@ -920,6 +920,10 @@ struct palo_table {
 	u8  reserved2[6];
 };
 
+#define NPTCG_FROM_PAL			0
+#define NPTCG_FROM_PALO			1
+#define NPTCG_FROM_KERNEL_PARAMETER	2
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_IA64_SAL_H */
