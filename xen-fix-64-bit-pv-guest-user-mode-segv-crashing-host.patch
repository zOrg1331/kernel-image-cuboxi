From: Paolo Bonzini <pbonzini@redhat.com>
Date: Mon, 29 Nov 2010 18:52:08 -0500
Subject: [xen] fix 64-bit PV guest user mode segv crashing host
Message-id: <1291056728-7153-1-git-send-email-pbonzini@redhat.com>
Patchwork-id: 4520
O-Subject: [kernel team] [RHEL5.6 PATCH] [xen] 64-bit PV guest user mode segv
	may crash host
Bugzilla: 658354
CVE: CVE-2010-4255
RH-Acked-by: Rik van Riel <riel@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>
RH-Acked-by: Miroslav Rezanina <mrezanin@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=658155

Upstream status: http://xenbits.xensource.com/xen-unstable.hg?rev/16975
    http://permalink.gmane.org/gmane.comp.emulators.xen.devel/94336

Brew build: https://brewweb.devel.redhat.com/taskinfo?taskID=2920230

handle_gdt_ldt_mapping_fault() is intended to deal with accesses to the
per-domain GDT/LDT shadow pages caused by descriptor loads.  For 32-bit,
segment limits indeed prevent the function being entered for direct
accesses and a #GP fault will be raised.  On 64-bit however all accesses
(no matter if user- or kernel-mode, since the guest kernel runs in ring
3) would reach handle_gdt_ldt_mapping_fault and possibly crash at the
BUG_ON() at the beginning of that function.

Fortunately the fix is simple: Since the guest kernel runs in ring 3,
any guest direct access will have the "user mode" bit set, and we can
propagate the page fault to the guest in this case.

The patch posted upstream does not apply directly because xen-unstable.hg
changeset 16975 is missing in our tree.  The patch was posted upstream at
http://lists.xensource.com/archives/html/xen-devel/2008-02/msg00022.html
as fixing only a theoretical problem; however, I think it's better to
be safe, since an actual bug was found due to guest code forcing Xen
down this path.  So, I'm including it too.

Tested by me.  Please review and ack for 5.6/5.5.z.

Signed-off-by: Paolo Bonzini  <pbonzini@redhat.com>
---
 arch/x86/traps.c |   22 +++++++++++++++++++---
 1 files changed, 19 insertions(+), 3 deletions(-)

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/arch/x86/traps.c b/arch/x86/traps.c
index 0aeeeff..c5f2602 100644
--- a/arch/x86/traps.c
+++ b/arch/x86/traps.c
@@ -787,6 +787,15 @@ asmlinkage void do_machine_check(struct cpu_user_regs *regs)
     machine_check_vector(regs, regs->error_code);
 }
 
+static void reserved_bit_page_fault(
+    unsigned long addr, struct cpu_user_regs *regs)
+{
+    printk("d%d:v%d: reserved bit in page table (ec=%04X)\n",
+           current->domain->domain_id, current->vcpu_id, regs->error_code);
+    show_page_walk(addr);
+    show_execution_state(regs);
+}
+
 void propagate_page_fault(unsigned long addr, u16 error_code)
 {
     struct trap_info *ti;
@@ -810,10 +819,13 @@ void propagate_page_fault(unsigned long addr, u16 error_code)
         tb->flags |= TBF_INTERRUPT;
     if ( unlikely(null_trap_bounce(v, tb)) )
     {
-        printk("Unhandled page fault in domain %d on VCPU %d (ec=%04X)\n",
+        printk("d%d:v%d: unhandled page fault (ec=%04X)\n",
                v->domain->domain_id, v->vcpu_id, error_code);
         show_page_walk(addr);
     }
+
+    if ( unlikely(error_code & PFEC_reserved_bit) )
+        reserved_bit_page_fault(addr, guest_cpu_user_regs());
 }
 
 static int handle_gdt_ldt_mapping_fault(
@@ -989,7 +1001,8 @@ static int fixup_page_fault(unsigned long addr, struct cpu_user_regs *regs)
     {
         if ( paging_mode_external(d) && guest_mode(regs) )
             return paging_fault(addr, regs);
-        if ( (addr >= GDT_LDT_VIRT_START) && (addr < GDT_LDT_VIRT_END) )
+        if ( !(regs->error_code & (PFEC_user_mode | PFEC_reserved_bit)) &&
+             (addr >= GDT_LDT_VIRT_START) && (addr < GDT_LDT_VIRT_END) )
             return handle_gdt_ldt_mapping_fault(
                 addr - GDT_LDT_VIRT_START, regs);
         return 0;
@@ -999,7 +1012,8 @@ static int fixup_page_fault(unsigned long addr, struct cpu_user_regs *regs)
          guest_kernel_mode(v, regs) &&
          /* Do not check if access-protection fault since the page may 
             legitimately be not present in shadow page tables */
-         ((regs->error_code & PFEC_write_access) == PFEC_write_access) &&
+         ((regs->error_code & (PFEC_write_access|PFEC_reserved_bit)) ==
+          PFEC_write_access) &&
          ptwr_do_page_fault(v, addr, regs) )
         return EXCRET_fault_fixed;
 
@@ -1039,6 +1053,8 @@ asmlinkage int do_page_fault(struct cpu_user_regs *regs)
         if ( likely((fixup = search_exception_table(regs->eip)) != 0) )
         {
             perfc_incr(copy_user_faults);
+            if ( unlikely(regs->error_code & PFEC_reserved_bit) )
+                reserved_bit_page_fault(addr, regs);
             regs->eip = fixup;
             return 0;
         }
