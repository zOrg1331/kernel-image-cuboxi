From: Hendrik Brueckner <brueckner@redhat.com>
Date: Tue, 16 Feb 2010 08:44:45 -0500
Subject: [s390] qdio: continue polling for buffer state ERROR
Message-id: <20100216084445.GA5691@redhat.com>
Patchwork-id: 23279
O-Subject: [RHEL5.6 PATCH 1/1] [s390] qdio: continue polling for buffer state
	ERROR
Bugzilla: 565531
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>

Description
-----------
If the next buffer to check is in state ERROR, polling is stopped
and the final check for further available inbound buffers disregards
buffers in state ERROR.	 The inbound traffic handling might hang.

The solution is to include state ERROR when checking availability
of more inbound buffers.

Bugzilla
--------
BZ 565531
https://bugzilla.redhat.com/show_bug.cgi?id=565531

Upstream status of the patch
----------------------------
The patch is upstream as of kernel version 2.6.33
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=4c52228d1b83ef67d4fa381c2ade70122c9e3c34

Test status
-----------
The patch has been tested and fixes the problem.
The fix has been verified by the IBM test department.


diff --git a/drivers/s390/cio/qdio.c b/drivers/s390/cio/qdio.c
index 6664038..8b52c9d 100644
--- a/drivers/s390/cio/qdio.c
+++ b/drivers/s390/cio/qdio.c
@@ -526,7 +526,7 @@ qdio_stop_polling(struct qdio_q *q)
                qdio_do_eqbs(q, &state, &gsf, &count);
        } else
                state = q->slsb.acc.val[gsf];
-       if (state != SLSB_P_INPUT_PRIMED)
+       if (state != SLSB_P_INPUT_PRIMED && state != SLSB_P_INPUT_ERROR)
 		return 1;
 	/* 
 	 * set our summary bit again, as otherwise there is a
@@ -1238,7 +1238,7 @@ tiqdio_is_inbound_q_done(struct qdio_q *q)
 		qdio_do_eqbs(q, &state, &start_buf, &count);
 	} else
 		state = q->slsb.acc.val[q->first_to_check];
-	if (state != SLSB_P_INPUT_PRIMED)
+	if (state != SLSB_P_INPUT_PRIMED && state != SLSB_P_INPUT_ERROR)
 		/* 
 		 * nothing more to do, if next buffer is not PRIMED.
 		 * note that we did a SYNC_MEMORY before, that there
@@ -1293,7 +1293,7 @@ qdio_is_inbound_q_done(struct qdio_q *q)
 		qdio_do_eqbs(q, &state, &start_buf, &count);
 	} else
 		state = q->slsb.acc.val[q->first_to_check];
-	if (state == SLSB_P_INPUT_PRIMED) {
+	if (state == SLSB_P_INPUT_PRIMED || state == SLSB_P_INPUT_ERROR) {
 		/* we got something to do */
 		QDIO_DBF_TEXT4(0,trace,"inqisntA");
 		QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
