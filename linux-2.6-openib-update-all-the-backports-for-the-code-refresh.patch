From: Doug Ledford <dledford@redhat.com>
Date: Tue, 14 Apr 2009 15:23:43 -0400
Subject: [openib] update all the backports for the code refresh
Message-id: 1239737023-31222-17-git-send-email-dledford@redhat.com
O-Subject: [Patch RHEL5.4 16/16] [InfiniBand] update all the backports for the code refresh
Bugzilla: 476301

Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/Makefile b/drivers/infiniband/core/Makefile
index b2e522d..754721e 100644
--- a/drivers/infiniband/core/Makefile
+++ b/drivers/infiniband/core/Makefile
@@ -8,14 +8,14 @@ obj-$(CONFIG_INFINIBAND_USER_ACCESS) +=	ib_uverbs.o ib_ucm.o \
 					$(user_access-y)
 
 ib_core-y :=			packer.o ud_header.o verbs.o sysfs.o \
-				device.o fmr_pool.o cache.o
+				device.o fmr_pool.o cache.o kobject_backport.o
 ib_core-$(CONFIG_INFINIBAND_USER_MEM) += umem.o
 
 ib_mad-y :=			mad.o smi.o agent.o mad_rmpp.o
 
 ib_sa-y :=			sa_query.o multicast.o notice.o local_sa.o
 
-ib_cm-y :=			cm.o
+ib_cm-y :=			cm.o kobject_backport.o
 
 iw_cm-y :=			iwcm.o
 
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index 31ee171..cc17114 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -39,6 +39,7 @@
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
+#include <linux/mount.h>
 
 #include "core_priv.h"
 
diff --git a/drivers/infiniband/core/kobject_backport.c b/drivers/infiniband/core/kobject_backport.c
new file mode 100644
index 0000000..b07f894
--- /dev/null
+++ b/drivers/infiniband/core/kobject_backport.c
@@ -0,0 +1,160 @@
+#include <linux/slab.h>
+#include <linux/kobject.h>
+
+struct kobj_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count);
+};
+
+/* default kobject attribute operations */
+static ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,
+			      char *buf)
+{
+	struct kobj_attribute *kattr;
+	ssize_t ret = -EIO;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->show)
+		ret = kattr->show(kobj, kattr, buf);
+	return ret;
+}
+
+static ssize_t kobj_attr_store(struct kobject *kobj, struct attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct kobj_attribute *kattr;
+	ssize_t ret = -EIO;
+
+	kattr = container_of(attr, struct kobj_attribute, attr);
+	if (kattr->store)
+		ret = kattr->store(kobj, kattr, buf, count);
+	return ret;
+}
+
+static struct sysfs_ops kobj_sysfs_ops = {
+	.show   = kobj_attr_show,
+	.store  = kobj_attr_store,
+};
+
+static void dynamic_kobj_release(struct kobject *kobj)
+{
+	pr_debug("kobject: (%p): %s\n", kobj, __FUNCTION__);
+	kfree(kobj);
+}
+
+static struct kobj_type dynamic_kobj_ktype = {
+	.release        = dynamic_kobj_release,
+	.sysfs_ops      = &kobj_sysfs_ops,
+};
+
+/**
+ * kobject_create_and_add - create a struct kobject dynamically and register it with sysfs
+ *
+ * @name: the name for the kset
+ * @parent: the parent kobject of this kobject, if any.
+ *
+ * This function creates a kobject structure dynamically and registers it
+ * with sysfs.  When you are finished with this structure, call
+ * kobject_put() and the structure will be dynamically freed when
+ * it is no longer being used.
+ *
+ * If the kobject was not able to be created, NULL will be returned.
+ */
+struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
+{
+	struct kobject *kobj;
+	int retval;
+
+	kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);
+	if (!kobj)
+		return NULL;
+
+	kobject_init(kobj);
+	kobj->ktype = &dynamic_kobj_ktype;
+	kobj->parent = parent;
+
+	retval = kobject_set_name(kobj, "%s", name);
+	if (retval) {
+		printk(KERN_WARNING "%s: kobject_set_name error: %d\n",
+			__FUNCTION__, retval);
+		goto err;
+	}
+
+	retval = kobject_add(kobj);
+	if (retval) {
+		printk(KERN_WARNING "%s: kobject_add error: %d\n",
+			__FUNCTION__, retval);
+		goto err;
+	}
+
+	return kobj;
+
+err:
+	kobject_put(kobj);
+	return NULL;
+}
+
+/**
+ * kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy
+ * @kobj: pointer to the kobject to initialize
+ * @ktype: pointer to the ktype for this kobject.
+ * @parent: pointer to the parent of this kobject.
+ * @fmt: the name of the kobject.
+ *
+ * This function combines the call to kobject_init() and
+ * kobject_add().  The same type of error handling after a call to
+ * kobject_add() and kobject lifetime rules are the same here.
+ */
+int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
+                         struct kobject *parent, const char *fmt, ...)
+{
+	int retval;
+	int limit;
+	int need;
+	va_list args;
+	char *name;
+
+	/* find out how big a buffer we need */
+	name = kmalloc(1024, GFP_KERNEL);
+	if (!name) {
+		retval = -ENOMEM;
+		goto out;
+	}
+	va_start(args, fmt);
+	need = vsnprintf(name, 1024, fmt, args);
+	va_end(args);
+	kfree(name);
+
+	/* Allocate the new space and copy the string in */
+	limit = need + 1;
+	name = kmalloc(limit, GFP_KERNEL);
+	if (!name) {
+		retval = -ENOMEM;
+		goto out;
+	}
+
+	va_start(args, fmt);
+	need = vsnprintf(name, limit, fmt, args);
+	va_end(args);
+
+	kobject_init(kobj);
+
+	kobj->ktype = ktype;
+	kobj->parent = parent;
+
+	retval = kobject_set_name(kobj, name);
+	kfree(name);
+	if (retval)
+		goto out;
+
+	retval = kobject_add(kobj);
+	if (retval)
+		goto out;
+
+out:
+	return retval;
+}
+
diff --git a/drivers/infiniband/core/namespace.c b/drivers/infiniband/core/namespace.c
index 281502d..f43fcb8 100644
--- a/drivers/infiniband/core/namespace.c
+++ b/drivers/infiniband/core/namespace.c
@@ -15,7 +15,7 @@ struct mnt_writer {
 } ____cacheline_aligned_in_smp;
 static DEFINE_PER_CPU(struct mnt_writer, mnt_writers);
 
-int __init init_mnt_writers(void)
+int backport_init_mnt_writers(void)
 {
 	int cpu;
 	for_each_possible_cpu(cpu) {
@@ -27,6 +27,7 @@ int __init init_mnt_writers(void)
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(backport_init_mnt_writers);
 
 static inline void __clear_mnt_count(struct mnt_writer *cpu_writer)
 {
@@ -50,7 +51,7 @@ static inline void use_cpu_writer_for_mount(struct mnt_writer *cpu_writer,
 	cpu_writer->mnt = mnt;
 }
 
-int mnt_want_write(struct vfsmount *mnt)
+int backport_mnt_want_write(struct vfsmount *mnt)
 {
 	int ret = 0;
 	struct mnt_writer *cpu_writer;
@@ -68,9 +69,9 @@ out:
 	put_cpu_var(mnt_writers);
 	return ret;
 }
-EXPORT_SYMBOL(mnt_want_write);
+EXPORT_SYMBOL(backport_mnt_want_write);
 
-void mnt_drop_write(struct vfsmount *mnt)
+void backport_mnt_drop_write(struct vfsmount *mnt)
 {
 	struct mnt_writer *cpu_writer;
 
@@ -93,4 +94,5 @@ void mnt_drop_write(struct vfsmount *mnt)
 	 */
 	put_cpu_var(mnt_writers);
 }
-EXPORT_SYMBOL(mnt_drop_write);
+EXPORT_SYMBOL(backport_mnt_drop_write);
+
diff --git a/drivers/infiniband/include/linux/fs.h b/drivers/infiniband/include/linux/fs.h
new file mode 100644
index 0000000..e94b212
--- /dev/null
+++ b/drivers/infiniband/include/linux/fs.h
@@ -0,0 +1,62 @@
+#ifndef BACKPORT_LINUX_FS_H
+#define BACKPORT_LINUX_FS_H
+
+#include_next <linux/fs.h>
+#include <linux/mount.h>
+
+#define FILE_LOCK_DEFERRED 1
+
+#define ATTR_KILL_PRIV  (1 << 14)
+
+static inline void __locks_copy_lock(struct file_lock *new, const struct file_lock *fl)
+{
+	new->fl_owner = fl->fl_owner;
+	new->fl_pid = fl->fl_pid;
+	new->fl_file = NULL;
+	new->fl_flags = fl->fl_flags;
+	new->fl_type = fl->fl_type;
+	new->fl_start = fl->fl_start;
+	new->fl_end = fl->fl_end;
+	new->fl_ops = NULL;
+	new->fl_lmops = NULL;
+}
+
+#define vfs_setlease(a, b, c) setlease(a, b, c)
+
+static inline int __mandatory_lock(struct inode *ino)
+{
+	return (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;
+}
+
+#define mandatory_lock(_args) MANDATORY_LOCK(_args)
+
+static inline int backport_vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)
+{
+	return vfs_symlink(dir, dentry, oldname, 0);
+}
+
+#define vfs_symlink(_dir, _dentry, _oldname) backport_vfs_symlink(_dir, _dentry, _oldname)
+
+#ifdef CONFIG_DEBUG_WRITECOUNT
+static inline void file_take_write(struct file *f)
+{
+	WARN_ON(f->f_mnt_write_state != 0);
+	f->f_mnt_write_state = FILE_MNT_WRITE_TAKEN;
+}
+#else
+static inline void file_take_write(struct file *filp) {}
+#endif
+
+static inline int inode_permission(struct inode *inode, int flags)
+{
+	return permission(inode, flags, NULL);
+}
+
+static inline int __mnt_is_readonly(struct vfsmount *mnt)
+{
+	if (mnt->mnt_sb->s_flags & MS_RDONLY)
+		return 1;
+	return 0;
+}
+
+#endif
diff --git a/drivers/infiniband/include/linux/if.h b/drivers/infiniband/include/linux/if.h
new file mode 100644
index 0000000..bbf8363
--- /dev/null
+++ b/drivers/infiniband/include/linux/if.h
@@ -0,0 +1,10 @@
+#ifndef __BACKPORT_LINUX_IF_H_TO_2_6_18__
+#define __BACKPORT_LINUX_IF_H_TO_2_6_18__
+
+#include_next <linux/if.h>
+
+#if defined(__powerpc64__)
+#define IFF_BONDING	0x20		/* bonding master or slave      */
+#endif
+
+#endif /* __BACKPORT_LINUX_IF_H_TO_2_6_18__ */
diff --git a/drivers/infiniband/include/linux/if_vlan.h b/drivers/infiniband/include/linux/if_vlan.h
index 90a8e1a..0c68427 100644
--- a/drivers/infiniband/include/linux/if_vlan.h
+++ b/drivers/infiniband/include/linux/if_vlan.h
@@ -14,4 +14,19 @@ static inline void vlan_group_set_device(struct vlan_group *vg, int vlan_id,
 	vg->vlan_devices[vlan_id] = dev;
 }
 
+#define vlan_dev_info(x) VLAN_DEV_INFO(x)
+
+static inline u16 vlan_dev_vlan_id(const struct net_device *dev)
+{
+	return vlan_dev_info(dev)->vlan_id;
+}
+
+#define vlan_dev_real_dev(netdev) (VLAN_DEV_INFO(netdev)->real_dev)
+#define vlan_dev_vlan_id(netdev) (VLAN_DEV_INFO(netdev)->vlan_id)
+
+static inline int is_vlan_dev(struct net_device *dev)
+{
+	return dev->priv_flags & IFF_802_1Q_VLAN;
+}
+
 #endif
diff --git a/drivers/infiniband/include/linux/in.h b/drivers/infiniband/include/linux/in.h
new file mode 100644
index 0000000..9b3913b
--- /dev/null
+++ b/drivers/infiniband/include/linux/in.h
@@ -0,0 +1,17 @@
+#ifndef __BACKPORT_LINUX_IN_H_TO_2_6_24__
+#define __BACKPORT_LINUX_IN_H_TO_2_6_24__
+
+#include_next <linux/in.h>
+
+
+static inline bool ipv4_is_loopback(__be32 addr)
+{
+	return (addr & htonl(0xff000000)) == htonl(0x7f000000);
+}
+
+static inline bool ipv4_is_zeronet(__be32 addr)
+{
+	return (addr & htonl(0xff000000)) == htonl(0x00000000);
+}
+
+#endif	/* __BACKPORT_LINUX_IN_H_TO_2_6_24__ */
diff --git a/drivers/infiniband/include/linux/inetdevice.h b/drivers/infiniband/include/linux/inetdevice.h
new file mode 100644
index 0000000..f9ed138
--- /dev/null
+++ b/drivers/infiniband/include/linux/inetdevice.h
@@ -0,0 +1,8 @@
+#ifndef _BACKPORT_LINUX_INETDEVICE_H
+#define _BACKPORT_LINUX_INETDEVICE_H
+
+#include_next <linux/inetdevice.h>
+
+#define ip_dev_find(net, addr) ip_dev_find(addr)
+
+#endif
diff --git a/drivers/infiniband/include/linux/kobject.h b/drivers/infiniband/include/linux/kobject.h
new file mode 100644
index 0000000..a21eda0
--- /dev/null
+++ b/drivers/infiniband/include/linux/kobject.h
@@ -0,0 +1,37 @@
+#ifndef __BACKPORT_KOBJECT_H_TO_2_6_24__
+#define __BACKPORT_KOBJECT_H_TO_2_6_24__
+
+#include_next <linux/kobject.h>
+
+
+/**
+ * kobject_create_and_add - create a struct kobject dynamically and register it with sysfs
+ *
+ * @name: the name for the kset
+ * @parent: the parent kobject of this kobject, if any.
+ *
+ * This function creates a kobject structure dynamically and registers it
+ * with sysfs.  When you are finished with this structure, call
+ * kobject_put() and the structure will be dynamically freed when
+ * it is no longer being used.
+ *
+ * If the kobject was not able to be created, NULL will be returned.
+ */
+struct kobject *kobject_create_and_add(const char *name, struct kobject *parent);
+
+/**
+ * kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy
+ * @kobj: pointer to the kobject to initialize
+ * @ktype: pointer to the ktype for this kobject.
+ * @parent: pointer to the parent of this kobject.
+ * @fmt: the name of the kobject.
+ *
+ * This function combines the call to kobject_init() and
+ * kobject_add().  The same type of error handling after a call to
+ * kobject_add() and kobject lifetime rules are the same here.
+ */
+int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
+                         struct kobject *parent, const char *fmt, ...);
+
+
+#endif /* __BACKPORT_KOBJECT_H_TO_2_6_24__ */
diff --git a/drivers/infiniband/include/linux/mount.h b/drivers/infiniband/include/linux/mount.h
new file mode 100644
index 0000000..446aafe
--- /dev/null
+++ b/drivers/infiniband/include/linux/mount.h
@@ -0,0 +1,15 @@
+#ifndef BACKPORT_LINUX_MOUNT_H
+#define BACKPORT_LINUX_MOUNT_H
+
+#include_next <linux/mount.h>
+#include <linux/fs.h>
+
+extern int backport_mnt_want_write(struct vfsmount *mnt);
+extern void backport_mnt_drop_write(struct vfsmount *mnt);
+extern int backport_init_mnt_writers(void);
+
+#define mnt_want_write backport_mnt_want_write
+#define mnt_drop_write backport_mnt_drop_write
+#define init_mnt_writers backport_init_mnt_writers
+
+#endif
diff --git a/drivers/infiniband/include/linux/mpage.h b/drivers/infiniband/include/linux/mpage.h
new file mode 100644
index 0000000..1c5ed55
--- /dev/null
+++ b/drivers/infiniband/include/linux/mpage.h
@@ -0,0 +1,15 @@
+#ifndef BACKPORT_LINUX_MPAGE_H
+#define BACKPORT_LINUX_MPAGE_H
+
+#include_next <linux/mpage.h>
+#include <linux/pagevec.h>
+
+typedef int (*backport_writepage_t)(struct page *page, struct writeback_control *wbc,
+                                void *data);
+
+extern int backport_write_cache_pages(struct address_space *mapping,
+                      struct writeback_control *wbc, backport_writepage_t writepage,
+                      void *data);
+
+#define write_cache_pages backport_write_cache_pages
+#endif
diff --git a/drivers/infiniband/include/linux/netdevice.h b/drivers/infiniband/include/linux/netdevice.h
index c13e522..b7f6acd 100644
--- a/drivers/infiniband/include/linux/netdevice.h
+++ b/drivers/infiniband/include/linux/netdevice.h
@@ -1,5 +1,6 @@
 #ifndef BACKPORT_LINUX_NETDEVICE_TO_2_6_18
 #define BACKPORT_LINUX_NETDEVICE_TO_2_6_18
+
 #include_next <linux/netdevice.h>
 
 static inline int skb_checksum_help_to_2_6_18(struct sk_buff *skb)
@@ -13,4 +14,8 @@ static inline int skb_checksum_help_to_2_6_18(struct sk_buff *skb)
 #define SET_ETHTOOL_OPS(netdev, ops) \
 	(netdev)->ethtool_ops = (struct ethtool_ops *)(ops)
 
+#define NETIF_F_LRO		32768   /* large receive offload */
+#define NETIF_F_IPV6_CSUM	16	/* Can checksum TCP/UDP over IPV6 */
+
+#define dev_get_by_name(net, name) dev_get_by_name(name)
 #endif
diff --git a/drivers/infiniband/include/linux/notifier.h b/drivers/infiniband/include/linux/notifier.h
index 0da2154..69501e2 100644
--- a/drivers/infiniband/include/linux/notifier.h
+++ b/drivers/infiniband/include/linux/notifier.h
@@ -1,8 +1,15 @@
-#ifndef LINUX_NOTIFIER_BACKPORT_TO_2_6_21_H
-#define LINUX_NOTIFIER_BACKPORT_TO_2_6_21_H
+#ifndef __BACKPORT_LINUX_NOTIFIER_H_TO_2_6_26__
+#define __BACKPORT_LINUX_NOTIFIER_H_TO_2_6_26__
 
 #include_next <linux/notifier.h>
 
+#define NETDEV_BONDING_FAILOVER NETDEV_CHANGE
+#define NOTIFY_DONE		0x0000		/* Don't care */
+
+#endif /* __BACKPORT_LINUX_NOTIFIER_H_TO_2_6_26__ */
+
+#ifndef LINUX_NOTIFIER_BACKPORT_TO_2_6_21_H
+#define LINUX_NOTIFIER_BACKPORT_TO_2_6_21_H
 
 /* Used for CPU hotplug events occuring while tasks are frozen due to a suspend
  * operation in progress
diff --git a/drivers/infiniband/include/linux/pagemap.h b/drivers/infiniband/include/linux/pagemap.h
new file mode 100644
index 0000000..c02739b
--- /dev/null
+++ b/drivers/infiniband/include/linux/pagemap.h
@@ -0,0 +1,8 @@
+#ifndef BACKPORT_LINUX_PAGEMAP_H
+#define BACKPORT_LINUX_PAGEMAP_H
+
+#include_next <linux/pagemap.h>
+
+#define __grab_cache_page	grab_cache_page
+
+#endif
diff --git a/drivers/infiniband/include/linux/rculist.h b/drivers/infiniband/include/linux/rculist.h
new file mode 100644
index 0000000..25872d5
--- /dev/null
+++ b/drivers/infiniband/include/linux/rculist.h
@@ -0,0 +1,7 @@
+#ifndef LINUX_RCULIST_BACKPORT_tO_2_6_26_H
+#define LINUX_RCULIST_BACKPORT_tO_2_6_26_H
+
+#include_next <linux/list.h>
+#include_next <linux/rcupdate.h>
+
+#endif
diff --git a/drivers/infiniband/include/linux/semaphore.h b/drivers/infiniband/include/linux/semaphore.h
new file mode 100644
index 0000000..1f42287
--- /dev/null
+++ b/drivers/infiniband/include/linux/semaphore.h
@@ -0,0 +1,6 @@
+#ifndef __BACKPORT_LINUX_SEMAPHORE_H_TO_2_6_25__
+#define __BACKPORT_LINUX_SEMAPHORE_H_TO_2_6_25__
+
+#include_next <asm/semaphore.h>
+
+#endif /* __BACKPORT_LINUX_SEMAPHORE_H_TO_2_6_25__ */
diff --git a/drivers/infiniband/include/linux/skbuff.h b/drivers/infiniband/include/linux/skbuff.h
new file mode 100644
index 0000000..9b606db
--- /dev/null
+++ b/drivers/infiniband/include/linux/skbuff.h
@@ -0,0 +1,23 @@
+#ifndef LINUX_SKBUFF_H_BACKPORT
+#define LINUX_SKBUFF_H_BACKPORT
+
+#include_next <linux/skbuff.h>
+
+#define CHECKSUM_PARTIAL CHECKSUM_HW 
+#define CHECKSUM_COMPLETE CHECKSUM_HW 
+
+#endif
+#ifndef __BACKPORT_LINUX_SKBUFF_H_TO_2_6_21__
+#define __BACKPORT_LINUX_SKBUFF_H_TO_2_6_21__
+
+#include_next <linux/skbuff.h>
+
+#define transport_header h.raw
+#define network_header nh.raw
+
+static inline int skb_csum_unnecessary(const struct sk_buff *skb)
+{
+	return skb->ip_summed & CHECKSUM_UNNECESSARY;
+}
+
+#endif
diff --git a/drivers/infiniband/include/linux/smp_lock.h b/drivers/infiniband/include/linux/smp_lock.h
new file mode 100644
index 0000000..e95c3ee
--- /dev/null
+++ b/drivers/infiniband/include/linux/smp_lock.h
@@ -0,0 +1,18 @@
+#ifndef LINUX_SMPLOCK_BACKPORT_tO_2_6_26_H
+#define LINUX_SMPLOCK_BACKPORT_tO_2_6_26_H
+
+#include_next <linux/smp_lock.h>
+
+/*
+ * Various legacy drivers don't really need the BKL in a specific
+ * function, but they *do* need to know that the BKL became available.
+ * This function just avoids wrapping a bunch of lock/unlock pairs
+ * around code which doesn't really need it.
+ */
+static inline void cycle_kernel_lock(void)
+{
+	lock_kernel();
+	unlock_kernel();
+}
+
+#endif
diff --git a/drivers/infiniband/include/linux/sysctl.h b/drivers/infiniband/include/linux/sysctl.h
new file mode 100644
index 0000000..8b1afea
--- /dev/null
+++ b/drivers/infiniband/include/linux/sysctl.h
@@ -0,0 +1,83 @@
+#ifndef __BACKPORT_SYSCTL_H_TO_2_6_18__
+#define __BACKPORT_SYSCTL_H_TO_2_6_18__
+
+#include <linux/slab.h>
+#include <linux/err.h>
+#include_next <linux/sysctl.h>
+
+#define CTL_NONE	0
+#define CTL_UNNUMBERED	-2	/* sysctl without a binary number */
+
+#define CTL_SUNRPC	7249        /* sunrpc debug */
+
+/* struct ctl_path describes where in the hierarchy a table is added */
+struct ctl_path {
+	const char *procname;
+	int ctl_name;
+};
+
+#define FAKE_SYSCTL_MAGIC1	((void *) 0xcafebabe)
+
+static inline void __fake_sysctl_table_destroy(struct ctl_table *node)
+{
+	struct ctl_table *next;
+
+	while (node && node[1].extra1 == FAKE_SYSCTL_MAGIC1) {
+		next = node->child;
+		kfree(node);
+		node = next;
+	}
+}
+
+/*
+ * Given a ctl_path and a ctl_table, convert this to the old-fashioned
+ * table hierarchy, linked through table->child.
+ */
+static inline struct ctl_table_header *
+register_sysctl_paths(const struct ctl_path *path, struct ctl_table *table)
+{
+	struct ctl_table_header *result = NULL;
+	struct ctl_table *root = NULL, *tp, **prev = &root;
+
+	for (; path->procname; ++path) {
+		tp = kzalloc(2 * sizeof(struct ctl_table), GFP_KERNEL);
+		if (!tp)
+			goto out;
+
+		tp->ctl_name = path->ctl_name;
+		tp->procname = path->procname;
+		tp->mode = 0555;
+		tp[1].extra1 = FAKE_SYSCTL_MAGIC1;
+		*prev = tp;
+		prev = &tp->child;
+	}
+	*prev = table;
+
+	result = register_sysctl_table(root, 0);
+
+out:
+	if (result == NULL)
+		__fake_sysctl_table_destroy(root);
+
+	return result;
+}
+
+static inline void
+fake_unregister_sysctl_table(struct ctl_table_header *hdr)
+{
+	struct ctl_table *node = hdr->ctl_table;
+
+	unregister_sysctl_table(hdr);
+	__fake_sysctl_table_destroy(node);
+}
+
+#define unregister_sysctl_table(hdr)	fake_unregister_sysctl_table(hdr)
+
+static inline struct ctl_table_header *
+backport_register_sysctl_table(ctl_table *table) {
+	return register_sysctl_table(table, 0);
+}
+
+#define register_sysctl_table backport_register_sysctl_table
+
+#endif /* __BACKPORT_SYSCTL_H_TO_2_6_18__ */
diff --git a/drivers/infiniband/include/linux/types.h b/drivers/infiniband/include/linux/types.h
deleted file mode 100644
index b2275c3..0000000
--- a/drivers/infiniband/include/linux/types.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef BACKPORT_LINUX_TYPES_TO_2_6_19
-#define BACKPORT_LINUX_TYPES_TO_2_6_19
-
-#include_next <linux/types.h>
-
-typedef __u16	__sum16;
-
-#endif
diff --git a/drivers/infiniband/include/linux/workqueue.h b/drivers/infiniband/include/linux/workqueue.h
index 43e5c7a..f1428c9 100644
--- a/drivers/infiniband/include/linux/workqueue.h
+++ b/drivers/infiniband/include/linux/workqueue.h
@@ -47,16 +47,26 @@ int backport_schedule_delayed_work(struct delayed_work *work, unsigned long dela
 #undef INIT_WORK
 #define INIT_WORK(_work, _func) backport_INIT_WORK(_work, _func)
 #define INIT_DELAYED_WORK(_work, _func) INIT_WORK(&(_work)->work, _func)
+#define INIT_DELAYED_WORK_DEFERRABLE(_work, _func) INIT_DELAYED_WORK(_work, _func)
 
 #undef DECLARE_WORK
 #define DECLARE_WORK(n, f) \
 	struct work_struct n = __WORK_INITIALIZER(n, (void (*)(void *))f, &(n))
 #define DECLARE_DELAYED_WORK(n, f) \
-	struct delayed_work n = { .work = __WORK_INITIALIZER(n.work, f, &(n.work)) }
+	struct delayed_work n = { .work = __WORK_INITIALIZER(n.work, (void (*)(void *))f, &(n.work)) }
 
 #define queue_delayed_work backport_queue_delayed_work
 #define cancel_delayed_work backport_cancel_delayed_work
+#define cancel_delayed_work_sync cancel_delayed_work
 #define cancel_rearming_delayed_workqueue backport_cancel_rearming_delayed_workqueue
 #define schedule_delayed_work backport_schedule_delayed_work
+#define cancel_delayed_work_sync cancel_delayed_work
+
+static inline void backport_cancel_rearming_delayed_work(struct delayed_work *work)
+{
+	cancel_delayed_work_sync(work);
+}
+
+#define cancel_rearming_delayed_work backport_cancel_rearming_delayed_work
 
 #endif
diff --git a/drivers/infiniband/include/net/ip.h b/drivers/infiniband/include/net/ip.h
index 8644731..e00f876 100644
--- a/drivers/infiniband/include/net/ip.h
+++ b/drivers/infiniband/include/net/ip.h
@@ -5,3 +5,47 @@
 #define inet_get_local_port_range(a, b) { *(a) = sysctl_local_port_range[0]; *(b) = sysctl_local_port_range[1]; }
 
 #endif
+
+
+#ifndef __BACKPORT_IP_H_TO_2_6_24__
+#define __BACKPORT_IP_H_TO_2_6_24__
+
+#include_next <net/ip.h>
+
+static inline void 
+backport_ip_ib_mc_map(__be32 naddr, const unsigned char *broadcast, char *buf)
+{
+	__u32 addr;
+	unsigned char scope = broadcast[5] & 0xF;
+
+	buf[0]  = 0;		/* Reserved */
+	buf[1]  = 0xff;		/* Multicast QPN */
+	buf[2]  = 0xff;
+	buf[3]  = 0xff;
+	addr    = ntohl(naddr);
+	buf[4]  = 0xff;
+	buf[5]  = 0x10 | scope;	/* scope from broadcast address */
+	buf[6]  = 0x40;		/* IPv4 signature */
+	buf[7]  = 0x1b;
+	buf[8]  = broadcast[8];		/* P_Key */
+	buf[9]  = broadcast[9];
+	buf[10] = 0;
+	buf[11] = 0;
+	buf[12] = 0;
+	buf[13] = 0;
+	buf[14] = 0;
+	buf[15] = 0;
+	buf[19] = addr & 0xff;
+	addr  >>= 8;
+	buf[18] = addr & 0xff;
+	addr  >>= 8;
+	buf[17] = addr & 0xff;
+	addr  >>= 8;
+	buf[16] = addr & 0x0f;
+}
+
+#undef ip_ib_mc_map
+
+#define ip_ib_mc_map(naddr, broadcast, buf) backport_ip_ib_mc_map(naddr, broadcast, buf)
+
+#endif	/* __BACKPORT_IP_H_TO_2_6_24__ */
diff --git a/drivers/infiniband/include/net/net_namespace.h b/drivers/infiniband/include/net/net_namespace.h
new file mode 100644
index 0000000..bb1b7d2
--- /dev/null
+++ b/drivers/infiniband/include/net/net_namespace.h
@@ -0,0 +1,3 @@
+#ifndef __NET_NAMESPACE_H__
+#define __NET_NAMESPACE_H__
+#endif
diff --git a/drivers/infiniband/include/net/route.h b/drivers/infiniband/include/net/route.h
new file mode 100644
index 0000000..e55a914
--- /dev/null
+++ b/drivers/infiniband/include/net/route.h
@@ -0,0 +1,13 @@
+#ifndef _BACKPORT_NET_ROUTE_H_
+#define _BACKPORT_NET_ROUTE_H_
+
+#include_next <net/route.h>
+
+#define ip_route_output_flow(net, rp, fl, sk, flags) \
+	ip_route_output_flow(rp, fl, sk, flags)
+
+#define ip_route_output_key(net, rp, fl) ip_route_output_key(rp, fl)
+
+#define inet_addr_type(net, addr) inet_addr_type(addr)
+
+#endif
diff --git a/drivers/net/cxgb3/Makefile b/drivers/net/cxgb3/Makefile
index 3434679..0cfb03e 100644
--- a/drivers/net/cxgb3/Makefile
+++ b/drivers/net/cxgb3/Makefile
@@ -1,3 +1,8 @@
+INFINIBANDINCLUDE := -Idrivers/infiniband/include \
+	$(if $(KBUILD_SRC),-I$(srctree)/drivers/infiniband/include)
+
+export CPPFLAGS := $(INFINIBANDINCLUDE) $(CPPFLAGS)
+
 #
 # Chelsio T3 driver
 #
diff --git a/drivers/net/mlx4/Makefile b/drivers/net/mlx4/Makefile
index 5b96ef4..f5487c6 100644
--- a/drivers/net/mlx4/Makefile
+++ b/drivers/net/mlx4/Makefile
@@ -1,3 +1,8 @@
+INFINIBANDINCLUDE := -Idrivers/infiniband/include \
+	$(if $(KBUILD_SRC),-I$(srctree)/drivers/infiniband/include)
+
+export CPPFLAGS := $(INFINIBANDINCLUDE) $(CPPFLAGS)
+
 obj-$(CONFIG_MLX4_CORE)		+= mlx4_core.o
 
 mlx4_core-y :=	alloc.o catas.o cmd.o cq.o eq.o fw.o icm.o intf.o main.o mcg.o \
