From: Jeff Layton <jlayton@redhat.com>
Date: Tue, 3 Aug 2010 12:21:26 -0400
Subject: [fs] cifs: remove force parm from cifs_unix_info_to_inode
Message-id: <1280838086-8887-1-git-send-email-jlayton@redhat.com>
Patchwork-id: 27299
O-Subject: [RHEL5.6 PATCH] BZ#619112: cifs: remove force_uid_gid parm from
	cifs_unix_info_to_inode
Bugzilla: 619112
RH-Acked-by: Steve Dickson <SteveD@redhat.com>

cifs_unix_info_to_inode was introduced upstream a couple of years ago to
consolidate some code. When it was implemented, a force_uid_gid flag was
added to address the fact that the code it replaced had a couple of
different variants. Some of them used the uid/gid from the wire
unconditionally rather than the one specified to override the wire
values.

The problem though is that the variants that always used the wire values
were just broken. When the uid=/gid= mount options are specified, those
values should *always* override the values from the server. This patch
removes that parameter from cifs_unix_info_to_inode and fixes up the
callers not to pass it in.

This patch is not upstream. The code upstream these days is vastly
different than what's in RHEL5, and this function no longer exists
there.

Tested by me with the customer-provided reproducer and by the customer
who reported the problem.

Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 64ce3076..1a4e8e2 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -82,7 +82,7 @@ static void cifs_set_ops(struct inode *inode, const bool is_dfs_referral)
 }
 
 static void cifs_unix_info_to_inode(struct inode *inode,
-		FILE_UNIX_BASIC_INFO *info, int force_uid_gid)
+				    FILE_UNIX_BASIC_INFO *info)
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifsInodeInfo *cifsInfo = CIFS_I(inode);
@@ -133,14 +133,12 @@ static void cifs_unix_info_to_inode(struct inode *inode,
 		break;
 	}
 
-	if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID) &&
-	    !force_uid_gid)
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)
 		inode->i_uid = cifs_sb->mnt_uid;
 	else
 		inode->i_uid = le64_to_cpu(info->Uid);
 
-	if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID) &&
-	    !force_uid_gid)
+	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)
 		inode->i_gid = cifs_sb->mnt_gid;
 	else
 		inode->i_gid = le64_to_cpu(info->Gid);
@@ -298,7 +296,7 @@ int cifs_get_inode_info_unix(struct inode **pinode,
 	/* this is ok to set on every inode revalidate */
 	atomic_set(&cifsInfo->inUse, 1);
 
-	cifs_unix_info_to_inode(inode, &find_data, 0);
+	cifs_unix_info_to_inode(inode, &find_data);
 
 	if (num_of_bytes < end_of_file)
 		cFYI(1, ("allocation size less than end of file"));
@@ -1079,7 +1077,7 @@ void posix_fill_in_inode(struct inode *tmp_inode,
 	local_mtime = tmp_inode->i_mtime;
 	local_size  = tmp_inode->i_size;
 
-	cifs_unix_info_to_inode(tmp_inode, pData, 1);
+	cifs_unix_info_to_inode(tmp_inode, pData);
 	cifs_set_ops(tmp_inode, false);
 
 	if (!S_ISREG(tmp_inode->i_mode))
