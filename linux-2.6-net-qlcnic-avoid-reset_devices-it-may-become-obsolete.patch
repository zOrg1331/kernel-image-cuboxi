From: Chad Dupuis <cdupuis@redhat.com>
Date: Mon, 29 Nov 2010 15:55:34 -0500
Subject: [net] qlcnic: avoid reset_devices, it may become obsolete
Message-id: <20101129155533.4428.43232.sendpatchset@localhost.localdomain>
Patchwork-id: 29656
O-Subject: [RHEL 5.6 PATCH 3/3] qlcnic: Avoid using reset_devices as it may
	become obsolete.
Bugzilla: 656008
RH-Acked-by: David S. Miller <davem@redhat.com>

Bugzilla
--------

Bug 656008 (https://bugzilla.redhat.com/show_bug.cgi?id=656008)

Upstream Status
---------------

netdev posting: http://permalink.gmane.org/gmane.linux.network/178814

Description
-----------

>From d432cf27b689064273a56610a7a8a8e64c34b4bb Mon Sep 17 00:00:00 2001
From: Rajesh Borundia <rajesh.borundia@qlogic.com>
Date: Fri, 19 Nov 2010 16:53:51 -0800
Subject: [PATCH] qlcnic: Avoid using reset_devices as it may become obsolete.

In kdump environment do not depend upon reset_devices parameter
to reset the pci function as this parameter may become obsolete.
Instead use an adapter specific mechanism to determine if the pci
function needs to be reset.

Per function refcount is maintained in driver, which is set in probe
and reset in remove handler of adapter. If the probe detects the count
as non zero then reset the function.

Signed-off-by: Rajesh Borundia <rajesh.borundia@qlogic.com>

diff --git a/drivers/net/qlcnic/qlcnic.h b/drivers/net/qlcnic/qlcnic.h
index 7b892eb..7b7eec3 100644
--- a/drivers/net/qlcnic/qlcnic.h
+++ b/drivers/net/qlcnic/qlcnic.h
@@ -899,6 +899,7 @@ struct qlcnic_mac_req {
 #define QLCNIC_BRIDGE_ENABLED       	0X10
 #define QLCNIC_DIAG_ENABLED		0x20
 #define QLCNIC_ESWITCH_ENABLED		0x40
+#define QLCNIC_NEED_FLR			0x1000
 #define QLCNIC_IS_MSI_FAMILY(adapter) \
 	((adapter)->flags & (QLCNIC_MSI_ENABLED | QLCNIC_MSIX_ENABLED))
 
diff --git a/drivers/net/qlcnic/qlcnic_ctx.c b/drivers/net/qlcnic/qlcnic_ctx.c
index ac604fe..d98be8f 100644
--- a/drivers/net/qlcnic/qlcnic_ctx.c
+++ b/drivers/net/qlcnic/qlcnic_ctx.c
@@ -480,8 +480,10 @@ int qlcnic_fw_create_ctx(struct qlcnic_adapter *adapter)
 {
 	int err;
 
-	if (reset_devices)
+	if (adapter->flags & QLCNIC_NEED_FLR) {
 		pci_reset_function(adapter->pdev);
+		adapter->flags &= ~QLCNIC_NEED_FLR;
+	}
 
 	err = qlcnic_fw_cmd_create_rx_ctx(adapter);
 	if (err)
diff --git a/drivers/net/qlcnic/qlcnic_hdr.h b/drivers/net/qlcnic/qlcnic_hdr.h
index 15fc320..ce84968 100644
--- a/drivers/net/qlcnic/qlcnic_hdr.h
+++ b/drivers/net/qlcnic/qlcnic_hdr.h
@@ -721,7 +721,7 @@ enum {
 #define QLCNIC_DEV_NPAR_NOT_RDY	0
 #define QLCNIC_DEV_NPAR_RDY		1
 
-#define QLC_DEV_CHECK_ACTIVE(VAL, FN)		((VAL) &= (1 << (FN * 4)))
+#define QLC_DEV_CHECK_ACTIVE(VAL, FN)		((VAL) & (1 << (FN * 4)))
 #define QLC_DEV_SET_REF_CNT(VAL, FN)		((VAL) |= (1 << (FN * 4)))
 #define QLC_DEV_CLR_REF_CNT(VAL, FN)		((VAL) &= ~(1 << (FN * 4)))
 #define QLC_DEV_SET_RST_RDY(VAL, FN)		((VAL) |= (1 << (FN * 4)))
diff --git a/drivers/net/qlcnic/qlcnic_main.c b/drivers/net/qlcnic/qlcnic_main.c
index 95170d9..2367af7 100644
--- a/drivers/net/qlcnic/qlcnic_main.c
+++ b/drivers/net/qlcnic/qlcnic_main.c
@@ -1338,6 +1338,7 @@ qlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	int err;
 	uint8_t revision_id;
 	uint8_t pci_using_dac;
+	u32 val;
 
 	err = pci_enable_device(pdev);
 	if (err)
@@ -1402,6 +1403,10 @@ qlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (err)
 		goto err_out_iounmap;
 
+	val = QLCRD32(adapter, QLCNIC_CRB_DEV_REF_COUNT);
+	if (QLC_DEV_CHECK_ACTIVE(val, adapter->portnum))
+		adapter->flags |= QLCNIC_NEED_FLR;
+
 	err = adapter->nic_ops->start_firmware(adapter);
 	if (err) {
 		dev_err(&pdev->dev, "Loading fw failed.Please Reboot\n");
