From: Mikulas Patocka <mpatocka@redhat.com>
Date: Fri, 10 Sep 2010 23:49:27 -0400
Subject: [md] dm-raid1: fix data lost at mirror log failure
Message-id: <Pine.LNX.4.64.1009101936160.15623@hs20-bc2-1.build.redhat.com>
Patchwork-id: 28210
O-Subject: [PATCH RHEL5] bz555197: fix data lost at mirror log failure
Bugzilla: 555197
RH-Acked-by: Mike Snitzer <snitzer@redhat.com>

Bugzilla #555197

dm raid1: fail writes if errors are not handled and log fails

If the mirror log fails when the handle_errors option was not selected
and there is no remaining valid mirror leg, writes return success even
though they weren't actually written to any device.  This patch
completes them with EIO instead.

This code path is taken:
do_writes:
    bio_list_merge(&ms->failures, &sync);
do_failures:
    if (!get_valid_mirror(ms)) (false)
    else if (log->type->get_failure_response(log) == DMLOG_IOERR_BLOCK)
(false)
    else bio_endio(bio, 0);

The logic in do_failures is based on presuming that the write was already
tried: if it succeeded at least on one leg (without DMLOG_IOERR_BLOCK) it
is reported as success.

This is backport of 5528d17de1cf1462f285c40ccaf8e0d0e4c64dc0 from 2.6.33.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
index 23c1d65..5b5d12b 100644
--- a/drivers/md/dm-raid1.c
+++ b/drivers/md/dm-raid1.c
@@ -1280,7 +1280,7 @@ static void do_writes(struct mirror_set *ms, struct bio_list *writes)
 	/*
 	 * Dispatch io.
 	 */
-	if (unlikely(ms->log_failure)) {
+	if (unlikely(ms->log_failure) && log->type->get_failure_response(log) == DMLOG_IOERR_BLOCK) {
 		spin_lock_irq(&ms->lock);
 		bio_list_merge(&ms->failures, &sync);
 		spin_unlock_irq(&ms->lock);
