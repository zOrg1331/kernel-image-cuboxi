From: Steve Best <sbest@redhat.com>
Date: Mon, 30 Aug 2010 15:18:08 -0400
Subject: [scsi] ipr: fix transition to operational on new adapters
Message-id: <20100830150621.5212.20381.sendpatchset@squad5-lp1.lab.bos.redhat.com>
Patchwork-id: 27930
O-Subject: [PATCH RHEL5.6 BZ626566 14/16] ipr: fix transition to operational for
	new adapters
Bugzilla: 626566

RHBZ#:
------
https://bugzilla.redhat.com/show_bug.cgi?id=626566

Description:
------------
The method of transitioning to operational for new adapters includes using
initialization stages.  The current stage is indicated via a register read.
The final good stage in the sequence is "operational" but does not necessarily
indicate that the driver can proceed.  There is another bit that gets set in the
adapter->host interrupt register when the adapter has completed enough of its
bringup such that it can accept commands.  The driver was not checking that
bit before proceeding which led to intermittent errors and adapter resets.

The fix is to check the "transition to operational" bit in the interrupt
register after detecting that the initialization stage is "operational" and
only proceed if both are set.

Signed-off-by: Wayne Boyer <wayneb@linux.vnet.ibm.com>
Acked-by: Brian King <brking@linux.vnet.ibm.com>
Signed-off-by: James Bottomley <James.Bottomley@suse.de>

RHEL Version Found:
-------------------
5.6

Brew:
-----
Built on all platforms. All patches brewed together.
http://brewweb.devel.redhat.com/brew/taskinfo?taskID=2713332

Upstream Status:
----------------
http://git.kernel.org/?p=linux/kernel/git/jejb/scsi-misc-2.6.git;
a=commit;h=1df79ca4223632113f14618833b8bb1727a8ca15

Steve Best
IBM on-site partner

Proposed Patch:
---------------

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c
index ef5259d..cedb9dd 100644
--- a/drivers/scsi/ipr.c
+++ b/drivers/scsi/ipr.c
@@ -7142,12 +7142,15 @@ static int ipr_reset_next_stage(struct ipr_cmnd *ipr_cmd)
 		stage_time = ioa_cfg->transop_timeout;
 		ipr_cmd->job_step = ipr_ioafp_identify_hrrq;
 	} else if (stage == IPR_IPL_INIT_STAGE_TRANSOP) {
-		ipr_cmd->job_step = ipr_ioafp_identify_hrrq;
-		maskval = IPR_PCII_IPL_STAGE_CHANGE;
-		maskval = (maskval << 32) | IPR_PCII_IOA_TRANS_TO_OPER;
-		writeq(maskval, ioa_cfg->regs.set_interrupt_mask_reg);
-		int_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);
-		return IPR_RC_JOB_CONTINUE;
+		int_reg = readl(ioa_cfg->regs.sense_interrupt_reg32);
+		if (int_reg & IPR_PCII_IOA_TRANS_TO_OPER) {
+			ipr_cmd->job_step = ipr_ioafp_identify_hrrq;
+			maskval = IPR_PCII_IPL_STAGE_CHANGE;
+			maskval = (maskval << 32) | IPR_PCII_IOA_TRANS_TO_OPER;
+			writeq(maskval, ioa_cfg->regs.set_interrupt_mask_reg);
+			int_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);
+			return IPR_RC_JOB_CONTINUE;
+		}
 	}
 
 	ipr_cmd->timer.data = (unsigned long) ipr_cmd;
