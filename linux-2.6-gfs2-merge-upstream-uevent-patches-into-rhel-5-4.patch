From: Steven Whitehouse <swhiteho@redhat.com>
Date: Tue, 10 Mar 2009 10:02:11 +0000
Subject: [gfs2] merge upstream uevent patches into RHEL 5.4
Message-id: 1236679331.9571.887.camel@quoit
O-Subject: [RHEL 5.4] GFS2: Merge upstream uevent patches into RHEL 5.4
Bugzilla: 476707
RH-Acked-by: Bob Peterson <rpeterso@redhat.com>

Hi,

This does exactly what it says on the tin. We ought to be sending a
proper set of variables with uevent messages to make it easier to
decipher what is going on. Since we don't change any existing strings
which are sent, this is backward compatible with the existing userspace
programs.

This fixes bugzilla: #476707 and has also been upstream for some time.
This has a couple of minor changes due to the uevent API being slightly
different in RHEL.

Steve.

-------------------------------------------------------------------------

diff --git a/fs/gfs2/locking/dlm/mount.c b/fs/gfs2/locking/dlm/mount.c
index 84da1f1..57e132a 100644
--- a/fs/gfs2/locking/dlm/mount.c
+++ b/fs/gfs2/locking/dlm/mount.c
@@ -202,17 +202,25 @@ out:
 static void gdlm_recovery_done(void *lockspace, unsigned int jid,
                                unsigned int message)
 {
+	char env_jid[20];
+	char env_status[20];
+	char *envp[] = { env_jid, env_status, NULL };
 	struct gdlm_ls *ls = lockspace;
 	ls->recover_jid_done = jid;
 	ls->recover_jid_status = message;
-	kobject_uevent(&ls->kobj, KOBJ_CHANGE);
+	sprintf(env_jid, "JID=%d", jid);
+	sprintf(env_status, "RECOVERY=%s",
+		message == LM_RD_SUCCESS ? "Done" : "Failed");
+	kobject_uevent_env(&ls->kobj, KOBJ_CHANGE, envp);
 }
 
 static void gdlm_others_may_mount(void *lockspace)
 {
+	char *message = "FIRSTMOUNT=Done";
+	char *envp[] = { message, NULL };
 	struct gdlm_ls *ls = lockspace;
 	ls->first_done = 1;
-	kobject_uevent(&ls->kobj, KOBJ_CHANGE);
+	kobject_uevent_env(&ls->kobj, KOBJ_CHANGE, envp);
 }
 
 /* Userspace gets the offline uevent, blocks new gfs locks on
diff --git a/fs/gfs2/locking/dlm/sysfs.c b/fs/gfs2/locking/dlm/sysfs.c
index 1373aec..b1b6e63 100644
--- a/fs/gfs2/locking/dlm/sysfs.c
+++ b/fs/gfs2/locking/dlm/sysfs.c
@@ -187,10 +187,13 @@ static struct kobj_type gdlm_ktype = {
 	.sysfs_ops     = &gdlm_attr_ops,
 };
 
+static struct kset_uevent_ops gdlm_uevent_ops;
+
 static struct kset gdlm_kset = {
 	.subsys = &kernel_subsys,
 	.kobj   = {.name = "lock_dlm",},
 	.ktype  = &gdlm_ktype,
+	.uevent_ops = &gdlm_uevent_ops,
 };
 
 int gdlm_kobject_setup(struct gdlm_ls *ls, struct kobject *fskobj)
@@ -219,6 +222,24 @@ void gdlm_kobject_release(struct gdlm_ls *ls)
 	kobject_unregister(&ls->kobj);
 }
 
+static int gdlm_uevent(struct kset *kset, struct kobject *kobj, char **envp,
+		       int num_envp, char *buffer, int buffer_size)
+{
+	struct gdlm_ls *ls = container_of(kobj, struct gdlm_ls, kobj);
+	int index = 0;
+	int length= 0;
+	if (add_uevent_var(envp, num_envp, &index, buffer, buffer_size, &length, "LOCKTABLE=%s:%s", ls->clustername, ls->fsname))
+		return -ENOMEM;
+	if (add_uevent_var(envp, num_envp, &index, buffer, buffer_size, &length, "LOCKPROTO=lock_dlm"))
+		return -ENOMEM;
+	envp[index] = NULL;
+	return 0;
+}
+
+static struct kset_uevent_ops gdlm_uevent_ops = {
+	.uevent = gdlm_uevent,
+};
+
 int gdlm_sysfs_init(void)
 {
 	int error;
@@ -226,7 +247,7 @@ int gdlm_sysfs_init(void)
 	error = kset_register(&gdlm_kset);
 	if (error)
 		printk("lock_dlm: cannot register kset %d\n", error);
-
+	
 	return error;
 }
 
diff --git a/fs/gfs2/sys.c b/fs/gfs2/sys.c
index e4faab8..7e997cf 100644
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@ -222,10 +222,13 @@ static struct kobj_type gfs2_ktype = {
 	.sysfs_ops     = &gfs2_attr_ops,
 };
 
+static struct kset_uevent_ops gfs2_uevent_ops;
+
 static struct kset gfs2_kset = {
 	.subsys = &fs_subsys,
 	.kobj   = {.name = "gfs2"},
 	.ktype  = &gfs2_ktype,
+	.uevent_ops = &gfs2_uevent_ops,
 };
 
 /*
@@ -528,6 +531,24 @@ void gfs2_sys_fs_del(struct gfs2_sbd *sdp)
 	kobject_unregister(&sdp->sd_kobj);
 }
 
+static int gfs2_uevent(struct kset *kset, struct kobject *kobj, char **envp,
+		       int num_envp, char *buffer, int buffer_size)
+{
+	struct gfs2_sbd *sdp = container_of(kobj, struct gfs2_sbd, sd_kobj);
+	int index = 0;
+	int length = 0;
+	if (add_uevent_var(envp, num_envp, &index, buffer, buffer_size, &length, "LOCKTABLE=%s", sdp->sd_table_name))
+		return -ENOMEM;
+	if (add_uevent_var(envp, num_envp, &index, buffer, buffer_size, &length, "LOCKPROTO=%s", sdp->sd_proto_name))
+		return -ENOMEM;
+	envp[index] = NULL;
+	return 0;
+}
+
+static struct kset_uevent_ops gfs2_uevent_ops = {
+	.uevent = gfs2_uevent,
+};
+
 int gfs2_sys_init(void)
 {
 	gfs2_sys_margs = NULL;
