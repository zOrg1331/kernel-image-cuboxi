From: Alexander Viro <aviro@redhat.com>
Date: Mon, 8 Dec 2008 16:53:53 -0500
Subject: [audit] misc kernel fixups
Message-id: 20081208215353.GC4523@shell.devel.redhat.com
O-Subject: [rhel5.4][bz#475330] misc kernel audit fixups
Bugzilla: 475330
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>
RH-Acked-by: Eric Paris <eparis@redhat.com>
RH-Acked-by: Jiri Pirko <jpirko@redhat.com>

[on top of rhel5 git + previous 5 audit patches, should apply to
rhel5 git alone as well]

several mainline fixes:
commit 88ae704c2aba150372e3d5c2f017c816773d09a7, by Adrian Bunk
	kernel/auditsc.c: fix an off-by-one
	This patch fixes an off-by-one in a BUG_ON() spotted by the Coverity
	checker.
commit 436c405c7d19455a71f42c9bec5fd5e028f1eb4e, by Eric Paris
	Audit: end printk with newline
	A couple of audit printk statements did not have a newline.
commit 5b9a4262232d632c28990fcdf4f36d0e0ade5f18, by Steve Grubb
	[PATCH] Make IPC mode consistent
	The mode fields for IPC records are not consistent. Some are hex, others
	are octal. This patch makes them all octal.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index 8e8539a..db50226 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1294,7 +1294,7 @@ static void audit_log_exit(struct audit_context *context, struct task_struct *ts
 		case AUDIT_IPC: {
 			struct audit_aux_data_ipcctl *axi = (void *)aux;
 			audit_log_format(ab, 
-				 "ouid=%u ogid=%u mode=%x",
+				 "ouid=%u ogid=%u mode=%#o",
 				 axi->uid, axi->gid, axi->mode);
 			if (axi->osid != 0) {
 				char *ctx = NULL;
@@ -1313,7 +1313,7 @@ static void audit_log_exit(struct audit_context *context, struct task_struct *ts
 		case AUDIT_IPC_SET_PERM: {
 			struct audit_aux_data_ipcctl *axi = (void *)aux;
 			audit_log_format(ab,
-				"qbytes=%lx ouid=%u ogid=%u mode=%x",
+				"qbytes=%lx ouid=%u ogid=%u mode=%#o",
 				axi->qbytes, axi->uid, axi->gid, axi->mode);
 			break; }
 
@@ -1641,7 +1641,7 @@ static inline void handle_one(const struct inode *inode)
 	if (likely(put_tree_ref(context, chunk)))
 		return;
 	if (unlikely(!grow_tree_refs(context))) {
-		printk(KERN_WARNING "out of memory, audit has lost a tree reference");
+		printk(KERN_WARNING "out of memory, audit has lost a tree reference\n");
 		audit_set_auditable(context);
 		audit_put_chunk(chunk);
 		unroll_tree_refs(context, p, count);
@@ -1699,7 +1699,7 @@ retry:
 		}
 		/* too bad */
 		printk(KERN_WARNING
-			"out of memory, audit has lost a tree reference");
+			"out of memory, audit has lost a tree reference\n");
 		unroll_tree_refs(context, p, count);
 		audit_set_auditable(context);
 		return;
@@ -1794,13 +1794,13 @@ static int audit_inc_name_count(struct audit_context *context,
 	if (context->name_count >= AUDIT_NAMES) {
 		if (inode)
 			printk(KERN_DEBUG "name_count maxed, losing inode data: "
-			       "dev=%02x:%02x, inode=%lu",
+			       "dev=%02x:%02x, inode=%lu\n",
 			       MAJOR(inode->i_sb->s_dev),
 			       MINOR(inode->i_sb->s_dev),
 			       inode->i_ino);
 
 		else
-			printk(KERN_DEBUG "name_count maxed, losing inode data");
+			printk(KERN_DEBUG "name_count maxed, losing inode data\n");
 		return 1;
 	}
 	context->name_count++;
@@ -2464,7 +2464,7 @@ int __audit_signal_info(int sig, struct task_struct *t)
 		axp->d.next = ctx->aux_pids;
 		ctx->aux_pids = (void *)axp;
 	}
-	BUG_ON(axp->pid_count > AUDIT_AUX_PIDS);
+	BUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);
 
 	axp->target_pid[axp->pid_count] = t->tgid;
 	axp->target_auid[axp->pid_count] = audit_get_loginuid(t->audit_context);
