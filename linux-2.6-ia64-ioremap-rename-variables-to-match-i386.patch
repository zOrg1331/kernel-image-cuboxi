From: Jarod Wilson <jwilson@redhat.com>
Date: Tue, 7 Aug 2007 11:59:43 -0400
Subject: [ia64] ioremap: rename variables to match i386
Message-id: 46B896EF.9080000@redhat.com
O-Subject: [RHEL5.1 PATCH 2/5] ia64: validate and remap mmap requests
Bugzilla: 240006

This is a multi-part message in MIME format.
Make ioremap variable names on ia64 consistent with x86. (and stay
consistent with upstream).

[PATCH] ia64: rename variables to match i386

No functional change, just use the same names as i386.

Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>

--
Jarod Wilson
jwilson@redhat.com

[PATCH] ia64: rename variables to match i386

No functional change, just use the same names as i386.

Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>

Acked-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/arch/ia64/mm/ioremap.c b/arch/ia64/mm/ioremap.c
index 7ecfe98..e0006c0 100644
--- a/arch/ia64/mm/ioremap.c
+++ b/arch/ia64/mm/ioremap.c
@@ -14,18 +14,18 @@
 #include <asm/meminit.h>
 
 static inline void __iomem *
-__ioremap (unsigned long offset, unsigned long size)
+__ioremap (unsigned long phys_addr, unsigned long size)
 {
 #ifdef CONFIG_XEN
-	offset = HYPERVISOR_ioremap(offset, size);
-	if (IS_ERR_VALUE(offset))
-		return (void __iomem*)offset;
+	phys_addr = HYPERVISOR_ioremap(phys_addr, size);
+	if (IS_ERR_VALUE(phys_addr))
+		return (void __iomem*)phys_addr;
 #endif
-	return (void __iomem *) (__IA64_UNCACHED_OFFSET | offset);
+	return (void __iomem *) (__IA64_UNCACHED_OFFSET | phys_addr);
 }
 
 void __iomem *
-ioremap (unsigned long offset, unsigned long size)
+ioremap (unsigned long phys_addr, unsigned long size)
 {
 	u64 attr;
 	unsigned long gran_base, gran_size;
@@ -35,31 +35,31 @@ ioremap (unsigned long offset, unsigned long size)
 	 * as the rest of the kernel.  For more details, see
 	 * Documentation/ia64/aliasing.txt.
 	 */
-	attr = kern_mem_attribute(offset, size);
+	attr = kern_mem_attribute(phys_addr, size);
 	if (attr & EFI_MEMORY_WB)
-		return (void __iomem *) phys_to_virt(offset);
+		return (void __iomem *) phys_to_virt(phys_addr);
 	else if (attr & EFI_MEMORY_UC)
-		return __ioremap(offset, size);
+		return __ioremap(phys_addr, size);
 
 	/*
 	 * Some chipsets don't support UC access to memory.  If
 	 * WB is supported for the whole granule, we prefer that.
 	 */
-	gran_base = GRANULEROUNDDOWN(offset);
-	gran_size = GRANULEROUNDUP(offset + size) - gran_base;
+	gran_base = GRANULEROUNDDOWN(phys_addr);
+	gran_size = GRANULEROUNDUP(phys_addr + size) - gran_base;
 	if (efi_mem_attribute(gran_base, gran_size) & EFI_MEMORY_WB)
-		return (void __iomem *) phys_to_virt(offset);
+		return (void __iomem *) phys_to_virt(phys_addr);
 
-	return __ioremap(offset, size);
+	return __ioremap(phys_addr, size);
 }
 EXPORT_SYMBOL(ioremap);
 
 void __iomem *
-ioremap_nocache (unsigned long offset, unsigned long size)
+ioremap_nocache (unsigned long phys_addr, unsigned long size)
 {
-	if (kern_mem_attribute(offset, size) & EFI_MEMORY_WB)
+	if (kern_mem_attribute(phys_addr, size) & EFI_MEMORY_WB)
 		return NULL;
 
-	return __ioremap(offset, size);
+	return __ioremap(phys_addr, size);
 }
 EXPORT_SYMBOL(ioremap_nocache);
