From: Jiri Pirko <jpirko@redhat.com>
Date: Date: Fri, 29 Jan 2010 09:43:46 +0100
Subject: [net] e1000e: fix WoL on 82577/82578
Message-id: <20100129084345.GB2920@psychotron.redhat.com>
O-Subject: [RHEL5.4.z patch] BZ543449 net: e1000e: fix WoL on 82577/82578
Bugzilla: 543449
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Dean Nelson <dnelson@redhat.com>

BZ543449
https://bugzilla.redhat.com/show_bug.cgi?id=543449

Description:
There were some WoL issues on Intel's latest hardware and this patch addresses
them appropriately. In 5.5 this is handled by a driver update.

Upstream:
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=82776a4bcd7aa5fbcd2e6339b3ce88b727dd40ab
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=74eee2e8d08048c847d1998c686e12a477ff939a
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=438b365a2758c012393a7be24d31a9c06aa0a504

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=2228908

Test:
Tested by customer.

Note:
linux-2.6-net-e1000e-fix-broken-wol.patch patch needs to be included too for
this to fix the issue.

Jirka

Signed-off-by: Andy Gospodarek <gospo@redhat.com>
Signed-off-by: Jiri Pirko <jpirko@redhat.com>

diff --git a/drivers/net/e1000e/ich8lan.c b/drivers/net/e1000e/ich8lan.c
index 9e23f50..c37057b 100644
--- a/drivers/net/e1000e/ich8lan.c
+++ b/drivers/net/e1000e/ich8lan.c
@@ -2693,9 +2693,8 @@ void e1000e_disable_gig_wol_ich8lan(struct e1000_hw *hw)
 		            E1000_PHY_CTRL_GBE_DISABLE;
 		ew32(PHY_CTRL, phy_ctrl);
 
-		/* Workaround SWFLAG unexpectedly set during S0->Sx */
 		if (hw->mac.type == e1000_pchlan)
-			udelay(500);
+			e1000_phy_hw_reset_ich8lan(hw);
 	default:
 		break;
 	}
diff --git a/drivers/net/e1000e/netdev.c b/drivers/net/e1000e/netdev.c
index bc8fc0c..ca1da5e 100644
--- a/drivers/net/e1000e/netdev.c
+++ b/drivers/net/e1000e/netdev.c
@@ -4568,8 +4568,7 @@ static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
 		/* Allow time for pending master requests to run */
 		e1000e_disable_pcie_master(&adapter->hw);
 
-		if ((adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) &&
-		    !(hw->mac.ops.check_mng_mode(hw))) {
+		if (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {
 			/* enable wakeup by the PHY */
 			retval = e1000_init_phy_wakeup(adapter, wufc);
 			if (retval)
@@ -4587,7 +4586,8 @@ static int e1000_suspend(struct pci_dev *pdev, pm_message_t state)
 	}
 
 	/* make sure adapter isn't asleep if manageability is enabled */
-	if (adapter->flags & FLAG_MNG_PT_ENABLED) {
+	if ((adapter->flags & FLAG_MNG_PT_ENABLED) ||
+	    (hw->mac.ops.check_mng_mode(hw))) {
 		pci_enable_wake(pdev, PCI_D3hot, 1);
 		pci_enable_wake(pdev, PCI_D3cold, 1);
 	}
@@ -4955,10 +4955,7 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
 		goto err_pci_reg;
 
 	pci_set_master(pdev);
-	/* PCI config space info */
-	err = pci_save_state(pdev);
-	if (err)
-		goto err_alloc_etherdev;
+	pci_save_state(pdev);
 
 	err = -ENOMEM;
 	netdev = alloc_etherdev(sizeof(struct e1000_adapter));

