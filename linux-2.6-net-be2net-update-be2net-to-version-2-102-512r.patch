From: Ivan Vecera <ivecera@redhat.com>
Date: Thu, 18 Nov 2010 14:07:43 -0500
Subject: [net] be2net: Update be2net to version 2.102.512r
Message-id: <1290089263-1824-1-git-send-email-ivecera@redhat.com>
Patchwork-id: 29486
O-Subject: [RHEL5.6 PATCH] be2net: Update be2net to version 2.102.512r
Bugzilla: 647259
RH-Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Thomas Graf <tgraf@redhat.com>

BZs:
#647259 - [Emulex 5.6 bug] Update be2net to version 2.102.512r

Description:
This patch updates be2net driver to version 2.102.512r (adds 3 important
upstream bugfixes - see below).

Test status:
Build OK. Tested by Emulex and also by myself.

Upstream commits:
63a7694 be2net: Call netif_carier_off() after register_netdev()
c6ce2f4 be2net: Fix CSO for UDP packets
f203af7 be2net: Schedule/Destroy worker thread in probe()/remove() rather than open()/close()

Signed-off-by: Ivan Vecera <ivecera@redhat.com>

diff --git a/drivers/net/benet/be.h b/drivers/net/benet/be.h
index cc12c54..151b4ea 100644
--- a/drivers/net/benet/be.h
+++ b/drivers/net/benet/be.h
@@ -34,7 +34,7 @@
 
 #include "be_hw.h"
 
-#define DRV_VER			"2.102.453r"
+#define DRV_VER			"2.102.512r"
 #define DRV_NAME		"be2net"
 #define BE_NAME			"ServerEngines BladeEngine2 10Gbps NIC"
 #define BE3_NAME		"ServerEngines BladeEngine3 10Gbps NIC"
diff --git a/drivers/net/benet/be_main.c b/drivers/net/benet/be_main.c
index 02f039b..1c9740c 100644
--- a/drivers/net/benet/be_main.c
+++ b/drivers/net/benet/be_main.c
@@ -687,20 +687,16 @@ static void be_rx_stats_update(struct be_adapter *adapter,
 	stats->be_rx_pkts++;
 }
 
-static inline bool do_pkt_csum(struct be_eth_rx_compl *rxcp, bool cso)
+static inline bool csum_passed(struct be_eth_rx_compl *rxcp)
 {
-	u8 l4_cksm, ip_version, ipcksm, tcpf = 0, udpf = 0, ipv6_chk;
+	u8 l4_cksm, ipv6, ipcksm;
 
 	l4_cksm = AMAP_GET_BITS(struct amap_eth_rx_compl, l4_cksm, rxcp);
 	ipcksm = AMAP_GET_BITS(struct amap_eth_rx_compl, ipcksm, rxcp);
-	ip_version = AMAP_GET_BITS(struct amap_eth_rx_compl, ip_version, rxcp);
-	if (ip_version) {
-		tcpf = AMAP_GET_BITS(struct amap_eth_rx_compl, tcpf, rxcp);
-		udpf = AMAP_GET_BITS(struct amap_eth_rx_compl, udpf, rxcp);
-	}
-	ipv6_chk = (ip_version && (tcpf || udpf));
+	ipv6 = AMAP_GET_BITS(struct amap_eth_rx_compl, ip_version, rxcp);
 
-	return ((l4_cksm && ipv6_chk && ipcksm) && cso) ? false : true;
+	/* Ignore ipcksm for ipv6 pkts */
+	return l4_cksm && (ipcksm || ipv6);
 }
 
 static struct be_rx_page_info *
@@ -851,10 +847,10 @@ static void be_rx_compl_process(struct be_adapter *adapter,
 
 	skb_fill_rx_data(adapter, skb, rxcp, num_rcvd);
 
-	if (do_pkt_csum(rxcp, adapter->rx_csum))
-		skb->ip_summed = CHECKSUM_NONE;
-	else
+	if (likely(adapter->rx_csum && csum_passed(rxcp)))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	else
+		skb->ip_summed = CHECKSUM_NONE;
 
 	skb->truesize = skb->len + sizeof(struct sk_buff);
 	skb->protocol = eth_type_trans(skb, adapter->netdev);
@@ -1567,6 +1563,20 @@ static void be_worker(void *data)
 		container_of(work, struct be_adapter, work.work);
 	int status;
 
+	/* when interrupts are not yet enabled, just reap any pending
+	* mcc completions */
+	if (!netif_running(adapter->netdev)) {
+		int mcc_compl;
+
+		mcc_compl = be_process_mcc(adapter);
+
+		if (mcc_compl) {
+			struct be_mcc_obj *mcc_obj = &adapter->mcc_obj;
+			be_cq_notify(adapter, mcc_obj->cq.id, false, mcc_compl);
+		}
+		goto reschedule;
+	}
+
 	/* Get Stats */
 	status = be_cmd_get_stats(adapter, &adapter->stats.cmd);
 	if (!status)
@@ -1583,6 +1593,7 @@ static void be_worker(void *data)
 		be_post_rx_frags(adapter);
 	}
 
+reschedule:
 	schedule_delayed_work(&adapter->work.work, msecs_to_jiffies(1000));
 }
 
@@ -1726,8 +1737,6 @@ static int be_close(struct net_device *netdev)
 	struct be_eq_obj *be_eq = &adapter->be_eq;
 	int vec;
 
-	cancel_delayed_work_sync(&adapter->work);
-
 	be_async_mcc_disable(adapter);
 
 	netif_stop_queue(netdev);
@@ -1781,8 +1790,6 @@ static int be_open(struct net_device *netdev)
 	/* Now that interrupts are on we can process async mcc */
 	be_async_mcc_enable(adapter);
 
-	schedule_delayed_work(&adapter->work.work, msecs_to_jiffies(100));
-
 	status = be_cmd_link_status_query(adapter, &link_up, &mac_speed,
 			&link_speed);
 	if (status)
@@ -2261,7 +2268,6 @@ static void be_netdev_init(struct net_device *netdev)
 	netdev->poll = be_poll_compat;
 	adapter->napi.dev = netdev;
 
-	netif_carrier_off(netdev);
 	netif_stop_queue(netdev);
 }
 
@@ -2454,6 +2460,8 @@ static void __devexit be_remove(struct pci_dev *pdev)
 
 	sysfs_remove_group(&adapter->netdev->class_dev.kobj, &benet_attr_group);
 
+	cancel_delayed_work_sync(&adapter->work);
+
 	unregister_netdev(adapter->netdev);
 
 	be_clear(adapter);
@@ -2608,12 +2616,14 @@ static int __devinit be_probe(struct pci_dev *pdev,
 	status = register_netdev(netdev);
 	if (status != 0)
 		goto unsetup;
+	netif_carrier_off(netdev);
 
 	if (sysfs_create_group(&adapter->netdev->class_dev.kobj,
 			       &benet_attr_group))
 		dev_err(&pdev->dev, "Could not create sysfs group\n");
 
 	dev_info(&pdev->dev, "%s - %s\n", netdev->name, nic_name(pdev));
+	schedule_delayed_work(&adapter->work.work, msecs_to_jiffies(100));
 	return 0;
 
 unsetup:
