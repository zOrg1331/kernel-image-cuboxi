From: Aristeu Rozanski <aris@redhat.com>
Date: Wed, 20 Aug 2008 13:16:58 -0400
Subject: [x86_64] nmi: kill disable_irq calls
Message-id: 20080820171649.372394000@redhat.com
O-Subject: [RHEL5.3 PATCH 12/25] nmi: kill disable_irq(0) calls
Bugzilla: 447618

https://bugzilla.redhat.com/show_bug.cgi?id=447618

{disable_enable}_timer_nmi_watchdog() is used to provide oprofile a periodic
timer. These functions disable/enable the NMI watchdog (but not the periodic
NMIs) in the case IO_APIC is being used. The problem on the x86_64 version on
RHEL-5 is that disable_timer_nmi_watchdog() also disables the interrupt 0.

fix {disable,enable}_timer_nmi_watchdog() so:
- interrupt 0 isn't disabled (this causes to all clock interrupts to stop while
  oprofile is in use when nmi watchdog uses IO_APIC - no idea how nobody ever
  noticed that)
- don't touch nmi_watchdog variable

upstream: not relevant upstream, both functions aren't used since
          2fbe7b25c8edaf2d10e6c1a4cc9f8afe714c4764

diff --git a/arch/x86_64/kernel/nmi.c b/arch/x86_64/kernel/nmi.c
index 671531f..638aa5f 100644
--- a/arch/x86_64/kernel/nmi.c
+++ b/arch/x86_64/kernel/nmi.c
@@ -195,22 +195,19 @@ void disable_timer_nmi_watchdog(void)
 	    (atomic_read(&nmi_watchdog_active) <= 0))
 		return;
 
-	disable_irq(0);
 	unset_nmi_callback();
 	old_ioapic_count = atomic_read(&nmi_watchdog_active);
 	atomic_set(&nmi_watchdog_active, -1);
 	nmi_active = -1;
-	nmi_watchdog = NMI_NONE;
 }
 
 void enable_timer_nmi_watchdog(void)
 {
-	if (atomic_read(&nmi_watchdog_active) < 0) {
-		nmi_watchdog = NMI_IO_APIC;
+	if (nmi_watchdog == NMI_IO_APIC &&
+	    atomic_read(&nmi_watchdog_active) < 0) {
 		touch_nmi_watchdog();
 		atomic_set(&nmi_watchdog_active, old_ioapic_count);
 		nmi_active = 1;
-		enable_irq(0);
 	}
 }
 
