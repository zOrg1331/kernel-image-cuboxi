From: Chad Dupuis <cdupuis@redhat.com>
Date: Mon, 26 Jul 2010 17:19:48 -0400
Subject: [scsi] qla4xxx: add support for ISP82XX
Message-id: <20100726171823.3177.37497.sendpatchset@localhost.localdomain>
Patchwork-id: 27101
O-Subject: [RHEL 5.6 PATCH 2/2] qla4xxx: Support for ISP82XX
Bugzilla: 546592

Description
===========

This patch adds support for the QLogic 82XX family of CNAs.

Bugzilla
========

546592

Upstream Status
===============

This was posted to the linux-scsi mailing list but has not been accepted
in the scsi-misc tree quite yet:

http://marc.info/?l=linux-scsi&m=127672174209834&w=2
Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/scsi/qla4xxx/Makefile b/drivers/scsi/qla4xxx/Makefile
index 86ea37b..f9c9905 100644
--- a/drivers/scsi/qla4xxx/Makefile
+++ b/drivers/scsi/qla4xxx/Makefile
@@ -1,5 +1,6 @@
 qla4xxx-y := ql4_os.o ql4_init.o ql4_mbx.o ql4_iocb.o ql4_isr.o \
-		ql4_nvram.o ql4_dbg.o
+		ql4_nvram.o ql4_dbg.o ql4_nx.o
 
 obj-$(CONFIG_SCSI_QLA_ISCSI) += qla4xxx.o
 
+EXTRA_CFLAGS += -g
diff --git a/drivers/scsi/qla4xxx/ql4_dbg.h b/drivers/scsi/qla4xxx/ql4_dbg.h
index 56ddc22..d861c3b 100644
--- a/drivers/scsi/qla4xxx/ql4_dbg.h
+++ b/drivers/scsi/qla4xxx/ql4_dbg.h
@@ -22,14 +22,14 @@
 #endif
 
 #if defined(QL_DEBUG_LEVEL_2)
-#define DEBUG2(x)      do {if(extended_error_logging == 2) x;} while (0);
+#define DEBUG2(x)      do {if(ql4xextended_error_logging == 2) x;} while (0);
 #define DEBUG2_3(x)   do {x;} while (0);
 #else				/*  */
 #define DEBUG2(x)	do {} while (0);
 #endif				/*  */
 
 #if defined(QL_DEBUG_LEVEL_3)
-#define DEBUG3(x)      do {if(extended_error_logging == 3) x;} while (0);
+#define DEBUG3(x)      do {if(ql4xextended_error_logging == 3) x;} while (0);
 #else				/*  */
 #define DEBUG3(x)	do {} while (0);
 #if !defined(QL_DEBUG_LEVEL_2)
diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index a12eb78..e82acb0 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -21,6 +21,7 @@
 #include <linux/mempool.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
+#include <linux/firmware.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/mutex.h>
@@ -33,6 +34,8 @@
 #include <scsi/scsi_transport.h>
 #include <scsi/scsi_transport_iscsi2.h>
 
+#include "ql4_dbg.h"
+#include "ql4_nx.h"
 
 #ifndef PCI_DEVICE_ID_QLOGIC_ISP4010
 #define PCI_DEVICE_ID_QLOGIC_ISP4010	0x4010
@@ -40,11 +43,15 @@
 
 #ifndef PCI_DEVICE_ID_QLOGIC_ISP4022
 #define PCI_DEVICE_ID_QLOGIC_ISP4022	0x4022
-#endif				
+#endif
 
 #ifndef PCI_DEVICE_ID_QLOGIC_ISP4032
 #define PCI_DEVICE_ID_QLOGIC_ISP4032	0x4032
-#endif				
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP8022
+#define PCI_DEVICE_ID_QLOGIC_ISP8022	0x8022
+#endif
 
 #define QLA_SUCCESS			0
 #define QLA_ERROR			1
@@ -133,7 +140,7 @@
 #define SOFT_RESET_TOV			30
 #define RESET_INTR_TOV			3
 #define SEMAPHORE_TOV			10
-#define ADAPTER_INIT_TOV		120
+#define ADAPTER_INIT_TOV		30
 #define ADAPTER_RESET_TOV		180
 #define EXTEND_CMD_TOV			60
 #define WAIT_CMD_TOV			30
@@ -156,22 +163,24 @@ struct srb {
 	struct list_head list;	/* (8)	 */
 	struct scsi_qla_host *ha;	/* HA the SP is queued on */
 	struct ddb_entry	*ddb;
-	uint16_t flags;		/* (1) Status flags. */
 
+	uint16_t flags;		/* (1) Status flags. */
 #define SRB_SCSI_PASSTHRU	BIT_2	/* for scsi passthru cmds */
 #define SRB_DMA_VALID		BIT_3	/* DMA Buffer mapped. */
 #define SRB_GOT_SENSE		BIT_4	/* sense data recieved. */
-	uint8_t state;		/* (1) Status flags. */
 
+	uint8_t state;		/* (1) Status flags. */
 #define SRB_NO_QUEUE_STATE	 0	/* Request is in between states */
 #define SRB_FREE_STATE		 1
 #define SRB_ACTIVE_STATE	 3
 #define SRB_ACTIVE_TIMEOUT_STATE 4
+#define SRB_RETRY_STATE      5
+#define SRB_DONE_STATE       6
 #define SRB_SUSPENDED_STATE	 7	/* Request in suspended state */
 
 	struct scsi_cmnd *cmd;	/* (4) SCSI command block */
 	dma_addr_t dma_handle;	/* (4) for unmap of single transfers */
-	atomic_t ref_count;	/* reference count for this srb */
+	struct kref srb_ref;	/* reference count for this srb */
 	uint32_t fw_ddb_index;
 	uint8_t err_id;		/* error id */
 #define SRB_ERR_PORT	   1	/* Request failed because "port down" */
@@ -201,8 +210,18 @@ struct ddb_entry {
 	struct iscsi_cls_conn *conn;
 
 	atomic_t state;		/* DDB State */
+#define DDB_STATE_DEAD		0	/* We can no longer talk to this device */
+#define DDB_STATE_ONLINE	1	/* Device ready to accept commands */
+#define DDB_STATE_MISSING	2	/* Device logged off, trying to re-login */
 
 	unsigned long flags;	/* DDB Flags */
+#define DF_RELOGIN			0	/* Relogin to device */
+#define DF_NO_RELOGIN		1	/* Do not relogin if IOCTL logged it out */
+#define DF_ISNS_DISCOVERED	2	/* Device was discovered via iSNS */
+#define DF_FO_MASKED		3
+#define DF_REMOVE			4	/* FW DDB is destroyed */
+#define DF_DYNAMIC_LUN_SCAN_NEEDED	5
+
 
 	unsigned long dev_scan_wait_to_start_relogin;
 	unsigned long dev_scan_wait_to_complete_relogin;
@@ -244,25 +263,6 @@ struct ddb_entry {
 };
 
 /*
- * DDB states.
- */
-#define DDB_STATE_DEAD		0	/* We can no longer talk to
-					 * this device */
-#define DDB_STATE_ONLINE	1	/* Device ready to accept
-					 * commands */
-#define DDB_STATE_MISSING	2	/* Device logged off, trying
-					 * to re-login */
-
-/*
- * DDB flags.
- */
-#define DF_RELOGIN		0	/* Relogin to device */
-#define DF_NO_RELOGIN		1	/* Do not relogin if IOCTL
-					 * logged it out */
-#define DF_ISNS_DISCOVERED	2	/* Device was discovered via iSNS */
-#define DF_FO_MASKED		3
-
-/*
  * Asynchronous Event Queue structure
  */
 struct aen {
@@ -277,6 +277,64 @@ struct ql4_aen_log {
 #include "ql4_fw.h"
 #include "ql4_nvram.h"
 
+struct ql82xx_hw_data {
+	/* Offsets for flash/nvram access (set to ~0 if not used). */
+	uint32_t        flash_conf_off;
+	uint32_t        flash_data_off;
+
+	uint32_t        fdt_wrt_disable;
+	uint32_t        fdt_erase_cmd;
+	uint32_t        fdt_block_size;
+	uint32_t        fdt_unprotect_sec_cmd;
+	uint32_t        fdt_protect_sec_cmd;
+
+	uint32_t        flt_region_flt;
+	uint32_t        flt_region_fdt;
+	uint32_t        flt_region_boot;
+	uint32_t        flt_region_bootload;
+	uint32_t        flt_region_fw;
+	uint32_t        reserved;
+};
+
+struct qla82xx_legacy_intr_set {
+	uint32_t        int_vec_bit;
+	uint32_t        tgt_status_reg;
+	uint32_t        tgt_mask_reg;
+	uint32_t        pci_int_reg;
+};
+
+/* MSI-X Support */
+
+#define QLA_MSIX_DEFAULT	0x00
+#define QLA_MSIX_RSP_Q		0x01
+
+#define QLA_MSIX_ENTRIES	2
+#define QLA_MIDX_DEFAULT	0
+#define QLA_MIDX_RSP_Q		1
+
+struct ql4_msix_entry {
+	int have_irq;
+	uint16_t msix_vector;
+	uint16_t msix_entry;
+};
+
+struct isp_operations {
+	int  (*iospace_config) (struct scsi_qla_host *ha);
+	void (*pci_config) (struct scsi_qla_host *);
+	void (*disable_intrs) (struct scsi_qla_host *);
+	void (*enable_intrs) (struct scsi_qla_host *);
+	int  (*start_firmware) (struct scsi_qla_host *);
+	irqreturn_t (*intr_handler) (int , void *, struct pt_regs *);
+	void (*interrupt_service_routine) (struct scsi_qla_host *, uint32_t);
+	int  (*reset_chip) (struct scsi_qla_host *);
+	int  (*reset_firmware) (struct scsi_qla_host *);
+	void  (*queue_iocb) (struct scsi_qla_host *);
+	void  (*complete_iocb) (struct scsi_qla_host *);
+	uint16_t (*rd_shdw_req_q_out) (struct scsi_qla_host *);
+	uint16_t (*rd_shdw_rsp_q_in) (struct scsi_qla_host *);
+	int (*get_sys_info) (struct scsi_qla_host *);
+};
+
 /*
  * Linux Host Adapter structure
  */
@@ -286,7 +344,7 @@ struct scsi_qla_host {
 	uint16_t rsvd0;
 
 	/* exported functions */
-	int (*ql4cmd)(struct scsi_qla_host *ha, struct srb * srb);
+	int (*ql4cmd)(struct scsi_qla_host *ha, struct srb *srb);
 	int (*ql4mbx)(struct scsi_qla_host *ha, uint8_t inCount,
 		uint8_t outCount, uint32_t *mbx_cmd, uint32_t *mbx_sts);
 
@@ -295,30 +353,40 @@ struct scsi_qla_host {
 	uint32_t tot_ddbs;
 	unsigned long flags;
 
-#define AF_ISNS_CMD_DONE	     13 /* 0x00002000 */
 #define AF_ONLINE			0 /* 0x00000001 */
 #define AF_INIT_DONE			1 /* 0x00000002 */
 #define AF_MBOX_COMMAND			2 /* 0x00000004 */
 #define AF_MBOX_COMMAND_DONE		3 /* 0x00000008 */
+#define AF_DPC_SCHEDULED		5 /* 0x00000020 */
 #define AF_INTERRUPTS_ON		6 /* 0x00000040 Not Used */
 #define AF_GET_CRASH_RECORD		7 /* 0x00000080 */
 #define AF_LINK_UP			8 /* 0x00000100 */
-#define AF_TOPCAT_CHIP_PRESENT		9 /* 0x00000200 */
 #define AF_IRQ_ATTACHED			10 /* 0x00000400 */
 #define AF_DISABLE_ACB_COMPLETE		11 /* 0x00000800 */
+#define AF_OS_INDEX_VALID		12 /* 0x00001000 */
+#define AF_ISNS_CMD_DONE		13 /* 0x00002000 */
+#define AF_INTx_ENABLED			15 /* 0x000080000 */
+#define AF_MSI_ENABLED			16 /* 0x00010000 */
+#define AF_MSIX_ENABLED			17 /* 0x00020000 */
+#define AF_HBA_GOING_AWAY		18 /* 0x00040000 */
+#define AF_MBOX_COMMAND_NOPOLL	19 /* 0x00080000 */
 
 	unsigned long dpc_flags;
 
 #define DPC_RESET_HA			1 /* 0x00000002 */
 #define DPC_RETRY_RESET_HA		2 /* 0x00000004 */
 #define DPC_RELOGIN_DEVICE		3 /* 0x00000008 */
-#define DPC_RESET_HA_DESTROY_DDB_LIST	4 /* 0x00000010 */
+#define DPC_RESET_HA_FW_CONTEXT	4 /* 0x00000010 */
 #define DPC_RESET_HA_INTR		5 /* 0x00000020 */
 #define DPC_ISNS_RESTART		7 /* 0x00000080 */
 #define DPC_AEN				9 /* 0x00000200 */
 #define DPC_GET_DHCP_IP_ADDR		15 /* 0x00008000 */
 #define DPC_ASYNC_MSG_PDU		16 /* 0x00010000 */
-#define DPC_LINK_CHANGED		17 /* 0x00020000 */
+#define DPC_LINK_CHANGED		19 /* 0x00020000 */
+#define DPC_RESET_ACTIVE		20 /* 0x00040000 */
+#define DPC_HA_UNRECOVERABLE	21 /* 0x00080000 ISP-82xx only*/
+#define DPC_HA_NEED_QUIESCENT	22 /* 0x00100000 ISP-82xx only*/
+#define DPC_DYNAMIC_LUN_SCAN	23 /* 0x00800000 */
 
 	uint16_t	iocb_cnt;
 	uint16_t	rsvd;
@@ -471,11 +539,13 @@ struct scsi_qla_host {
 	/* Map ddb_list entry by FW ddb index */
 	struct ddb_entry *fw_ddb_index_map[MAX_DDB_ENTRIES];
 	struct ql4_aen_log aen_log;
-	void (*ql4getaenlog)(struct scsi_qla_host *ha,
-				struct ql4_aen_log *aenl);
+	void (*ql4getaenlog)(struct scsi_qla_host *ha, struct ql4_aen_log *aenl);
 
+	/* Reserved variable needed for structure parity with our other
+	 * drivers, in order to use the same ioctl module */
 	unsigned long reserved[16];
-	/* Placeholder for original srb of status continuation */
+
+	/* Saved srb for status continuation entry processing */
 	struct srb *status_srb;
 
 	struct list_head async_iocb_list;
@@ -498,6 +568,47 @@ struct scsi_qla_host {
 	struct in6_addr         ipv6_addr0;
 	struct in6_addr         ipv6_addr1;
 	struct in6_addr         ipv6_default_router_addr;
+
+	/* ACB & IPv6 supported in future.
+	 * Include structures now for IOCTL module compatibility */
+	uint16_t ifcb_size;
+
+	/* NetXen (NX3031) specific fields */
+	struct device_reg_82xx  __iomem *qla82xx_reg; /* Base I/O address */
+	unsigned long nx_pcibase;       /* Base I/O address */
+	uint8_t *nx_db_rd_ptr;         /* Doorbell read pointer */
+	unsigned long nx_db_wr_ptr;     /* Door bell write pointer */
+	unsigned long first_page_group_start;
+	unsigned long first_page_group_end;
+
+	uint32_t crb_win;
+	uint32_t curr_window;
+	uint32_t ddr_mn_window;
+	unsigned long mn_win_crb;
+	unsigned long ms_win_crb;
+	int qdr_sn_window;
+	rwlock_t hw_lock;
+	uint16_t portnum; /* function number */
+	int link_width;
+
+	void *rsvd4;
+	struct qla82xx_legacy_intr_set nx_legacy_intr;
+	u32 nx_crb_mask;
+
+	uint8_t revision_id;
+	uint8_t rsvd3[3];
+
+	int fw_heartbeat_counter;
+
+	struct isp_operations *isp_ops;
+	struct ql82xx_hw_data hw;
+
+	struct ql4_msix_entry msix_entries[QLA_MSIX_ENTRIES];
+
+	uint32_t nx_dev_init_timeout;
+	uint32_t nx_reset_timeout;
+
+	struct completion mbx_intr_comp;
 };
 
 static inline int is_ipv4_enabled(struct scsi_qla_host *ha)
@@ -539,6 +650,11 @@ static inline int is_qla4032(struct scsi_qla_host *ha)
 	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4032;
 }
 
+static inline int is_qla8022(struct scsi_qla_host *ha)
+{
+	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022;
+}
+
 static inline int adapter_up(struct scsi_qla_host *ha)
 {
 	return (test_bit(AF_ONLINE, &ha->flags) != 0) &&
@@ -552,51 +668,51 @@ static inline struct scsi_qla_host* to_qla_host(struct Scsi_Host *shost)
 
 static inline void __iomem *isp_semaphore(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u1.isp4010.nvram :
-		&ha->reg->u1.isp4022.semaphore); 
+		&ha->reg->u1.isp4022.semaphore;
 }
 
 static inline void __iomem *isp_nvram(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u1.isp4010.nvram :
-		&ha->reg->u1.isp4022.nvram);
+		&ha->reg->u1.isp4022.nvram;
 }
 
 static inline void __iomem *isp_ext_hw_conf(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u2.isp4010.ext_hw_conf :
-		&ha->reg->u2.isp4022.p0.ext_hw_conf);
+		&ha->reg->u2.isp4022.p0.ext_hw_conf;
 }
 
 static inline void __iomem *isp_port_status(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u2.isp4010.port_status :
-		&ha->reg->u2.isp4022.p0.port_status);
+		&ha->reg->u2.isp4022.p0.port_status;
 }
 
 static inline void __iomem *isp_port_ctrl(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u2.isp4010.port_ctrl :
-		&ha->reg->u2.isp4022.p0.port_ctrl);
+		&ha->reg->u2.isp4022.p0.port_ctrl;
 }
 
 static inline void __iomem *isp_port_error_status(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u2.isp4010.port_err_status :
-		&ha->reg->u2.isp4022.p0.port_err_status);
+		&ha->reg->u2.isp4022.p0.port_err_status;
 }
 
 static inline void __iomem *isp_gp_out(struct scsi_qla_host *ha)
 {
-	return (is_qla4010(ha) ?
+	return is_qla4010(ha) ?
 		&ha->reg->u2.isp4010.gp_out :
-		&ha->reg->u2.isp4022.p0.gp_out);
+		&ha->reg->u2.isp4022.p0.gp_out;
 }
 
 static inline void __iomem *isp_probe_mux_addr(struct scsi_qla_host *ha)
@@ -681,6 +797,8 @@ static inline void ql4xxx_unlock_drvr(struct scsi_qla_host *a)
 		ql4xxx_sem_unlock(a, QL4022_DRVR_SEM_MASK);
 }
 
+#include "ql4_glbl.h"
+
 /*---------------------------------------------------------------------------*/
 
 /* Defines for qla4xxx_initialize_adapter() and qla4xxx_recover_adapter() */
diff --git a/drivers/scsi/qla4xxx/ql4_fw.h b/drivers/scsi/qla4xxx/ql4_fw.h
index e374be8..2bf0f50 100644
--- a/drivers/scsi/qla4xxx/ql4_fw.h
+++ b/drivers/scsi/qla4xxx/ql4_fw.h
@@ -41,6 +41,36 @@ struct host_mem_cfg_regs {
 	__le32 rsrvd1[31];	/* 0x84-0xFF */
 };
 
+/*
+ * ISP 3031 I/O Register Set structure definitions.
+ */
+struct device_reg_82xx {
+	__le32 req_q_out;         /* Offset 0x0000 (R) : Request Queue out-Pointer. (64 * 4) */
+	__le32 reserve1[63];         /*  Request Queue out-Pointer. (64 * 4) */
+	__le32 rsp_q_in;          /*  Offset 0x0100 (R/W) : Response Queue In-Pointer. */
+	__le32 reserve2[63];          /*  Response Queue In-Pointer. */
+
+
+	__le32 rsp_q_out;         /*  Offset 0x0200 (R/W) : Response Queue Out-Pointer. */
+	__le32 reserve3[63];         /*  Response Queue Out-Pointer. */
+
+	__le32 mailbox_in[8];        /* Offset 0x0300 (R/W): Mail box In registers */
+	__le32 reserve4[24];
+	__le32 hint;                 /* Offset 0x0380 (R/W):Host interrupt register */
+#define HINT_MBX_INT_PENDING    BIT_0
+	__le32 reserve5[31];
+	__le32 mailbox_out[8];       /* Offset 0x0400 (R): Mail box Out registers */
+	__le32 reserve6[56];
+
+	__le32 host_status;           /* Offset 0x500 (R): host status*/
+/* Need to find out if HSRX_RISC_INT is supposed to be BIT_15 or BIT_0 as per FCoE or iSCSI */
+#define HSRX_RISC_MB_INT         BIT_0 /* RISC to Host Mailbox interrupt */
+#define HSRX_RISC_IOCB_INT       BIT_1 /* RISC to Host IOCB interrupt */
+
+	__le32 host_int;             /* Offset 0x0504 (R/W): Interrupt status.*/
+#define ISRX_82XX_RISC_INT                BIT_0   /* RISC interrupt. */
+};
+
 /*  remote register set (access via PCI memory read/write) */
 struct isp_reg {
 #define MBOX_REG_COUNT 8
@@ -215,6 +245,82 @@ union external_hw_config_reg {
 	uint32_t Asuint32_t;
 };
 
+/* 82XX Support  start */
+/* 82xx Default FLT Addresses */
+#define FA_FLASH_LAYOUT_ADDR_82		0xFC400
+#define FA_FLASH_DESCR_ADDR_82		0xFC000
+#define FA_BOOT_LOAD_ADDR_82		0x04000
+#define FA_BOOT_CODE_ADDR_82		0x20000
+#define FA_RISC_CODE_ADDR_82		0x40000
+#define FA_GOLD_RISC_CODE_ADDR_82	0x80000
+
+/* Flash Description Table ***************************************************/
+struct qla_fdt_layout {
+	uint8_t sig[4];
+	uint16_t version;
+	uint16_t len;
+	uint16_t checksum;
+	uint8_t unused1[2];
+	uint8_t model[16];
+	uint16_t man_id;
+	uint16_t id;
+	uint8_t flags;
+	uint8_t erase_cmd;
+	uint8_t alt_erase_cmd;
+	uint8_t wrt_enable_cmd;
+	uint8_t wrt_enable_bits;
+	uint8_t wrt_sts_reg_cmd;
+	uint8_t unprotect_sec_cmd;
+	uint8_t read_man_id_cmd;
+	uint32_t block_size;
+	uint32_t alt_block_size;
+	uint32_t flash_size;
+	uint32_t wrt_enable_data;
+	uint8_t read_id_addr_len;
+	uint8_t wrt_disable_bits;
+	uint8_t read_dev_id_len;
+	uint8_t chip_erase_cmd;
+	uint16_t read_timeout;
+	uint8_t protect_sec_cmd;
+	uint8_t unused2[65];
+};
+
+/* Flash Layout Table ********************************************************/
+
+struct qla_flt_location {
+	uint8_t sig[4];
+	uint16_t start_lo;
+	uint16_t start_hi;
+	uint8_t version;
+	uint8_t unused[5];
+	uint16_t checksum;
+};
+
+struct qla_flt_header {
+	uint16_t version;
+	uint16_t length;
+	uint16_t checksum;
+	uint16_t unused;
+};
+
+/* 82xx FLT Regions */
+#define FLT_REG_FDT             0x1a
+#define FLT_REG_FLT             0x1c
+#define FLT_REG_BOOTLOAD_82	0x72
+#define FLT_REG_FW_82		0x74
+#define FLT_REG_GOLD_FW_82	0x75
+#define FLT_REG_BOOT_CODE_82	0x78
+
+struct qla_flt_region {
+	uint32_t code;
+	uint32_t size;
+	uint32_t start;
+	uint32_t end;
+};
+
+/* 82XX Support end **********************************************************/
+
+
 /*************************************************************************
  *
  *		Mailbox Commands Structures and Definitions
@@ -224,6 +330,10 @@ union external_hw_config_reg {
 /*  Mailbox command definitions */
 #define MBOX_CMD_ABOUT_FW			0x0009
 #define MBOX_CMD_PING				0x000B
+#define MBOX_CMD_ENABLE_INTRS		0x0010
+#define INTR_DISABLE				0
+#define INTR_ENABLE					1
+#define MBOX_CMD_STOP_FW			0x0014
 #define MBOX_CMD_ABORT_TASK			0x0015
 #define MBOX_CMD_LUN_RESET			0x0016
 #define MBOX_CMD_GET_MANAGEMENT_DATA		0x001E
@@ -251,6 +361,7 @@ union external_hw_config_reg {
 #define DDB_DS_LOGIN_IN_PROCESS			0x07
 #define MBOX_CMD_GET_FW_STATE			0x0069
 #define MBOX_CMD_GET_INIT_FW_CTRL_BLOCK_DEFAULTS 0x006A
+#define MBOX_CMD_GET_SYS_INFO			0x0078
 #define MBOX_CMD_RESTORE_FACTORY_DEFAULTS	0x0087
 #define MBOX_CMD_SET_ACB			0x0088
 #define MBOX_CMD_GET_ACB			0x0089
@@ -371,8 +482,8 @@ struct addr_ctrl_blk {
 	uint8_t ipv4_tos;	/* 38 */
 	uint8_t ipv4_ttl;	/* 39 */
 	uint8_t acb_version;	/* 3A */
-#define ACB_NOT_SUPPORTED	0x00
-#define ACB_SUPPORTED		0x02	/* Capable of ACB Version 2 Features */
+#define ACB_NOT_SUPPORTED		0x00
+#define ACB_SUPPORTED			0x02	/* Capable of ACB Version 2 Features */
 
 	uint8_t res2;	/* 3B */
 	uint16_t def_timeout;	/* 3C-3D */
@@ -418,7 +529,7 @@ struct addr_ctrl_blk {
 #define IPV6_OPT_IPV6_PROTOCOL_ENABLE	0x8000
 
 	uint16_t ipv6_addtl_opts;	/* 208-209 */
-#define IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE	0x0002 /*Pri ACB Only*/
+#define IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE	0x0002 /* Pri ACB Only */
 #define IPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR		0x0001
 
 	uint16_t ipv6_tcp_opts;	/* 20A-20B */
@@ -460,6 +571,7 @@ struct addr_ctrl_blk {
 
 struct init_fw_ctrl_blk {
 	struct addr_ctrl_blk pri;
+	/*struct addr_ctrl_blk sec;	Only primary ACB needed in initiator driver */
 };
 
 /*************************************************************************/
@@ -564,6 +676,20 @@ struct flash_sys_info {
 	uint32_t reserved1[39]; /* 170-1ff */
 };	/* 200 */
 
+struct mbx_sys_info {
+	uint8_t	board_id_str[16];   /* 0-f Keep board ID string first */
+				    /* in this structure for GUI. */
+	uint16_t board_id;	/* 10-11 board ID code */
+	uint16_t phys_port_cnt;	/* 12-13 number of physical network ports*/
+	uint16_t port_num;	/* 14-15 network port for this PCI function */
+				    /* (port 0 is first port) */
+	uint8_t	mac_addr[6];	/* 16-1b MAC address for this PCI function */
+	uint32_t iscsi_pci_func_cnt; /* 1c-1f number of iSCSI PCI functions */
+	uint32_t pci_func;	/* 20-23 this PCI function */
+	unsigned char serial_number[16];  /* 24-33 serial number string */
+	uint8_t	reserved[12];		/* 34-3f */
+};
+
 struct crash_record {
 	uint16_t fw_major_version;	/* 00 - 01 */
 	uint16_t fw_minor_version;	/* 02 - 03 */
@@ -784,12 +910,6 @@ struct status_entry {
 
 };
 
-/* Status Continuation entry */
-struct status_cont_entry {
-       struct qla4_header hdr; /* 00-03 */
-       uint8_t extSenseData[IOCB_MAX_EXT_SENSEDATA_LEN]; /* 04-63 */
-};
-
 struct pdu_entry {
 	uint8_t *Buff;
 	uint32_t BuffLen;
@@ -799,6 +919,12 @@ struct pdu_entry {
 	dma_addr_t DmaBuff;
 };
 
+/* Status Continuation entry */
+struct status_cont_entry {
+       struct qla4_header hdr; /* 00-03 */
+       uint8_t extSenseData[IOCB_MAX_EXT_SENSEDATA_LEN]; /* 04-63 */
+};
+
 struct passthru0 {
 	struct qla4_header hdr;		       /* 00-03 */
 	uint32_t handle;	/* 04-07 */
@@ -840,4 +966,13 @@ struct passthru_status {
 	uint8_t res4[16];	/* 30-3F */
 };
 
+/*
+ * ISP queue - response queue entry definition.
+ */
+struct response_q {
+	uint8_t         data[60];
+	uint32_t        signature;
+#define RESPONSE_PROCESSED      0xDEADDEAD      /* Signature */
+} ;
+
 #endif /*  _QLA4X_FW_H */
diff --git a/drivers/scsi/qla4xxx/ql4_glbl.h b/drivers/scsi/qla4xxx/ql4_glbl.h
index 0522bea..e67cf05 100644
--- a/drivers/scsi/qla4xxx/ql4_glbl.h
+++ b/drivers/scsi/qla4xxx/ql4_glbl.h
@@ -10,16 +10,16 @@
 
 struct iscsi_cls_conn;
 
-void qla4xxx_hw_reset(struct scsi_qla_host *ha);
+int qla4xxx_hw_reset(struct scsi_qla_host *ha);
 int ql4xxx_lock_drvr_wait(struct scsi_qla_host *a);
 int qla4xxx_conn_start(struct iscsi_cls_conn *conn);
 int qla4xxx_send_tgts(struct scsi_qla_host *ha, char *ip, uint16_t port);
-int qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb *srb);
+int qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb * srb);
 int qla4xxx_initialize_adapter(struct scsi_qla_host *ha,
 			       uint8_t renew_ddb_list);
 int qla4xxx_soft_reset(struct scsi_qla_host *ha);
-irqreturn_t qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
 
+void qla4xxx_free_ddb(struct scsi_qla_host *ha, struct ddb_entry *ddb_entry);
 void qla4xxx_free_ddb_list(struct scsi_qla_host *ha);
 void qla4xxx_process_aen(struct scsi_qla_host *ha, uint8_t process_aen);
 
@@ -27,7 +27,7 @@ int qla4xxx_get_dhcp_ip_address(struct scsi_qla_host *ha);
 int qla4xxx_relogin_device(struct scsi_qla_host *ha,
 			   struct ddb_entry *ddb_entry);
 int qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb);
-int qla4xxx_reset_lun(struct scsi_qla_host *ha, struct ddb_entry *ddb_entry,
+int qla4xxx_reset_lun(struct scsi_qla_host *ha, struct ddb_entry * ddb_entry,
 		      int lun);
 int qla4xxx_get_flash(struct scsi_qla_host *ha, dma_addr_t dma_addr,
 		      uint32_t offset, uint32_t len);
@@ -63,36 +63,110 @@ struct ddb_entry *qla4xxx_alloc_sess(struct scsi_qla_host *ha);
 int qla4xxx_add_sess(struct ddb_entry *, int);
 void qla4xxx_destroy_sess(struct ddb_entry *ddb_entry);
 int qla4xxx_conn_close_sess_logout(struct scsi_qla_host *ha,
-				uint16_t fw_ddb_index,
-				uint16_t connection_id,
-				uint16_t option);
+				   uint16_t fw_ddb_index,
+				   uint16_t connection_id,
+				   uint16_t option);
 int qla4xxx_clear_database_entry(struct scsi_qla_host *ha,
 				 uint16_t fw_ddb_index);
 int qla4xxx_is_nvram_configuration_valid(struct scsi_qla_host *ha);
 int qla4xxx_get_fw_version(struct scsi_qla_host *ha);
 void qla4xxx_interrupt_service_routine(struct scsi_qla_host *ha,
-				uint32_t intr_status);
+				       uint32_t intr_status);
 int qla4xxx_init_rings(struct scsi_qla_host *ha);
 void qla4xxx_dump_buffer(void *b, uint32_t size);
-struct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,
-				uint32_t index);
-void qla4xxx_srb_compl(struct scsi_qla_host *ha, struct srb *srb);
+struct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha, uint32_t index);
+void qla4xxx_srb_compl(struct kref *ref);
 int qla4xxx_reinitialize_ddb_list(struct scsi_qla_host * ha);
-int qla4xxx_process_ddb_changed(struct scsi_qla_host *ha,
-				uint32_t fw_ddb_index,
+int qla4xxx_process_ddb_changed(struct scsi_qla_host *ha, uint32_t fw_ddb_index,
 				uint32_t state, uint32_t conn_error);
 
 int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
-				uint8_t outCount, uint32_t *mbx_cmd,
-			    uint32_t *mbx_sts);
+			uint8_t outCount, uint32_t *mbx_cmd, uint32_t *mbx_sts);
+extern void qla4xxx_queue_iocb(struct scsi_qla_host *ha);
+extern void qla4xxx_complete_iocb(struct scsi_qla_host *ha);
+int qla4xxx_get_sys_info(struct scsi_qla_host *ha);
+extern int qla4xxx_iospace_config(struct scsi_qla_host *ha);
+extern void qla4xxx_pci_config(struct scsi_qla_host *ha);
+extern uint32_t *qla4xxx_isp_mbx_out(struct scsi_qla_host *ha);
+extern int qla4xxx_start_firmware(struct scsi_qla_host *ha);
+extern irqreturn_t qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
+extern uint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha);
+extern uint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha);
+void qla4xxx_dump_bytes(void *buffer, uint32_t size);
+int qla4xxx_mbx_reg_test(struct scsi_qla_host *ha);
+int qla4xxx_request_irqs(struct scsi_qla_host *ha);
+void qla4xxx_free_irqs(struct scsi_qla_host *ha);
+void qla4xxx_process_response_queue(struct scsi_qla_host *ha);
+void qla4xxx_isr_decode_mailbox(struct scsi_qla_host *ha, uint32_t mbox_status);
+void qla4xxx_wake_dpc(struct scsi_qla_host *ha);
+
+/* ISP 3031 related functions */
+extern void qla82xx_pci_config(struct scsi_qla_host *);
+extern void qla82xx_reset_chip(struct scsi_qla_host *);
+extern int qla82xx_iospace_config(struct scsi_qla_host *ha);
+extern void qla82xx_reset_adapter(struct scsi_qla_host *);
+extern int qla82xx_nvram_config(struct scsi_qla_host *);
+extern int qla82xx_load_risc(struct scsi_qla_host *);
+extern char *qla82xx_get_fw_version_str(struct scsi_qla_host *, char *);
+extern int qla82xx_abort_command(struct srb *);
+extern int qla82xx_start_scsi(struct srb *);
+extern irqreturn_t qla82xx_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
+extern void qla82xx_queue_iocb(struct scsi_qla_host *ha);
+extern void qla82xx_complete_iocb(struct scsi_qla_host *ha);
+
+extern int qla82xx_crb_win_lock(struct scsi_qla_host *);
+extern void qla82xx_crb_win_unlock(struct scsi_qla_host *);
+extern int qla82xx_pci_get_crb_addr_2M(struct scsi_qla_host *, u64 *);
+extern void qla82xx_wr_32(struct scsi_qla_host *, u64, u32);
+extern int qla82xx_rd_32(struct scsi_qla_host *, u64);
+extern int QLA30XX_RDMEM(struct scsi_qla_host *, u64, void *, int);
+extern int QLA30XX_WRMEM(struct scsi_qla_host *, u64, void *, int);
+extern int check_for_bad_spd(struct scsi_qla_host *);
+extern void load_fw (struct scsi_qla_host *);
+extern int rom_lock(struct scsi_qla_host *);
+extern void rom_unlock(struct scsi_qla_host *);
+extern int rom_fast_read(struct scsi_qla_host *, int , int*);
+extern int qla82xx_pci_mem_read_2M(struct scsi_qla_host *, u64, void*, int);
+extern int qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha, u64, void*, int);
+extern int qla82xx_pci_write_immediate_2M(struct scsi_qla_host *, u64, u32);
+extern u32 qla82xx_pci_read_immediate_2M(struct scsi_qla_host *, u64);
+extern void qla80xx_update_crb_int_ptr(struct scsi_qla_host *);
+
+extern int qla82xx_isp_reset(struct scsi_qla_host *ha);
+extern uint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha);
+extern uint16_t qla82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha);
+extern uint16_t qla82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha);
+void qla82xx_interrupt_service_routine(struct scsi_qla_host *ha, uint32_t intr_status);
+int qla82xx_get_sys_info(struct scsi_qla_host *ha);
+void qla82xx_init_local_data(struct scsi_qla_host *ha);
+void qla82xx_watchdog(struct scsi_qla_host *ha);
+int qla82xx_stop_firmware(struct scsi_qla_host *ha);
+void qla82xx_restore_known_fw_state(struct scsi_qla_host *ha);
+
 int qla4xxx_send_marker_iocb(struct scsi_qla_host *ha,
 	struct ddb_entry *ddb_entry, int lun);
-void sp_put(struct scsi_qla_host *ha, struct srb *sp);
 int qla4_is_relogin_allowed(struct scsi_qla_host *ha, uint32_t conn_err);
 
+int qla82xx_get_flash_info(struct scsi_qla_host *ha);
+void qla82xx_enable_intrs(struct scsi_qla_host *ha);
+void qla82xx_disable_intrs(struct scsi_qla_host *ha);
+int qla82xx_enable_msix(struct scsi_qla_host *ha);
+void qla82xx_disable_msix(struct scsi_qla_host *ha);
+irqreturn_t qla82xx_msi_handler(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t qla82xx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t qla82xx_msix_rsp_q(int irq, void *dev_id);
+void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res);
+void qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha);
+void qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha);
+int qla82xx_idc_lock(struct scsi_qla_host *ha);
+void qla82xx_idc_unlock(struct scsi_qla_host *ha);
+int qla82xx_device_state_handler(struct scsi_qla_host *ha);
+void qla82xx_need_qsnt_handler(struct scsi_qla_host *ha);
+void qla82xx_clear_drv_active(struct scsi_qla_host *ha);
 
-extern int extended_error_logging;
+extern int ql4xextended_error_logging;
 extern int ql4xdiscoverywait;
 extern int ql4xdontresethba;
-extern int ql4_mod_unload;
+extern int ql4_demo_code;
+extern int ql4xenablemsix;
 #endif				/* _QLA4x_GBL_H */
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index d38d39b..cf5a4e7 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -86,6 +86,25 @@ void qla4xxx_free_ddb_list(struct scsi_qla_host *ha)
 }
 
 /**
+ * qla4xxx_init_response_q_entries() - Initializes response queue entries.
+ * @ha: HA context
+ *
+ * Beginning of request ring has initialization control block already built
+ * by nvram config routine.
+ **/
+static void qla4xxx_init_response_q_entries(struct scsi_qla_host *ha)
+{
+   uint16_t cnt;
+   struct response_q *pkt;
+
+   pkt = (struct response_q *)ha->response_ptr;
+   for (cnt = 0; cnt < RESPONSE_QUEUE_DEPTH; cnt++) {
+       pkt->signature = RESPONSE_PROCESSED;
+       pkt++;
+   }
+}
+
+/**
  * qla4xxx_init_rings - initialize hw queues
  * @ha: pointer to host adapter structure.
  *
@@ -110,35 +129,43 @@ int qla4xxx_init_rings(struct scsi_qla_host *ha)
 	ha->response_out = 0;
 	ha->response_ptr = &ha->response_ring[ha->response_out];
 
-	/*
-	 * Initialize DMA Shadow registers.  The firmware is really supposed to
-	 * take care of this, but on some uniprocessor systems, the shadow
-	 * registers aren't cleared-- causing the interrupt_handler to think
-	 * there are responses to be processed when there aren't.
-	 */
-	ha->shadow_regs->req_q_out = __constant_cpu_to_le32(0);
-	ha->shadow_regs->rsp_q_in = __constant_cpu_to_le32(0);
-	wmb();
+	if (is_qla8022(ha)) {
+		writel(0, (unsigned long  __iomem *)&ha->qla82xx_reg->req_q_out);
+		writel(0, (unsigned long  __iomem *)&ha->qla82xx_reg->rsp_q_in);
+		writel(0, (unsigned long  __iomem *)&ha->qla82xx_reg->rsp_q_out);
+	} else {
+		/*
+		 * Initialize DMA Shadow registers.  The firmware is really supposed to
+		 * take care of this, but on some uniprocessor systems, the shadow
+		 * registers aren't cleared-- causing the interrupt_handler to think
+		 * there are responses to be processed when there aren't.
+		 */
+		ha->shadow_regs->req_q_out = __constant_cpu_to_le32(0);
+		ha->shadow_regs->rsp_q_in = __constant_cpu_to_le32(0);
+		wmb();
 
-	writel(0, &ha->reg->req_q_in);
-	writel(0, &ha->reg->rsp_q_out);
-	readl(&ha->reg->rsp_q_out);
+		writel(0, &ha->reg->req_q_in);
+		writel(0, &ha->reg->rsp_q_out);
+		readl(&ha->reg->rsp_q_out);
+	}
 
 	/* Initialize active array */
 	for (i = 0; i < MAX_SRBS; i++)
 		ha->active_srb_array[i] = NULL;
 
+	qla4xxx_init_response_q_entries(ha);
+
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	return QLA_SUCCESS;
 }
 
 /**
- * qla4xxx_validate_mac_address - validate adapter MAC address(es)
+ * qla4xxx_get_sys_info - Get sys info params
  * @ha: pointer to host adapter structure.
  *
  **/
-static int qla4xxx_validate_mac_address(struct scsi_qla_host *ha)
+int qla4xxx_get_sys_info(struct scsi_qla_host *ha)
 {
 	struct flash_sys_info *sys_info;
 	dma_addr_t sys_info_dma;
@@ -150,7 +177,7 @@ static int qla4xxx_validate_mac_address(struct scsi_qla_host *ha)
 		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
 			      ha->host_no, __func__));
 
-		goto exit_validate_mac_no_free;
+		goto exit_get_sys_info;
 	}
 	memset(sys_info, 0, sizeof(*sys_info));
 
@@ -160,7 +187,7 @@ static int qla4xxx_validate_mac_address(struct scsi_qla_host *ha)
 		DEBUG2(printk("scsi%ld: %s: get_flash FLASH_OFFSET_SYS_INFO "
 			      "failed\n", ha->host_no, __func__));
 
-		goto exit_validate_mac;
+		goto exit_sys_info_free;
 	}
 
 	/* Save M.A.C. address & serial_number */
@@ -173,11 +200,11 @@ static int qla4xxx_validate_mac_address(struct scsi_qla_host *ha)
 
 	status = QLA_SUCCESS;
 
- exit_validate_mac:
+ exit_sys_info_free:
 	dma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,
 			  sys_info_dma);
 
- exit_validate_mac_no_free:
+ exit_get_sys_info:
 	return status;
 }
 
@@ -211,67 +238,57 @@ qla4xxx_wait_for_ip_config(struct scsi_qla_host *ha)
 
 	if (is_ipv4_enabled(ha) && is_ipv6_enabled(ha)) {
 		if (((ha->addl_fw_state & FW_ADDSTATE_DHCPv4_ENABLED) != 0) &&
-		    ((ha->addl_fw_state & FW_ADDSTATE_DHCPv4_LEASE_ACQUIRED)
-			== 0)) {
+		    ((ha->addl_fw_state & FW_ADDSTATE_DHCPv4_LEASE_ACQUIRED) == 0)) {
 			ipv4_wait = 1;
 		}
-		if (((ha->ipv6_addl_options &
-		    IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) != 0) &&
+		if (((ha->ipv6_addl_options & IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) != 0) &&
 		     ((ha->ipv6_link_local_state == IP_ADDRSTATE_ACQUIRING) ||
 		      (ha->ipv6_addr0_state == IP_ADDRSTATE_ACQUIRING) ||
 		      (ha->ipv6_addr1_state == IP_ADDRSTATE_ACQUIRING))) {
 
 			ipv6_wait = 1;
 
-			if ((ha->ipv6_link_local_state ==
-			    IP_ADDRSTATE_PREFERRED) ||
+			if ((ha->ipv6_link_local_state == IP_ADDRSTATE_PREFERRED) ||
 			    (ha->ipv6_addr0_state == IP_ADDRSTATE_PREFERRED) ||
 			    (ha->ipv6_addr1_state == IP_ADDRSTATE_PREFERRED)) {
-				DEBUG2(printk(KERN_INFO "scsi%ld: %s: Preferred"
-					" IP configured. Don't wait! \n",
+				DEBUG2(printk("scsi%ld: %s: "
+					"Preferred IP configured.  Don't wait! \n",
 					ha->host_no, __func__));
 				ipv6_wait = 0;
 			}
 			if (memcmp(&ha->ipv6_default_router_addr, ip_address,
 				   IPv6_ADDR_LEN) == 0) {
-				DEBUG2(printk("scsi%ld: %s: No Router"
-					" configured.  Don't wait! \n",
+				DEBUG2(printk("scsi%ld: %s: "
+					"No Router configured.  Don't wait! \n",
 					ha->host_no, __func__));
 				ipv6_wait = 0;
 			}
-			if ((ha->ipv6_default_router_state ==
-				IPV6_RTRSTATE_MANUAL) &&
-			    (ha->ipv6_link_local_state ==
-				IP_ADDRSTATE_TENTATIVE) &&
+			if ((ha->ipv6_default_router_state == IPV6_RTRSTATE_MANUAL) &&
+			    (ha->ipv6_link_local_state == IP_ADDRSTATE_TENTATIVE) &&
 			    (memcmp(&ha->ipv6_link_local_addr,
 				   &ha->ipv6_default_router_addr, 4) == 0)) {
-				DEBUG2(printk("scsi%ld: %s: LinkLocal Router &"
-					" IP configured.  Don't wait! \n",
+				DEBUG2(printk("scsi%ld: %s: LinkLocal Router & "
+					"IP configured.  Don't wait! \n",
 					ha->host_no, __func__));
 				ipv6_wait = 0;
 			}
 		}
 		if (ipv4_wait || ipv6_wait) {
-			DEBUG2(printk("scsi%ld: %s: Wait for additional"
-					" IP(s)\n",
+			DEBUG2(printk("scsi%ld: %s: Wait for additional IP(s) \"",
 					ha->host_no, __func__));
 			if (ipv4_wait)
-				DEBUG2(printk(KERN_INFO "IPv4 "));
-			if (ha->ipv6_link_local_state ==
-				IP_ADDRSTATE_ACQUIRING)
-				DEBUG2(printk(KERN_INFO "IPv6LinkLocal "));
+				DEBUG2(printk("IPv4 "));
+			if (ha->ipv6_link_local_state == IP_ADDRSTATE_ACQUIRING)
+				DEBUG2(printk("IPv6LinkLocal "));
 			if (ha->ipv6_addr0_state == IP_ADDRSTATE_ACQUIRING)
-				DEBUG2(printk(KERN_INFO "IPv6Addr0 "));
+				DEBUG2(printk("IPv6Addr0 "));
 			if (ha->ipv6_addr1_state == IP_ADDRSTATE_ACQUIRING)
 				DEBUG2(printk("IPv6Addr1 "));
 			DEBUG2(printk("\"\n"));
 		}
 	}
 
-	if (ipv4_wait)
-		return ipv4_wait;
-	else
-		return ipv6_wait;
+	return ipv4_wait|ipv6_wait;
 }
 
 static int qla4xxx_fw_ready(struct scsi_qla_host *ha)
@@ -312,7 +329,7 @@ static int qla4xxx_fw_ready(struct scsi_qla_host *ha)
 		}
 
 		if (ha->firmware_state & FW_STATE_WAIT_AUTOCONNECT) {
-			DEBUG2(printk(KERN_INFO "scsi%ld: %s: fwstate:"
+			DEBUG2(printk("scsi%ld: %s: fwstate:"
 				      "AUTOCONNECT in progress\n",
 				      ha->host_no, __func__));
 		}
@@ -321,21 +338,18 @@ static int qla4xxx_fw_ready(struct scsi_qla_host *ha)
 			DEBUG2(printk("scsi%ld: %s: fwstate: CONFIGURING IP\n",
 				      ha->host_no, __func__));
 			/*
-			 * Check for link state after 15 secs and if link is
-			 * still DOWN then, cable is unplugged. Ignore "DHCP in
-			 * Progress/CONFIGURING IP" bit to check if firmware
-			 * is in ready state or not after 15 secs.
+			 * Check for link state after 15 secs and if link is still DOWN then,
+			 * cable is unplugged. Ignore "DHCP in Progress/CONFIGURING IP" bit
+			 * to check if firmware is in ready state or not after 15 secs.
 			 * This is applicable for both 2.x & 3.x firmware
 			 */
 			if (timeout_count <= (ADAPTER_INIT_TOV - 15)) {
 				if (ha->addl_fw_state & FW_ADDSTATE_LINK_UP) {
-					DEBUG2(printk(KERN_INFO "scsi%ld: %s: "
-						      "LINK UP "
+					DEBUG2(printk("scsi%ld: %s: LINK UP "
 						      "(Cable plugged)\n",
 						      ha->host_no, __func__));
 				} else if (ha->firmware_state &
-					(FW_STATE_CONFIGURING_IP |
-					FW_STATE_READY)) {
+					(FW_STATE_CONFIGURING_IP | FW_STATE_READY)) {
 					DEBUG2(printk("scsi%ld: %s: LINK DOWN "
 						      "(Cable unplugged)\n",
 						      ha->host_no, __func__));
@@ -346,46 +360,38 @@ static int qla4xxx_fw_ready(struct scsi_qla_host *ha)
 
 		if (ha->firmware_state == FW_STATE_READY) {
 			/* If DHCP IP Addr is available, retrieve it now. */
-			if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR,
-				&ha->dpc_flags))
+			if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))
 				qla4xxx_get_dhcp_ip_address(ha);
 
-			if (!qla4xxx_wait_for_ip_config(ha) ||
-				timeout_count == 1) {
-				DEBUG2(dev_info(&ha->pdev->dev,
-						"Firmware Ready..\n"));
-				/* The firmware is ready to
-				 * process SCSI commands. */
+			if (!qla4xxx_wait_for_ip_config(ha) || timeout_count == 1) {
+				DEBUG2(dev_info(&ha->pdev->dev, "Firmware Ready..\n"));
+				/* The firmware is ready to process SCSI commands. */
 				DEBUG2(dev_info(&ha->pdev->dev,
-						"scsi%ld: %s: "
-						"MEDIA TYPE - %s\n",
-						ha->host_no,  __func__,
-						(ha->addl_fw_state &
-						FW_ADDSTATE_OPTICAL_MEDIA)
-						!= 0 ? "OPTICAL" : "COPPER"));
+						  "scsi%ld: %s: MEDIA TYPE - %s\n",
+						  ha->host_no,
+						  __func__, (ha->addl_fw_state &
+							     FW_ADDSTATE_OPTICAL_MEDIA)
+						  != 0 ? "OPTICAL" : "COPPER"));
 				DEBUG2(dev_info(&ha->pdev->dev,
-						  "scsi%ld: %s: "
-						"DHCPv4 STATE Enabled "
-						"%s\n",
-						ha->host_no, __func__,
-						(ha->addl_fw_state &
-						FW_ADDSTATE_DHCPv4_ENABLED) !=
-						0 ?
-						"YES" : "NO"));
+						  "scsi%ld: %s: DHCPv4 STATE Enabled "
+						  "%s\n",
+						  ha->host_no, __func__,
+						  (ha->addl_fw_state &
+						   FW_ADDSTATE_DHCPv4_ENABLED) != 0 ?
+						  "YES" : "NO"));
 				DEBUG2(dev_info(&ha->pdev->dev,
-						"scsi%ld: %s: LINK %s\n",
-						ha->host_no, __func__,
-						(ha->addl_fw_state &
-						 FW_ADDSTATE_LINK_UP) != 0 ?
-						"UP" : "DOWN"));
+						  "scsi%ld: %s: LINK %s\n",
+						  ha->host_no, __func__,
+						  (ha->addl_fw_state &
+						   FW_ADDSTATE_LINK_UP) != 0 ?
+						  "UP" : "DOWN"));
 				DEBUG2(dev_info(&ha->pdev->dev,
-						"scsi%ld: %s: iSNS Service "
-						"Started %s\n",
-						ha->host_no, __func__,
-						(ha->addl_fw_state &
-						FW_ADDSTATE_ISNS_SVC_ENABLED)
-						!= 0 ?
-						"YES" : "NO"));
+						  "scsi%ld: %s: iSNS Service "
+						  "Started %s\n",
+						  ha->host_no, __func__,
+						  (ha->addl_fw_state &
+						   FW_ADDSTATE_ISNS_SVC_ENABLED) != 0 ?
+						  "YES" : "NO"));
 
 				ready = 1;
 				break;
@@ -460,7 +466,7 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 	if (fw_ddb_entry == NULL) {
 		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
 			      ha->host_no, __func__));
-		return NULL;
+		goto exit_get_ddb_entry_no_free;
 	}
 
 	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
@@ -470,7 +476,7 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 		DEBUG2(printk("scsi%ld: %s: failed get_ddb_entry for "
 			      "fw_ddb_index %d\n", ha->host_no, __func__,
 			      fw_ddb_index));
-		return NULL;
+		goto exit_get_ddb_entry;
 	}
 
 	/* Allocate DDB if not already allocated. */
@@ -488,6 +494,7 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 		}
 	}
 
+	/* if not found allocate new ddb */
 	if (!found) {
 		DEBUG2(printk("scsi%ld: %s: ddb[%d] not found - allocating "
 			      "new ddb\n", ha->host_no, __func__,
@@ -496,10 +503,11 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 		ddb_entry = qla4xxx_alloc_ddb(ha, fw_ddb_index);
 	}
 
-	/* if not found allocate new ddb */
+exit_get_ddb_entry:
 	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,
 			  fw_ddb_entry_dma);
 
+exit_get_ddb_entry_no_free:
 	return ddb_entry;
 }
 
@@ -562,8 +570,7 @@ int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,
 	ddb_entry->exe_throttle = le16_to_cpu(fw_ddb_entry->exec_throttle);
 	ddb_entry->default_relogin_timeout =
 		le16_to_cpu(fw_ddb_entry->def_timeout);
-	ddb_entry->default_time2wait =
-		le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);
+	ddb_entry->default_time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);
 
 	/* Update index in case it changed */
 	ddb_entry->fw_ddb_index = fw_ddb_index;
@@ -632,6 +639,12 @@ struct ddb_entry * qla4xxx_alloc_ddb(struct scsi_qla_host *ha,
 	atomic_set(&ddb_entry->relogin_timer, 0);
 	atomic_set(&ddb_entry->relogin_retry_count, 0);
 	atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
+
+	dev_info(&ha->pdev->dev,
+		"scsi%ld: %s: ddb[%d] os[%d] marked ONLINE\n",
+		ha->host_no, __func__, ddb_entry->fw_ddb_index,
+		ddb_entry->os_target_id);
+
 	list_add_tail(&ddb_entry->list, &ha->ddb_list);
 	ha->fw_ddb_index_map[fw_ddb_index] = ddb_entry;
 	ha->tot_ddbs++;
@@ -656,19 +669,19 @@ int qla4_is_relogin_allowed(struct scsi_qla_host *ha, uint32_t conn_err)
 	login_rsp_sts_class = ((conn_err & 0x0000ff00) >> 8);
 
 	if (err_code == 0x1c || err_code == 0x06) {
-		DEBUG2(dev_info(&ha->pdev->dev,
-			": conn_err=0x%08x, send target completed or access"
-			" denied failure\n", conn_err));
-		relogin = 0;
+	       DEBUG2(dev_info(&ha->pdev->dev,
+		       ": conn_err=0x%08x, send target completed or access"
+		       " denied failure\n", conn_err));
+	       relogin = 0;
 	}
 
 	if ((err_code == 0x08) && (login_rsp_sts_class == 0x02)) {
-		/* Login Response PDU returned an error.
-		   Login Response Status in Error Code Detail
-		   indicates login should not be retried.*/
-		DEBUG2(dev_info(&ha->pdev->dev,
-			": conn_err=0x%08x, do not retry relogin\n", conn_err));
-		relogin = 0;
+	       /* Login Response PDU returned an error.
+		  Login Response Status in Error Code Detail
+		  indicates login should not be retried.*/
+	       DEBUG2(dev_info(&ha->pdev->dev,
+		       ": conn_err=0x%08x, do not retry relogin\n", conn_err));
+	       relogin = 0;
 	}
 
 	return relogin;
@@ -987,7 +1000,7 @@ int qla4xxx_reinitialize_ddb_list(struct scsi_qla_host *ha)
  * The ddb entry must be assigned prior to making this call.
  **/
 int qla4xxx_relogin_device(struct scsi_qla_host *ha,
-			   struct ddb_entry *ddb_entry)
+				struct ddb_entry *ddb_entry)
 {
 	uint16_t relogin_timer;
 
@@ -995,7 +1008,7 @@ int qla4xxx_relogin_device(struct scsi_qla_host *ha,
 			    (uint16_t)RELOGIN_TOV);
 	atomic_set(&ddb_entry->relogin_timer, relogin_timer);
 
-	DEBUG2(printk("scsi%ld: Relogin index [%d]. TOV=%d\n", ha->host_no,
+	DEBUG2(printk("scsi%ld: Relogin ddb [%d]. TOV=%d\n", ha->host_no,
 		      ddb_entry->fw_ddb_index, relogin_timer));
 
 	qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index, 0);
@@ -1054,7 +1067,22 @@ static int qla4xxx_config_nvram(struct scsi_qla_host *ha)
 	return QLA_SUCCESS;
 }
 
-static void qla4x00_pci_config(struct scsi_qla_host *ha)
+/**
+ * qla82xx_pci_config() - Setup ISP30xx PCI configuration registers.
+ * @ha: HA context
+ **/
+void qla82xx_pci_config(struct scsi_qla_host *ha)
+{
+	pci_set_master(ha->pdev);
+
+	/* FIXME: TODO - Check for memory write invalidate setting
+	 * Any parity settings
+	 * Adjust Max Read Request size
+	 * PCI disable ROM
+	 */
+}
+
+void qla4xxx_pci_config(struct scsi_qla_host *ha)
 {
 	uint16_t w;
 
@@ -1091,7 +1119,7 @@ static int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)
 	 * connections use the same TCP ports after each reboot,
 	 * causing some connections to not get re-established.
 	 */
-	DEBUG(printk("scsi%d: %s: Start firmware from flash ROM\n",
+	DEBUG(printk("scsi%ld: %s: Start firmware from flash ROM\n",
 		     ha->host_no, __func__));
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
@@ -1108,7 +1136,7 @@ static int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	/* Wait for firmware to come UP. */
-	DEBUG2(printk(KERN_INFO "scsi%ld: %s: Wait up to %d seconds for "
+	DEBUG2(printk("scsi%ld: %s: Wait up to %d seconds for "
 			"boot firmware to complete... \n",
 			ha->host_no, __func__, FIRMWARE_UP_TOV));
 	max_wait_time = jiffies + (FIRMWARE_UP_TOV * HZ);
@@ -1159,6 +1187,7 @@ int ql4xxx_lock_drvr_wait(struct scsi_qla_host *a)
 #define QL4_LOCK_DRVR_SLEEP	1
 
 	int drvr_wait = QL4_LOCK_DRVR_WAIT;
+
 	while (drvr_wait) {
 		if (ql4xxx_lock_drvr(a) == 0) {
 			ssleep(QL4_LOCK_DRVR_SLEEP);
@@ -1185,7 +1214,7 @@ int ql4xxx_lock_drvr_wait(struct scsi_qla_host *a)
  * This routine performs the neccessary steps to start the firmware for
  * the QLA4010 adapter.
  **/
-static int qla4xxx_start_firmware(struct scsi_qla_host *ha)
+int qla4xxx_start_firmware(struct scsi_qla_host *ha)
 {
 	unsigned long flags = 0;
 	uint32_t mbox_status;
@@ -1264,9 +1293,9 @@ static int qla4xxx_start_firmware(struct scsi_qla_host *ha)
 	if (soft_reset) {
 		DEBUG(printk("scsi%ld: %s: Issue Soft Reset\n", ha->host_no,
 			     __func__));
-		status = qla4xxx_soft_reset(ha);
+		status = qla4xxx_soft_reset(ha); /* NOTE: acquires drvr lock again, but ok */
 		if (status == QLA_ERROR) {
-			DEBUG(printk("scsi%d: %s: Soft Reset failed!\n",
+			DEBUG(printk("scsi%ld: %s: Soft Reset failed!\n",
 				     ha->host_no, __func__));
 			ql4xxx_unlock_drvr(ha);
 			return QLA_ERROR;
@@ -1285,7 +1314,6 @@ static int qla4xxx_start_firmware(struct scsi_qla_host *ha)
 
 	ql4xxx_unlock_drvr(ha);
 	if (status == QLA_SUCCESS) {
-		qla4xxx_get_fw_version(ha);
 		if (test_and_clear_bit(AF_GET_CRASH_RECORD, &ha->flags))
 			qla4xxx_get_crash_record(ha);
 	} else {
@@ -1312,18 +1340,21 @@ int qla4xxx_initialize_adapter(struct scsi_qla_host *ha,
 	int status = QLA_ERROR;
 	int8_t ip_address[IP_ADDR_LEN] = {0} ;
 
-	clear_bit(AF_ONLINE, &ha->flags);
 	ha->eeprom_cmd_data = 0;
 
-	qla4x00_pci_config(ha);
+	dev_info(&ha->pdev->dev, "Configuring PCI space...\n");
+	ha->isp_ops->pci_config(ha);
 
-	qla4xxx_disable_intrs(ha);
+	ha->isp_ops->disable_intrs(ha);
 
 	/* Initialize the Host adapter request/response queues and firmware */
-	if (qla4xxx_start_firmware(ha) == QLA_ERROR)
+	if (ha->isp_ops->start_firmware(ha) == QLA_ERROR)
 		goto exit_init_hba;
 
-	if (qla4xxx_validate_mac_address(ha) == QLA_ERROR)
+	if (qla4xxx_get_fw_version(ha) == QLA_ERROR)
+		goto exit_init_hba;
+
+	if (ha->isp_ops->get_sys_info(ha) == QLA_ERROR)
 		goto exit_init_hba;
 
 	if (qla4xxx_init_local_data(ha) == QLA_ERROR)
@@ -1375,6 +1406,8 @@ int qla4xxx_initialize_adapter(struct scsi_qla_host *ha,
 
 exit_init_hba0:
 	set_bit(AF_ONLINE, &ha->flags);
+	dev_info(&ha->pdev->dev, "%s: adapter ONLINE\n", __func__);
+
 exit_init_hba:
 	return status;
 }
@@ -1491,8 +1524,7 @@ int qla4xxx_process_ddb_changed(struct scsi_qla_host *ha, uint32_t fw_ddb_index,
 		 * the device came back.
 		 */
 	} else {
-		/* Device went away, try to relogin. */
-		/* Mark device missing */
+		/* Device went away, mark device missing */
 		if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
 			qla4xxx_mark_device_missing(ha, ddb_entry);
 		/*
@@ -1521,6 +1553,19 @@ int qla4xxx_process_ddb_changed(struct scsi_qla_host *ha, uint32_t fw_ddb_index,
 			atomic_set(&ddb_entry->relogin_timer, 0);
 			atomic_set(&ddb_entry->retry_relogin_timer,
 				   ddb_entry->default_time2wait + 4);
+			DEBUG(printk("scsi%ld: %s: ddb[%d] "
+			      "initiate relogin after %d seconds\n",
+			      ha->host_no, __func__,
+			      ddb_entry->fw_ddb_index,
+			      ddb_entry->default_time2wait + 4));
+		} else {
+			DEBUG(printk("scsi%ld: %s:  ddb[%d] "
+				"relogin not initiated, State=%d, "
+				"ddb_entry->flags=0x%lx\n",
+				ha->host_no, __func__,
+				ddb_entry->fw_ddb_index,
+				ddb_entry->fw_ddb_device_state,
+				ddb_entry->flags));
 		}
 	}
 
diff --git a/drivers/scsi/qla4xxx/ql4_inline.h b/drivers/scsi/qla4xxx/ql4_inline.h
index 6375eb0..4cc9f12 100644
--- a/drivers/scsi/qla4xxx/ql4_inline.h
+++ b/drivers/scsi/qla4xxx/ql4_inline.h
@@ -29,12 +29,29 @@ qla4xxx_lookup_ddb_by_fw_index(struct scsi_qla_host *ha, uint32_t fw_ddb_index)
 		ddb_entry = ha->fw_ddb_index_map[fw_ddb_index];
 	}
 
-	DEBUG3(printk("scsi%d: %s: index [%d], ddb_entry = %p\n",
+	DEBUG3(printk("scsi%ld: %s: ddb [%d], ddb_entry = %p\n",
 	    ha->host_no, __func__, fw_ddb_index, ddb_entry));
 
 	return ddb_entry;
 }
 
+static inline struct ddb_entry *
+qla4xxx_lookup_ddb_by_os_index(struct scsi_qla_host *ha, int os_idx)
+{
+	struct ddb_entry *ddb_entry = NULL;
+	struct ddb_entry *detemp;
+
+	list_for_each_entry_safe(ddb_entry, detemp, &ha->ddb_list, list) {
+		if (ddb_entry->os_target_id == os_idx)
+		break;
+	}
+
+	DEBUG3(printk("scsi%ld: %s: ddb[%d], ddb_entry = %p\n",
+		ha->host_no, __func__, fw_ddb_index, ddb_entry));
+
+	return ddb_entry;
+}
+
 static inline void
 __qla4xxx_enable_intrs(struct scsi_qla_host *ha)
 {
diff --git a/drivers/scsi/qla4xxx/ql4_iocb.c b/drivers/scsi/qla4xxx/ql4_iocb.c
index dbd2458..0b489b9 100644
--- a/drivers/scsi/qla4xxx/ql4_iocb.c
+++ b/drivers/scsi/qla4xxx/ql4_iocb.c
@@ -20,7 +20,7 @@ qla4xxx_space_in_req_ring(struct scsi_qla_host *ha, uint16_t req_cnt)
 
 	/* Calculate number of free request entries. */
 	if ((req_cnt + 2) >= ha->req_q_count) {
-		cnt = (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+		cnt = ha->isp_ops->rd_shdw_req_q_out(ha);
 		if (ha->request_in < cnt)
 			ha->req_q_count = cnt - ha->request_in;
 		else
@@ -110,9 +110,7 @@ int qla4xxx_send_marker_iocb(struct scsi_qla_host *ha,
 	int_to_scsilun(lun, &marker_entry->lun);
 	wmb();
 
-	/* Tell ISP it's got a new I/O request */
-	writel(ha->request_in, &ha->reg->req_q_in);
-	readl(&ha->reg->req_q_in);
+	ha->isp_ops->queue_iocb(ha);
 
 exit_send_marker:
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
@@ -209,6 +207,72 @@ void qla4xxx_build_scsi_iocbs(struct srb *srb,
 }
 
 /**
+ * qla82xx_queue_iocb - Tell ISP it's got new request(s)
+ * @ha: pointer to host adapter structure.
+ *
+ * This routine is notifies the ISP that one or more new request
+ * queue entries have been placed on the request queue.
+ **/
+void qla82xx_queue_iocb(struct scsi_qla_host *ha)
+{
+	uint32_t   dbval = 0;
+	unsigned long wtime;
+
+	dbval = 0x14 | (ha->portnum << 5);
+	dbval = dbval | (0 << 8) | (ha->request_in << 16);
+	writel(dbval, (unsigned long __iomem *)ha->nx_db_wr_ptr);
+	wmb();
+
+	wtime = jiffies + (2 * HZ);
+	while (readl(ha->nx_db_rd_ptr) != dbval &&
+			!time_after_eq(jiffies, wtime)) {
+		writel(dbval, (unsigned long __iomem *)ha->nx_db_wr_ptr);
+		wmb();
+	}
+}
+
+/**
+ * qla82xx_complete_iocb - Tell ISP we're done with response(s)
+ * @ha: pointer to host adapter structure.
+ *
+ * This routine is notifies the ISP that one or more response/completion
+ * queue entries have been processed by the driver.
+ * This also clears the interrupt.
+ **/
+void qla82xx_complete_iocb(struct scsi_qla_host *ha)
+{
+	writel(ha->response_out, &ha->qla82xx_reg->rsp_q_out);
+	readl(&ha->qla82xx_reg->rsp_q_out);
+}
+
+/**
+ * qla4xxx_queue_iocb - Tell ISP it's got new request(s)
+ * @ha: pointer to host adapter structure.
+ *
+ * This routine is notifies the ISP that one or more request
+ * queue entries have been placed on the request queue.
+ **/
+void qla4xxx_queue_iocb(struct scsi_qla_host *ha)
+{
+	writel(ha->request_in, &ha->reg->req_q_in);
+	readl(&ha->reg->req_q_in);
+}
+
+/**
+ * qla4xxx_complete_iocb - Tell ISP we're done with response(s)
+ * @ha: pointer to host adapter structure.
+ *
+ * This routine is notifies the ISP that one or more response/completion
+ * queue entries have been processed by the driver.
+ * This also clears the interrupt.
+ **/
+void qla4xxx_complete_iocb(struct scsi_qla_host *ha)
+{
+	writel(ha->response_out, &ha->reg->rsp_q_out);
+	readl(&ha->reg->rsp_q_out);
+}
+
+/**
  * qla4xxx_send_command_to_isp - issues command to HBA
  * @ha: pointer to host adapter structure.
  * @srb: pointer to SCSI Request Block to be sent to ISP
@@ -262,10 +326,9 @@ int qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb *srb)
 	 * garbage for pointers.
 	 */
 	if (!test_bit(AF_ONLINE, &ha->flags)) {
-		DEBUG2(printk(KERN_INFO
-				"scsi%ld: %s: Adapter OFFLINE! "
-				"Do not issue command.\n",
-				ha->host_no, __func__));
+		DEBUG2(printk("scsi%ld: %s: Adapter OFFLINE! "
+			      "Do not issue command.\n",
+			      ha->host_no, __func__));
 		goto queuing_error;
 	}
 
@@ -364,9 +427,8 @@ int qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb *srb)
 	srb->iocb_cnt = req_cnt;
 	ha->req_q_count -= req_cnt;
 
-	/* Debug print statements */
-	writel(ha->request_in, &ha->reg->req_q_in);
-	readl(&ha->reg->req_q_in);
+	/* Tell ISP it's got a new I/O request */
+	ha->isp_ops->queue_iocb(ha);
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	return QLA_SUCCESS;
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
index b5ac5bf..5220b8c 100644
--- a/drivers/scsi/qla4xxx/ql4_isr.c
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -13,12 +13,12 @@
 #include <scsi/iscsi_proto.h>
 
 /**
- * qla4xxx_copy_sense - copy sense data	into cmd sense buffer
+ * qla4xxx_check_and_copy_sense - copy sense data into cmd sense buffer
  * @ha: Pointer to host adapter structure.
  * @sts_entry: Pointer to status entry structure.
  * @srb: Pointer to srb structure.
  **/
-static void qla4xxx_copy_sense(struct scsi_qla_host *ha,
+static void qla4xxx_check_and_copy_sense(struct scsi_qla_host *ha,
                                struct status_entry *sts_entry,
                                struct srb *srb)
 {
@@ -60,6 +60,34 @@ static void qla4xxx_copy_sense(struct scsi_qla_host *ha,
 	else
 		ha->status_srb = NULL;
 
+	if ((srb->flags & SRB_SCSI_PASSTHRU))
+		return;
+
+	/* check for vaild sense data */
+	if ((sts_entry->senseData[0] & 0x70) != 0x70)
+		return;
+
+	switch (sts_entry->senseData[2] & 0x0f) {
+	case UNIT_ATTENTION:
+		if (sts_entry->senseData[12] == 0x3F &&
+			sts_entry->senseData[13] == 0x0E) {
+			struct ddb_entry *ddb_entry;
+
+			ddb_entry = qla4xxx_lookup_ddb_by_os_index(ha,
+				cmd->device->id);
+			if (ddb_entry) {
+				dev_info(&ha->pdev->dev, "%s: ddb[%d] os[%d] "
+					"schedule dynamic lun scan\n",
+					__func__, ddb_entry->fw_ddb_index,
+					ddb_entry->os_target_id);
+
+				set_bit(DF_DYNAMIC_LUN_SCAN_NEEDED,
+					&ddb_entry->flags);
+				set_bit(DPC_DYNAMIC_LUN_SCAN, &ha->dpc_flags);
+			}
+		}
+		break;
+	}
 }
 
 /**
@@ -83,15 +111,13 @@ qla4xxx_status_cont_entry(struct scsi_qla_host *ha,
 	cmd = srb->cmd;
 	if (cmd == NULL) {
 		DEBUG2(printk("scsi%ld: %s: Cmd already returned back to OS "
-			"srb=%p srb->state:%d\n", ha->host_no,
-			__func__, srb, srb->state));
+			"srb=%p srb->state:%d\n", ha->host_no, __func__, srb, srb->state));
 		ha->status_srb = NULL;
 		return;
 	}
 
 	/* Copy sense data. */
-	sense_len = min(srb->req_sense_len,
-			(uint16_t) IOCB_MAX_EXT_SENSEDATA_LEN);
+	sense_len = min(srb->req_sense_len, (uint16_t) IOCB_MAX_EXT_SENSEDATA_LEN);
 	memcpy(srb->req_sense_ptr, sts_cont->extSenseData, sense_len);
 	DEBUG5(qla4xxx_dump_buffer(srb->req_sense_ptr, sense_len));
 
@@ -100,7 +126,7 @@ qla4xxx_status_cont_entry(struct scsi_qla_host *ha,
 
 	/* Place command on done queue. */
 	if (srb->req_sense_len == 0) {
-		sp_put(ha, srb);
+		kref_put(&srb->srb_ref, qla4xxx_srb_compl);
 		ha->status_srb = NULL;
 	}
 }
@@ -119,8 +145,7 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 	struct ddb_entry *ddb_entry;
 	uint32_t residual;
 
-	srb = qla4xxx_del_from_active_array(ha,
-			le32_to_cpu(sts_entry->handle));
+	srb = qla4xxx_del_from_active_array(ha, le32_to_cpu(sts_entry->handle));
 	if (!srb) {
 		dev_warn(&ha->pdev->dev, "%s invalid status entry:"
 			" handle=0x%0x\n", __func__, sts_entry->handle);
@@ -154,9 +179,8 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 		}
 		if (sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) {
 			cmd->resid = residual;
-			if (!scsi_status &&
-				((cmd->request_bufflen - residual) <
-				cmd->underflow)) {
+			if (!scsi_status && ((cmd->request_bufflen - residual) <
+				   cmd->underflow)) {
 				cmd->result = DID_ERROR << 16;
 				break;
 			}
@@ -168,7 +192,7 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 			break;
 
 		/* Copy Sense Data into sense buffer. */
-		qla4xxx_copy_sense(ha, sts_entry, srb);
+		qla4xxx_check_and_copy_sense(ha, sts_entry, srb);
 		break;
 
 	case SCS_INCOMPLETE:
@@ -194,9 +218,11 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 		break;
 
 	case SCS_TIMEOUT:
-		DEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: Timeout\n",
+		DEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: Timeout, "
+				"sts_handle=0x%x\n",
 			      ha->host_no, cmd->device->channel,
-			      cmd->device->id, cmd->device->lun));
+			      cmd->device->id, cmd->device->lun,
+				  sts_entry->handle));
 
 		cmd->result = DID_BUS_BUSY << 16;
 
@@ -235,7 +261,7 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 				break;
 
 			/* Copy Sense Data into sense buffer. */
-			qla4xxx_copy_sense(ha, sts_entry, srb);
+			qla4xxx_check_and_copy_sense(ha, sts_entry, srb);
 
 			DEBUG2(printk("scsi%ld:%d:%d:%d: %s: sense key = %x, "
 				      "ASC/ASCQ = %02x/%02x\n", ha->host_no,
@@ -292,9 +318,10 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 		 * state change AEN soon.
 		 */
 		DEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: DEVICE_UNAVAILABLE "
-			      "or DEVICE_LOGGED_OUT\n",
+			      "or DEVICE_LOGGED_OUT, sts_handle=0x%x\n",
 			      ha->host_no, cmd->device->channel,
-			      cmd->device->id, cmd->device->lun));
+			      cmd->device->id, cmd->device->lun,
+				  sts_entry->handle));
 
 		if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
 			qla4xxx_mark_device_missing(ha, ddb_entry);
@@ -327,7 +354,7 @@ status_entry_exit:
 	/* complete the request, if not waiting for status_continuation pkt */
 	srb->cc_stat = sts_entry->completionStatus;
 	if (ha->status_srb == NULL)
-		sp_put(ha, srb);
+		kref_put(&srb->srb_ref, qla4xxx_srb_compl);
 }
 
 /**
@@ -337,7 +364,7 @@ status_entry_exit:
  * This routine process response queue completions in interrupt context.
  * Hardware_lock locked upon entry
  **/
-static void qla4xxx_process_response_queue(struct scsi_qla_host * ha)
+void qla4xxx_process_response_queue(struct scsi_qla_host *ha)
 {
 	uint32_t count = 0;
 	struct srb *srb = NULL;
@@ -347,9 +374,7 @@ static void qla4xxx_process_response_queue(struct scsi_qla_host * ha)
 	struct async_msg_pdu_iocb *apdu_iocb;
 
 	/* Process all responses from response queue */
-	while ((ha->response_in =
-		(uint16_t)le32_to_cpu(ha->shadow_regs->rsp_q_in)) !=
-	       ha->response_out) {
+	while ((ha->response_ptr->signature != RESPONSE_PROCESSED)) {
 		sts_entry = (struct status_entry *) ha->response_ptr;
 		count++;
 
@@ -379,23 +404,22 @@ static void qla4xxx_process_response_queue(struct scsi_qla_host * ha)
 			pdu_hdr = (struct iscsi_hdr *)apdu->iscsi_pdu_hdr;
 			if (pdu_hdr->hlength || pdu_hdr->dlength[0] ||
 				pdu_hdr->dlength[1] || pdu_hdr->dlength[2]){
-				apdu_iocb = kmalloc(
-					sizeof(struct async_msg_pdu_iocb),
-					GFP_ATOMIC);
+				apdu_iocb = kmalloc(sizeof(struct async_msg_pdu_iocb),
+							GFP_ATOMIC);
 				if (apdu_iocb) {
 					memcpy(apdu_iocb->iocb, apdu,
 						sizeof(struct async_pdu_iocb));
 					list_add_tail(&apdu_iocb->list,
 							&ha->async_iocb_list);
-					DEBUG2(printk(KERN_INFO "scsi%ld:"
+					DEBUG2(printk("scsi%ld:"
 						"%s: schedule async msg pdu\n",
 						ha->host_no, __func__));
 					set_bit(DPC_ASYNC_MSG_PDU,
 							&ha->dpc_flags);
 				} else {
-					DEBUG2(printk("scsi%ld:%s: unable to"
-						" alloc ASYNC PDU\n",
-						ha->host_no, __func__));
+					DEBUG2(printk("scsi%ld:"
+							"%s: unable to alloc ASYNC PDU\n",
+							ha->host_no, __func__));
 				}
 			}
 		break;
@@ -422,7 +446,7 @@ static void qla4xxx_process_response_queue(struct scsi_qla_host * ha)
 			/* ETRY normally by sending it back with
 			 * DID_BUS_BUSY */
 			srb->cmd->result = DID_BUS_BUSY << 16;
-			sp_put(ha, srb);
+			kref_put(&srb->srb_ref, qla4xxx_srb_compl);
 			break;
 
 		case ET_CONTINUE:
@@ -442,14 +466,15 @@ static void qla4xxx_process_response_queue(struct scsi_qla_host * ha)
 				      sts_entry->hdr.entryType));
 			goto exit_prq_error;
 		}
+
+		((struct response_q *)sts_entry)->signature = RESPONSE_PROCESSED;
+		wmb();
 	}
 
 	/*
-	 * Done with responses, update the ISP For QLA4010, this also clears
-	 * the interrupt.
+	 * Tell ISP we're done with response(s). This also clears the interrupt.
 	 */
-	writel(ha->response_out, &ha->reg->rsp_q_out);
-	readl(&ha->reg->rsp_q_out);
+	ha->isp_ops->complete_iocb(ha);
 
 	return;
 
@@ -459,9 +484,7 @@ exit_prq_invalid_handle:
 		      sts_entry->completionStatus));
 
 exit_prq_error:
-	writel(ha->response_out, &ha->reg->rsp_q_out);
-	readl(&ha->reg->rsp_q_out);
-
+	ha->isp_ops->complete_iocb(ha);
 	set_bit(DPC_RESET_HA, &ha->dpc_flags);
 }
 
@@ -473,11 +496,11 @@ exit_prq_error:
  * This routine decodes the mailbox status during the ISR.
  * Hardware_lock locked upon entry. runs in interrupt context.
  **/
-static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
+void qla4xxx_isr_decode_mailbox(struct scsi_qla_host *ha,
 				       uint32_t mbox_status)
 {
 	int i;
-	uint32_t mbox_stat2, mbox_stat3;
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
 
 	if ((mbox_status == MBOX_STS_BUSY) ||
 	    (mbox_status == MBOX_STS_INTERMEDIATE_COMPLETION) ||
@@ -489,19 +512,27 @@ static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
 			 * Copy all mailbox registers to a temporary
 			 * location and set mailbox command done flag
 			 */
-			for (i = 1; i < ha->mbox_status_count; i++)
-				ha->mbox_status[i] =
-					readl(&ha->reg->mailbox[i]);
+			for (i = 0; i < ha->mbox_status_count; i++)
+				ha->mbox_status[i] = is_qla8022(ha)
+					? readl(&ha->qla82xx_reg->mailbox_out[i])
+					: readl(&ha->reg->mailbox[i]);
 
 			set_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+
+			if (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags))
+				complete(&ha->mbx_intr_comp);
 		}
 	} else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {
+		for (i = 0; i < MBOX_AEN_REG_COUNT; i++)
+			mbox_sts[i] = is_qla8022(ha)
+				? readl(&ha->qla82xx_reg->mailbox_out[i])
+				: readl(&ha->reg->mailbox[i]);
 		/* Immediately process the AENs that don't require much work.
 		 * Only queue the database_changed AENs */
 		if (ha->aen_log.count < MAX_AEN_ENTRIES) {
 			for (i = 0; i < MBOX_AEN_REG_COUNT; i++)
 				ha->aen_log.entry[ha->aen_log.count].mbox_sts[i] =
-					readl(&ha->reg->mailbox[i]);
+					mbox_sts[i];
 			ha->aen_log.count++;
 		}
 		switch (mbox_status) {
@@ -530,16 +561,15 @@ static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
 			set_bit(AF_LINK_UP, &ha->flags);
 			if (test_bit(AF_INIT_DONE, &ha->flags))
 				set_bit(DPC_LINK_CHANGED, &ha->dpc_flags);
-			DEBUG2(printk(KERN_INFO "scsi%ld: AEN %04x "
-					"Adapter LINK UP\n",
+			DEBUG2(printk("scsi%ld: AEN %04x Adapter LINK UP\n",
 					ha->host_no, mbox_status));
 			break;
 
 		case MBOX_ASTS_LINK_DOWN:
 			clear_bit(AF_LINK_UP, &ha->flags);
-			set_bit(DPC_LINK_CHANGED, &ha->dpc_flags);
-			DEBUG2(printk(KERN_INFO "scsi%ld: AEN %04x "
-					"Adapter LINK DOWN\n",
+			if (test_bit(AF_INIT_DONE, &ha->flags))
+				set_bit(DPC_LINK_CHANGED, &ha->dpc_flags);
+			DEBUG2(printk("scsi%ld: AEN %04x Adapter LINK DOWN\n",
 					ha->host_no, mbox_status));
 			break;
 
@@ -566,34 +596,31 @@ static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
 			break;
 
 		case MBOX_ASTS_IP_ADDR_STATE_CHANGED:
-			mbox_stat2 = readl(&ha->reg->mailbox[2]);
-			mbox_stat3 = readl(&ha->reg->mailbox[3]);
+			printk("scsi%ld: AEN %04x, mbox_sts[2]=%04x, mbox_sts[3]=%04x\n",
+					ha->host_no, mbox_sts[0], mbox_sts[2], mbox_sts[3]);
 
-			if ((mbox_stat3 == 5) && (mbox_stat2 == 3))
+			if ((mbox_sts[3] == 5) && (mbox_sts[2] == 3))
 				set_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);
-			else if ((mbox_stat3 == 2) && (mbox_stat2 == 5))
+			else if ((mbox_sts[3] == 2) && (mbox_sts[2] == 5))
 				set_bit(DPC_RESET_HA, &ha->dpc_flags);
 			break;
 
-		case MBOX_ASTS_MAC_ADDRESS_CHANGED:
 		case MBOX_ASTS_DNS:
 			/* No action */
 			DEBUG2(printk(KERN_INFO "scsi%ld: AEN %04x, "
 				      "mbox_sts[1]=%04x, mbox_sts[2]=%04x\n",
-				      ha->host_no, mbox_status,
-				      readl(&ha->reg->mailbox[1]),
-				      readl(&ha->reg->mailbox[2])));
+				      ha->host_no, mbox_sts[0],
+				      mbox_sts[1], mbox_sts[2]));
 			break;
 
+		case MBOX_ASTS_MAC_ADDRESS_CHANGED:
 		case MBOX_ASTS_SELF_TEST_FAILED:
 		case MBOX_ASTS_LOGIN_FAILED:
 			/* No action */
 			DEBUG2(printk("scsi%ld: AEN %04x, mbox_sts[1]=%04x, "
 				      "mbox_sts[2]=%04x, mbox_sts[3]=%04x\n",
-				      ha->host_no, mbox_status,
-				      readl(&ha->reg->mailbox[1]),
-				      readl(&ha->reg->mailbox[2]),
-				      readl(&ha->reg->mailbox[3])));
+				      ha->host_no, mbox_sts[0],
+				      mbox_sts[1], mbox_sts[2], mbox_sts[3]));
 			break;
 
 		case MBOX_ASTS_DATABASE_CHANGED:
@@ -604,22 +631,16 @@ static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
 				/* decrement available counter */
 				ha->aen_q_count--;
 
-				for (i = 1; i < MBOX_AEN_REG_COUNT; i++)
+				for (i = 0; i < MBOX_AEN_REG_COUNT; i++)
 					ha->aen_q[ha->aen_in].mbox_sts[i] =
-						readl(&ha->reg->mailbox[i]);
-
-				ha->aen_q[ha->aen_in].mbox_sts[0]
-							= mbox_status;
+							mbox_sts[i];
 
 				/* print debug message */
-				DEBUG2(printk("scsi%ld: AEN[%d] %04x queued "
-					"mb1:0x%x mb2:0x%x mb3:0x%x mb4:0x%x\n",
-					ha->host_no, ha->aen_in,
-					mbox_status,
-					ha->aen_q[ha->aen_in].mbox_sts[1],
-					ha->aen_q[ha->aen_in].mbox_sts[2],
-					ha->aen_q[ha->aen_in].mbox_sts[3],
-					ha->aen_q[ha->aen_in].  mbox_sts[4]));
+				DEBUG2(printk("scsi%ld: AEN[%d] %04x queued"
+					      " mb1:0x%x mb2:0x%x mb3:0x%x mb4:0x%x\n",
+							ha->host_no, ha->aen_in, mbox_sts[0],
+							mbox_sts[1], mbox_sts[2], mbox_sts[3],
+							mbox_sts[4]));
 				/* advance pointer */
 				ha->aen_in++;
 				if (ha->aen_in == MAX_AEN_ENTRIES)
@@ -631,18 +652,16 @@ static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
 				DEBUG2(printk("scsi%ld: %s: aen %04x, queue "
 					      "overflowed!  AEN LOST!!\n",
 					      ha->host_no, __func__,
-					      mbox_status));
+					      mbox_sts[0]));
 
 				DEBUG2(printk("scsi%ld: DUMP AEN QUEUE\n",
 					      ha->host_no));
 
 				for (i = 0; i < MAX_AEN_ENTRIES; i++) {
 					DEBUG2(printk("AEN[%d] %04x %04x %04x "
-					      "%04x\n", i,
-					      ha->aen_q[i].mbox_sts[0],
-					      ha->aen_q[i].mbox_sts[1],
-					      ha->aen_q[i].mbox_sts[2],
-					      ha->aen_q[i].mbox_sts[3]));
+							"%04x\n", i, mbox_sts[0],
+							mbox_sts[1], mbox_sts[2],
+							mbox_sts[3]));
 				}
 			}
 			break;
@@ -650,18 +669,43 @@ static void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,
 		default:
 			DEBUG2(printk(KERN_WARNING
 				      "scsi%ld: AEN %04x UNKNOWN\n",
-				      ha->host_no, mbox_status));
+				      ha->host_no, mbox_sts[0]));
 			break;
 		}
 	} else {
 		DEBUG2(printk("scsi%ld: Unknown mailbox status %08X\n",
 			      ha->host_no, mbox_status));
 
-		ha->mbox_status[0] = mbox_status;
+		ha->mbox_status[0] = mbox_sts[0];
 	}
 }
 
 /**
+ * qla82xx_interrupt_service_routine - isr
+ * @ha: pointer to host adapter structure.
+ *
+ * This is the main interrupt service routine.
+ * hardware_lock locked upon entry. runs in interrupt context.
+ **/
+void qla82xx_interrupt_service_routine(struct scsi_qla_host *ha,
+					uint32_t intr_status)
+{
+	/* Process response queue interrupt. */
+	if (intr_status & HSRX_RISC_IOCB_INT)  {
+		qla4xxx_process_response_queue(ha);
+	}
+
+	/* Process mailbox/asynch event interrupt.*/
+	if (intr_status & HSRX_RISC_MB_INT) {
+		qla4xxx_isr_decode_mailbox(ha, readl(&ha->qla82xx_reg->mailbox_out[0]));
+	}
+
+	/* clear the interrupt */
+	writel(0, &ha->qla82xx_reg->host_int);
+	readl(&ha->qla82xx_reg->host_int);
+}
+
+/**
  * qla4xxx_interrupt_service_routine - isr
  * @ha: pointer to host adapter structure.
  *
@@ -675,10 +719,10 @@ void qla4xxx_interrupt_service_routine(struct scsi_qla_host * ha,
 	if (intr_status & CSR_SCSI_COMPLETION_INTR)
 		qla4xxx_process_response_queue(ha);
 
-	/* Process mailbox/asynch event	 interrupt.*/
+	/* Process mailbox/asynch event interrupt.*/
 	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
 		qla4xxx_isr_decode_mailbox(ha,
-					   readl(&ha->reg->mailbox[0]));
+			readl(&ha->reg->mailbox[0]));
 
 		/* Clear Mailbox Interrupt */
 		writel(set_rmask(CSR_SCSI_PROCESSOR_INTR),
@@ -688,6 +732,28 @@ void qla4xxx_interrupt_service_routine(struct scsi_qla_host * ha,
 }
 
 /**
+ * qla82xx_spurious_interrupt - processes spurious interrupt
+ * @ha: pointer to host adapter structure.
+ * @reqs_count: .
+ *
+ **/
+static void qla82xx_spurious_interrupt(struct scsi_qla_host *ha,
+				       uint8_t reqs_count)
+{
+	if (reqs_count)
+		return;
+
+	DEBUG2(printk(KERN_INFO"Spurious Interrupt\n"));
+	if (is_qla8022(ha)) {
+		writel(0, &ha->qla82xx_reg->host_int);
+		if (test_bit(AF_INTx_ENABLED, &ha->flags))
+			qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+	}
+	ha->spurious_int_count++;
+
+}
+
+/**
  * qla4xxx_intr_handler - hardware interrupt handler.
  * @irq: Unused
  * @dev_id: Pointer to host adapter structure
@@ -718,7 +784,7 @@ irqreturn_t qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 		/*
 		 * Read interrupt status
 		 */
-		if (le32_to_cpu(ha->shadow_regs->rsp_q_in) !=
+		if (ha->isp_ops->rd_shdw_rsp_q_in(ha) !=
 		    ha->response_out)
 			intr_status = CSR_SCSI_COMPLETION_INTR;
 		else
@@ -768,22 +834,163 @@ irqreturn_t qla4xxx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 			       &ha->reg->ctrl_status);
 			readl(&ha->reg->ctrl_status);
 
-			if (!ql4_mod_unload)
+			if (!test_bit(AF_HBA_GOING_AWAY, &ha->flags))
 				set_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
 
 			break;
 		} else if (intr_status & INTR_PENDING) {
-			qla4xxx_interrupt_service_routine(ha, intr_status);
+			ha->isp_ops->interrupt_service_routine(ha, intr_status);
 			ha->total_io_count++;
 			if (++reqs_count == MAX_REQS_SERVICED_PER_INTR)
 				break;
+		}
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return IRQ_HANDLED;
+}
+
+/**
+ * qla82xx_intr_handler - hardware interrupt handler.
+ * @irq: Unused
+ * @dev_id: Pointer to host adapter structure
+ **/
+irqreturn_t qla82xx_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct scsi_qla_host *ha;
+	uint32_t intr_status;
+	uint32_t status;
+	unsigned long flags = 0;
+	uint8_t reqs_count = 0;
+
+	ha = (struct scsi_qla_host *) dev_id;
+	if (!ha) {
+		DEBUG2(printk(KERN_INFO
+			"qla82xx: Interrupt with NULL host ptr\n"));
+		return IRQ_NONE;
+	}
 
-			intr_status = 0;
+	ha->isr_count++;
+	status = qla82xx_rd_32(ha, ISR_INT_VECTOR);
+	if (!(status & ha->nx_legacy_intr.int_vec_bit)) {
+		DEBUG2(printk(KERN_INFO"%s legacy Int Vec bit set\n", __func__));
+		return IRQ_NONE;
+	}
+
+	status = qla82xx_rd_32(ha, ISR_INT_STATE_REG);
+	if (!ISR_IS_LEGACY_INTR_TRIGGERED(status)) {
+		DEBUG2(printk("%s legacy Int not triggered\n", __func__));
+		return IRQ_NONE;
+	}
+
+	/* clear the interrupt */
+	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);
+
+	/* read twice to ensure write is flushed */
+	qla82xx_rd_32(ha, ISR_INT_VECTOR);
+	qla82xx_rd_32(ha, ISR_INT_VECTOR);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	while (1) {
+		if (!(readl(&ha->qla82xx_reg->host_int) & ISRX_82XX_RISC_INT))  {
+			qla82xx_spurious_interrupt(ha, reqs_count);
+			break;
+		}
+		intr_status =  readl(&ha->qla82xx_reg->host_status);
+		if  ((intr_status & (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0)  {
+			qla82xx_spurious_interrupt(ha, reqs_count);
+			break;
+		}
+
+		ha->isp_ops->interrupt_service_routine(ha, intr_status);
+
+		/* Enable Interrupt */
+		qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+
+		if (++reqs_count == MAX_REQS_SERVICED_PER_INTR)
+				break;
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return IRQ_HANDLED;
+}
+
+irqreturn_t
+qla82xx_msi_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct scsi_qla_host *ha;
+
+	ha = (struct scsi_qla_host *) dev_id;
+	if (!ha) {
+		DEBUG2(printk(KERN_INFO
+			"qla4xxx: MSIX: Interrupt with NULL host ptr\n"));
+		return IRQ_NONE;
+	}
+
+	ha->isr_count++;
+	/* clear the interrupt */
+	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);
+
+	/* read twice to ensure write is flushed */
+	qla82xx_rd_32(ha, ISR_INT_VECTOR);
+	qla82xx_rd_32(ha, ISR_INT_VECTOR);
+
+	return qla82xx_default_intr_handler(irq, dev_id, (struct pt_regs *)ha);
+}
+
+/**
+ * qla82xx_default_intr_handler - hardware interrupt handler.
+ * @irq: Unused
+ * @dev_id: Pointer to host adapter structure
+ *
+ * This interrupt handler is called directly for MSI-X, and
+ * called indirectly for MSI.
+ **/
+irqreturn_t
+qla82xx_default_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct scsi_qla_host *ha = dev_id;
+	unsigned long	flags;
+	uint32_t intr_status;
+	uint8_t reqs_count = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	while (1) {
+		if (!(readl(&ha->qla82xx_reg->host_int) & ISRX_82XX_RISC_INT))  {
+			qla82xx_spurious_interrupt(ha, reqs_count);
+			break;
+		}
+
+		intr_status =  readl(&ha->qla82xx_reg->host_status);
+		if  ((intr_status &
+		      (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0)  {
+			qla82xx_spurious_interrupt(ha, reqs_count);
+			break;
 		}
+
+		ha->isp_ops->interrupt_service_routine(ha, intr_status);
+
+		if (++reqs_count == MAX_REQS_SERVICED_PER_INTR)
+			break;
 	}
 
+	ha->isr_count++;
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return IRQ_HANDLED;
+}
+
+irqreturn_t
+qla82xx_msix_rsp_q(int irq, void *dev_id)
+{
+	struct scsi_qla_host *ha = dev_id;
+	unsigned long flags;
 
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	qla4xxx_process_response_queue(ha);
+	writel(0, &ha->qla82xx_reg->host_int);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	ha->isr_count++;
 	return IRQ_HANDLED;
 }
 
@@ -805,6 +1012,9 @@ void qla4xxx_process_aen(struct scsi_qla_host *ha, uint8_t process_aen)
 	int i;
 	unsigned long flags;
 
+	DEBUG2(dev_info(&ha->pdev->dev, "%s proc_aen 0x%x\n",
+		__func__, process_aen));
+
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	while (ha->aen_out != ha->aen_in) {
 		aen = &ha->aen_q[ha->aen_out];
@@ -820,9 +1030,8 @@ void qla4xxx_process_aen(struct scsi_qla_host *ha, uint8_t process_aen)
 
 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
-		DEBUG2(printk("qla4xxx(%ld): AEN[%d]=0x%08x, mbx1=0x%08x "
-			"mbx2=0x%08x mbx3=0x%08x mbx4=0x%08x\n",
-			ha->host_no,
+		DEBUG2(printk("qla4xxx(%ld): AEN[%d]=0x%08x, mbx1=0x%08x mbx2=0x%08x"
+			" mbx3=0x%08x mbx4=0x%08x\n", ha->host_no,
 			(ha->aen_out ? (ha->aen_out-1): (MAX_AEN_ENTRIES-1)),
 			mbox_sts[0], mbox_sts[1], mbox_sts[2],
 			mbox_sts[3], mbox_sts[4]));
@@ -844,7 +1053,7 @@ void qla4xxx_process_aen(struct scsi_qla_host *ha, uint8_t process_aen)
 				ddb_entry =
 					/* FIXME: name length? */
 					qla4xxx_lookup_ddb_by_fw_index(ha,
-						mbox_sts[2]);
+								       mbox_sts[2]);
 				if (!ddb_entry)
 					break;
 
@@ -855,7 +1064,7 @@ void qla4xxx_process_aen(struct scsi_qla_host *ha, uint8_t process_aen)
 					((ddb_entry->default_time2wait +
 					  4) * HZ);
 
-				DEBUG2(printk("scsi%ld: ddb index [%d] initate"
+				DEBUG2(printk("scsi%ld: ddb [%d] initate"
 					      " RELOGIN after %d seconds\n",
 					      ha->host_no,
 					      ddb_entry->fw_ddb_index,
@@ -878,3 +1087,78 @@ void qla4xxx_process_aen(struct scsi_qla_host *ha, uint8_t process_aen)
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 }
 
+int qla4xxx_request_irqs(struct scsi_qla_host *ha)
+{
+	int ret;
+
+	if (!is_qla8022(ha))
+		goto try_intx;
+
+	if (ql4xenablemsix == 2)
+		goto try_msi;
+
+	if (ql4xenablemsix == 0 || ql4xenablemsix != 1)
+		goto try_intx;
+
+	/* Trying MSI-X */
+	ret = qla82xx_enable_msix(ha);
+	if (!ret) {
+		DEBUG2(printk("MSI-X: Enabled (0x%X).\n", ha->revision_id));
+		goto irq_attached;
+	}
+
+	printk(KERN_WARNING"MSI-X: Falling back-to MSI mode -- %d.\n", ret);
+
+try_msi:
+	/* Trying MSI */
+	ret = pci_enable_msi(ha->pdev);
+	if (!ret) {
+		ret = request_irq(ha->pdev->irq, qla82xx_msi_handler,
+		    IRQF_DISABLED|IRQF_SHARED, DRIVER_NAME, ha);
+		if (!ret) {
+			DEBUG2(printk(KERN_INFO"MSI: Enabled.\n"));
+			set_bit(AF_MSI_ENABLED, &ha->flags);
+			goto irq_attached;
+		} else {
+			printk(KERN_WARNING"Failed to reserve interrupt %d "
+				"already in use.\n", ha->pdev->irq);
+			pci_disable_msi(ha->pdev);
+		}
+	}
+	printk(KERN_WARNING"MSI: Falling back-to INTx mode -- %d.\n", ret);
+
+try_intx:
+	/* Trying INTx */
+	ret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,
+	    IRQF_DISABLED|IRQF_SHARED, DRIVER_NAME, ha);
+	if (!ret) {
+		DEBUG2(printk(KERN_INFO "INTx: Enabled.\n"));
+		set_bit(AF_INTx_ENABLED, &ha->flags);
+		goto irq_attached;
+	} else {
+		printk(KERN_WARNING
+		    "Failed to reserve interrupt %d already in use.\n",
+		    ha->pdev->irq);
+		return ret;
+	}
+
+irq_attached:
+	set_bit(AF_IRQ_ATTACHED, &ha->flags);
+	ha->host->irq = ha->pdev->irq;
+	dev_info(&ha->pdev->dev, "%s: irq %d attached\n",
+	    __func__, ha->pdev->irq);
+	return ret;
+}
+
+void
+qla4xxx_free_irqs(struct scsi_qla_host *ha)
+{
+	if (test_bit(AF_MSIX_ENABLED, &ha->flags))
+			qla82xx_disable_msix(ha);
+	else if (test_and_clear_bit(AF_MSI_ENABLED, &ha->flags)) {
+			free_irq(ha->pdev->irq, ha);
+			pci_disable_msi(ha->pdev);
+	} else if (test_and_clear_bit(AF_INTx_ENABLED, &ha->flags)) {
+			free_irq(ha->pdev->irq, ha);
+	}
+}
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index b7d8e53..c2d2cb2 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -20,7 +20,7 @@
  * @mbx_cmd: data pointer for mailbox in registers.
  * @mbx_sts: data pointer for mailbox out registers.
  *
- * This routine sssue mailbox commands and waits for completion.
+ * This routine issues mailbox commands and waits for completion.
  * If outCount is 0, this routine completes successfully WITHOUT waiting
  * for the mailbox command to complete.
  **/
@@ -43,7 +43,7 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 
 	/* Mailbox code active */
 	wait_count = MBOX_TOV * 100;
-	
+
 	while (wait_count--) {
 		mutex_lock(&ha->mbox_sem);
 		if (!test_bit(AF_MBOX_COMMAND, &ha->flags)) {
@@ -61,16 +61,33 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	}
 
 	/* To prevent overwriting mailbox registers for a command that has
-	 * not yet been serviced, check to see if a previously issued
-	 * mailbox command is interrupting.
+	 * not yet been serviced, check to see if an active command
+	 * (AEN, IOCB, etc.) is interrupting, then service it.
 	 * -----------------------------------------------------------------
 	 */
 	spin_lock_irqsave(&ha->hardware_lock, flags);
-	intr_status = readl(&ha->reg->ctrl_status);
-	if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
-		/* Service existing interrupt */
-		qla4xxx_interrupt_service_routine(ha, intr_status);
-		clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+	if (is_qla8022(ha)) {
+		intr_status = readl(&ha->qla82xx_reg->host_int);
+		if (intr_status & ISRX_82XX_RISC_INT) {
+			/* Service existing interrupt */
+			DEBUG2(printk("scsi%ld: %s: "
+				"servicing existing interrupt\n",
+				ha->host_no, __func__));
+			intr_status = readl(&ha->qla82xx_reg->host_status);
+			ha->isp_ops->interrupt_service_routine(ha, intr_status);
+			clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+			if (test_bit(AF_INTERRUPTS_ON, &ha->flags) &&
+				test_bit(AF_INTx_ENABLED, &ha->flags))
+				qla82xx_wr_32(ha,
+					ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+		}
+	} else {
+		intr_status = readl(&ha->reg->ctrl_status);
+		if (intr_status & CSR_SCSI_PROCESSOR_INTR) {
+			/* Service existing interrupt */
+			ha->isp_ops->interrupt_service_routine(ha, intr_status);
+			clear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);
+		}
 	}
 
 	/* Send the mailbox command to the firmware */
@@ -78,15 +95,23 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	for (i = 0; i < outCount; i++)
 		ha->mbox_status[i] = 0;
 
-	/* Load all mailbox registers, except mailbox 0. */
-	for (i = 1; i < inCount; i++)
-		writel(mbx_cmd[i], &ha->reg->mailbox[i]);
-
-	/* Wakeup firmware  */
-	writel(mbx_cmd[0], &ha->reg->mailbox[0]);
-	readl(&ha->reg->mailbox[0]);
-	writel(set_rmask(CSR_INTR_RISC), &ha->reg->ctrl_status);
-	readl(&ha->reg->ctrl_status);
+	if (is_qla8022(ha)) {
+		/* Load all mailbox registers, except mailbox 0. */
+		for (i = 1; i < inCount; i++)
+			writel(mbx_cmd[i], &ha->qla82xx_reg->mailbox_in[i]);
+		writel(mbx_cmd[0], &ha->qla82xx_reg->mailbox_in[0]);
+		readl(&ha->qla82xx_reg->mailbox_in[0]);
+		writel(HINT_MBX_INT_PENDING, &ha->qla82xx_reg->hint);
+	} else {
+		/* Load all mailbox registers, except mailbox 0. */
+		for (i = 1; i < inCount; i++)
+			writel(mbx_cmd[i], &ha->reg->mailbox[i]);
+		/* Wakeup firmware  */
+		writel(mbx_cmd[0], &ha->reg->mailbox[0]);
+		readl(&ha->reg->mailbox[0]);
+		writel(set_rmask(CSR_INTR_RISC), &ha->reg->ctrl_status);
+		readl(&ha->reg->ctrl_status);
+	}
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	/*
@@ -98,30 +123,57 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 		status = QLA_SUCCESS;
 		goto mbox_exit;
 	}
-	/* Wait for completion */
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	/* Wait for command to complete */
-	wait_count = jiffies + MBOX_TOV * HZ;
-	while (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {
-		if (time_after_eq(jiffies, wait_count))
-			break;
 
-		spin_lock_irqsave(&ha->hardware_lock, flags);
-		intr_status = readl(&ha->reg->ctrl_status);
-		if (intr_status & INTR_PENDING) {
+	/*
+	 * Wait for completion: Poll or completion queue
+	 */
+	if (test_bit(AF_IRQ_ATTACHED, &ha->flags) &&
+		test_bit(AF_INTERRUPTS_ON, &ha->flags) &&
+		test_bit(AF_ONLINE, &ha->flags) &&
+		!test_bit(AF_HBA_GOING_AWAY, &ha->flags)) {
+		/* Do not poll for completion.  Use completion queue */
+		set_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);
+		wait_for_completion_timeout(&ha->mbx_intr_comp, MBOX_TOV * HZ);
+		clear_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);
+	} else {
+		/* Poll for command to complete */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		wait_count = jiffies + (MBOX_TOV * HZ);
+		while (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {
+			if (time_after_eq(jiffies, wait_count))
+				break;
+
+			/* Check for IOCB and MBX Interrpt ?? */
 			/*
 			 * Service the interrupt.
 			 * The ISR will save the mailbox status registers
 			 * to a temporary storage location in the adapter
 			 * structure.
 			 */
-			ha->mbox_status_count = outCount;
-			qla4xxx_interrupt_service_routine(ha, intr_status);
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			if (is_qla8022(ha)) {
+				intr_status = readl(&ha->qla82xx_reg->host_int);
+				if (intr_status & ISRX_82XX_RISC_INT) {
+					ha->mbox_status_count = outCount;
+					intr_status = readl(&ha->qla82xx_reg->host_status);
+					ha->isp_ops->interrupt_service_routine(ha, intr_status);
+					if (test_bit(AF_INTERRUPTS_ON, &ha->flags) &&
+						test_bit(AF_INTx_ENABLED, &ha->flags))
+						qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,
+							0xfbff);
+				}
+			} else {
+				intr_status = readl(&ha->reg->ctrl_status);
+				if (intr_status & INTR_PENDING) {
+					ha->mbox_status_count = outCount;
+					ha->isp_ops->interrupt_service_routine(ha, intr_status);
+				}
+			}
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			msleep(10);
 		}
-		spin_unlock_irqrestore(&ha->hardware_lock, flags);
-		msleep(10);
+		set_current_state(TASK_RUNNING);
 	}
-	set_current_state(TASK_RUNNING);
 
 	/* Check for mailbox timeout. */
 	if (!test_bit(AF_MBOX_COMMAND_DONE, &ha->flags)) {
@@ -183,7 +235,7 @@ mbox_exit:
  * @phys_addr: physical address of buffer.
  * @size: size of buffer.
  *
- * Issues iocbs via mailbox commands. 
+ * Issues iocbs via mailbox commands.
  * TARGET_QUEUE_LOCK must be released.
  * ADAPTER_STATE_LOCK must be released.
  **/
@@ -203,8 +255,7 @@ qla4xxx_issue_iocb(struct scsi_qla_host *ha, uint32_t comp_offset,
 	mbox_cmd[2] = LSDW(phys_addr);
 	mbox_cmd[3] = MSDW(phys_addr);
 
-	status = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1,
-			&mbox_cmd[0], &mbox_sts[0]);
+	status = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]);
 	return status;
 }
 
@@ -222,10 +273,9 @@ int qla4xxx_conn_close_sess_logout(struct scsi_qla_host * ha,
 	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;
 	mbox_cmd[1] = fw_ddb_index;
 	mbox_cmd[2] = connection_id;
-	mbox_cmd[3] = LOGOUT_OPTION_RESET;
+	mbox_cmd[3] = option;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2,
-			&mbox_cmd[0], &mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_CONN_CLOSE_SESS_LOGOUT "
 			      "option %04x failed sts %04X %04X",
@@ -250,8 +300,7 @@ int qla4xxx_clear_database_entry(struct scsi_qla_host * ha,
 	mbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;
 	mbox_cmd[1] = fw_ddb_index;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5,
-			&mbox_cmd[0], &mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS)
 		return QLA_ERROR;
 
@@ -259,8 +308,8 @@ int qla4xxx_clear_database_entry(struct scsi_qla_host * ha,
 }
 
 uint8_t
-qla4xxx_set_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,
-			uint32_t *mbox_sts, dma_addr_t init_fw_cb_dma)
+qla4xxx_set_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd, uint32_t *mbox_sts,
+			dma_addr_t init_fw_cb_dma)
 {
 	memset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);
 	memset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);
@@ -273,7 +322,7 @@ qla4xxx_set_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,
 
 	if (qla4xxx_mailbox_command(ha, 6, 6, mbox_cmd, mbox_sts)
 		!= QLA_SUCCESS) {
-		DEBUG2(printk(KERN_INFO "scsi%ld: %s: "
+		DEBUG2(printk("scsi%ld: %s: "
 		    "MBOX_CMD_INITIALIZE_FIRMWARE failed w/ status %04X\n",
 		    ha->host_no, __func__, mbox_sts[0]));
 		return QLA_ERROR;
@@ -282,8 +331,8 @@ qla4xxx_set_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,
 }
 
 uint8_t
-qla4xxx_get_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,
-			uint32_t *mbox_sts, dma_addr_t init_fw_cb_dma)
+qla4xxx_get_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd, uint32_t *mbox_sts,
+			dma_addr_t init_fw_cb_dma)
 {
 	memset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);
 	memset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);
@@ -295,8 +344,8 @@ qla4xxx_get_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,
 	if (qla4xxx_mailbox_command(ha, 5, 5, mbox_cmd, mbox_sts)
 		!= QLA_SUCCESS) {
 
-		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_INIT_FW_CTRL_BLOCK"
-			" failed w/ status %04X\n",
+		DEBUG2(printk("scsi%ld: %s: "
+			"MBOX_CMD_GET_INIT_FW_CTRL_BLOCK failed w/ status %04X\n",
 			ha->host_no, __func__, mbox_sts[0]));
 		return QLA_ERROR;
 	}
@@ -317,29 +366,21 @@ qla4xxx_update_local_ip(struct scsi_qla_host *ha,
 
 	if (is_ipv6_enabled(ha)) {
 		/* Save IPv6 Address */
-		ha->ipv6_link_local_state =
-			init_fw_cb->ipv6_lnk_lcl_addr_state;
+		ha->ipv6_link_local_state = init_fw_cb->ipv6_lnk_lcl_addr_state;
 		ha->ipv6_addr0_state = init_fw_cb->ipv6_addr0_state;
 		ha->ipv6_addr1_state = init_fw_cb->ipv6_addr1_state;
-		ha->ipv6_default_router_state =
-			init_fw_cb->ipv6_dflt_rtr_state;
+		ha->ipv6_default_router_state = init_fw_cb->ipv6_dflt_rtr_state;
 
 		ha->ipv6_link_local_addr.in6_u.u6_addr8[0] = 0xFE;
 		ha->ipv6_link_local_addr.in6_u.u6_addr8[1] = 0x80;
-		memcpy(&ha->ipv6_link_local_addr.in6_u.u6_addr8[8],
-		    init_fw_cb->ipv6_if_id,
-		    min(sizeof(ha->ipv6_link_local_addr)/2,
-		    sizeof(init_fw_cb->ipv6_if_id)));
+		memcpy(&ha->ipv6_link_local_addr.in6_u.u6_addr8[8], init_fw_cb->ipv6_if_id,
+		    min(sizeof(ha->ipv6_link_local_addr)/2, sizeof(init_fw_cb->ipv6_if_id)));
 		memcpy(&ha->ipv6_addr0, init_fw_cb->ipv6_addr0,
-		    min(sizeof(ha->ipv6_addr0),
-		    sizeof(init_fw_cb->ipv6_addr0)));
+		    min(sizeof(ha->ipv6_addr0), sizeof(init_fw_cb->ipv6_addr0)));
 		memcpy(&ha->ipv6_addr1, init_fw_cb->ipv6_addr1,
-		    min(sizeof(ha->ipv6_addr1),
-		    sizeof(init_fw_cb->ipv6_addr1)));
-		memcpy(&ha->ipv6_default_router_addr,
-		    init_fw_cb->ipv6_dflt_rtr_addr,
-		    min(sizeof(ha->ipv6_default_router_addr),
-		    sizeof(init_fw_cb->ipv6_dflt_rtr_addr)));
+		    min(sizeof(ha->ipv6_addr1), sizeof(init_fw_cb->ipv6_addr1)));
+		memcpy(&ha->ipv6_default_router_addr, init_fw_cb->ipv6_dflt_rtr_addr,
+		    min(sizeof(ha->ipv6_default_router_addr), sizeof(init_fw_cb->ipv6_dflt_rtr_addr)));
 	}
 }
 
@@ -372,6 +413,8 @@ qla4xxx_update_local_ifcb(struct scsi_qla_host *ha,
 	/*memcpy(ha->alias, init_fw_cb->Alias,
 	       min(sizeof(ha->alias), sizeof(init_fw_cb->Alias)));*/
 
+	DEBUG2(printk("%s - func : iSCSI Name : %s\n", __func__, ha->name_string));
+
 	/* Save Command Line Paramater info */
 	ha->port_down_retry_count = le16_to_cpu(init_fw_cb->conn_ka_timeout);
 	ha->discovery_wait = ql4xdiscoverywait;
@@ -403,7 +446,7 @@ int qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)
 	if (init_fw_cb == NULL) {
 		DEBUG2(printk("scsi%ld: %s: Unable to alloc init_cb\n",
 			      ha->host_no, __func__));
-		return 10;
+		goto exit_init_fw_cb_no_free;
 	}
 	memset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));
 
@@ -444,16 +487,14 @@ int qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)
 
 	if (qla4xxx_set_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)
 		!= QLA_SUCCESS) {
-		DEBUG2(printk(KERN_INFO "scsi%ld: %s: Failed to "
-					"set init_fw_ctrl_blk\n",
+		DEBUG2(printk("scsi%ld: %s: Failed to set init_fw_ctrl_blk\n",
 					ha->host_no, __func__));
 		goto exit_init_fw_cb;
 	}
 
 	if (qla4xxx_update_local_ifcb(ha, &mbox_cmd[0], &mbox_sts[0],
-			      init_fw_cb, init_fw_cb_dma) != QLA_SUCCESS) {
-		DEBUG2(printk(KERN_INFO "scsi%ld: %s: Failed to update "
-					"local ifcb\n",
+				      init_fw_cb, init_fw_cb_dma) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: Failed to update local ifcb\n",
 					ha->host_no, __func__));
 		goto exit_init_fw_cb;
 	}
@@ -464,6 +505,7 @@ exit_init_fw_cb:
 	dma_free_coherent(&ha->pdev->dev, sizeof(struct init_fw_ctrl_blk),
 			  init_fw_cb, init_fw_cb_dma);
 
+exit_init_fw_cb_no_free:
 	return status;
 }
 
@@ -484,7 +526,7 @@ int qla4xxx_get_dhcp_ip_address(struct scsi_qla_host *ha)
 	if (init_fw_cb == NULL) {
 		printk("scsi%ld: %s: Unable to alloc init_cb\n", ha->host_no,
 		       __func__);
-		return 10;
+		return QLA_ERROR;
 	}
 
 	/* Get Initialize Firmware Control Block. */
@@ -521,8 +563,7 @@ int qla4xxx_get_firmware_state(struct scsi_qla_host * ha)
 
 	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 4,
-			&mbox_cmd[0], &mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 4, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_FW_STATE failed w/ "
 			      "status %04X\n", ha->host_no, __func__,
@@ -532,10 +573,8 @@ int qla4xxx_get_firmware_state(struct scsi_qla_host * ha)
 	ha->firmware_state = mbox_sts[1];
 	ha->board_id = mbox_sts[2];
 	ha->addl_fw_state = mbox_sts[3];
-	DEBUG2(printk("scsi%ld: %s firmware_state=0x%x\n",
-		      ha->host_no, __func__, ha->firmware_state);)
 
-		return QLA_SUCCESS;
+	return QLA_SUCCESS;
 }
 
 /**
@@ -553,8 +592,7 @@ int qla4xxx_get_firmware_status(struct scsi_qla_host * ha)
 
 	mbox_cmd[0] = MBOX_CMD_GET_FW_STATUS;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3,
-			&mbox_cmd[0], &mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_FW_STATUS failed w/ "
 			      "status %04X\n", ha->host_no, __func__,
@@ -591,7 +629,7 @@ int qla4xxx_get_fwddb_entry(struct scsi_qla_host *ha,
 
 	/* Make sure the device index is valid */
 	if (fw_ddb_index >= MAX_DDB_ENTRIES) {
-		DEBUG2(printk("scsi%ld: %s: index [%d] out of range.\n",
+		DEBUG2(printk("scsi%ld: %s: ddb [%d] out of range.\n",
 			      ha->host_no, __func__, fw_ddb_index));
 		goto exit_get_fwddb;
 	}
@@ -604,8 +642,7 @@ int qla4xxx_get_fwddb_entry(struct scsi_qla_host *ha,
 	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
 	mbox_cmd[4] = sizeof(struct dev_db_entry);
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 7,
-				&mbox_cmd[0], &mbox_sts[0]) ==
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) ==
 	    QLA_ERROR) {
 		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_GET_DATABASE_ENTRY failed"
 			      " with status 0x%04X\n", ha->host_no, __func__,
@@ -613,18 +650,18 @@ int qla4xxx_get_fwddb_entry(struct scsi_qla_host *ha,
 		goto exit_get_fwddb;
 	}
 	if (fw_ddb_index != mbox_sts[1]) {
-		DEBUG2(printk("scsi%ld: %s: index mismatch [%d] != [%d].\n",
+		DEBUG2(printk("scsi%ld: %s: ddb mismatch [%d] != [%d].\n",
 			      ha->host_no, __func__, fw_ddb_index,
 			      mbox_sts[1]));
 		goto exit_get_fwddb;
 	}
 	if (fw_ddb_entry) {
 		DEBUG2(dev_info(&ha->pdev->dev, "%s: DDB[%d] MB0 %04x Tot %d "
-				"Next %d State %04x ConnErr %08x " NIPQUAD_FMT
+				"Next %d State %04x ConnErr %08x %pI4"
 				":%04d \"%s\"\n", __func__, fw_ddb_index,
 				mbox_sts[0], mbox_sts[2], mbox_sts[3],
 				mbox_sts[4], mbox_sts[5],
-				NIPQUAD(fw_ddb_entry->ip_addr),
+				fw_ddb_entry->ip_addr,
 				le16_to_cpu(fw_ddb_entry->port),
 				fw_ddb_entry->iscsi_name));
 	}
@@ -661,8 +698,8 @@ exit_get_fwddb:
  * @fw_ddb_entry: Pointer to firmware's ddb entry structure, or NULL.
  *
  * This routine initializes or updates the adapter's device database
- * entry for the specified device. It also triggers a login for the 
- * specified device. Therefore, it may also be used as a secondary 
+ * entry for the specified device. It also triggers a login for the
+ * specified device. Therefore, it may also be used as a secondary
  * login routine when a NULL pointer is specified for the fw_ddb_entry.
  **/
 int qla4xxx_set_ddb_entry(struct scsi_qla_host * ha, uint16_t fw_ddb_index,
@@ -670,6 +707,7 @@ int qla4xxx_set_ddb_entry(struct scsi_qla_host * ha, uint16_t fw_ddb_index,
 {
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
 	uint32_t mbox_sts[MBOX_REG_COUNT];
+	int status;
 
 	/* Do not wait for completion. The firmware will send us an
 	 * ASTS_DATABASE_CHANGED (0x8014) to notify us of the login status.
@@ -683,8 +721,11 @@ int qla4xxx_set_ddb_entry(struct scsi_qla_host * ha, uint16_t fw_ddb_index,
 	mbox_cmd[3] = MSDW(fw_ddb_entry_dma);
 	mbox_cmd[4] = sizeof(struct dev_db_entry);
 
-	return qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1,
-				&mbox_cmd[0], &mbox_sts[0]);
+	status = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]);
+	DEBUG2(printk("scsi%ld: %s: status=%d mbx0=0x%x mbx4=0x%x\n",
+			ha->host_no, __func__, status, mbox_sts[0], mbox_sts[4]);)
+
+	return status;
 }
 
 int qla4xxx_conn_open_session_login(struct scsi_qla_host * ha,
@@ -704,13 +745,12 @@ int qla4xxx_conn_open_session_login(struct scsi_qla_host * ha,
 	mbox_cmd[1] = (uint32_t) fw_ddb_index;
 	mbox_cmd[6] = 1;
 
-	status = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 0, &mbox_cmd[0],
-				&mbox_sts[0]);
+	status = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 0, &mbox_cmd[0], &mbox_sts[0]);
 	DEBUG2(printk("%s fw_ddb_index=%d status=%d mbx0_1=0x%x :0x%x\n",
 		      __func__, fw_ddb_index, status, mbox_sts[0],
 		      mbox_sts[1]);)
 
-		return status;
+	return status;
 }
 
 /**
@@ -733,8 +773,7 @@ void qla4xxx_get_crash_record(struct scsi_qla_host * ha)
 	/* Get size of crash record. */
 	mbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],
-					&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: ERROR: Unable to retrieve size!\n",
 			      ha->host_no, __func__));
@@ -762,8 +801,7 @@ void qla4xxx_get_crash_record(struct scsi_qla_host * ha)
 	mbox_cmd[3] = MSDW(crash_record_dma);
 	mbox_cmd[4] = crash_record_size;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],
-				&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS)
 		goto exit_get_crash_record;
 
@@ -798,8 +836,7 @@ void qla4xxx_get_conn_event_log(struct scsi_qla_host * ha)
 	/* Get size of crash record. */
 	mbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],
-			&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS)
 		goto exit_get_event_log;
 
@@ -821,8 +858,7 @@ void qla4xxx_get_conn_event_log(struct scsi_qla_host * ha)
 	mbox_cmd[2] = LSDW(event_log_dma);
 	mbox_cmd[3] = MSDW(event_log_dma);
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],
-			&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: ERROR: Unable to retrieve event "
 			      "log!\n", ha->host_no, __func__));
@@ -841,7 +877,7 @@ void qla4xxx_get_conn_event_log(struct scsi_qla_host * ha)
 	DEBUG3(printk("scsi%ld: Connection Event Log Dump (%d entries):\n",
 		      ha->host_no, num_valid_entries));
 
-	if (extended_error_logging == 3) {
+	if (ql4xextended_error_logging == 3) {
 		if (oldest_entry == 0) {
 			/* Circular Buffer has not wrapped around */
 			for (i=0; i < num_valid_entries; i++) {
@@ -888,9 +924,8 @@ int qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb)
 	struct scsi_cmnd *cmd = srb->cmd;
 	int status = QLA_SUCCESS;
 
-	DEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: abort task issued\n",
-			ha->host_no, cmd->device->channel,
-			cmd->device->id, cmd->device->lun));
+	DEBUG2(printk("scsi%ld:%d:%d:%d: abort task issued\n", ha->host_no,
+		      cmd->device->channel, cmd->device->id, cmd->device->lun));
 
 	/*
 	 * Send abort task command to ISP, so that the ISP will return
@@ -904,17 +939,15 @@ int qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb)
 	mbox_cmd[2] = (unsigned long)(unsigned char *)cmd->host_scribble;
 	mbox_cmd[5] = 0x01;     /* Immediate Command Enable */
 
-	qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],
-				&mbox_sts[0]);
+	qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]);
 	if (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE) {
 		status = QLA_ERROR;
 
-		DEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: abort task FAILED:",
-				ha->host_no, cmd->device->channel,
-				cmd->device->id, cmd->device->lun));
-		DEBUG2(printk("mbx0=%04X, mb1=%04X, mb2=%04X, mb3=%04X,"
-				" mb4=%04X\n", mbox_sts[0], mbox_sts[1],
-				mbox_sts[2], mbox_sts[3], mbox_sts[4]));
+		DEBUG2(printk("scsi%ld:%d:%d:%d: abort task FAILED: ", ha->host_no,
+			      cmd->device->channel, cmd->device->id, cmd->device->lun));
+		DEBUG2(printk("mbx0=%04X, mb1=%04X, mb2=%04X, mb3=%04X, mb4=%04X\n",
+			      mbox_sts[0], mbox_sts[1], mbox_sts[2], mbox_sts[3],
+			      mbox_sts[4]));
 	}
 
 	return status;
@@ -923,8 +956,8 @@ int qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb)
 /**
  * qla4xxx_reset_lun - issues LUN Reset
  * @ha: Pointer to host adapter structure.
- * @db_entry: Pointer to device database entry
- * @un_entry: Pointer to lun entry structure
+ * @ddb_entry: Pointer to device database entry
+ * @lun: lun number
  *
  * This routine performs a LUN RESET on the specified target/lun.
  * The caller must ensure that the ddb_entry and lun_entry pointers
@@ -952,8 +985,7 @@ int qla4xxx_reset_lun(struct scsi_qla_host * ha, struct ddb_entry * ddb_entry,
 	mbox_cmd[2] = lun << 8;
 	mbox_cmd[5] = 0x01;	/* Immediate Command Enable */
 
-	qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],
-				&mbox_sts[0]);
+	qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]);
 	if (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE &&
 	    mbox_sts[0] != MBOX_STS_COMMAND_ERROR)
 		status = QLA_ERROR;
@@ -977,8 +1009,7 @@ int qla4xxx_get_flash(struct scsi_qla_host * ha, dma_addr_t dma_addr,
 	mbox_cmd[3] = offset;
 	mbox_cmd[4] = len;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],
-			&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_READ_FLASH, failed w/ "
 		    "status %04X %04X, offset %08x, len %08x\n", ha->host_no,
@@ -992,8 +1023,8 @@ int qla4xxx_get_flash(struct scsi_qla_host * ha, dma_addr_t dma_addr,
  * qla4xxx_get_fw_version - gets firmware version
  * @ha: Pointer to host adapter structure.
  *
- * Retrieves the firmware version on HBA. In QLA4010, mailboxes 2 & 3 may 
- * hold an address for data.  Make sure that we write 0 to those mailboxes, 
+ * Retrieves the firmware version on HBA. In QLA4010, mailboxes 2 & 3 may
+ * hold an address for data.  Make sure that we write 0 to those mailboxes,
  * if unused.
  **/
 int qla4xxx_get_fw_version(struct scsi_qla_host * ha)
@@ -1007,8 +1038,7 @@ int qla4xxx_get_fw_version(struct scsi_qla_host * ha)
 
 	mbox_cmd[0] = MBOX_CMD_ABOUT_FW;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],
-			&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: MBOX_CMD_ABOUT_FW failed w/ "
 		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
@@ -1021,6 +1051,9 @@ int qla4xxx_get_fw_version(struct scsi_qla_host * ha)
 	ha->patch_number = mbox_sts[3];
 	ha->build_number = mbox_sts[4];
 
+	dev_info(&ha->pdev->dev, "%s:  fw=%02d.%02d.%02d.%02d\n", __func__,
+			ha->firmware_version[0], ha->firmware_version[1],
+			ha->patch_number, ha->build_number);
 	return QLA_SUCCESS;
 }
 
@@ -1036,8 +1069,7 @@ int qla4xxx_get_default_ddb(struct scsi_qla_host *ha, dma_addr_t dma_addr)
 	mbox_cmd[2] = LSDW(dma_addr);
 	mbox_cmd[3] = MSDW(dma_addr);
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],
-			&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: failed status %04X\n",
 		     ha->host_no, __func__, mbox_sts[0]));
@@ -1057,8 +1089,7 @@ int qla4xxx_req_ddb_entry(struct scsi_qla_host *ha, uint32_t *ddb_index)
 	mbox_cmd[0] = MBOX_CMD_REQUEST_DATABASE_ENTRY;
 	mbox_cmd[1] = MAX_PRST_DEV_DB_ENTRIES;
 
-	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0],
-				&mbox_sts[0]) !=
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0], &mbox_sts[0]) !=
 	    QLA_SUCCESS) {
 		if (mbox_sts[0] == MBOX_STS_COMMAND_ERROR) {
 			*ddb_index = mbox_sts[2];
@@ -1090,16 +1121,16 @@ int qla4xxx_send_tgts(struct scsi_qla_host *ha, char *ip, uint16_t port)
 		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
 			      ha->host_no, __func__));
 		ret_val = QLA_ERROR;
-		goto qla4xxx_send_tgts_exit;
+		goto exit_send_tgts_no_free;
 	}
 
 	ret_val = qla4xxx_get_default_ddb(ha, fw_ddb_entry_dma);
 	if (ret_val != QLA_SUCCESS)
-		goto qla4xxx_send_tgts_exit;
+		goto exit_send_tgts;
 
 	ret_val = qla4xxx_req_ddb_entry(ha, &ddb_index);
 	if (ret_val != QLA_SUCCESS)
-		goto qla4xxx_send_tgts_exit;
+		goto exit_send_tgts;
 
 	memset((void *)fw_ddb_entry->iscsi_alias, 0,
 	       sizeof(fw_ddb_entry->iscsi_alias));
@@ -1107,24 +1138,45 @@ int qla4xxx_send_tgts(struct scsi_qla_host *ha, char *ip, uint16_t port)
 	memset((void *)fw_ddb_entry->iscsi_name, 0,
 	       sizeof(fw_ddb_entry->iscsi_name));
 
-	memset((void *)fw_ddb_entry->ip_addr, 0,
-		sizeof(fw_ddb_entry->ip_addr));
+	memset((void *)fw_ddb_entry->ip_addr, 0, sizeof(fw_ddb_entry->ip_addr));
 	memset((void *)fw_ddb_entry->tgt_addr, 0,
 	       sizeof(fw_ddb_entry->tgt_addr));
 
 	fw_ddb_entry->options = (DDB_OPT_DISC_SESSION | DDB_OPT_TARGET);
-	fw_ddb_entry->port = cpu_to_le16(ntohs(port));
+	fw_ddb_entry->port = port;
 
-	fw_ddb_entry->ip_addr[0] = *ip;
-	fw_ddb_entry->ip_addr[1] = *(ip + 1);
-	fw_ddb_entry->ip_addr[2] = *(ip + 2);
-	fw_ddb_entry->ip_addr[3] = *(ip + 3);
+	if (is_qla8022(ha) && ip == NULL) {
+		/* We manually configure the DDBs, if
+		 * iSCLI is not yet available
+		 */
+/*
+		fw_ddb_entry->ip_addr[0] = 192;
+		fw_ddb_entry->ip_addr[1] = 168;
+*/
+		fw_ddb_entry->ip_addr[0] = (ha->portnum == 4) ? 192 : 172;
+		fw_ddb_entry->ip_addr[1] = (ha->portnum == 4) ? 168 : 17;
+		fw_ddb_entry->ip_addr[2] = (ha->portnum == 4) ? 2 : 140;
+		#if 1  /* Cable Normal */
+		fw_ddb_entry->ip_addr[3] = (ha->portnum == 4) ? 101 : 76;
+		#else  /* Cable Reverse */
+		fw_ddb_entry->ip_addr[3] = (ha->portnum == 4) ? 5 : 4;
+		#endif
+	} else {
+		fw_ddb_entry->ip_addr[0] = *ip;
+		fw_ddb_entry->ip_addr[1] = *(ip + 1);
+		fw_ddb_entry->ip_addr[2] = *(ip + 2);
+		fw_ddb_entry->ip_addr[3] = *(ip + 3);
+	}
 
+	DEBUG2(printk("scsi%ld: %s: idx=0x%x, ip=%d.%d.%d.%d\n", ha->host_no, __func__, ddb_index,
+		fw_ddb_entry->ip_addr[0], fw_ddb_entry->ip_addr[1], fw_ddb_entry->ip_addr[2], fw_ddb_entry->ip_addr[3]));
 	ret_val = qla4xxx_set_ddb_entry(ha, ddb_index, fw_ddb_entry_dma);
 
-qla4xxx_send_tgts_exit:
+exit_send_tgts:
 	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
 			  fw_ddb_entry, fw_ddb_entry_dma);
+
+exit_send_tgts_no_free:
 	return ret_val;
 }
 
diff --git a/drivers/scsi/qla4xxx/ql4_nx.c b/drivers/scsi/qla4xxx/ql4_nx.c
new file mode 100644
index 0000000..9ed8326
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_nx.c
@@ -0,0 +1,2345 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2009 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include "ql4_def.h"
+#include "ql4_glbl.h"
+
+#define MASK(n)			((1ULL<<(n))-1)
+#define MN_WIN(addr) (((addr & 0x1fc0000) >> 1) | ((addr >> 25) & 0x3ff))
+#define OCM_WIN(addr) (((addr & 0x1ff0000) >> 1) | ((addr >> 25) & 0x3ff))
+#define MS_WIN(addr) (addr & 0x0ffc0000)
+#define QLA82XX_PCI_MN_2M   (0)
+#define QLA82XX_PCI_MS_2M   (0x80000)
+#define QLA82XX_PCI_OCM0_2M (0xc0000)
+#define VALID_OCM_ADDR(addr) (((addr) & 0x3f800) != 0x3f800)
+#define GET_MEM_OFFS_2M(addr) (addr & MASK(18))
+
+/* CRB window related */
+#define CRB_BLK(off)	((off >> 20) & 0x3f)
+#define CRB_SUBBLK(off)	((off >> 16) & 0xf)
+#define CRB_WINDOW_2M	(0x130060)
+#define QLA82XX_PCI_CAMQM_2M_END	(0x04800800UL)
+#define CRB_HI(off)	((qla82xx_crb_hub_agt[CRB_BLK(off)] << 20) | ((off) & 0xf0000))
+#define QLA82XX_PCI_CAMQM_2M_BASE	(0x000ff800UL)
+#define CRB_INDIRECT_2M	(0x1e0000UL)
+
+#ifndef readq
+static u64 readq(void __iomem *reg)
+{
+	return ((u64)readl(reg + 0x4UL) << 32) | (u64)readl(reg);
+}
+
+static void writeq(u64 val, void __iomem *reg)
+{
+	writel(val & 0xffffffff, reg);
+	writel(val >> 32, reg + 0x4UL);
+}
+#endif
+
+static inline void *qla82xx_pci_base_offsetfset(struct scsi_qla_host *ha, unsigned long off)
+{
+	if ((off < ha->first_page_group_end) &&
+	    (off >= ha->first_page_group_start))
+		return (void *)(ha->nx_pcibase + off);
+
+	return NULL;
+}
+
+#define MAX_CRB_XFORM 60
+static unsigned long crb_addr_xform[MAX_CRB_XFORM];
+int qla82xx_crb_table_initialized;
+
+#define qla82xx_crb_addr_transform(name) \
+	(crb_addr_xform[QLA82XX_HW_PX_MAP_CRB_##name] = \
+	QLA82XX_HW_CRB_HUB_AGT_ADR_##name << 20)
+static void
+qla82xx_crb_addr_transform_setup(void)
+{
+	qla82xx_crb_addr_transform(XDMA);
+	qla82xx_crb_addr_transform(TIMR);
+	qla82xx_crb_addr_transform(SRE);
+	qla82xx_crb_addr_transform(SQN3);
+	qla82xx_crb_addr_transform(SQN2);
+	qla82xx_crb_addr_transform(SQN1);
+	qla82xx_crb_addr_transform(SQN0);
+	qla82xx_crb_addr_transform(SQS3);
+	qla82xx_crb_addr_transform(SQS2);
+	qla82xx_crb_addr_transform(SQS1);
+	qla82xx_crb_addr_transform(SQS0);
+	qla82xx_crb_addr_transform(RPMX7);
+	qla82xx_crb_addr_transform(RPMX6);
+	qla82xx_crb_addr_transform(RPMX5);
+	qla82xx_crb_addr_transform(RPMX4);
+	qla82xx_crb_addr_transform(RPMX3);
+	qla82xx_crb_addr_transform(RPMX2);
+	qla82xx_crb_addr_transform(RPMX1);
+	qla82xx_crb_addr_transform(RPMX0);
+	qla82xx_crb_addr_transform(ROMUSB);
+	qla82xx_crb_addr_transform(SN);
+	qla82xx_crb_addr_transform(QMN);
+	qla82xx_crb_addr_transform(QMS);
+	qla82xx_crb_addr_transform(PGNI);
+	qla82xx_crb_addr_transform(PGND);
+	qla82xx_crb_addr_transform(PGN3);
+	qla82xx_crb_addr_transform(PGN2);
+	qla82xx_crb_addr_transform(PGN1);
+	qla82xx_crb_addr_transform(PGN0);
+	qla82xx_crb_addr_transform(PGSI);
+	qla82xx_crb_addr_transform(PGSD);
+	qla82xx_crb_addr_transform(PGS3);
+	qla82xx_crb_addr_transform(PGS2);
+	qla82xx_crb_addr_transform(PGS1);
+	qla82xx_crb_addr_transform(PGS0);
+	qla82xx_crb_addr_transform(PS);
+	qla82xx_crb_addr_transform(PH);
+	qla82xx_crb_addr_transform(NIU);
+	qla82xx_crb_addr_transform(I2Q);
+	qla82xx_crb_addr_transform(EG);
+	qla82xx_crb_addr_transform(MN);
+	qla82xx_crb_addr_transform(MS);
+	qla82xx_crb_addr_transform(CAS2);
+	qla82xx_crb_addr_transform(CAS1);
+	qla82xx_crb_addr_transform(CAS0);
+	qla82xx_crb_addr_transform(CAM);
+	qla82xx_crb_addr_transform(C2C1);
+	qla82xx_crb_addr_transform(C2C0);
+	qla82xx_crb_addr_transform(SMB);
+	qla82xx_crb_addr_transform(OCM0);
+	/*
+	 * Used only in P3 just define it for P2 also.
+	 */
+	qla82xx_crb_addr_transform(I2C0);
+
+	qla82xx_crb_table_initialized = 1;
+}
+
+struct crb_128M_2M_block_map crb_128M_2M_map[64] = {
+	{{{0, 0,         0,         0} } },		/* 0: PCI */
+	{{{1, 0x0100000, 0x0102000, 0x120000},	/* 1: PCIE */
+	  {1, 0x0110000, 0x0120000, 0x130000},
+	  {1, 0x0120000, 0x0122000, 0x124000},
+	  {1, 0x0130000, 0x0132000, 0x126000},
+	  {1, 0x0140000, 0x0142000, 0x128000},
+	  {1, 0x0150000, 0x0152000, 0x12a000},
+	  {1, 0x0160000, 0x0170000, 0x110000},
+	  {1, 0x0170000, 0x0172000, 0x12e000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {1, 0x01e0000, 0x01e0800, 0x122000},
+	  {0, 0x0000000, 0x0000000, 0x000000} } },
+	{{{1, 0x0200000, 0x0210000, 0x180000} } },/* 2: MN */
+	{{{0, 0,         0,         0} } },	    /* 3: */
+	{{{1, 0x0400000, 0x0401000, 0x169000} } },/* 4: P2NR1 */
+	{{{1, 0x0500000, 0x0510000, 0x140000} } },/* 5: SRE   */
+	{{{1, 0x0600000, 0x0610000, 0x1c0000} } },/* 6: NIU   */
+	{{{1, 0x0700000, 0x0704000, 0x1b8000} } },/* 7: QM    */
+	{{{1, 0x0800000, 0x0802000, 0x170000},  /* 8: SQM0  */
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {1, 0x08f0000, 0x08f2000, 0x172000} } },
+	{{{1, 0x0900000, 0x0902000, 0x174000},	/* 9: SQM1*/
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {1, 0x09f0000, 0x09f2000, 0x176000} } },
+	{{{0, 0x0a00000, 0x0a02000, 0x178000},	/* 10: SQM2*/
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {1, 0x0af0000, 0x0af2000, 0x17a000} } },
+	{{{0, 0x0b00000, 0x0b02000, 0x17c000},	/* 11: SQM3*/
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {0, 0x0000000, 0x0000000, 0x000000},
+		 {1, 0x0bf0000, 0x0bf2000, 0x17e000} } },
+	{{{1, 0x0c00000, 0x0c04000, 0x1d4000} } },/* 12: I2Q */
+	{{{1, 0x0d00000, 0x0d04000, 0x1a4000} } },/* 13: TMR */
+	{{{1, 0x0e00000, 0x0e04000, 0x1a0000} } },/* 14: ROMUSB */
+	{{{1, 0x0f00000, 0x0f01000, 0x164000} } },/* 15: PEG4 */
+	{{{0, 0x1000000, 0x1004000, 0x1a8000} } },/* 16: XDMA */
+	{{{1, 0x1100000, 0x1101000, 0x160000} } },/* 17: PEG0 */
+	{{{1, 0x1200000, 0x1201000, 0x161000} } },/* 18: PEG1 */
+	{{{1, 0x1300000, 0x1301000, 0x162000} } },/* 19: PEG2 */
+	{{{1, 0x1400000, 0x1401000, 0x163000} } },/* 20: PEG3 */
+	{{{1, 0x1500000, 0x1501000, 0x165000} } },/* 21: P2ND */
+	{{{1, 0x1600000, 0x1601000, 0x166000} } },/* 22: P2NI */
+	{{{0, 0,         0,         0} } },	/* 23: */
+	{{{0, 0,         0,         0} } },	/* 24: */
+	{{{0, 0,         0,         0} } },	/* 25: */
+	{{{0, 0,         0,         0} } },	/* 26: */
+	{{{0, 0,         0,         0} } },	/* 27: */
+	{{{0, 0,         0,         0} } },	/* 28: */
+	{{{1, 0x1d00000, 0x1d10000, 0x190000} } },/* 29: MS */
+	{{{1, 0x1e00000, 0x1e01000, 0x16a000} } },/* 30: P2NR2 */
+	{{{1, 0x1f00000, 0x1f10000, 0x150000} } },/* 31: EPG */
+	{{{0} } },				/* 32: PCI */
+	{{{1, 0x2100000, 0x2102000, 0x120000},	/* 33: PCIE */
+	  {1, 0x2110000, 0x2120000, 0x130000},
+	  {1, 0x2120000, 0x2122000, 0x124000},
+	  {1, 0x2130000, 0x2132000, 0x126000},
+	  {1, 0x2140000, 0x2142000, 0x128000},
+	  {1, 0x2150000, 0x2152000, 0x12a000},
+	  {1, 0x2160000, 0x2170000, 0x110000},
+	  {1, 0x2170000, 0x2172000, 0x12e000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000},
+	  {0, 0x0000000, 0x0000000, 0x000000} } },
+	{{{1, 0x2200000, 0x2204000, 0x1b0000} } },/* 34: CAM */
+	{{{0} } },				/* 35: */
+	{{{0} } },				/* 36: */
+	{{{0} } },				/* 37: */
+	{{{0} } },				/* 38: */
+	{{{0} } },				/* 39: */
+	{{{1, 0x2800000, 0x2804000, 0x1a4000} } },/* 40: TMR */
+	{{{1, 0x2900000, 0x2901000, 0x16b000} } },/* 41: P2NR3 */
+	{{{1, 0x2a00000, 0x2a00400, 0x1ac400} } },/* 42: RPMX1 */
+	{{{1, 0x2b00000, 0x2b00400, 0x1ac800} } },/* 43: RPMX2 */
+	{{{1, 0x2c00000, 0x2c00400, 0x1acc00} } },/* 44: RPMX3 */
+	{{{1, 0x2d00000, 0x2d00400, 0x1ad000} } },/* 45: RPMX4 */
+	{{{1, 0x2e00000, 0x2e00400, 0x1ad400} } },/* 46: RPMX5 */
+	{{{1, 0x2f00000, 0x2f00400, 0x1ad800} } },/* 47: RPMX6 */
+	{{{1, 0x3000000, 0x3000400, 0x1adc00} } },/* 48: RPMX7 */
+	{{{0, 0x3100000, 0x3104000, 0x1a8000} } },/* 49: XDMA */
+	{{{1, 0x3200000, 0x3204000, 0x1d4000} } },/* 50: I2Q */
+	{{{1, 0x3300000, 0x3304000, 0x1a0000} } },/* 51: ROMUSB */
+	{{{0} } },				/* 52: */
+	{{{1, 0x3500000, 0x3500400, 0x1ac000} } },/* 53: RPMX0 */
+	{{{1, 0x3600000, 0x3600400, 0x1ae000} } },/* 54: RPMX8 */
+	{{{1, 0x3700000, 0x3700400, 0x1ae400} } },/* 55: RPMX9 */
+	{{{1, 0x3800000, 0x3804000, 0x1d0000} } },/* 56: OCM0 */
+	{{{1, 0x3900000, 0x3904000, 0x1b4000} } },/* 57: CRYPTO */
+	{{{1, 0x3a00000, 0x3a04000, 0x1d8000} } },/* 58: SMB */
+	{{{0} } },				/* 59: I2C0 */
+	{{{0} } },				/* 60: I2C1 */
+	{{{1, 0x3d00000, 0x3d04000, 0x1dc000} } },/* 61: LPC */
+	{{{1, 0x3e00000, 0x3e01000, 0x167000} } },/* 62: P2NC */
+	{{{1, 0x3f00000, 0x3f01000, 0x168000} } }	/* 63: P2NR0 */
+};
+
+/*
+ * top 12 bits of crb internal address (hub, agent)
+ */
+unsigned qla82xx_crb_hub_agt[64] = {
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PS,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_MN,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_MS,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SRE,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_NIU,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_QMN,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SQN0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SQN1,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SQN2,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SQN3,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_I2Q,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_TIMR,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGN4,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_XDMA,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGN0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGN1,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGN2,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGN3,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGND,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGNI,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGS0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGS1,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGS2,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGS3,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGSI,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SN,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_EG,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PS,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_CAM,
+	0,
+	0,
+	0,
+	0,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_TIMR,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX1,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX2,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX3,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX4,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX5,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX6,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX7,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_XDMA,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_I2Q,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX8,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX9,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_OCM0,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_SMB,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_I2C0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_I2C1,
+	0,
+	QLA82XX_HW_CRB_HUB_AGT_ADR_PGNC,
+	0,
+};
+
+/*
+ * Set the CRB window based on the offset.
+ * Return 0 if successful; 1 otherwise
+*/
+void qla82xx_pci_change_crbwindow_128M(struct scsi_qla_host *ha, int wndw)
+{
+	WARN_ON(1);
+}
+
+/*
+ * In: 'off' is offset from CRB space in 128M pci map
+ * Out: 'off' is 2M pci map addr
+ * side effect: lock crb window
+ */
+static void
+qla82xx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, u64 *off)
+{
+	u32 win_read;
+
+	ha->crb_win = CRB_HI(*off);
+	writel(ha->crb_win,
+		(void *)(CRB_WINDOW_2M + ha->nx_pcibase));
+
+	/* Read back value to make sure write has gone through before trying
+	* to use it. */
+	win_read = readl((void *)(CRB_WINDOW_2M + ha->nx_pcibase));
+	if (win_read != ha->crb_win) {
+		DEBUG2(printk("%s: Written crbwin (0x%x) != Read crbwin (0x%x), off = 0x%llx\n",
+			__func__, ha->crb_win, win_read, *off));
+	}
+	*off = (*off & MASK(16)) + CRB_INDIRECT_2M + ha->nx_pcibase;
+}
+
+void
+qla82xx_wr_32(struct scsi_qla_host *ha, u64 off, u32 data)
+{
+	unsigned long flags = 0;
+	int rv;
+
+	rv = qla82xx_pci_get_crb_addr_2M(ha, &off);
+
+	BUG_ON(rv == -1);
+
+	if (rv == 1) {
+		write_lock_irqsave(&ha->hw_lock, flags);
+		qla82xx_crb_win_lock(ha);
+		qla82xx_pci_set_crbwindow_2M(ha, &off);
+	}
+
+	writel(data, (void __iomem *)((unsigned long)off));
+
+	if (rv == 1) {
+		qla82xx_crb_win_unlock(ha);
+		write_unlock_irqrestore(&ha->hw_lock, flags);
+	}
+}
+
+int
+qla82xx_rd_32(struct scsi_qla_host *ha, u64 off)
+{
+	unsigned long flags = 0;
+	int rv;
+	u32 data;
+
+	rv = qla82xx_pci_get_crb_addr_2M(ha, &off);
+
+	BUG_ON(rv == -1);
+
+	if (rv == 1) {
+		write_lock_irqsave(&ha->hw_lock, flags);
+		qla82xx_crb_win_lock(ha);
+		qla82xx_pci_set_crbwindow_2M(ha, &off);
+	}
+	data = readl((void __iomem *)((unsigned long)off));
+
+	if (rv == 1) {
+		qla82xx_crb_win_unlock(ha);
+		write_unlock_irqrestore(&ha->hw_lock, flags);
+	}
+	return data;
+}
+
+#define CRB_WIN_LOCK_TIMEOUT 100000000
+
+int qla82xx_crb_win_lock(struct scsi_qla_host *ha)
+{
+	int i;
+	int done = 0, timeout = 0;
+
+	while (!done) {
+		/* acquire semaphore3 from PCI HW block */
+		done = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));
+		if (done == 1)
+			break;
+		if (timeout >= CRB_WIN_LOCK_TIMEOUT)
+			return -1;
+
+		timeout++;
+
+		/* Yield CPU */
+		if (!in_interrupt())
+			schedule();
+		else {
+			for (i = 0; i < 20; i++)
+				cpu_relax();    /*This a nop instr on i386*/
+		}
+	}
+	qla82xx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->portnum);
+	return 0;
+}
+
+void qla82xx_crb_win_unlock(struct scsi_qla_host *ha)
+{
+	qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));
+}
+
+#define IDC_LOCK_TIMEOUT 100000000
+
+/**
+ * qla82xx_idc_lock - hw_lock
+ * @ha: pointer to adapter structure
+ *
+ * General purpose lock used to synchronize access to
+ * CRB_DEV_STATE, CRB_DEV_REF_COUNT, etc.
+ **/
+int qla82xx_idc_lock(struct scsi_qla_host *ha)
+{
+	int i;
+	int done = 0, timeout = 0;
+
+	while (!done) {
+		/* acquire semaphore5 from PCI HW block */
+		done = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));
+		if (done == 1)
+			break;
+		if (timeout >= IDC_LOCK_TIMEOUT)
+			return -1;
+
+		timeout++;
+
+		/* Yield CPU */
+		if (!in_interrupt())
+			schedule();
+		else {
+			for (i = 0; i < 20; i++)
+				cpu_relax();    /*This a nop instr on i386*/
+		}
+	}
+	return 0;
+}
+
+void qla82xx_idc_unlock(struct scsi_qla_host *ha)
+{
+	qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));
+}
+
+int
+qla82xx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, u64 *off)
+{
+	struct crb_128M_2M_sub_block_map *m;
+
+	if (*off >= QLA82XX_CRB_MAX)
+		return -1;
+
+	if (*off >= QLA82XX_PCI_CAMQM && (*off < QLA82XX_PCI_CAMQM_2M_END)) {
+		*off = (*off - QLA82XX_PCI_CAMQM) +
+		    QLA82XX_PCI_CAMQM_2M_BASE + ha->nx_pcibase;
+		return 0;
+	}
+
+	if (*off < QLA82XX_PCI_CRBSPACE)
+		return -1;
+
+	*off -= QLA82XX_PCI_CRBSPACE;
+	/*
+	 * Try direct map
+	 */
+
+	m = &crb_128M_2M_map[CRB_BLK(*off)].sub_block[CRB_SUBBLK(*off)];
+
+	if (m->valid && (m->start_128M <= *off) && (m->end_128M > *off)) {
+		*off = *off + m->start_2M - m->start_128M + ha->nx_pcibase;
+		return 0;
+	}
+
+	/*
+	 * Not in direct map, use crb window
+	 */
+	return 1;
+}
+
+/*  PCI Windowing for DDR regions.  */
+#define QLA82XX_ADDR_IN_RANGE(addr, low, high)            \
+	(((addr) <= (high)) && ((addr) >= (low)))
+
+/*
+* check memory access boundary.
+* used by test agent. support ddr access only for now
+*/
+static unsigned long
+qla82xx_pci_mem_bound_check(struct scsi_qla_host *ha,
+		unsigned long long addr, int size)
+{
+	if (!QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET, QLA82XX_ADDR_DDR_NET_MAX) ||
+		!QLA82XX_ADDR_IN_RANGE(addr + size - 1, QLA82XX_ADDR_DDR_NET, QLA82XX_ADDR_DDR_NET_MAX) ||
+		((size != 1) && (size != 2) && (size != 4) && (size != 8))) {
+		return 0;
+	}
+	return 1;
+}
+
+static int qla82xx_pci_set_window_warning_count;
+
+static unsigned long
+qla82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)
+{
+	int window;
+	u32 win_read;
+
+	if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET,
+	    QLA82XX_ADDR_DDR_NET_MAX)) {
+		/* DDR network side */
+		window = MN_WIN(addr);
+		ha->ddr_mn_window = window;
+		qla82xx_wr_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);
+		win_read = qla82xx_rd_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE);
+		if ((win_read << 17) != window) {
+			DEBUG2(printk(KERN_WARNING"%s: Written MNwin (0x%x) != Read MNwin (0x%x)\n",
+			__func__, window, win_read));
+		}
+		addr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_DDR_NET;
+	} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_OCM0, QLA82XX_ADDR_OCM0_MAX)) {
+		unsigned int temp1;
+		if ((addr & 0x00ff800) == 0xff800) {	/* if bits 19:18&17:11 are on */
+			DEBUG2(printk("%s: QM access not handled.\n", __func__));
+			addr = -1UL;
+		}
+
+		window = OCM_WIN(addr);
+		ha->ddr_mn_window = window;
+		qla82xx_wr_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);
+		win_read = qla82xx_rd_32(ha, ha->mn_win_crb | QLA82XX_PCI_CRBSPACE);
+		temp1 = ((window & 0x1FF) << 7) | ((window & 0x0FFFE0000) >> 17);
+		if (win_read != temp1) {
+			DEBUG2(printk("%s: Written OCMwin (0x%x) != Read OCMwin (0x%x)\n",
+				__func__, temp1, win_read));
+		}
+		addr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_OCM0_2M;
+	} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_QDR_NET, QLA82XX_P3_ADDR_QDR_NET_MAX)) {
+		/* QDR network side */
+		window = MS_WIN(addr);
+		ha->qdr_sn_window = window;
+		qla82xx_wr_32(ha, ha->ms_win_crb | QLA82XX_PCI_CRBSPACE, window);
+		win_read = qla82xx_rd_32(ha, ha->ms_win_crb | QLA82XX_PCI_CRBSPACE);
+		if (win_read != window) {
+			DEBUG2(printk("%s: Written MSwin (0x%x) != Read MSwin (0x%x)\n",
+			__func__, window, win_read));
+		}
+		addr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_QDR_NET;
+
+	} else {
+		/*
+		 * peg gdb frequently accesses memory that doesn't exist,
+		 * this limits the chit chat so debugging isn't slowed down.
+		 */
+		if ((qla82xx_pci_set_window_warning_count++ < 8)
+				|| (qla82xx_pci_set_window_warning_count % 64 == 0)) {
+			DEBUG2(printk("%s: Warning:%s Unknown address range!\n", __func__,
+						DRIVER_NAME));
+		}
+		addr = -1UL;
+	}
+	return addr;
+}
+
+/* check if address is in the same windows as the previous access */
+static int qla82xx_pci_is_same_window(struct scsi_qla_host *ha,
+		unsigned long long addr)
+{
+	int window;
+	unsigned long long qdr_max;
+
+	qdr_max = QLA82XX_P3_ADDR_QDR_NET_MAX;
+
+	if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_DDR_NET,
+	    QLA82XX_ADDR_DDR_NET_MAX)) {
+		/* DDR network side */
+		BUG();	/* MN access can not come here */
+	} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_OCM0,
+	     QLA82XX_ADDR_OCM0_MAX)) {
+		return 1;
+	} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_OCM1,
+	     QLA82XX_ADDR_OCM1_MAX)) {
+		return 1;
+	} else if (QLA82XX_ADDR_IN_RANGE(addr, QLA82XX_ADDR_QDR_NET,
+	    qdr_max)) {
+		/* QDR network side */
+		window = ((addr - QLA82XX_ADDR_QDR_NET) >> 22) & 0x3f;
+		if (ha->qdr_sn_window == window)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int qla82xx_pci_mem_read_direct(struct scsi_qla_host *ha,
+			u64 off, void *data, int size)
+{
+	unsigned long   flags;
+	void           *addr;
+	int             ret = 0;
+	u64             start;
+	uint8_t         *mem_ptr = NULL;
+	unsigned long   mem_base;
+	unsigned long   mem_page;
+
+	write_lock_irqsave(&ha->hw_lock, flags);
+
+	/*
+	 * If attempting to access unknown address or straddle hw windows,
+	 * do not access.
+	 */
+	start = qla82xx_pci_set_window(ha, off);
+	if ((start == -1UL) ||
+	    (qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {
+		write_unlock_irqrestore(&ha->hw_lock, flags);
+		DEBUG2(printk(KERN_ERR"%s out of bound pci memory access. "
+		    "offset is 0x%llx\n", DRIVER_NAME, off));
+		return -1;
+	}
+
+	addr = qla82xx_pci_base_offsetfset(ha, start);
+	if (!addr) {
+		write_unlock_irqrestore(&ha->hw_lock, flags);
+		mem_base = pci_resource_start(ha->pdev, 0);
+		mem_page = start & PAGE_MASK;
+		/* Map two pages whenever user tries to access addresses in two
+		 * consecutive pages.
+		 */
+		if (mem_page != ((start + size - 1) & PAGE_MASK))
+			mem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE * 2);
+		else
+			mem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);
+		if (mem_ptr == 0UL) {
+			*(u8  *)data = 0;
+			return -1;
+		}
+		addr = mem_ptr;
+		addr += start & (PAGE_SIZE - 1);
+		write_lock_irqsave(&ha->hw_lock, flags);
+	}
+
+	switch (size) {
+	case 1:
+		*(u8  *)data = readb(addr);
+		break;
+	case 2:
+		*(u16 *)data = readw(addr);
+		break;
+	case 4:
+		*(u32 *)data = readl(addr);
+		break;
+	case 8:
+		*(u64 *)data = readq(addr);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+	write_unlock_irqrestore(&ha->hw_lock, flags);
+
+	if (mem_ptr)
+		iounmap(mem_ptr);
+	return ret;
+}
+
+static int
+qla82xx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,
+		void *data, int size)
+{
+	unsigned long flags;
+	void           *addr;
+	int             ret = 0;
+	u64             start;
+	uint8_t         *mem_ptr = NULL;
+	unsigned long   mem_base;
+	unsigned long   mem_page;
+
+	write_lock_irqsave(&ha->hw_lock, flags);
+
+	/*
+	 * If attempting to access unknown address or straddle hw windows,
+	 * do not access.
+	 */
+	start = qla82xx_pci_set_window(ha, off);
+	if ((start == -1UL) ||
+	    (qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {
+		write_unlock_irqrestore(&ha->hw_lock, flags);
+		DEBUG2(printk("%s out of bound pci memory access. "
+		    "offset is 0x%llx\n", DRIVER_NAME, off));
+		return -1;
+	}
+
+	addr = qla82xx_pci_base_offsetfset(ha, start);
+	if (!addr) {
+		write_unlock_irqrestore(&ha->hw_lock, flags);
+		mem_base = pci_resource_start(ha->pdev, 0);
+		mem_page = start & PAGE_MASK;
+		/* Map two pages whenever user tries to access addresses in two
+		 * consecutive pages.
+		 */
+		if (mem_page != ((start + size - 1) & PAGE_MASK))
+			mem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE*2);
+		else
+			mem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);
+		if (mem_ptr == 0UL) {
+			return -1;
+		}
+		addr = mem_ptr;
+		addr += start & (PAGE_SIZE - 1);
+		write_lock_irqsave(&ha->hw_lock, flags);
+	}
+
+	switch (size) {
+	case 1:
+		writeb(*(u8 *)data, addr);
+		break;
+	case 2:
+		writew(*(u16 *)data, addr);
+		break;
+	case 4:
+		writel(*(u32 *)data, addr);
+		break;
+	case 8:
+		writeq(*(u64 *)data, addr);
+		break;
+	default:
+		ret = -1;
+		break;
+	}
+	write_unlock_irqrestore(&ha->hw_lock, flags);
+	if (mem_ptr)
+		iounmap(mem_ptr);
+	return ret;
+}
+
+#define MTU_FUDGE_FACTOR 100
+
+static unsigned long
+qla82xx_decode_crb_addr(unsigned long addr)
+{
+	int i;
+	unsigned long base_addr, offset, pci_base;
+
+	if (!qla82xx_crb_table_initialized)
+		qla82xx_crb_addr_transform_setup();
+
+	pci_base = ADDR_ERROR;
+	base_addr = addr & 0xfff00000;
+	offset = addr & 0x000fffff;
+
+	for (i = 0; i < MAX_CRB_XFORM; i++) {
+		if (crb_addr_xform[i] == base_addr) {
+			pci_base = i << 20;
+			break;
+		}
+	}
+	if (pci_base == ADDR_ERROR)
+		return pci_base;
+	else
+		return pci_base + offset;
+}
+
+static long rom_max_timeout = 100;
+static long qla82xx_rom_lock_timeout = 100;
+
+static int
+qla82xx_rom_lock(struct scsi_qla_host *ha)
+{
+	int i;
+	int done = 0, timeout = 0;
+
+	while (!done) {
+		/* acquire semaphore2 from PCI HW block */
+
+		done = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));
+		if (done == 1)
+			break;
+		if (timeout >= qla82xx_rom_lock_timeout)
+			return -1;
+
+		timeout++;
+
+		/* Yield CPU */
+		if (!in_interrupt())
+			schedule();
+		else {
+			for (i = 0; i < 20; i++)
+				cpu_relax();    /*This a nop instr on i386*/
+		}
+	}
+	qla82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ROM_LOCK_DRIVER);
+	return 0;
+}
+
+static void
+qla82xx_rom_unlock(struct scsi_qla_host *ha)
+{
+	qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));
+}
+
+static int
+qla82xx_wait_rom_done(struct scsi_qla_host *ha)
+{
+	long timeout = 0;
+	long done = 0 ;
+
+	while (done == 0) {
+		done = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);
+		done &= 2;
+		timeout++;
+		if (timeout >= rom_max_timeout) {
+			DEBUG2(printk("%s: Timeout reached  waiting for rom done",
+					DRIVER_NAME));
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static int
+qla82xx_do_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
+{
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0xb);
+	if (qla82xx_wait_rom_done(ha)) {
+		DEBUG2(printk("%s: Error waiting for rom done\n", DRIVER_NAME));
+		return -1;
+	}
+	/* reset abyte_cnt and dummy_byte_cnt */
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);
+	udelay(10);
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);
+
+	*valp = qla82xx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);
+	return 0;
+}
+
+static int
+qla82xx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)
+{
+	int ret, loops = 0;
+
+	while ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {
+		udelay(100);
+		schedule();
+		loops++;
+	}
+	if (loops >= 50000) {
+		DEBUG2(printk("%s: qla82xx_rom_lock failed\n", DRIVER_NAME));
+		return -1;
+	}
+	ret = qla82xx_do_rom_fast_read(ha, addr, valp);
+	qla82xx_rom_unlock(ha);
+	return ret;
+}
+
+/**
+ * This routine does CRB initialize sequence
+ * to put the ISP into operational state
+ **/
+static int
+qla82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
+{
+	int addr, val;
+	int i ;
+	int init_delay = 0;
+	struct crb_addr_pair *buf;
+	unsigned long off;
+	unsigned offset, n;
+
+	struct crb_addr_pair {
+		long addr;
+		long data;
+	};
+
+	/* Grab the lock so that no one can read flash when we reset the chip. */
+	qla82xx_rom_lock(ha);
+
+	if (test_bit(DPC_RESET_HA, &ha->dpc_flags)) { /* don't reset CAM block on reset */
+		qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);
+	} else {
+		qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);
+	}
+
+	/* Just in case it was held when we reset the chip */
+	qla82xx_rom_unlock(ha);
+
+	if (qla82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||
+		qla82xx_rom_fast_read(ha, 4, &n) != 0) {
+		DEBUG2(printk("[ERROR] Reading crb_init area: n: %08x\n", n));
+		return -1;
+	}
+	offset = n & 0xffffU;
+	n = (n >> 16) & 0xffffU;
+	if (n  >= 1024) {
+		DEBUG2(printk("%s: %s:n = 0x%x [ERROR] Card flash not initialized.\n",
+			DRIVER_NAME, __func__, n));
+		return -1;
+	}
+
+	DEBUG2(printk("%s: %d CRB init values found in ROM.\n", DRIVER_NAME, n));
+
+	buf = kmalloc(n*sizeof(struct crb_addr_pair), GFP_KERNEL);
+	if (buf == NULL) {
+		DEBUG2(printk("%s: [ERROR] Unable to malloc memory.\n", DRIVER_NAME));
+		return -1;
+	}
+
+	for (i = 0; i < n; i++) {
+		if (qla82xx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||
+			qla82xx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) != 0) {
+			kfree(buf);
+			return -1;
+		}
+
+		buf[i].addr = addr;
+		buf[i].data = val;
+	}
+
+	for (i = 0; i < n; i++) {
+		off = qla82xx_decode_crb_addr((unsigned long)buf[i].addr) + QLA82XX_PCI_CRBSPACE;
+		/* skipping cold reboot MAGIC */
+		if (off == QLA82XX_CAM_RAM(0x1fc))
+			continue;
+
+		/* do not reset PCI */
+		if (off == (ROMUSB_GLB + 0xbc))
+			continue;
+
+		/* skip the function enable register */
+		if (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION)) {
+			continue;
+		}
+		if (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION2)) {
+			continue;
+		}
+		if ((off & 0x0ff00000) == QLA82XX_CRB_SMB) {
+			continue;
+		}
+
+		if ((off & 0x0ff00000) == QLA82XX_CRB_DDR_NET) {
+			continue;
+		}
+
+		if (off == ADDR_ERROR) {
+			DEBUG2(printk("%s: [ERROR] Unknown addr: 0x%08lx\n",
+					DRIVER_NAME, buf[i].addr));
+			continue;
+		}
+
+		/* After writing this register, HW needs time for CRB */
+		/* to quiet down (else crb_window returns 0xffffffff) */
+		if (off == QLA82XX_ROMUSB_GLB_SW_RESET) {
+			init_delay = 1;
+		}
+
+		qla82xx_wr_32(ha, off, buf[i].data);
+		if (init_delay == 1) {
+			msleep(1000);
+			init_delay = 0;
+		}
+
+		msleep(1);
+	}
+	kfree(buf);
+
+	/* p2dn replyCount */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D + 0xec, 0x1e);
+	/* disable_peg_cache 0 */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D + 0x4c, 8);
+	/* disable_peg_cache 1 */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_I + 0x4c, 8);
+
+	/* peg_clr_all */
+	/* peg_clr 0 */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x8, 0);
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0xc, 0);
+	/* peg_clr 1 */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x8, 0);
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0xc, 0);
+	/* peg_clr 2 */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x8, 0);
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0xc, 0);
+	/* peg_clr 3 */
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x8, 0);
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0xc, 0);
+
+	return 0;
+}
+
+static int qla82xx_check_for_bad_spd(struct scsi_qla_host *ha)
+{
+	u32 val = 0;
+	val = qla82xx_rd_32(ha, BOOT_LOADER_DIMM_STATUS) ;
+	val &= QLA82XX_BOOT_LOADER_MN_ISSUE;
+	if (val & QLA82XX_PEG_TUNE_MN_SPD_ZEROED) {
+		printk("Memory DIMM SPD not programmed.  Assumed valid.\n");
+		return 1;
+	} else if (val) {
+		printk("Memory DIMM type incorrect.  Info:%08X.\n", val);
+		return 2;
+	}
+	return 0;
+}
+
+static int
+qla82xx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
+{
+	int  i;
+	long size = 0;
+	long flashaddr, memaddr;
+	u64 data;
+	u32 high, low;
+
+		flashaddr = memaddr = ha->hw.flt_region_bootload;
+		size = (image_start - flashaddr) / 8;
+
+		DEBUG2(printk("scsi%ld: %s: bootldr = 0x%lx, fw_image = 0x%x\n",
+				ha->host_no, __func__, flashaddr, image_start));
+
+		for (i = 0; i < size; i++) {
+			if ((qla82xx_rom_fast_read(ha, flashaddr, (int *)&low)) ||
+			    (qla82xx_rom_fast_read(ha, flashaddr + 4, (int *)&high))) {
+				return -1;
+			}
+			data = ((u64)high << 32) | low ;
+			qla82xx_pci_mem_write_2M(ha, memaddr, &data, 8);
+			flashaddr += 8;
+			memaddr   += 8;
+
+			if (i % 0x1000 == 0) {
+				msleep(1);
+			}
+		}
+
+	udelay(100);
+
+	read_lock(&ha->hw_lock);
+	qla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);
+	read_unlock(&ha->hw_lock);
+	return 0;
+}
+
+static int qla82xx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)
+{
+	u32 rst;
+
+	qla82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);
+	if (qla82xx_pinit_from_rom(ha, 0) != QLA_SUCCESS) {
+		printk(KERN_WARNING "%s: Error during CRB Initialization\n",
+					__func__);
+		return QLA_ERROR;
+	}
+
+	udelay(500);
+
+	/* at this point, QM is in reset. This could be a problem if there are
+	 * incoming d* transition queue messages. QM/PCIE could wedge.
+	 * To get around this, QM is brought out of reset.
+	 */
+
+	rst = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);
+	/* unreset qm */
+	rst &= ~(1 << 28);
+	qla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);
+
+	if (qla82xx_load_from_flash(ha, image_start)) {
+		DEBUG2(printk("%s: Error trying to load fw from flash!\n", __func__));
+		return QLA_ERROR;
+	}
+	return QLA_SUCCESS;
+}
+
+int
+qla82xx_pci_mem_read_2M(struct scsi_qla_host *ha,
+		u64 off, void *data, int size)
+{
+	int i, j = 0, k, start, end, loop, sz[2], off0[2];
+	int	      shift_amount;
+	uint32_t      temp;
+	uint64_t      off8, val, mem_crb, word[2] = {0, 0};
+
+	/*
+	 * If not MN, go check for MS or invalid.
+	 */
+
+	if (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)
+		mem_crb = QLA82XX_CRB_QDR_NET;
+	else {
+		mem_crb = QLA82XX_CRB_DDR_NET;
+		if (qla82xx_pci_mem_bound_check(ha, off, size) == 0)
+			return qla82xx_pci_mem_read_direct(ha,
+					off, data, size);
+	}
+
+	off8 = off & 0xfffffff0;
+	off0[0] = off & 0xf;
+	sz[0] = (size < (16 - off0[0])) ? size : (16 - off0[0]);
+	shift_amount = 4;
+
+	loop = ((off0[0] + size - 1) >> shift_amount) + 1;
+	off0[1] = 0;
+	sz[1] = size - sz[0];
+
+	for (i = 0; i < loop; i++) {
+		temp = off8 + (i << shift_amount);
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);
+		temp = 0;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);
+		temp = MIU_TA_CTL_ENABLE;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+		temp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+
+		for (j = 0; j < MAX_CTL_CHECK; j++) {
+			temp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);
+			if ((temp & MIU_TA_CTL_BUSY) == 0)
+				break;
+		}
+
+		if (j >= MAX_CTL_CHECK) {
+			if (printk_ratelimit())
+				dev_err(&ha->pdev->dev,
+					"failed to read through agent\n");
+			break;
+		}
+
+		start = off0[i] >> 2;
+		end   = (off0[i] + sz[i] - 1) >> 2;
+		for (k = start; k <= end; k++) {
+			temp = qla82xx_rd_32(ha,
+				mem_crb + MIU_TEST_AGT_RDDATA(k));
+			word[i] |= ((uint64_t)temp << (32 * (k & 1)));
+		}
+	}
+
+	if (j >= MAX_CTL_CHECK)
+		return -1;
+
+	if ((off0[0] & 7) == 0) {
+		val = word[0];
+	} else {
+		val = ((word[0] >> (off0[0] * 8)) & (~(~0ULL << (sz[0] * 8)))) |
+		((word[1] & (~(~0ULL << (sz[1] * 8)))) << (sz[0] * 8));
+	}
+
+	switch (size) {
+	case 1:
+		*(uint8_t  *)data = val;
+		break;
+	case 2:
+		*(uint16_t *)data = val;
+		break;
+	case 4:
+		*(uint32_t *)data = val;
+		break;
+	case 8:
+		*(uint64_t *)data = val;
+		break;
+	}
+	return 0;
+}
+
+int
+qla82xx_pci_mem_write_2M(struct scsi_qla_host *ha,
+		u64 off, void *data, int size)
+{
+	int i, j, ret = 0, loop, sz[2], off0;
+	int scale, shift_amount, startword;
+	uint32_t temp;
+	uint64_t off8, mem_crb, tmpw, word[2] = {0, 0};
+
+	/*
+	 * If not MN, go check for MS or invalid.
+	 */
+	if (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)
+		mem_crb = QLA82XX_CRB_QDR_NET;
+	else {
+		mem_crb = QLA82XX_CRB_DDR_NET;
+		if (qla82xx_pci_mem_bound_check(ha, off, size) == 0)
+			return qla82xx_pci_mem_write_direct(ha,
+					off, data, size);
+	}
+
+	off0 = off & 0x7;
+	sz[0] = (size < (8 - off0)) ? size : (8 - off0);
+	sz[1] = size - sz[0];
+
+	off8 = off & 0xfffffff0;
+	loop = (((off & 0xf) + size - 1) >> 4) + 1;
+	shift_amount = 4;
+	scale = 2;
+	startword = (off & 0xf)/8;
+
+	for (i = 0; i < loop; i++) {
+		if (qla82xx_pci_mem_read_2M(ha, off8 + (i << shift_amount),
+					&word[i * scale], 8))
+			return -1;
+	}
+
+	switch (size) {
+	case 1:
+		tmpw = *((uint8_t *)data);
+		break;
+	case 2:
+		tmpw = *((uint16_t *)data);
+		break;
+	case 4:
+		tmpw = *((uint32_t *)data);
+		break;
+	case 8:
+	default:
+		tmpw = *((uint64_t *)data);
+	break;
+	}
+
+	if (sz[0] == 8) {
+		word[startword] = tmpw;
+	} else {
+		word[startword] &=
+		~((~(~0ULL << (sz[0] * 8))) << (off0 * 8));
+		word[startword] |= tmpw << (off0 * 8);
+	}
+	if (sz[1] != 0) {
+		word[startword + 1] &= ~(~0ULL << (sz[1] * 8));
+		word[startword + 1] |= tmpw >> (sz[0] * 8);
+	}
+
+	for (i = 0; i < loop; i++) {
+		temp = off8 + (i << shift_amount);
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);
+		temp = 0;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);
+		temp = word[i * scale] & 0xffffffff;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_LO, temp);
+		temp = (word[i * scale] >> 32) & 0xffffffff;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_HI, temp);
+		temp = word[i*scale + 1] & 0xffffffff;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_LO, temp);
+		temp = (word[i*scale + 1] >> 32) & 0xffffffff;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_HI, temp);
+
+		temp = MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+		temp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;
+		qla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);
+
+		for (j = 0; j < MAX_CTL_CHECK; j++) {
+			temp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);
+			if ((temp & MIU_TA_CTL_BUSY) == 0)
+				break;
+		}
+
+		if (j >= MAX_CTL_CHECK) {
+			if (printk_ratelimit())
+				dev_err(&ha->pdev->dev,
+					"failed to write through agent\n");
+			ret = -1;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int qla82xx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)
+{
+	u32 val = 0;
+	int retries = 60;
+
+	if (!pegtune_val) {
+		do {
+			val = qla82xx_rd_32(ha, CRB_CMDPEG_STATE);
+			if ((val == PHAN_INITIALIZE_COMPLETE) ||
+			     (val == PHAN_INITIALIZE_ACK))
+				return 0;
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(500);
+
+		} while (--retries);
+
+		qla82xx_check_for_bad_spd(ha);
+
+		if (!retries) {
+			pegtune_val = qla82xx_rd_32(ha,
+			    QLA82XX_ROMUSB_GLB_PEGTUNE_DONE);
+			printk(KERN_WARNING "%s: init failed, "
+			    "pegtune_val = %x\n", __func__, pegtune_val);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int qla82xx_rcvpeg_ready(struct scsi_qla_host *ha)
+{
+	uint32_t state = 0;
+	int loops = 0, err = 0;
+
+	/* Window 1 call */
+	read_lock(&ha->hw_lock);
+	state = qla82xx_rd_32(ha, CRB_RCVPEG_STATE);
+	read_unlock(&ha->hw_lock);
+
+	while ((state != PHAN_PEG_RCV_INITIALIZED) && (loops < 30000)) {
+		udelay(100);
+		schedule();
+		/* Window 1 call */
+
+		read_lock(&ha->hw_lock);
+		state = qla82xx_rd_32(ha, CRB_RCVPEG_STATE);
+		read_unlock(&ha->hw_lock);
+
+		loops++;
+	}
+
+	if (loops >= 30000) {
+		DEBUG2(printk("Receive Peg initialization not complete: 0x%x.\n", state));
+		err = -EIO;
+	}
+
+	return err;
+}
+
+static inline void
+qla82xx_set_drv_active(struct scsi_qla_host *ha)
+{
+	uint32_t drv_active;
+
+	drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+
+	drv_active |= (1 << (ha->portnum * 4));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);
+}
+
+void
+qla82xx_clear_drv_active(struct scsi_qla_host *ha)
+{
+	uint32_t drv_active;
+
+	drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+	drv_active &= ~(1 << (ha->portnum * 4));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);
+}
+
+static inline int
+qla82xx_need_reset(struct scsi_qla_host *ha)
+{
+	uint32_t drv_state;
+	int rval;
+
+	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	rval = drv_state & (1 << (ha->portnum * 4));
+	return rval;
+}
+
+static inline void
+qla82xx_set_rst_ready(struct scsi_qla_host *ha)
+{
+	uint32_t drv_state;
+
+	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+
+	drv_state |= (1 << (ha->portnum * 4));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);
+}
+
+static inline void
+qla82xx_clear_rst_ready(struct scsi_qla_host *ha)
+{
+	uint32_t drv_state;
+
+	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	drv_state &= ~(1 << (ha->portnum * 4));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);
+}
+
+static inline void
+qla82xx_set_qsnt_ready(struct scsi_qla_host *ha)
+{
+	uint32_t qsnt_state;
+
+	qsnt_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	qsnt_state |= (2 << (ha->portnum * 4));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);
+}
+
+static int
+qla82xx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)
+{
+	int           pcie_cap;
+	uint16_t      lnk;
+
+	/* scrub dma mask expansion register */
+	qla82xx_wr_32(ha, CRB_DMA_SHIFT, 0x55555555);
+
+	/* Overwrite stale initialization register values */
+	qla82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);
+	qla82xx_wr_32(ha, CRB_RCVPEG_STATE, 0);
+	qla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);
+	qla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);
+
+	if (qla82xx_load_fw(ha, image_start) != QLA_SUCCESS) {
+		printk("%s: Error trying to start fw!\n", __func__);
+		return QLA_ERROR;
+	}
+
+	/* Handshake with the card before we register the devices. */
+	if (qla82xx_cmdpeg_ready(ha, 0) != QLA_SUCCESS) {
+		printk("%s: Error during card handshake!\n", __func__);
+		return QLA_ERROR;
+	}
+
+	/* Negotiated Link width */
+	pcie_cap = pci_find_capability(ha->pdev, PCI_CAP_ID_EXP);
+	pci_read_config_word(ha->pdev, pcie_cap + PCI_EXP_LNKSTA, &lnk);
+	ha->link_width = (lnk >> 4) & 0x3f;
+
+	/* Synchronize with Receive peg */
+	return qla82xx_rcvpeg_ready(ha);
+}
+
+static int
+qla82xx_try_start_fw(struct scsi_qla_host *ha)
+{
+	int rval = QLA_ERROR;
+
+	/*
+	 * FW Load priority:
+	 * 1) Operational firmware residing in flash.
+	 * 2) Fail
+	 */
+
+	DEBUG2(printk(KERN_INFO"FW: Retrieving flash offsets from FLT/FDT ...\n"));
+	rval = qla82xx_get_flash_info(ha);
+	if (rval != QLA_SUCCESS)
+		return rval;
+
+	rval = qla82xx_start_firmware(ha, ha->hw.flt_region_fw);
+	if (rval == QLA_SUCCESS)
+		return rval;
+
+	DEBUG2(printk(KERN_ERR"FW: Load firmware from flash FAILED...\n"));
+	rval = QLA_ERROR;
+	return rval;
+}
+
+/**
+ * qla82xx_device_bootstrap - Initialize device, set DEV_READY, start fw
+ * @ha: pointer to adapter structure
+ *
+ * Note: IDC lock must be held upon entry
+ **/
+static int
+qla82xx_device_bootstrap(struct scsi_qla_host *ha)
+{
+	int rval, i, timeout;
+	uint32_t old_count, count;
+
+	if (qla82xx_need_reset(ha))
+		goto dev_initialize;
+
+	old_count = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+
+	for (i = 0; i < 10; i++) {
+		timeout = msleep_interruptible(200);
+		if (timeout) {
+			qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+			    QLA82XX_DEV_FAILED);
+			return QLA_ERROR;  /* FIXME: CHANGE AT LATER POINT IN TIME */
+		}
+
+		count = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+		if (count != old_count)
+			goto dev_ready;
+	}
+
+dev_initialize:
+	/* set to DEV_INITIALIZING */
+	DEBUG2(printk(KERN_INFO"HW State: INITIALIZING\n"));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_INITIALIZING);
+
+	/* Driver that sets device state to initializating sets IDC version */
+	qla82xx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION, QLA82XX_IDC_VERSION);
+
+	qla82xx_idc_unlock(ha);
+	rval = qla82xx_try_start_fw(ha);
+	qla82xx_idc_lock(ha);
+
+	if (rval != QLA_SUCCESS) {
+		DEBUG2(printk(KERN_INFO"HW State: FAILED\n"));
+		qla82xx_clear_drv_active(ha);
+		qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);
+		return rval;
+	}
+
+dev_ready:
+	DEBUG2(printk(KERN_INFO"HW State: READY\n"));
+	qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_READY);
+
+	return QLA_SUCCESS;
+}
+
+/**
+ * qla82xx_need_reset_handler - Code to start reset sequence
+ * @ha: pointer to adapter structure
+ *
+ * Note: IDC lock must be held upon entry
+ **/
+static void
+qla82xx_need_reset_handler(struct scsi_qla_host *ha)
+{
+	uint32_t dev_state, drv_state, drv_active;
+	unsigned long reset_timeout;
+
+	DEBUG2(printk(KERN_INFO"Performing ISP error recovery\n"));
+
+	if (test_and_clear_bit(AF_ONLINE, &ha->flags)) {
+		qla82xx_idc_unlock(ha);
+		ha->isp_ops->disable_intrs(ha);
+		qla82xx_idc_lock(ha);
+	}
+
+	qla82xx_set_rst_ready(ha);
+
+	/* wait for 10 seconds for reset ack from all functions */
+	reset_timeout = jiffies + (ha->nx_reset_timeout * HZ);
+
+	drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+	drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+
+	while (drv_state != drv_active) {
+
+		if (time_after_eq(jiffies, reset_timeout)) {
+			printk("%s: RESET TIMEOUT!\n", DRIVER_NAME);
+			break;
+		}
+
+		qla82xx_idc_unlock(ha);
+		msleep(1000);
+		qla82xx_idc_lock(ha);
+
+		drv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);
+		drv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);
+	}
+
+	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+
+	/* Force to DEV_COLD unless someone else is starting a reset */
+	if (dev_state != QLA82XX_DEV_INITIALIZING) {
+		DEBUG2(printk(KERN_INFO"HW State: COLD/RE-INIT\n"));
+		qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_COLD);
+	}
+}
+
+/**
+ * qla82xx_need_qsnt_handler - Code to start qsnt
+ * @ha: pointer to adapter structure
+ **/
+void
+qla82xx_need_qsnt_handler(struct scsi_qla_host *ha)
+{
+	qla82xx_idc_lock(ha);
+	qla82xx_set_qsnt_ready(ha);
+	qla82xx_idc_unlock(ha);
+}
+
+/*
+ * qla82xx_device_state_handler - Adapter state machine
+ * @ha: pointer to host adapter structure.
+ *
+ * Note: IDC lock must be held upon entry
+ **/
+int qla82xx_device_state_handler(struct scsi_qla_host *ha)
+{
+	uint32_t dev_state;
+	int rval = QLA_SUCCESS;
+	unsigned long dev_init_timeout;
+
+	if (!test_bit(AF_INIT_DONE, &ha->flags)) {
+		DEBUG2(printk("scsi%ld: %s: calling set_drv_active\n", ha->host_no, __func__));
+		qla82xx_set_drv_active(ha);
+	}
+
+	/* wait for 30 seconds for device to go ready */
+	dev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);
+
+	while (1) {
+		qla82xx_idc_lock(ha);
+
+		if (time_after_eq(jiffies, dev_init_timeout)) {
+			DEBUG2(printk("%s: device init failed!\n", DRIVER_NAME));
+			qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA82XX_DEV_FAILED);
+			DEBUG2(printk("HW State: Failed\n"));
+		}
+
+		dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+		DEBUG2(printk("scsi%ld: %s: dev_state = 0x%x\n", ha->host_no, __func__, dev_state));
+		/* NOTE: Make sure idc unlocked upon exit of switch statement */
+		switch (dev_state) {
+		case QLA82XX_DEV_READY:
+			qla82xx_idc_unlock(ha);
+			goto exit;
+		case QLA82XX_DEV_COLD:
+			rval = qla82xx_device_bootstrap(ha);
+			qla82xx_idc_unlock(ha);
+			goto exit;
+		case QLA82XX_DEV_INITIALIZING:
+			qla82xx_idc_unlock(ha);
+			msleep(1000);
+			break;
+		case QLA82XX_DEV_NEED_RESET:
+			if (!ql4xdontresethba)
+				qla82xx_need_reset_handler(ha);
+			/* Update timeout value after need reset handler */
+			dev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);
+			qla82xx_idc_unlock(ha);
+			break;
+		case QLA82XX_DEV_NEED_QUIESCENT:
+			qla82xx_idc_unlock(ha);
+			qla82xx_need_qsnt_handler(ha);
+			qla82xx_idc_lock(ha);
+		case QLA82XX_DEV_QUIESCENT:
+			qla82xx_idc_unlock(ha);
+			DEBUG2(printk("scsi%ld: %s: quiescent.. sleep\n", ha->host_no, __func__));
+			msleep(1000);
+			break;
+		case QLA82XX_DEV_FAILED:
+			qla82xx_idc_unlock(ha);
+			qla4xxx_dead_adapter_cleanup(ha);
+			rval = QLA_ERROR;
+			goto exit;
+		default:
+			/* temp code, device state register
+			 * contains unknown value during reset
+			 */
+			DEBUG2(printk("scsi%ld: %s: default.. sleep\n", ha->host_no, __func__));
+			qla82xx_idc_unlock(ha);
+			qla4xxx_dead_adapter_cleanup(ha);
+			rval = QLA_ERROR;
+			goto exit;
+		}
+	}
+exit:
+	return rval;
+}
+
+int qla82xx_load_risc(struct scsi_qla_host *ha)
+{
+	return qla82xx_device_state_handler(ha);
+}
+
+
+
+/* ISR related functions */
+uint32_t qla82xx_isr_int_target_mask_enable[8] = {
+	ISR_INT_TARGET_MASK, ISR_INT_TARGET_MASK_F1,
+	ISR_INT_TARGET_MASK_F2, ISR_INT_TARGET_MASK_F3,
+	ISR_INT_TARGET_MASK_F4, ISR_INT_TARGET_MASK_F5,
+	ISR_INT_TARGET_MASK_F7, ISR_INT_TARGET_MASK_F7
+};
+
+uint32_t qla82xx_isr_int_target_status[8] = {
+	ISR_INT_TARGET_STATUS, ISR_INT_TARGET_STATUS_F1,
+	ISR_INT_TARGET_STATUS_F2, ISR_INT_TARGET_STATUS_F3,
+	ISR_INT_TARGET_STATUS_F4, ISR_INT_TARGET_STATUS_F5,
+	ISR_INT_TARGET_STATUS_F7, ISR_INT_TARGET_STATUS_F7
+};
+
+static struct qla82xx_legacy_intr_set legacy_intr[] = {
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F0,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(0) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F1,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F1,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F1,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(1) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F2,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F2,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F2,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(2) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F3,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F3,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F3,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(3) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F4,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F4,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F4,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(4) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F5,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F5,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F5,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(5) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F6,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F6,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F6,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(6) },
+	{
+		.int_vec_bit    =       PCIX_INT_VECTOR_BIT_F7,
+		.tgt_status_reg =       ISR_INT_TARGET_STATUS_F7,
+		.tgt_mask_reg   =       ISR_INT_TARGET_MASK_F7,
+		.pci_int_reg    =       ISR_MSI_INT_TRIGGER(7) },
+};
+
+void qla80xx_update_crb_int_ptr(struct scsi_qla_host *ha)
+{
+	struct qla82xx_legacy_intr_set *nx_legacy_intr;
+
+	nx_legacy_intr = &legacy_intr[ha->portnum];
+
+	ha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;
+	ha->nx_legacy_intr.tgt_status_reg = nx_legacy_intr->tgt_status_reg;
+	ha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;
+	ha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;
+}
+
+/**
+ * qla82xx_init_local_data - initialize adapter specific local data
+ * @ha: pointer to host adapter structure.
+ *
+ **/
+void qla82xx_init_local_data(struct scsi_qla_host *ha)
+{
+	/* ISP 8022 initializations */
+	rwlock_init(&ha->hw_lock);
+	ha->qdr_sn_window = -1;
+	ha->ddr_mn_window = -1;
+	ha->curr_window = 255;
+	ha->portnum = PCI_FUNC(ha->pdev->devfn);
+	qla80xx_update_crb_int_ptr(ha);
+}
+
+/*****************************************************************************/
+/* Flash Manipulation Routines                                               */
+/*****************************************************************************/
+
+#define OPTROM_BURST_SIZE       0x1000
+#define OPTROM_BURST_DWORDS     (OPTROM_BURST_SIZE / 4)
+
+#define FARX_DATA_FLAG	BIT_31
+#define FARX_ACCESS_FLASH_CONF	0x7FFD0000
+#define FARX_ACCESS_FLASH_DATA	0x7FF00000
+
+static inline uint32_t
+flash_conf_addr(struct ql82xx_hw_data *hw, uint32_t faddr)
+{
+	return hw->flash_conf_off | faddr;
+}
+
+static inline uint32_t
+flash_data_addr(struct ql82xx_hw_data *hw, uint32_t faddr)
+{
+	return hw->flash_data_off | faddr;
+}
+
+static uint32_t *
+qla82xx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,
+    uint32_t faddr, uint32_t length)
+{
+	uint32_t i;
+	uint32_t val;
+	int loops = 0;
+	while ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {
+		udelay(100);
+		cond_resched();
+		loops++;
+	}
+	if (loops >= 50000) {
+		dev_warn(&ha->pdev->dev,
+		    "ROM lock failed\n");
+		return dwptr;
+	}
+
+	/* Dword reads to flash. */
+	for (i = 0; i < length/4; i++, faddr += 4) {
+		if (qla82xx_do_rom_fast_read(ha, faddr, &val)) {
+			dev_warn(&ha->pdev->dev,
+			    "Do ROM fast read failed\n");
+			goto done_read;
+		}
+		dwptr[i] = __constant_cpu_to_le32(val);
+	}
+
+done_read:
+	qla82xx_rom_unlock(ha);
+	return dwptr;
+}
+
+/**
+ * Address and length are byte address
+ **/
+static uint8_t *
+qla82xx_read_optrom_data(struct scsi_qla_host *ha, uint8_t *buf,
+    uint32_t offset, uint32_t length)
+{
+	qla82xx_read_flash_data(ha, (uint32_t *)buf, offset, length);
+	return buf;
+}
+
+static int
+qla82xx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)
+{
+	const char *loc, *locations[] = { "DEF", "PCI" };
+
+	/*
+	 * FLT-location structure resides after the last PCI region.
+	 */
+
+	/* Begin with sane defaults. */
+	loc = locations[0];
+	*start = FA_FLASH_LAYOUT_ADDR_82;
+	DEBUG2(dev_info(&ha->pdev->dev, "FLTL[%s] = 0x%x.\n", loc, *start));
+	return QLA_SUCCESS;
+}
+
+static void
+qla82xx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)
+{
+	const char *loc, *locations[] = { "DEF", "FLT" };
+	uint16_t *wptr;
+	uint16_t cnt, chksum;
+	uint32_t start;
+	struct qla_flt_header *flt;
+	struct qla_flt_region *region;
+	struct ql82xx_hw_data *hw = &ha->hw;
+
+	hw->flt_region_flt = flt_addr;
+	wptr = (uint16_t *)ha->request_ring;
+	flt = (struct qla_flt_header *)ha->request_ring;
+	region = (struct qla_flt_region *)&flt[1];
+	qla82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
+	    flt_addr << 2, OPTROM_BURST_SIZE);
+	if (*wptr == __constant_cpu_to_le16(0xffff))
+		goto no_flash_data;
+	if (flt->version != __constant_cpu_to_le16(1)) {
+		DEBUG2(dev_info(&ha->pdev->dev, "Unsupported FLT detected: "
+		    "version = 0x%x length = 0x%x checksum = 0x%x.\n",
+		    le16_to_cpu(flt->version), le16_to_cpu(flt->length),
+		    le16_to_cpu(flt->checksum)));
+		goto no_flash_data;
+	}
+
+	cnt = (sizeof(struct qla_flt_header) + le16_to_cpu(flt->length)) >> 1;
+	for (chksum = 0; cnt; cnt--)
+		chksum += le16_to_cpu(*wptr++);
+	if (chksum) {
+		DEBUG2(dev_info(&ha->pdev->dev, "Inconsistent FLT detected: "
+		    "version = 0x%x length = 0x%x checksum = 0x%x.\n",
+		    le16_to_cpu(flt->version), le16_to_cpu(flt->length),
+		    chksum));
+		goto no_flash_data;
+	}
+
+	loc = locations[1];
+	cnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);
+	for ( ; cnt; cnt--, region++) {
+		/* Store addresses as DWORD offsets. */
+		start = le32_to_cpu(region->start) >> 2;
+
+		DEBUG3(printk(KERN_DEBUG"FLT[%02x]: start = 0x%x "
+		    "end = 0x%x size = 0x%x.\n", le32_to_cpu(region->code), start,
+		    le32_to_cpu(region->end) >> 2, le32_to_cpu(region->size)));
+
+		switch (le32_to_cpu(region->code) & 0xff) {
+		case FLT_REG_FDT:
+			hw->flt_region_fdt = start;
+			break;
+		case FLT_REG_BOOT_CODE_82:
+			hw->flt_region_boot = start;
+			break;
+		case FLT_REG_FW_82:
+			hw->flt_region_fw = start;
+			break;
+		case FLT_REG_BOOTLOAD_82:
+			hw->flt_region_bootload = start;
+			break;
+		}
+	}
+	goto done;
+
+
+no_flash_data:
+	/* Use hardcoded defaults. */
+	loc = locations[0];
+
+	hw->flt_region_fdt      = FA_FLASH_DESCR_ADDR_82;
+	hw->flt_region_boot     = FA_BOOT_CODE_ADDR_82;
+	hw->flt_region_bootload = FA_BOOT_LOAD_ADDR_82;
+	hw->flt_region_fw       = FA_RISC_CODE_ADDR_82;
+done:
+		DEBUG2(dev_info(&ha->pdev->dev, "FLT[%s]: flt = 0x%x fdt = 0x%x boot = 0x%x bootload = 0x%x "
+				"fw = 0x%x\n", loc,
+				hw->flt_region_flt, hw->flt_region_fdt,
+				hw->flt_region_boot, hw->flt_region_bootload,
+				hw->flt_region_fw));
+}
+
+static void
+qla82xx_get_fdt_info(struct scsi_qla_host *ha)
+{
+#define FLASH_BLK_SIZE_4K       0x1000
+#define FLASH_BLK_SIZE_32K      0x8000
+#define FLASH_BLK_SIZE_64K      0x10000
+	const char *loc, *locations[] = { "MID", "FDT" };
+	uint16_t cnt, chksum;
+	uint16_t *wptr;
+	struct qla_fdt_layout *fdt;
+	uint16_t mid = 0, fid = 0;
+	struct ql82xx_hw_data *hw = &ha->hw;
+
+	hw->flash_conf_off = FARX_ACCESS_FLASH_CONF;
+	hw->flash_data_off = FARX_ACCESS_FLASH_DATA;
+
+	wptr = (uint16_t *)ha->request_ring;
+	fdt = (struct qla_fdt_layout *)ha->request_ring;
+	qla82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
+	    hw->flt_region_fdt << 2, OPTROM_BURST_SIZE);
+
+	if (*wptr == __constant_cpu_to_le16(0xffff))
+		goto no_flash_data;
+
+	if (fdt->sig[0] != 'Q' || fdt->sig[1] != 'L' || fdt->sig[2] != 'I' ||
+	    fdt->sig[3] != 'D')
+		goto no_flash_data;
+
+	for (cnt = 0, chksum = 0; cnt < sizeof(struct qla_fdt_layout) >> 1;
+	    cnt++)
+		chksum += le16_to_cpu(*wptr++);
+
+	if (chksum) {
+		DEBUG2(dev_info(&ha->pdev->dev, "Inconsistent FDT detected: "
+		    "checksum = 0x%x id = %c version = 0x%x.\n", chksum, fdt->sig[0],
+		    le16_to_cpu(fdt->version)));
+		DEBUG5(qla4xxx_dump_buffer((uint8_t *)fdt, sizeof(*fdt)));
+		goto no_flash_data;
+	}
+
+	loc = locations[1];
+	mid = le16_to_cpu(fdt->man_id);
+	fid = le16_to_cpu(fdt->id);
+	hw->fdt_wrt_disable = fdt->wrt_disable_bits;
+	hw->fdt_erase_cmd = flash_conf_addr(hw, 0x0300 | fdt->erase_cmd);
+	hw->fdt_block_size = le32_to_cpu(fdt->block_size);
+
+	if (fdt->unprotect_sec_cmd) {
+		hw->fdt_unprotect_sec_cmd = flash_conf_addr(hw, 0x0300 |
+		    fdt->unprotect_sec_cmd);
+		hw->fdt_protect_sec_cmd = fdt->protect_sec_cmd ?
+		    flash_conf_addr(hw, 0x0300 | fdt->protect_sec_cmd) :
+		    flash_conf_addr(hw, 0x0336);
+	}
+	goto done;
+
+no_flash_data:
+	loc = locations[0];
+	hw->fdt_block_size = FLASH_BLK_SIZE_64K;
+done:
+	DEBUG2(dev_info(&ha->pdev->dev, "FDT[%s]: (0x%x/0x%x) erase = 0x%x "
+	    "pro = %x upro = %x wrtd = 0x%x blk = 0x%x.\n", loc, mid, fid,
+	    hw->fdt_erase_cmd, hw->fdt_protect_sec_cmd,
+	    hw->fdt_unprotect_sec_cmd, hw->fdt_wrt_disable,
+	    hw->fdt_block_size));
+}
+
+static void
+qla82xx_get_idc_param(struct scsi_qla_host *ha)
+{
+#define QLA82XX_IDC_PARAM_ADDR      0x003e885c
+	uint32_t *wptr;
+
+	if (!is_qla8022(ha))
+		return;
+	wptr = (uint32_t *)ha->request_ring;
+	qla82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,
+	    QLA82XX_IDC_PARAM_ADDR , 8);
+
+	if (*wptr == __constant_cpu_to_le32(0xffffffff)) {
+		ha->nx_dev_init_timeout = ROM_DEV_INIT_TIMEOUT;
+		ha->nx_reset_timeout = ROM_DRV_RESET_ACK_TIMEOUT;
+	} else {
+		ha->nx_dev_init_timeout = le32_to_cpu(*wptr++);
+		ha->nx_reset_timeout = le32_to_cpu(*wptr);
+	}
+
+	DEBUG2(printk("ha->nx_dev_init_timeout = %d\n",
+	    ha->nx_dev_init_timeout));
+	DEBUG2(printk("ha->nx_reset_timeout = %d\n",
+	    ha->nx_reset_timeout));
+	return;
+}
+
+int
+qla82xx_get_flash_info(struct scsi_qla_host *ha)
+{
+	int ret;
+	uint32_t flt_addr;
+
+	ret = qla82xx_find_flt_start(ha, &flt_addr);
+	if (ret != QLA_SUCCESS)
+		return ret;
+
+	qla82xx_get_flt_info(ha, flt_addr);
+	qla82xx_get_fdt_info(ha);
+	qla82xx_get_idc_param(ha);
+
+	return QLA_SUCCESS;
+}
+
+/**
+ * qla82xx_stop_firmware - stops firmware on specified adapter instance
+ * @ha: pointer to host adapter structure.
+ *
+ * Remarks:
+ * For iSCSI, throws away all I/O and AENs into bit bucket, so they will
+ * not be available after successful return.  Driver must cleanup potential
+ * outstanding I/O's after calling this funcion.
+ **/
+int
+qla82xx_stop_firmware(struct scsi_qla_host *ha)
+{
+	int rval;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_STOP_FW;
+
+	rval = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1,
+	    &mbox_cmd[0], &mbox_sts[0]);
+	DEBUG2(printk("scsi%ld: %s: status = %d\n", ha->host_no,
+	    __func__, rval));
+	return rval;
+}
+
+/**
+ * qla82xx_isp_reset - Resets ISP and aborts all outstanding commands.
+ * @ha: pointer to host adapter structure.
+ **/
+int
+qla82xx_isp_reset(struct scsi_qla_host *ha)
+{
+	int rval;
+	uint32_t dev_state;
+
+	qla82xx_idc_lock(ha);
+	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+
+	if (dev_state == QLA82XX_DEV_READY) {
+		DEBUG2(printk(KERN_INFO"HW State: NEED RESET\n"));
+		qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+		    QLA82XX_DEV_NEED_RESET);
+	} else
+		DEBUG2(printk(KERN_INFO"HW State: DEVICE INITIALIZING\n"));
+
+	qla82xx_idc_unlock(ha);
+
+	rval = qla82xx_device_state_handler(ha);
+
+	qla82xx_idc_lock(ha);
+	qla82xx_clear_rst_ready(ha);
+	qla82xx_idc_unlock(ha);
+
+	return rval;
+}
+
+/**
+ * qla82xx_get_sys_info - Get sys info params
+ * @ha: pointer to host adapter structure.
+ *
+ **/
+int qla82xx_get_sys_info(struct scsi_qla_host *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct mbx_sys_info *sys_info;
+	dma_addr_t sys_info_dma;
+	int status = QLA_ERROR;
+
+	sys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),
+				      &sys_info_dma, GFP_KERNEL);
+	if (sys_info == NULL) {
+		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
+		    ha->host_no, __func__));
+		return status;
+	}
+
+	memset(sys_info, 0, sizeof(*sys_info));
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_GET_SYS_INFO;
+	mbox_cmd[1] = LSDW(sys_info_dma);
+	mbox_cmd[2] = MSDW(sys_info_dma);
+	mbox_cmd[4] = sizeof(*sys_info);
+
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 6, &mbox_cmd[0],
+	    &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: GET_SYS_INFO failed\n",
+		    ha->host_no, __func__));
+		goto exit_sys_info_free;
+	}
+
+	/* Make sure we receive the minimum required data to cache internally*/
+	if (mbox_sts[4] < offsetof(struct mbx_sys_info, reserved)) {
+		DEBUG2(printk("scsi%ld: %s: GET_SYS_INFO data receive error (%x)\n",
+			ha->host_no, __func__, mbox_sts[4]));
+		goto exit_sys_info_free;
+
+	}
+
+	/* Save M.A.C. address & serial_number */
+	memcpy(ha->my_mac, &sys_info->mac_addr[0],
+	       min(sizeof(ha->my_mac), sizeof(sys_info->mac_addr)));
+	memcpy(ha->serial_number, &sys_info->serial_number,
+	       min(sizeof(ha->serial_number), sizeof(sys_info->serial_number)));
+
+	DEBUG2(printk("scsi%ld: %s: "
+	    "mac %02x:%02x:%02x:%02x:%02x:%02x "
+	    "serial %s\n", ha->host_no, __func__,
+	    ha->my_mac[0], ha->my_mac[1], ha->my_mac[2],
+	    ha->my_mac[3], ha->my_mac[4], ha->my_mac[5],
+	    ha->serial_number));
+
+	status = QLA_SUCCESS;
+
+exit_sys_info_free:
+	dma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,
+			  sys_info_dma);
+	return status;
+}
+
+/* Interrupt handling helpers. */
+
+static int
+qla82xx_mbx_intr_enable(struct scsi_qla_host *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	DEBUG2(printk(KERN_INFO"%s\n", __func__));
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;
+	mbox_cmd[1] = INTR_ENABLE;
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],
+		&mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\n",
+			__func__, mbox_sts[0]));
+		return QLA_ERROR;
+	}
+
+	return QLA_SUCCESS;
+}
+
+static int
+qla82xx_mbx_intr_disable(struct scsi_qla_host *ha)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;
+	mbox_cmd[1] = INTR_DISABLE;
+	if (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],
+	    &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\n",
+			__func__, mbox_sts[0]));
+		return QLA_ERROR;
+	}
+
+	return QLA_SUCCESS;
+}
+
+void
+qla82xx_enable_intrs(struct scsi_qla_host *ha)
+{
+	qla82xx_mbx_intr_enable(ha);
+
+	spin_lock_irq(&ha->hardware_lock);
+	/* BIT 10 - reset */
+	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);
+	spin_unlock_irq(&ha->hardware_lock);
+	set_bit(AF_INTERRUPTS_ON, &ha->flags);
+}
+
+void
+qla82xx_disable_intrs(struct scsi_qla_host *ha)
+{
+	if (test_bit(AF_INTERRUPTS_ON, &ha->flags))
+		qla82xx_mbx_intr_disable(ha);
+
+	spin_lock_irq(&ha->hardware_lock);
+	/* BIT 10 - set */
+	qla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);
+	spin_unlock_irq(&ha->hardware_lock);
+	clear_bit(AF_INTERRUPTS_ON, &ha->flags);
+}
+
+struct ql4_init_msix_entry {
+	uint16_t entry;
+	uint16_t index;
+	const char *name;
+	irq_handler_t handler;
+};
+
+static struct ql4_init_msix_entry qla82xx_msix_entries[QLA_MSIX_ENTRIES] = {
+	{ QLA_MSIX_DEFAULT, QLA_MIDX_DEFAULT,
+	    "qla4xxx (default)", (irq_handler_t)qla82xx_default_intr_handler },
+
+	{ QLA_MSIX_RSP_Q, QLA_MIDX_RSP_Q,
+		"qla4xxx (rsp_q)", (irq_handler_t)qla82xx_msix_rsp_q },
+};
+
+void
+qla82xx_disable_msix(struct scsi_qla_host *ha)
+{
+	int i;
+	struct ql4_msix_entry *qentry;
+
+	for (i = 0; i < QLA_MSIX_ENTRIES; i++) {
+		qentry = &ha->msix_entries[qla82xx_msix_entries[i].index];
+		if (qentry->have_irq) {
+			free_irq(qentry->msix_vector, ha);
+			DEBUG2(printk(KERN_INFO "%s: %s\n",
+				__func__, qla82xx_msix_entries[i].name));
+		}
+	}
+	pci_disable_msix(ha->pdev);
+	clear_bit(AF_MSIX_ENABLED, &ha->flags);
+}
+
+int
+qla82xx_enable_msix(struct scsi_qla_host *ha)
+{
+	int i, ret;
+	struct msix_entry entries[QLA_MSIX_ENTRIES];
+	struct ql4_msix_entry *qentry;
+
+	for (i = 0; i < QLA_MSIX_ENTRIES; i++)
+		entries[i].entry = qla82xx_msix_entries[i].entry;
+
+	ret = pci_enable_msix(ha->pdev, entries, ARRAY_SIZE(entries));
+	if (ret) {
+		printk(KERN_WARNING
+		    "MSI-X: Failed to enable support -- %d/%d\n",
+		    QLA_MSIX_ENTRIES, ret);
+		goto msix_out;
+	}
+	set_bit(AF_MSIX_ENABLED, &ha->flags);
+
+	for (i = 0; i < QLA_MSIX_ENTRIES; i++) {
+		qentry = &ha->msix_entries[qla82xx_msix_entries[i].index];
+		qentry->msix_vector = entries[i].vector;
+		qentry->msix_entry = entries[i].entry;
+		qentry->have_irq = 0;
+		ret = request_irq(qentry->msix_vector,
+		    qla82xx_msix_entries[i].handler, 0,
+		    qla82xx_msix_entries[i].name, ha);
+		if (ret) {
+			printk(KERN_WARNING
+			    "MSI-X: Unable to register handler -- %x/%d.\n",
+			    qla82xx_msix_entries[i].index, ret);
+			qla82xx_disable_msix(ha);
+			goto msix_out;
+		}
+		qentry->have_irq = 1;
+	}
+
+msix_out:
+	return ret;
+}
diff --git a/drivers/scsi/qla4xxx/ql4_nx.h b/drivers/scsi/qla4xxx/ql4_nx.h
new file mode 100644
index 0000000..acc086a
--- /dev/null
+++ b/drivers/scsi/qla4xxx/ql4_nx.h
@@ -0,0 +1,779 @@
+/*
+ * QLogic Fibre Channel HBA Driver
+ * Copyright (c)  2003-2008 QLogic Corporation
+ *
+ * See LICENSE.qla2xxx for copyright and licensing details.
+ */
+#ifndef __QLA_NX_H
+#define __QLA_NX_H
+
+/*
+ * Following are the states of the Phantom. Phantom will set them and
+ * Host will read to check if the fields are correct.
+*/
+#define PHAN_INITIALIZE_FAILED		0xffff
+#define PHAN_INITIALIZE_COMPLETE	0xff01
+
+/* Host writes the following to notify that it has done the init-handshake */
+#define PHAN_INITIALIZE_ACK		0xf00f
+#define PHAN_PEG_RCV_INITIALIZED	0xff01
+
+/*CRB_RELATED*/
+#define QLA82XX_CRB_BASE	QLA82XX_CAM_RAM(0x200)
+#define QLA82XX_REG(X)		(QLA82XX_CRB_BASE+(X))
+
+#define CRB_CMDPEG_STATE		QLA82XX_REG(0x50)
+#define CRB_RCVPEG_STATE		QLA82XX_REG(0x13c)
+#define BOOT_LOADER_DIMM_STATUS		QLA82XX_REG(0x54)
+#define CRB_DMA_SHIFT			QLA82XX_REG(0xcc)
+
+#define QLA82XX_HW_H0_CH_HUB_ADR	0x05
+#define QLA82XX_HW_H1_CH_HUB_ADR	0x0E
+#define QLA82XX_HW_H2_CH_HUB_ADR	0x03
+#define QLA82XX_HW_H3_CH_HUB_ADR	0x01
+#define QLA82XX_HW_H4_CH_HUB_ADR	0x06
+#define QLA82XX_HW_H5_CH_HUB_ADR	0x07
+#define QLA82XX_HW_H6_CH_HUB_ADR	0x08
+
+/*  Hub 0 */
+#define QLA82XX_HW_MN_CRB_AGT_ADR	0x15
+#define QLA82XX_HW_MS_CRB_AGT_ADR	0x25
+
+/*  Hub 1 */
+#define QLA82XX_HW_PS_CRB_AGT_ADR	0x73
+#define QLA82XX_HW_QMS_CRB_AGT_ADR	0x00
+#define QLA82XX_HW_RPMX3_CRB_AGT_ADR	0x0b
+#define QLA82XX_HW_SQGS0_CRB_AGT_ADR	0x01
+#define QLA82XX_HW_SQGS1_CRB_AGT_ADR	0x02
+#define QLA82XX_HW_SQGS2_CRB_AGT_ADR	0x03
+#define QLA82XX_HW_SQGS3_CRB_AGT_ADR	0x04
+#define QLA82XX_HW_C2C0_CRB_AGT_ADR	0x58
+#define QLA82XX_HW_C2C1_CRB_AGT_ADR	0x59
+#define QLA82XX_HW_C2C2_CRB_AGT_ADR	0x5a
+#define QLA82XX_HW_RPMX2_CRB_AGT_ADR	0x0a
+#define QLA82XX_HW_RPMX4_CRB_AGT_ADR	0x0c
+#define QLA82XX_HW_RPMX7_CRB_AGT_ADR	0x0f
+#define QLA82XX_HW_RPMX9_CRB_AGT_ADR	0x12
+#define QLA82XX_HW_SMB_CRB_AGT_ADR	0x18
+
+/*  Hub 2 */
+#define QLA82XX_HW_NIU_CRB_AGT_ADR	0x31
+#define QLA82XX_HW_I2C0_CRB_AGT_ADR	0x19
+#define QLA82XX_HW_I2C1_CRB_AGT_ADR	0x29
+
+#define QLA82XX_HW_SN_CRB_AGT_ADR	0x10
+#define QLA82XX_HW_I2Q_CRB_AGT_ADR	0x20
+#define QLA82XX_HW_LPC_CRB_AGT_ADR	0x22
+#define QLA82XX_HW_ROMUSB_CRB_AGT_ADR   0x21
+#define QLA82XX_HW_QM_CRB_AGT_ADR	0x66
+#define QLA82XX_HW_SQG0_CRB_AGT_ADR	0x60
+#define QLA82XX_HW_SQG1_CRB_AGT_ADR	0x61
+#define QLA82XX_HW_SQG2_CRB_AGT_ADR	0x62
+#define QLA82XX_HW_SQG3_CRB_AGT_ADR	0x63
+#define QLA82XX_HW_RPMX1_CRB_AGT_ADR    0x09
+#define QLA82XX_HW_RPMX5_CRB_AGT_ADR    0x0d
+#define QLA82XX_HW_RPMX6_CRB_AGT_ADR    0x0e
+#define QLA82XX_HW_RPMX8_CRB_AGT_ADR    0x11
+
+/*  Hub 3 */
+#define QLA82XX_HW_PH_CRB_AGT_ADR	0x1A
+#define QLA82XX_HW_SRE_CRB_AGT_ADR	0x50
+#define QLA82XX_HW_EG_CRB_AGT_ADR	0x51
+#define QLA82XX_HW_RPMX0_CRB_AGT_ADR	0x08
+
+/*  Hub 4 */
+#define QLA82XX_HW_PEGN0_CRB_AGT_ADR	0x40
+#define QLA82XX_HW_PEGN1_CRB_AGT_ADR	0x41
+#define QLA82XX_HW_PEGN2_CRB_AGT_ADR	0x42
+#define QLA82XX_HW_PEGN3_CRB_AGT_ADR	0x43
+#define QLA82XX_HW_PEGNI_CRB_AGT_ADR	0x44
+#define QLA82XX_HW_PEGND_CRB_AGT_ADR	0x45
+#define QLA82XX_HW_PEGNC_CRB_AGT_ADR	0x46
+#define QLA82XX_HW_PEGR0_CRB_AGT_ADR	0x47
+#define QLA82XX_HW_PEGR1_CRB_AGT_ADR	0x48
+#define QLA82XX_HW_PEGR2_CRB_AGT_ADR	0x49
+#define QLA82XX_HW_PEGR3_CRB_AGT_ADR	0x4a
+#define QLA82XX_HW_PEGN4_CRB_AGT_ADR	0x4b
+
+/*  Hub 5 */
+#define QLA82XX_HW_PEGS0_CRB_AGT_ADR	0x40
+#define QLA82XX_HW_PEGS1_CRB_AGT_ADR	0x41
+#define QLA82XX_HW_PEGS2_CRB_AGT_ADR	0x42
+#define QLA82XX_HW_PEGS3_CRB_AGT_ADR	0x43
+
+#define QLA82XX_HW_PEGSI_CRB_AGT_ADR	0x44
+#define QLA82XX_HW_PEGSD_CRB_AGT_ADR	0x45
+#define QLA82XX_HW_PEGSC_CRB_AGT_ADR	0x46
+
+/*  Hub 6 */
+#define QLA82XX_HW_CAS0_CRB_AGT_ADR	0x46
+#define QLA82XX_HW_CAS1_CRB_AGT_ADR	0x47
+#define QLA82XX_HW_CAS2_CRB_AGT_ADR	0x48
+#define QLA82XX_HW_CAS3_CRB_AGT_ADR	0x49
+#define QLA82XX_HW_NCM_CRB_AGT_ADR	0x16
+#define QLA82XX_HW_TMR_CRB_AGT_ADR	0x17
+#define QLA82XX_HW_XDMA_CRB_AGT_ADR	0x05
+#define QLA82XX_HW_OCM0_CRB_AGT_ADR	0x06
+#define QLA82XX_HW_OCM1_CRB_AGT_ADR	0x07
+
+/*  This field defines PCI/X adr [25:20] of agents on the CRB */
+/*  */
+#define QLA82XX_HW_PX_MAP_CRB_PH	0
+#define QLA82XX_HW_PX_MAP_CRB_PS	1
+#define QLA82XX_HW_PX_MAP_CRB_MN	2
+#define QLA82XX_HW_PX_MAP_CRB_MS	3
+#define QLA82XX_HW_PX_MAP_CRB_SRE	5
+#define QLA82XX_HW_PX_MAP_CRB_NIU	6
+#define QLA82XX_HW_PX_MAP_CRB_QMN	7
+#define QLA82XX_HW_PX_MAP_CRB_SQN0	8
+#define QLA82XX_HW_PX_MAP_CRB_SQN1	9
+#define QLA82XX_HW_PX_MAP_CRB_SQN2	10
+#define QLA82XX_HW_PX_MAP_CRB_SQN3	11
+#define QLA82XX_HW_PX_MAP_CRB_QMS	12
+#define QLA82XX_HW_PX_MAP_CRB_SQS0	13
+#define QLA82XX_HW_PX_MAP_CRB_SQS1	14
+#define QLA82XX_HW_PX_MAP_CRB_SQS2	15
+#define QLA82XX_HW_PX_MAP_CRB_SQS3	16
+#define QLA82XX_HW_PX_MAP_CRB_PGN0	17
+#define QLA82XX_HW_PX_MAP_CRB_PGN1	18
+#define QLA82XX_HW_PX_MAP_CRB_PGN2	19
+#define QLA82XX_HW_PX_MAP_CRB_PGN3	20
+#define QLA82XX_HW_PX_MAP_CRB_PGN4	QLA82XX_HW_PX_MAP_CRB_SQS2
+#define QLA82XX_HW_PX_MAP_CRB_PGND	21
+#define QLA82XX_HW_PX_MAP_CRB_PGNI	22
+#define QLA82XX_HW_PX_MAP_CRB_PGS0	23
+#define QLA82XX_HW_PX_MAP_CRB_PGS1	24
+#define QLA82XX_HW_PX_MAP_CRB_PGS2	25
+#define QLA82XX_HW_PX_MAP_CRB_PGS3	26
+#define QLA82XX_HW_PX_MAP_CRB_PGSD	27
+#define QLA82XX_HW_PX_MAP_CRB_PGSI	28
+#define QLA82XX_HW_PX_MAP_CRB_SN	29
+#define QLA82XX_HW_PX_MAP_CRB_EG	31
+#define QLA82XX_HW_PX_MAP_CRB_PH2	32
+#define QLA82XX_HW_PX_MAP_CRB_PS2	33
+#define QLA82XX_HW_PX_MAP_CRB_CAM	34
+#define QLA82XX_HW_PX_MAP_CRB_CAS0	35
+#define QLA82XX_HW_PX_MAP_CRB_CAS1	36
+#define QLA82XX_HW_PX_MAP_CRB_CAS2	37
+#define QLA82XX_HW_PX_MAP_CRB_C2C0	38
+#define QLA82XX_HW_PX_MAP_CRB_C2C1	39
+#define QLA82XX_HW_PX_MAP_CRB_TIMR	40
+#define QLA82XX_HW_PX_MAP_CRB_RPMX1	42
+#define QLA82XX_HW_PX_MAP_CRB_RPMX2	43
+#define QLA82XX_HW_PX_MAP_CRB_RPMX3	44
+#define QLA82XX_HW_PX_MAP_CRB_RPMX4	45
+#define QLA82XX_HW_PX_MAP_CRB_RPMX5	46
+#define QLA82XX_HW_PX_MAP_CRB_RPMX6	47
+#define QLA82XX_HW_PX_MAP_CRB_RPMX7	48
+#define QLA82XX_HW_PX_MAP_CRB_XDMA	49
+#define QLA82XX_HW_PX_MAP_CRB_I2Q	50
+#define QLA82XX_HW_PX_MAP_CRB_ROMUSB    51
+#define QLA82XX_HW_PX_MAP_CRB_CAS3	52
+#define QLA82XX_HW_PX_MAP_CRB_RPMX0	53
+#define QLA82XX_HW_PX_MAP_CRB_RPMX8	54
+#define QLA82XX_HW_PX_MAP_CRB_RPMX9	55
+#define QLA82XX_HW_PX_MAP_CRB_OCM0	56
+#define QLA82XX_HW_PX_MAP_CRB_OCM1	57
+#define QLA82XX_HW_PX_MAP_CRB_SMB	58
+#define QLA82XX_HW_PX_MAP_CRB_I2C0	59
+#define QLA82XX_HW_PX_MAP_CRB_I2C1	60
+#define QLA82XX_HW_PX_MAP_CRB_LPC	61
+#define QLA82XX_HW_PX_MAP_CRB_PGNC	62
+#define QLA82XX_HW_PX_MAP_CRB_PGR0	63
+#define QLA82XX_HW_PX_MAP_CRB_PGR1	4
+#define QLA82XX_HW_PX_MAP_CRB_PGR2	30
+#define QLA82XX_HW_PX_MAP_CRB_PGR3	41
+
+/*  This field defines CRB adr [31:20] of the agents */
+/*  */
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_MN	((QLA82XX_HW_H0_CH_HUB_ADR << 7) | \
+					QLA82XX_HW_MN_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PH	((QLA82XX_HW_H0_CH_HUB_ADR << 7) | \
+					QLA82XX_HW_PH_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_MS	((QLA82XX_HW_H0_CH_HUB_ADR << 7) | \
+					QLA82XX_HW_MS_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PS	((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					QLA82XX_HW_PS_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SS	((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					QLA82XX_HW_SS_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX3    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX3_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_QMS	    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_QMS_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQS0     ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQGS0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQS1     ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQGS1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQS2     ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQGS2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQS3     ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQGS3_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_C2C0     ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_C2C0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_C2C1     ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_C2C1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX2    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX4    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX4_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX7    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX7_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX9    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX9_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SMB	    ((QLA82XX_HW_H1_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SMB_CRB_AGT_ADR)
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_NIU      ((QLA82XX_HW_H2_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_NIU_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_I2C0     ((QLA82XX_HW_H2_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_I2C0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_I2C1     ((QLA82XX_HW_H2_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_I2C1_CRB_AGT_ADR)
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SRE      ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SRE_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_EG       ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_EG_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX0    ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_QMN      ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_QM_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQN0     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQG0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQN1     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQG1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQN2     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQG2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SQN3     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SQG3_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX1    ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX5    ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX5_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX6    ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX6_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_RPMX8    ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_RPMX8_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_CAS0     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_CAS0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_CAS1     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_CAS1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_CAS2     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_CAS2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_CAS3     ((QLA82XX_HW_H3_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_CAS3_CRB_AGT_ADR)
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGNI     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGNI_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGND     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGND_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGN0     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGN0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGN1     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGN1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGN2     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGN2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGN3     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGN3_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGN4     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGN4_CRB_AGT_ADR)
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGNC     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGNC_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGR0     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGR0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGR1     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGR1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGR2     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGR2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGR3     ((QLA82XX_HW_H4_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGR3_CRB_AGT_ADR)
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGSI     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGSI_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGSD     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGSD_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGS0     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGS0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGS1     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGS1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGS2     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGS2_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGS3     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGS3_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_PGSC     ((QLA82XX_HW_H5_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_PEGSC_CRB_AGT_ADR)
+
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_CAM      ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_NCM_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_TIMR     ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_TMR_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_XDMA     ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_XDMA_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_SN       ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_SN_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_I2Q      ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_I2Q_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB   ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_ROMUSB_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_OCM0     ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_OCM0_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_OCM1     ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_OCM1_CRB_AGT_ADR)
+#define QLA82XX_HW_CRB_HUB_AGT_ADR_LPC      ((QLA82XX_HW_H6_CH_HUB_ADR << 7) | \
+					    QLA82XX_HW_LPC_CRB_AGT_ADR)
+
+#define ROMUSB_GLB	(QLA82XX_CRB_ROMUSB + 0x00000)
+#define QLA82XX_ROMUSB_GLB_PEGTUNE_DONE		(ROMUSB_GLB + 0x005c)
+#define QLA82XX_ROMUSB_GLB_STATUS		(ROMUSB_GLB + 0x0004)
+#define QLA82XX_ROMUSB_GLB_SW_RESET		(ROMUSB_GLB + 0x0008)
+#define QLA82XX_ROMUSB_ROM_ADDRESS		(ROMUSB_ROM + 0x0008)
+#define QLA82XX_ROMUSB_ROM_WDATA		(ROMUSB_ROM + 0x000c)
+#define QLA82XX_ROMUSB_ROM_ABYTE_CNT		(ROMUSB_ROM + 0x0010)
+#define QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT	(ROMUSB_ROM + 0x0014)
+#define QLA82XX_ROMUSB_ROM_RDATA		(ROMUSB_ROM + 0x0018)
+
+#define ROMUSB_ROM	(QLA82XX_CRB_ROMUSB + 0x10000)
+#define QLA82XX_ROMUSB_ROM_INSTR_OPCODE	(ROMUSB_ROM + 0x0004)
+#define QLA82XX_ROMUSB_GLB_CAS_RST	(ROMUSB_GLB + 0x0038)
+
+/* Lock IDs for ROM lock */
+#define ROM_LOCK_DRIVER		0x0d417340
+
+#define QLA82XX_PCI_CRB_WINDOWSIZE	0x00100000    /* all are 1MB windows */
+#define QLA82XX_PCI_CRB_WINDOW(A)	(QLA82XX_PCI_CRBSPACE + \
+					(A)*QLA82XX_PCI_CRB_WINDOWSIZE)
+
+#define QLA82XX_CRB_C2C_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_C2C0)
+#define QLA82XX_CRB_C2C_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_C2C1)
+#define QLA82XX_CRB_C2C_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_C2C2)
+#define QLA82XX_CRB_CAM \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_CAM)
+#define QLA82XX_CRB_CASPER \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_CAS)
+#define QLA82XX_CRB_CASPER_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_CAS0)
+#define QLA82XX_CRB_CASPER_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_CAS1)
+#define QLA82XX_CRB_CASPER_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_CAS2)
+#define QLA82XX_CRB_DDR_MD \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_MS)
+#define QLA82XX_CRB_DDR_NET \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_MN)
+#define QLA82XX_CRB_EPG \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_EG)
+#define QLA82XX_CRB_I2Q \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_I2Q)
+#define QLA82XX_CRB_NIU \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_NIU)
+/* HACK upon HACK upon HACK (for PCIE builds) */
+#define QLA82XX_CRB_PCIX_HOST \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PH)
+#define QLA82XX_CRB_PCIX_HOST2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PH2)
+#define QLA82XX_CRB_PCIX_MD \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PS)
+#define QLA82XX_CRB_PCIE	QLA82XX_CRB_PCIX_MD
+/* window 1 pcie slot */
+#define QLA82XX_CRB_PCIE2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PS2)
+
+#define QLA82XX_CRB_PEG_MD_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGS0)
+#define QLA82XX_CRB_PEG_MD_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGS1)
+#define QLA82XX_CRB_PEG_MD_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGS2)
+#define QLA82XX_CRB_PEG_MD_3 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGS3)
+#define QLA82XX_CRB_PEG_MD_3 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGS3)
+#define QLA82XX_CRB_PEG_MD_D \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGSD)
+#define QLA82XX_CRB_PEG_MD_I \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGSI)
+#define QLA82XX_CRB_PEG_NET_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGN0)
+#define QLA82XX_CRB_PEG_NET_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGN1)
+#define QLA82XX_CRB_PEG_NET_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGN2)
+#define QLA82XX_CRB_PEG_NET_3 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGN3)
+#define QLA82XX_CRB_PEG_NET_4 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGN4)
+#define QLA82XX_CRB_PEG_NET_D \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGND)
+#define QLA82XX_CRB_PEG_NET_I \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_PGNI)
+#define QLA82XX_CRB_PQM_MD \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_QMS)
+#define QLA82XX_CRB_PQM_NET \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_QMN)
+#define QLA82XX_CRB_QDR_MD \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SS)
+#define QLA82XX_CRB_QDR_NET \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SN)
+#define QLA82XX_CRB_ROMUSB \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_ROMUSB)
+#define QLA82XX_CRB_RPMX_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX0)
+#define QLA82XX_CRB_RPMX_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX1)
+#define QLA82XX_CRB_RPMX_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX2)
+#define QLA82XX_CRB_RPMX_3 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX3)
+#define QLA82XX_CRB_RPMX_4 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX4)
+#define QLA82XX_CRB_RPMX_5 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX5)
+#define QLA82XX_CRB_RPMX_6 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX6)
+#define QLA82XX_CRB_RPMX_7 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_RPMX7)
+#define QLA82XX_CRB_SQM_MD_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQS0)
+#define QLA82XX_CRB_SQM_MD_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQS1)
+#define QLA82XX_CRB_SQM_MD_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQS2)
+#define QLA82XX_CRB_SQM_MD_3 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQS3)
+#define QLA82XX_CRB_SQM_NET_0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQN0)
+#define QLA82XX_CRB_SQM_NET_1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQN1)
+#define QLA82XX_CRB_SQM_NET_2 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQN2)
+#define QLA82XX_CRB_SQM_NET_3 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SQN3)
+#define QLA82XX_CRB_SRE \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SRE)
+#define QLA82XX_CRB_TIMER \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_TIMR)
+#define QLA82XX_CRB_XDMA \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_XDMA)
+#define QLA82XX_CRB_I2C0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_I2C0)
+#define QLA82XX_CRB_I2C1 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_I2C1)
+#define QLA82XX_CRB_OCM0 \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_OCM0)
+#define QLA82XX_CRB_SMB \
+	QLA82XX_PCI_CRB_WINDOW(QLA82XX_HW_PX_MAP_CRB_SMB)
+
+
+#define QLA82XX_CRB_MAX		QLA82XX_PCI_CRB_WINDOW(64)
+
+/*
+ * ====================== BASE ADDRESSES ON-CHIP ======================
+ * Base addresses of major components on-chip.
+ * ====================== BASE ADDRESSES ON-CHIP ======================
+ */
+#define QLA82XX_ADDR_DDR_NET		(0x0000000000000000ULL)
+#define QLA82XX_ADDR_DDR_NET_MAX	(0x000000000fffffffULL)
+
+/* Imbus address bit used to indicate a host address. This bit is
+ * eliminated by the pcie bar and bar select before presentation
+ * over pcie. */
+/* host memory via IMBUS */
+#define QLA82XX_P2_ADDR_PCIE	(0x0000000800000000ULL)
+#define QLA82XX_P3_ADDR_PCIE	(0x0000008000000000ULL)
+#define QLA82XX_ADDR_PCIE_MAX	(0x0000000FFFFFFFFFULL)
+#define QLA82XX_ADDR_OCM0	(0x0000000200000000ULL)
+#define QLA82XX_ADDR_OCM0_MAX	(0x00000002000fffffULL)
+#define QLA82XX_ADDR_OCM1	(0x0000000200400000ULL)
+#define QLA82XX_ADDR_OCM1_MAX	(0x00000002004fffffULL)
+#define QLA82XX_ADDR_QDR_NET	(0x0000000300000000ULL)
+
+#define QLA82XX_P2_ADDR_QDR_NET_MAX	(0x00000003001fffffULL)
+#define QLA82XX_P3_ADDR_QDR_NET_MAX	(0x0000000303ffffffULL)
+
+#define QLA82XX_PCI_CRBSPACE		(unsigned long)0x06000000
+#define QLA82XX_PCI_DIRECT_CRB		(unsigned long)0x04400000
+#define QLA82XX_PCI_CAMQM		(unsigned long)0x04800000
+#define QLA82XX_PCI_CAMQM_MAX		(unsigned long)0x04ffffff
+#define QLA82XX_PCI_DDR_NET		(unsigned long)0x00000000
+#define QLA82XX_PCI_QDR_NET		(unsigned long)0x04000000
+#define QLA82XX_PCI_QDR_NET_MAX		(unsigned long)0x043fffff
+
+/*
+ *   Register offsets for MN
+ */
+#define MIU_CONTROL			(0x000)
+#define MIU_TAG				(0x004)
+#define MIU_TEST_AGT_CTRL		(0x090)
+#define MIU_TEST_AGT_ADDR_LO		(0x094)
+#define MIU_TEST_AGT_ADDR_HI		(0x098)
+#define MIU_TEST_AGT_WRDATA_LO		(0x0a0)
+#define MIU_TEST_AGT_WRDATA_HI		(0x0a4)
+#define MIU_TEST_AGT_WRDATA(i)		(0x0a0+(4*(i)))
+#define MIU_TEST_AGT_RDDATA_LO		(0x0a8)
+#define MIU_TEST_AGT_RDDATA_HI		(0x0ac)
+#define MIU_TEST_AGT_RDDATA(i)		(0x0a8+(4*(i)))
+#define MIU_TEST_AGT_ADDR_MASK		0xfffffff8
+#define MIU_TEST_AGT_UPPER_ADDR(off)	(0)
+
+/* MIU_TEST_AGT_CTRL flags. work for SIU as well */
+#define MIU_TA_CTL_START	1
+#define MIU_TA_CTL_ENABLE	2
+#define MIU_TA_CTL_WRITE	4
+#define MIU_TA_CTL_BUSY		8
+
+/*CAM RAM */
+# define QLA82XX_CAM_RAM_BASE	(QLA82XX_CRB_CAM + 0x02000)
+# define QLA82XX_CAM_RAM(reg)	(QLA82XX_CAM_RAM_BASE + (reg))
+
+#define QLA82XX_PEG_TUNE_MN_SPD_ZEROED	0x80000000
+#define QLA82XX_BOOT_LOADER_MN_ISSUE	0xff00ffff
+#define QLA82XX_PORT_MODE_ADDR		(QLA82XX_CAM_RAM(0x24))
+#define QLA82XX_PEG_HALT_STATUS1	(QLA82XX_CAM_RAM(0xa8))
+#define QLA82XX_PEG_HALT_STATUS2	(QLA82XX_CAM_RAM(0xac))
+#define QLA82XX_PEG_ALIVE_COUNTER	(QLA82XX_CAM_RAM(0xb0))
+
+#define HALT_STATUS_UNRECOVERABLE	0x80000000
+#define HALT_STATUS_RECOVERABLE		0x40000000
+
+
+#define QLA82XX_ROM_LOCK_ID		(QLA82XX_CAM_RAM(0x100))
+#define QLA82XX_CRB_WIN_LOCK_ID		(QLA82XX_CAM_RAM(0x124))
+#define QLA82XX_FW_VERSION_MAJOR	(QLA82XX_CAM_RAM(0x150))
+#define QLA82XX_FW_VERSION_MINOR	(QLA82XX_CAM_RAM(0x154))
+#define QLA82XX_FW_VERSION_SUB		(QLA82XX_CAM_RAM(0x158))
+#define QLA82XX_PCIE_REG(reg)		(QLA82XX_CRB_PCIE + (reg))
+
+/* Driver Coexistence Defines */
+#define QLA82XX_CRB_DRV_ACTIVE		(QLA82XX_CAM_RAM(0x138))
+#define QLA82XX_CRB_DEV_STATE		(QLA82XX_CAM_RAM(0x140))
+#define QLA82XX_CRB_DEV_PART_INFO	(QLA82XX_CAM_RAM(0x14c))
+#define QLA82XX_CRB_DRV_IDC_VERSION	(QLA82XX_CAM_RAM(0x174))
+#define QLA82XX_CRB_DRV_STATE		(QLA82XX_CAM_RAM(0x144))
+#define QLA82XX_CRB_DRV_SCRATCH		(QLA82XX_CAM_RAM(0x148))
+#define QLA82XX_CRB_DEV_PART_INFO	(QLA82XX_CAM_RAM(0x14c))
+
+/* Every driver should use these Device State */
+#define QLA82XX_DEV_COLD		1
+#define QLA82XX_DEV_INITIALIZING	2
+#define QLA82XX_DEV_READY		3
+#define QLA82XX_DEV_NEED_RESET		4
+#define QLA82XX_DEV_NEED_QUIESCENT	5
+#define QLA82XX_DEV_FAILED		6
+#define QLA82XX_DEV_QUIESCENT		7
+#define MAX_STATES			8 /* Increment if new state added */
+
+#define QLA82XX_IDC_VERSION		0x1
+#define ROM_DEV_INIT_TIMEOUT		30
+#define ROM_DRV_RESET_ACK_TIMEOUT	10
+
+#define PCIE_SETUP_FUNCTION		(0x12040)
+#define PCIE_SETUP_FUNCTION2		(0x12048)
+
+#define QLA82XX_PCIX_PS_REG(reg)	(QLA82XX_CRB_PCIX_MD + (reg))
+#define QLA82XX_PCIX_PS2_REG(reg)	(QLA82XX_CRB_PCIE2 + (reg))
+
+#define PCIE_SEM2_LOCK		(0x1c010)  /* Flash lock   */
+#define PCIE_SEM2_UNLOCK	(0x1c014)  /* Flash unlock */
+#define PCIE_SEM5_LOCK		(0x1c028)  /* Coexistence lock   */
+#define PCIE_SEM5_UNLOCK	(0x1c02c)  /* Coexistence unlock */
+#define PCIE_SEM7_LOCK		(0x1c038)  /* crb win lock */
+#define PCIE_SEM7_UNLOCK	(0x1c03c)  /* crbwin unlock*/
+
+/*
+ * The PCI VendorID and DeviceID for our board.
+ */
+#define QLA82XX_MSIX_TBL_SPACE		8192
+#define QLA82XX_PCI_REG_MSIX_TBL	0x44
+#define QLA82XX_PCI_MSIX_CONTROL	0x40
+
+struct crb_128M_2M_sub_block_map {
+	unsigned valid;
+	unsigned start_128M;
+	unsigned end_128M;
+	unsigned start_2M;
+};
+
+struct crb_128M_2M_block_map {
+	struct crb_128M_2M_sub_block_map sub_block[16];
+};
+
+struct crb_addr_pair {
+	long addr;
+	long data;
+};
+
+#define ADDR_ERROR	((unsigned long) 0xffffffff)
+#define MAX_CTL_CHECK	1000
+
+/***************************************************************************
+ *		PCI related defines.
+ **************************************************************************/
+
+/*
+ * Interrupt related defines.
+ */
+#define PCIX_TARGET_STATUS	(0x10118)
+#define PCIX_TARGET_STATUS_F1	(0x10160)
+#define PCIX_TARGET_STATUS_F2	(0x10164)
+#define PCIX_TARGET_STATUS_F3	(0x10168)
+#define PCIX_TARGET_STATUS_F4	(0x10360)
+#define PCIX_TARGET_STATUS_F5	(0x10364)
+#define PCIX_TARGET_STATUS_F6	(0x10368)
+#define PCIX_TARGET_STATUS_F7	(0x1036c)
+
+#define PCIX_TARGET_MASK	(0x10128)
+#define PCIX_TARGET_MASK_F1	(0x10170)
+#define PCIX_TARGET_MASK_F2	(0x10174)
+#define PCIX_TARGET_MASK_F3	(0x10178)
+#define PCIX_TARGET_MASK_F4	(0x10370)
+#define PCIX_TARGET_MASK_F5	(0x10374)
+#define PCIX_TARGET_MASK_F6	(0x10378)
+#define PCIX_TARGET_MASK_F7	(0x1037c)
+
+/*
+ * Message Signaled Interrupts
+ */
+#define PCIX_MSI_F0		(0x13000)
+#define PCIX_MSI_F1		(0x13004)
+#define PCIX_MSI_F2		(0x13008)
+#define PCIX_MSI_F3		(0x1300c)
+#define PCIX_MSI_F4		(0x13010)
+#define PCIX_MSI_F5		(0x13014)
+#define PCIX_MSI_F6		(0x13018)
+#define PCIX_MSI_F7		(0x1301c)
+#define PCIX_MSI_F(FUNC)	(0x13000 + ((FUNC) * 4))
+
+/*
+ *
+ */
+#define PCIX_INT_VECTOR		(0x10100)
+#define PCIX_INT_MASK		(0x10104)
+
+/*
+ * Interrupt state machine and other bits.
+ */
+#define PCIE_MISCCFG_RC		(0x1206c)
+
+#define ISR_INT_TARGET_STATUS \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS))
+#define ISR_INT_TARGET_STATUS_F1 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F1))
+#define ISR_INT_TARGET_STATUS_F2 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F2))
+#define ISR_INT_TARGET_STATUS_F3 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F3))
+#define ISR_INT_TARGET_STATUS_F4 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F4))
+#define ISR_INT_TARGET_STATUS_F5 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F5))
+#define ISR_INT_TARGET_STATUS_F6 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F6))
+#define ISR_INT_TARGET_STATUS_F7 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_STATUS_F7))
+
+#define ISR_INT_TARGET_MASK \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK))
+#define ISR_INT_TARGET_MASK_F1 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F1))
+#define ISR_INT_TARGET_MASK_F2 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F2))
+#define ISR_INT_TARGET_MASK_F3 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F3))
+#define ISR_INT_TARGET_MASK_F4 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F4))
+#define ISR_INT_TARGET_MASK_F5 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F5))
+#define ISR_INT_TARGET_MASK_F6 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F6))
+#define ISR_INT_TARGET_MASK_F7 \
+	(QLA82XX_PCIX_PS_REG(PCIX_TARGET_MASK_F7))
+
+#define ISR_INT_VECTOR			(QLA82XX_PCIX_PS_REG(PCIX_INT_VECTOR))
+#define ISR_INT_MASK			(QLA82XX_PCIX_PS_REG(PCIX_INT_MASK))
+#define ISR_INT_STATE_REG		(QLA82XX_PCIX_PS_REG(PCIE_MISCCFG_RC))
+
+#define	ISR_MSI_INT_TRIGGER(FUNC)	(QLA82XX_PCIX_PS_REG(PCIX_MSI_F(FUNC)))
+
+
+#define	ISR_IS_LEGACY_INTR_IDLE(VAL)		(((VAL) & 0x300) == 0)
+#define	ISR_IS_LEGACY_INTR_TRIGGERED(VAL)	(((VAL) & 0x300) == 0x200)
+
+/*
+ * PCI Interrupt Vector Values.
+ */
+#define	PCIX_INT_VECTOR_BIT_F0	0x0080
+#define	PCIX_INT_VECTOR_BIT_F1	0x0100
+#define	PCIX_INT_VECTOR_BIT_F2	0x0200
+#define	PCIX_INT_VECTOR_BIT_F3	0x0400
+#define	PCIX_INT_VECTOR_BIT_F4	0x0800
+#define	PCIX_INT_VECTOR_BIT_F5	0x1000
+#define	PCIX_INT_VECTOR_BIT_F6	0x2000
+#define	PCIX_INT_VECTOR_BIT_F7	0x4000
+
+/* struct qla82xx_legacy_intr_set defined in ql4_def.h */
+
+#define QLA82XX_LEGACY_INTR_CONFIG                                      \
+{                                                                       \
+	{                                                               \
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F0,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS,          \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK,            \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(0) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F1,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F1,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F1,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(1) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F2,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F2,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F2,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(2) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F3,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F3,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F3,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(3) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F4,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F4,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F4,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(4) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F5,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F5,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F5,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(5) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F6,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F6,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F6,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(6) },       \
+									\
+	{								\
+		.int_vec_bit    =	PCIX_INT_VECTOR_BIT_F7,         \
+		.tgt_status_reg =	ISR_INT_TARGET_STATUS_F7,       \
+		.tgt_mask_reg   =	ISR_INT_TARGET_MASK_F7,         \
+		.pci_int_reg    =	ISR_MSI_INT_TRIGGER(7) },       \
+}
+
+/* Magic number to let user know flash is programmed */
+#define QLA82XX_BDINFO_MAGIC 	0x12345678
+#define FW_SIZE_OFFSET		(0x3e840c)
+
+/* QLA82XX additions */
+#define MIU_TEST_AGT_WRDATA_UPPER_LO	(0x0b0)
+#define	MIU_TEST_AGT_WRDATA_UPPER_HI	(0x0b4)
+
+#endif
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 401fe24..000b1ce 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -24,41 +24,49 @@
 char qla4xxx_version_str[64];
 EXPORT_SYMBOL_GPL(qla4xxx_version_str);
 
-/*      
+/*
  * List of host adapters
  */
 struct klist qla4xxx_hostlist;
- 
+
 struct klist *qla4xxx_hostlist_ptr = &qla4xxx_hostlist;
 EXPORT_SYMBOL_GPL(qla4xxx_hostlist_ptr);
- 
+
 static atomic_t qla4xxx_hba_count;
- 
+
 /*
  * SRB allocation cache
  */
-static kmem_cache_t *srb_cachep;
+static struct kmem_cache *srb_cachep;
 
 /*
  * Module parameter information and variables
  */
-int ql4xdiscoverywait = 60;
-module_param(ql4xdiscoverywait, int, S_IRUGO | S_IRUSR);
+int ql4xdiscoverywait = 10;
+module_param(ql4xdiscoverywait, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(ql4xdiscoverywait, "Discovery wait time");
 int ql4xdontresethba = 0;
-module_param(ql4xdontresethba, int, S_IRUGO | S_IRUSR);
+module_param(ql4xdontresethba, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(ql4xdontresethba,
-		 "Dont reset the HBA when the driver gets 0x8002 AEN "
-		 " default it will reset hba :0"
-		 " set to 1 to avoid resetting HBA");
-
-int extended_error_logging = 0; /* 0 = off, 1 = log errors */
-module_param(extended_error_logging, int, S_IRUGO | S_IRUSR);
-MODULE_PARM_DESC(extended_error_logging,
-		 "Option to enable extended error logging, "
-		 "Default is 0 - no logging, 1 - debug logging");
+		 " Don't reset the HBA for driver recovery\n"
+		 " \t\t 0 - It will reset HBA (Default)\n"
+		 " \t\t 1 - It will NOT reset HBA");
+
+int ql4xextended_error_logging = 0; /* 0 = off, 1 = log errors */
+module_param(ql4xextended_error_logging, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(ql4xextended_error_logging,
+		 " Option to enable extended error logging,\n"
+		 "\t\t 0 - no logging (Default).\n"
+		 "\t\t 2 - debug logging");
+
+int ql4xenablemsix = 1;
+module_param(ql4xenablemsix, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(ql4xenablemsix,
+		 " Set to enable MSI or MSI-X interrupt mechanism.\n"
+		 "\t\t 0 = enable INTx interrupt mechanism.\n"
+		 "\t\t 1 = enable MSI-X interrupt mechanism.\n"
+		 "\t\t 2 = enable MSI interrupt mechanism.");
 
-int ql4_mod_unload = 0;
 /*
  * SCSI host template entry points
  */
@@ -72,6 +80,9 @@ void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha);
 static int qla4xxx_tgt_dscvr(struct Scsi_Host *shost,
 			     enum iscsi_tgt_dscvr type,
 			     uint32_t enable, struct sockaddr *dst_addr);
+
+static int qla4xxx_host_get_param(struct Scsi_Host *,
+			enum iscsi_host_param, char *);
 static int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,
 				  enum iscsi_param param, char *buf);
 static int qla4xxx_sess_get_param(struct iscsi_cls_session *sess,
@@ -87,12 +98,13 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd);
 static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);
 static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd);
 static int qla4xxx_slave_alloc(struct scsi_device *device);
+static void qla4xxx_slave_destroy(struct scsi_device *sdev);
 static int qla4xxx_slave_configure(struct scsi_device *device);
 
 static struct scsi_host_template qla4xxx_driver_template = {
-	.module			= THIS_MODULE,
-	.name			= DRIVER_NAME,
-	.proc_name		= DRIVER_NAME,
+	.module				= THIS_MODULE,
+	.name				= DRIVER_NAME,
+	.proc_name			= DRIVER_NAME,
 	.queuecommand		= qla4xxx_queuecommand,
 
 	.eh_abort_handler	= qla4xxx_eh_abort,
@@ -101,6 +113,7 @@ static struct scsi_host_template qla4xxx_driver_template = {
 
 	.slave_configure	= qla4xxx_slave_configure,
 	.slave_alloc		= qla4xxx_slave_alloc,
+	.slave_destroy		= qla4xxx_slave_destroy,
 
 	.this_id		= -1,
 	.cmd_per_lun		= 3,
@@ -111,14 +124,19 @@ static struct scsi_host_template qla4xxx_driver_template = {
 };
 
 static struct iscsi_transport qla4xxx_iscsi_transport = {
-	.owner			= THIS_MODULE,
-	.name			= DRIVER_NAME,
-	.param_mask		= ISCSI_CONN_PORT |
-				  ISCSI_CONN_ADDRESS |
-				  ISCSI_TARGET_NAME |
-				  ISCSI_TPGT,
-
+	.owner				= THIS_MODULE,
+	.name				= DRIVER_NAME,
+	.caps				= CAP_FW_DB | CAP_SENDTARGETS_OFFLOAD |
+						CAP_DATA_PATH_OFFLOAD,
+	.param_mask			= ISCSI_CONN_PORT |
+						ISCSI_CONN_ADDRESS |
+						ISCSI_TARGET_NAME |
+						ISCSI_TPGT,
+	.host_param_mask	= ISCSI_HOST_HWADDRESS |
+						ISCSI_HOST_IPADDRESS |
+						ISCSI_HOST_INITIATOR_NAME,
 	.tgt_dscvr		= qla4xxx_tgt_dscvr,
+	.get_host_param		= qla4xxx_host_get_param,
 	.get_conn_param		= qla4xxx_conn_get_param,
 	.get_session_param	= qla4xxx_sess_get_param,
 	.session_recovery_timedout = qla4xxx_recovery_timedout,
@@ -140,7 +158,7 @@ static void qla4xxx_recovery_timedout(struct iscsi_cls_session *session)
 
 	DEBUG2(printk("scsi%ld: %s: scheduling dpc routine - dpc flags = "
 		      "0x%lx\n", ha->host_no, __func__, ha->dpc_flags));
-	queue_work(ha->dpc_thread, &ha->dpc_work);
+	qla4xxx_wake_dpc(ha);
 }
 
 int qla4xxx_conn_start(struct iscsi_cls_conn *conn)
@@ -151,9 +169,9 @@ int qla4xxx_conn_start(struct iscsi_cls_conn *conn)
 	session = iscsi_dev_to_session(conn->dev.parent);
 	ddb_entry = session->dd_data;
 
-	DEBUG2(printk("scsi%ld: %s: index [%d] starting conn\n",
-		      ddb_entry->ha->host_no, __func__,
-		      ddb_entry->fw_ddb_index));
+	DEBUG2(printk("scsi%ld: %s: ddb [%d] starting conn\n",
+			ddb_entry->ha->host_no, __func__,
+			ddb_entry->fw_ddb_index));
 	iscsi2_unblock_session(session);
 	return 0;
 }
@@ -164,11 +182,17 @@ static void qla4xxx_conn_stop(struct iscsi_cls_conn *conn, int flag)
 	struct ddb_entry *ddb_entry;
 
 	session = iscsi_dev_to_session(conn->dev.parent);
+
+	if (session == NULL) {
+		printk("session is  NULL \n");
+		return;
+	}
+
 	ddb_entry = session->dd_data;
 
-	DEBUG2(printk("scsi%ld: %s: index [%d] stopping conn\n",
-		      ddb_entry->ha->host_no, __func__,
-		      ddb_entry->fw_ddb_index));
+	DEBUG2(printk("scsi%ld: %s: ddb [%d] stopping conn\n",
+			ddb_entry->ha->host_no, __func__,
+			ddb_entry->fw_ddb_index));
 	if (flag == STOP_CONN_RECOVER)
 		iscsi2_block_session(session);
 	else
@@ -184,7 +208,7 @@ static int qla4xxx_sess_get_param(struct iscsi_cls_session *sess,
 	switch (param) {
 	case ISCSI_PARAM_TARGET_NAME:
 		len = snprintf(buf, PAGE_SIZE - 1, "%s\n",
-			       ddb_entry->iscsi_name);
+				ddb_entry->iscsi_name);
 		break;
 	case ISCSI_PARAM_TPGT:
 		len = sprintf(buf, "%u\n", ddb_entry->tpgt);
@@ -196,6 +220,42 @@ static int qla4xxx_sess_get_param(struct iscsi_cls_session *sess,
 	return len;
 }
 
+static ssize_t format_addr(char *buf, const unsigned char *addr, int len)
+{
+	int i;
+	char *cp = buf;
+
+	for (i = 0; i < len; i++)
+		cp += sprintf(cp, "%02x%c", addr[i],
+			i == (len - 1) ? '\n' : ':');
+	return cp - buf;
+}
+
+static int qla4xxx_host_get_param(struct Scsi_Host *shost,
+			enum iscsi_host_param param, char *buf)
+{
+	struct scsi_qla_host *ha = to_qla_host(shost);
+	int len;
+
+	switch (param) {
+	case ISCSI_HOST_PARAM_HWADDRESS:
+		len = format_addr(buf, ha->my_mac, MAC_ADDR_LEN);
+		break;
+	case ISCSI_HOST_PARAM_IPADDRESS:
+		len = sprintf(buf, "%d.%d.%d.%d", ha->ip_address[0],
+				ha->ip_address[1], ha->ip_address[2],
+				ha->ip_address[3]);
+		break;
+	case ISCSI_HOST_PARAM_INITIATOR_NAME:
+		len = sprintf(buf, "%s", ha->name_string);
+		break;
+	default:
+		return -ENOSYS;
+	}
+
+	return len;
+}
+
 static int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,
 				  enum iscsi_param param, char *buf)
 {
@@ -211,9 +271,8 @@ static int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,
 		len = sprintf(buf, "%hu\n", ddb_entry->port);
 		break;
 	case ISCSI_PARAM_CONN_ADDRESS:
-		/* TODO: what are the ipv6 bits */
-		len = sprintf(buf, "%u.%u.%u.%u\n",
-			      NIPQUAD(ddb_entry->ip_addr));
+		len = sprintf(buf, "%pI4\n",
+			      ddb_entry->ip_addr);
 		break;
 	default:
 		return -ENOSYS;
@@ -267,6 +326,7 @@ void qla4xxx_destroy_sess(struct ddb_entry *ddb_entry)
 		iscsi2_destroy_conn(ddb_entry->conn);
 		iscsi2_remove_session(ddb_entry->sess);
 	}
+
 	iscsi2_free_session(ddb_entry->sess);
 }
 
@@ -281,6 +341,7 @@ int qla4xxx_add_sess(struct ddb_entry *ddb_entry, int scan)
 	}
 
 	ddb_entry->conn = iscsi2_create_conn(ddb_entry->sess, 0, 0);
+
 	if (!ddb_entry->conn) {
 		iscsi2_remove_session(ddb_entry->sess);
 		DEBUG2(printk(KERN_ERR "Could not add connection.\n"));
@@ -321,7 +382,7 @@ static void qla4xxx_start_timer(struct scsi_qla_host *ha, void *func,
 				unsigned long interval)
 {
 	DEBUG(printk("scsi: %s: Starting timer thread for adapter %d\n",
-		     __func__, ha->host->host_no));
+			__func__, ha->host->host_no));
 	init_timer(&ha->timer);
 	ha->timer.expires = jiffies + interval * HZ;
 	ha->timer.data = (unsigned long)ha;
@@ -341,17 +402,36 @@ static void qla4xxx_stop_timer(struct scsi_qla_host *ha)
  * @ha: Pointer to host adapter structure.
  * @ddb_entry: Pointer to device database entry
  *
- * This routine marks a device missing and resets the relogin retry count.
+ * This routine marks a device missing and closes the connection
  **/
 void qla4xxx_mark_device_missing(struct scsi_qla_host *ha,
 				 struct ddb_entry *ddb_entry)
 {
-	atomic_set(&ddb_entry->state, DDB_STATE_MISSING);
-	DEBUG3(printk("scsi%d:%d:%d: index [%d] marked MISSING\n",
-		      ha->host_no, ddb_entry->bus, ddb_entry->target,
-		      ddb_entry->fw_ddb_index));
+	if ((atomic_read(&ddb_entry->state) == DDB_STATE_DEAD))
+		dev_info(&ha->pdev->dev, "%s: ddb[%d] os[%d] DEAD\n",
+			__func__, ddb_entry->fw_ddb_index, ddb_entry->os_target_id);
+	else {
+		atomic_set(&ddb_entry->state, DDB_STATE_MISSING);
+		dev_info(&ha->pdev->dev, "%s: ddb[%d] os[%d] marked MISSING\n",
+			__func__, ddb_entry->fw_ddb_index, ddb_entry->os_target_id);
+	}
+
+	if (ddb_entry->conn)
+		qla4xxx_conn_stop(ddb_entry->conn, STOP_CONN_RECOVER);
+}
 
-	qla4xxx_conn_stop(ddb_entry->conn, STOP_CONN_RECOVER);
+/**
+ * qla4xxx_mark_all_devices_missing - mark all devices as missing.
+ * @ha: Pointer to host adapter structure.
+ *
+ * This routine marks a device missing and resets the relogin retry count.
+ **/
+void qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha)
+{
+	struct ddb_entry *ddb_entry, *ddbtemp;
+	list_for_each_entry_safe(ddb_entry, ddbtemp, &ha->ddb_list, list) {
+		qla4xxx_mark_device_missing(ha, ddb_entry);
+	}
 }
 
 /***
@@ -375,7 +455,7 @@ static struct srb* qla4xxx_get_new_srb(struct scsi_qla_host *ha,
 	if (!srb)
 		return srb;
 
-	atomic_set(&srb->ref_count, 1);
+	kref_init(&srb->srb_ref);
 	srb->ha = ha;
 	srb->ddb = ddb_entry;
 	srb->cmd = cmd;
@@ -404,9 +484,11 @@ static void qla4xxx_srb_free_dma(struct scsi_qla_host *ha, struct srb *srb)
 	cmd->SCp.ptr = NULL;
 }
 
-void qla4xxx_srb_compl(struct scsi_qla_host *ha, struct srb *srb)
+void qla4xxx_srb_compl(struct kref *ref)
 {
+	struct srb *srb = container_of(ref, struct srb, srb_ref);
 	struct scsi_cmnd *cmd = srb->cmd;
+	struct scsi_qla_host *ha = srb->ha;
 
 	if (!(srb->flags & SRB_SCSI_PASSTHRU)) {
 		qla4xxx_srb_free_dma(ha, srb);
@@ -416,45 +498,17 @@ void qla4xxx_srb_compl(struct scsi_qla_host *ha, struct srb *srb)
 }
 
 /**
- * sp_put - Decrement reference count and call callback.
- * @ha: Pointer to host adapter structure.
- * @sp: Pointer to srb structure
- **/
-void sp_put(struct scsi_qla_host *ha, struct srb *sp)
-{
-	if (atomic_read(&sp->ref_count) == 0) {
-		DEBUG2(printk(KERN_INFO
-			"%s: SP->ref_count ZERO\n", __func__));
-		DEBUG2(BUG());
-		return;
-	}
-	if (!atomic_dec_and_test(&sp->ref_count))
-		return;
-
-	qla4xxx_srb_compl(ha, sp);
-}
-
-/**
- * sp_get - Increment reference count of the specified sp.
- * @sp: Pointer to srb structure
- **/
-void sp_get(struct srb *sp)
-{
-       atomic_inc(&sp->ref_count);
-}
-
-/**
  * qla4xxx_queuecommand - scsi layer issues scsi command to driver.
  * @cmd: Pointer to Linux's SCSI command structure
  * @done_fn: Function that the driver calls to notify the SCSI mid-layer
- *	that the command has been processed.
+ * that the command has been processed.
  *
  * Remarks:
  * This routine is invoked by Linux to send a SCSI command to the driver.
  * The mid-level driver tries to ensure that queuecommand never gets
  * invoked concurrently with itself or the interrupt handler (although
  * the interrupt handler may call this routine as part of request-
- * completion handling).   Unfortunely, it sometimes calls the scheduler
+ * completion handling).  Unfortunely, it sometimes calls the scheduler
  * in interrupt context which is a big NO! NO!.
  **/
 static int qla4xxx_queuecommand(struct scsi_cmnd *cmd,
@@ -473,7 +527,14 @@ static int qla4xxx_queuecommand(struct scsi_cmnd *cmd,
 		goto qc_host_busy;
 	}
 
-	if (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags))
+	if (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
+	    test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||
+	    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+		test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||
+	    test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||
+		test_bit(AF_HBA_GOING_AWAY, &ha->flags) ||
+		!test_bit(AF_ONLINE, &ha->flags) ||
+	    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))
 		goto qc_host_busy;
 
 	spin_unlock_irq(ha->host->host_lock);
@@ -548,7 +609,13 @@ static void qla4xxx_mem_free(struct scsi_qla_host *ha)
 	ha->srb_mempool = NULL;
 
 	/* release io space registers  */
-	if (ha->reg)
+	if (is_qla8022(ha)) {
+		if (ha->nx_pcibase)
+			iounmap((struct device_reg_82xx __iomem *)ha->nx_pcibase);
+
+		if (ha->nx_db_wr_ptr)
+			iounmap((struct device_reg_82xx __iomem *)ha->nx_db_wr_ptr);
+	} else if (ha->reg)
 		iounmap(ha->reg);
 	pci_release_regions(ha->pdev);
 }
@@ -556,7 +623,7 @@ static void qla4xxx_mem_free(struct scsi_qla_host *ha)
 /**
  * qla4xxx_mem_alloc - allocates memory for use by adapter.
  * @ha: Pointer to host adapter structure
- * 
+ *
  * Allocates DMA memory for request and response queues. Also allocates memory
  * for srbs.
  **/
@@ -595,8 +662,8 @@ static int qla4xxx_mem_alloc(struct scsi_qla_host *ha)
 	ha->response_dma = ha->queues_dma + align +
 		(REQUEST_QUEUE_DEPTH * QUEUE_SIZE);
 	ha->response_ring = (struct queue_entry *) (ha->queues + align +
-						    (REQUEST_QUEUE_DEPTH *
-						     QUEUE_SIZE));
+							(REQUEST_QUEUE_DEPTH *
+							QUEUE_SIZE));
 	ha->shadow_regs_dma = ha->queues_dma + align +
 		(REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +
 		(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);
@@ -633,6 +700,70 @@ mem_alloc_error_exit:
 }
 
 /**
+ * qla82xx_check_fw_alive - Check firmware health
+ * @ha: Pointer to host adapter structure.
+ *
+ * Context: Interrupt
+ **/
+static void
+qla82xx_check_fw_alive(struct scsi_qla_host *ha)
+{
+	uint32_t fw_heartbeat_counter, halt_status;
+
+	fw_heartbeat_counter = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);
+	if (ha->fw_heartbeat_counter == fw_heartbeat_counter) {
+		ha->seconds_since_last_heartbeat++;
+
+		/* FW not alive after 2 seconds */
+		if (ha->seconds_since_last_heartbeat == 2) {
+			ha->seconds_since_last_heartbeat = 0;
+			halt_status = qla82xx_rd_32(ha, QLA82XX_PEG_HALT_STATUS1);
+			/* Since we cannot change dev_state in interrupt
+			 * context, set appropriate DPC flag then wakeup
+			 * DPC */
+			if (halt_status & HALT_STATUS_UNRECOVERABLE)
+				set_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);
+			else
+				set_bit(DPC_RESET_HA, &ha->dpc_flags);
+
+			qla4xxx_wake_dpc(ha);
+		}
+	}
+
+	ha->fw_heartbeat_counter = fw_heartbeat_counter;
+}
+
+/**
+ * qla82xx_watchdog - Poll dev state
+ * @ha: Pointer to host adapter structure.
+ *
+ * Context: Interrupt
+ **/
+void qla82xx_watchdog(struct scsi_qla_host *ha)
+{
+	uint32_t dev_state;
+
+	dev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
+
+	/* don't poll if reset is going on */
+	if (!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags)) {
+		if (dev_state == QLA82XX_DEV_NEED_RESET) {
+			printk("scsi%ld: %s: detect HA Reset needed!\n",
+				ha->host_no, __func__);
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			qla4xxx_wake_dpc(ha);
+		} else if (dev_state == QLA82XX_DEV_NEED_QUIESCENT) {
+			printk("HW State: NEED QUIESCENT detected\n");
+			set_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags);
+			qla4xxx_wake_dpc(ha);
+		} else {
+			/* Check firmware health */
+			qla82xx_check_fw_alive(ha);
+		}
+	}
+}
+
+/**
  * qla4xxx_timer - checks every second for work to do.
  * @ha: Pointer to host adapter structure.
  **/
@@ -641,8 +772,18 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 	struct ddb_entry *ddb_entry, *dtemp;
 	int start_dpc = 0;
 
+	if (test_bit(AF_HBA_GOING_AWAY, &ha->flags)) {
+		DEBUG2(printk("%s exited. HBA GOING AWAY\n", __func__));
+		return;
+	}
+
+	if (is_qla8022(ha)) {
+		qla82xx_watchdog(ha);
+	}
+
 	/* Search for relogin's to time-out and port down retry. */
 	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {
+
 		/* Count down time between sending relogins */
 		if (adapter_up(ha) &&
 		    !test_bit(DF_RELOGIN, &ddb_entry->flags) &&
@@ -657,10 +798,10 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 					set_bit(DPC_RELOGIN_DEVICE,
 						&ha->dpc_flags);
 					set_bit(DF_RELOGIN, &ddb_entry->flags);
-					DEBUG2(printk("scsi%ld: %s: index [%d]"
-						" login device\n",
-						ha->host_no, __func__,
-						ddb_entry->fw_ddb_index));
+					DEBUG2(printk("scsi%ld: %s: ddb [%d]"
+						      " login device\n",
+						      ha->host_no, __func__,
+						      ddb_entry->fw_ddb_index));
 				} else
 					atomic_dec(&ddb_entry->
 							retry_relogin_timer);
@@ -674,28 +815,20 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 			 * If the relogin times out and the device is
 			 * still NOT ONLINE then try and relogin again.
 			 */
-			if (atomic_read(&ddb_entry->state) !=
-			    DDB_STATE_ONLINE &&
-			    ddb_entry->fw_ddb_device_state ==
-			    DDB_DS_SESSION_FAILED) {
+			if (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE &&
+			    ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_FAILED) {
 				/* Reset retry relogin timer */
 				atomic_inc(&ddb_entry->relogin_retry_count);
-				DEBUG2(printk("scsi%ld: index[%d] relogin"
-					      " timed out-retrying"
+				DEBUG2(printk("scsi%ld: index[%d] relogin timed out-retrying"
 					      " relogin (%d)\n",
-					      ha->host_no,
-					      ddb_entry->fw_ddb_index,
-					      atomic_read(&ddb_entry->
-							  relogin_retry_count))
+					      ha->host_no, ddb_entry->fw_ddb_index,
+					      atomic_read(&ddb_entry->relogin_retry_count))
 					);
 				start_dpc++;
-				DEBUG(printk("scsi%ld:%d:%d: index [%d] "
-					     "initate relogin after"
+				DEBUG(printk("scsi%ld:%d:%d: index [%d] initate relogin after"
 					     " %d seconds\n",
-					     ha->host_no, ddb_entry->bus,
-					     ddb_entry->target,
-					     ddb_entry->fw_ddb_index,
-					     ddb_entry->default_time2wait + 4)
+					     ha->host_no, ddb_entry->bus, ddb_entry->target,
+					     ddb_entry->fw_ddb_index, ddb_entry->default_time2wait + 4)
 					);
 
 				atomic_set(&ddb_entry->retry_relogin_timer,
@@ -705,31 +838,36 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 	}
 
 	/* Check for heartbeat interval. */
-	if (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&
-	    ha->heartbeat_interval != 0) {
-		ha->seconds_since_last_heartbeat++;
-		if (ha->seconds_since_last_heartbeat >
-		    ha->heartbeat_interval + 2)
-			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+	if (!is_qla8022(ha)) {
+		if (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&
+		    ha->heartbeat_interval != 0) {
+			ha->seconds_since_last_heartbeat++;
+			if (ha->seconds_since_last_heartbeat >
+			    ha->heartbeat_interval + 2)
+				set_bit(DPC_RESET_HA, &ha->dpc_flags);
+		}
 	}
 
-
 	/* Wakeup the dpc routine for this adapter, if needed. */
 	if ((start_dpc ||
 	     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
 	     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||
 	     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||
-	     test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags) ||
+	     test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||
 	     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
 	     test_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||
+		 test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||
+	     test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||
+		 test_bit(DPC_DYNAMIC_LUN_SCAN, &ha->dpc_flags) ||
 	     test_bit(DPC_AEN, &ha->dpc_flags) ||
-	     test_bit(DPC_LINK_CHANGED, &ha->dpc_flags) ||
+		 test_bit(DPC_LINK_CHANGED, &ha->dpc_flags) ||
 	     test_bit(DPC_ASYNC_MSG_PDU, &ha->dpc_flags)) &&
-	     ha->dpc_thread) {
+	    !test_bit(AF_DPC_SCHEDULED, &ha->flags) &&
+		ha->dpc_thread) {
 		DEBUG2(printk("scsi%ld: %s: scheduling dpc routine"
 			      " - dpc flags = 0x%lx\n",
 			      ha->host_no, __func__, ha->dpc_flags));
-		queue_work(ha->dpc_thread, &ha->dpc_work);
+		qla4xxx_wake_dpc(ha);
 	}
 
 	/* Reschedule timer thread to call us back in one second */
@@ -748,15 +886,12 @@ static void qla4xxx_timer(struct scsi_qla_host *ha)
 static int qla4xxx_cmd_wait(struct scsi_qla_host *ha)
 {
 	uint32_t index = 0;
-	int stat = QLA_SUCCESS;
 	unsigned long flags;
-	int wait_cnt = WAIT_CMD_TOV;	/*
-					 * Initialized for 30 seconds as we
-					 * expect all commands to retuned
-					 * ASAP.
-					 */
+	unsigned long wtime = jiffies + (WAIT_CMD_TOV * HZ);
+
+	DEBUG2(printk(KERN_INFO "Wait up to %d seconds for cmds to complete\n", WAIT_CMD_TOV));
 
-	while (wait_cnt) {
+	while (!time_after_eq(jiffies, wtime)) {
 		spin_lock_irqsave(&ha->hardware_lock, flags);
 		/* Find a command that hasn't completed. */
 		for (index = 1; index < MAX_SRBS; index++) {
@@ -766,31 +901,29 @@ static int qla4xxx_cmd_wait(struct scsi_qla_host *ha)
 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 		/* If No Commands are pending, wait is complete */
-		if (index == MAX_SRBS) {
-			break;
-		}
+		if (index == MAX_SRBS)
+			return QLA_SUCCESS;
 
-		/* If we timed out on waiting for commands to come back
-		 * return ERROR.
-		 */
-		wait_cnt--;
-		if (wait_cnt == 0)
-			stat = QLA_ERROR;
-		else {
-			msleep(1000);
-		}
-	}			/* End of While (wait_cnt) */
+		msleep(1000);
 
-	return stat;
+	} /* End of While (wait_cnt) */
+
+	/* If we timed out on waiting for commands to come back
+	 * return ERROR. */
+
+	return QLA_ERROR;
 }
 
-void qla4xxx_hw_reset(struct scsi_qla_host *ha)
+int qla4xxx_hw_reset(struct scsi_qla_host *ha)
 {
 	uint32_t ctrl_status;
 	unsigned long flags = 0;
 
 	DEBUG2(printk(KERN_ERR "scsi%ld: %s\n", ha->host_no, __func__));
 
+	if (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)
+		return QLA_ERROR;
+
 	spin_lock_irqsave(&ha->hardware_lock, flags);
 	/*
 	 * If the SCSI Reset Interrupt bit is set, clear it.
@@ -805,6 +938,7 @@ void qla4xxx_hw_reset(struct scsi_qla_host *ha)
 	readl(&ha->reg->ctrl_status);
 
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return QLA_SUCCESS;
 }
 
 /**
@@ -818,7 +952,8 @@ int qla4xxx_soft_reset(struct scsi_qla_host *ha)
 	int status = QLA_ERROR;
 	uint32_t ctrl_status;
 
-	qla4xxx_hw_reset(ha);
+	if (qla4xxx_hw_reset(ha) != QLA_SUCCESS)
+		return QLA_ERROR;
 
 	/* Wait until the Network Reset Intr bit is cleared */
 	max_wait_time = RESET_INTR_TOV;
@@ -903,15 +1038,16 @@ int qla4xxx_soft_reset(struct scsi_qla_host *ha)
 }
 
 /**
- * qla4xxx_flush_active_srbs - returns all outstanding i/o requests to O.S.
+ * qla4xxx_abort_active_cmds - returns all outstanding i/o requests to O.S.
  * @ha: Pointer to host adapter structure.
+ * @res: Command Return Code.
  *
  * This routine is called just prior to a HARD RESET to return all
  * outstanding commands back to the Operating System.
  * Caller should make sure that the following locks are released
  * before this calling routine: Hardware lock, and io_request_lock.
  **/
-static void qla4xxx_flush_active_srbs(struct scsi_qla_host *ha)
+void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res)
 {
 	struct srb *srb;
 	int i;
@@ -921,8 +1057,8 @@ static void qla4xxx_flush_active_srbs(struct scsi_qla_host *ha)
 	for (i = 1; i < MAX_SRBS; i++) {
 		if ((srb = ha->active_srb_array[i]) != NULL) {
 			qla4xxx_del_from_active_array(ha, i);
-			srb->cmd->result = DID_RESET << 16;
-			sp_put(ha, srb);
+			srb->cmd->result = res;
+			kref_put(&srb->srb_ref, qla4xxx_srb_compl);
 		}
 	}
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
@@ -930,79 +1066,135 @@ static void qla4xxx_flush_active_srbs(struct scsi_qla_host *ha)
 }
 
 /**
+ *  qla4xxx_dead_adapter_cleanup - Cleanup perermanently disable HA
+ *  @ha: pointer to adapter structure
+ **/
+void
+qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha)
+{
+	/* Disable the board */
+	DEBUG2(printk(KERN_INFO"Disabling the board\n"));
+
+	set_bit(AF_HBA_GOING_AWAY, &ha->flags);
+
+	qla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);
+	qla4xxx_mark_all_devices_missing(ha);
+
+	clear_bit(AF_ONLINE, &ha->flags);
+	clear_bit(AF_INIT_DONE, &ha->flags);
+}
+
+/**
  * qla4xxx_recover_adapter - recovers adapter after a fatal error
  * @ha: Pointer to host adapter structure.
  * @renew_ddb_list: Indicates what to do with the adapter's ddb list
  *	after adapter recovery has completed.
  *	0=preserve ddb list, 1=destroy and rebuild ddb list
  **/
-static int qla4xxx_recover_adapter(struct scsi_qla_host *ha, 
+static int qla4xxx_recover_adapter(struct scsi_qla_host *ha,
 				uint8_t renew_ddb_list)
 {
-	int status;
+	int status = QLA_ERROR;
+	uint8_t reset_chip = 0;
 
 	/* Stall incoming I/O until we are done */
+	DEBUG2(printk("scsi%ld: recover adapter .. BEGIN\n", ha->host_no));
+	dev_info(&ha->pdev->dev, "%s: adapter OFFLINE\n", __func__);
 	clear_bit(AF_ONLINE, &ha->flags);
+	scsi_block_requests(ha->host);
+
 	DEBUG2(printk("scsi%ld: %s calling qla4xxx_cmd_wait\n", ha->host_no,
 		      __func__));
 
-	/* Wait for outstanding commands to complete.
-	 * Stalls the driver for max 30 secs
-	 */
-	status = qla4xxx_cmd_wait(ha);
+	set_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
 
-	qla4xxx_disable_intrs(ha);
+	if (test_bit(DPC_RESET_HA, &ha->dpc_flags))
+		reset_chip = 1;
 
-	/* Flush any pending ddb changed AENs */
-	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+	/* For the DPC_RESET_HA_INTR case (ISP-4xxx specific)
+	 * do not reset adapter, jump to initialize_adapter */
+	if (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {
+		status = QLA_SUCCESS;
+		goto recover_ha_init_adapter;
+	}
 
-	qla4xxx_flush_active_srbs(ha);
+	/* For the ISP-802x adapter, issue a stop_firmware if invoked
+	 * from eh_host_reset or ioctl module */
+	if (is_qla8022(ha) && !reset_chip &&
+		test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {
+			DEBUG2(dev_info(&ha->pdev->dev,
+				"scsi%ld: %s - Performing stop_firmware...\n",
+				ha->host_no, __func__));
+			status = ha->isp_ops->reset_firmware(ha);
+			if (status == QLA_SUCCESS) {
+				(void) qla4xxx_cmd_wait(ha);
+				ha->isp_ops->disable_intrs(ha);
+				qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+				qla4xxx_abort_active_cmds(ha, DID_RESET << 16);
+			} else {
+				/* If the stop_firmware fails then
+				 * reset the entire chip */
+				reset_chip = 1;
+				clear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);
+				set_bit(DPC_RESET_HA, &ha->dpc_flags);
+			}
+	}
 
-	/* Reset the firmware.	If successful, function
-	 * returns with ISP interrupts enabled.
-	 */
-	DEBUG2(printk(KERN_ERR "scsi%ld: %s - Performing soft reset..\n",
-		      ha->host_no, __func__));
-	if (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS)
-		status = qla4xxx_soft_reset(ha);
-	else
-		status = QLA_ERROR;
+	/* Issue full chip reset if recovering from a catastrophic error,
+	 * or if stop_firmware fails for ISP-802x.
+	 * This is the default case for ISP-4xxx */
+	if (!is_qla8022(ha) || reset_chip) {
+		(void) qla4xxx_cmd_wait(ha);
+		qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+		qla4xxx_abort_active_cmds(ha, DID_RESET << 16);
+		DEBUG2(dev_info(&ha->pdev->dev,
+			"scsi%ld: %s - Performing chip reset..\n",
+			ha->host_no, __func__));
+		status = ha->isp_ops->reset_chip(ha);
+	}
 
 	/* Flush any pending ddb changed AENs */
 	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
 
-	/* Re-initialize firmware. If successful, function returns
-	 * with ISP interrupts enabled */
+recover_ha_init_adapter:
+	/* Upon successful firmware/chip reset, re-initialize the adapter */
 	if (status == QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s - Initializing adapter..\n",
-			      ha->host_no, __func__));
+			ha->host_no, __func__));
 
-		/* If successful, AF_ONLINE flag set in
-		 * qla4xxx_initialize_adapter */
-		status = qla4xxx_initialize_adapter(ha, renew_ddb_list);
+		/* For ISP-4xxx, force function 1 to always initialize
+		 * before function 3 to prevent both funcions from
+		 * stepping on top of the other */
+		if (!is_qla8022(ha) && (ha->mac_index == 3))
+			ssleep(6);
+
+		/* NOTE: AF_ONLINE flag set upon successful completion of
+		 * 		qla4xxx_initialize_adapter */
+		(void) qla4xxx_initialize_adapter(ha, PRESERVE_DDB_LIST);
 	}
 
-	/* Failed adapter initialization?
-	 * Retry reset_ha only if invoked via DPC (DPC_RESET_HA) */
-	if ((test_bit(AF_ONLINE, &ha->flags) == 0) &&
-	    (test_bit(DPC_RESET_HA, &ha->dpc_flags))) {
+	/* Retry failed adapter initialization, if necessary
+	 * Do not retry initialize_adapter for RESET_HA_INTR (ISP-4xxx specific)
+	 * case to prevent ping-pong resets between functions */
+	if (!test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) &&
+		!test_bit(AF_ONLINE, &ha->flags)) {
 		/* Adapter initialization failed, see if we can retry
-		 * resetting the ha */
+		 * resetting the ha.
+		 * Since we don't want to block the DPC for too long
+		 * with multiple resets in the same thread,
+		 * utilize DPC to retry */
 		if (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {
 			ha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;
 			DEBUG2(printk("scsi%ld: recover adapter - retrying "
-				      "(%d) more times\n", ha->host_no,
-				      ha->retry_reset_ha_cnt));
+				"(%d) more times\n", ha->host_no, ha->retry_reset_ha_cnt));
 			set_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
 			status = QLA_ERROR;
 		} else {
 			if (ha->retry_reset_ha_cnt > 0) {
 				/* Schedule another Reset HA--DPC will retry */
 				ha->retry_reset_ha_cnt--;
-				DEBUG2(printk("scsi%ld: recover adapter - "
-					      "retry remaining %d\n",
-					      ha->host_no,
-					      ha->retry_reset_ha_cnt));
+				DEBUG2(printk("scsi%ld: recover adapter - retry remaining %d\n",
+					ha->host_no, ha->retry_reset_ha_cnt));
 				status = QLA_ERROR;
 			}
 
@@ -1010,31 +1202,46 @@ static int qla4xxx_recover_adapter(struct scsi_qla_host *ha,
 				/* Recover adapter retries have been exhausted.
 				 * Adapter DEAD */
 				DEBUG2(printk("scsi%ld: recover adapter "
-					      "failed - board disabled\n",
-					      ha->host_no));
-				qla4xxx_flush_active_srbs(ha);
+					"failed - board disabled\n",
+					ha->host_no));
+				qla4xxx_dead_adapter_cleanup(ha);
 				clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
 				clear_bit(DPC_RESET_HA, &ha->dpc_flags);
-				clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST,
-					  &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);
 				status = QLA_ERROR;
 			}
 		}
 	} else {
 		clear_bit(DPC_RESET_HA, &ha->dpc_flags);
-		clear_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+		clear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);
 		clear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);
 	}
 
 	ha->adapter_error_count++;
 
-	if (status == QLA_SUCCESS)
-		qla4xxx_enable_intrs(ha);
+	if (test_bit(AF_ONLINE, &ha->flags)) {
+		ha->isp_ops->enable_intrs(ha);
+		DEBUG2(printk("%s: scsi_unblock_requests\n", __func__));
+		scsi_unblock_requests(ha->host);
+		status = QLA_SUCCESS;
+	}
+
+	clear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
+	DEBUG2(printk("scsi%ld: recover adapter .. DONE (status=%d)\n",
+		ha->host_no, status));
 
-	DEBUG2(printk("scsi%ld: recover adapter .. DONE\n", ha->host_no));
 	return status;
 }
 
+void qla4xxx_wake_dpc(struct scsi_qla_host *ha)
+{
+	if (ha->dpc_thread &&
+	    !test_bit(AF_DPC_SCHEDULED, &ha->flags)) {
+		set_bit(AF_DPC_SCHEDULED, &ha->flags);
+		queue_work(ha->dpc_thread, &ha->dpc_work);
+	}
+}
+
 /*
  * qla4xxx_async_iocbs - processes ASYNC PDU IOCBS, if they are greater in
  * length than 48 bytes (i.e., more than just the iscsi header). Used for
@@ -1118,22 +1325,17 @@ static void qla4xxx_async_iocbs(struct scsi_qla_host *ha,
 				/* reported luns data has changed */
 				uint16_t fw_index = apdu->target_id;
 
-				ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha,
-						fw_index);
+				ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_index);
 				if (ddb_entry == NULL) {
 					dev_info(&ha->pdev->dev,
-						"%s: No DDB entry for index"
-						"  [%d]\n"
+						 "%s: No DDB entry for index [%d]\n"
 						 , __func__, fw_index);
 					goto exit_async_pdu_iocb;
 				}
-				if (ddb_entry->fw_ddb_device_state !=
-					DDB_DS_SESSION_ACTIVE) {
+				if (ddb_entry->fw_ddb_device_state != DDB_DS_SESSION_ACTIVE) {
 					dev_info(&ha->pdev->dev,
-						"scsi%ld: %s: No Active"
-						" Session for index [%d]\n",
-						ha->host_no,
-						__func__, fw_index);
+						 "scsi%ld: %s: No Active Session for index [%d]\n",
+						 ha->host_no, __func__, fw_index);
 					goto exit_async_pdu_iocb;
 				}
 
@@ -1169,8 +1371,6 @@ exit_async_pdu_iocb:
 	return;
 }
 
-
-
 /**
  * qla4xxx_do_dpc - dpc routine
  * @data: in our case pointer to adapter structure
@@ -1190,23 +1390,50 @@ static void qla4xxx_do_dpc(void *data)
 	int status = QLA_ERROR;
 
 	DEBUG2(printk("scsi%ld: %s: DPC handler waking up."
-		"ha->flags=0x%08lx ha->dpc_flags=0x%08lx"
-		" ctrl_status=0x%08x\n",
-		ha->host_no, __func__, ha->flags, ha->dpc_flags,
-		readw(&ha->reg->ctrl_status)));
+		"ha->flags=0x%08lx ha->dpc_flags=0x%08lx\n",
+		ha->host_no, __func__, ha->flags, ha->dpc_flags));
 
 	/* Initialization not yet finished. Don't do anything yet. */
 	if (!test_bit(AF_INIT_DONE, &ha->flags))
 		return;
 
-	if (adapter_up(ha) ||
-	    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
+	/* HBA is in the process of being permanently disabled.
+	 * Don't process anything */
+	if (test_bit(AF_HBA_GOING_AWAY, &ha->flags))
+		return;
+
+	if (is_qla8022(ha)) {
+		if (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {
+			qla82xx_idc_lock(ha);
+			qla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
+				QLA82XX_DEV_FAILED);
+			qla82xx_idc_unlock(ha);
+			DEBUG2(printk(KERN_INFO"HW State: FAILED\n"));
+			qla82xx_device_state_handler(ha);
+		}
+		if (test_and_clear_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {
+			qla82xx_need_qsnt_handler(ha);
+		}
+	}
+
+	if ((!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags)) &&
+	    (test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
 	    test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||
-	    test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags)) {
-		if (test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags) ||
-		    test_bit(DPC_RESET_HA, &ha->dpc_flags))
-			qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
+	    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))) {
+		if (ql4xdontresethba) {
+				DEBUG2(printk("%s: Don't Reset HBA\n",
+						__func__));
+				clear_bit(DPC_RESET_HA, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
+				clear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);
+				goto dpc_post_reset_ha;
+		}
+		if (test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||
+			test_bit(DPC_RESET_HA, &ha->dpc_flags)) {
+				qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
+		}
 
+		/* ISP-4xxx Specific */
 		if (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {
 			uint8_t wait_time = RESET_INTR_TOV;
 
@@ -1221,18 +1448,18 @@ static void qla4xxx_do_dpc(void *data)
 				DEBUG2(printk("scsi%ld: %s: SR|FSR "
 					      "bit not cleared-- resetting\n",
 					      ha->host_no, __func__));
-			qla4xxx_flush_active_srbs(ha);
+			qla4xxx_abort_active_cmds(ha, DID_RESET << 16);
 			if (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS) {
 				qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
-				status = qla4xxx_initialize_adapter(ha, 
-						PRESERVE_DDB_LIST);
+				status = qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST);
 			}
 			clear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);
 			if (status == QLA_SUCCESS)
-				qla4xxx_enable_intrs(ha);
+				ha->isp_ops->enable_intrs(ha);
 		}
 	}
 
+dpc_post_reset_ha:
 	/* ---- process AEN? --- */
 	if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
 		qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
@@ -1241,6 +1468,39 @@ static void qla4xxx_do_dpc(void *data)
 	if (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))
 		qla4xxx_get_dhcp_ip_address(ha);
 
+	/* ---- Link Change? --- */
+	if (test_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {
+		if (!test_bit(AF_LINK_UP, &ha->flags)) {
+			/* ---- link down? --- */
+			list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {
+				if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
+					qla4xxx_mark_device_missing(ha, ddb_entry);
+			}
+		} else {
+			/* ---- link up? ---
+			 * F/W will auto login to all devices ONLY ONCE after
+			 * link up during driver initialization and runtime
+			 * fatal error recovery.  Therefore, the driver must
+			 * manually relogin to devices when recovering from
+			 * connection failures, logouts, expired KATO, etc. */
+			list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {
+				if ((atomic_read(&ddb_entry->state) == DDB_STATE_MISSING) ||
+				    (atomic_read(&ddb_entry->state) == DDB_STATE_DEAD)) {
+					if (ddb_entry->fw_ddb_device_state
+					    == DDB_DS_SESSION_ACTIVE) {
+						atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
+						dev_info(&ha->pdev->dev, "scsi%ld: %s: ddb[%d] "
+							 "os[%d] marked ONLINE\n", ha->host_no, __func__,
+							 ddb_entry->fw_ddb_index, ddb_entry->os_target_id);
+						qla4xxx_conn_start(ddb_entry->conn);
+					} else {
+						qla4xxx_relogin_device(ha, ddb_entry);
+					}
+				}
+			}
+		}
+	}
+
 	/* ---- relogin device? --- */
 	if (adapter_up(ha) &&
 	    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {
@@ -1265,6 +1525,24 @@ static void qla4xxx_do_dpc(void *data)
 		}
 	}
 
+	/* ---- perform dynamic lun scan? --- */
+	if (adapter_up(ha) &&
+		test_and_clear_bit(DPC_DYNAMIC_LUN_SCAN, &ha->dpc_flags)) {
+		list_for_each_entry_safe(ddb_entry, dtemp,
+		&ha->ddb_list, list) {
+			if (test_and_clear_bit(DF_DYNAMIC_LUN_SCAN_NEEDED,
+				&ddb_entry->flags)) {
+				dev_info(&ha->pdev->dev, "%s: ddb[%d] os[%d] "
+					"perform dynamic lun scan\n",
+					__func__, ddb_entry->fw_ddb_index,
+					ddb_entry->os_target_id);
+				/* report new lun to kernel */
+				scsi_scan_target(&ddb_entry->sess->dev, 0,
+						ddb_entry->sess->target_id, SCAN_WILD_CARD, 0);
+			}
+		}
+	}
+
 	/* Check for ASYNC PDU IOCBs */
 	if (adapter_up(ha) &&
 		test_bit(DPC_ASYNC_MSG_PDU, &ha->dpc_flags)) {
@@ -1277,19 +1555,6 @@ static void qla4xxx_do_dpc(void *data)
 		}
 		clear_bit(DPC_ASYNC_MSG_PDU, &ha->dpc_flags);
 	}
-
-	if (test_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {
-		if (!test_bit(AF_LINK_UP, &ha->flags)) {
-			/* ---- link down? --- */
-			list_for_each_entry_safe(ddb_entry, dtemp,
-			&ha->ddb_list, list) {
-				if (atomic_read(&ddb_entry->state) ==
-					DDB_STATE_ONLINE)
-					qla4xxx_mark_device_missing(ha,
-						ddb_entry);
-			}
-		}
-	}
 }
 
 /**
@@ -1301,24 +1566,28 @@ static void qla4xxx_free_adapter(struct scsi_qla_host *ha)
 
 	if (test_bit(AF_INTERRUPTS_ON, &ha->flags)) {
 		/* Turn-off interrupts on the card. */
-		qla4xxx_disable_intrs(ha);
+		ha->isp_ops->disable_intrs(ha);
 	}
 
+	/* Remove timer thread, if present */
+	if (ha->timer_active)
+		qla4xxx_stop_timer(ha);
+
 	/* Kill the kernel thread for this host */
 	if (ha->dpc_thread)
 		destroy_workqueue(ha->dpc_thread);
 
-	/* Issue Soft Reset to put firmware in unknown state */
-	if (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS)
-		qla4xxx_hw_reset(ha);
-
-	/* Remove timer thread, if present */
-	if (ha->timer_active)
-		qla4xxx_stop_timer(ha);
+	/* Put firmware in a known state */
+	ha->isp_ops->reset_firmware(ha);
+	if (is_qla8022(ha)) {
+		qla82xx_idc_lock(ha);
+		qla82xx_clear_drv_active(ha);
+		qla82xx_idc_unlock(ha);
+	}
 
 	/* Detach interrupts */
 	if (test_and_clear_bit(AF_IRQ_ATTACHED, &ha->flags))
-		free_irq(ha->pdev->irq, ha);
+		qla4xxx_free_irqs(ha);
 
 	/* free extra memory */
 	qla4xxx_mem_free(ha);
@@ -1326,6 +1595,74 @@ static void qla4xxx_free_adapter(struct scsi_qla_host *ha)
 	pci_disable_device(ha->pdev);
 }
 
+int qla82xx_iospace_config(struct scsi_qla_host *ha)
+{
+	int status = 0;
+	uint8_t revision_id;
+	unsigned long mem_base, mem_len, db_base, db_len;
+	struct pci_dev *pdev = ha->pdev;
+
+	status = pci_request_regions(pdev, DRIVER_NAME);
+	if (status) {
+		printk(KERN_WARNING
+				"scsi(%ld) Failed to reserve PIO regions (%s) status=%d\n",
+				ha->host_no, pci_name(pdev), status);
+		goto iospace_error_exit;
+	}
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &revision_id);
+	DEBUG2(printk(KERN_INFO "%s: revision-id=%d\n",
+					__func__, revision_id));
+	ha->revision_id = revision_id;
+
+	/* remap phys address */
+	mem_base = pci_resource_start(pdev, 0); /* 0 is for BAR 0 */
+	mem_len = pci_resource_len(pdev, 0);
+	DEBUG2(printk(KERN_INFO "%s: ioremap from %lx a size of %lx\n",
+					__func__, mem_base, mem_len));
+
+	/* mapping of pcibase pointer */
+	ha->nx_pcibase = (unsigned long)ioremap(mem_base, mem_len);
+	if (!ha->nx_pcibase) {
+		printk(KERN_ERR
+			"cannot remap MMIO (%s), aborting\n", pci_name(pdev));
+		pci_release_regions(ha->pdev);
+		goto iospace_error_exit;
+	}
+
+	/* Mapping of IO base pointer, door bell read and write pointer */
+
+	/* mapping of IO base pointer */
+	ha->qla82xx_reg = (struct device_reg_82xx  __iomem *)((uint8_t *)ha->nx_pcibase +
+			0xbc000 + (ha->pdev->devfn << 11));
+
+	db_base = pci_resource_start(pdev, 4);  /* doorbell is on bar 4 */
+	db_len = pci_resource_len(pdev, 4);
+
+	/* mapping of doorbell write pointer */
+	ha->nx_db_wr_ptr = (unsigned long)ioremap(db_base +
+			(ha->pdev->devfn << 12), 4);
+	if (!ha->nx_db_wr_ptr) {
+		printk(KERN_ERR
+			"cannot remap MMIO doorbell-write (%s), aborting\n",
+			pci_name(pdev));
+		goto iospace_error_exit;
+	}
+
+	/* mapping of doorbell read pointer */
+	ha->nx_db_rd_ptr = (uint8_t *) ha->nx_pcibase + (512 * 1024) +
+		(ha->pdev->devfn * 8);
+	if (!ha->nx_db_rd_ptr)
+		printk(KERN_ERR
+			"cannot remap MMIO doorbell-read (%s), aborting\n",
+			pci_name(pdev));
+
+	return 0;
+
+iospace_error_exit:
+	return -ENOMEM;
+}
+
 /***
  * qla4xxx_iospace_config - maps registers
  * @ha: pointer to adapter structure
@@ -1333,7 +1670,7 @@ static void qla4xxx_free_adapter(struct scsi_qla_host *ha)
  * This routines maps HBA's registers from the pci address space
  * into the kernel virtual address space for memory mapped i/o. 
  **/
-static int qla4xxx_iospace_config(struct scsi_qla_host *ha)
+int qla4xxx_iospace_config(struct scsi_qla_host *ha)
 {
 	unsigned long pio, pio_len, pio_flags;
 	unsigned long mmio, mmio_len, mmio_flags;
@@ -1360,7 +1697,6 @@ static int qla4xxx_iospace_config(struct scsi_qla_host *ha)
 	if (!(mmio_flags & IORESOURCE_MEM)) {
 		dev_err(&ha->pdev->dev,
 			"region #0 not an MMIO resource, aborting\n");
-			
 		goto iospace_error_exit;
 	}
 	if (mmio_len < MIN_IOBASE_LEN) {
@@ -1392,6 +1728,59 @@ iospace_error_exit:
 	return -ENOMEM;
 }
 
+struct isp_operations qla4xxx_isp_ops = {
+	.iospace_config		= qla4xxx_iospace_config,
+	.pci_config		= qla4xxx_pci_config,
+	.disable_intrs		= qla4xxx_disable_intrs,
+	.enable_intrs		= qla4xxx_enable_intrs,
+	.start_firmware		= qla4xxx_start_firmware,
+	.intr_handler		= qla4xxx_intr_handler,
+	.interrupt_service_routine = qla4xxx_interrupt_service_routine,
+	.reset_chip		= qla4xxx_soft_reset,
+	.reset_firmware		= qla4xxx_hw_reset,
+	.queue_iocb		= qla4xxx_queue_iocb,
+	.complete_iocb		= qla4xxx_complete_iocb,
+	.rd_shdw_req_q_out	= qla4xxx_rd_shdw_req_q_out,
+	.rd_shdw_rsp_q_in	= qla4xxx_rd_shdw_rsp_q_in,
+	.get_sys_info		= qla4xxx_get_sys_info,
+};
+struct isp_operations qla82xx_isp_ops = {
+	.iospace_config		= qla82xx_iospace_config,
+	.pci_config		= qla82xx_pci_config,
+	.disable_intrs		= qla82xx_disable_intrs,
+	.enable_intrs		= qla82xx_enable_intrs,
+	.start_firmware		= qla82xx_load_risc,
+	.intr_handler		= qla82xx_intr_handler,
+	.interrupt_service_routine = qla82xx_interrupt_service_routine,
+	.reset_chip			= qla82xx_isp_reset,
+	.reset_firmware		= qla82xx_stop_firmware,
+	.queue_iocb		= qla82xx_queue_iocb,
+	.complete_iocb		= qla82xx_complete_iocb,
+	.rd_shdw_req_q_out	= qla82xx_rd_shdw_req_q_out,
+	.rd_shdw_rsp_q_in	= qla82xx_rd_shdw_rsp_q_in,
+	.get_sys_info		= qla82xx_get_sys_info,
+};
+
+uint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)
+{
+	return (uint16_t) le32_to_cpu(ha->shadow_regs->req_q_out);
+}
+
+uint16_t qla82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha)
+{
+	return (uint16_t) le32_to_cpu(readl(&ha->qla82xx_reg->req_q_out));
+}
+
+uint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)
+{
+	return (uint16_t) le32_to_cpu(ha->shadow_regs->rsp_q_in);
+}
+
+uint16_t qla82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)
+{
+	return (uint16_t) le32_to_cpu(readl(&ha->qla82xx_reg->rsp_q_in));
+}
+
 static void ql4_get_aen_log(struct scsi_qla_host *ha, struct ql4_aen_log *aenl)
 {
 	if (aenl) {
@@ -1410,13 +1799,13 @@ static void ql4_get_aen_log(struct scsi_qla_host *ha, struct ql4_aen_log *aenl)
  * the driver.
  **/
 static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
-					   const struct pci_device_id *ent)
+											const struct pci_device_id *ent)
 {
-	int ret = -ENODEV, status;
+	int ret = -ENODEV;
 	struct Scsi_Host *host;
 	struct scsi_qla_host *ha;
 	struct ddb_entry *ddb_entry, *ddbtemp;
-	uint8_t init_retry_count = 0;
+	uint8_t i;
 	char buf[34];
 
 	if (pci_enable_device(pdev))
@@ -1438,14 +1827,26 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	ha->host = host;
 	ha->host_no = host->host_no;
 
+	/* Setup Runtime configurable options */
+	if (is_qla8022(ha))
+		ha->isp_ops = &qla82xx_isp_ops;
+	else
+		ha->isp_ops = &qla4xxx_isp_ops;
+
+
+	/* ISP 8022 initializations */
+	if (is_qla8022(ha)) {
+		qla82xx_init_local_data(ha);
+	}
+
 	ha->ql4mbx = qla4xxx_mailbox_command;
 	ha->ql4cmd = qla4xxx_send_command_to_isp;
 	ha->ql4getaenlog = ql4_get_aen_log;
 
 	/* Configure PCI I/O space. */
-	ret = qla4xxx_iospace_config(ha);
+	ret = ha->isp_ops->iospace_config(ha);
 	if (ret)
-		goto probe_failed;
+		goto probe_failed_iospace_config;
 
 	dev_info(&ha->pdev->dev, "Found an ISP%04x, irq %d, iobase 0x%p\n",
 		   pdev->device, pdev->irq, ha->reg);
@@ -1458,6 +1859,7 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	INIT_LIST_HEAD(&ha->async_iocb_list);
 
 	mutex_init(&ha->mbox_sem);
+	init_completion(&ha->mbx_intr_comp);
 
 	spin_lock_init(&ha->hardware_lock);
 	spin_lock_init(&ha->list_lock);
@@ -1471,20 +1873,38 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 		goto probe_failed;
 	}
 
+	if (is_qla8022(ha)) {
+		ret = qla4xxx_request_irqs(ha);
+		if (ret) {
+			dev_warn(&ha->pdev->dev, "Failed to reserve interrupt %d"
+				" already in use.\n", pdev->irq);
+			goto probe_failed;
+		}
+		set_bit(AF_IRQ_ATTACHED, &ha->flags);
+		host->irq = pdev->irq;
+		dev_info(&ha->pdev->dev, "irq %d attached\n", ha->pdev->irq);
+	}
+
+	if (is_qla8022(ha))
+		(void) qla82xx_get_flash_info(ha);
+
 	/*
-	 * Initialize the Host adapter request/response queues and
-	 * firmware
-	 * NOTE: interrupts enabled upon successful completion
+	 * Initialize the Host adapter request/response queues and firmware
+	 * NOTE: AF_ONLINE flag set upon successful completion of
+	 *       qla4xxx_initialize_adapter
 	 */
-	status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
-	while (status == QLA_ERROR && init_retry_count++ < MAX_INIT_RETRIES) {
-		DEBUG2(printk(KERN_ERR "scsi%ld: %s: retrying adapter"
-			" initialization (%d)\n",
-			ha->host_no, __func__, init_retry_count));
-		qla4xxx_soft_reset(ha);
-		status = qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
-	}
-	if (status == QLA_ERROR) {
+	(void) qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+
+	for (i = 1; !test_bit(AF_ONLINE, &ha->flags) && i <= MAX_INIT_RETRIES; i++) {
+		DEBUG2(dev_info(&ha->pdev->dev, "%s: retry adapter init %d\n",
+			__func__, i));
+
+		if (ha->isp_ops->reset_chip(ha) == QLA_ERROR)
+			continue;
+
+		(void) qla4xxx_initialize_adapter(ha, REBUILD_DDB_LIST);
+	}
+	if (!test_bit(AF_ONLINE, &ha->flags)) {
 		dev_warn(&ha->pdev->dev, "Failed to initialize adapter\n");
 
 		ret = -ENODEV;
@@ -1511,18 +1931,19 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	}
 	INIT_WORK(&ha->dpc_work, qla4xxx_do_dpc, ha);
 
-	ret = request_irq(pdev->irq, qla4xxx_intr_handler,
-			  SA_INTERRUPT|SA_SHIRQ, "qla4xxx", ha);
-	if (ret) {
-		dev_warn(&ha->pdev->dev, "Failed to reserve interrupt %d"
-			" already in use.\n", pdev->irq);
-		goto probe_failed;
+	if (!is_qla8022(ha)) {
+		ret = qla4xxx_request_irqs(ha);
+		if (ret) {
+			dev_warn(&ha->pdev->dev, "Failed to reserve interrupt %d"
+				" already in use.\n", pdev->irq);
+			goto probe_failed;
+		}
+		set_bit(AF_IRQ_ATTACHED, &ha->flags);
+		host->irq = pdev->irq;
+		DEBUG(printk("scsi%ld: irq %d attached\n", ha->host_no, ha->pdev->irq));
 	}
-	set_bit(AF_IRQ_ATTACHED, &ha->flags);
-	host->irq = pdev->irq;
-	DEBUG(printk("scsi%d: irq %d attached\n", ha->host_no, ha->pdev->irq));
 
-	qla4xxx_enable_intrs(ha);
+	ha->isp_ops->enable_intrs(ha);
 
 	/* Start timer thread. */
 	qla4xxx_start_timer(ha, qla4xxx_timer, 1);
@@ -1543,9 +1964,8 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	}
 
 	printk(KERN_INFO
-		" QLogic iSCSI HBA Driver version: %s\n"
-		" QLogic ISP%04x @ %s, pdev = %p host#=%ld,"
-		" fw=%02d.%02d.%02d.%02d\n",
+	       " QLogic iSCSI HBA Driver version: %s\n"
+	       "  QLogic ISP%04x @ %s, pdev = %p host#=%ld, fw=%02d.%02d.%02d.%02d\n",
 	       qla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev), pdev,
 	       ha->host_no, ha->firmware_version[0], ha->firmware_version[1],
 	       ha->patch_number, ha->build_number);
@@ -1565,6 +1985,8 @@ remove_host:
 
 probe_failed:
 	qla4xxx_free_adapter(ha);
+
+probe_failed_iospace_config:
 	scsi_host_put(ha->host);
 
 probe_disable_device:
@@ -1583,7 +2005,11 @@ static void __devexit qla4xxx_remove_adapter(struct pci_dev *pdev)
 
 	ha = pci_get_drvdata(pdev);
 
-	qla4xxx_disable_intrs(ha);
+	dev_info(&ha->pdev->dev, "scsi%d: %s:\n", ha->host->host_no, __func__);
+
+	set_bit(AF_HBA_GOING_AWAY, &ha->flags);
+
+	ha->isp_ops->disable_intrs(ha);
 
 	while (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags))
 		ssleep(1);
@@ -1630,10 +2056,12 @@ void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha)
 static int qla4xxx_slave_alloc(struct scsi_device *sdev)
 {
 	struct iscsi_cls_session *sess = starget_to_session(sdev->sdev_target);
-	struct ddb_entry *ddb = sess->dd_data;
 
-	sdev->hostdata = ddb;
-	return 0;
+	if (sess) {
+		sdev->hostdata = sess->dd_data;
+		return 0;
+	}
+	return FAILED;
 }
 
 static int qla4xxx_slave_configure(struct scsi_device *sdev)
@@ -1646,6 +2074,11 @@ static int qla4xxx_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
+static void qla4xxx_slave_destroy(struct scsi_device *sdev)
+{
+	sdev->hostdata = NULL;
+}
+
 /**
  * qla4xxx_del_from_active_array - returns an active srb
  * @ha: Pointer to host adapter structure.
@@ -1653,8 +2086,7 @@ static int qla4xxx_slave_configure(struct scsi_device *sdev)
  *
  * This routine removes and returns the srb at the specified index
  **/
-struct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,
-						uint32_t index)
+struct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha, uint32_t index)
 {
 	struct srb *srb = NULL;
 
@@ -1689,21 +2121,14 @@ struct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,
 static int qla4xxx_eh_wait_on_command(struct scsi_qla_host *ha,
 				      struct scsi_cmnd *cmd, int got_ref)
 {
-#define ABORT_POLLING_PERIOD	1000
+#define ABORT_POLLING_PERIOD	2000
 #define ABORT_WAIT_ITER		1
 	int done = 0;
-	struct srb *rp;
 	unsigned long wait_iter = ABORT_WAIT_ITER;
 
 	do {
 		/* Checking to see if its returned to OS */
-		rp = (struct srb *) cmd->SCp.ptr;
-		if (rp == NULL) {
-			done++;
-			break;
-		}
-
-		if (got_ref && (atomic_read(&rp->ref_count) == 1)) {
+		if (cmd->host_scribble == NULL) {
 			done++;
 			break;
 		}
@@ -1722,7 +2147,7 @@ static int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha)
 {
 	unsigned long wait_online;
 
-	wait_online = jiffies + (30 * HZ);
+	wait_online = jiffies + (60 * HZ);
 	while (time_before(jiffies, wait_online)) {
 
 		if (adapter_up(ha))
@@ -1800,17 +2225,13 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 	unsigned long wait_online;
 
 	if (!ddb_entry) {
-		DEBUG2(printk(KERN_INFO
-			"scsi%ld: ABORT - NULL ddb entry.\n",
-			ha->host_no));
+		DEBUG2(printk("scsi%ld: ABORT - NULL ddb entry.\n", ha->host_no));
 		return FAILED;
 	}
 
 	if (cmd == NULL) {
-		DEBUG2(printk(KERN_INFO
-			"scsi%ld: ABORT - **** SCSI mid-layer"
-			"passing in NULL cmd\n",
-			ha->host_no));
+		DEBUG2(printk("scsi%ld: ABORT - **** SCSI mid-layer passing in NULL cmd\n",
+				ha->host_no));
 		return SUCCESS;
 	}
 
@@ -1823,13 +2244,12 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 
 	dev_info(&ha->pdev->dev, "scsi%ld:%d:%d:%d: ABORT ISSUED "
 		 "cmd=%p, pid=%ld, ref=%d\n", ha->host_no, channel, id, lun,
-		 cmd, serial, atomic_read(&srb->ref_count));
+		 cmd, serial, atomic_read(&srb->srb_ref.refcount));
 
 	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
-		DEBUG2(printk(KERN_INFO
-			"scsi%ld:%d: %s: Unable to abort task. Adapter "
-			"DEAD.\n", ha->host_no, cmd->device->channel
-			, __func__));
+		DEBUG2(printk("scsi%ld:%d: %s: Unable to abort task. Adapter "
+				"DEAD.\n", ha->host_no, cmd->device->channel
+				, __func__));
 
 		return FAILED;
 	}
@@ -1851,13 +2271,12 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 		DEBUG3(qla4xxx_print_scsi_cmd(cmd));
 
 		/* Get a reference to the sp and drop the lock.*/
-		sp_get(srb);
+		kref_get(&srb->srb_ref);
 		got_ref++;
 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 		/*
-		 * If device is not online wait for 10 sec for device
-		 * to come online,
+		 * If device is not online wait for 10 sec for device to come online,
 		 * else return error and do not issue abort task.
 		 */
 		if (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {
@@ -1865,19 +2284,15 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 			while (time_before(jiffies, wait_online)) {
 				set_current_state(TASK_INTERRUPTIBLE);
 				schedule_timeout(HZ);
-				if (atomic_read(&ddb_entry->state) ==
-					DDB_STATE_ONLINE)
+				if (atomic_read(&ddb_entry->state) == DDB_STATE_ONLINE)
 					break;
 			}
-			if (atomic_read(&ddb_entry->state) !=
-				DDB_STATE_ONLINE) {
-				DEBUG2(printk("scsi%ld:%d: %s: Unable to abort"
-						"task Device is not online.\n",
-						ha->host_no,
-						cmd->device->channel,
-						__func__));
-
-				return FAILED;
+			if (atomic_read(&ddb_entry->state) != DDB_STATE_ONLINE) {
+				DEBUG2(printk("scsi%ld:%d: %s: Unable to abort task."
+					      "Device is not online.\n", ha->host_no
+					      , cmd->device->channel, __func__));
+				kref_put(&srb->srb_ref, qla4xxx_srb_compl);
+				goto exit_qla4xxx_eh_abort;
 			}
 		}
 
@@ -1895,20 +2310,25 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 	}
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
-	/* Wait for command to complete */
-	if (qla4xxx_eh_wait_on_command(ha, cmd, got_ref)) {
-		dev_info(&ha->pdev->dev,
-			 "scsi%ld:%d:%d:%d: ABORT SUCCEEDED - "
-			 "cmd returned back to OS.\n",
-			 ha->host_no, channel, id, lun);
-		ret = SUCCESS;
+	if (i < MAX_SRBS) {
+		if (qla4xxx_eh_wait_on_command(ha, cmd, got_ref)) {
+			dev_info(&ha->pdev->dev,
+				 "scsi%ld:%d:%d:%d: ABORT SUCCEEDED - "
+				 "cmd returned back to OS.\n",
+				 ha->host_no, channel, id, lun);
+			ret = SUCCESS;
+		}
+		DEBUG2(printk("scsi%ld:%d:%d:%d: ABORT cmd=%p, pid=%ld, ref=%d, "
+			"ret=%x\n", ha->host_no, channel, id, lun, cmd,
+			serial, atomic_read(&srb->srb_ref.refcount), ret));
+		kref_put(&srb->srb_ref, qla4xxx_srb_compl);
+	} else {
+		dev_info(&ha->pdev->dev, "scsi%ld:%d:%d:%d: ABORT FAILED",
+			ha->host_no, channel, id, lun);
+		ret = FAILED;
 	}
 
-	if (got_ref)
-		sp_put(ha, srb);
-
-	DEBUG2(printk("scsi%ld:%d:%d:%d: ABORT cmd=%p, pid=%ld, ret=%x\n"
-		      , ha->host_no, channel, id, lun, cmd, serial, ret));
+exit_qla4xxx_eh_abort:
 	return ret;
 }
 
@@ -1928,8 +2348,7 @@ static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
 	unsigned int b, t, l;
 
 	if (cmd == NULL) {
-		DEBUG2(printk(KERN_INFO
-				"%s: **** SCSI mid-layer passing in NULL cmd"
+		DEBUG2(printk("%s: **** SCSI mid-layer passing in NULL cmd"
 				"DEVICE RESET - cmd already completed.\n",
 				__func__));
 		return SUCCESS;
@@ -1942,13 +2361,23 @@ static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
 	ha = to_qla_host(cmd->device->host);
 	ddb_entry = cmd->device->hostdata;
 	if (!ddb_entry) {
-		DEBUG2(printk("scsi%ld: DEVICE RESET - NULL ddb entry.\n",
-			ha->host_no));
+		DEBUG2(printk("scsi%ld: DEVICE RESET - NULL ddb entry.\n", ha->host_no));
 		return ret;
 	}
+
+	if (test_bit(AF_HBA_GOING_AWAY, &ha->flags)) {
+		DEBUG2(printk("scsi%ld: %s: Don't Reset.  "
+			      "HBA Going Away!\n", ha->host_no, __func__));
+		return FAILED;
+	}
+
+	if (test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags)) {
+		DEBUG2(printk("scsi%ld: %s: Don't Reset.  "
+			      "HBA Reset Active!\n", ha->host_no, __func__));
+		return FAILED;
+	}
 	dev_info(&ha->pdev->dev,
-		   "scsi%ld:%d:%d:%d: DEVICE RESET ISSUED.\n",
-			ha->host_no, b, t, l);
+		   "scsi%ld:%d:%d:%d: DEVICE RESET ISSUED.\n", ha->host_no, b, t, l);
 
 	DEBUG2(printk(KERN_INFO
 		      "scsi%ld: DEVICE_RESET cmd=%p jiffies = 0x%lx, to=%x,"
@@ -1957,9 +2386,8 @@ static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
 		      ha->dpc_flags, cmd->result, cmd->allowed));
 
 	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
-		DEBUG2(printk(KERN_INFO
-			"scsi%ld:%d: %s: DEVICE RESET. Adapter "
-			"Offline.\n", ha->host_no, b, __func__));
+		DEBUG2(printk("scsi%ld:%d: %s: DEVICE RESET. Adapter "
+				"Offline.\n", ha->host_no, b, __func__));
 
 		return FAILED;
 	}
@@ -1986,8 +2414,7 @@ static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
 		goto eh_dev_reset_done;
 
 	dev_info(&ha->pdev->dev,
-		   "scsi(%ld:%d:%d:%d): DEVICE RESET SUCCEEDED.\n",
-			ha->host_no, b, t, l);
+		   "scsi(%ld:%d:%d:%d): DEVICE RESET SUCCEEDED.\n", ha->host_no, b, t, l);
 
 	ret = SUCCESS;
 
@@ -2009,9 +2436,8 @@ static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
 	struct scsi_qla_host *ha;
 
 	if (cmd == NULL) {
-		DEBUG2(printk(KERN_INFO "%s: **** SCSI mid-layer passing "
-				"in NULL cmd HOST RESET - cmd already "
-				"completed.\n",
+		DEBUG2(printk("%s: **** SCSI mid-layer passing in NULL cmd"
+				"HOST RESET - cmd already completed.\n",
 				__func__));
 		return SUCCESS;
 	}
@@ -2022,6 +2448,16 @@ static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
 		   "scsi(%ld:%d:%d:%d): HOST RESET ISSUED.\n", ha->host_no,
 		   cmd->device->channel, cmd->device->id, cmd->device->lun);
 
+	if (ql4xdontresethba) {
+			DEBUG2(printk("%s: Don't Reset HBA\n", __func__));
+			return FAILED;
+	}
+
+	if (test_bit(AF_HBA_GOING_AWAY, &ha->flags)) {
+		DEBUG2(printk("scsi%ld: %s: Don't Reset.  HBA Going Away!\n", ha->host_no, __func__));
+		return FAILED;
+	}
+
 	if (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld:%d: %s: Unable to reset host.  Adapter "
 			      "DEAD.\n", ha->host_no, cmd->device->channel,
@@ -2030,6 +2466,12 @@ static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
 		return FAILED;
 	}
 
+	if (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {
+		(is_qla8022(ha)) ?
+			set_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) :
+			set_bit(DPC_RESET_HA, &ha->dpc_flags);
+	}
+
 	if (qla4xxx_recover_adapter(ha, PRESERVE_DDB_LIST) == QLA_SUCCESS) {
 		return_status = SUCCESS;
 	}
@@ -2060,6 +2502,12 @@ static struct pci_device_id qla4xxx_pci_tbl[] = {
 		.subvendor	= PCI_ANY_ID,
 		.subdevice	= PCI_ANY_ID,
 	},
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP8022,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+	},
 	{0, 0},
 };
 MODULE_DEVICE_TABLE(pci, qla4xxx_pci_tbl);
@@ -2090,7 +2538,7 @@ static int __init qla4xxx_module_init(void)
 
 	/* Derive version string. */
 	strcpy(qla4xxx_version_str, QLA4XXX_DRIVER_VERSION);
-	if (extended_error_logging)
+	if (ql4xextended_error_logging)
 		strcat(qla4xxx_version_str, "-debug");
 
 	qla4xxx_scsi_transport =
@@ -2117,7 +2565,6 @@ no_srp_cache:
 
 static void __exit qla4xxx_module_exit(void)
 {
-	ql4_mod_unload = 1;
 	pci_unregister_driver(&qla4xxx_pci_driver);
 	iscsi2_unregister_transport(&qla4xxx_iscsi_transport);
 	kmem_cache_destroy(srb_cachep);
diff --git a/drivers/scsi/qla4xxx/ql4_version.h b/drivers/scsi/qla4xxx/ql4_version.h
index 96fdf08..faf173b 100644
--- a/drivers/scsi/qla4xxx/ql4_version.h
+++ b/drivers/scsi/qla4xxx/ql4_version.h
@@ -5,5 +5,4 @@
  * See LICENSE.qla4xxx for copyright and licensing details.
  */
 
-#define QLA4XXX_DRIVER_VERSION	"5.01.00.00.05.05-k9"
-
+#define QLA4XXX_DRIVER_VERSION	"5.02.01.00.05.06-d1"
