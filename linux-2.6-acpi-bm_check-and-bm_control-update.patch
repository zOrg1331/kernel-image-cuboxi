From: Luming Yu <luyu@redhat.com>
Date: Fri, 30 Oct 2009 06:25:55 -0400
Subject: [acpi] bm_check and bm_control update
Message-id: <4AEA86F3.9010306@redhat.com>
Patchwork-id: 21261
O-Subject: [RHEL 5.5 PATCH 1/1] bz509422: bm_check and bm_control update
Bugzilla: 509422
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

Description of problem:

This incremental patch is to make back port patch "[RHEL 5.5 PATCH]
bz509422:Disable ARB_DISABLE on platforms where    it is not needed"
posted by me on 10/20/2009  more closer to upstream by:
1. adding second chunk of the upstream patch to
acpi_processor_power_verify_c3()
2. Just use acpi_processor_idle_simple if (bm_check and !bm_control) is
true. For any other combination of bm_check and bm_control, still use
unchanged acpi_processor_idle of previous version that the patch is
trying to fix.

Testing status:
Successfully tested by me on NHM EX system.

NOTE: to apply, please keep it in this order:

1.[RHEL 5.5 PATCH] bz509422:Disable ARB_DISABLE on platforms where    it
is not needed
2.[RHEL 5.5 PATCH 1/1] bz509422: bm_check and bm_control update

Brew info:
http://brewweb.devel.redhat.com/brew/taskinfo?taskID=2054448

diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index 3ddae02..d35be40 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -443,7 +443,6 @@ static void acpi_processor_idle_simple(void)
 		acpi_processor_power_activate(pr, next_state);
 }
 
-static void (*acpi_processor_idle)(void) = acpi_processor_idle_simple;
 static void acpi_processor_idle_bm(void)
 {
 	struct acpi_processor *pr = NULL;
@@ -748,6 +747,7 @@ static void acpi_processor_idle_bm(void)
 	if (next_state != pr->power.state)
 		acpi_processor_power_activate(pr, next_state);
 }
+static void (*acpi_processor_idle)(void) = acpi_processor_idle_bm;
 
 static int acpi_processor_set_power_policy(struct acpi_processor *pr)
 {
@@ -1041,7 +1041,8 @@ static void acpi_processor_power_verify_c2(struct acpi_processor_cx *cx)
 static void acpi_processor_power_verify_c3(struct acpi_processor *pr,
 					   struct acpi_processor_cx *cx)
 {
-	static int bm_check_flag;
+	static int bm_check_flag = -1;
+	static int bm_control_flag = -1;
 
 
 	if (!cx->address)
@@ -1071,12 +1072,14 @@ static void acpi_processor_power_verify_c3(struct acpi_processor *pr,
 	}
 
 	/* All the logic here assumes flags.bm_check is same across all CPUs */
-	if (!bm_check_flag) {
+	if (bm_check_flag == -1) {
 		/* Determine whether bm_check is needed based on CPU  */
 		acpi_processor_power_init_bm_check(&(pr->flags), pr->id);
 		bm_check_flag = pr->flags.bm_check;
+		bm_control_flag = pr->flags.bm_control;
 	} else {
 		pr->flags.bm_check = bm_check_flag;
+		pr->flags.bm_control = bm_control_flag;
 	}
 
 	if (pr->flags.bm_check) {
@@ -1130,8 +1133,8 @@ static int acpi_processor_power_verify(struct acpi_processor *pr)
 	on_each_cpu(switch_ipi_to_APIC_timer, &mask, 1, 1);
 #endif
 	acpi_processor_power_init_bm_check(&(pr->flags), pr->id);
-	if (pr->flags.bm_control)
-		acpi_processor_idle = acpi_processor_idle_bm;
+	if (pr->flags.bm_check && !pr->flags.bm_control)
+		acpi_processor_idle = acpi_processor_idle_simple;
 
 	for (i = 1; i < ACPI_PROCESSOR_MAX_POWER; i++) {
 		struct acpi_processor_cx *cx = &pr->power.states[i];
