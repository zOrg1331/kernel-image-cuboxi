From: Doug Ledford <dledford@redhat.com>
Date: Mon, 15 Jun 2009 09:52:37 -0400
Subject: [infiniband] OFED: removes this backport and all callers
Message-id: 425507bd826bab3e19b2aa22eebb22e9bce2d4ef.1245072809.git.dledford@redhat.com
O-Subject: [Patch RHEL5.4 02/16] [OFED] 1.4.1 final bits removes this backport and all callers
Bugzilla: 506097

Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/drivers/infiniband/core/Makefile b/drivers/infiniband/core/Makefile
index 754721e..86c0e9e 100644
--- a/drivers/infiniband/core/Makefile
+++ b/drivers/infiniband/core/Makefile
@@ -31,4 +31,3 @@ ib_ucm-y :=			ucm.o
 
 ib_uverbs-y :=			uverbs_main.o uverbs_cmd.o uverbs_marshall.o
 
-ib_core-y +=			namespace.o writeback.o
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index cc17114..34ea25a 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -736,10 +736,6 @@ static int __init ib_core_init(void)
 		dma_map_sg_hp_wa = 1;
 #endif
 
-	ret = init_mnt_writers();
-	if (ret)
-		printk(KERN_WARNING "Couldn't init mnt_writers\n");
-
 	ret = ib_sysfs_setup();
 	if (ret)
 		printk(KERN_WARNING "Couldn't create InfiniBand device class\n");
diff --git a/drivers/infiniband/core/namespace.c b/drivers/infiniband/core/namespace.c
deleted file mode 100644
index f43fcb8..0000000
--- a/drivers/infiniband/core/namespace.c
+++ /dev/null
@@ -1,98 +0,0 @@
-#include <linux/spinlock_types.h>
-#include <linux/percpu.h>
-#include <linux/mount.h>
-#include <linux/module.h>
-
-struct mnt_writer {
-	/*
-	 * If holding multiple instances of this lock, they
-	 * must be ordered by cpu number.
-	 */
-	spinlock_t lock;
-	struct lock_class_key lock_class; /* compiles out with !lockdep */
-	unsigned long count;
-	struct vfsmount *mnt;
-} ____cacheline_aligned_in_smp;
-static DEFINE_PER_CPU(struct mnt_writer, mnt_writers);
-
-int backport_init_mnt_writers(void)
-{
-	int cpu;
-	for_each_possible_cpu(cpu) {
-		struct mnt_writer *writer = &per_cpu(mnt_writers, cpu);
-		spin_lock_init(&writer->lock);
-		/* causes issues on RHEL-5 -debug kernels */
-		//lockdep_set_class(&writer->lock, &writer->lock_class);
-		writer->count = 0;
-	}
-	return 0;
-}
-EXPORT_SYMBOL_GPL(backport_init_mnt_writers);
-
-static inline void __clear_mnt_count(struct mnt_writer *cpu_writer)
-{
-	if (!cpu_writer->mnt)
-		return;
-	/*
-	 * This is in case anyone ever leaves an invalid,
-	 * old ->mnt and a count of 0.
-	 */
-	if (!cpu_writer->count)
-		return;
-	cpu_writer->count = 0;
-}
-
-static inline void use_cpu_writer_for_mount(struct mnt_writer *cpu_writer,
-					  struct vfsmount *mnt)
-{
-	if (cpu_writer->mnt == mnt)
-		return;
-	__clear_mnt_count(cpu_writer);
-	cpu_writer->mnt = mnt;
-}
-
-int backport_mnt_want_write(struct vfsmount *mnt)
-{
-	int ret = 0;
-	struct mnt_writer *cpu_writer;
-
-	cpu_writer = &get_cpu_var(mnt_writers);
-	spin_lock(&cpu_writer->lock);
-	if (__mnt_is_readonly(mnt)) {
-		ret = -EROFS;
-		goto out;
-	}
-	use_cpu_writer_for_mount(cpu_writer, mnt);
-	cpu_writer->count++;
-out:
-	spin_unlock(&cpu_writer->lock);
-	put_cpu_var(mnt_writers);
-	return ret;
-}
-EXPORT_SYMBOL(backport_mnt_want_write);
-
-void backport_mnt_drop_write(struct vfsmount *mnt)
-{
-	struct mnt_writer *cpu_writer;
-
-	cpu_writer = &get_cpu_var(mnt_writers);
-	spin_lock(&cpu_writer->lock);
-
-	use_cpu_writer_for_mount(cpu_writer, mnt);
-	if (cpu_writer->count > 0) {
-		cpu_writer->count--;
-	}
-
-	spin_unlock(&cpu_writer->lock);
-	/*
-	 * This could be done right after the spinlock
-	 * is taken because the spinlock keeps us on
-	 * the cpu, and disables preemption.  However,
-	 * putting it here bounds the amount that
-	 * __mnt_writers can underflow.  Without it,
-	 * we could theoretically wrap __mnt_writers.
-	 */
-	put_cpu_var(mnt_writers);
-}
-EXPORT_SYMBOL(backport_mnt_drop_write);
-
diff --git a/drivers/infiniband/core/writeback.c b/drivers/infiniband/core/writeback.c
deleted file mode 100644
index 7f8ebbe..0000000
--- a/drivers/infiniband/core/writeback.c
+++ /dev/null
@@ -1,106 +0,0 @@
-#include <linux/fs.h>
-#include <linux/pagemap.h>
-#include <linux/pagevec.h>
-#include <linux/writeback.h>
-#include <linux/mpage.h>
-#include <linux/module.h>
-
-int backport_write_cache_pages(struct address_space *mapping,
-                      struct writeback_control *wbc, backport_writepage_t writepage,
-                      void *data)
-{
-        struct backing_dev_info *bdi = mapping->backing_dev_info;
-        int ret = 0;
-        int done = 0;
-        struct pagevec pvec;
-        int nr_pages;
-        pgoff_t index;
-        pgoff_t end;            /* Inclusive */
-        int scanned = 0;
-        int range_whole = 0;
-        long nr_to_write = wbc->nr_to_write;
-
-        if (wbc->nonblocking && bdi_write_congested(bdi)) {
-                wbc->encountered_congestion = 1;
-                return 0;
-        }
-
-        pagevec_init(&pvec, 0);
-        if (wbc->range_cyclic) {
-                index = mapping->writeback_index; /* Start from prev offset */
-                end = -1;
-        } else {
-                index = wbc->range_start >> PAGE_CACHE_SHIFT;
-                end = wbc->range_end >> PAGE_CACHE_SHIFT;
-                if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
-                        range_whole = 1;
-                scanned = 1;
-        }
-retry:
-        while (!done && (index <= end) &&
-               (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index,
-                                              PAGECACHE_TAG_DIRTY,
-                                              min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {
-                unsigned i;
-
-                scanned = 1;
-                for (i = 0; i < nr_pages; i++) {
-                        struct page *page = pvec.pages[i];
-
-                        /*
-                         * At this point we hold neither mapping->tree_lock nor
-                         * lock on the page itself: the page may be truncated or
-                         * invalidated (changing page->mapping to NULL), or even
-                         * swizzled back from swapper_space to tmpfs file
-                         * mapping
-                         */
-                        lock_page(page);
-
-                        if (unlikely(page->mapping != mapping)) {
-                                unlock_page(page);
-                                continue;
-                        }
-
-                        if (!wbc->range_cyclic && page->index > end) {
-                                done = 1;
-                                unlock_page(page);
-                                continue;
-                        }
-
-                        if (wbc->sync_mode != WB_SYNC_NONE)
-                                wait_on_page_writeback(page);
-
-                        if (PageWriteback(page) ||
-                            !clear_page_dirty_for_io(page)) {
-                                unlock_page(page);
-                                continue;
-                        }
-
-                        ret = (*writepage)(page, wbc, data);
-
-                        if (unlikely(ret == AOP_WRITEPAGE_ACTIVATE)) {
-                                unlock_page(page);
-                                ret = 0;
-                        }
-                        if (ret || (--nr_to_write <= 0))
-                                done = 1;
-                        if (wbc->nonblocking && bdi_write_congested(bdi)) {
-                                wbc->encountered_congestion = 1;
-                                done = 1;
-                        }
-                }
-                pagevec_release(&pvec);
-                cond_resched();
-        }
-        if (!scanned && !done) {
-                /*
-                 * We hit the last page and there is more work to be done: wrap
-                 * back to the start of the file
-                 */
-                scanned = 1;
-                index = 0;
-                goto retry;
-        }
-        return ret;
-}
-EXPORT_SYMBOL(backport_write_cache_pages);
