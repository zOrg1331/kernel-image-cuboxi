From: Tomas Henzl <thenzl@redhat.com>
Date: Sun, 29 Aug 2010 15:49:17 -0400
Subject: [block] cciss: add cciss_sysfs_stat_inquiry function
Message-id: <1283097002-3341-19-git-send-email-thenzl@redhat.com>
Patchwork-id: 27872
O-Subject: [RHEL6 PATCH 18/63] cciss: Add cciss_sysfs_stat_inquiry function to
	gather info about logical drives.
Bugzilla: 568830
RH-Acked-by: Neil Horman <nhorman@redhat.com>

Add cciss_sysfs_stat_inquiry function to gather info about logical drives.

diff --git a/drivers/block/cciss.c b/drivers/block/cciss.c
index 7ff2f82..e8c90d6 100644
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -187,6 +187,8 @@ static int process_sendcmd_error(ctlr_info_t *h, CommandList_struct *c);
 static void fail_all_cmds(unsigned long ctlr);
 static void cciss_shutdown(struct pci_dev *);
 static int scan_thread(void *data);
+static void cciss_get_uid(int ctlr, int logvol, int withirq,
+	unsigned char *uid, int buflen);
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c);
 
 #ifdef CONFIG_PROC_FS
@@ -965,6 +967,47 @@ static int cciss_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 	return 0;
 }
 
+static void cciss_sysfs_stat_inquiry(int ctlr, int logvol,
+			drive_info_struct *drv)
+{
+	int return_code;
+	InquiryData_struct *inq_buff;
+	unsigned char scsi3addr[8];
+
+	/* If there are no heads then this is the controller disk and
+	 * not a valid logical drive so don't query it.
+	 */
+	if (!drv->heads)
+		return;
+
+	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
+	if (!inq_buff) {
+		printk(KERN_ERR "cciss: out of memory\n");
+		goto err;
+	}
+	log_unit_to_scsi3addr(hba[ctlr], scsi3addr, logvol);
+	return_code = sendcmd_withirq(CISS_INQUIRY, ctlr,
+		inq_buff, sizeof(*inq_buff), 0, scsi3addr, TYPE_CMD);
+	if (return_code == IO_OK) {
+		memcpy(drv->vendor, &inq_buff->data_byte[8], 8);
+		drv->vendor[8]='\0';
+		memcpy(drv->model, &inq_buff->data_byte[16], 16);
+		drv->model[16] = '\0';
+		memcpy(drv->rev, &inq_buff->data_byte[32], 4);
+		drv->rev[4] = '\0';
+	} else { /* Get geometry failed */
+		printk(KERN_WARNING "cciss: inquiry for VPD page 0 failed\n");
+	}
+
+	cciss_get_uid(ctlr, logvol, 1, drv->uid, sizeof(drv->uid));
+	
+err:
+	drv->vendor[8] = '\0';
+	drv->model[16] = '\0';
+	drv->rev[4] = '\0';
+
+}
+
 static void check_ioctl_unit_attention(ctlr_info_t *host, CommandList_struct *c)
 {
 	if (c->err_info->CommandStatus == CMD_TARGET_STATUS &&
@@ -1844,6 +1887,8 @@ static void cciss_update_drive_info(int ctlr, int drv_index, int first_time)
 	disk = h->gendisk[drv_index];
 	set_capacity(disk, h->drv[drv_index].nr_blocks);
 
+	cciss_sysfs_stat_inquiry(ctlr, drv_index, &h->drv[drv_index]);
+
  	/* We only add the c*d0 node once, at driver init time */
  	/* and never remove it. */
  	if (drv_index || first_time)
