From: Kei Tokunaga <ktokunag@redhat.com>
Subject: [RHEL5.1 PATCH 3/21] Fix xm mem-set hypercall on IA64
Date: Thu, 07 Jun 2007 03:32:56 -0400
Bugzilla: 241976
Message-Id: <4667B4A8.4000703@redhat.com>
Changelog: [xen] ia64: Fix xm mem-set hypercall on IA64


bz241976
https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=241976

Backport of cset#12442.

Dom0 hangs if you go through the following simple steps
due to a bug of "xm mem-set" hypercall.

  1. boot a xen kernel with dom0_mem=512M.
  2. run a command "xm mem-set 512M".

This patch fix it by saving/restoring hypercall parameters
within xencomm.

Thanks,
Kei




rh bug 241976

# HG changeset patch
# User awilliam@xenbuild.aw
# Date 1163442270 25200
# Node ID fe543184f7f9d4c54a38525d7584950cee27d73e
# Parent  169687dab774a442b51a2175cbbdbe2a13b433d4
[IA64] Fix xencomm for xm mem-set command

This patch saves and restores the hypercall parameter within xencomm.

Signed-off-by: Masaki Kanno <kanno.masaki@jp.fujitsu.com>


---

 linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xcom_hcall.c |   34 +++++++++-
 1 file changed, 32 insertions(+), 2 deletions(-)

diff -puN arch/ia64/xen/xcom_hcall.c~12442-IA64_Fix_xencomm_for_xm_mem-set_command arch/ia64/xen/xcom_hcall.c
--- linux-2.6.18-21.el5-gerd-order/arch/ia64/xen/xcom_hcall.c~12442-IA64_Fix_xencomm_for_xm_mem-set_command	2007-06-06 21:00:01.000000000 -0400
+++ linux-2.6.18-21.el5-gerd-order-kei/arch/ia64/xen/xcom_hcall.c	2007-06-06 21:00:01.000000000 -0400
@@ -221,10 +221,17 @@ xencommize_memory_reservation (xen_memor
 int
 xencomm_hypercall_memory_op(unsigned int cmd, void *arg)
 {
+	XEN_GUEST_HANDLE(xen_pfn_t) extent_start_va[2];
+	xen_memory_reservation_t *xmr = NULL, *xme_in = NULL, *xme_out = NULL;
+	int rc;
+
 	switch (cmd) {
 	case XENMEM_increase_reservation:
 	case XENMEM_decrease_reservation:
 	case XENMEM_populate_physmap:
+		xmr = (xen_memory_reservation_t *)arg;
+		xen_guest_handle(extent_start_va[0]) =
+			xen_guest_handle(xmr->extent_start);
 		xencommize_memory_reservation((xen_memory_reservation_t *)arg);
 		break;
 		
@@ -232,6 +239,12 @@ xencomm_hypercall_memory_op(unsigned int
 		break;
 
 	case XENMEM_exchange:
+		xme_in  = &((xen_memory_exchange_t *)arg)->in;
+		xme_out = &((xen_memory_exchange_t *)arg)->out;
+		xen_guest_handle(extent_start_va[0]) =
+			xen_guest_handle(xme_in->extent_start);
+		xen_guest_handle(extent_start_va[1]) =
+			xen_guest_handle(xme_out->extent_start);
 		xencommize_memory_reservation
 			(&((xen_memory_exchange_t *)arg)->in);
 		xencommize_memory_reservation
@@ -243,8 +256,25 @@ xencomm_hypercall_memory_op(unsigned int
 		return -ENOSYS;
 	}
 
-	return xencomm_arch_hypercall_memory_op
-		(cmd, xencomm_create_inline(arg));
+	rc =  xencomm_arch_hypercall_memory_op(cmd, xencomm_create_inline(arg));
+
+	switch (cmd) {
+	case XENMEM_increase_reservation:
+	case XENMEM_decrease_reservation:
+	case XENMEM_populate_physmap:
+		xen_guest_handle(xmr->extent_start) =
+			xen_guest_handle(extent_start_va[0]);
+		break;
+
+	case XENMEM_exchange:
+		xen_guest_handle(xme_in->extent_start) =
+			xen_guest_handle(extent_start_va[0]);
+		xen_guest_handle(xme_out->extent_start) =
+			xen_guest_handle(extent_start_va[1]);
+		break;
+	}
+
+	return rc;
 }
 
 unsigned long

_

