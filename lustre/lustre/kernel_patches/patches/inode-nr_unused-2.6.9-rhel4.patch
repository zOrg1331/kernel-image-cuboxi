Index: RH_2_6_9_55/fs/fs-writeback.c
===================================================================
--- RH_2_6_9_55.orig/fs/fs-writeback.c
+++ RH_2_6_9_55/fs/fs-writeback.c
@@ -230,7 +230,6 @@
 			 * The inode is clean, unused
 			 */
 			list_move(&inode->i_list, &inode_unused);
-			inodes_stat.nr_unused++;
 		}
 	}
 	wake_up_inode(inode);
@@ -244,6 +243,11 @@
 __writeback_single_inode(struct inode *inode,
 			struct writeback_control *wbc)
 {
+	if (!atomic_read(&inode->i_count))
+		WARN_ON(!(inode->i_state & I_WILL_FREE));
+	else
+		WARN_ON(inode->i_state & I_WILL_FREE);
+
 	if ((wbc->sync_mode != WB_SYNC_ALL) && (inode->i_state & I_LOCK)) {
 		list_move(&inode->i_list, &inode->i_sb->s_dirty);
 		return 0;
@@ -253,10 +257,8 @@
 	 * It's a data-integrity sync.  We must wait.
 	 */
 	while (inode->i_state & I_LOCK) {
-		__iget(inode);
 		spin_unlock(&inode_lock);
 		__wait_on_inode(inode);
-		iput(inode);
 		spin_lock(&inode_lock);
 	}
 	return __sync_single_inode(inode, wbc);
Index: RH_2_6_9_55/fs/inode.c
===================================================================
--- RH_2_6_9_55.orig/fs/inode.c
+++ RH_2_6_9_55/fs/inode.c
@@ -1056,6 +1056,7 @@
 	if (inode->i_data.nrpages)
 		truncate_inode_pages(&inode->i_data, 0);
 	clear_inode(inode);
+	wake_up_inode(inode);	
 	destroy_inode(inode);
 }
 
