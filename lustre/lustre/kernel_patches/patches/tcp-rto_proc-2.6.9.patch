Index: linux+rhel4+chaos/include/linux/sysctl.h
===================================================================
--- linux+rhel4+chaos.orig/include/linux/sysctl.h
+++ linux+rhel4+chaos/include/linux/sysctl.h
@@ -348,6 +348,8 @@ enum
 	NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR=109,
 	NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS=110,
 	NET_TCP_SLOW_START_AFTER_IDLE=111,
+	NET_TCP_RTO_MAX=112,
+	NET_TCP_RTO_INIT=113,
 };
 
 enum {
Index: linux+rhel4+chaos/net/ipv4/sysctl_net_ipv4.c
===================================================================
--- linux+rhel4+chaos.orig/net/ipv4/sysctl_net_ipv4.c
+++ linux+rhel4+chaos/net/ipv4/sysctl_net_ipv4.c
@@ -49,6 +49,10 @@ extern int inet_peer_maxttl;
 extern int inet_peer_gc_mintime;
 extern int inet_peer_gc_maxtime;
 
+/* From tcp_timer.c */
+extern unsigned sysctl_tcp_rto_max;
+extern unsigned sysctl_tcp_rto_init;
+
 #ifdef CONFIG_SYSCTL
 static int tcp_retr1_max = 255; 
 static int ip_local_port_range_min[] = { 1, 1 };
@@ -699,6 +703,22 @@ ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+	{
+		.ctl_name	= NET_TCP_RTO_MAX,
+		.procname	= "tcp_rto_max",
+		.data		= &sysctl_tcp_rto_max,
+		.maxlen		= sizeof(unsigned),
+		.mode		= 0644, 
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= NET_TCP_RTO_INIT,
+		.procname	= "tcp_rto_init",
+		.data		= &sysctl_tcp_rto_init,
+		.maxlen		= sizeof(unsigned), 
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
 	{ .ctl_name = 0 }
 };
 
Index: linux+rhel4+chaos/net/ipv4/tcp_timer.c
===================================================================
--- linux+rhel4+chaos.orig/net/ipv4/tcp_timer.c
+++ linux+rhel4+chaos/net/ipv4/tcp_timer.c
@@ -32,6 +32,9 @@ int sysctl_tcp_retries1 = TCP_RETR1;
 int sysctl_tcp_retries2 = TCP_RETR2;
 int sysctl_tcp_orphan_retries;
 
+unsigned sysctl_tcp_rto_max        = TCP_RTO_MAX;
+unsigned sysctl_tcp_rto_init       = TCP_TIMEOUT_INIT;
+
 static void tcp_write_timer(unsigned long);
 static void tcp_delack_timer(unsigned long);
 static void tcp_keepalive_timer (unsigned long data);
@@ -104,7 +107,7 @@ static int tcp_out_of_resources(struct s
 
 	/* If peer does not open window for long time, or did not transmit 
 	 * anything for long time, penalize it. */
-	if ((s32)(tcp_time_stamp - tp->lsndtime) > 2*TCP_RTO_MAX || !do_reset)
+	if ((s32)(tcp_time_stamp - tp->lsndtime) > 2*sysctl_tcp_rto_max || !do_reset)
 		orphans <<= 1;
 
 	/* If some dubious ICMP arrived, penalize even more. */
@@ -186,7 +189,7 @@ static int tcp_write_timeout(struct sock
 
 		retry_until = sysctl_tcp_retries2;
 		if (sock_flag(sk, SOCK_DEAD)) {
-			int alive = (tp->rto < TCP_RTO_MAX);
+			int alive = (tp->rto < sysctl_tcp_rto_max);
  
 			retry_until = tcp_orphan_retries(sk, alive);
 
@@ -292,7 +295,7 @@ static void tcp_probe_timer(struct sock 
 	max_probes = sysctl_tcp_retries2;
 
 	if (sock_flag(sk, SOCK_DEAD)) {
-		int alive = ((tp->rto<<tp->backoff) < TCP_RTO_MAX);
+		int alive = ((tp->rto<<tp->backoff) < sysctl_tcp_rto_max);
  
 		max_probes = tcp_orphan_retries(sk, alive);
 
@@ -336,7 +339,7 @@ static void tcp_retransmit_timer(struct 
 			       inet->num, tp->snd_una, tp->snd_nxt);
 		}
 #endif
-		if (tcp_time_stamp - tp->rcv_tstamp > TCP_RTO_MAX) {
+		if (tcp_time_stamp - tp->rcv_tstamp > sysctl_tcp_rto_max) {
 			tcp_write_err(sk);
 			goto out;
 		}
@@ -405,7 +408,7 @@ static void tcp_retransmit_timer(struct 
 	tp->retransmits++;
 
 out_reset_timer:
-	tp->rto = min(tp->rto << 1, TCP_RTO_MAX);
+	tp->rto = min(tp->rto << 1, sysctl_tcp_rto_max);
 	tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp->rto);
 	if (tp->retransmits > sysctl_tcp_retries1)
 		__sk_dst_reset(sk);
@@ -502,7 +505,7 @@ static void tcp_synack_timer(struct sock
 	if (tp->defer_accept)
 		max_retries = tp->defer_accept;
 
-	budget = 2*(TCP_SYNQ_HSIZE/(TCP_TIMEOUT_INIT/TCP_SYNQ_INTERVAL));
+	budget = 2*(TCP_SYNQ_HSIZE/(sysctl_tcp_rto_init/TCP_SYNQ_INTERVAL));
 	i = lopt->clock_hand;
 
 	do {
@@ -516,8 +519,8 @@ static void tcp_synack_timer(struct sock
 
 					if (req->retrans++ == 0)
 						lopt->qlen_young--;
-					timeo = min((TCP_TIMEOUT_INIT << req->retrans),
-						    TCP_RTO_MAX);
+					timeo = min((sysctl_tcp_rto_init << req->retrans),
+						    sysctl_tcp_rto_max);
 					req->expires = now + timeo;
 					reqp = &req->dl_next;
 					continue;
