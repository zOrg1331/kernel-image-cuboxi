Index: linux-2.6.9-full/include/linux/ext3_extents.h
===================================================================
--- linux-2.6.9-full.orig/include/linux/ext3_extents.h	2007-03-23 15:57:00.000000000 +0300
+++ linux-2.6.9-full/include/linux/ext3_extents.h	2007-03-26 22:08:16.000000000 +0400
@@ -242,6 +242,8 @@ struct ext3_extent_tree_stats {
 	int leaf_num;
 };
 
+extern int ext3_ext_search_left(struct ext3_extents_tree *, struct ext3_ext_path *, unsigned long *, unsigned long *);
+extern int ext3_ext_search_right(struct ext3_extents_tree *, struct ext3_ext_path *, unsigned long *, unsigned long *);
 extern void ext3_init_tree_desc(struct ext3_extents_tree *, struct inode *);
 extern int ext3_extent_tree_init(handle_t *, struct ext3_extents_tree *);
 extern int ext3_ext_calc_credits_for_insert(struct ext3_extents_tree *, struct ext3_ext_path *);
Index: linux-2.6.9-full/fs/ext3/extents.c
===================================================================
--- linux-2.6.9-full.orig/fs/ext3/extents.c	2007-03-23 15:57:00.000000000 +0300
+++ linux-2.6.9-full/fs/ext3/extents.c	2007-03-26 22:07:37.000000000 +0400
@@ -929,6 +929,150 @@ repeat:
 }
 
 /*
+ * search the closest allocated block to the left for *logical
+ * and returns it at @logical + it's physical address at @phys
+ * if *logical is the smallest allocated block, the function
+ * returns 0 at @phys
+ * return value contains 0 (success) or error code
+ */
+int
+ext3_ext_search_left(struct ext3_extents_tree *tree, struct ext3_ext_path *path,
+			unsigned long *logical, unsigned long *phys)
+{
+	struct ext3_extent_idx *ix;
+	struct ext3_extent *ex;
+	int depth;
+
+	BUG_ON(path == NULL);
+	depth = path->p_depth;
+	*phys = 0;
+
+	if (depth == 0 && path->p_ext == NULL)
+		return 0;
+
+	/* usually extent in the path covers blocks smaller
+	 * then *logical, but it can be that extent is the
+	 * first one in the file */
+
+	ex = path[depth].p_ext;
+	if (*logical < ex->ee_block) {
+		BUG_ON(EXT_FIRST_EXTENT(path[depth].p_hdr) != ex);
+		while (--depth >= 0) {
+			ix = path[depth].p_idx;
+			BUG_ON(ix != EXT_FIRST_INDEX(path[depth].p_hdr));
+		}
+		return 0;
+	}
+
+	BUG_ON(*logical < ex->ee_block + ex->ee_len);
+
+	*logical = ex->ee_block + ex->ee_len - 1;
+	*phys = ex->ee_start + ex->ee_len - 1;
+	return 0;
+}
+EXPORT_SYMBOL(ext3_ext_search_left);
+
+/*
+ * search the closest allocated block to the right for *logical
+ * and returns it at @logical + it's physical address at @phys
+ * if *logical is the smallest allocated block, the function
+ * returns 0 at @phys
+ * return value contains 0 (success) or error code
+ */
+int
+ext3_ext_search_right(struct ext3_extents_tree *tree, struct ext3_ext_path *path,
+			unsigned long *logical, unsigned long *phys)
+{
+	struct buffer_head *bh = NULL;
+	struct ext3_extent_header *eh;
+	struct ext3_extent_idx *ix;
+	struct ext3_extent *ex;
+	unsigned long block;
+	int depth;
+
+	BUG_ON(path == NULL);
+	depth = path->p_depth;
+	*phys = 0;
+
+	if (depth == 0 && path->p_ext == NULL)
+		return 0;
+
+	/* usually extent in the path covers blocks smaller
+	 * then *logical, but it can be that extent is the
+	 * first one in the file */
+
+	ex = path[depth].p_ext;
+	if (*logical < ex->ee_block) {
+		BUG_ON(EXT_FIRST_EXTENT(path[depth].p_hdr) != ex);
+		while (--depth >= 0) {
+			ix = path[depth].p_idx;
+			BUG_ON(ix != EXT_FIRST_INDEX(path[depth].p_hdr));
+		}
+		*logical = ex->ee_block;
+		*phys = ex->ee_start;
+		return 0;
+	}
+
+	BUG_ON(*logical < ex->ee_block + ex->ee_len);
+
+	if (ex != EXT_LAST_EXTENT(path[depth].p_hdr)) {
+		/* next allocated block in this leaf */
+		ex++;
+		*logical = ex->ee_block;
+		*phys = ex->ee_start;
+		return 0;
+	}
+
+	/* go up and search for index to the right */
+	while (--depth >= 0) {
+		ix = path[depth].p_idx;
+		if (ix != EXT_LAST_INDEX(path[depth].p_hdr))
+			break;
+	}
+
+	if (depth < 0) {
+		/* we've gone up to the root and
+		 * found no index to the right */
+		return 0;
+	}
+
+	/* we've found index to the right, let's
+	 * follow it and find the closest allocated
+	 * block to the right */
+	ix++;
+	block = ix->ei_leaf;
+	while (++depth < path->p_depth) {
+		bh = sb_bread(tree->inode->i_sb, block);
+		if (bh == NULL)
+			return -EIO;
+		eh = EXT_BLOCK_HDR(bh);
+		if (ext3_ext_check_header(eh)) {
+			brelse(bh);
+			return -EIO;
+		}
+		ix = EXT_FIRST_INDEX(eh);
+		block = ix->ei_leaf;
+		brelse(bh);
+	}
+
+	bh = sb_bread(tree->inode->i_sb, block);
+	if (bh == NULL)
+		return -EIO;
+	eh = EXT_BLOCK_HDR(bh);
+	if (ext3_ext_check_header(eh)) {
+		brelse(bh);
+		return -EIO;
+	}
+	ex = EXT_FIRST_EXTENT(eh);
+	*logical = ex->ee_block;
+	*phys = ex->ee_start;
+	brelse(bh);
+	return 0;
+
+}
+EXPORT_SYMBOL(ext3_ext_search_right);
+
+/*
  * returns allocated block in subsequent extent or EXT_MAX_BLOCK
  * NOTE: it consider block number from index entry as
  * allocated block. thus, index entries have to be consistent
