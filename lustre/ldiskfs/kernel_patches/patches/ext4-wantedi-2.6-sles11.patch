Index: linux-stage/fs/ext4/ialloc.c
===================================================================
--- linux-stage.orig/fs/ext4/ialloc.c
+++ linux-stage/fs/ext4/ialloc.c
@@ -675,7 +675,8 @@ err_ret:
  * For other inodes, search forward from the parent directory's block
  * group to find a free inode.
  */
-struct inode *ext4_new_inode(handle_t *handle, struct inode *dir, int mode)
+struct inode *ext4_new_inode(handle_t *handle, struct inode *dir, int mode,
+			     unsigned long goal)
 {
 	struct super_block *sb;
 	struct buffer_head *inode_bitmap_bh = NULL;
@@ -706,6 +707,51 @@ struct inode *ext4_new_inode(handle_t *h
 	sbi = EXT4_SB(sb);
 	es = sbi->s_es;
 
+	if (goal) {
+		group = (goal - 1) / EXT4_INODES_PER_GROUP(sb);
+		ino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);
+		err = -EIO;
+
+		gdp = ext4_get_group_desc(sb, group, &group_desc_bh);
+		if (!gdp)
+			goto fail;
+
+		inode_bitmap_bh = ext4_read_inode_bitmap(sb, group);
+		if (!inode_bitmap_bh)
+			goto fail;
+
+		BUFFER_TRACE(bh, "get_write_access");
+		err = ext4_journal_get_write_access(handle, inode_bitmap_bh);
+		if (err)
+			goto fail;
+
+		BUFFER_TRACE(group_desc_bh, "get_write_access");
+		err = ext4_journal_get_write_access(handle, group_desc_bh);
+		if (err)
+			goto fail;
+
+		err = ext4_claim_inode(sb, inode_bitmap_bh, ino, group, mode);
+		if (err) {
+			printk(KERN_ERR "goal inode %lu unavailable\n", goal);
+			/* Oh well, we tried. */
+			jbd2_journal_release_buffer(handle, inode_bitmap_bh);
+			jbd2_journal_release_buffer(handle, group_desc_bh);
+			goto continue_allocation;
+		}
+
+		/* we won it */
+		BUFFER_TRACE(inode_bitmap_bh,
+			     "call ext4_journal_dirty_metadata");
+		err = ext4_journal_dirty_metadata(handle, inode_bitmap_bh);
+		if (err)
+			goto fail;
+
+		/* zero bit is inode number 1*/
+		ino++;
+		goto got;
+	}
+
+continue_allocation:
 	if (sbi->s_log_groups_per_flex) {
 		ret2 = find_group_flex(sb, dir, &group);
 		goto got_group;
Index: linux-stage/fs/ext4/namei.c
===================================================================
--- linux-stage.orig/fs/ext4/namei.c
+++ linux-stage/fs/ext4/namei.c
@@ -104,6 +104,7 @@ struct dx_entry
 	__le32 block;
 };
 
+
 /*
  * dx_root_info is laid out so that if it should somehow get overlaid by a
  * dirent the two low bits of the hash version will be zero.  Therefore, the
@@ -149,6 +150,14 @@ struct dx_map_entry
 	u16 size;
 };
 
+#define LVFS_DENTRY_PARAM_MAGIC		20070216UL
+struct lvfs_dentry_params
+{
+	unsigned long   p_inum;
+	void	    *p_ptr;
+	u32	     magic;
+};
+
 static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);
 static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);
 static inline unsigned dx_get_hash(struct dx_entry *entry);
@@ -1716,6 +1725,20 @@ static int ext4_add_nondir(handle_t *han
 	return err;
 }
 
+static struct inode * ext4_new_inode_wantedi(handle_t *handle, struct inode *dir,
+						int mode, struct dentry *dentry)
+{
+	unsigned long inum = 0;
+
+	if (dentry->d_fsdata != NULL) {
+		struct lvfs_dentry_params *param = dentry->d_fsdata;
+
+		if (param->magic == LVFS_DENTRY_PARAM_MAGIC)
+			inum = param->p_inum;
+	}
+	return ext4_new_inode(handle, dir, mode, inum);
+}
+
 /*
  * By the time this is called, we already have created
  * the directory cache entry for the new file, but it
@@ -1741,7 +1764,7 @@ retry:
 	if (IS_DIRSYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext4_new_inode (handle, dir, mode);
+	inode = ext4_new_inode_wantedi(handle, dir, mode, dentry);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		inode->i_op = &ext4_file_inode_operations;
@@ -1775,7 +1798,7 @@ retry:
 	if (IS_DIRSYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext4_new_inode(handle, dir, mode);
+	inode = ext4_new_inode_wantedi(handle, dir, mode, dentry);
 	err = PTR_ERR(inode);
 	if (!IS_ERR(inode)) {
 		init_special_inode(inode, inode->i_mode, rdev);
@@ -1811,7 +1834,7 @@ retry:
 	if (IS_DIRSYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext4_new_inode(handle, dir, S_IFDIR | mode);
+	inode = ext4_new_inode_wantedi(handle, dir, S_IFDIR | mode, dentry);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
@@ -2211,7 +2234,7 @@ retry:
 	if (IS_DIRSYNC(dir))
 		handle->h_sync = 1;
 
-	inode = ext4_new_inode(handle, dir, S_IFLNK|S_IRWXUGO);
+	inode = ext4_new_inode_wantedi(handle, dir, S_IFLNK|S_IRWXUGO, dentry);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_stop;
Index: linux-stage/fs/ext4/ext4.h
===================================================================
--- linux-stage.orig/fs/ext4/ext4.h
+++ linux-stage/fs/ext4/ext4.h
@@ -1032,7 +1032,8 @@ extern int ext4fs_dirhash(const char *na
 			  dx_hash_info *hinfo);
 
 /* ialloc.c */
-extern struct inode * ext4_new_inode(handle_t *, struct inode *, int);
+extern struct inode * ext4_new_inode(handle_t *, struct inode *, int,
+				     unsigned long);
 extern void ext4_free_inode(handle_t *, struct inode *);
 extern struct inode * ext4_orphan_get(struct super_block *, unsigned long);
 extern unsigned long ext4_count_free_inodes(struct super_block *);
Index: linux-stage/fs/ext4/migrate.c
===================================================================
--- linux-stage.orig/fs/ext4/migrate.c
+++ linux-stage/fs/ext4/migrate.c
@@ -484,7 +484,7 @@ int ext4_ext_migrate(struct inode *inode
 	}
 	tmp_inode = ext4_new_inode(handle,
 				inode->i_sb->s_root->d_inode,
-				S_IFREG);
+				S_IFREG, 0);
 	if (IS_ERR(tmp_inode)) {
 		retval = -ENOMEM;
 		ext4_journal_stop(handle);
