Index: linux-2.6.5-7.312/fs/ext3/super.c
===================================================================
--- linux-2.6.5-7.312.orig/fs/ext3/super.c
+++ linux-2.6.5-7.312/fs/ext3/super.c
@@ -1298,6 +1298,34 @@ static int ext3_max_dir_size_write(struc
 	return count;
 }
 
+/*
+ * ext3_get_stripe_size: Get the stripe size.
+ * @sbi: In memory super block info
+ *
+ * If we have specified it via mount option, then
+ * use the mount option value. If the value specified at mount time is
+ * greater than the blocks per group use the super block value.
+ * If the super block value is greater than blocks per group return 0.
+ * Allocator needs it be less than blocks per group.
+ */
+static unsigned long ext3_get_stripe_size(struct ext3_sb_info *sbi)
+{
+	unsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);
+	unsigned long stripe_width =
+			le32_to_cpu(sbi->s_es->s_raid_stripe_width);
+
+	if (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)
+		return sbi->s_stripe;
+
+	if (stripe_width <= sbi->s_blocks_per_group)
+		return stripe_width;
+
+	if (stride <= sbi->s_blocks_per_group)
+		return stride;
+
+	return 0;
+}
+
 static int ext3_fill_super (struct super_block *sb, void *data, int silent)
 {
 	struct buffer_head * bh;
@@ -1618,6 +1646,8 @@ static int ext3_fill_super (struct super
 	atomic_set(&sbi->s_rsv_window_head.rsv_goal_size, 0);
 	rsv_window_add(sb, &sbi->s_rsv_window_head);
 
+        sbi->s_stripe = ext3_get_stripe_size(sbi);
+
 	/*
 	 * set up enough so that it can read an inode
 	 */
Index: linux-2.6.5-7.312/include/linux/ext3_fs.h
===================================================================
--- linux-2.6.5-7.312.orig/include/linux/ext3_fs.h
+++ linux-2.6.5-7.312/include/linux/ext3_fs.h
@@ -505,8 +505,12 @@ struct ext3_super_block {
 	__u32	s_free_blocks_hi;	/* Free blocks count high 32 bits */
 	__u16	s_min_extra_isize;	/* All inodes have at least # bytes */
 	__u16	s_want_extra_isize;	/* New inodes should reserve # bytes */
-	__u32	s_flags;		/* Miscellaneous flags */
-	__u32	s_reserved[167];	/* Padding to the end of the block */
+/*160*/ __le32  s_flags;		/* Miscellaneous flags */
+	__le16  s_raid_stride;		/* RAID stride */
+	__le16  s_mmp_update_interval;  /* # seconds to wait in MMP checking */
+	__le64  s_mmp_block;		/* Block for multi-mount protection */
+/*170*/ __le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/
+	__le32  s_reserved[163];	/* Padding to the end of the block */
 };
 
 #ifdef __KERNEL__
