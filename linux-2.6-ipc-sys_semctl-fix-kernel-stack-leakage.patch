From: Danny Feng <dfeng@redhat.com>
Date: Fri, 12 Nov 2010 09:53:45 -0500
Subject: [ipc] sys_semctl: fix kernel stack leakage
Message-id: <20101112095345.23651.17710.sendpatchset@danny.redhat>
Patchwork-id: 29205
O-Subject: [PATCH RHEL5.6] sys_semctl: fix kernel stack leakage
Bugzilla: 648722
CVE: CVE-2010-4083
RH-Acked-by: Amerigo Wang <amwang@redhat.com>
RH-Acked-by: Dean Nelson <dnelson@redhat.com>
RH-Acked-by: Jiri Pirko <jpirko@redhat.com>

Backport of:

commit 982f7c2b2e6a28f8f266e075d92e19c0dd4c6e56
Author: Dan Rosenberg <drosenberg@vsecurity.com>
Date:   Thu Sep 30 15:15:31 2010 -0700

    sys_semctl: fix kernel stack leakage

    The semctl syscall has several code paths that lead to the leakage of
    uninitialized kernel stack memory (namely the IPC_INFO, SEM_INFO,
    IPC_STAT, and SEM_STAT commands) during the use of the older, obsolete
    version of the semid_ds struct.

    The copy_semid_to_user() function declares a semid_ds struct on the stack
    and copies it back to the user without initializing or zeroing the
    "sem_base", "sem_pending", "sem_pending_last", and "undo" pointers,
    allowing the leakage of 16 bytes of kernel stack memory.

    The code is still reachable on 32-bit systems - when calling semctl()
    newer glibc's automatically OR the IPC command with the IPC_64 flag, but
    invoking the syscall directly allows users to use the older versions of
    the struct.

    Signed-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Fixes bz648722
Aka CVE-2010-4083

diff --git a/ipc/sem.c b/ipc/sem.c
index 6013c75..c6a8329 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -490,6 +490,8 @@ static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in,
 	    {
 		struct semid_ds out;
 
+		memset(&out, 0, sizeof(out));
+
 		ipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);
 
 		out.sem_otime	= in->sem_otime;
