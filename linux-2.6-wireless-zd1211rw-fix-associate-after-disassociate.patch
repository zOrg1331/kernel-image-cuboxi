From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Mon, 22 Nov 2010 14:24:03 -0500
Subject: [wireless] zd1211rw: fix associate after disassociate
Message-id: <1290435844-5282-1-git-send-email-sgruszka@redhat.com>
Patchwork-id: 29537
O-Subject: [RHEL5.6 PATCH 1/2] zd1211rw: fix associate after disassociate
Bugzilla: 644367
RH-Acked-by: John Linville <linville@redhat.com>
RH-Acked-by: Ivan Vecera <ivecera@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

BZ#644367

Description:
zd1211rw driver fail to associate with "error ioread32(CR_REG1): -11"
in dmesg. Usually first try to associate is successful, second try, after
disassociate usually fail. Patch include various fixes to improve that
situation:
- reset device every time it is opened
- fix netdev queue being stooped forever after down device
- allow to set channel when device is not up

Upstream:
N/A, zd1211rw driver was ported to mac80211 and does not have this
problems.

Testing:
Tested by my with two different ZyDAS devices.

diff --git a/drivers/net/wireless/zd1211rw/zd_mac.c b/drivers/net/wireless/zd1211rw/zd_mac.c
index dbb07f7..d62340c 100644
--- a/drivers/net/wireless/zd1211rw/zd_mac.c
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c
@@ -193,11 +193,9 @@ int zd_mac_open(struct net_device *netdev)
 	struct zd_usb *usb = &chip->usb;
 	int r;
 
-	if (!usb->initialized) {
-		r = zd_usb_init_hw(usb);
-		if (r)
-			goto out;
-	}
+	r = zd_usb_init_hw(usb);
+	if (r)
+		goto out;
 
 	tasklet_enable(&mac->rx_tasklet);
 
@@ -236,6 +234,7 @@ int zd_mac_open(struct net_device *netdev)
 
 	housekeeping_enable(mac);
 	ieee80211softmac_start(netdev);
+	netif_start_queue(netdev);
 	return 0;
 disable_rx:
 	zd_chip_disable_rx(chip);
@@ -268,7 +267,7 @@ int zd_mac_stop(struct net_device *netdev)
 
 	zd_chip_disable_hwint(chip);
 	zd_chip_switch_radio_off(chip);
-	zd_chip_disable_int(chip);
+	/* Keep usb interrupts enabled to allow to set channel */
 
 	return 0;
 }
@@ -390,10 +389,6 @@ static void set_channel(struct net_device *netdev, u8 channel)
 int zd_mac_request_channel(struct zd_mac *mac, u8 channel)
 {
 	unsigned long lock_flags;
-	struct ieee80211_device *ieee = zd_mac_to_ieee80211(mac);
-
-	if (ieee->iw_mode == IW_MODE_INFRA)
-		return -EPERM;
 
 	spin_lock_irqsave(&mac->lock, lock_flags);
 	if (!zd_regdomain_supports_channel(mac->regdomain, channel)) {
diff --git a/drivers/net/wireless/zd1211rw/zd_usb.c b/drivers/net/wireless/zd1211rw/zd_usb.c
index ca4cebd..d00b9eb 100644
--- a/drivers/net/wireless/zd1211rw/zd_usb.c
+++ b/drivers/net/wireless/zd1211rw/zd_usb.c
@@ -959,6 +959,8 @@ int zd_usb_init_hw(struct zd_usb *usb)
 
 	dev_dbg_f(zd_usb_dev(usb), "\n");
 
+	usb_reset_device(zd_usb_to_usbdev(usb));
+
 	r = upload_firmware(usb);
 	if (r) {
 		dev_err(zd_usb_dev(usb),
