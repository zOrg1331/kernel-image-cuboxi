diff -uprN old/fs/gfs/gfs.h new/fs/gfs/gfs.h
--- old/fs/gfs/gfs.h	2009-10-12 19:44:55.000000000 +0400
+++ new/fs/gfs/gfs.h	2009-10-12 19:45:28.000000000 +0400
@@ -14,7 +14,7 @@
 #ifndef __GFS_DOT_H__
 #define __GFS_DOT_H__
 
-#define GFS_RELEASE_NAME "0.1.31-3"
+#define GFS_RELEASE_NAME "0.1.34-2"
 
 #include "lm_interface.h"
 
diff -uprN old/fs/gfs/inode.c new/fs/gfs/inode.c
--- old/fs/gfs/inode.c	2008-11-12 00:33:00.000000000 +0300
+++ new/fs/gfs/inode.c	2009-07-23 20:36:54.000000000 +0400
@@ -193,10 +193,17 @@ gfs_iget(struct gfs_inode *ip, int creat
 		memcpy(&ip->gfs_file_aops, &gfs_file_aops,
 			   sizeof(struct address_space_operations));
 		tmp->i_mapping->a_ops = &ip->gfs_file_aops;
-		if (sdp->sd_args.ar_localflocks)
-			tmp->i_fop = &gfs_file_fops_nolock;
-		else
-			tmp->i_fop = &gfs_file_fops;
+		if (sdp->sd_args.ar_localflocks) {
+			if (gfs_is_jdata(ip))
+				tmp->i_fop = &gfs_file_fops_nolock_jdata;
+			else
+				tmp->i_fop = &gfs_file_fops_nolock;
+		} else {
+			if (gfs_is_jdata(ip))
+				tmp->i_fop = &gfs_file_fops_jdata;
+			else
+				tmp->i_fop = &gfs_file_fops;
+		}
 	} else if (ip->i_di.di_type == GFS_FILE_DIR) {
 		tmp->i_op = &gfs_dir_iops;
 		if (sdp->sd_args.ar_localflocks)
diff -uprN old/fs/gfs/ioctl.c new/fs/gfs/ioctl.c
--- old/fs/gfs/ioctl.c	2008-11-12 00:33:00.000000000 +0300
+++ new/fs/gfs/ioctl.c	2009-07-23 20:36:53.000000000 +0400
@@ -20,6 +20,7 @@
 #include <linux/buffer_head.h>
 #include <asm/uaccess.h>
 #include <linux/compat.h>
+#include <linux/vmalloc.h>
 
 #include "gfs_ioctl.h"
 #include "gfs.h"
@@ -67,7 +68,7 @@ gi_skeleton(struct gfs_inode *ip, struct
 	if (size > gi->gi_size)
 		size = gi->gi_size;
 
-        buf = kmalloc(size, GFP_KERNEL);
+        buf = vmalloc(size);
         if (!buf)
                 return -ENOMEM;
 
@@ -81,7 +82,7 @@ gi_skeleton(struct gfs_inode *ip, struct
 		error = count + 1;
 
  out:
-	kfree(buf);
+	vfree(buf);
 
 	return error;
 }
diff -uprN old/fs/gfs/ops_file.c new/fs/gfs/ops_file.c
--- old/fs/gfs/ops_file.c	2008-11-12 00:33:00.000000000 +0300
+++ new/fs/gfs/ops_file.c	2009-07-23 20:36:53.000000000 +0400
@@ -284,6 +284,37 @@ do_read_readi(struct file *file, char *b
 }
 
 /**
+ * grope_mapping - feel up a mapping that needs to be written
+ * @buf: the start of the memory to be written
+ * @size: the size of the memory to be written
+ *
+ * We do this after acquiring the locks on the mapping,
+ * but before starting the write transaction.  We need to make
+ * sure that we don't cause recursive transactions if blocks
+ * need to be allocated to the file backing the mapping.
+ *
+ * Returns: errno
+ */
+
+static int
+grope_mapping(char *buf, size_t size)
+{
+	unsigned long start = (unsigned long)buf;
+	unsigned long stop = start + size;
+	char c;
+
+	while (start < stop) {
+		if (copy_from_user(&c, (char *)start, 1))
+			return -EFAULT;
+
+		start += PAGE_CACHE_SIZE;
+		start &= PAGE_CACHE_MASK;
+	}
+
+	return 0;
+}
+
+/**
  * do_read_direct - Read bytes from a file
  * @file: The file to read from
  * @buf: The buffer to copy into
@@ -319,6 +350,12 @@ do_read_direct(struct file *file, char *
 
 	gfs_holder_init(ip->i_gl, state, flags, &ghs[num_gh]);
 
+	if (num_gh && atomic_read(&current->mm->mm_users) > 1) {
+		error = grope_mapping(buf, size);
+		if (error)
+			goto out;
+	}
+
 	error = gfs_glock_nq_m(num_gh + 1, ghs);
 	if (error)
 		goto out;
@@ -380,6 +417,12 @@ do_read_buf(struct file *file, char *buf
 
 	gfs_holder_init(ip->i_gl, LM_ST_SHARED, GL_ATIME, &ghs[num_gh]);
 
+	if (num_gh && atomic_read(&current->mm->mm_users) > 1) {
+		error = grope_mapping(buf, size);
+		if (error)
+			goto out;
+	}
+
 	error = gfs_glock_nq_m_atime(num_gh + 1, ghs);
 	if (error)
 		goto out;
@@ -454,37 +497,6 @@ gfs_aio_read(struct kiocb *iocb, char __
 }
 
 /**
- * grope_mapping - feel up a mapping that needs to be written
- * @buf: the start of the memory to be written
- * @size: the size of the memory to be written
- *
- * We do this after acquiring the locks on the mapping,
- * but before starting the write transaction.  We need to make
- * sure that we don't cause recursive transactions if blocks
- * need to be allocated to the file backing the mapping.
- *
- * Returns: errno
- */
-
-static int
-grope_mapping(char *buf, size_t size)
-{
-	unsigned long start = (unsigned long)buf;
-	unsigned long stop = start + size;
-	char c;
-
-	while (start < stop) {
-		if (copy_from_user(&c, (char *)start, 1))
-			return -EFAULT;
-
-		start += PAGE_CACHE_SIZE;
-		start &= PAGE_CACHE_MASK;
-	}
-
-	return 0;
-}
-
-/**
  * do_write_direct_alloc - Write bytes to a file
  * @file: The file to write to
  * @buf: The buffer to copy from
@@ -656,6 +668,12 @@ do_write_direct(struct file *file, char 
  restart:
 	gfs_holder_init(ip->i_gl, state, 0, &ghs[num_gh]);
 
+	if (num_gh && atomic_read(&current->mm->mm_users) > 1) {
+		error = grope_mapping(buf, size);
+		if (error)
+			goto out;
+	}
+
 	error = gfs_glock_nq_m(num_gh + 1, ghs);
 	if (error)
 		goto out;
@@ -960,6 +978,12 @@ do_write_buf(struct file *file,
 
 	gfs_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ghs[num_gh]);
 
+	if (num_gh && atomic_read(&current->mm->mm_users) > 1) {
+		error = grope_mapping(buf, size);
+		if (error)
+			goto out;
+	}
+
 	error = gfs_glock_nq_m(num_gh + 1, ghs);
 	if (error)
 		goto out;
@@ -1597,6 +1621,8 @@ gfs_fsync(struct file *file, struct dent
 			};
 			error = sync_inode(inode, &wbc);
 		}
+		if (gfs_is_stuffed(ip))
+			gfs_log_flush_glock(ip->i_gl);
 	}
 
 	gfs_glock_dq_uninit(&i_gh);
@@ -1810,6 +1836,24 @@ struct file_operations gfs_file_fops = {
 	.flock = gfs_flock,
 };
 
+struct file_operations gfs_file_fops_jdata = {
+	.llseek = gfs_llseek,
+	.read = gfs_read,
+	.write = gfs_write,
+        .aio_read = gfs_aio_read,
+        .aio_write = gfs_aio_write,
+	.ioctl = gfs_ioctl,
+#ifdef CONFIG_COMPAT
+        .compat_ioctl   = gfs_compat_ioctl,
+#endif
+	.mmap = gfs_mmap,
+	.open = gfs_open,
+	.release = gfs_close,
+	.fsync = gfs_fsync,
+	.lock = gfs_lock,
+	.flock = gfs_flock,
+};
+
 struct file_operations gfs_dir_fops = {
 	.readdir = gfs_readdir,
 	.ioctl = gfs_ioctl,
@@ -1840,6 +1884,22 @@ struct file_operations gfs_file_fops_nol
 	.sendfile = gfs_sendfile,
 };
 
+struct file_operations gfs_file_fops_nolock_jdata = {
+	.llseek = gfs_llseek,
+	.read = gfs_read,
+	.write = gfs_write,
+        .aio_read = gfs_aio_read,
+        .aio_write = gfs_aio_write,
+	.ioctl = gfs_ioctl,
+#ifdef CONFIG_COMPAT
+        .compat_ioctl   = gfs_compat_ioctl,
+#endif
+	.mmap = gfs_mmap,
+	.open = gfs_open,
+	.release = gfs_close,
+	.fsync = gfs_fsync,
+};
+
 struct file_operations gfs_dir_fops_nolock = {
 	.readdir = gfs_readdir,
 	.ioctl = gfs_ioctl,
diff -uprN old/fs/gfs/ops_file.h new/fs/gfs/ops_file.h
--- old/fs/gfs/ops_file.h	2008-11-12 00:33:00.000000000 +0300
+++ new/fs/gfs/ops_file.h	2009-07-23 20:36:54.000000000 +0400
@@ -15,8 +15,10 @@
 #define __OPS_FILE_DOT_H__
 
 extern struct file_operations gfs_file_fops;
+extern struct file_operations gfs_file_fops_jdata;
 extern struct file_operations gfs_dir_fops;
 extern struct file_operations gfs_file_fops_nolock;
+extern struct file_operations gfs_file_fops_nolock_jdata;
 extern struct file_operations gfs_dir_fops_nolock;
 
 #endif /* __OPS_FILE_DOT_H__ */
