From: Milan Broz <mbroz@redhat.com>
Date: Mon, 25 Aug 2008 13:51:05 +0200
Subject: [md] dm: reject barrier requests
Message-id: 48B29CA9.8030007@redhat.com
O-Subject: [RHEL5.3 PATCH] dm: reject barrier requests (#458936)
Bugzilla: 458936
RH-Acked-by: Alasdair G Kergon <agk@redhat.com>

RHEL5.3 dm: write barriers not supported, ext3 does not complain
Resolves: rhbz#458936
Patch is upstream, commit 07a83c47cfc00ba5f0f090ccddd3a0703be0eec9

This patch causes device-mapper to reject any barrier requests.

Currently, only some targets rejects barrier requests.
Since barrier requests won't get to the targets with this patch,
the checks in targets can be removed.

Until device-mapper will support barriers natively, current code
cannot guarantee that barrier request is processed correctly.
Even if there is only one underlying physical device, mapping can
change during the online operation
(e.g. using LVM - pvmove, lvextend etc.)

Kernel with patch compiled and tested.

diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
index d5ce9ce..cddd5d4 100644
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -918,9 +918,6 @@ static int crypt_map(struct dm_target *ti, struct bio *bio,
 	struct crypt_config *cc = ti->private;
 	struct crypt_io *io;
 
-	if (bio_barrier(bio))
-		return -EOPNOTSUPP;
-
 	io = mempool_alloc(cc->io_pool, GFP_NOIO);
 	io->target = ti;
 	io->base_bio = bio;
diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 2412c5a..eadcb4a 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -821,9 +821,6 @@ static int multipath_map(struct dm_target *ti, struct bio *bio,
 	struct mpath_io *mpio;
 	struct multipath *m = (struct multipath *) ti->private;
 
-	if (bio_barrier(bio))
-		return -EOPNOTSUPP;
-
 	mpio = mempool_alloc(m->mpio_pool, GFP_NOIO);
 	dm_bio_record(&mpio->details, bio);
 
diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
index 959c9e5..1353540 100644
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@ -1031,9 +1031,6 @@ static int snapshot_map(struct dm_target *ti, struct bio *bio,
 	if (!s->valid)
 		return -EIO;
 
-	if (unlikely(bio_barrier(bio)))
-		return -EOPNOTSUPP;
-
 	/* FIXME: should only take write lock if we need
 	 * to copy an exception */
 	down_write(&s->lock);
@@ -1312,9 +1309,6 @@ static int origin_map(struct dm_target *ti, struct bio *bio,
 	struct dm_dev *dev = (struct dm_dev *) ti->private;
 	bio->bi_bdev = dev->bdev;
 
-	if (unlikely(bio_barrier(bio)))
-		return -EOPNOTSUPP;
-
 	/* Only tell snapshots if this is a write */
 	return (bio_rw(bio) == WRITE) ? do_origin(dev, bio) : 1;
 }
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index c4c7cc1..47b25b9 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -829,6 +829,15 @@ static int dm_request(request_queue_t *q, struct bio *bio)
 	int rw = bio_data_dir(bio);
 	struct mapped_device *md = q->queuedata;
 
+	/*
+	 * There is no use in forwarding any barrier request since we can't
+	 * guarantee it is (or can be) handled by the targets correctly.
+	 */
+	if (unlikely(bio_barrier(bio))) {
+		bio_endio(bio, bio->bi_size, -EOPNOTSUPP);
+		return 0;
+	}
+
 	down_read(&md->io_lock);
 
 	disk_stat_inc(dm_disk(md), ios[rw]);
