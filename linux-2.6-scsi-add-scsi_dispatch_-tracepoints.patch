From: Jiri Olsa <jolsa@redhat.com>
Date: Fri, 24 Sep 2010 11:35:22 -0400
Subject: [scsi] add scsi_dispatch_* tracepoints
Message-id: <1285328122-4380-1-git-send-email-jolsa@redhat.com>
Patchwork-id: 28361
O-Subject: [PATCH RHEL5] BZ 568290 - scsi: adding tracepoints
Bugzilla: 568290

Bugzilla: 568290
https://bugzilla.redhat.com/show_bug.cgi?id=568290
Bug 568290 - [Fujitsu 5.6 FEAT] scsi: tracing

Description:
============
SCSI tracing has been presented as one of the prerequisites
for a business deal by some big mission critical customer.
This helps us a lot to reduce the time of analysis on issues
the customer hits, and that minimizes the impact to their
businesses.  Also, in some cases, the customer won't immediately
let us use their systems to recreate the issue with a customized
kernel for debugging.  In that case, trace information is really
helpful to narrow down the area to focus on or to find out the
cause.

Upstream status:
================
- [SCSI] add scsi trace core functions and put trace points
  commit bf81623542332bc2cedf3db49cbb2edb724780d2
  Author: Kei Tokunaga <tokunaga.keiich@jp.fujitsu.com>

Brew:
=====
https://brewweb.devel.redhat.com/taskinfo?taskID=2738911

as per Comment 14 in BZ, there was minor change missing,
brewing the kernel at the moment...
https://brewweb.devel.redhat.com/taskinfo?taskID=2778825

Tested:
=======
tested by customer

wbr,
jirka

diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index f830672..a6c2deb 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -67,6 +67,8 @@
 #include "scsi_priv.h"
 #include "scsi_logging.h"
 
+#include <trace/scsi.h>
+
 static void scsi_done(struct scsi_cmnd *cmd);
 
 /*
@@ -554,10 +556,12 @@ int scsi_dispatch_cmd(struct scsi_cmnd *cmd)
 		cmd->result = (DID_NO_CONNECT << 16);
 		scsi_done(cmd);
 	} else {
+		trace_scsi_dispatch_cmd_start(cmd);
 		rtn = host->hostt->queuecommand(cmd, scsi_done);
 	}
 	spin_unlock_irqrestore(host->host_lock, flags);
 	if (rtn) {
+		trace_scsi_dispatch_cmd_error(cmd, rtn);
 		if (scsi_delete_timer(cmd)) {
 			atomic_inc(&cmd->device->iodone_cnt);
 			scsi_attempt_requeue_command(cmd,
@@ -642,6 +646,8 @@ void __scsi_done(struct scsi_cmnd *cmd)
 
 	BUG_ON(!rq);
 
+	trace_scsi_dispatch_cmd_done(cmd);
+
 	/*
 	 * The uptodate/nbytes values don't matter, as we allow partial
 	 * completes and thus will check this in the softirq callback
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 9563693..97f3d20 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -38,6 +38,8 @@
 #include "scsi_priv.h"
 #include "scsi_logging.h"
 
+#include <trace/scsi.h>
+
 #define SENSE_TIMEOUT		(10*HZ)
 
 /*
@@ -51,6 +53,7 @@
 void scsi_eh_wakeup(struct Scsi_Host *shost)
 {
 	if (shost->host_busy == shost->host_failed) {
+		trace_scsi_eh_wakeup(shost);
 		wake_up_process(shost->ehandler);
 		SCSI_LOG_ERROR_RECOVERY(5,
 				printk("Waking error handler thread\n"));
@@ -186,6 +189,7 @@ void scsi_times_out(struct scsi_cmnd *scmd)
 {
 	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
 
+	trace_scsi_dispatch_cmd_timeout(scmd);
 	scsi_log_completion(scmd, TIMEOUT_ERROR);
 
 	if (scmd->device->host->transportt->eh_timed_out)
diff --git a/include/trace/scsi.h b/include/trace/scsi.h
new file mode 100644
index 0000000..69aa2ea
--- /dev/null
+++ b/include/trace/scsi.h
@@ -0,0 +1,29 @@
+
+#ifndef _TRACE_SCSI_H
+#define _TRACE_SCSI_H
+
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_host.h>
+#include <linux/tracepoint.h>
+
+DEFINE_TRACE(scsi_dispatch_cmd_start,
+	TPPROTO(struct scsi_cmnd *cmd),
+	TPARGS(cmd));
+
+DEFINE_TRACE(scsi_dispatch_cmd_error,
+	TPPROTO(struct scsi_cmnd *cmd, int rtn),
+	TPARGS(cmd, rtn));
+
+DEFINE_TRACE(scsi_dispatch_cmd_done,
+	TPPROTO(struct scsi_cmnd *cmd),
+	TPARGS(cmd));
+
+DEFINE_TRACE(scsi_dispatch_cmd_timeout,
+	TPPROTO(struct scsi_cmnd *cmd),
+	TPARGS(cmd));
+
+DEFINE_TRACE(scsi_eh_wakeup,
+	TPPROTO(struct Scsi_Host *shost),
+	TPARGS(shost));
+
+#endif /*  _TRACE_SCSI_H */
