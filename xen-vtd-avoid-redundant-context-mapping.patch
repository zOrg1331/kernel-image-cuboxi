From: ddugger@redhat.com <ddugger@redhat.com>
Date: Mon, 23 Mar 2009 10:23:14 -0600
Subject: [xen] vtd: avoid redundant context mapping
Message-id: 200903231623.n2NGNEIZ022084@sobek.n0ano.com
O-Subject: [RHEL5.4 PATCH 10/21 V2] vtd: avoid redundant context mapping
Bugzilla: 484227
RH-Acked-by: Chris Lalancette <clalance@redhat.com>
RH-Acked-by: Gerd Hoffmann <kraxel@redhat.com>
RH-Acked-by: Chris Lalancette <clalance@redhat.com>

In case DEV_TYPE_PCI in domain_context_mapping(), redundant context
mapping may occur for some devices.

For example, the NIC is 03:00.0, and its parent bridge is: 00:1e.0.
After domain_context_mapping_one() 03:00.0 and 00:1e.0, the
'secbus' is 3 and 'bus' is 0, so will domain_context_mapping_one()
03:00.0 again -- this redundant invocation returns -EINVAL because
we have created the mapping but haven't changed pdev->domain from
Dom0 to a new domain at this time and eventually the
XEN_DOMCTL_assign_device hypercall returns a failure.

This patch detects this case and avoids the redundant invocation.

Upstream Status: Accepted (CS 18964)

BZ: 484227

Signed-off-by: Weidong Han <weidong.han@intel.com>
Signed-off-by: Gerd Hoffman <kraxel@redhat.com>
Signed-off-by: Don Dugger <donald.d.dugger@intel.com>

diff --git a/drivers/passthrough/vtd/iommu.c b/drivers/passthrough/vtd/iommu.c
index 988182f..b78b80c 100644
--- a/drivers/passthrough/vtd/iommu.c
+++ b/drivers/passthrough/vtd/iommu.c
@@ -1186,7 +1186,7 @@ static int domain_context_mapping(struct domain *domain, u8 bus, u8 devfn)
     int ret = 0;
     u16 sec_bus, sub_bus;
     u32 type;
-    u8 secbus;
+    u8 secbus, secdevfn;
 
     drhd = acpi_find_matched_drhd_unit(bus, devfn);
     if ( !drhd )
@@ -1233,10 +1233,12 @@ static int domain_context_mapping(struct domain *domain, u8 bus, u8 devfn)
            break;
 
         secbus = bus;
+        secdevfn = devfn;
         /* dependent devices mapping */
         while ( bus2bridge[bus].map )
         {
             secbus = bus;
+            secdevfn = devfn;
             devfn = bus2bridge[bus].devfn;
             bus = bus2bridge[bus].bus;
             ret = domain_context_mapping_one(domain, drhd->iommu, bus, devfn);
@@ -1244,7 +1246,7 @@ static int domain_context_mapping(struct domain *domain, u8 bus, u8 devfn)
                 return ret;
         }
 
-        if ( secbus != bus )
+        if ( (secbus != bus) && (secdevfn != 0) )
             /*
              * The source-id for transactions on non-PCIe buses seem
              * to originate from devfn=0 on the secondary bus behind
@@ -1310,7 +1312,7 @@ static int domain_context_unmap(struct domain *domain, u8 bus, u8 devfn)
     struct acpi_drhd_unit *drhd;
     int ret = 0;
     u32 type;
-    u8 secbus;
+    u8 secbus, secdevfn;
 
     drhd = acpi_find_matched_drhd_unit(bus, devfn);
     if ( !drhd )
@@ -1339,10 +1341,12 @@ static int domain_context_unmap(struct domain *domain, u8 bus, u8 devfn)
             break;
 
         secbus = bus;
+        secdevfn = devfn;
         /* dependent devices unmapping */
         while ( bus2bridge[bus].map )
         {
             secbus = bus;
+            secdevfn = devfn;
             devfn = bus2bridge[bus].devfn;
             bus = bus2bridge[bus].bus;
             ret = domain_context_unmap_one(domain, drhd->iommu, bus, devfn);
@@ -1350,7 +1354,7 @@ static int domain_context_unmap(struct domain *domain, u8 bus, u8 devfn)
                 return ret;
         }
 
-        if ( bus != secbus )
+        if ( (secbus != bus) && (secdevfn != 0) )
             ret = domain_context_unmap_one(domain, drhd->iommu, secbus, 0);
         break;
 
