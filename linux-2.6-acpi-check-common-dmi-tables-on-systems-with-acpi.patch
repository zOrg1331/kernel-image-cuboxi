From: Andy Gospodarek <gospo@redhat.com>
Date: Fri, 31 Oct 2008 18:11:01 -0400
Subject: [acpi] check common dmi tables on systems with acpi
Message-id: 20081031221100.GB14345@gospo.rdu.redhat.com
O-Subject: [RHEL5.3 PATCH] acpi: make sure to check common dmi tables on systems with acpi
Bugzilla: 469444
RH-Acked-by: Brian Maly <bmaly@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>

I was working with Don on an issue and discovered that systems that
used ACPI were not re-ordering pci devices as we expected.  They were
systems who were listed in the pciprobe_dmi_table, but for some reason
the systems weren't being detected.  I realized that we don't run the
legacy and acpi code on systems with acpi, so I started looking to
find a way to initialize things earlier and make sure we were sorting
devices that need to be sorted.  I discovered that someone did it
quite similar upstream, so I adapted that patch to RHEL since it was
pretty close to what I had done anyway.

commit 0df18ff366853cdf31e5238764ec5c63e6b5a398
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Mon Apr 14 15:40:37 2008 -0700

    x86 PCI: call dmi_check_pciprobe()

I also threw in a fix in pci_acpi_scan_root that I noticed when
compiling.  It crept in with this patch:

commit 103d69a012e98165af4fb5ad3ae3a6881c624de1
Author: Jeff Garzik <jgarzik@redhat.com>
Date:   Thu Aug 28 17:53:07 2008 -0400

    [x86] PCI domain support

This will resolve RHBZ 469444.

diff --git a/arch/i386/pci/acpi.c b/arch/i386/pci/acpi.c
index 5bf20fa..42cddcf 100644
--- a/arch/i386/pci/acpi.c
+++ b/arch/i386/pci/acpi.c
@@ -191,10 +191,10 @@ struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int do
 {
 	struct pci_bus *bus;
 	struct pci_sysdata *sd;
-	dmi_check_system(acpi_pciprobe_dmi_table);
-
 	int pxm;
 
+	dmi_check_system(acpi_pciprobe_dmi_table);
+
 	/* Allocate per-root-bus (not per bus) arch-specific data.
 	 * TODO: leak; this memory is never freed.
 	 * It's arguable whether it's worth the trouble to care.
diff --git a/arch/i386/pci/common.c b/arch/i386/pci/common.c
index a92da29..f49b5b0 100644
--- a/arch/i386/pci/common.c
+++ b/arch/i386/pci/common.c
@@ -368,13 +368,16 @@ static struct dmi_system_id __devinitdata pciprobe_dmi_table[] = {
 	{}
 };
 
+void __init dmi_check_pciprobe(void)
+{
+	dmi_check_system(pciprobe_dmi_table);
+}
+
 struct pci_bus * __devinit pcibios_scan_root(int busnum)
 {
 	struct pci_bus *bus = NULL;
 	struct pci_sysdata *sd;
 
-	dmi_check_system(pciprobe_dmi_table);
-
 	while ((bus = pci_find_next_bus(bus)) != NULL) {
 		if (bus->number == busnum) {
 			/* Already scanned */
diff --git a/arch/i386/pci/init.c b/arch/i386/pci/init.c
index 7c611ec..816b841 100644
--- a/arch/i386/pci/init.c
+++ b/arch/i386/pci/init.c
@@ -9,6 +9,8 @@ static __init int pci_access_init(void)
 #ifdef CONFIG_PCI_MMCONFIG
 	pci_mmcfg_init();
 #endif
+	dmi_check_pciprobe();
+
 	if (raw_pci_ops)
 		return 0;
 
diff --git a/arch/i386/pci/pci.h b/arch/i386/pci/pci.h
index 932f39e..2c3ac48 100644
--- a/arch/i386/pci/pci.h
+++ b/arch/i386/pci/pci.h
@@ -40,6 +40,8 @@ enum pci_bf_sort_state {
        pci_dmi_bf,
 };
 
+extern void __init dmi_check_pciprobe(void);
+
 extern struct pci_ops pci_legacy_ops; 	/* direct.c */
 
 /* pci-i386.c */
