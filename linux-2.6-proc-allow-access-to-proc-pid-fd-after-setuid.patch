From: Danny Feng <dfeng@redhat.com>
Date: Mon, 6 Sep 2010 10:22:35 -0400
Subject: [proc] allow access to /proc/$PID/fd after setuid
Message-id: <20100906102235.4761.22735.sendpatchset@danny.redhat>
Patchwork-id: 28158
O-Subject: [PATCH RHEL5] Allow access to /proc/$PID/fd after setuid()
Bugzilla: 617707
RH-Acked-by: Jiri Olsa <jolsa@redhat.com>

Backport of:

commit 8948e11f450e6189a79e47d6051c3d5a0b98e3f3
Author: Alexey Dobriyan <adobriyan@openvz.org>
Date:   Tue May 8 00:23:35 2007 -0700

    Allow access to /proc/$PID/fd after setuid()

    /proc/$PID/fd has r-x------ permissions, so if process does setuid(), it
    will not be able to access /proc/*/fd/. This breaks fstatat() emulation
    in glibc.

    open("foo", O_RDONLY|O_DIRECTORY)       = 4
    setuid32(65534)                         = 0
    stat64("/proc/self/fd/4/bar", 0xbfafb298) = -1 EACCES (Permission denied)

    Signed-off-by: Alexey Dobriyan <adobriyan@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Ulrich Drepper <drepper@redhat.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Acked-By: Kirill Korotaev <dev@openvz.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Resolves bz617707
Brew build #: 2736454

diff --git a/fs/proc/base.c b/fs/proc/base.c
index 5581604..6c0bff6 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1933,10 +1933,28 @@ static struct file_operations proc_task_operations = {
 };
 
 /*
+ * /proc/pid/fd needs a special permission handler so that a process can still
+ * access /proc/self/fd after it has executed a setuid().
+ */
+static int proc_fd_permission(struct inode *inode, int mask,
+			       struct nameidata *nd)
+{
+	int rv;
+
+	rv = generic_permission(inode, mask, NULL);
+	if (rv == 0)
+		return 0;
+	if (task_pid(current) == proc_pid(inode))
+		rv = 0;
+	return rv;
+}
+
+/*
  * proc directories can do almost nothing..
  */
 static struct inode_operations proc_fd_inode_operations = {
 	.lookup		= proc_lookupfd,
+	.permission	= proc_fd_permission,
 	.setattr	= proc_setattr,
 };
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 53683be..38981f6 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1498,6 +1498,11 @@ static inline int has_group_leader_pid(struct task_struct *p)
 	return p->pid == p->tgid;
 }
 
+static inline struct pid *task_pid(struct task_struct *task)
+{
+        return task->pids[PIDTYPE_PID].pid;
+}
+
 static inline struct task_struct *next_thread(const struct task_struct *p)
 {
 	return list_entry(rcu_dereference(p->thread_group.next),
